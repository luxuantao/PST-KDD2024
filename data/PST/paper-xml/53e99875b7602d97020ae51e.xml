<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">HMQV: A High-Performance Secure Diffie-Hellman Protocol *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2005-07-05">July 5, 2005</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
							<email>hugo@ee.technion.ac.il</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM T.J.Watson Research Center</orgName>
								<address>
									<postBox>PO Box 704</postBox>
									<postCode>10598</postCode>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">HMQV: A High-Performance Secure Diffie-Hellman Protocol *</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2005-07-05">July 5, 2005</date>
						</imprint>
					</monogr>
					<idno type="MD5">A568E04460745BAC369269F4FBB28440</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The MQV protocol of Law, Menezes, Qu, Solinas and Vanstone is possibly the most efficient of all known authenticated Diffie-Hellman protocols that use public-key authentication. In addition to great performance, the protocol has been designed to achieve a remarkable list of security properties. As a result MQV has been widely standardized, and has recently been chosen by the NSA as the key exchange mechanism underlying "the next generation cryptography to protect US government information".</p><p>One question that has not been settled so far is whether the protocol can be proven secure in a rigorous model of key-exchange security. In order to provide an answer to this question we analyze the MQV protocol in the Canetti-Krawczyk model of key exchange. Unfortunately, we show that MQV fails to a variety of attacks in this model that invalidate its basic security as well as many of its stated security goals. On the basis of these findings, we present HMQV, a carefully designed variant of MQV, that provides the same superb performance and functionality of the original protocol but for which all the MQV's security goals can be formally proved to hold in the random oracle model under the computational Diffie-Hellman assumption.</p><p>We base the design and proof of HMQV on a new form of "challenge-response signatures", derived from the Schnorr identification scheme, that have the property that both the challenger and signer can compute the same signature; the former by having chosen the challenge and the latter by knowing the private signature key.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Revision. In http://eprint.iacr.org/2005/205, Menezes <ref type="bibr" target="#b30">[32]</ref> describes some shortcomings in our analysis that lead to the need for a prime-order verification of public DH values in the protocol. Some of Menezes's claims are correct and some other are not. We keep the originally posted paper here but add a Preface section (preceding the introduction) that briefly explains these findings and their implications to our results. In essence, the provability of HMQV and its security superiority relative to MQV remain valid; even computation-wise, after adding the verification steps where needed, HMQV is as efficient as (and in some cases even more efficient than) MQV.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Preface</head><p>Recently, Menezes <ref type="bibr" target="#b30">[32]</ref> has claimed that contrary to what is stated in this paper the proven security of HMQV depends on the execution of an explicit verification that DH public values belong to the prime-order group G used by the protocol (below we refer to these tests as G-tests). Menezes's claim is not true for the core HMQV protocol as specified in Section 5.1 and proven in Sections 5 and 6. However, G-tests are needed when requiring that the protocol remain secure even when ephemeral exponents are revealed (Section 7. <ref type="bibr">1)</ref> and for the one-pass protocol of Section 9.</p><p>The reason that G-tests are not required for the basic security of HMQV is that, as stated in this paper, the security of XCR signatures (Section 4), on which HMQV is based, holds even if DH values are chosen by the attacker as arbitrary elements of a supergroup G that contains G. In particular, Menezes's claim that the proof of XCR signatures is flawed is incorrect. On the other hand, he is correct in that the proof of HCR signatures (Lemma <ref type="bibr" target="#b25">27)</ref> implicitly assumes that the challenge X lies in the subgroup G. As a consequence, when applying HCR signatures in the context of HMQV one must require that public DH values (static and ephemeral) be tested for membership in G. Specifically, this is needed for the case in which ephemeral DH exponents are kept in the session state (and then vulnerable to state-reveal queries) as in Section 7 and for the one-pass protocol of <ref type="bibr">Section 9.</ref> This all boils down to the following conclusions. When using the one-pass protocol one should always perform G-tests. When running the 2-message or 3-message HMQV protocol one can dispense completely with these tests but then the protocol may become insecure (this depends on the order of the supergroup G ) if secret ephemeral exponents are revealed. Thus, if one wants to ensure security in the presence of the disclosure of ephemeral exponents then G-tests need to be required. This provides a clear performance-security trade-off: Perform G-tests and get a stronger security assurance, or do not perform these tests but make sure to protect your ephemeral exponents as well as your private key (such a protection is assumed, for example, for DSA-like signatures).</p><p>Finally, when compared to MQV, HMQV retains all the security advantages stated and proven in this paper. HMQV is also superior to MQV in performance in cases that group membership tests are not required and is otherwise of the same efficiency as MQV (in MQV an exponentiation whose cost is equivalent to a G-test is always performed).</p><p>A personal perspective. I would like to thank Alfred Menezes for identifying the oversight in the HCR proof and the need for group membership verification in the one-pass protocol. At the same time, I must strongly disagree with the attempt in <ref type="bibr" target="#b30">[32]</ref> to discredit the effort of the cryptographic community dedicated to improving our understanding and design of protocols. True, we make mistakes (and I do not justify my own); and proofs (even if correct) are never stronger than the model and assumptions they are based on. But with all its imperfection, this form of analysis is an essential tool for gaining confidence in the soundness of a cryptographic design. Moreover, as clearly shown here, the proof process itself serves as a guide in choosing the right design elements.</p><p>At a time when we demand the best (almost perfect) security from basic encryption and hash functions, and having witnessed the effects of initially-mild attacks, we can only hope that the applied-cryptography community and its representing standard bodies will see formal analysis as a requirement, and main source of confidence, when adopting protocols for wide use. These analyses can (and must) be verified by the community at large (in contrast, ad-hoc designs do not even provide the "luxury" of judging well-defined security properties). This is all the more significant in the case of a protocol such as MQV which is not only intended for wide commercial use but also to protect "classified or mission critical national security information" <ref type="bibr" target="#b34">[36]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The classic Diffie-Hellman (DH) key-exchange protocol (see Figure <ref type="figure" target="#fig_0">1</ref>) that marked the birth of modern cryptography has since been one of the main pillars of both theory and practice of cryptography. While the basic protocol as originally proposed is believed to be secure against an eavesdropping-only attacker, the quest for an "authenticated Diffie-Hellman" protocol that resists active, man-in-the-middle, attacks has resulted in innumerable ad-hoc proposals, many of which have been broken or shown to suffer from serious weaknesses. Fortunately, with the development of rigorous security models for key exchange in the last years, we are now in a much better position to judge the security of these protocols as well as to develop designs that provably withstand realistic active attacks. In addition to the need for sound security, the many practical applications of key exchange have driven designers to improve on the performance cost associated with authentication mechanisms, especially those based on public key. One ambitious line of investigation, initiated by Matsumoto, Takashima and Imai in 1986 <ref type="bibr" target="#b28">[30]</ref>, is to design DH protocols whose communication is identical to the basic DH protocol (i.e., no explicit authentication added except for the possible transmission of PK certificates), yet they are implicitly authenticated by the sole ability of the parties to compute the resultant session key (i.e., rather than agreeing on the key g xy , the parties would agree on a key that combines g x , g y with their public/private keys). Not only can this approach generate protocols that are very efficient communication-wise, but the combination of authentication with the key derivation procedure can potentially result in significant computational savings. For these reasons, several of these "implicitly authenticated" protocols have been standardized by major national and international security standards. Of these protocols, the most famous, most efficient and most standardized is the MQV protocol of Law, Menezes, Qu, Solinas and Vanstone <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b27">29]</ref>. This protocol has been standardized by many organizations, e.g. <ref type="bibr">[2,</ref><ref type="bibr">3,</ref><ref type="bibr">20,</ref><ref type="bibr" target="#b19">21,</ref><ref type="bibr" target="#b33">35]</ref>, and has recently been announced by the US National Security Agency (NSA) as the key exchange mechanism underlying "the next generation cryptography to protect US government information" (which includes the protection of "classified or mission critical national security information") <ref type="bibr" target="#b34">[36]</ref>. Indeed, MQV appears to be a remarkable protocol that not only is the most efficient and versatile authenticated DH protocol in existence, but it has also been designed to satisfy an impressive array of security goals.</p><p>Yet, in spite of its attractiveness and success, MQV has so far eluded any formal analysis in a well-defined model of key exchange. The present work was initially motivated by the desire to provide such an analysis. Our findings, however, have been disappointing: we found that when formally studied virtually none of the stated MQV goals can be shown to hold (specifically, we carried this study in the computational key exchange model of Canetti and Krawczyk <ref type="bibr" target="#b10">[11]</ref>). This raises clear concerns about the security of the protocol and triggers a natural question: Do we have a replacement for MQV with the same superb performance and versatility but for which the MQV security goals can be guaranteed in a well analyzed, provable way?</p><p>The main contribution of this paper is in identifying the various analytical shortcomings of the MQV design and proposing a "hashed variant" of the protocol, which we call HMQV, that provides the same (almost optimal) performance of MQV but also delivers, in a provable way, the original security goals of MQV (and even more).</p><p>Note on groups and notation. All the protocols and operations discussed in this paper assume a cyclic group G of prime order q generated by a generator g. We denote by |q| the bit length of q (i.e., |q| = log 2 q ), and use this quantity as an implicit security parameter. The parameters G, g and q are assumed to be fixed and known in advance to the parties (this is usually the case in practice, e.g., <ref type="bibr" target="#b18">[19]</ref>; alternatively, one could include these values in certificates, etc.). We use the multiplicative representation of group operations but our treatment is equally applicable to additive (prime order) groups such as elliptic curves. In our protocols, public keys (denoted by upper case letters) are elements in the group G, and the private keys (denoted by the corresponding lower case letters) are elements in Z q . For example, to a public key A = g a corresponds a private key a. The party having A as its public key will be denoted by Â (in general, the "hat notation" is used to denote the identities of parties in the protocol, possibly including the party's PK certificate). All parties in the protocol are probabilistic polynomial-time machines, including the attacker. The latter is denoted by M (where M stands for "malicious" or, paraphrasing the Alice and Bob tradition, M may stand for "Malice" or "Mob"). The communication in the MQV protocol is identical to the basic unauthenticated DH protocol depicted in Figure <ref type="figure" target="#fig_0">1</ref> except that the identities Â, B may include a public-key certificate. The computation of the session key is shown in Figure <ref type="figure" target="#fig_1">2</ref> where: party Â possesses a long-term private key a ∈ Z q and corresponding public key A = g a , B's private/public key pair is (b, B = g b ), and the ephemeral DH values exchanged in the protocol are X = g x , Y = g y (x, y chosen by Â, B, respectively). The computation of the session key also uses the values d = X and e = Ȳ , where X = 2 + (X mod 2 ) and Ȳ = 2 + (Y mod 2 ) for = |q|/2. The computation of the session key by Â (and similarly by B) involves the exponentiations X = g x , B e , and (Y B e ) x+da . Note, however, that e is of length |q|/2 and hence B e counts as "half exponentiation" (i.e. half the number of modular multiplication relative to a regular exponentiation of g). Also, note that X = g x can be pre-computed. This sums up to an impressive performance: same communication as the basic DH protocol and just half exponentiation more than the basic protocol, i.e. a mere 25% increase in computation to achieve an authenticated exchange! This is significantly better than any of the proven DH protocols that rely on digital signatures or public key encryption for authentication (which involve more expensive operations and increased bandwidth), and is also the most efficient of the implicitly-authenticated DH protocols (the closest are the "Unified Model" protocols <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b21">23]</ref> that require three full exponentiations and offer substantially less security features -see Section 1.6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The MQV Protocol</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Stated Security Goals of the MQV Protocol</head><p>The designers of MQV clearly, albeit informally, stated the security goals behind the MQV design (see <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b27">29]</ref> and related publications). This includes the resistance to a variety of explicit attack strategies such as guessing attacks, impersonation attacks, known-key attacks, key-compromise impersonation (KCI) attacks, and the provision of perfect forward secrecy (PFS).</p><p>While resistance to guessing attacks and impersonation attacks are basic and obvious security requirements, it is worth expanding on the meaning of the other attacks. They all represent realizations of the same fundamental security principle: a good security system is not one that denies the possibility of failures but rather one designed to confine the adverse effects of such failures to the possible minimum.</p><p>In the case of known key attacks, one is concerned with the realistic possibility that some sessionspecific information, such as a session key (or the ephemeral secrets that led to the computation of that key), will leak to an attacker. This can happen in a variety of ways ranging from the simple mishandling of information to a temporary break-in into a computer system or the malicious action of an insider. In this case, one does not expect the exposed session to remain secure, but a welldesigned key-exchange protocol needs to guarantee that such a failure will only affect the specific compromised session. Other sessions, by the same or other parties, should not be endangered by this leakage. The resistance to known-key attacks enforces other basic security principles as well; most importantly, that keys from different sessions should be fully "computationally independent" (i.e., from learning one session key nothing can be implied about the value of other session keys).</p><p>The properties of PFS and KCI resistance are also concerned with limiting the effects of eventual failures, in this case the disclosure of long-term keys. Clearly, the discovery by an attacker M of the long-term authentication key of party Â allows M to impersonate Â and establish its own sessions in the name of Â. A protocol is said to have PFS if session keys established (and deleted from memory) before the compromise of the long-term key cannot be recovered (even with the use of this key). In the case of KCI, the question is whether the knowledge of Â's private key allows M not only to impersonate Â to others but also to impersonate other, uncorrupted, parties to Â. A protocol that prevents this form of "reverse impersonation" is said to resist KCI attacks. In other words, in such a protocol the only way M can take advantage of the knowledge of Â's private key is by active impersonation of Â. Any session established by Â, without being actively controlled by M, remains secure. Resistance to KCI attacks is a very significant security property that has added much to the attractiveness of MQV as it is not offered by other implicitly-authenticated protocols, such as the unified-model protocols of <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b21">23]</ref> (see Section 1. <ref type="bibr">6)</ref>, that use the static DH key g ab for authentication (this key functions as a long-term shared key and hence cannot resist a KCI attack).</p><p>Another important robustness consideration for any Diffie-Hellman protocol is its resistance to the leakage of ephemeral secret DH exponents. While this property has not been addressed directly by the designers of MQV, we consider it a prime security concern and therefore carefully study it in the context of HMQV (see Section 1.4).</p><p>Note: One assurance that MQV is not designed to provide is that a party completing a session with (assumed) peer B knows for certain that this peer computed the session key or even that the peer was alive during this exchange. Such an assurance cannot be provided (at least not for the responder) by any 2-message protocol. More importantly, while this may be a desirable operational property in some applications (in which case the protocol needs to be augmented to three rounds as we discuss later), it is not essential for securing communications as demonstrated in <ref type="bibr" target="#b10">[11]</ref>. The essential security property is that Â is guaranteed that if the assumed peer B is uncorrupted then B is the only party that may possibly know K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Weaknesses of the MQV Protocol</head><p>In spite of the ambitious security goals described above, it turns out that when casting these goals in a well-defined formal setting as the one in <ref type="bibr" target="#b10">[11]</ref>, the MQV protocol falls short of delivering most of its intended security. Here we summarize some of these findings. (See Section 3.2 for a detailed presentation of MQV's shortcomings.)</p><p>Group representation attacks. We first observe that MQV's security is strongly susceptible to the specific way the group elements are represented in the protocol. We show how some representations render the protocol totally insecure. While ordinary group representations may not have such an extreme effect on the security of the protocol, this result shows that any attempt at proving MQV would need to involve restricted group representations. Moreover, the inherent weaknesses of the protocol discussed below show that the protocol cannot be proven secure even for specific groups.</p><p>UKS attacks. We study the vulnerability of the protocol to "unknown key share" (UKS) attacks which were also listed as a security consideration in MQV. A successful UKS attack <ref type="bibr" target="#b15">[16]</ref> is one in which two parties compute the same session key but have different views of who the peer to the exchange was (this attack represents both an authentication failure as well as a vulnerability to known-key attacks). Originally, it was thought that MQV (at least when the registrants of public keys are required to prove "possession" of the corresponding private keys) was immune to these attacks; later it was shown by <ref type="bibr">Kaliski [24]</ref> that even with such proofs of possession MQV fails to a UKS attack. Since then it has been believed that augmenting the protocol with a "key confirmation" step (which adds a third message to the protocol) would solve the problem. Here we show that this is not the case. Indeed, the 3-message variant of MQV is still vulnerable to this form of attack if the attacker can learn ephemeral session-state information for sessions other than the session being attacked.</p><p>Lack of PFS. MQV does not provide Perfect Forward Secrecy (PFS). This, however, is not just a failure of MQV but it's an inherent limitation of implicitly-authenticated 2-message protocols based on public-key authentication (and which do not rely on a previously established shared state between the parties). Indeed no such protocol can provide PFS. We present a generic attack against any such protocol where an active attacker M causes the establishment of a session key K at party Â with peer B such that a later corruption of B (even after K was erased) allows M to find K. KCI attacks. Since MQV is susceptible to basic authentication attacks even when the private key of the victim is not known to the attacker, then KCI resistance cannot be satisfied. Yet, it is interesting to see explicit KCI attacks that take advantage of the knowledge of such private key. We show such an attack against MQV in the case that the attacker has access to the ephemeral values σ from which the session key is computed. This serves to motivate two design principles in HMQV: (i) the essential role of the hashing of σ for session key derivation (in MQV this hashing is recommended but separated from the core specification of the protocol <ref type="bibr" target="#b27">[29]</ref>) <ref type="foot" target="#foot_0">1</ref> ; and (ii) the care required in handling ephemeral information (especially when an attacker may access such information).</p><p>Prime-order checks. Our description in Figure <ref type="figure" target="#fig_1">2</ref> omitted an element from the session-key computation in MQV: In case where the group G generated by g is a subgroup of a larger group G (which is the case in typical mod p and elliptic curve groups), MQV specifies that the key be computed as K = H(σ) for σ = (σ Â) h = (σ B ) h (σ Â and σ B are defined in Figure <ref type="figure" target="#fig_1">2</ref>) where h denotes the co-factor |G |/|G|. This measure is used to ensure that the value σ belong to the group G, and has been added to MQV as a safeguard against potential attacks resulting from the lack of explicit authentication of the DH values, e.g., small-group attacks. We note, however, that this addition is of no help against the vulnerabilities mentioned above (and as we will see is not needed to provide security in HMQV). Moreover, lacking a proof that the above counter-measure really works, several standards defining MQV, as well as various descriptions of the protocol in the literature, often specify (or at least recommend) that the parties to MQV explicitly check that the DH value presented by the peer is of prime order q. This adds a costly extra exponentiation to each peer and takes significantly from the almost-optimal performance of MQV. As we will see, HMQV "provably dispenses" of the need for this costly check.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">The HMQV Protocol and its Proven Security</head><p>Description of the HMQV Protocol. The HMQV protocol ("H" is for Hash) is a simple but powerful variant of MQV. As in MQV, its communication is identical to the basic DH exchange (Figure <ref type="figure" target="#fig_0">1</ref>) with the possible addition of certificates. The computation of the session key, shown in Figure <ref type="figure" target="#fig_1">2</ref>, differs from MQV's in the computation of the values d and e which involves the hashing of the party's own DH value and the peer's identity. The output of this hash is = |q|/2 bits. In addition, HMQV mandates the hashing of the values σ Â = σ B into k-bit keys where k is the length of the desired session key. We denote the hash function with bits of output by H and the one with k bits by H. In practice the same hash function can be used with different output lengths. (As a mnemonic, the bar in H indicates that the output of the function is used as an exponent).</p><p>From this description one can see that HMQV preserves the outstanding performance of MQV (both in terms of communication and computation). At the same time, HMQV overcomes all the mentioned security shortcomings of MQV to the largest possible extent in a 2-message protocol. We prove that in the random oracle model <ref type="bibr">[5]</ref>, and under the Computational Diffie-Hellman (CDH) assumption <ref type="bibr" target="#b14">[15]</ref>, the protocol is secure in the Canetti-Krawczyk security model <ref type="bibr" target="#b10">[11]</ref>. In particular, this establishes the security of the protocol against impersonation attacks, known-key attacks, and UKS attacks. We also prove the resistance of HMQV to KCI attacks (which we formally define) under the same assumptions.</p><p>Furthermore, HMQV enjoys an additional performance advantage in that it provably dispenses of the need for costly prime-order tests on the DH values transmitted in the protocol. Indeed, our proof shows that the only way an attacker can benefit from the choice of rogue DH values is by choosing these to be zero, and thus a simple non-zero check is all is required (hence, there is no need for prime-order tests or for the co-factor h used in MQV).</p><p>Regarding forward secrecy, we said earlier that PFS cannot be achieved by any implicitly authenticated 2-message protocol, including HMQV. Yet, the following limited forward secrecy property holds for HMQV: any session key established without the active intervention of the attacker (except for eavesdropping the communication) is guaranteed to be irrecoverable by the attacker once the session key is erased from memory. This is the case even if the attacker knew the private keys of both peers when the session was established.</p><p>For applications that require full PFS we present a 3-message variant of HMQV which adds a third message and a MAC computation by each party (see Figure <ref type="figure">7</ref> in page 55) and guarantees full PFS. This 3-message protocol, called HMQV-C, also provides "key confirmation" to both parties, i.e., the assurance that the assumed peer indeed participated in the protocol and that it computed the same session key. Another advantage of HMQV-C is that it can be proven secure in the stronger universally composable (UC) KE security model of <ref type="bibr" target="#b12">[13]</ref> which ensures the security of keyexchange protocols when run concurrently with other applications. (HMQV satisfies the weaker "relaxed UC" definition from <ref type="bibr" target="#b12">[13]</ref>.) We note that while HMQV-C requires an extra message, its computational cost is essentially the same as HMQV as the MAC computation is negligible relative to the exponentiation cost. On the other hand, <ref type="bibr" target="#b21">[23]</ref> note that 2-message symmetric protocols such as the basic HMQV allow for simultaneous initiation of a session by both Â and B, a desirable property in some network settings.</p><p>Another variant of HMQV is a one-pass authenticated key-exchange protocol in which Â sends a single message to B after which both parties share a secret key. We show also this protocol to be secure (under CDH and in the random oracle model) in a security model adapted from <ref type="bibr" target="#b10">[11]</ref> to one-pass protocols (the only difference is that we cannot prevent the adversarial replay of a message from Â to B and, of course, cannot provide PFS). In particular, this one-pass protocol provides the functionality of public-key based deniable authentication as well as an authenticated CCA encryption scheme (in the random oracle model) in a more efficient way than existing alternatives.</p><p>An important security consideration not discussed by the authors of MQV is the resilience of the protocol to the disclosure of the secret exponent x corresponding to an ephemeral (session-specific) DH value X = g x . This is a prime concern for any Diffie-Hellman protocol since many applications will boost protocol performance by pre-computing ephemeral pairs (x, X = g x ) for later use in the protocol (this may apply to low-power devices as well as to high-volume servers). In this case, however, these stored pairs are more vulnerable to leakage than long-term static secrets (the latter may be stored in a hardware-protected area while the ephemeral pairs will be typically stored on disk and hence more available to a temporary break or to a malicious user of the system). We prove that HMQV's security is preserved even in the presence of the leakage of ephemeral secret DH exponents (see Section 1.6 for comparison to other work). For this property (and only for it) we need to resort to two strong assumptions: Gap Diffie-Hellman <ref type="bibr" target="#b35">[37]</ref> and Knowledge of Exponent (KEA1) <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr">4]</ref>; in return we get a guarantee that not even the session key computed using the exposed exponent is compromised by this leakage.</p><p>We end by noting an important property of our analysis: all results in this paper hold under a strong adversarial model in which the attacker is allowed to register arbitrary public key for all corrupted parties (and at any time during the protocol). This may include a public key that is identical, or related, to the public key of another (possibly uncorrupted) party; in particular, the attacker may not know the private key corresponding to the public key it chose. In practical terms this means that the security of our protocols does not depend on the certification authority requiring registrants of public keys to prove knowledge of the corresponding private keys. This is important since in many practical settings such "proofs of possession" are not required or performed by the CA (for contrast, see the comparison with <ref type="bibr" target="#b21">[23]</ref> in Section 1.6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Challenge-Response Signatures</head><p>The main technical tool that we develop in order to prove the security of HMQV is a new form of interactive signatures that we call challenge-response signatures and which we implement on the basis of a (new) variant of the Schnorr's identification scheme. By applying the Fiat-Shamir methodology to this scheme (and using the proof techniques of Pointcheval-Stern <ref type="bibr" target="#b36">[38]</ref>) we obtain challenge-response signatures, named XCR, that are secure in the random oracle model (under the CDH assumption) and have the property that both verifier and signer can compute the same signature, the former by knowing the challenge and the latter by knowing the private signature key. The HMQV protocol uses these signatures in an essential way both for the purpose of authentication (of the DH values and the peer identity) as well as for session-key computation. XCR signatures (and their "dual version", called DCR) provide for a natural interpretation of the ideas underlying the MQV design and serve as the basis (technical and conceptual) to the design of HMQV.</p><p>In addition, XCR signatures may have applications beyond the HMQV protocol. They do not provide the classical functionality of digital signatures since they are verifier-specific and nontransferable (i.e., cannot be used for non-repudiation purposes). On the other hand, in interactive settings they provide "deniable authentication", an important property for some applications including key exchange. Moreover, for such settings, hashed XCR signatures (denoted HCR) constitute an attractive alternative to DSA signatures. As with DSA, HCR signatures can be implemented over any dlog-based system, including elliptic curves. However, in contrast to DSA, their security is not compromised by the disclosure of ephemeral information (recall that in DSA, the disclosure of a single ephemeral exponent renders the signature scheme totally insecure by revealing the private signing key).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">Related Work.</head><p>Implicitly-authenticated DH protocols were first studied in the work of Matsumoto, Takashima and Imai <ref type="bibr" target="#b28">[30]</ref> in 1986. Since then this line of research generated many protocols, many of which suffer from various weaknesses. See <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8]</ref> for some surveys which also include the discussion of desirable security goals for these protocols as well as some of the shortcomings of specific proposals. Two works that study such protocols in a formal model are those of Blake-Wilson et al <ref type="bibr" target="#b7">[8]</ref> and Jeong et al <ref type="bibr" target="#b21">[23]</ref>. They both treat very similar protocols referred to in the literature as the "unified model". In these protocols, parties Â and B use their public keys g a , g b to generate a shared key g ab that they then use to authenticate a DH exchange (c.f., <ref type="bibr" target="#b24">[26]</ref>).</p><p>The variant studied in <ref type="bibr" target="#b7">[8]</ref> is shown to be open to interleaving and known-key attacks and hence insecure (unfortunately, this variant has been widely standardized <ref type="bibr">[2,</ref><ref type="bibr">3,</ref><ref type="bibr">20]</ref>). One main flaw of this protocol is that it does not explicitly authenticate (or includes under the key derivation hashing) the ephemeral DH values exchanged by the parties. <ref type="bibr" target="#b21">[23]</ref> studies the version in which the DH values are included under the key derivation and shows this protocol to be secure in the random oracle model. However, the protocol does not provide resistance to KCI and is open to a UKS attack if the CA does not enforce a proof-of-posession check at time of certificate issuance. <ref type="foot" target="#foot_1">2</ref> Lack of KCI is one aspect of a more substantial drawback of these protocols, namely, the use of the keys g ab as long-term shared keys between the parties; these keys become particularly vulnerable when cached for efficiency.</p><p>In contrast, HMQV is a significantly stronger protocol which, in particular, does not use g ab as a long-term key, does not require (even for efficiency) to cache this value, and even if the value of g ab is ever learned by the attacker it is of no help for impersonating either Â or B, or for learning anything about their session keys. On top of all its security advantages (which hold without relying on proofs of possession performed by CAs or prime-order tests performed by the parties), HMQV is more efficient than the unified model protocols that take 3 exponentiations per-party.</p><p>Finally, we mention the works of Shoup <ref type="bibr" target="#b39">[41]</ref> and Jeong et al <ref type="bibr" target="#b21">[23]</ref> that present 2-message authenticated DH exchanges with explicit authentication (via signatures and MAC, respectively) that they show to satisfy the security definitions from <ref type="bibr" target="#b39">[41,</ref><ref type="bibr">6]</ref> in the standard (non-random-oracle) model. In these protocols, however, it is sufficient for the attacker to learn a single ephemeral exponent x of a DH value g x exchanged between parties Â and B to be able to impersonate Â to B indefinitely, and without ever having to learn Â's or B's private keys. This is a serious security weakness which violates the basic principle that the disclosure of ephemeral session-specific information should not compromise other sessions. The reason that these protocols could be proven secure in <ref type="bibr" target="#b39">[41,</ref><ref type="bibr" target="#b21">23]</ref> is that the models of key exchange security considered in these works do not allow the attacker to find any session-specific information beyond the session key itself. The above vulnerability, however, indicates that such models are insufficient to capture some realistic attack scenarios. In contrast, the model of <ref type="bibr" target="#b10">[11]</ref>, used as the basis for our analysis, captures such attacks via state-reveal queries (see <ref type="bibr">Section 2)</ref>.</p><p>See also Section 3.1 for some more detail on the protocols discussed above, and the concluding remarks in Section 10 for additional comparison to other work.</p><p>Organization The paper is organized in the following sections: Section 2 provides a succinct description of the model of secure key-exchange protocols <ref type="bibr" target="#b10">[11]</ref> on which all of our analysis work is based (this includes much of the security terminology used in subsequent sections). Section 3 provides background on the MQV protocol as needed for understanding its design, demonstrating its security shortcomings, and motivating the design of HMQV. The presentation in this section is informal and technically "light". Section 4 introduces XCR and DCR signatures which form the basis for our analysis of HMQV (and may be of independent interest), and proves their security (in the random oracle model under the CDH assumption). Section 5 proves the security of HMQV in the formal model of <ref type="bibr" target="#b10">[11]</ref> by showing how a successful attacker can be converted into an efficient forger against XCR signatures. Section 6 discusses, defines and proves additional security properties of HMQV not covered by the basic model of <ref type="bibr" target="#b10">[11]</ref>. Section 7 is dedicated to analyze the resistance of HMQV to the leakage of ephemeral DH exponents for which it introduces and analyzes "hashed XCR signatures (HCR)". Section 8 presents the 3-message HMQV-C protocol and its added security features. Section 9 presents the one-pass HMQV protocol and its security properties. We end the paper with concluding remarks in Section 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Security Model for Key-Exchange Protocols</head><p>This section presents an abridged description of the Canetti-Krawczyk security model for keyexchange protocols <ref type="bibr" target="#b10">[11]</ref> on which all the analysis work in this paper is based. The reader familiar with this model can skip this section. On the other hand, please consult <ref type="bibr" target="#b10">[11]</ref> for complete details.</p><p>A key-exchange (KE) protocol is run in a network of interconnected parties where each party can be activated to run an instance of the protocol called a session. Within a session a party can be activated to initiate the session or to respond to an incoming message. As a result of these activations, and according to the specification of the protocol, the party creates and maintains a session state, generates outgoing messages, and eventually completes the session by outputting a session key and erasing the session state. A session may also be aborted without generating a session key. A KE session is associated with its holder or owner (the party at which the session exists), a peer (the party with which the session key is intended to be established), and a session identifier. We will simplify the presentation here by making two assumptions (consistent with the model of <ref type="bibr" target="#b10">[11]</ref>): (i) the activation of a session at a party always specifies the name of the intended peer (this is called the "pre-specified peer model" in <ref type="bibr" target="#b11">[12]</ref>); and (ii) the session identifier is a quadruple ( Â, B, Out, <ref type="bibr">In)</ref> where Â is the identity of the holder of the session, B the peer, Out the outgoing messages in the session, and In the incoming messages. In particular, in the case of MQV and HMQV this results in an identifier of the form ( Â, B, X, Y ) where X is the outgoing DH value and Y the incoming DH value to the session. The peer that sends the first message in a session is called the initiator and the other the responder. We usually denote the peers to a session by Â and B; either one may act as initiator or responder. The session ( B, Â, Y, X) (if it exists) is said to be matching to the session ( Â, B, X, Y ). As we'll see, matching sessions play a fundamental role in the definition of security.</p><p>In addition, we assume that each party owns a long-term pair of private and public keys, and that other parties can verify the authentic binding between an identity and a public key. For concreteness, we will assume that this binding assurance is provided by a certification authority (CA) which is only trusted to correctly verify the identity of the registrant of a public key before issuing the certificate that binds this identity and the public key. No other actions by the CA are required or assumed; in particular, we make no assumption on whether the CA requires a proof-ofpossession of the private key from a registrant of a public key, and we do not assume any specific checks on the value of a public key. In particular, a corrupted party can choose (at any point during the protocol) to register any public key of its choice, including public keys equal or related to keys of other parties in the system. In this paper, a public key will always be a static Diffie-Hellman value and the private key its secret exponent.</p><p>Attacker Model. The attacker is modeled to capture realistic attack capabilities in open networks, including the control of communication links and the access to some of the secret information used or generated in the protocol. The basic principle is that since security breaches happen in practice (e.g., via break-ins, mishandling of information, insider attacks, cryptanalysis), a well-designed protocol needs to confine the damage of such breaches to a minimum. In particular, the leakage of session-specific ephemeral secret information should have no adverse effect on the security of any other non-matching sessions.</p><p>The attacker, denoted M, is an active "man-in-the-middle" adversary with full control of the communication links between parties. M can intercept and modify messages sent over these links, it can delay or prevent their delivery, inject its own messages, interleave messages from different sessions, etc. (Formally, it is M to whom parties hand their outgoing messages for delivery.) M also schedules all session activations and session-message delivery. In addition, in order to model potential disclosure of secret information, the attacker is allowed access to secret information via session exposure attacks (a.k.a. known-key attacks) of three types: state-reveal queries, sessionkey queries, and party corruption. A state-reveal query is directed at a single session while still incomplete (i.e., before outputting the session key) and its result is that the attacker learns the session state for that particular session (which may include, for example, the secret exponent of an ephemeral DH value but not the long-term private key used across all sessions at the party). A session-key query can be performed against an individual session after completion and the result is that the attacker learns the corresponding session-key key either via usage of the Finally, party corruption means that the attacker learns all information in the memory of that party (including the long-term private key of the party as well all session states and session keys stored at the party); in addition, from the moment a party is corrupted all its actions may be controlled by the attacker. Indeed, note that the knowledge of the private key allows the attacker to impersonate the party at will <ref type="foot" target="#foot_2">3</ref> .</p><p>Sessions against which any one of the above attacks is performed (including sessions compromised via party corruption) are called exposed. In addition, a session is also called exposed if the matching session has been exposed (since matching sessions output the same session key, the compromise of one inevitably implies the compromise of the other).</p><p>The security of session keys generated in unexposed sessions is captured via the inability of the attacker M to distinguish the session key of a test session, chosen by M among all complete sessions in the protocol, from a random value. When M chooses the test session it is provided with a value v which is chosen as follows: a random bit b is tossed, if b = 0 then v is the real value of the session key, otherwise v is a random value chosen under the same distribution of session-keys produced by the protocol but independent of the value of the real session key. After receiving v the attacker may continue with the regular actions against the protocol; at the end of its run M outputs a bit b . The attacker succeeds in its distinguishing attack if (1) the test session is not exposed, and (2) the probability that b = b is significantly larger than 1/2.</p><p>Definition 1 <ref type="bibr" target="#b10">[11]</ref> A polynomial-time attacker with the above capabilities is called a KE-attacker.</p><p>A key-exchange protocol π is called secure if for all KE-attackers M running against π it holds:</p><p>1. If two uncorrupted parties complete matching sessions in a run of protocol π under attacker M then, except for a negligible probability, the session key output in these sessions is the same.</p><p>2. M succeeds (in its test-session distinguishing attack) with probability not more that 1/2 plus a negligible fraction.</p><p>This definition captures the essential security properties of a KE protocol; in particular, <ref type="bibr" target="#b10">[11]</ref> show that a KE protocol that is secure in the above sense is sufficient for the most important application of KE protocols, namely, the establishment of secure communication channels between two parties.</p><p>An important property of key-exchange protocols not captured in the above definition is perfect forward secrecy (PFS) <ref type="bibr" target="#b32">[34]</ref>, namely, the assurance that once a session key is erased from its holders memory then the key cannot be learned by the attacker even if the parties are subsequently corrupted. Formally, this is captured in <ref type="bibr" target="#b10">[11]</ref> via the notion of session-key expiration (which represents the erasure of a session key from memory). A key-exchange protocol is said to be secure with PFS if the above definition holds even when the attacker is allowed to corrupt a peer to the test session after the test-session key expired at that peer.</p><p>Additional specific security properties for key-exchange protocols (such as resistance to keycompromise impersonation attacks) are discussed and defined in Sections 3.2 and 6, respectively 3 From MQV to HMQV</p><p>The MQV protocol was proposed ten years ago and much has been written about it in the literature and in the many standards that adopted it. Yet, relatively little rationale has been given for the specific design choices in the protocol. On the other hand, the authors of MQV <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b27">29]</ref> have been very explicit about the specific security goals they set for the protocol. In Section 3.1 we attempt to provide some motivation for the MQV design and its underlying ideas (as we understand them). Then, in Section 3.2, we list the stated security goals of MQV and show that the protocol falls short of fulfilling these goals. Finally, in Section 3.3 we show how the lessons learned from the MQV design are applied to the design of HMQV. In particular, while the basic (elegant!) ideas from MQV, as well as the superb performance of the protocol, have been preserved in HMQV, we show how the latter enjoys a much more robust design that provably delivers the security goals envisioned for, but unattained by, the MQV protocol. This whole section is presented informally for the benefit of the non-specialist, leaving the formal treatment and rigorous analysis for later sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Introduction to MQV</head><p>A first challenge in designing a 2-message key-exchange protocol is to prevent a successful attack based on the replay of the first protocol message. This is problematic since the first message cannot include any form of a session-specific "freshness guarantee" (such as a nonce or a fresh DH value) contributed by the responder. A solution to this problem is to provide freshness via the computation of the session key. Consider, for example, the following 2-message Diffie-Hellman protocol authenticated using digital signatures and adapted from the ISO protocol <ref type="bibr" target="#b20">[22]</ref>.</p><formula xml:id="formula_0">Â Â , B , g x , sig Â(g x , B) - B B , Â , g y , sig B (g y , g x , Â)</formula><p>Note that while the inclusion of g x under the signature of B provides freshness to the authentication by B this safeguard does not exist in Â's message. Yet, the session key, g xy is guaranteed to be fresh (and independent from other session keys) as it is randomized by the fresh y. However, also note that the security of the protocol breaks if the attacker is able to find a single pair (x, g x ) used by Â in a session with B (in which case the attacker also learns sig Â(g x , B) from watching the protocol). This allows the attacker to impersonate Â to B indefinitely (using the same message and its knowledge of x) and without ever having to learn Â's long-term private signature key! This is a serious vulnerability that violates the basic principle that the disclosure of ephemeral session-specific information (e.g., the pair (x, g x )) should not compromise other sessions. This is particularly serious considering that many applications will compute the pairs (x, g x ) off-line and keep them in less protected storage than the long-term signature key.</p><p>Note: As pointed out in Section 1.6, Shoup <ref type="bibr" target="#b39">[41]</ref> presents a proof for the above protocol in a security model that does not allow the attacker to find any session-specific information beyond the session key itself. The above vulnerability, however, indicates that such a model is insufficient to capture some realistic attack scenarios. In contrast, the model from <ref type="bibr" target="#b10">[11]</ref> used here does capture such attacks via state-reveal queries (see Section 2) and, in particular, allows us to prove that such attacks are not possible against HMQV.</p><p>So how can we still design a 2-message protocol such that the authentication in the first message can not be replayed? One solution, put forth in 1986 by Matsumoto, Takashima and Imai <ref type="bibr" target="#b28">[30]</ref>, is to dispense of the explicit authentication of the DH values and instead provide authentication via the derivation of the session key, namely, by computing this key as a function of the sessionspecific ephemeral DH values exchanged in the protocol and the long-term private/public keys of the parties (in this setting public keys are static DH keys). In this way, one preserves the original two messages of the basic DH protocol (Figure <ref type="figure" target="#fig_0">1</ref>) while thwarting man-in-the-middle attacks via the authenticated key derivation.</p><p>A simple instantiation of this idea is to let any pair of parties, Â, B, use their respective public keys g a , g b in order to compute a shared key g ab which can then be combined with the ephemeral DH key g xy for computing the session key. This approach has been termed the "unified model" in the literature and an insecure instantiation of it (in which the session key is computed as the hash of g ab and g xy ) has been extensively standardized <ref type="bibr">[2,</ref><ref type="bibr">3,</ref><ref type="bibr">20]</ref>. As shown in <ref type="bibr" target="#b7">[8]</ref> this protocol falls to known-key and interleaving attacks. A more secure version would also include the ephemeral DH values g x , g y under the hash. <ref type="bibr" target="#b21">[23]</ref> shows this variant to be secure in the random oracle model provided the CA requires each certificate requester to prove knowledge of the corresponding private key. Clearly, the protocol cannot withstand KCI attacks (see Section 1.2) since knowledge of the private key a of Â allows the attacker to impersonate any party to Â. This weakness is inevitable when using g ab as a long-term pairwise shared key. Hence, to provide security against KCI attacks (and other forms of secrecy compromise), as well as to avoid the need to trust the CA with proof of possession protocols, we need to depart from the g ab keys.</p><p>What we are looking for is a way to mix the values A = g a , B = g b , X = g x , Y = g y in the key derivation procedure in such a way that as long as the attacker M does not know both a and x, or both b and y, then M cannot compute the session key. A natural solution is to compute the session key K = g (x+a)(y+b) (which Â and B compute as (Y B) x+a and (XA) y+b , respectively). In this case, if an attacker learns x but not a, it cannot compute K. Yet, the protocol is still insecure as the following simple attack shows. M chooses a value x * ∈ R Z q , computes X * = g x * /A, and sends X * to B as the initial message from Â. B sends Y = g y and computes the session key K = (X * A) y+b . Unfortunately, also M can compute K as (BY ) x * . Note that if we augment the computation of K to K = g (x+da)(y+eb) for constant d, e the attack is still possible. Moreover, the attack works even if we compute the session key as H(K) for any publicly computable function H (even an ideally random function). On the other hand, if we let d, e vary with X, Y (e.g., in a way that the attacker cannot control e and Y , or d and X, separately) the above simple attack may not work. This idea leads to the the design of MQV where d and e are set to X and Ȳ , respectively (recall that X = 2 + (X mod 2 ) and Ȳ = 2 + (Y mod 2 ) for = |q|/2).</p><p>But, is this solution secure? We investigates this question next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Insecurity of MQV</head><p>As said before, the designers of MQV clearly, albeit informally, stated the security goals behind the MQV design (see <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b27">29]</ref> and related publications). Here we examine to what extent the MQV protocol achieves these goals in the context of the key-exchange model described in Section 2. We show that some of the most essential security properties, such as resistance to impersonation and known-key attacks, are not satisfied in general by the protocol. We present explicit attacks against most of the properties intended for MQV (in each attack M succeeds in computing the session key corresponding to an unexposed test session). This stands in strong contrast to HMQV where all these properties are strictly satisfied (see Section 3.3). The presentation here is informal yet some familiarity with the terminology from Section 2 is recommended.</p><p>Before going into the specific goals of MQV, let us point to one property that MQV is not intended to provide, namely, the assurance to a party completing a session that the peer to the exchange has established the corresponding session key or even that the peer was "alive" at the time of the exchange. Moreover, no 2-message protocol, HMQV included, can provide such assurance (at least not for the responder). However, note that such assurance, while desirable in some applications, is not part of the core requirements from a secure key-exchange protocol and, in particular, not ensured by the definition of security from Section 2. What the latter definition ensures is that if a honest party Â established a session key K with an uncorrupted peer B then the only party other than Â that may possibly know the key is B. This suffices, in particular, to ensure the security of the most important application of key-exchange protocols, namely, secure channels <ref type="bibr" target="#b10">[11]</ref>. We expand more on these issues in Section 8 where this property will be added to the protocol at the cost of an extra message.</p><p>Resistance to basic impersonation attacks. A minimal requirement for a secure key-exchange protocol is that the attacker, not knowing the private key of a party Â, should not be able to impersonate Â. This minimal requirement, however, cannot be proven to hold in MQV, at least without resorting to specific assumptions on the representation of group elements. To see this consider any group G (of prime order q) and choose a representation of the elements of G such that the |q|/2 least significant bits of the representation are fixed. In this case, the MQV's session key becomes K = H(σ) where σ = g (x+da)(y+eb) and d = X and e = Ȳ are fixed constants. As shown in Section 3.1, in this case the protocol is open to trivial impersonation attacks (the attack is also possible with non-fixed but low-entropy values d and e). In particular, this shows that no analysis of MQV over general prime-order groups can prove the protocol to be secure. Even if one restricts the groups over which an analysis is carried, the following weaknesses of MQV remain.</p><p>Resistance to UKS attacks. An unknown-key share (UKS) attack (also known by the more informative terms "source-substitution" <ref type="bibr" target="#b32">[34]</ref> or "identity misbinding" <ref type="bibr" target="#b25">[27]</ref> attacks) is a particular form of impersonation attack in which the attacker M interferes with the session establishment between two honest parties Â and B such that at the end of the attack both parties compute the same session key K (which M may not learn), yet while Â is convinced that the key is shared with B, B believes that the peer to the session has been M (here M can be any corrupted party). This attack, first discovered by Diffie, van Oorschot and Wiener <ref type="bibr" target="#b32">[34]</ref>, has since become a basic attack under which key-exchange protocols are validated. One can easily see that the MQV protocol is trivially vulnerable to such an attack if M can register the public key of an honest party Â under its own (i.e., M's) identity. It was suggested, however, that the protocol could resist UKS attacks if one disallowed the registration of arbitrary public keys by the attacker; in particular, if the certification authority required a proof of possession by the registrant of a public key (i.e., a proof of knowledge of the corresponding private key). This belief turned out to be wrong as demonstrated by a clever attack due to Kaliski <ref type="bibr" target="#b22">[24]</ref> showing that a UKS attack against MQV can be carried by M using a public key for which M knows the corresponding private key (in this attack M chooses its public and private keys after seeing Â's initial DH value X). A short description of the attack can be found in Appendix A.</p><p>For detailed discussions of different aspects of UKS attacks (including its practical consequences) see <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b22">24]</ref> and many other works in the area. Here we point to one consequence of the attack when seen in light of the model from Section 2. Since the attack forces the same session key, K, to be computed in two non-matching sessions, ( Â, B, X, Y ) and ( B, M, Y, X), then the attacker can choose the former as its test session and win the distinguishing game (in other words, the protocol falls to a known-key attack). Interestingly, since the publication of Kaliski's attack it has been believed that one way to solve this weakness of MQV was to move to a 3-message protocol in which MQV is augmented with a "key confirmation" step. Specifically, the protocol is augmented with a MAC value mac Km ( B, Â, Y, X) sent in the second message (from B to Â) as well as with a third message in which Â sends mac Km ( Â, B, X, Y ) (here K m is derived from σ = σ A = σ B while the session key is set to another value derived from σ and "computationally independent" from K m ). The idea is that now the above UKS attack fails since B will send mac Km ( B, M, Y, X) while Â expects mac Km ( B, Â, Y, X). This, however, is not the case since the attacker can still break the secrecy of the session ( Â, B, X, Y ). For this, M breaks into the session ( B, M, Y, X) at B, before B sends out the second message, and finds the value of K m ; now M can compute the MAC value mac Km ( B, Â, Y, X) which will convince Â that she was talking to B. Here again the attacker can choose the unexposed test session ( Â, B, X, Y ) and win the distinguishing game.</p><p>Perfect Forward Secrecy (PFS) Informally, a key-exchange protocol is said to have the PFS property if the leakage of the long-term key of a party does not compromise the security of session keys established by that party and erased from memory before the leakage occurred. (See Section 2 for a formal definition.) This is another important security property that ensures damage confinement in the case of secrecy leakages, and a main motivation for the use of Diffie-Hellman key-exchange protocols. PFS has also been an explicit design goal for MQV. However, MQV does not achieve it. To see this consider two uncorrupted parties Â, B. The attacker M chooses x ∈ R Z q and sends X = g x to B pretending it to be an initial message for a session coming from Â. Then, B, acting as responder, chooses y ∈ R Z q , sends Y = g y (supposedly to Â) and completes the session with key K = H((XA X ) y+ Ȳ b ). (Note that the matching session will not be established at Â who did not choose the value X.) Once the session key expires at B, and is removed from memory, the attacker corrupts Â and finds the private key a. It now can compute the key K as H((Y B Ȳ ) x+ Xa ) contradicting the PFS property.</p><p>We note that this form of attack can be carried against any 2-message key-exchange protocol (including HMQV) authenticated via public keys and with no secure shared state previously established between the parties. What can be achieved in a 2-message protocol is a weaker form of forward secrecy in which sessions created without the active involvement of the attacker cannot be recovered after the key expired. While weaker than full PFS this is still an important security feature that we prove to hold in the case of HMQV.</p><p>Resistance to Key-Compromise Impersonation (KCI) attacks. Consider the case in which M has learned the private key a of a party Â. Obviously, M can now impersonate Â to any other party. But even in this situation it is desirable to prevent M from impersonating other (uncorrupted) parties to Â. This property, referred to as resistance to KCI attacks, provides the assurance that sessions established by Â while not being actively controlled by M remain secure even if her private key is learned by M. This feature has been stated as one of the explicit goals of MQV (in particular, one that differentiates MQV from other implicitly-authenticated KE protocols). In the case of MQV the property states that if Â establishes a session s = ( Â, B, X, Y ) where X was chosen by Â (such that M does not know x) and B is an uncorrupted party then the session s must be secure (i.e., M cannot distinguish its session key from random without exposing s or its matching session). Since MQV is susceptible to attacks even when the attacker does not know one of the parties' private key then, strictly speaking, it cannot achieve KCI resistance (for a formal treatment of KCI see Section <ref type="figure">6</ref>). Yet, it is interesting to examine direct KCI attacks against the protocol. We show such an attack in the case that M has access to the values σ Â or σ B (remember that the session key is obtained by hashing these values). This demonstrates two important design and specification issues arising from our analysis: (i) The essential contribution of the hashing of the σ values to the security of the protocol (see footnote <ref type="bibr">1)</ref>; and (ii) The sensitivity of the protocol to the disclosure of ephemeral state information (e.g., if the computation of σ, which involves the party's private key, is performed in a secure module, then this module should output H(σ) rather than σ itself).</p><p>Let Â be a party for whom M knows the private key a, and B be an uncorrupted party. Assume that Â initiates a session with B sending the DH value X (truly chosen by Â not by M). M intercepts the message and sends it to B but this time with the sender being a party Â = Â for which M knows the private key a ( Â can be M itself or any corrupted party). When B responds to Â with a DH value Y , M forwards this message to Â. In this case, Â and B compute σ Â = (Y B Ȳ ) x+ Xa and σ B = (XA X ) y+ Ȳ b , respectively. Now, if M learns the value σ B it can use its knowledge of a and a to compute ) , and from it the session key of session ( Â, B, X, Y ). In other words, the knowledge of a allows M to break the unexposed session ( Â, B, X, Y ) (this session is unexposed since the exposed session ( B, Â , Y, X) is non-matching) even though M does not know x and B is uncorrupted. This represents a successful KCI attack against MQV. Furthermore, the same attack (which, as said, depends on the ability of the attacker to learn the value of σ) is possible even against the stronger 3-message variant of MQV with key confirmation.</p><formula xml:id="formula_1">σ Â = σ B • (Y B Ȳ ) X(a-a</formula><p>Prime-order testing and exponentiation performance. One potential problem identified by the MQV designers is that since the DH values are not explicitly authenticated by the protocol then it could be possible for an attacker to replace these values. An example of such potential vulnerability is the so called "small group attack" in which the attacker replaces the legitimate DH values of the parties with elements of small order and thus forces the same low-entropy key at both ends. Due to these potential attacks, "implicitly-authenticated" protocols, such as MQV, are often specified to check that the peer's DH value is of the expected prime order q. Unfortunately, this verification adds an exponentiation to the protocol, a drawback particularly noticeable in MQV whose main attractiveness is the virtually optimal performance. To remedy this situation, the MQV designers specified that when the group G is a subgroup of a larger subgroup G , the session key K be computed as H(σ) where σ = σ h Â = σ h B and h is the cofactor value |G |/|G|. This strategy has two benefits: forcing σ to be in the subgroup G (regardless of whether the DH values were in G or not) and saving the extra exponentiation (the exponentiation to h is for free as it can be combined with the other exponentiations in the protocol). While this specification of MQV certainly ensures that the key is in G, it is not clear whether it solves other potential vulnerabilities. For this reason the standards implementing MQV, as well as various descriptions of the MQV protocol in the literature, often specify (or at least recommend) the performance of the extra exponentiation needed to test that the peer's DH is of prime order q (an operation usually referred to as "ephemeral public key validation").</p><p>We do not know if the cofactor exponentiation or an explicitly prime-order test add any real benefit to MQV (in particular, these measures do not prevent any of the attacks shown above). On the other hand, we prove that HMQV is secure without any one of these operations. This serves to highlight the importance and benefits of an analysis-driven design which frees us from costly precautionary defenses. (All is needed in HMQV is to check that the peer's DH value is non-zero).</p><p>Validation of long-term public keys. Both the MQV paper and its standardized version require that the long-term public keys of the parties be validated to be in the prime-order subgroup G. In contrast to the validation of ephemeral DH values as discussed above, in this case the extra computation incurred by this test is easily affordable if it is done by the certification authority at the time of key registration. Yet, since not all CA's will be configured to do such tests, it is better to minimize these extra requirements from CAs. Also in this case, we can prove that the HMQV protocol does not need of such tests. Namely, a dishonest party can choose an element of order other that q as its public key and yet be unable to cause harm to any honest party.</p><p>A more significant burden on the CA is to require the latter to check whether the the registrant of a public key knows the corresponding private key. While technically this can be done via zero-knowledge proofs of knowledge, in practice many CAs will not do these checks at all. While originally believed that such "proof of possession" tests could benefit the MQV protocol, this was questioned by Kaliski's UKS attacks <ref type="bibr" target="#b22">[24]</ref> (see the discussion above) that are not avoided by these tests. Also here the analysis of HMQV shows that the security of the protocol does not rely on proof-of-possession tests by the CA.</p><p>Resistance to disclosure of Diffie-Hellman exponents. As discussed in Section 3.1 an important security requirement from Diffie-Hellman protocols is that the disclosure of the exponent of an ephemeral DH value should not compromise the security of sessions in which that value was not used. In particular, the lack of this property weakens the performance claim that the ephemeral DH exponentiation can be done off-line (an extreme example of such a weakness are DSS signatures where the disclosure of a single ephemeral exponent compromises the long-term signature secret key). While this property has not been considered in the MQV publications, we do investigate it in the setting of HMQV and prove it to hold there. We do not know to what extent it may be satisfied by MQV when the session key is the result of hashing the value σ; without such hashing the property is not achieved (we omit the details of such an attack).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The security of HMQV</head><p>In contrast to MQV, the HMQV protocol presented in this paper can be proven secure in the Canetti-Krawczyk model outlined in Section 2. Moreover, we prove that all the additional security goals of MQV are satisfied by HMQV (with the exception of PFS which cannot be fully achieved by any 2-message protocol). Here we summarize all these properties of HMQV and point out to the design mechanisms that resolve the above weaknesses of MQV. The presentation is still informal and follows the description of properties from the previous subsection; full rigorous proofs are presented in the rest of the paper.</p><p>Basic security of HMQV. We prove that HMQV, over any prime order group in which the CDH assumption holds <ref type="foot" target="#foot_3">4</ref> , is secure in the sense of Definition 1 when the hash function is modeled as a random oracle. While the proof of this result occupies the largest part of this paper, it is instructive to consider two of the attacks on MQV discussed before as a way to motivate some of the elements in the HMQV design. Specifically, consider the weakness of MQV to group representation and its vulnerability to UKS attacks. Due to our general security proof for HMQV we know that both weaknesses are avoided in HMQV. Specifically, these attacks are prevented via the replacement of the values d = X and e = Ȳ in MQV with d = H(X, B) and e = H(Y, Â). The randomization of X and Y provided by the hashing prevents the weakness of MQV caused by relying on specific group representations, while the identity under the hash binds the peer's identity with the key derivation thus preventing UKS (and other impersonation) attacks.</p><p>Resistance to KCI attacks. In Section 6 we formalize KCI attacks in the context of the CK model and show that HMQV provides provable resistance to this attack. For this property we need an additional design element in HMQV, namely, the hashing of σ Â and σ B ; without this hashing the following KCI attack is possible. Let Â be a party for which M knows the private key a, and B be an uncorrupted party. When Â initiates a session with B sending a DH value X chosen by Â (and whose exponent x the attacker M does not know), M replaces X with the DH value</p><formula xml:id="formula_2">X 2 . Now B computes K B = σ B = (X 2 A d ) y+eb (with d = H(X, B), e = H(Y, Â)).</formula><p>M issues a session-key query and learns K B . From this value, and using the knowledge of a, M computes (X 2 ) y+eb , and by taking a square root M obtains (X) y+eb . Now, using a, M computes K Â = σ Â = (XA d ) y+eb (here d = H(X 2 , B)). Therefore, by exposing the session ( B, Â, Y, X 2 ), the attacker is able to learn the key of the non-matching session ( Â, B, X, Y ). As said, this attack demonstrates the need to define the session key of HMQV to be the hashing of the σ values rather than these values themselves.</p><p>Resilience to the disclosure of g ab . The resistance to KCI implies an important characteristic of HMQV that sets it apart from other implicitly-authenticated protocols such as the unified model <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b21">23]</ref> (see Section 3.1). In particular, in these protocols the value g ab serves as a long-term shared key between parties Â and B, and therefore its disclosure suffices for impersonating Â to B, and viceversa. In the case of HMQV, and as a corollary of KCI resistance, the disclosure of g ab does not allow impersonation in any direction.</p><p>Perfect Forward Secrecy (PFS) As said before, no 2-message protocol (based on public key authentication and without assuming a previous secure exchange between the parties) can provide the PFS property. Thus, this inherent limitation holds for HMQV as well. Yet, HMQV enjoys the highest form of forward secrecy a 2-message protocol can provide: Any session key established by uncorrupted parties without active intervention by the attacker is guaranteed to remain secure even if the parties to the exchange are corrupted after the session key was erased from the parties memory. This property (which we call 'weak PFS (wPFS)' is formalized and proven in Section 6. Also, as shown in Section 8 the 3-message variant of HMQV augmented with key confirmation provides full PFS.</p><p>Prime-order testing and exponentiation performance. HMQV enjoys the best computational performance of any Diffie-Hellman based key exchange protocol authenticated with public keys: 2.5 exponentiations per party. It does not necessitate of any further exponentiations such as the testing for the prime order of the ephemeral DH values required in other protocols and in various standard specifications of MQV. This is a prime example of the effect that a rigorous proof can have on the performance of a protocol by minimizing the safeguards required in its design. Indeed, our analysis of HMQV shows that the only property of the peer's DH value that needs to be verified is that this value is non-zero.</p><p>Validation of long-term public keys. Another advantage of the HMQV protocol is that it frees the certification authority from any checks beyond the essential verification of the identity of the registrant of a public key. In particular, the proven security of HMQV does not rely on a registrant of a public key providing proof of possession of the private key to the CA (nor it requires any other checks on the public key).</p><p>Resistance to disclosure of Diffie-Hellman exponents. The HMQV protocol can be proven to withstand the leakage of ephemeral DH exponents. Moreover, not only the disclosure of an exponent y of a DH value Y does not compromise sessions in which Y is not used, but even the session in which Y is used is not compromised by the leakage of y (provided, of course, that the private key of the party choosing Y is not known to the attacker). For proving this property (and only for this property) we need to recourse to two stronger assumptions than CDH, namely, the Gap Diffie-Hellman and Knowledge of Exponent assumptions (see Section 7 for the details).</p><p>On maximal resistance to exposure attacks. HMQV enjoys a remarkable resistance to disclosure of secret information. Consider a session ( Â, B, X = g x , Y = g y ); the computation of the session key involves the four secret values a, b, x, y. Obviously the disclosure of both a and x, or both b and y, allows the attacker to learn the session key. Remarkably, we prove that the disclosure of any other pair of values in the set {a, b, x, y} is insufficient for the attacker to distinguish the session key from randomness. This includes the cases in that the attacker learns both a and b (this is the wPFS property discussed above), both x and y (this follows from the resilience of HMQV to the leakage of ephemeral DH exponents -see Remark 7.1), both a and y, or both b and x (the last two follow from the security of HMQV to KCI attacks). In addition, as we already said, Â and B's communication remains secure even if g ab is learned by the attacker.</p><p>HMQV-C: 3-message with key confirmation. While the HMQV protocol provides a full spectrum of basic and advanced security properties it fails to provide two properties that are required or desirable in some applications: full PFS and confirmation from the peer that the session key was computed. The lack of these two properties is unavoidable in HMQV and in any 2-message protocol (without prior communication between the parties). If these properties are to be ensured one can extend HMQV to include a "key confirmation" step. This results in a 3-message protocol (called HMQV-C and described and analyzed in Section 8) that inherits all the security benefits of HMQV plus the above two properties. Another analytical advantage of HMQV-C is that the security proofs for HMQV-C from this paper directly translate into the stronger notion of "universally composable (UC)" security from <ref type="bibr" target="#b12">[13]</ref>. See Section 8.</p><p>One-pass HMQV. A one-pass key exchange protocol consists of a single message sent from a sender Â to a recipient B from which both parties (using their private and public keys) derive a unique key that only Â and B may possibly know (as long as both parties and the session are uncorrupted). More precisely, the requirements from the established key are the same as in a regular key exchange protocol except for the possibility that the message received by B is a replay of an older message from Â. In Section 9 we formalize this notion and show how to build such a protocol from HMQV. This is similar to one-pass MQV but with a proof of security. In addition, this protocol can be used as a secure (in the random oracle model) authenticated CCA encryption scheme which is well suited to store-and-forward applications and more efficient than other alternatives.</p><p>The rest of the paper is devoted to formalizing and proving all of the above claims about the security of HMQV. We start by introducing and analyzing a main technical tool in our proof: a new type of challenge-response signatures based on the Schnorr identification scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Exponential Challenge-Response Signatures</head><p>Here we introduce the Exponential Challenge-Response (XCR) Signature Scheme which is the main building block used in the design and analysis of the HMQV protocol. As in a regular digital signature scheme, in a challenge-response signature scheme a signer has a pair of private and public keys used for generation and verification, respectively, of signatures. However, in contrast to regular signatures, challenge-response signatures are inherently interactive and require the recipient (i.e., the verifier) of a signature to issue a challenge to the signer before the latter can generate the signature on a given message. A secure challenge-response signature scheme needs to guarantee that no one other than the legitimate signer be able to generate a signature that will convince the challenger to accept it as valid (in particular, a signature is not only message-specific but also challenge-specific). On the other hand, we are only interested to ensure verifiability of the signature by the challenger, and thus we make no assumptions or requirements regarding the transferability, or verifiability by a third party, of the signature. Moreover, in the scheme described below the party that chooses the challenge can always generate a signature, on any message, which is valid with respect to that particular challenge. What is even more important for our application (and differentiates our scheme from other interactive signatures) is the fact that the verifier can compute, using the challenge, the same signature string as the signer.</p><p>While the above description may serve as a basis for a general definition of challenge-response signatures, we omit here such a general treatment in favor of a more focused description of the specific challenge-response signature used in this work. In particular, the definition of security is simplified by tailoring it to this specific scheme.</p><p>As before, we use g to denote a generator of a group G of prime order q, and H to denote a hash function that outputs = |q|/2 bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Definition of the XCR Signature Scheme</head><p>Definition 2 The exponential challenge-response (XCR) signature scheme. The signer in a XCR scheme, denoted by B, possesses a private key b ∈ R Z q and a public key B = g b . A verifier (or challenger), denoted Â, provides a message m for signature by B together with a challenge X which Â computes as X = g x for x ∈ R Z q (x is chosen, and kept secret, by Â). The signature of B on m using challenge X is defined as a pair (Y, X y+ H(Y,m)b ), where Y = g y and y ∈ R Z q is chosen by B. The verifier Â accepts a signature pair (Y, σ) as valid (for message m and with respect to challenge X = g x ) if and only if it holds that Y = 0 and (Y B H(Y,m) ) x = σ). Notation: For a given message m, challenge X, and value Y we define XSIG B (Y, m, X) def = X y+ H(Y,m)b (i.e., XSIG B denotes the second element in an XCR signature pair).</p><p>Relation between XCR and Schnorr's scheme. The main motivation for introducing the XCR scheme comes from its use in our design and analysis of the HMQV protocol (Section 5). By now, however, it may be illustrative to motivate this scheme via its relation to the Schnorr's identification scheme from which the XCR scheme is derived. We sketch this relation next. Schnorr's (interactive) identification scheme consists of a proof of knowledge of the discrete logarithm b for a given input B = g b . Let B denote the prover in this scheme (that possesses b) and Â the verifier (that is given the input B). The basic Schnorr's identification consists of three messages: (i) B chooses y ∈ R Z q and sends Y = g y to Â; (ii) Â responds with a random value e ∈ R Z q ; and (iii) B sends Â the value s = y + eb. Â accepts if and only if g s = Y B e holds. This protocol is a Arthur-Merlin zero-knowledge proof of knowledge (of b) for an honest verifier Â (i.e., one that chooses e uniformly at random). Therefore, it can be transformed via the Fiat-Shamir methodology into a signature scheme, namely sig B (m) = (Y, y + H(Y, m)b), that is provably secure in the random oracle model <ref type="bibr" target="#b36">[38]</ref>. Now consider the following 4-message variant of Schnorr's protocol in which a first message from Â to B is added. In this first message Â sends to B a value X = g x . Then the 3 messages from Schnorr's scheme follow, except that in message (iii) (the fourth message in the modified protocol) rather than sending s = y + eb to Â, B sends S = X s . Â accepts if and only if S = (Y B e ) x . It can be shown that this protocol is a proof of the "ability" of B to compute CDH(B, X) for any value X ∈ G. Moreover, the protocol is zero-knowledge against a verifier Â that chooses e at random (while X may be chosen arbitrarily). Now, note that applying the Fiat-Shamir transformation to this protocol one obtains the challenge-response signature XCR. <ref type="foot" target="#foot_4">5</ref> This also explains why we use the term "exponential" in naming the XCR scheme: it refers to the replacement of s = y + eb in the Schnorr scheme with X s in the last message of the protocol.</p><p>Next we establish our security requirement from the XCR scheme.</p><p>Definition 3 Security of the XCR signature scheme. We say that the XCR challenge-response signature scheme is secure if no polynomial-time machine F can win the game in Figure <ref type="figure" target="#fig_3">3</ref> with non-negligible probability.</p><p>Forger F in Definition 3 where Y = g y , y ∈ R Z q , is chosen by B afresh with each query.</p><formula xml:id="formula_3">1. F is given values B, X 0 where B, X 0 ∈ R G.</formula><p>3. F is allowed a polynomial number of queries to B where the queries are chosen (possibly adaptively) by F.</p><p>4. F halts with output "fail" or with a guess in the form of a triple (Y 0 , m 0 , σ).</p><p>F's guess is called a (successful) forgery if the following two conditions hold:</p><p>(a) The pair (Y 0 , σ) is a valid XCR signature of B on message m 0 with respect to challenge X 0 (i.e., Y 0 = 0 and σ = XSIG B (Y 0 , m 0 , X 0 ); also note that the value of X 0 is the one received by F as input).</p><p>(b) The pair (Y 0 , m 0 ) did not appear in any of the responses of B to F's queries.</p><p>We say that F wins the game (or simply forges) if it outputs a successful forgery. 1. Note that in order to be successful the forger has to use the input X 0 in its forgery. This captures the fact that XCR signatures are only unforgeable with respect to a challenge not chosen by the attacker (indeed, a signature with a given challenge can be trivially computed by the party choosing the challenge, i.e. the one that knows the dlog of the challenge).</p><p>2. According to our definition, if B outputs a signature (Y, σ) on a message m wrt challenge X, and the forger can find a signature (Y , σ ) for the same m wrt the same challenge X but with Y = Y , then we consider F successful (namely, finding a second signature for the same message is considered a valid forgery). In some sense, we look at these signatures as signing both m and Y . This property may not be essential in other applications of challenge-response signatures but it is crucial for the application to HMQV security in this paper.</p><p>that the soundness is limited by 2 -. This is the basis for our choice of = |q|/2 as the output length of H(Y, m), namely, a trade-off between efficiency and security. See Remark 4.2 for a more accurate discussion.</p><p>3. We do not ask that F will always output good forgeries; it can output "fail" or even invalid triples. The only requirement is that with non-negligible probability (over the distribution of inputs to F, the choices by the random oracle H, the coins of F, and the coins of B) F output a successful forgery.</p><p>4. Note that we only restricted Y 0 to be non-zero. In particular, we require no check that Y 0 be of prime order q (only that it represents a non-zero element for which the group operation is defined). This is an important aspect of XCR signatures. In particular, the requirement to run a prime-order test would translate into an additional exponentiation for each party in the HMQV protocol, thus degrading significantly the "almost optimal" performance of the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Proof of Unforgeability for the XCR Signature Scheme</head><p>The security of XCR signatures (and of all other results in this paper) depends on the Computational Diffie-Hellman (CDH) Assumption that we define below. We first need the following remark (or disclaimer) on our treatment of computational issues.</p><p>Remark 4.1 (Asymptotics.) The technical presentation of computational results in this paper uses the probabilistic polynomial-time abstraction (leaving a detailed concrete security analysis for further work). The implicit security parameter used throughout the paper is the quantity |q| (where q denotes the order of the group G). As customary, we will use the term negligible to denote a function on the security parameter that decreases faster than any inverse polynomial fraction while non-negligible denotes a function on the security parameter that is lower bounded by an inverse polynomial fraction. (Note that "negligible" and "non-negligible" are not the complement of each other.) Here and in the sequel, our treatment of asymptotics is informal. For example, we state claims in terms of single groups while a formal statement should consider infinite families of finite groups. We believe that these details are relatively straightforward to fill in and thus we prefer to sacrifice formal accuracy for easier understanding.</p><p>Definition 4 For two elements U = g u , V = g v in G we denote by CDH g (U, V ) the result of applying the Diffie-Hellman computation (wrt to generator g) to U and V , i.e., CDH g (U, V ) = g uv .</p><p>(For simplicity we will often omit the subscript g from the CDH g notation.) An algorithm is called a CDH solver for G if it takes as input pairs of elements (U, V ) in G and a generator g of G and outputs the Diffie-Hellman result CDH g (U, V ).</p><p>We say that the Computational Diffie-Hellman (CDH) assumption holds in the group G = g if for all polynomial-time CDH solvers for G, the probability that on a pair (U, V ), for U, V ∈ R G, the solver computes the correct value CDH g (U, V ) is negligible (the probability taken over the random coins of the solver and the choice of U, V independently at random in G).</p><p>The following theorem states the security of the XCR scheme in the random oracle model under the CDH assumption; it constitutes the basis for the proof of security of protocol HMQV.</p><p>Theorem 5 Under the CDH assumption, the XCR signature scheme is secure (according to Definition 3) in the random oracle model.</p><p>Proof: Given an efficient and successful forger F against the XCR signature scheme (i.e., F wins the forgery game from Definition 3 with non-negligible probability), we build an efficient solver C for the CDH problem, namely, C gets as input a pair of random elements U, V in G, and outputs the value CDH(U, V ) with non-negligible probability. Unsuccessful runs of C may end with "fail" or just the wrong value of CDH(U, V ). Using results by Maurer and Wolf <ref type="bibr" target="#b29">[31]</ref> and Shoup <ref type="bibr" target="#b38">[40]</ref> such a "faulty CDH solver" can be transformed, using the self-reducibility properties of the CDH problem, into an efficient algorithm that solves CDH for every input U, V with only negligible probability of error.</p><p>Algorithm C is presented in Figure <ref type="figure" target="#fig_4">4</ref>, and it follows a mostly standard argument for Fiat-Shamir type signatures. The idea is that if F can succeed in forging a signature with a pair (Y 0 , m 0 ) and a given value H(Y 0 , m 0 ) output by the function H, then F is likely to succeed also when H(Y 0 , m 0 ) is set to a different random value. Using this property, we construct C such that after running F twice, C obtains (with non-negligible probability) two forgeries with the same pair (Y 0 , m 0 ) but different values of H(Y 0 , m 0 ). Now, using these two forgeries C is able to compute CDH(U, V ).</p><p>Examining the specification of C in more detail, first note that in the run of F by C all queries to the signer B are answered by C without knowledge of the private key b, and without access to an actual signing oracle for B. Instead all these answers are simulated by C in steps S1-S3. It is easy to see that this is a perfect simulation of the XCR signature generation algorithm under private key b except for the following deviation that happens with negligible probability: In step S3 of the simulation, C does not complete the run of F if the value (Y, m) was queried earlier from H. However, since the value Y , as generated by C, is distributed uniformly over G and chosen independently of previous values in the protocol, then the probability that the point (Y, m) was queried earlier from H is at most Q/q where Q is an upper bound on the number of queries to H that occur in a run of C.</p><p>Therefore, the probability of F outputting a successful forgery in the run under C is the same, up to a negligible difference, as in a real run of F, and therefore non-negligible. In particular, when such a successful forgery is output by F then conditions F1 and F2 checked by C necessarily hold. Condition F3 also holds except for probability 2 -, i.e., the probability that F's forgery is correct when it did not query H(Y 0 , m 0 ). To see this, note that if one fixes the pair (Y 0 , m 0 ) and the challenge X 0 , then the signature produced with e = H(Y 0 , m 0 ) is necessarily different than the signature produced with e = H(Y 0 , m 0 ) if e = e (mod q). Hence, the probability that F will guess the right signature without querying H(Y 0 , m 0 ) is at most as the probability of guessing the value of H(Y 0 , m 0 ), i.e., 2 -. Since conditions F1-F3 determine the run of the "repeat experiment" then in all we have that the simultaneous probability that F outputs a correct forgery in a run under C AND that C executes the "repeat experiment" in that run is non-negligible. Now, using the Forking Lemma<ref type="foot" target="#foot_5">6</ref> from <ref type="bibr" target="#b36">[38]</ref> we obtain that the probability that in the "repeat experiment" F will output a correct forgery for the pair (Y 0 , m 0 ) given that F did so in the first run is non-negligible. Moreover, in such a case we are guaranteed that the forgeries in the first and second runs use different values e, e of H(Y 0 , m 0 ).</p><p>We now proceed to show that in the case that both the first run and the repeat experiment end up with two valid forgeries for the same pair (Y 0 , m 0 ), and e = e (which happens with probability 1 -2 -), then the value W computed by C equals CDH(X 0 , B). Indeed, a simple computation Building a CDH solver C from an XCR forger F Setup. Given a successful XCR-forger F we build an algorithm C to solve the CDH problem. The inputs to C are random values U = g u , V = g v in G, and its goal is to compute CDH(U, V ) = g uv . C's actions. C sets B = V and X 0 = U , and runs the forger F on input (B, X 0 ) against a signer B with public key B. C provides F with a random tape and provides random answers to the H queries generated in the run (if the same H query is presented more than once C answers it with the same response as in the first time). Each time F queries B for a signature on values (X, m) chosen by F, C answers the query for B as follows (note that C does not know b): <ref type="figure">H(Y,</ref><ref type="figure">m</ref>) was defined by a previous query to H, C aborts its run and outputs "fail").</p><formula xml:id="formula_4">S1. Chooses s ∈ R Z q , e ∈ R {0, 1} . S2. Sets Y = g s /B e . S3. Sets H(Y, m) = e (if</formula><p>C responds to F's query with the signature pair (Y, X s )</p><p>When F halts C checks whether the three following conditions hold:</p><p>F1. F output a guess (Y 0 , m 0 , σ), Y 0 = 0.</p><p>F2. The pair (Y 0 , m 0 ) was not used as the (Y, m) pair in any of the signatures generated by B.</p><p>F3. The value H(Y 0 , m 0 ) was queried from the random oracle H.</p><p>If the three conditions hold, then C proceeds to the "repeat experiment" below; in all other cases C halts and outputs "fail". The repeat experiment. C runs F again for a second time under the same input (B, X 0 ) and using the same coins for both C and F. The difference between the two runs is in the way in which C answers the H queries during the second run. Specifically, all queries to H performed before the H(Y 0 , m 0 ) query are answered identically as in the first run. The query H(Y 0 , m 0 ), however, is answered with a new independent value e ∈ R {0, 1} . Subsequent queries to H are also answered at random from {0, 1} , independently of the responses provided in the first run.</p><p>Output. If at the end of the second run, F outputs a guess (Y 0 , m 0 , σ ) (with same (Y 0 , m 0 ) as in the first run) and e = e , then C computes the value W = (σ/σ ) (e-e ) -1 and outputs W as its guess for CDH(U, V ); otherwise C outputs "fail". shows that, if Y 0 = 0 as necessary for a valid forgery, then writing X 0 = g x 0 we have:</p><formula xml:id="formula_5">W = σ σ 1 e-e = (Y B e ) x 0 (Y B e ) x 0 1 e-e = (B (e-e )x 0 ) 1 e-e = B x 0 = CDH(X 0 , B).</formula><p>Now, since X 0 and B are, respectively, the inputs U and V provided to C, then we get that in this case (which happens with non-negligible probability) C has successfully computed CDH(U, V ).</p><p>2 . Let be the number of bits in the output of H(Y, m). Clearly, the smaller the more efficient the signature scheme is; on the other hand, a too small implies a bad security bound (since once the exponent H(Y, m) is predictable the signature scheme is insecure). But how large a do we need for security purposes? Here we see that setting = 1 2 |q|, as we specified for XCR signatures (and for its application to the HMQV protocol), provides the right performance-security trade-off. In order to assess the level of security that provides to the XCR signatures (and consequently to HMQV), we note that there are two places in the above proof where this parameter enters the analysis. One is when bounding the probability that the attacker could forge a signature with parameters (Y 0 , m 0 ) without querying H on this pair. As we claimed the probability in this case is 2 -(or 1/ √ q using the fact that we defined = |q|/2).</p><p>The other use of is in the proof of the Forking Lemma by Pointcheval and Stern <ref type="bibr" target="#b36">[38]</ref>. When written in terms of XCR signatures Lemma 9 and Theorem 10 from <ref type="bibr" target="#b36">[38]</ref> show that given a forger against XCR signatures that works time T , performs Q queries to H and forges with probability ε, one can build a CDH solver that runs expected time c Q ε T provided that ε ≥ c Q 2 (c, c are constants). Now, since we know how to build CDH solvers that run time √ q (e.g., Shanks algorithm) then the above analysis tells us something significant only when</p><formula xml:id="formula_6">c Q ε T &lt;&lt; √ q, in particular Q/ε &lt;&lt; √ q.</formula><p>From this and the condition ε ≥ c Q/2 we get that we need Q/ε &lt; min{ √ q, 2 }. Since this is the only constraint on we see that choosing such that 2 &gt; √ q does not add to the security of the scheme, and therefore setting = 1 2 |q| provides the best trade-off between security and performance. (Note that the same length consideration applies to the parameter e in the modified Schnorr's identification scheme described following Definition 2). We also comment, independently from the above considerations on , that the above constraint Q &lt; ε √ q also guarantees that the simulation error in step S3 of Figure <ref type="figure" target="#fig_4">4</ref> (which we showed in the proof of Theorem 5 to be at most Q/q) is no more than 1/ √ q.</p><p>Remark 4.3 (Changing the order of interaction with B.) In our application of XCR signatures to the analysis of the HMQV protocol we change the order of interaction between the challenger Â and the signer B. In Definition 2, Â presents B with the message m at the same time that it provides the challenge X to B, thus allowing B to immediately respond with the signature pair (Y, XSIG B (Y, m, X)). In the modified version that we will consider, we have the following order of interaction: (i) Â presents message m to B and B outputs Y , then (at some later point) (ii) Â provides (Y, m, X) to B, and B outputs XSIG B (Y, m, X). Now, we can modify the forging game of Definition 3 to allow F's queries to B to take this modified order. In particular, F can interleave different interaction with B, namely, it can run several instances of step (i) before running the corresponding steps (ii). This requires B to keep state after step (i) with the values of Y , y and m. When F later presents (Y, m, X) in step (ii), B checks that it has the pair (Y, m) in its state and if so it responds with XSIG B (Y, m, X) and erases (Y, m) from its state (if B did not have the pair (Y, m) in its state then it does not issue the signature). Note that this specification of B's actions ensures that B will never use the same value of Y for two different signatures. It can be easily verified that the above proof of security of XCR signatures remains valid for this modified order (simply because the simulation of the choice of Y by B does not require the knowledge of X, but only the value of m needed to determine H(Y, m)).</p><p>Remark 4.4 (A non-interactive XCR variant.) XCR signatures can be made non-interactive, but verifier-specific, by putting X = A, where A is a public key of the verifier. In this case the signature will be a pair (Y, t) where t is a MAC tag computed on the signed message using a key derived by hashing XSIG Â(Y, " Â", A). This provides for a very efficient non-interactive verifierspecific deniable authentication mechanism (see Section 9). It does not provide for a universallyverifiable non-repudiable signature. Remark 4.5 (HCR and DSS signatures.) We do not know whether XCR signatures remain secure if the exponent y corresponding to a value Y used by B in a signature is revealed to the forger (note that in this case the simulation steps S1-S3 in Figure <ref type="figure" target="#fig_4">4</ref> do not work). On the other hand, if one modifies the definition of XCR such that the XSIG B component is replaced with a hash of this value (note that the signature is still verifiable by the challenger) then one obtains a signature scheme in which revealing y does not help the forger. More precisely, in Section 7 we study these signatures, which we call HCR, in detail and show that under the Gap Diffie-Hellman and KEA1 assumptions they are unforgeable in the random oracle model even if y is revealed to the attacker. As a result, HCR signatures provide for a more secure alternative to DSS signatures as they resolve the main DSS vulnerability by which the disclosure of a single ephemeral exponent (i.e., k in the component r = g k of a DSS signature) suffices to reveal the signature key. On the other hand, HCR signatures are verifier-specific and require interaction (or the possession of a public key by the verifier as in Remark 4.4), and do not provide for third-party verifiability (a property that may be a bug or a feature of HCR depending on the application).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Dual XCR Signatures (DCR)</head><p>An important property of XCR signatures is that the challenger (having chosen the challenge) can compute the signature by itself. Here we show how to take advantage of this property in order to derive a related challenge-response signature scheme (which we call the "dual XCR scheme", or DCR for short) with the property that any two parties, Â, B, can interact with each other with the dual roles of challenger and signer, and each produce a signature that no third party can forge. Moreover, and this is what makes the scheme essential to the HMQV protocol, the resultant signatures by Â and by B have the same value. (More precisely, they have the same XSIG component.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6</head><p>The dual (exponential) challenge-response (DCR) signature scheme. Let Â, B be two parties with public keys A = g a , B = g b , respectively. Let m 1 , m 2 be two messages. The dual XCR signature (DCR for short) of Â and B on messages m 1 , m 2 , respectively, is defined as a triple of values: X, Y and DSIG Â, B (m 1 , m 2 , X, Y ) def = g (x+da) (y+eb) , where X = g x , Y = g y are challenges chosen by Â and B, respectively, and the symbols d and e denote H(X, m 1 ) and H(Y, m 2 ), respectively.</p><p>As said, a fundamental property of a DCR signature is that after exchanging the values X and Y (with x and y chosen by Â and B, respectively), both Â and B can compute (and verify) the same signature DSIG Â, B (m 1 , m 2 , X, Y ). This can be seen from the identities:</p><formula xml:id="formula_7">DSIG Â, B (m 1 , m 2 , X, Y ) = g (x+da)(y+eb) = (Y B e ) x+da = (XA d ) y+eb</formula><p>Moreover, as shown next the attacker cannot feasibly compute this signature.</p><p>The security of DCR signatures. Roughly speaking, a dual signature is an XCR signature by Â on message m 1 , under challenge Y B e , and at the same time an XCR signature by B on message m 2 , under challenge XA d . More precisely, since the values d and e are determined during the signature process (via the possibly adversarial choice of messages m 1 , m 2 ), then we will say that a DCR signature of B is secure (with respect to A) if no efficient attacker can win, with nonnegligible probability, the game of Figure <ref type="figure" target="#fig_3">3</ref> with the following modifications. In step 2, the queries to B are of the form (X, m, m 1 ) and the signature by B is the pair (Y, XSIG B (Y, m, XA d )) where Y is chosen by B and d = H(X, m 1 ). A successful forgery is a quadruple (Y 0 , m 0 , m 1 , σ) where σ = XSIG B (Y 0 , m 0 , X 0 A d ), Y 0 = 0, the pair (Y 0 , m 0 ) satisfies the validity requirement (b) from Figure <ref type="figure" target="#fig_3">3</ref>, and m 1 is an arbitrary message chosen by F. We say that the dual signature of B is secure if it is secure with respect to any value A = g a not chosen by the attacker.</p><p>Theorem 7 Let Â, B be two parties with public keys A = g a , B = g b , respectively. Under the CDH assumption, the DCR signature of B with respect to A is secure even if the forger is given the private key a of Â (but not the private key of B).</p><p>Proof: The same proof of unforgeability of XCR (Theorem 5) works here with a modified computation of W as specified below. First note that since the DCR signature of B now involves the value d = H(X 0 , m 1 ), where m 1 is a message that F may choose at will, then the value of m 1 chosen by F before the repeat experiment may differ from the value of m 1 chosen during the repeat experiment. In this case we get two different values, d, d , used in the σ and σ signatures. Also, note that even with a single value of d the specification of W in the proof of Theorem 5 would result in the value (XA d ) b rather than X b (as required in order to solve the CDH problem on inputs U = X, V = B). We deal with these two issues by redefining W as follows (here we use the fact that a, the private key of Â, is known to C):</p><formula xml:id="formula_8">W = σ/(Y B e ) da σ /(Y B e ) d a 1 e-e<label>(1)</label></formula><p>The rest of the proof remains unchanged.</p><p>2</p><p>Remark 4.6 The above Theorem assumes that the value b is not known while a is known (to the attacker and to the CDH solver C). While this results in a strong assurance of security (namely, the DCR signatures of B are secure even if the private key of the peer, Â, is given to the attacker), it also implicitly assumes that Â and B are different entities or, more precisely, that A = B. Indeed, when Â = B both a and b are secret (they are the same value) and therefore the computation of the CDH value W cannot be carried out as specified in the above proof using a. For the time being we will assume A = B and use the above theorem. Only in Section 6.3 we will return to the issue of A = B when dealing with reflection attacks against the HMQV protocol. There we will see that we can extend the Theorem to the case A = B, at least with some restrictions on the forger F that are satisfied in the HMQV setting.</p><p>HMQV in a nutshell. The HMQV protocol consists of an exchange between parties Â and B of DH values X = g x and Y = g y that serve as challenges from which both parties compute the dual XCR signature DSIG Â, B (" Â", " B", X, Y ) = g (x+da) (y+eb) . The session key is then derived by hashing this value. In this way the signature itself need not be transmitted: it is the uniqueness of the signature that ensures a common derived value for the session key, and it is the ability to compute the key (equivalently, the signature) that provides for a proof that the exchange was carried by the alleged parties Â and B. Moreover, since the messages m 1 , m 2 on which the signature is computed are the identities of the peers, both parties get assurance that the key they computed is uniquely bound to the correct identities (this is essential to avoid some authentication failures such as the UKS attacks). While the casting of the HMQV design in terms of DCR signatures is the main conceptual contribution of our work, showing that this idea indeed works for proving the security of the protocol turns out to be technically involved. The rest of the paper is devoted to this proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Basic Security Analysis of the HMQV Protocol</head><p>Using the terminology from the previous section, a session of the HMQV protocol between two parties Â, B consists of a basic Diffie-Hellman exchange of DH values X = g x and Y = g y (Figure <ref type="figure" target="#fig_0">1</ref>) with the session key computed as H(π) where π = DSIG Â, B (m 1 = B, m 2 = Â, X, Y ). That is, π is computed as the dual signature of Â and B on each other's identity. In the sequel, we denote the above signature by the shorthand π( Â, B, X, Y ), namely,</p><formula xml:id="formula_9">π( Â, B, X, Y ) def = DSIG Â, B (m 1 = B, m 2 = Â, X, Y ) = g (x+da)(y+eb)</formula><p>where d = H(X, B), e = H(Y, Â), and A = g a , B = g b are the public keys of parties Â, B respectively. Note that π( Â, B, X, Y ) = π( B, Â, Y, X).</p><p>In this section we prove that the HMQV protocol is secure in the Canetti-Krawczyk model of key exchange <ref type="bibr" target="#b10">[11]</ref> outlined in Section 2; additional security properties of HMQV are proven in Section 6. We start with a full specification of the HMQV protocol, in accordance to the above formal model of key exchange.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Detailed Specification of the HMQV Protocol</head><p>In our formal treatment we will refer to the HMQV protocol as protocol Π.</p><p>Protocol Π runs in a multi-party network where any of the parties can be invoked to run the protocol. Each invocation of the protocol at a party creates a session (a local state containing information related to this specific instance of the protocol), which may produce outgoing messages and the output of a session key at completion. During a session, a party can be activated with three types of activations presented next (in the following description Â denotes the identity of the party being activated and B the identity of of the intended peer to the session).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Session Activations</head><p>Initiate( Â, B): Â generates a value X = g x , x ∈ R Z q , creates a local session of protocol Π which she identifies as (the incomplete) session ( Â, B, X), and outputs the value X as its outgoing message.</p><p>The meaning of this activation is that Â has been activated as the initiator of a session with B, and X is the message intended to be delivered to peer B as part of this session. We call Â the holder (or owner) of the session, B the peer to the session, and X the outgoing (DH) value.</p><p>Respond( Â, B, Y ): Â checks that Y = 0, if so it generates a value X = g x , x ∈ R Z q , outputs X, and completes a session with identifier ( Â, B, X, Y ) and session key H(π( Â, B, X, Y )).</p><p>Here Â is being activated as the responder in the session with peer B and incoming value Y . In this case, Â immediately completes its session (there are no further incoming messages).</p><p>Note that if the incoming value Y is zero Â ignores the activation.</p><p>Complete( Â, B, X, Y ): Â checks that Y = 0 and that she has an open session with identifier ( Â, B, X). If any of these conditions fails Â ignores the activation, otherwise she completes the session with session id ( Â, B, X, Y ) and the session key</p><formula xml:id="formula_10">K = H(π( Â, B, X, Y )).</formula><p>This represents the delivery of the second message in the protocol with the incoming value Y , (allegedly) the response from peer B.</p><p>Remark. In normal circumstances the above activations are decided by the application invoking the protocol and by the incoming protocol messages. However, in our adversarial model we will analyze the protocol assuming that protocol activations and their inputs are chosen by the attacker.</p><p>In particular, while the normal semantics of the Respond activation is that prior to this activation B was activated with an Initiate message with peer Â, and that B output Y in that activation, this does not actually have to be the case when the attacker M controls communications and the scheduling of activations. Indeed, M can generate a Respond activation for A regardless of the existence or not of an open session ( B, Â, Y ) at B. The same holds for the Complete activation where the value Y could have been generated by B for this or other session, or simply never generated by B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Session state</head><p>For the time being we specify that the only values stored in a session state are the peer's identity B, the outgoing and incoming DH values X, Y , and the session key K.</p><p>In particular, neither the exponent (dlog) x of the outgoing DH value X nor π( Â, B, X, Y ) are stored in the session state. In other words, the latter values are not accessible to the attacker in a state-reveal query. Note that since our security model considers the long-term private key a to be stored separately (and, supposedly, more securely) than the ephemeral state information, then the computation of π( Â, B, X, Y ) that uses the private key must be carried in the same module that stores this key (and therefore not part of the session state). Thus, only K = H(π( Â, B, X, Y )) is to be output into the session state. On the other hand, forbidding the storage of the ephemeral exponent x in the session state is too restrictive (especially considering that such exponents may be chosen off-line to speed-up exponentiation) and therefore we will show in Section 7 (Lemma 29) that this restriction is not needed (the reason we separate the analysis of this property is that it relies on stronger assumptions).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Session identifiers and matching sessions</head><p>The session identifiers (in the form of a quadruple ( Â, B, X, Y ) for completed sessions) are significant in that they bind together incoming and outgoing messages and the identities of peers. In particular, a session with identifier ( Â, B, X, Y ) means that the session is held by Â, that X was the (unique) outgoing value generated by Â for this session, and that the session was activated at Â with peer B and incoming value Y .</p><p>With the above notation we obtain that if ( Â, B, X, Y ) is a complete session at Â then its matching session (if it exists) is unique, its owner is B and its session-id is ( B, Â, Y, X).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Proof of Security for the HMQV Protocol</head><p>We are now ready to prove the basic security of the HMQV protocol. See Section 6 for an analysis of additional security properties of the protocol.</p><p>Theorem 8 Under the CDH assumption, the HMQV protocol Π, with its hash function modeled as a random oracle, is a secure key-exchange protocol (without PFS) in the Canetti-Krawczyk model.</p><p>The PFS property (which holds in a weak form in HMQV) is further discussed and analyzed in Section 6 and Section 8.</p><p>The proof of the above theorem follows from the definition of secure key-exchange protocols outlined in Section 2 and the following two lemmas.</p><p>Lemma 9 If two parties Â, B complete matching sessions, then their session keys are the same.</p><p>Lemma 10 Under the CDH assumption, there is no feasible adversary that succeeds in distinguishing the session key of an unexposed session with non-negligible probability.</p><p>Lemma 9 follows immediately from the definition of matching sessions. That is, if Â completes session (A, B, X, Y ) and B completes the matching session ( B, Â, Y, X) then Â computes its session key as H(π( Â, B, X, Y )) while B computes the same value as H(π( B, Â, Y, X)).</p><p>The proof of Lemma 10 is far more involved and occupies the rest of this section. It consists of showing that given a successful KE-attacker M against protocol Π (i.e., M runs in polynomial-time and succeeds with non-negligible probability in the distinguishing game of Definition 1) one can build a successful forger against the dual signature DCR. Combining this with Theorem 7 we get the existence of an efficient CDH solver in contradiction to the CDH assumption.</p><p>In this section, we develop the proof of HMQV for the case that the attacker chooses test sessions in which the peers are different entities (in particular, with different public keys). Later in Section 6.3 we complete the proof by showing the security of the protocol when both peers are the same (in particular, this proves the resistance of HMQV to reflection attacks).</p><p>Terminology. By the session signature of a session ( Â, B, X, Y ) in Π we refer to the signature π( Â, B, X, Y ). When ( Â, B, X, Y ) is the test session we refer to its session signature as the test signature. We usually denote the identifier of the test session as the quadruple ( Â, B, X 0 , Y 0 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Specialized attack goals</head><p>We start by observing that since the session key corresponding to the test session ( Â, B, X 0 , Y 0 ) is computed as H(v), where v is the value of the test signature π( Â, B, X 0 , Y 0 ), then the KEattacker M has only two possible strategies to distinguish H(v) from random (remember that we are modeling H as a random function):</p><p>Forging attack. At some point in its run M queries the function H on the value π( Â, B, X 0 , Y 0 ).</p><p>Clearly, this is possible only if M succeeds in computing (or learning) the test signature π( Â, B, X 0 , Y 0 ).</p><p>Key-replication attack. M succeeds in forcing the establishment of a session (other than the test session or its matching session) that has the same key as the test session. In this case M can learn the test-session key by simply querying the session with the same key, and without having to learn the value of the test signature.</p><p>Therefore, in the sequel, instead of considering the regular distinguishing goal of a KE-attacker we will consider an attacker whose goal is to succeed (with non-negligible probability) in one of the above two attacks. We will show that if such an efficient attacker exists against Π then there also exists an efficient forger against the DCR scheme in contradiction (via Theorem 7) to the assumed infeasibility of CDH.</p><p>For simplicity of analysis we will consider the above two forms of attacks separately. We start by considering an attacker that wins the forging attack (Section 5.2.2) and then move to analyze key-replication attacks (Section 5.2.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Infeasibility of Forging Attacks</head><p>Let M be a forging attacker against Π. Namely, M interacts with protocol Π as a KE-attacker but does not run a distinguishing test. Instead, M ends its run either with a "fail" output or with a pair (sid, v) where sid is a session identifier and v a guess for the session signature of session sid. We call M successful if it outputs, with non-negligible probability, a correct guess for the session signature of an unexposed session. The session for which M outputs a guess will be called the test session, and we refer to the corresponding session signature as the test signature.</p><p>Consider a successful run of M, and let ( Â, B, X 0 , Y 0 ) denote the test session for which M outputs a correct guess for the test signature π( Â, B, X 0 , Y 0 ). By the convention on session identifiers, we know that the test session ( Â, B, X 0 , Y 0 ) is held by Â (either as initiator or responder), Â was activated in this session with peer identity B, X 0 was the value output by Â in the session, and Y 0 was the incoming value to this session. The generation of the value Y 0 , delivered to Â by M, can fall under one of the following four cases: C1. Y 0 was never output by B as its outgoing value in any of the sessions activated at B, or B did output Y 0 as its outgoing value for some session s but it never computed the session key of s (e.g., B was activated as the initiator of s but was never activated with the Complete message to the session).</p><p>C2. Y 0 was generated by B in a session matching the test session, i.e., in session ( B, Â, Y 0 , X 0 ). C3. Y 0 was generated at B during a session ( B, Â * , Y 0 , X * ) with Â * = Â (and arbitrary X * ).</p><p>C4. Y 0 was generated at B during session ( B, Â * , Y 0 , X * ) with Â * = Â but X * = X 0 .</p><p>Since we assume that M succeeds in its forgery attack with non-negligible probability then there is at least one of the above cases that happens with non-negligible probability in the successful runs of M. Now, for each of the cases C1-C4 we build a forger F against the DCR scheme with the following property: if M succeeds with non-negligible probability in case Ci then the forger F built for case Ci succeeds with non-negligible probability in forging DCR signatures.</p><p>Important. The forgers that we build below interact with the signer B in the modified order of interaction as specified in Remark 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2.1">Forger F for Cases C1-C3</head><p>We start by presenting a first forger F that works in cases C1, C2 and C3. Namely, given an attacker M that guesses the test signature with non-negligible probability in one of these three cases, F will use M (as a subroutine) in order to forge DCR signatures also with non-negligible probability. In the description of F we will assume that whenever a session (other than the test session or its matching session) is exposed, the attacker M receives the session signature value and not just the session key. This simplifies our presentation but also shows a stronger result, namely, that in cases C1-C3 this extra information provided to M does not help in wining a forgery attack. The forger F that we construct is modeled after Definition 3 and Figure <ref type="figure" target="#fig_3">3</ref> with the modifications stated in Remark 4.3.</p><p>F actions are as follows:</p><p>1. The input to F consists of values X 0 , B ∈ R G and an oracle B for DCR signatures under public key B. (That is, B is the signer, B its public key, and X 0 is the challenge under which F is trying to forge B's signature.) F 's output consists of a (not necessarily correct) forgery against B's DCR signatures, or a "fail" symbol. In addition, F may abort its run without output (technically, this is equivalent to outputting "fail" but we differentiate between these two cases for the purpose of the analysis of F).</p><p>2. F builds a virtual setting for the run of protocol Π under attacker M, with n parties P 1 , P 2 , . . . , P n in which each party is activated at most m times (n and m are polynomials in the security parameter).</p><p>3. F chooses i, j ∈ R {1, . . . , n}, i = j,<ref type="foot" target="#foot_6">7</ref> and t ∈ R {1, . . . , m}, and sets the public key of party P j to be B. With these choices F is trying to guess which session will be chosen by M as the test session, and who the peers to the session will be. F's guess will be correct if M ends choosing as the test session the t-th session activated at party P i (either as initiator or responder) and with P j as the peer to that session. Since P j is given the public key B, we will refer to P j as B and to P i as Â. Also, we will refer to the t-th session at P i as the g-session ('g' for guess, namely, the session guessed by F as the test session to be chosen by M).</p><p>4. F chooses private and public keys for each of the n parties in the protocol, except for P j for whom the public key was set to B (and whose private key b is unknown to F). We note that while F sets all these keys initially, the attacker is allowed to later choose new, arbitrary, public keys for corrupted parties.</p><p>5. F proceeds to run the protocol Π under the control of M who schedules all session activations as well as session exposures and party corruptions. With the exception of B (whose behavior we explain below) all actions of uncorrupted parties are performed by F who has full information about their private keys and internal states. Any message produced by an uncorrupted party is handed by F to M.</p><p>6. When a session is activated at party B (whose private key b F does not know) then F uses its signing oracle (which we will also refer to as B) to determine the actions of party B in the protocol. Specifically, when M activates a session at B, either as responder or initiator, with peer identity P and incoming value X, then F feeds the signer B with P as the message to be signed and P as the public key (of P ) with respect to which the dual signature of B is to be generated. In response, F gets a value Y from the signer B. F then hands M the value Y as the outgoing value from party B. (Note that F does not request the full signature from B at this point; this will be done only in case that a state-reveal or session-key query is later performed by M on the session).</p><p>7. When M issues a state-reveal or session-key query to a session, F responds to it with the value of the corresponding session signature (if already determined). If the queried session is one held by B then F queries the session signature from B (by presenting to the signing oracle the triple (Y, peer-id, X) corresponding to the queried session -see Remark 4. <ref type="bibr">3)</ref>, and returns the value of the signature to M.</p><p>8. Upon corruption of a party (other than B) by M, F provides M with the private key of the party and any state information for current sessions and unexpired session keys at the party (specifically, F provides M with the session signatures corresponding to these sessions, not just the session keys). From the moment of corruption all actions of a corrupted party are decided by M (including the possible "registration" of a new public key for the party).</p><p>9. When M activates the t-th session at Â (i.e., the g-session), if the peer in the activation is not B then F aborts. Else, F provides M with the value X 0 (from F's input) as the outgoing value of Â in that session (this is done regardless of whether Â was activated as initiator or responder).</p><p>10. In addition in any of the following cases F aborts its run:</p><p>(a) M halts with a test session different than the g-session.</p><p>(b) M corrupts either Â or B. (Later, we will see that we can actually let M learn Â's private key, but for the moment it is simpler to assume that Â is never corrupted.)</p><p>(c) M exposes the g-session via a state-reveal or session-key query.</p><p>(d) M exposes the session matching to the g-session (if such session exists) via a state-reveal or session-key query.</p><p>11. If M halts with the g-session as its test session (in this case the test session has identifier ( Â, B, X 0 , Y 0 ) for some value Y 0 ) and with a guess π0 for the test signature, then F outputs the triple ( Â, Y 0 , π0 ) as a forgery of B's DCR signature on message m = Â (and challenge X 0 ). Else, if M outputs "fail" (i.e., no test session chosen) then F outputs "fail" as well.</p><p>Lemma 11 Assume that M has a non-negligible probability to correctly guess the test signature when either of cases C1-C3 holds, then the above forger F succeeds in forging B's DCR signatures with non-negligible probability.</p><p>The lemma is proved through Claims 12 and 13.</p><p>Claim 12 Let M be a forging attacker against protocol Π which succeeds with non-negligible probability when at least one of cases C1-C3 holds. Then there is a non-negligible probability that a run of M under F succeeds (i.e., ends with a correct guess for the value of the unexposed test signature).</p><p>Proof: By fixing a set of random coins for the attacker M and for each of the parties in protocol Π, together with a fixing of the random functions H and H, we obtain a deterministic execution of protocol Π. In particular, these fixed values fully determine the actions and view of M in that execution. In the sequel we refer to such a fixed execution as a run of M. In the case that M is run by F (as specified in the above description of F), then it is F that provides all of the random coins to M and to the protocol parties except for party B. The latter has its own random coins as represented by the random coins used by the signing oracle B. These sets of random coins determine a run of M under F that may be different than the run of M with the same coins in a real execution of the protocol. We say that a run of M under F is perfect if it is identical to the run of the real M under the same coins set by F and by oracle B. We claim that any run of M under F in which F does not abort is perfect. Indeed, one can see that the simulation of the run of M by F is perfect up to the point that F aborts (and thus a run in which F does not abort is perfect). To see this, consider first the simulation by F of actions related to uncorrupted players other than B. For these players F has full information and thus it runs all their actions (session activations, session exposures and party corruptions) exactly as in a real interaction with M. One possible deviation happens when M activates the g-session at Â: in this case rather than choosing an outgoing value X = g x for the session, F uses X 0 , received in F's input, as the outgoing value. However since X 0 ∈ R G then it has the identical distribution of a real X; moreover, since as long as F does not abort the g-session is not queried, then F does not need to take any action that would require the knowledge of the logarithm of X 0 .</p><p>It remains to consider the simulation by F of party B for whom F does not know the private key b, and therefore only runs it by using the signing oracle as a black box. Note, first that F does not need to provide b to the attacker since a corruption of B triggers an abort by F. Therefore, F only needs to simulate B's actions related to session activations and session exposures. However these two forms of actions are perfectly simulated by F using the signing oracle B. The resultant actions correspond exactly to the behavior of a real player B with public key B and random coins as those used by the oracle B.</p><p>So we've seen that non-aborting runs of F result in perfect runs of M. On the other hand, non-aborting runs of F happen only when M chooses its test session equal to the g-session (or when M fails without choosing a test session). Let's consider the triples (i, j, t) as used by F (in step 3) to choose the g-session. Let γ denote one specific triple (such a triple defines a unique session which may or may not be activated in a given run of M). From the above argument we have that all runs of M that end with the choice of session γ as the test session of M will result in perfect runs under F provided that F chooses γ as its g-session (since in this case F will not abort). In particular, this implies that for every value of γ: P rob (M succeeds in session γ under the run of F : F chooses γ as its g-session)</p><p>= P rob (M succeeds in session γ).</p><p>By "M succeeds in session γ" we mean that M outputs a correct guess for the session signature corresponding to session γ.</p><p>Since a run of M is successful (i.e., ends with a correct guess for the test signature) if and only if there is an (unexposed) session γ activated at this run for which M outputs a correct forgery (and since there are at most n 2 m possible values of γ) we get: P rob (Successful run of M under F) = = γ P rob (F chooses γ as the g-session AND M succeeds in γ under F) = γ P rob (M succeeds in γ under F : F chooses γ as the g-session) * * P rob ( F chooses γ as the g-session)</p><formula xml:id="formula_11">≥ (n 2 m) -1 γ P rob (M succeeds in γ) = (n 2 m) -1 P rob (M succeeds)</formula><p>Since by assumption, P rob (M succeeds) is non-negligible, when at least one of the cases C1-C3 holds, then the above bound on P rob (Successful run of M under F) is non-negligible.</p><p>2</p><p>Claim 13 If in a run of F, M outputs a correct guess for the test signature, then the output of F in that run is a correct and valid forgery against B's DCR signatures.</p><p>Proof: By construction, F outputs an attempted forgery against B's signatures each time that M, as run by F, completes its run and outputs a guess π0 for the test signature π 0 = π( Â, B, X 0 , Y 0 ). More precisely, in this case F outputs a forgery triple τ = (m = Â, Y 0 , π0 ) under the input challenge value X 0 . Clearly, the forgery is correct if π0 = π 0 which is the case by the claim's hypothesis.</p><p>Therefore, what remains to be shown is that the triple τ is a valid forgery, namely, that Y 0 = 0 and the pair (m = Â, Y = Y 0 ) never appeared in a signature issued by B in any of its invocations by F. The first condition, Y 0 = 0, holds since otherwise this value would have been rejected by Â as the incoming value to the g-session. As for the second condition, let's assume that π0 = π 0 and examine its validity under each of the three cases C1-C3.</p><p>Case C1: In this case the value Y 0 was never output in any of the signatures issued by B and therefore τ is clearly a valid forgery.</p><p>Case C2: Here, Y 0 was generated by B in session ( B, Â, Y 0 , X 0 ). However this session, being matching to the test session, was never queried by M (or F would have aborted without outputting a forgery), which in turn implies that F never queried B for the value of π( B, Â, Y 0 , X 0 ). Note that, by construction, F never queries the signature corresponding to a session in B except if this session is queried, via state reveal or session-key queries, by M. Since Y 0 was generated by B only for the above session (except for a negligible probability of accidental repetition) then no signature issued by B has this value of Y 0 . Thus, τ is a valid forgery.</p><p>Case C3: The value Y 0 was generated by B in relation to a session ( B, Â * , Y 0 , X * ) with Â * = Â.</p><p>Thus, if M queried this session then B did produce the signature π( B, Â * , Y 0 , X * ). However this is a signature of B with Y 0 on message m = Â * which is different than the message m = Â in the forgery τ . Hence τ is valid in this case too Summarizing, for each of the above cases, if M succeeds with non-negligible probability in that case, then with non-negligible probability F outputs a forgery triple τ which is correct and valid. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2.2">Forger F for Case C4</head><p>We now define a forger F that will succeed in forging B's DCR signatures provided that there is a non-negligible probability that M succeeds in a forgery attack under case C4. Recall that this case happens when M outputs a correct guess π 0 for the signature of the test session ( Â, B, X 0 , Y 0 ) and the value Y 0 was generated by B in another session ( B, Â, Y 0 , X * ) with X * = X 0 . We build the forger F following the same lines of the design of F, but with some important differences that we specify next.</p><p>1. In addition to choosing random values i, j, t as F does, F also chooses a number l ∈ R {1, . . . , m}. As before we denote P i and P j by Â and B, respectively. The choice of i, j, t represents a guess by F that the test session will be chosen by M as the t-th session activated at P i and that P j will be the peer to this session; the choice of l represents a further guess that the l-th session activated at B will be the session in which B generated Y 0 , i.e. this session will have identifier ( B, Â, Y 0 , X * ) for some X * = X 0 .</p><p>2. F aborts in the cases that F does, plus in the following two cases: (i) the l-th activation at B has a peer other than Â or it has X * = X 0 , and (ii) the incoming value fed by M to Â in its t-th session is different than the value Y 0 output by B in its l-th activation. (This guarantees that if F does not abort its run then the l-th activation of B resulted in a session ( B, Â, Y 0 , X * ) for some value X * = X 0 .)</p><p>3. The rest of F is the same as F except that in the l-th activation at B, F does not query the signer B but instead it chooses a random Y 0 and provides it to M as B's outgoing value for this session. If at any point M queries the session ( B, Â, Y 0 , X * ) (via a state reveal or session-key query) then F chooses a random value in {0, 1} k (the range of H) and answers M's query with that value. (Note that F never queries the signature π( B, Â, Y 0 , X * ).)</p><p>4. If M halts without having queried session ( B, Â, Y 0 , X * ) then F halts with same result as M, namely, if M fails so does F , and if M outputs a guess π0 for π( Â, B, X 0 , Y 0 ) then F outputs the triple ( Â, Y 0 , π0 ) as its forgery of B's signature on message m = Â (under challenge X 0 ).</p><p>5. If M halts after having queried session ( B, Â, Y 0 , X * ), F chooses a random bit β and proceeds as follows:</p><p>(a) Case β = 0. F halts and its output is determined exactly as in Step 4 above.</p><p>(b) Case β = 1. Rewinding step: F rewinds M to its state at the time it queried session<ref type="foot" target="#foot_7">8</ref> ( B, Â, Y 0 , X * ). This time, however, instead of answering this query by a random value, F chooses at random one of the queries to H produced by M, say v, and responds to the ( B, Â, Y 0 , X * ) query with H(v). (The query v is chosen among all queries by M to H including queries made after M queried the session ( B, Â, Y 0 , X * ) in the original run.) From this point F continues the normal running of M, which may end with F aborting or with M halting. In the latter case, the output of F is determined as in Step 4 above.</p><p>Note: In the above run of M by F it may happen that if M queries the session ( B, Â, Y 0 , X * ) the response by F is different than the actual value H(π( B, Â, Y 0 , X * )). This discrepancy relative to the real runs of M may cause M to run beyond the normal time bounds of M. Therefore, to be precise, we can specify that if M exceeds a certain (polynomial) running time then F stops and outputs failure.</p><p>Lemma 14 Assume that M has a non-negligible probability to correctly guess the test signature when case C4 holds, then forger F succeeds in forging B's DCR signatures with non-negligible probability.</p><p>The lemma is proved through Claims 15 and 16.</p><p>Claim 15 Let M be a forging attacker against protocol Π which succeeds with non-negligible probability in case C4, then there is a non-negligible probability that a run of M under F succeeds (i.e., ends with a correct guess for the value of the unexposed test signature).</p><p>Proof: As in Claim 12 we refer to a "run of M" as a fixed (deterministic) execution of the attacker M when we fix a set of random coins for M, for all the parties in the protocol, and for the random functions H and H. We will say that a run of M is of type-C4 if M outputs a guess (not necessarily a correct one) for the session signature of an unexposed test session ( Â, B, X 0 , Y 0 ) (chosen by <ref type="bibr">M)</ref> in which Y 0 was generated by B during a session ( B, Â, Y 0 , X * ) with X * = X 0 . Note that by the Claim's hypothesis, the attacker M has a non-negligible probability to succeed (i.e., guess correctly) in a run of type-C4. In particular, this implies that type-C4 runs occur with non-negligible probability in the runs of M. Also note that in type-C4 runs the session ( B, Â, Y 0 , X * ) is well-defined and unique (up to a negligible probability that B chose the same Y 0 for two different sessions).</p><p>We denote the test session ( Â, B, X 0 , Y 0 ) by s 0 , and the session ( B, Â, Y 0 , X * ) by s * . The test signature π( Â, B, X 0 , Y 0 ) is denoted by π 0 and the session signature π( B, Â, Y 0 , X * ) of session s * by π * . We will say that M queries session s * if M issues a state-reveal or session-key query against s * . We say that M queries H on π * if M presents the value π * explicitly as an input to H (therefore querying s * is not the same as querying H on π * even though the answer to both queries is the same).</p><p>We divide the type-C4 runs of M into three classes:</p><p>1. M does not query the session s * .</p><p>2. M queries session s * but does query H on π * .</p><p>3. M queries s * and also queries H on π * .</p><p>We proceed to analyze what happens to these runs in the executions of M under F . For the time being we are going to consider only executions of F in which F does not abort (i.e., in which M's run is of type-C4 and F guessed correctly the s 0 and s * sessions). First we need two observations from which we can see that the notion of a run of C4-type is well defined for runs of M under F .</p><p>The first is that following a similar argument as in the proof of Claim 12, in the non-aborting runs of F the simulation of the protocol actions carried by F for M are perfect except for (i) the response to the query to session s * , if such a query is presented by M, and (ii) the subsequent rewinding step, if performed. For the second observation we consider the runs of M under F that precede the rewinding step (or those in which this step is not performed at all). Note that in runs in which M queries s * before it queries H on π * (this includes runs where M does not query H on π * at all), the probability that M later queries H on π * is the same whether the response to the s * query was the real H(π * ) or a random value (indeed, at this point of the run these two responses are indistinguishable given the current view of M). Similarly, if M first queries H on π * , then the probability that it will later query s * is the same regardless of the random value used to answer H(π * ).</p><p>From the above two observations we obtain that the probability that M queries the session s * and/or queries H on π * is the same in the real runs of M than in the runs under F (and before carrying the rewinding step). Thus, the probability that a run of M under F (before the rewinding step) falls into any one of the three classes of C4-type runs is the same as the probability that a real M run fall in this case.</p><p>Let's now consider how the behavior of M when run under F differs from a real run of M in each of the three classes of C4-type runs. (Remember that we are considering only non-aborting executions of F .) In the first class the run of M by F is identical to a real run (since none of the differences (i) or (ii) exist). In the second case, if β = 0 then the run of M under F is identical to a real run since as long as M does not query H on π * then the random response of F to the s * query is indistinguishable from any other random value. Finally, for the third class we consider the case that β = 1 and F happens to choose the query v by M such that v = π * (there is a non-negligible probability, at least 1/Q, that this happens since we are considering the case that at least one of the Q queries made by M to H during its run was the value π * ). In this case, if we consider the "hybrid" run by M as the one composed of the execution preceding the query by M of session s * followed by the execution of M after the rewinding step, we get that this run is identical to the corresponding run of the real M (in which the query to s * is answered with the correct value H(π * ) <ref type="bibr">)</ref>.</p><p>In all, we have that for each class of type-C4 runs the probability of such runs under F is the same as in a real execution of M, and that there is a non-negligible probability (over the choice of β and of the query v in the rewinding step) that the behavior of M in these runs under F is identical to the corresponding runs in a real execution of M.</p><p>Thus, since there is a non-negligible probability that a type-C4 run of (the real) M will be successful, then there must be at least one class of C4-type runs in which the probability of success of M is also non-negligible. But then, by the above argument, the latter is true also for this class of runs under F . We thus conclude that, in the non-aborting runs of F , M as run by F has non-negligible probability of success.</p><p>All we need in order to conclude the proof is to observe that, by an argument similar to the one in the proof of Claim 12, for each type-C4 run of M there is a non-negligible probability (i.e., 1 over the number of quadruples (i, j, t, l) chosen by F in Step 1), that this run under F is non-aborting. Thus, the conditioning on non-aborting runs in the above arguments holds with non-negligible probability, and then the overall probability that the run of M under F outputs a successful forgery is non-negligible.</p><p>2</p><p>Claim 16 If in a run of F , M outputs a correct guess for the test signature, then the output of F in that run is a correct and valid forgery against B's DCR signatures.</p><p>Proof: In the case that M outputs the correct guess π 0 for the test session ( Â, B, X , Y 0 ) under a run of F , F outputs a forgery against B's signatures of the form τ = (m = Â, Y 0 , π 0 ), under the input challenge value X 0 , which is correct since M's guess was correct. Therefore, it remains to show that when case C4 holds this forgery is also valid. That is, that Y 0 = 0 and the pair (m = Â, Y = Y 0 ) never appeared in a signature issued by B in any of its invocations by F . The first condition, Y 0 = 0, holds since otherwise this value would have been rejected by Â as the incoming value to the g-session. As for the second condition, we know that the only session in which B used Y 0 is the session s * = ( B, Â, Y 0 , X * ). Thus the only signature that could have possibly used Y 0 is the session signature π * = π( B, Â, Y 0 , X * ). However, this signature was never queried by F . Indeed, even if M queried the session, F answered this query by a random value (Step 3) or by a previous output of H (Step 5b), with no invocation to B. Thus the forgery triple τ is a correct and valid forgery by F against B's signatures. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Infeasibility of Key-Replication Attacks</head><p>As introduced and motivated in Section 5.2.1 a successful key-replication attack is one in which the attacker, acting as a KE attacker, has as its goal to force the establishment of two different, non-matching, sessions that output the same session key, and in which one of the two sessions (we will refer to it as the "test session") is unexposed. Note that if an attacker succeeds in such an attack against Π, it can easily find the session key of the test session by querying the second session containing the same key (this is allowed since the sessions are non-matching). <ref type="foot" target="#foot_8">9</ref> .</p><p>In this section we prove that key-replication attacks are infeasible against protocol Π by showing that such a successful attacker would contradict the security of DCR signature. For this we use the same forgers F and F built in Section 5.2.2. Specifically, we show the following:</p><p>Lemma 17 If an efficient attacker, M, succeeds in a key-replication attack against Π with nonnegligible probability then one of forgers F or F constructed above is a successful forger against the DCR signature scheme.</p><p>Proof: Assume that attacker M is successful in a replication attack against the (unexposed) test session denoted by s = ( Â, B, X 0 , Y 0 ). Namely, M succeeds in establishing a session s = ( Â , B , X , Y ) which has the same key as ( Â, B, X 0 , Y 0 ) (and this session is different than ( Â, B, X 0 , Y 0 ) and ( B, Â, Y 0 , X 0 )). This means that (except of a negligible probability of collision in the output of H) π( Â , B , X , Y ) = π( Â, B, X 0 , Y 0 ).</p><p>Let's now consider the four cases C1-C4, described in Section 5.2.2, concerning the generation of the value Y 0 in the test session s. Since these four cases cover all possible ways to generate Y 0 during the protocol, then there must be (at least) one of these cases in which M wins the keyreplication attack with non-negligible probability. Assume, first, that this non-negligible probability of success holds for any of the first three cases C1-C3, and consider the forger F built above and its interaction with the key-replication attacker M. Recall that, by construction, F provides M with the session signatures of exposed sessions (not just the session keys). Therefore, if M is able to succeed in a key-replication attack then it can query the session s (which M is allowed to expose) and obtain the signature π = π( Â , B , X , Y ) from F. But this means that M is able to find the test signature π( Â, B, X 0 , Y 0 ) (which is the same as π ) without exposing the test session or its matching session. But as we showed, in this case F succeeds in outputting a valid forgery against B's signatures.</p><p>Let's now consider case C4. Observing the construction of F , we note that F provides M with the session signatures (not just the session keys) for any exposed session other than session ( B, Â, Y 0 , X * ). Thus, by the same argument above, if M is able to force the same key as the test session in a non-matching session other than ( B, Â, Y 0 , X * ) then M is able to win the forging game, and F succeeds as a forger against B's signatures. We are then left with the possibility that the session ( B, Â, Y 0 , X * ) had the same key as ( Â, B, X 0 , Y 0 ). This however is not possible since for X * = X 0 it must be that π( B, Â, Y 0 , X * ) = π( B, Â, Y 0 , X 0 ) = π( Â, B, X 0 , Y 0 ) and thus the two session keys are different (except for a negligible probability of collision in the output of H on these two different input values).</p><p>2</p><p>This completes the proof of Lemma 10 which, together with Lemma 9 and Lemma 24 (the latter proven in the next section), completes the proof of Theorem 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Further Security Properties of the HMQV Protocol</head><p>In the previous section we have proved that the HMQV protocol enjoys the essential security properties captured by the formal model of <ref type="bibr" target="#b10">[11]</ref> (and outlined in Section 2). This definition guarantees the essential security properties of a key-exchange protocol, namely, that a party that completes a session has the guarantee that (i) if the peer to the session is uncorrupted then the session key is not known to anyone except this peer, and (ii) if the peer completes a matching session then the two have the same shared key. These properties are guaranteed even if the attacker has corrupted other parties in the system and/or the attacker have learned secret information from other sessions. Most importantly, as shown in <ref type="bibr" target="#b10">[11]</ref>, this security definition is all that is needed to ensure that the communications between the session peers, when protected with the exchanged key (via symmetric encryption and MAC function), are secure.</p><p>In some applications and scenarios, however, there are additional properties of a key-exchange protocol that one may be interested to have. In this section we consider the properties and examine if they apply or not to HMQV.</p><p>As a result we have the following comprehensive extension of Theorem 8.</p><p>Theorem 18 Under the CDH assumption and in the random oracle model, the HMQV protocol as defined in Section 5.1 is secure in the Canetti-Krawczyk model (outlined in Section 2) and in addition it enjoys the following properties: Resistance to KCI attacks, weak forward secrecy, and resilience to the leakage of ephemeral secret DH exponents (the last property proven in Section 7 under the Gap Diffie-Hellman and KEA1 assumptions).</p><p>The definition and proof of the above additional properties is presented in the following subsections. Resilience to leakage of ephemeral DH exponents requires a more extensive treatment and is presented in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Resistance to KCI Attacks</head><p>A basic principle guiding any security formulation for key-exchange protocols is that the leakage of ephemeral information associated with a particular session (e.g., its session key or state) does not compromise other sessions. As pointed out before, this property is indeed ensured by our security definition. On the other hand, this definition provides no guarantee for sessions exchanged by, or with, corrupted parties. Yet, in practice, it is important to confound the damage of key leakage even when this leakage concerns the long-term private key of a party. In this, and next subsection, we discuss two security notions that extend our basic model and deal precisely with limiting the damage of leakage of long term private keys. We start by observing that when an attacker learns the private key of a party Â, our model considers that party to be under the full control of the attacker, and all the sessions established by that party are deemed insecure. This, however, is a simplification of practical scenarios in which it is possible that the private key of Â is compromised, yet the attacker does not actively control Â (e.g., it does not have access to Â's computer). In such a situation, while there is nothing to prevent the attacker from running its own key exchange session in the name of Â, one would like to ensure the security of the sessions established by Â itself while not being actively controlled by the attacker.</p><p>An example of this type of security is the so called resistance to key-compromise impersonation (KCI). This notion has been postulated in many works as a desirable property of (public-key based) key-exchange protocols and, in particular, it has been stated as one of the advantages of the MQV protocol over other protocols. Informally (as this property has not been formalized before) a keycompromise impersonation is deemed successful if the attacker, knowing the private key of a party Â is able to "impersonate" other, uncorrupted, parties to Â. Here, we first formalize this notion and then prove it to hold in the case of HMQV. <ref type="foot" target="#foot_9">10</ref> For this we first introduce the following definition: <ref type="bibr">Definition 19</ref> We say that a completed session of a key-exchange protocol is clean if the attacker did not have access to the session's state at the time of session establishment, nor it issued a session-key query against the session after completion.</p><p>When considering sessions at uncorrupted parties the definition of clean session is equivalent to saying that the attacker did not issue a state-reveal query while the session was incomplete or a session-key query after completion. However, when considering an attacker that learned the longterm private key of a party, this notion is more general and it implies that the attacker was not actively controlling or impersonating the party during the session establishment (neither by making any choices on behalf of that party in that session or eavesdropping into the session's state). Note that in the case of HMQV, a clean session is one in which the attacker does not choose the outgoing value of the session, nor it issues a session-key query against it.</p><p>Definition 20 We say that a KE-attacker M that has learned the private key of party Â succeeds in a Key-compromise impersonation (KCI) attack against Â, if M is able to distinguish from random the session key of a complete session at Â for which the session peer is uncorrupted and the session and its matching session (if it exists) are clean.</p><p>In other words, the definition says that as long as the attacker is not actively controlling or observing the secret choices made for the generation of the session then, even the knowledge of Â's private key does not allow M to compromise the session key. In particular, in such a protocol M cannot impersonate an uncorrupted party B to Â in a way that allow M to learn (any information about) the resultant session key.</p><p>Lemma 21 Under the CDH assumption, the HMQV protocol resists key-compromise impersonation (KCI) attacks.</p><p>Proof: All is needed is to note that the proof of HMQV in Section 5.2 holds even if we assume that the attacker M is given the private key of Â. The only change to the proof is that in the description of forger F (step 10b) we now remove the corruption of Â as a reason for F to abort. The proof remains valid since (i) as proven in Theorem 7 the DCR signatures of B with challenger Â remain secure even if the private key of Â is known, and (ii) the above abort operation is never used in the proof (we added it for ease of presentation and for compliance with the notion of session exposure in the basic security model). Also worth noting is that in the proof the outgoing value X 0 in the test session is provided in the input to F and then not chosen by M (thus ensuring that the session is clean).</p><p>2</p><p>As shown in Section 3.3, ensuring resistance to KCI attacks requires that the attacker does not learn the DCR signature produced in the protocol which explains the need to define the session key in HMQV as the hash of this signature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Perfect Forward Secrecy (PFS)</head><p>Another important notion that provides a security guarantee of key-exchange sessions in the case that the attacker has learned the private keys of some parties is Perfect Forward Secrecy (PFS).</p><p>Informally, a key-exchange protocol is said to have the PFS property if the leakage of the long-term key of a party does not compromise the security of session keys established by that party, and erased from memory, before the leakage occurred. A formal definition of PFS in the context of the model from Section 2 appears at the end of that section. As it turns out, HMQV (nor the original MQV) protocol achieve this property. Moreover, as shown in Section 3.2, no 2-message protocol can achieve PFS (as long as there are no means, such as a secure state shared by the parties in a previous exchange, to authenticate the first message and avoid its replay). Note that, nonetheless, HMQV does provide a weak form of forward secrecy: If the attacker is not actively involved with the choice of the X, Y values at a session (specifically if it does not get to choose or learn the exponents x and y) then the resultant session key does enjoy forward secrecy. While certainly weaker than the usual PFS, this guarantee of forward secrecy is still significant in practice where the mounting of active attacks is harder than simple recording past communications and can usually be performed on a smaller number of sessions. This (unavoidable) weakness of the 2-message HMQV protocol can be solved by adding a third message to the protocol and a key confirmation mechanism as shown in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 22</head><p>A key-exchange protocol provides weak PFS (wPFS) if an attacker M cannot distinguish from random the key of any session for which the session and its matching session are clean even if M has learned the private keys of both peers to the session.</p><p>Note that in the regular definition of PFS (Section 2) one assumes that the session was established at the time that both Â and B were uncorrupted and the attacker only learns the private keys of these parties at a later point after the session key has already expired and erased from memory. In the above formulation, the security guarantee is provided even if the attacker learned the private keys before the session was established, as long as the session (and its matching one) are clean. Of course, this comes at the cost of assuming that the attacker was passive during the session establishment.</p><p>Lemma 23 Under the CDH assumption, protocol HMQV provides weak PFS.</p><p>Proof: We only outline the idea of the proof and omit the details that can be completed following the proof from Section 5.2. Given an attacker M that breaks the wPFS property, we construct a CDH solver C as follows. (An important difference between this case and the proof from Section 5.2 is that here we use M to directly build a CDH solver rather than building a DCR forger.) Let X = g x and Y = g y be the inputs to C; the goal of C is to compute g xy . C runs M against a virtual execution of the protocol in which C chooses all parties' private keys, and also chooses a random guess for the test session against which M succeeds in its wPFS attack. We call this guessed session the g-session and denote its peers by Â and B (and their private keys by a and b, respectively). C then uses the input values X, Y as the incoming and outgoing messages in the g-session. If the attacker does choose the g-session as its test session and M distinguishes its session key from random (both events happen simultaneously with non-negligible probability) then the following must be true. In order to be considered successful M cannot modify the X, Y values in the test session (otherwise the session is not clean). Hence the established key is H(π 0 ) for π 0 = g (x+da) (y+eb) , and for distinguishing H(π 0 ) from random M must output at some point in its run the value π 0 . Now, with the knowledge of a and b, C can compute g xy out of π 0 . 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Reflection Attacks</head><p>In the analysis of protocol HMQV we have assumed that the peers Â and B in the test session are different (see Step 3 in the description of forger F in Section 5.2). In some scenarios, however, a party may want to establish a secure channel with itself (for example, a mobile user that communicates to its desktop computer, while both the mobile device and the desktop have the same identity in the form of the same digital certificate). Here we show how to extend the analysis of Section 5.2 to include such scenarios. In particular, we show that HMQV resists the so called reflection attacks in which the attacker simply copies Â's authentic messages and sends them back to Â as the messages coming from the other copy of Â. The technical difficulty in achieving this result is that we are now concerned with test sessions of the form ( B, B, X 0 , Y 0 ), that is, sessions in which Â = B. When we apply the analysis of Section 5.2 to this case we get that if an attacker can successfully win the distinguishing test against the above test session then we can build a forger F against the dual signature DSIG B, B (m 1 = B, m 2 = B, X 0 , Y 0 ) where X 0 is the value input to F (as the challenge on which to forge the signature) and Y 0 is chosen by F. The problem, however, is that we have not shown that such forgers do not exist. Indeed, Theorem 7 only guarantees the security of DCR signatures with peers Â = B. Consequently, we outline here an extension of the proof of Theorem 7 that will allow us to claim the infeasibility of a forger F as above, and then also the infeasibility of a KE-attacker that wins the distinguishing test.</p><p>The difficulty in extending the proof of Theorem 7 to the case Â = B is that the proof of the theorem assumes that the private key a of Â is known to the forger and to the CDH solver C (the value of a is required in the computation of W in Equation ( <ref type="formula" target="#formula_8">1</ref>) in order to get rid of the factor A d in that computation). Here a is unknown since a = b and the latter is secret. Thus, if we apply the same reduction as in Theorem 7 we get a solver C that computes (X 0 A d ) b rather than X b 0 as needed for deriving CDH(U, V ). An "obvious" fix is to change the way C sets X 0 in Figure <ref type="figure" target="#fig_4">4</ref> from X 0 = U to X 0 = U/A d . This, however, requires knowing the value of d = H(X 0 , m 1 ) at the onset of F's activation which is not necessarily the case in general (indeed, F can choose the value m 1 that determines d much later in the game). Fortunately, in the case of interest here (that considers a specific signature of the form DSIG B, B (m 1 = B, m 2 = B, X 0 , Y 0 )) the value m 1 is not chosen by F but rather fixed to m 1 = B. Thus both m 1 and X 0 are known in advance and thus we can specify C to set X 0 = U/A d . There is, however, one more obstacle: if the forger F chooses Y 0 to be X 0 then we get d = H(X 0 , B) = H(Y 0 , B) = e, and therefore the value d changes, in the description of C in Figure <ref type="figure" target="#fig_4">4</ref>, before and after the repeat experiment. In this case setting X 0 = U/A d does not allow computing W .</p><p>On the basis of the above discussion we can now go back to the security analysis of protocol HMQV in the case that the attacker M is assumed to win the distinguishing game with a test session ( B, B, X 0 , Y 0 ). We consider two cases:</p><p>Case I: X 0 = Y 0 . In this case the proof from Section 5.2 extends to show the existence of a forger F that forges B's dual signatures DSIG B, B (m 1 = B, m 2 = B, X 0 , Y 0 ) for X 0 = Y 0 . Thus, following the above discussion, we build a CDH solver C that runs the forger F as in Figure <ref type="figure" target="#fig_4">4</ref> except that C:</p><p>1. Chooses a random value d in {0, 1} (the range of H).</p><p>2. Sets X 0 = U/B d and B = V (remember that U, V are the inputs to C and here A = B).</p><p>3. Sets H(X 0 , m 1 ) to the value d.</p><p>The rest of C is unchanged, including the same calculation of W as in Figure <ref type="figure" target="#fig_4">4</ref> which results in C solving CDH(U, V ).</p><p>Case II: X 0 = Y 0 . In this case a fix of C as above does not work since, as pointed out, the value of d before and after the repeat experiment changes. To solve this issue we have two approaches. The first is to change the specification of HMQV such that the definition of the values d, e has a "directional indication": for example, define d = H(X, Â, "0") and e = H(Y, B, "1") (here "0" and "1" are used by the initiator and responder of the session, respectively). This guarantees that, even if X 0 = Y 0 , the value d does not change before and after the repeat experiment, and therefore the argument in Case I holds here too, showing that the protocol is secure in the case X 0 = Y 0 too.</p><p>The second approach shows that the above modification to HMQV is not necessary. For this, observe that when X 0 = Y 0 then these values are chosen by the uncorrupted B and therefore we are in a situation similar to that of Section 6.2 in which the Diffie-Hellman values are chosen in "clean sessions". Specifically, by applying the argument in the proof of Lemma 23 one can show how to transform an attacker that can distinguish the key of session ( B, B, X 0 , X 0 ) from random into a CDH solver. In this case, however, we can only guarantee this solver to work on inputs X, Y with X = Y . In other words, we can build an algorithm that given g x 0 computes g x 2 0 . But, as observed by Maurer and Wolf <ref type="bibr" target="#b29">[31]</ref>, such an algorithm can in turn be used to solve the general CDH problem (namely, where the inputs are arbitrary values X, Y in G).</p><p>Summarizing the above we have the following lemma:</p><p>Lemma 24 Under the CDH assumption, sessions established in the HMQV protocol between an uncorrupted peer and itself are secure. In particular, successful reflection attacks are not feasible.</p><p>We note that this lemma together with Lemmas 9 and 10 completes the proof of Theorem 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">HCR Signatures and Resilience to Leakage of DH Exponents</head><p>As we have stated repeatedly, a main security requirement for key-exchange protocols is to confine the damage caused by the leakage of session-specific ephemeral information to the compromised session only (and its matching session, if it exists). In particular, Diffie-Hellman protocols should ensure that the leakage of ephemeral DH exponents does not affect the security of sessions where this exponent is not used. A good illustration of a protocol not having this property is the signaturebased 2-message protocol discussed at the beginning of Section 3.1. In that case, stealing the value of a DH exponent from a single session between Â and B suffices for the attacker to impersonate Â to B forever, and without having to learn anything about Â's or B's private keys.</p><p>The present section is devoted to showing the robustness of the HMQV protocol against such ephemeral leakage of Diffie-Hellman exponents. We show that disclosing to the attacker the exponent used in an HMQV session has no bearing on the security of other sessions. Formally, we show that even if the ephemeral session DH exponents are stored in the session's state, the protocol remains secure in the face of state-reveal queries through which the attacker learns these exponents. Moreover, resilience to the leakage of ephemeral DH exponents is important to protect a party that pre-computes pairs (y, g y ) for use at later sessions (pre-computation reduces the on-line cost of the protocol to 1.5 exponentiations). Discovering such a pair helps the attacker in two ways: learning y and being able to predict which value of g y will be used in a session. We show that the best protection against such an attacker is obtained by adding the parties' identities to the key derivation hashing or by adding an unpredictable nonce to the protocol messages.</p><p>A significant technical point that is worth noting is that resilience to the disclosure of ephemeral DH exponents does not follow from the analysis in Sections 5 and 6. That analysis refers to the formal specification of HMQV in Section 5.1 which did not allow for the storage of ephemeral exponents in the session state (thus requiring that ephemeral exponents be as protected as the long term private key). Moreover, the fact that the attacker is not allowed to see these ephemeral exponents is used in an essential way in that analysis. This is so since the proof of unforgeability of XCR signatures (in Section 4. <ref type="bibr">2)</ref>, on which the security of HMQV relies, does not carry on to the case in which the attacker learns an ephemeral value y used by the signer B in one of its signatures. Indeed, observe that in the simulation of B's signatures performed by the CDH solver C in Figure <ref type="figure" target="#fig_4">4</ref> (specifically steps S1-S3) the simulator does not know the value y (and thus cannot present it to F if such a value is queried). Consequently, the analysis of HMQV in Section 5.2 that builds on the security of XCR signatures does not apply to the case where the ephemeral DH exponents are revealed.</p><p>To overcome this problem we are going to consider in this section a "hashed variant" of XCR signatures (which we call HCR signatures) that we prove to be unforgeable even if the exponents y used by the signer in its signatures are provided to the forger. On the basis of these signatures we are able to claim the security of HMQV even in the face of leaked DH exponents. This, however, requires replacing the CDH assumption used in our previous analysis with two substantially stronger assumptions that we recall below: Gap Diffie-Hellman and KEA1. Yet, we emphasize that these stronger assumptions are not needed for any one of the other properties proven to hold for HMQV (this is the main reason to treat the resilience to DH exponents separately).</p><p>Definition 25 <ref type="bibr" target="#b35">[37]</ref> Let G be a cyclic group generated by an element g. We say that a decision algorithm O is a Decisional Diffie-Hellman (DDH) Oracle for a group G and generator g if on input a triple (X, Y, Z), for X, Y ∈ G, oracle O outputs 1 if and only if Z = CDH g (X, Y ). We say that G satisfies the Gap-Diffie-Hellman (GDH) assumption if no feasible algorithm exists to solve the CDH problem, even when the algorithm is provided with a DDH-oracle for G.</p><p>What this assumption says is that in the group G computing CDH(X, Y ), for X, Y ∈ R G, is strictly harder than deciding if a given Z equals CDH(X, Y ).</p><p>The following assumption was first stated and used in <ref type="bibr" target="#b13">[14]</ref>; it was re-defined and further studied in <ref type="bibr" target="#b17">[18,</ref><ref type="bibr">4]</ref>. The name KEA1 (where KEA stands "knowledge of exponent assumption") is from <ref type="bibr">[4]</ref>. The statement of the assumption presented next is somewhat informal; please refer to the above works for the details. The KEA1 assumption captures the intuition related to the difficulty of the Diffie-Hellman problem by which the "only way" to produce a pair of the form (C, C b ) when all is given is a pair (g, g b ), where g is a generator of a group of prime order q, is to choose c ∈ Z q and compute (g c , (g b ) c ).</p><p>Definition 26 <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr">4]</ref> Let G be a cyclic group of prime order q generated by an element g, and consider algorithms that on input a pair (g, g b ) output a pair (C, D) in G 2 . Such an algorithm E is said to be a KEA1 algorithm if with non-negligible probability (over the choice of b and E's random coins) E(g, g b ) outputs (C, D) such that D = C b . We say that the KEA1 assumption holds over G if for every efficient KEA1 algorithm E in G there exists another efficient algorithm E for which the following property holds except for a negligible probability: let (g, g b ) be an input to E and ρ a vector of random coins for E on which E outputs (C, D = C b ) then on the same inputs (and random coins) E outputs the triple (C, D = C b , c) where C = g c . The rest of the section is organized as follows: Section 7.1 introduces HCR signatures and their security requirements; Section 7.2 proves the unforgeability of these signatures under the above assumptions; Section 7.3 deals with the case in which a DH value Y used in a signature is known in advance by the forger. Finally, Section 7.4 uses these results to prove the resilience of HMQV to the leakage of ephemeral DH exponents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">HCR Signatures</head><p>Here we introduce Hashed XCR signatures (HCR, for short) defined exactly as XCR signatures except that instead of a pair (Y, σ) as output by regular XCR signatures (on input message m and challenge X), the HCR signature outputs (Y, H(σ)) where H outputs k bits (same output length as used in producing the key in the HMQV protocol). The computation of σ by a signer B with public key B = g b is exactly as in XCR, namely, σ = XSIG(Y, m, X) = X y+eb , where e = H(Y, m) is of length bits. We denote the modified signature by HSIG, i.e., HSIG(Y, m, X) = H(X y+eb ). Note that in spite of the hashing of σ such a signature can be verified by the challenger that knows the dlog of X; in particular, the HMQV protocol uses such signatures. Our main motivation to consider HCR signatures (in addition to XCR ones) is that they enjoy the property of being unforgeable even if the attacker knows the ephemeral exponent y corresponding to Y = g y . <ref type="foot" target="#foot_10">11</ref>In order to formalize this property in a way that is applicable to the security analysis of HMQV we modify the forgery game from Figure <ref type="figure" target="#fig_3">3</ref> and present the modified game in Figure <ref type="figure">5</ref>. In this new game we are making the task of the forger F harder by providing it with only a hashed version of XCR signatures, but at the same time making it easier for F by disclosing to it the exponent y used by B to compute each signature component Y = g y . Moreover, we will accept a forgery (Y 0 , m 0 , HSIG(Y 0 , m 0 , X 0 ) as valid even if F is unable to compute y 0 = log g (Y 0 ). We also let F choose its challenge value X presented to the signer only after the signer disclosed its value y for the signature. As we pointed out in Remark 4.3, this modified order of interaction captures the interaction induced by the HMQV protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Unforgeability of HCR signatures</head><p>Lemma 27 Under the GDH and KEA1 assumptions, the HCR signature scheme is secure in the random oracle model, namely, no efficient forger can succeed with non-negligible probability in the forgery game of Figure <ref type="figure">5</ref>.</p><p>Proof: Let F be a forger against HCR signatures that wins with non-negligible probability the forgery game of Figure <ref type="figure">5</ref>. We will use such F to build a successful CDH solver C which is equipped with a DDH oracle, thus contradicting the Gap Diffie-Hellman assumption. The general structure of C is similar to the CDH solver built in the proof of Theorem 5 and presented in Figure <ref type="figure" target="#fig_4">4</ref>, yet it 1. Forger F is given values B, X 0 where B, X 0 ∈ R G. 4. F is allowed a polynomial number of signature queries (as in <ref type="bibr">3)</ref> to B where the queries are chosen (possibly adaptively) by F. We allow for the interaction steps from different signature queries may be interleaved. (This is why B records incomplete and complete triples.)</p><p>5. F halts with output "fail" or with a guess in the form of a triple (Y 0 , m 0 , r).</p><p>F's guess is called a successful forgery if the following two conditions hold:</p><p>(a) The pair (Y 0 , m 0 ) did not appear in any of the responses of B to F's queries and Y 0 = 0.</p><p>(b) r = HSIG B (Y 0 , m 0 , X 0 ) (where X 0 is the value provided as input to F).</p><p>We say that F wins the game (or simply forges) if it outputs a successful forgery.</p><p>Figure <ref type="figure">5</ref>: Forgery Game for HCR Signatures has some important differences resulting from a different way to simulate the signer's answers. In particular, in the present case C does not need to simulate the computation of the signature value σ but just return a random value for H(σ). The problem is how to provide consistent answers to the forger F. For example, if C returns a random value r as the value of H(σ), where C does not know the actual value of σ, and later F queries H on the explicit value σ (which F may be able to compute if it chose the challenge x) how does C know to return the same value r? It is for this purpose that we need to use a DDH oracle (which is also why we need to assume the Gap DH assumption). The full description of C is presented in Figure <ref type="figure">6</ref>.</p><p>We now analyze the behavior of C. First note that the simulation of the signer B by C is perfect except for the negligible probability that the input (Y = g y , m) was queried from H before C chose Y . However, since this choice by C is done independent of previous computations, then the probability that (Y, m) was queried earlier is at most Q/q where Q is the number of H-queries in the whole simulation. It is also worth noting the essential use of the DDH oracle needed to check whether the value of a signature σ = X y+be was previously presented as input to the oracle H. This is required since if F chose the challenge X = g x knowing x then it can compute the actual value of σ and therefore it can query H on σ. For the simulation to succeed, C must make sure that it answers the H query and the simulated output of the HCR signature consistently. The same argument holds for the consistency check of other H-queries.</p><p>then the security of the scheme depends on the quantity O(min{N 2 , Q 2 }2 -) rather than 2 -as before. When the space of possible messages (in the case of HMQV this is the space of possible identities) is small or when |q| is large enough (e.g., |q| = 255 as mandated in <ref type="bibr" target="#b34">[36]</ref>) the above bound may be considered sufficient for dealing with this limited threat (see Remark 7.2). In other cases, however, one may want to strengthen HCR signatures against such leakage; we discuss several possible approaches. One, of course, is to increase . This however has a negative impact on the performance of HCR signatures (and their application to the HMQV protocol). A more efficient solution to the above problem is that instead of computing the exponent e as H(Y, m) one could compute e = H(Y, m, ν) where ν is a nonce chosen by the signer at the time of signing and transmitted to the verifier as part of the signature.</p><p>Yet another solution, probably the most simple and economical, is to keep small, dispense of ν, and just include the value of the message m under the final hash. That is, instead of computing the HCR signature as H(σ), one would compute it as H(σ, m). In this case, the success probability of the above attack on an a-priori known Y would reduce to min{N 2 , Q 2 }2 -( +k) . If we consider a typical case (e.g., the use of HCR signatures in HMQV) where ≥ 80 and k ≥ 128 then the level of security achieved by including m under the hash as above is perfectly satisfactory (like a birthday attack on a 208-bit hash function). In Section 7.4 we will discuss the possible effect of such a change to the security and specification of HMQV.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Application to HMQV: Resilience to the Leakage of DH Exponents</head><p>Here we show how the resilience of the HMQV protocol to the disclosure of ephemeral DH exponents follows from the proven security of HCR signatures. We first consider the case in which a party to a session generates the ephemeral DH value, say Y = g y , during the run of the session and stores the exponent y in the session's state. In this case an attacker M can find the value y by breaking into the session's state (formally, via a state-reveal query). Later, we will consider the case in which the DH value Y is pre-computed ahead of the session in which it is used.</p><p>Lemma 29 Under the GDH and KEA1 assumptions, protocol HMQV remains secure in the random oracle model even if session states are specified to store the secret exponent of the session's outgoing value. That is, learning the exponent of an ephemeral DH value used in a session via a state-reveal query does not help the attacker M in breaking other sessions (not even the session that uses the leaked ephemeral exponent).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof (sketch):</head><p>The lemma follows from Lemma 27 in a way similar to the proof of Lemma 10 (Section 5.2), namely, by showing how to construct a successful forger F in the game of Figure <ref type="figure">5</ref> given a successful HMQV attacker M which is allowed to learn ephemeral DH exponents via statereveal queries. As usual, F will orchestrate a run of the HMQV protocol, in which the signing oracle B is used as one of the parties, and will run M against this simulated protocol. The difference with respect to previous such constructions of F is that we assume an attacker M that is allowed to learn, via state-reveal queries, the values of ephemeral exponents y (corresponding to DH values Y = g y exchanged in the protocol). Specifically, F needs to be able to provide these values for any session held at an uncorrupted party (except for the test session and its matching session). For uncorrupted parties other than B, F itself chooses these exponents so it can provide them to M. In the case of B, F receives the exponents y directly from B, as part of B's HCR signatures, and therefore it can provide these values to M if M queries them. In the case of state-reveal and session-key queries against sessions held at B, F can also provide to M the value of the corresponding session keys since these are exactly the output of HCR signatures. As in the original proof in Section 5.2, the run of M by F is indistinguishable from a real run of M and therefore when F happens to guess the test session and M outputs a correct forgery for the test signature, then F can use this test signature as a forgery against B. Thus, if M succeeds with non-negligible probability against HMQV, the constructed F succeeds also with non-negligible probability to forge HCR signatures. A final technical point is that since HMQV uses dual HCR signatures, in which the challenge X is replaced with XA d for d = H(X, m), then in the above forgery game we have to replace challenges X with XA d for A = g a and d = H(X, m). However, since the above proof works even in case that the attacker knows a then forging a signature with challenge XA d is equivalent to forging it with challenge X. (Similarly to the modified computation of W (in this case, relative to Figure <ref type="figure">6</ref>) as in the proof of <ref type="bibr">Theorem 7)</ref>. 2</p><p>Remark 7.1 (Security of sessions that use a compromised DH exponent.) The proof of Lemma 29 shows that even if M learns the value y corresponding to a test session ( Â, B, X, Y = g y ), M cannot distinguish the session key from random (this holds even if M knows Â's private key a).</p><p>In addition, it is possible to show that if both private keys of Â and B are unknown to M and Â completes a session ( Â, B, X, Y ) with values X = g x , Y = g y chosen by Â, B, respectively, then even if M knows x and y, the session key remains secure. The proof for the latter case consists of showing how to use an assumed successful attacker M in order to build a CDH solver that computes CDH(A, B). We sketch this idea: Given inputs A, B, the solver C for CDH(A, B) will run M against a setting of the HMQV protocol in which two of the parties (call them Â, B) are provided with public keys A and B, respectively. The simulation of Â and B (for which C does not know the private keys) uses the simulation of HCR signatures (helped by a DDH-oracle as before). If M succeeds in a test session ( Â, B, X, Y ) for which the exponents x, y are chosen by C on behalf of A, B (and possibly known to M) then M must query the dual signature g (x+da)(y+eb) from the oracle H. From this value, and using the knowledge of x, y, d, e, the solver C derives CDH(A, B) = g ab .</p><p>We proceed to analyze the case in which the exposure of the exponent y (or even g y ) happens before its use in a session. The security of the protocol in this case also follows from the unforgeability of HCR signatures. However, the setting that we need to consider is the one analyzed in Section 7.3, namely, in which the value g y to be used in a session (or a signature) is known to the attacker in advance. As discussed there, in cases where is small and the space of messages (i.e., identities) is large, one may want to add an (unpredictable) nonce to the signature or to hash the signed message together with the hashing of σ. This results in two possible variants of HMQV:</p><p>1. When Â sends X = g x to B she also sends a random nonce ν Â (where ν Â cannot be predicted by M before it is sent). Similarly, B will respond with Y = g y and its own unpredictable nonce ν B . The exponents d and e are computed as H(X, B, ν Â) and H(Y, Â, ν B ), respectively.</p><p>2. The protocol messages are unchanged; instead the parties' identities are added to the key derivation procedure; namely the session key is now computed as K = H(σ, Â, B) instead of K = H(σ) as before (the order of Â and B under H can be determined arbitrarily but, of course, must be the same for both Â and B).</p><p>Both variants are simple and inexpensive. The second may be preferable as it saves the extra nonce; on the other hand, such a nonce is likely to be used anyway in actual implementations of the protocol for purposes of session identification (but note that the nonce in this case must be unpredictable). An advantage of variant 2 is that the hashing of identities in the key derivation function provides uniformity with the one-pass protocol of Section 9 (see Remark 9.1). We thus have the following lemma.</p><p>Lemma 30 Under the GDH and KEA1 assumptions, any one of the above variants of protocol HMQV remain secure in the random oracle model even if the attacker is allowed access to secret ephemeral DH exponents before or during the session that uses these exponents.</p><p>Remark 7.2 (The effect of birthday-type attacks on the original HMQV.) While we do not recommend ignoring the effect of the birthday-type attacks described above (especially, that they can be avoided easily), it is illustrative to understand the effect of such an attack on the basic HMQV protocol. In order to take advantage of such an attack, M would need to know the value Y used by a party B in advance. Then it would need to find two identities in the system (recall that in HMQV the message m is always the identity of a party), say P and P , for which a collision H(Y 0 , P ) = H(Y, P ) can be found. Once these are found, the attacker can mount a UKS attack against B and P by forcing the generation of two unmatching sessions at these parties which output the same key but have different peers ( B would end the session with peer P and P with peer B).</p><p>In addition, for this attack to succeed, M would need to corrupt P and register the same public key of P under the name of P (this also assumes that no proof of possession is required by the CA). Finally, note that in general M may have some control about one of the identities to attack, but in order to control both identities it would require that each identity will have many different representations (e.g., the identity could include arbitrary random bits in its representation). In all, it can be argued that the practicality of such an attack is minimal. Yet, for the case in which is relatively small, say = 160, then one may want to choose one of the above variants of HMQV.</p><p>respectively, and set the key K to the hash of these (equal) values. (Note that in this case the exponent e does not add any value to the protocol except for making it compatible with the other variants; it actually somewhat detracts from the protocol efficiency.) Yet, an additional discrepancy remains between the value of d = H(X, ( Â, B)) in the one-pass version and d = H(X, B) in the 2-message version of HMQV. A way to provide compatibility between the three modes would be to have in all of them d = H(X, B), e = H(Y, Â) (where Y = B in the one-pass case), and add the identities Â, B to the session-key derivation function: namely, K = H(σ, Â, B) (with the order of Â and B defined using some fixed criterion). This replaces the need to add Â in the computation of d. It also has the advantage, as discussed in Section 7.3 of strengthening HMQV in the case of leaked pre-computed DH values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Concluding Remarks</head><p>The results in this paper show vulnerabilities of MQV to known-key and other attacks (in the case of the 3-message variant of MQV some of these vulnerabilities depend on the ability of the attacker to access ephemeral state information for incomplete sessions). The extent to which these weaknesses are exploitable in practice depends of course on the application, the computing and communication environment, threat model, etc. These results do not mean that applications already using MQV are necessarily insecure in their specific environments. At the same time, the identified weaknesses should not be dismissed as theoretical only, especially when considering that MQV has been (and is being) standardized as a key-exchange protocol for use in heterogeneous and unknown scenarios (including the highly sensitive applications such as those announced by the NSA <ref type="bibr" target="#b34">[36]</ref>). This is particularly true when, as shown here, these weaknesses are not inherent to the problem being solved nor to the formal analytical setting. Indeed, HMQV provides the same functionality with the same (or even better) performance of MQV while enjoying a full proof of security. <ref type="foot" target="#foot_11">12</ref> Two caveats regarding this proof are the use of the idealized random oracle methodology and the significant (though polynomially bounded) reduction cost. Other proven protocols (such as SKEME <ref type="bibr" target="#b24">[26]</ref>, ISO <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b10">11]</ref> and SIGMA <ref type="bibr" target="#b25">[27,</ref><ref type="bibr" target="#b11">12]</ref>), while less efficient, enjoy less expensive reductions and do not directly require random oracles. We note, however, that dispensing of random oracles in these protocols requires the use of the more expensive (and seldom used in practice) signature and encryption schemes that do not rely on random oracles, and also requires the stronger DDH assumption. Certainly, coming up with a protocol that offers the many attractive security and performance properties of HMQV and does not rely on the random oracle model in its analysis is an important open question.</p><p>We end by stressing that in spite of the weaknesses demonstrated here, the MQV protocol contains some remarkable ideas without which the design of HMQV would have not been possible. Nor would this design have been possible without the rigorous examination of these ideas in a formal framework such as the one in <ref type="bibr" target="#b10">[11]</ref>. The design of HMQV is a demonstration of the strength of "proof-driven designs" which guide us in choosing the necessary design elements of the protocol while dispensing of unnecessary "safety margins". As a result, one obtains solutions that are not only cryptographically sound but are also more efficient.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The basic (unauthenticated) Diffie-Hellman protocol</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>KeyFigure 2 :</head><label>2</label><figDesc>Figure 2:Computation of the session key K in each of the two protocols (A = g a and B = g b are Â's and B's public keys, respectively.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 .</head><label>2</label><figDesc>F is given access to a signing oracle B (representing a signer B with private key b and public key B) which on query (X, m) outputs a pair (Y, XSIG B (Y, m, X))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Forgery Game for XCR Signatures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Proof of Theorem 5: Reduction from CDH to XCR forgeries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Remark 4 . 2 (</head><label>42</label><figDesc>Number of bits in H(Y, m))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>2 . 3 .</head><label>23</label><figDesc>F is given access to a signing oracle B (representing an HCR signer B with private key b and public key B = g b ). Each signature query from F to B consists of the following interaction (a) F presents B with a message m; (b) B responds with y ∈ R Z q and stores the triple (y, Y = g y , m) as an "incomplete triple" (c) F presents B with a pair (Y, m) and a challenge X. (d) B checks that the pair (Y, m) is in one of its incomplete triples and that X = 0; if not, it aborts, else it responds with r = HSIG B (Y = g y , m, X) = H(X y+ H(Y,m)b ), marks the triple (y, Y, m) as complete and stores with it the signature values X, e = H(Y, m), r.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The MQV paper is somewhat ambiguous about the need to hash σ (see the end of Sections 1 and 5 in<ref type="bibr" target="#b27">[29]</ref>). In particular, this hashing is not viewed as essential to the security of the protocol but as a possible safeguard against potential weak bits in σ (which is not the source of weakness in this example, but rather the malleability of σ is.)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In<ref type="bibr" target="#b21">[23]</ref>, this protocol is also claimed to enjoy perfect forward secrecy (PFS), but what they actually show is a weaker and non-standard notion (see Section 6.2) where PFS holds only for sessions created without active intervention by the attacker. As we pointed out, lack of (full) PFS is an inherent limitation of any 2-message implicitlyauthenticated DH exchange, including the 2-message protocols from<ref type="bibr" target="#b21">[23]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The separation between state-reveal and session-key queries from party corruption considers the realistic possibility that private keys be better protected than ephemeral session-specific information.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>See Section 4.2 for a formalization of the CDH assumption.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Note that if in Schnorr's protocol one chooses e in {0, 1} (rather than from Zq) the protocol remains valid except</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>We note that the formulation of the Forking Lemma in<ref type="bibr" target="#b36">[38]</ref> is very general and fits exactly our application: namely, it applies to signatures of the form (m, Y, H(Y, m), σ) derived via the Fiat-Shamir methodology, provided that the signer is simulatable without knowledge of its private key (the use of the challenge X in our case does not affect the validity of the Forking Lemma argument).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>We deal with the case i = j, i.e., reflection attacks, in Section 6.3.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>Note that by construction of F the rewinding step is performed only in cases where M actually queried (B, A, Y0, X * ) during its run.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>Formally, key-replication attacks can be defined by requiring that the attacker explicitly outputs the identifiers of the two non-matching sessions that have the same key, or equivalently, i.e. up to a polynomial factor in success probability, one may just require that these sessions exist at the end of a successful run of the attacker.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>It is illustrative to note that some natural key-exchange protocols do not achieve this property: Such is the case of key-transport protocols based on public key encryption (such as SSL) or key-exchange protocols that use long term static DH keys g a , g b to derive a long-term shared key g ab (see Section 3.1). Examples of protocols that do provide resistance to KCI are the the signature-based SIGMA protocol<ref type="bibr" target="#b25">[27]</ref>, the ISO protocol<ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b20">22]</ref> and the SKEME protocol authenticated via public-key encryption<ref type="bibr" target="#b24">[26]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>See Remark 4.5 for a comparison of HCR and DSS signatures.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>We hope that standard bodies will take into account provability of protocols when selecting or revising protocols for standardization.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Building a CDH solver C from an HCR forger F Setup. Given a successful HCR-forger F we build an algorithm C that having access to a DDH oracle solves the CDH problem over G. The inputs to C are a generator g of G and a pair U = g u , V = g v ∈ R G. The goal of C is to compute CDH(U, V ) = g uv . Initializing F. C sets B = V and X 0 = U , and runs the forger F on input (B, X 0 ) against a simulated signing oracle, denoted B, under public key B. C provides F with a random tape and also provides answers to the random oracle queries H and H generated in the run as specified below. Simulation of signer B. The interaction between F and B takes four steps as specified in Figure <ref type="figure">5</ref>. The actions of B in this interaction are simulated by C as follows.</p><p>S1. F presents to B a message m for signing. S2. C chooses y ∈ R Z q and e ∈ R {0, 1} , and sets H(Y, m) to e (if (Y, m) was queried earlier from H then C aborts). C responds to F, on behalf of B, with y and e. It stores the values e and the triple (y, Y, m) which it marks as an "incomplete triple".</p><p>S3. F presents B with a pair (Y, m) and a challenge X.</p><p>S4. C checks that the pair (Y, m) is part of one of its incomplete triples and that X = 0; if not the query is ignored. Else C checks for every value σ ∈ G previously used as input to the oracle H whether σ = X y+be : it does so using the DDH oracle, namely, by checking whether CDH(X, B) = (σ/X y ) 1/e . If the answer is positive then C sets r to the already determined value of H(σ), otherwise r is set to a random value in {0, 1} k ; C marks the triple (y, Y, m) as complete, stores a vector (y, m, e, X, r), and returns r to F.</p><p>Simulation of H queries. Queries of F to the random oracle are answered by C as follows. If the same query was made earlier then C responds with the same original answer. New queries to H are answered with a random value in {0, 1} . If a new input σ is queried from H, then C checks whether σ = X y+be for any one of the vectors (y, m, e, X, r) stored by C (as before this check is done using the DDH oracle). If equality holds then the corresponding r is returned as H(σ), else a random r in {0, 1} k is returned. Upon F's termination. When F halts with a forgery guess Y 0 , m 0 , r 0 (i.e., r 0 is a guess by F for HSIG B (Y 0 , m 0 , X 0 )), C checks whether:</p><p>F1. The pair (Y 0 , m 0 ) is valid, i.e. it was not used as the (Y, m) pair in any of the signatures generated by B in steps S1-S4 and also Y 0 = 0.</p><p>F2. The value H(Y 0 , m 0 ) was queried from the random oracle; if so, we denote the response of H to this query by e 0 .</p><p>F3. The value r 0 was set earlier as H(σ 0 ) for some queried value σ 0 .</p><p>If these conditions hold, C proceeds to run the following "repeat experiment", else it aborts. The repeat experiment. C runs F again for a second time under the same input (B, X 0 ) and using the same coins for both C and F. The difference between the two runs is in the way in which C answers the H queries during the second run. Specifically, all queries to H performed before the H(Y 0 , m 0 ) query are answered identically as in the first run. The query H(Y 0 , m 0 ), however, is answered with a new independent value e 0 ∈ R {0, 1} . Subsequent queries to H are also answered at random from {0, 1} , independently of the responses provided in the first run. C's Output. If at the end of the second run, F outputs a forgery guess (Y 0 , m 0 , r 0 ) (with the same (Y 0 , m 0 ) as in the first run), then C checks that conditions F 1 -F 3 hold wrt (Y 0 , m 0 , r 0 ). If not C aborts. Else, C sets σ 0 to be the value in which H(σ 0 ) = r 0 , it computes W = (σ 0 /σ 0 ) (e0-e 0 ) -1 , and outputs W as a guess for g uv .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6: Proof of Lemma 27</head><p>As a result of this almost perfect simulation of B in its game with F, we see that the probability that F outputs a correct forgery in its run by C is, up to a negligible difference, the same as in a real run of F, and hence non-negligible. Below we will argue that whenever F outputs a correct forgery Y 0 , m 0 , r 0 under the run by C then the three conditions F1-F3 checked by C hold except for a non-negligible probability. Therefore, except for such a negligible probability, a successful run of F (i.e., in which the triple Y 0 , m 0 , r 0 is a valid forgery wrt X 0 ) will produce a value σ 0 as in condition F3 and such that σ 0 = X y 0 +e 0 b 0 . Since F outputs correct forgeries with non-negligible probability then we have that with non-negligible probability the first run of F ends with a value σ 0 = X y 0 +e 0 b 0 . In this case, the repeat experiment will be performed. By (a straightforward adaptation of) the Forking Lemma <ref type="bibr" target="#b36">[38]</ref> we get that with non-negligible probability this second run ends with a forgery Y 0 , m 0 , r 0 where (Y 0 , m 0 ) = (Y 0 , m 0 ) and r 0 = H(σ 0 ) where σ 0 is a value presented by F as an input to H and also σ 0 = X y 0 +e 0 b 0 . In this case the value (σ 0 /σ 0 ) (e 0 -e 0 ) -1 is equal to X b 0 which in turn is equal to g uv . In all, the probability that C outputs a correct value CDH(U, V ) is non-negligible.</p><p>All is left to prove is that in the case in which the forgery Y 0 , m 0 , r 0 output by F is correct and valid then conditions F1-F3 checked by C hold except for a negligible probability. This is obvious for F1 since this is a condition for the forgery to be valid. In the case of F2, if H(Y 0 , m 0 ) was not queried then the probability for F to output a correct forgery is at most 1/2 + 1/2 k : for each value of e 0 = H(Y 0 , m 0 ) the induced value σ 0 = X y 0 +e 0 b 0 is different and then hitting the right r 0 requires guessing e 0 or guessing H(σ 0 ) without knowing σ 0 . In the case of condition F3, guessing r 0 without querying H(σ 0 ) has only a probability of 1/2 k to succeed. However, the value r 0 may be chosen by F as one of the random values r answered by C (on behalf of B) in the simulation step S4, say an r taken from a vector (y, m, e, X, r) stored by C. In this case, even though neither C nor F queried H on the value σ = X y+eb (nor on σ 0 = X y 0 +e 0 b 0 ), the forgery by F would be correct if it happens that</p><p>where e 0 = H(Y 0 , m 0 ), e = H(Y, m), X 0 is the input to F, and X the challenge (chosen by F) under which B produced the signature (y, m, r). However, if this is the case then we cannot use algorithm C from Figure <ref type="figure">6</ref> to compute the DH value X b 0 since in order to do that C needs to learn the value σ 0 . What we are going to show, in Lemma 28 below, is that the probability that algorithm F finds a forgery that satisfies Equation ( <ref type="formula">2</ref>) is negligible. This will end the proof of Lemma 27. 2</p><p>In order to formalize and prove Lemma 28 below, we first define a class of forgers F, which we call collision forgers, that interact with an HCR-signer B with public key B as specified in Step 3 of Figure <ref type="figure">5</ref>. Without loss of generality, we will assume that F either aborts or else it outputs a signature triple (Y 0 , m 0 , r 0 ) as a candidate forgery; we also assume that r 0 = H(σ) for all values of σ explicitly queried from H (we are only interested on the ability of F to output triples (Y 0 , m 0 , r 0 ) that violate condition F3). We will call such a triple (Y 0 , m 0 , r 0 ) a collision forgery, and say it is correct if (i) the pair (Y 0 , m 0 ) is valid (i.e. Y 0 = 0 and (Y 0 , m 0 ) was not used in any of the signatures issued by B), (ii) B generated a signature (y, m, r) under some challenge X (chosen by F) for which r = r 0 , and (iii) Equation ( <ref type="formula">2</ref>) holds. In this case we call (Y 0 , m 0 , r 0 ) the collision forgery and call the triple (Y, m, r) the colliding signature (of B wrt some challenge X).</p><p>Lemma 28 Under the Gap Diffie-Hellman and KEA1 assumptions, there is no efficient collision forger against HCR signatures in the random oracle model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>We assume that there is an efficient algorithm F that contradicts the lemma's statement. Specifically, we will assume that F interacts with a signer B (with public key B) and eventually outputs either "abort" or a collision forgery (Y 0 , m 0 , r 0 ) such that for some signature (y, m, r) issued by B with respect to a challenge X (chosen by F) it holds that r = r 0 (and r was not output by H on any explicit query σ); in this case we call (y, m, r) the colliding signature. For contradiction, we assume that with non-negligible probability F outputs a correct collision forgery.</p><p>We prove the lemma by considering two cases. The first assumes that with non-negligible probability F solves Equation ( <ref type="formula">2</ref>) with a value of Y 0 (in the collision forgery) different than Y (in the colliding signature); the second case assumes that with non-negligible probability F succeeds with Y 0 = Y (obviously, at least one of the two cases must hold with non-negligible probability).</p><p>Case I: Y 0 = Y . We show how to build from F an algorithm D that solves the discrete logarithm problem over G. We start by defining an algorithm C similar to the one described in Figure <ref type="figure">6</ref> but with some important changes.</p><p>C runs F as in Figure <ref type="figure">6</ref>, in particular by simulating B to F via the simulation steps S1-S4. However, before this simulation starts, C chooses i ∈ R {1, . . . , n}, where n is a bound on the number of signature queries performed by F, and three other values y 1 ∈ R Z q , e 1 ∈ R {0, 1} and r 1 ∈ R {0, 1} k . Simulation of signature queries is identical to Figure <ref type="figure">6</ref> except that when F asks its i-th signature query, say on message m 1 , C uses y 1 as the y-value of this signature. In this case, C also sets H(Y 1 = g y 1 , m 1 ) to the value e 1 (except if H(Y 1 , m 1 ) was queried before in which case C aborts). When presented with the challenge X for this signature, C sets the r-value of the signature to r 1 ; we denote the challenge X presented by F in this query by X 1 .</p><p>If F outputs a forgery guess (Y 0 , m 0 , r 0 ) where r 0 = r 1 (i.e., an alleged forgery collision with the i-th signature by B) and (Y 0 , m 0 ) is valid (i.e., not used by B in any of its signatures and with Y 0 = 0) then C performs the following "repeat experiment"; in all other cases C aborts its run.</p><p>The repeat experiment: C rewinds its computation up to the point in which F queried the value H(Y 0 , m 0 ) and re-runs F from this point on but this time with new random values for the H(Y 0 , m 0 ) query and subsequent H-queries. We denote by e 0 the response to H(Y 0 , m 0 ) in the first run and by e 0 the response to H(Y 0 , m 0 ) during the repeat experiment. In addition, C makes the following modification to its re-run of F: if in the first run of F the simulation used the pair (y 1 , e 1 ) after the H(Y 0 , m 0 ) query took place, then in the repeat experiment C chooses at random (among the remaining sessions, and independently of the choice of i in the first run) the signature query in which to embed the values y 1 , e 1 , r 1 . If the H(Y 0 , m 0 ) query happened after the pair (y 1 , e 1 ) was used by C then the above modification is not needed.</p><p>If both the first and second run of F by C end up with valid collision forgeries with the same pair (Y 0 , m 0 ) and the same values (y 1 , e 1 , r 1 ) in the colliding signature, then we denote by m 1 , X 1 the message and challenge used in the colliding signature in the first run, and by m 1 , X 1 the corresponding values from the colliding signature in the second run. In this case, C outputs the values: Y 0 , m 0 , e 0 , y 1 , e 1 , m 1 , m 1 , X 1 = 0, X 1 = 0 as well as two values C 1 , C 2 computed as:</p><p>In all other cases C aborts. We proceed to analyze C. By assumption, when interacting with a real signer B, F outputs a correct collision forgery with non-negligible probability. Since the simulation of B by C is perfect up to a negligible probability (see the proof of Lemma 27) then the non-negligible probability of success of F holds too when F is run by C. Also, with non-negligible probability C guesses correctly the signature query in which the colliding signature is computed. Therefore with non-negligible probability F ends its first run by C with a correct collision forgery (wrt the challenge X 0 ) with parameters denoted as Y 0 , m 0 , e 0 , r 0 and with a colliding signature with parameters y 1 , m 1 , e 1 , r 1 , X 1 where (y 1 , e 1 , r 1 ) were chosen by C at the beginning of its run and m 1 , X 1 were chosen by F. Using (an adaptation of) the Forking Lemma from <ref type="bibr" target="#b36">[38]</ref> one gets that all of the above holds for the second run of F under the repeat experiment (which also has a non-negligible probability of guessing the correct i in which to embed the values y 1 , e 1 , r 1 ). More precisely, there is a non-negligible probability that F will output in both first and second runs a correct collision forgery with the same parameters Y 0 , m 0 , r 0 , and the same colliding values y 1 , e 1 , r 1 = r 0 , but possibly different values of m 1 and X 1 (since the choice of these elements by F may depend on the response to the H(Y 0 , m 0 ) query). Hence, we let m 1 , X 1 denote the corresponding values from the first run of F, and m 1 , X 1 denote the values from the second run. We note that even if m 1 = m 1 , we have by construction of C that the values H(Y, m 1 ) and H(Y, m 1 ) are both equal to e 1 .</p><p>Putting all together, we have that with non-negligible probability C outputs a sequence of values Y 0 , m 0 , e 0 , y 1 , e 1 , m 1 , m 1 , X 1 .X 1 which satisfy Equation ( <ref type="formula">2</ref>), namely,</p><p>Re-arranging these two equations and dividing one by the other we obtain that</p><p>In other words, we see that the values C 1 and C 2 output by C satisfy that C b 1 = C 2 . By the KEA1 assumption there exists an algorithm C that in addition to all values output by C also outputs a value t such that t = log g (C 1 ) = (e 0 -e 0 )x 0 -e 1 ∆x 1 where x 0 = log g (X 0 ) and ∆x 1 = log g (X 1 /X 1 ). Note that by the equality C b 1 = C 2 we also have that t satisfies bt = y 1 ∆x 1 . We are now ready to describe a dlog solver D. Algorithm D receives as input a value X 0 ∈ R G. It chooses an element b ∈ R Z q , sets B = g b , and runs C on inputs B = g b , X 0 . When C produces its output, including the value t, then D sets the two equations induced by t, namely: t = (e 0 -e 0 )x 0 -e 1 ∆x 1 and bt = y 1 ∆x 1 .</p><p>(</p><p>Since D knows b and t, these represent two linear equations on two unknowns x 0 and ∆x 1 , which can be solved to obtain X 0 . Note that these equations have a unique solution provided that e 0 = e 0 which is the case except for probability 2 -. Summarizing, we have shown that if F is an efficient collision forger that succeeds with nonnegligible probability then we can build an efficient algorithm D that solves the discrete logarithm problem over the group G. This ends the proof of Case I.</p><p>Case II: Y 0 = Y . Since in the proof of case I we have used the notation Y 1 instead of Y we will keep this notation here, i.e., we assume that the component Y 0 in the forgery output by F equals the value Y 1 = g y 1 generated by C. In the analysis of case I we have used the fact that H(Y 0 , m 0 ) and H(Y 1 , m 1 ) are chosen independently of each other so that a change in the response to H(Y 0 , m 0 ) did not result in changing e 1 . This is not the case, however, when Y 0 = Y 1 ; in this case the whole argument used in Case I collapses. Fortunately, in Case II we can take advantage of the fact that Y 0 = Y 1 in a different way: now, we know also the exponent y 0 for which Y 0 = g y 0 since y 0 = y 1 and the latter is chosen by C.</p><p>Using the above fact, we define a new algorithm C that on input X 0 , B ∈ R G, interacts with the forger F as in Figure <ref type="figure">6</ref>. This time, however, we do not need C to choose in advance the values y 1 , e 1 for the colliding signature nor it is needed to guess which query from B produces this colliding signature. Moreover, we can get rid of the repeat experiment all together. All is needed is to specify that when F outputs a collision forgery (Y 0 , m 0 , r 0 ) wrt challenge X 0 which collides with a signature (y 1 , m 1 , r 1 ) output by B under challenge X 1 (i.e., r 1 = r 0 ) and such that Y 0 = Y 1 , then C outputs the sequence of values: Y 0 , m 0 , e 0 = H(Y 0 , m 0 ), y 1 = y 0 , e 1 = H(Y 1 , m 1 ), m 1 , X 1 as well as two values C 1 , C 2 computed as C 1 = X e 0 0 X e 1 1 and C 2 = (X 1 /X 0 ) y 1 . Analyzing the behavior of C we see that, if in a run under C, the forger F outputs a correct collision forgery (Y 0 , m 0 ) which collides with a signature (y 1 , m 1 ) output by B (and with values X 0 , X 1 , y 0 = y 1 , m 1 , y 1 , e 0 , e 1 as specified above) then by virtue of Equation ( <ref type="formula">2</ref>) and since</p><p>. Re-arranging terms and denoting C 1 = X e 0 0 X -e 1 1 and C 2 = (X 1 /X 0 ) y 1 , we have that in the case of a correct collision forgery by F, C succeeds in finding two (known</p><p>Thus, using the KEA1 assumption we know that there is an algorithm C that, in addition to the other outputs of C, it also outputs t = log g (C 1 ) = e 0 x 0 -e 1 x 1 (where x 0 = log g (X 0 ) and x 1 = log g (X 1 )).</p><p>We are now ready to define an algorithm D for solving the dlog problem for input X 0 ∈ R G. This algorithm D chooses b ∈ R Z q and runs C on inputs B = g b and X 0 . When C halts with a (non-abort) output as above then D can set two linear equations t = e 0 x 0 -e 1 x 1 and bt = y 1 x 0 -y 1 x 1 on unknowns x 0 , x 1 . In the case that y 1 = 0 and e 0 = e 1 , these equations have a unique solution from which D can obtain x 0 = log g (X 0 ). Hence D successfully computes the dlog of its input X 0 whenever the following three conditions are satisfied: (i) the run of F under C produces a correct collision forgery, (ii) y 1 = 0, and (iii) e 0 = H(Y 0 , m 0 ) = e 1 = H(Y 1 , m 1 ). The first happens with non-negligible probability by assumption on F and by the almost-perfect simulation of C. Condition (ii) happens with probability 1 -1/q since y 1 is chosen by C (or B) at random in Z q . The last condition (e 0 = e 1 ) happens as long as H(Y 0 , m 0 ) = H(Y 1 , m 1 ). Now, since m 0 = m 1 (otherwise, since Y 0 = Y 1 we would have (Y 0 , m 0 ) = (Y 1 , m 1 ) which would make F's forgery invalid), then the probability that H(Y 0 , m</p><p>This completes the proof of Lemma 28 and with it the proof of Lemma 27.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">HCR Signatures with Off-Line Computed Y</head><p>In Section 7.2 we proved that if the exponent y of the Y = g y component in an HCR signature generated by the legitimate signer is revealed then the scheme still remains unforgeable. However, the analysis there assumed that the value y is chosen randomly at the time of the signature generation (i.e., in Step 3b of Figure <ref type="figure">5</ref>) and only then y is revealed. Moreover, the analysis used the fact that Y = g y is unpredictable to the forger before this value is output by the signer B. This is used in an essential way in the proof of Lemma 28 when arguing that in case II the probability that H(Y, m 0 ) = H(Y, m) for m = m 0 is 2 -and, similarly, that in case I the probability</p><p>where Y 0 = Y 1 (and m 0 , m 1 unrestricted) is also at most 2 -. In the case that the attacker knows Y in advance the analysis needs to consider that the attacker can now find m 0 , m</p><p>where N is a bound on the number of possible messages in the system and Q is the total number of H-oracle queries made by F. Therefore, if we envision a scenario in which the attacker may have access to the values Y before they are used by the signer B (as in the case in which pre-computed values of Y are leaked)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">The 3-message HMQV-C Protocol</head><p>The HMQV-C Protocol</p><p>M AC Km ("0") -</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Key Computation (by Â and B):</head><p>Compute σ as in HMQV; compute K m = H(σ, 0) and SK = H(σ, 1)</p><p>Figure <ref type="figure">7</ref>: Â and B, with public keys A = g a and B = g b , resp., share session key SK.</p><p>In this section we study a 3-message variant of the HMQV protocol, which we refer to as HMQV-C (where C stands for "key Confirmation"), and which is depicted in Figure <ref type="figure">7</ref>. The protocol enjoys all the security properties of HMQV (the same analysis of HMQV establishes these properties for HMQV-C) and essentially the same computational cost. It adds, however, a third message to the protocol and a slight increase in the length of protocol messages. In return, HMQV-C provides some properties lacking in the basic HMQV protocol. We discuss three such properties: key confirmation, PFS, and universal composability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Key confirmation.</head><p>The HMQV protocol provides a fundamental assurance to a party Â that completes a session with peer B and session key K: if B is not corrupted then only B may possibly know K. What the protocol does not provide is any assurance to Â that B completed the session or computed the session key; moreover, B might not have even been "alive" during the execution of the session. This is not just a drawback of HMQV but the same will be true for any 2-message public-key based protocol (assuming, as in the typical public key scenario, that no prior shared state was created at an earlier communication between Â and B). Furthermore, as pointed out by Shoup <ref type="bibr" target="#b39">[41]</ref>, the seemingly natural goal that both parties have assurance that the the peer completed the session before each starts using the key cannot be achieved by any key-exchange protocol. Indeed, the attacker can always prevent this mutual assurance by stopping the last protocol message from reaching its destination.</p><p>Yet, the weaker assurance to each of the parties that the peer was able to compute the key (but not necessarily that it output the key to the calling application) is achievable and referred to in the literature as the key confirmation property. While not crucial for the basic security of a key exchange (e.g., the lack of key confirmation is not a threat to the privacy or authenticity of communications protected with this key <ref type="bibr" target="#b10">[11]</ref>), this property may provide a useful "operational sanity check" for some applications. In this case, protocol HMQV-C is better suited than HMQV since the added M AC values provide key confirmation. Moreover, the M AC validation confirms the active involvement of the identified peer to the session as well as the fact that this peer possesses a matching session (i.e., with same peers and same session key). Note that in order to achieve these properties, the M AC in HMQV-C does not need to be applied to any specific session information but simply to a single bit used to indicate the "direction" of the message and to prevent reflection. Also worth noting is that the protocol consisting of only the first two messages in HMQV-C already provides key confirmation to the initiator (which may add a useful feature to HMQV without increasing the number of protocol messages).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note (denial of service):</head><p>In many applications of key exchange, lack of key confirmation may lead to a form of "denial of service" (DoS) attack in which a party Â starts using the key, say to send protected information to B, while B is not able to process this information since it did not yet establish the key. As said, this situation cannot be avoided completely since mutual "session completion" confirmation is not achievable. Moreover, there are more serious forms of DoS attacks against protocols based on public key operations, in which a party is forced to spend significant computation cycles (and create session state) before discovering the invalidity of the peer. Some useful but limited-scope counter-measures to DoS attacks exist (cf. <ref type="bibr" target="#b18">[19]</ref>) that can be applied to any key-exchange protocol (including HMQV) at the expense of added protocol messages.</p><p>Perfect Forward Secrecy (PFS). As shown in Section 6.2, no 2-message protocol, and in particular HMQV, can provide full perfect forward secrecy. Instead, the best one can hope for is the weak form of PFS provided by HMQV and proven in that section. The main advantage of HMQV-C is that it lifts this inherent limitation of HMQV and provides for full PFS (see formal definition in Section 2). The proof of this fact is similar to the proof of Lemma 23. In that case, in order to claim forward secrecy, we had to explicitly assume (as formally captured by the notion of "clean sessions") that the legitimate parties chose the DH values for the session. In the case of HMQV-C, however, there is no need for any such assumptions. Indeed, a completed session in HMQV-C already provides assurance that the DH values were chosen (and explicitly authenticated) by the session's peers. We thus obtain full perfect forward secrecy: if an uncorrupted party Â establishes an HMQV-C session with uncorrupted peer B, then the session key K remains secure even if the attacker corrupts Â after K expired at Â, or it corrupts B after K expired at B. UC Security. In <ref type="bibr" target="#b12">[13]</ref>, Canetti and Krawczyk expand their model of key exchange from <ref type="bibr" target="#b10">[11]</ref> (which we use as the basis for this work) to a more ambitious model targeted at ensuring the security of key-exchange protocols when run concurrently with other applications (as is the case in real-world environments). This model is known as the Universal-Composability (UC) model of key exchange (a part of the general UC framework of Canetti <ref type="bibr" target="#b9">[10]</ref>). An important theorem from <ref type="bibr" target="#b12">[13]</ref> shows that if a protocol is proven secure in the model of <ref type="bibr" target="#b10">[11]</ref> and it also enjoys the so called "ACK property" then the protocol is also secure in the stronger UC model. Informally, the ACK property requires that when the first party to complete a session outputs its session key then the peer's state contains only information that can be "simulated" from the public information in the protocol and the session key. This can be shown to be the case for HMQV-C (see Claim 15 in <ref type="bibr" target="#b12">[13]</ref>). Therefore, HMQV-C is secure in the UC model as well. (On the other hand, HMQV can be shown to be secure in the "relaxed UC" model from <ref type="bibr" target="#b12">[13]</ref> but not in the regular UC model.) We summarize the above properties of HMQV-C in the following theorem:</p><p>Theorem 31 Under the CDH assumption, the HMQV-C protocol, with its hash function modeled as a random oracle, is a secure key-exchange protocol in the Canetti-Krawczyk model, which enjoys all the security properties from Theorem 18, and the additional properties of perfect forward secrecy (PFS) and key confirmation. The security of the protocol holds also in the Universal Composability model of key-exchange protocols <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">One-Pass HMQV</head><p>A one-pass key exchange protocol consists of a single message sent from a sender Â to a recipient B from which both parties (using their private and public keys) derive a unique key that only Â and B may possibly know (as long as both parties and the session are uncorrupted as defined below). In particular, B knows that the incoming message originated from Â and was intended to B. In other words, the requirements from the established key are the same as in a regular key exchange protocol except for the possibility that the message received by B is a replay of an older message from Â (this replay is inevitable in a one-pass protocol, though it may be detectable by other means such as synchronized time or shared state). In addition, such a protocol cannot provide PFS since (by lack of a session-specific input from B) the key should be computable with the sole knowledge of B's private key. Below we outline a formal definition of the security of one-pass protocols. The MQV papers <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b27">29]</ref> suggested a one-pass variant of the protocol. Here we adopt the same ideas with respect to HMQV, and obtain a very efficient and provably secure one-pass key-exchange protocol.</p><p>One-pass HMQV. One-pass HMQV between parties Â and B (with public keys A = g a , B = g b , respectively) consists of a single value X = g x transmitted from Â to B (where x ∈ R Z q is chosen by Â). The session key K is computed by Â as: (i) Let ( Â, B) denote a message that includes the two identities Â and B, and set d to be the result of d = H(X, ( Â, B)). (ii) compute</p><p>where H outputs a number of bits equal to the length of the required key. The same key K is computed by B (after checking that X = 0) as K = H((XA d ) b ).</p><p>Security model for one-pass protocols. The key-exchange security model of Canetti-Krawczyk outlined in Section 2 applies to the one-pass protocol case through the following changes. Sessions are named by their peers and the exchanged message, i.e. by the triple ( Â, B, X) (for simplicity we use the same session notation for both Â and B). A session is called exposed if one of the following happens: (i) Â or B are corrupted; (ii) a session-key query is issued against the session (in which case the attacker obtains the session key); (iii) a state-reveal query is issued against the session (either at Â or B). The test-session game is the same as in the general model (in particular, a test session can be chosen among any one of the unexposed sessions). The rest of the model and security definitions are unchanged.</p><p>Theorem 32 Under the CDH assumption and in the random oracle model, One-Pass HMQV is a secure one-pass key-exchange protocol.</p><p>The proof of this theorem combines two elements: (i) a proof based on XCR signatures (by Â) similar in spirit to the proof of the HMQV protocol from Section 5.2; and (ii) a proof of indistinguishability of the key K which involves arguments similar to those used in <ref type="bibr">[1]</ref>. The latter aspect is orthogonal to most of the analysis work in this paper and its proof is related to other implicitly-authenticated Diffie-Hellman studied in <ref type="bibr" target="#b26">[28]</ref>. The reason to include the identity of Â under the signed message (i.e., under the hash that defines d) is to thwart a UKS-type attack as follows. The attacker M registers Â's public key, A, as her own public key. Then, when Â sends to B the message Â, X, the attacker M replaces it with M, X. The result is that B believes the resultant key K is shared with M while Â believes she shared (the same) K with B.</p><p>We conclude by pointing out that the above one-pass protocol can be used as an authenticated CCA encryption scheme, that is, Â can transmit a message m to B encrypted (against chosenciphertext attacks) as well as authenticated (by Â). For this, Â would send a triple (X, c, t) where X = g x , c is a ciphertext obtained as the symmetric CPA encryption of message m under a key K 1 , and t a MAC value computed on c under key K 2 . The keys K 1 and K 2 are derived from a key K computed from X as in the one-pass HMQV protocol. The whole cost of this procedure is 2 exponentiations for Â (one is off-line) and 1.5 for B. This is just 1/2 exponentiation more for B compared to the DHIES CCA encryption from <ref type="bibr">[1]</ref> but in return it provides authentication from Â (with DHIES this authentication would require a full additional signature from Â). This efficient authenticated CCA encryption is very attractive for "store-and-forward" applications such as PGP, and significantly cheaper than the usual sign-and-encrypt paradigm. The only caveat here is that the identity Â (and possibly its certificate) needs to be transmitted in the clear as it is needed for the decryption operation. Yet another property of the above protocol that is worth noting is that it can be used just as a verifier-specific signature of Â on message m without necessarily adding the encryption part. This signature, however, is recipient specific and therefore does not provide non-repudiation; instead it provides deniability, a very valuable feature in many applications, e.g. PGP. (See also Remark 4.5.) Remark 9.1 (A note on standardization.) Many of the standards that have adopted MQV, have also adopted the one-pass variant of it. For standards interested in adopting HMQV in its different forms (one, two and three messages), it could make sense to define the derivation of the key in the one-pass protocol similar to the derivation in the other variants of HMQV. Specifically, by substituting Y with B in the dual signatures that define the HMQV protocol (Section 5), we obtain the following values for the one-pass key: Â and B compute σ Â = (BB e ) x+da and σ B = (XA d ) b+eb ,</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Oracle Diffie-Hellman Assumptions and an Analysis of DHIES</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CT-RSA</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Naccache</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2001">2001. 2020. 2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">Public Key Cryptography for the Financial Services Industry: Agreement of Symmetric Keys Using Discrete Logarithm Cryptography</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="42" to="2001" />
		</imprint>
		<respStmt>
			<orgName>American National Standard</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">American National Standard (ANSI) X9.63: Public Key Cryptography for the Financial Services Industry: Key Agreement and Key Transport using Elliptic Curve Cryptography</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Knowledge-of-Exponent Assumptions and 3-round Zero-Knowledge Protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Palacio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto&apos;04</title>
		<imprint>
			<biblScope unit="volume">3152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Random Oracles are Practical: A Paradigm for Designing Efficient Protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Entity authentication and key distribution</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto&apos;93</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">773</biblScope>
			<biblScope unit="page" from="232" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Authenticated Diffie-Hellman Key Agreement Protocols</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blake-Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SAC &apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>SAC &apos;99</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1556</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Key exchange protocols and their security analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blake-Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Sixth IMA International Conference on Cryptography and Coding</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Protocols for Authentication and Key Establishment</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mathuria</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Universally Composable Security: A New paradigm for Cryptographic Protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>42nd FOCS</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Analysis of Key-Exchange Protocols and Their Use for Building Secure Channels</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/)" />
	</analytic>
	<monogr>
		<title level="m">Full version in: Cryptology ePrint Archive</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2001">2001. 2001/040</date>
			<biblScope unit="volume">2045</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Security Analysis of IKE&apos;s Signature-based Key-Exchange Protocol</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto 2002. LNCS</title>
		<imprint>
			<biblScope unit="volume">2442</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Universally Composable Notions of Key Exchange and Secure Channels</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2002/059" />
	</analytic>
	<monogr>
		<title level="j">Eurocrypt</title>
		<imprint>
			<biblScope unit="volume">02</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Towards Practical Public Key Systems Secure Against Chosen Ciphertext Attacks</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto&apos;91</title>
		<title level="s">LNCS</title>
		<imprint>
			<biblScope unit="volume">576</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">New Directions in Cryptography</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Info. Theor</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="644" to="654" />
			<date type="published" when="1976-11">Nov 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Authentication and authenticated key exchanges</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wiener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Designs, Codes and Cryptography</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="107" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Concurrent Zero-Knowledge</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proc. of 30 th ACM Symposium on Theory of Computing (STOC)</title>
		<meeting>of 30 th ACM Symposium on Theory of Computing (STOC)</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="409" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the Existence of 3-round Zero-Knowledge Protocols</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tanaka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto&apos;98</title>
		<title level="s">LNCS</title>
		<imprint>
			<biblScope unit="volume">1462</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Harkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carrel</surname></persName>
		</author>
		<title level="m">The Internet Key Exchange (IKE)</title>
		<imprint>
			<date type="published" when="1998-11">Nov. 1998</date>
		</imprint>
	</monogr>
	<note>RFC 2409</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Information technology -Security techniques -Cryptographic techniques based on elliptic curves -Part 3: Key establishment</title>
		<idno>ISO/IEC IS 15946-3</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Entity authentication mechanisms -Part 3: Entity authentication using asymmetric techniques</title>
		<idno>ISO/IEC IS 9798-3</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">One-Round Protocols for Two-Party Authenticated Key Exchange</title>
		<author>
			<persName><forename type="first">Rae</forename><surname>Ik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lee</forename><surname>Hoon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACNS</title>
		<imprint>
			<biblScope unit="volume">2004</biblScope>
			<biblScope unit="page" from="220" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An unknown key-share attack on the MQV key agreement protocol</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kaliski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security (TISSEC)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="275" to="288" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient and Non-Malleable Proofs of Plaintext Knowledge and Applications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -Proc. of EUROCRYPT &apos;03</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2656</biblScope>
			<biblScope unit="page" from="211" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">SKEME: A Versatile Secure Key Exchange Mechanism for Internet</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Internet Society Symposium on Network and Distributed System Security</title>
		<imprint>
			<date type="published" when="1996-02">1996. Feb. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">SIGMA: The &apos;SiGn-and-MAc&apos; Approach to Authenticated Diffie-Hellman and Its Use in the IKE Protocols</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Crypto &apos;03</title>
		<title level="s">LNCS</title>
		<imprint>
			<date type="published" when="2003">2729. 2003</date>
			<biblScope unit="page" from="400" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">On the Security of Implicitly-Authenticated Diffie-Hellman Protocols</title>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>work in progress</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An efficient Protocol for Authenticated Key Agreement</title>
		<author>
			<persName><forename type="first">L</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Solinas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Designs, Codes and Cryptography</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="119" to="134" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On seeking smart public-key distribution systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Matsumoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Takashima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Imai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. IECE of Japan</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="99" to="106" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Diffie-Hellman oracles</title>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;96</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="268" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Another Look at HMQV</title>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2005/205" />
		<imprint>
			<date type="published" when="2005-06-27">June 27, 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Some new key agreement protocols providing mutual implicit authentication</title>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second Workshop on Selected Areas in Cryptography (SAC 95)</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Handbook of Applied Cryptography</title>
		<author>
			<persName><forename type="first">A</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>CRC Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">NIST Special Publication</title>
		<imprint>
			<biblScope unit="page" from="800" to="856" />
			<date type="published" when="2003-01">Jan. 2003</date>
		</imprint>
	</monogr>
	<note>Recommendation on Key Establishment Schemes. Draft 2</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Cryptography Office, National Security Agency) to the IETF&apos;s Security Area Advisory Group</title>
		<ptr target="http://www.machshav.com/˜smb/saag-11-2004/NSA-EC-License.pdf" />
		<editor>Mr. John Stasak</editor>
		<imprint>
			<date type="published" when="2004-11">Nov 2004</date>
		</imprint>
	</monogr>
	<note>NSAs Elliptic Curve Licensing Agreement</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The Gap-Problems: A New Class of Problems for the Security of Cryptographic Schemes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2001, LNCS 1992</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="104" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Security Arguments for Digital Signatures and Blind Signatures</title>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J.Cryptology</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="361" to="396" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Digitalized Signatures</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Secure Computing, DeMillo-Dobkins-Jones-Lipton</title>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="155" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Lower Bounds for Discrete Logarithms and Related Problems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurocrypt&apos;97</title>
		<title level="s">LNCS</title>
		<imprint>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="256" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">On Formal Models for Secure Key Exchange</title>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<ptr target="http://philby.ucsd.edu/cryptolib/1999/99-12.html" />
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography Library</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">s On-line UKS Attack Against MQV For the benefit of the reader we present here Kaliski&apos;s UKS attack [24] demonstrating that the requirement of proof-of-possession from registrants of public keys is not a solution to this UKS weakness of the MQV protocol. Moreover, this attack demonstrates that replacing the exponents d = X, e = Ȳ used in the MQV protocol with</title>
		<author>
			<persName><surname>Kaliski</surname></persName>
		</author>
		<imprint>
			<pubPlace>H(X), H(Y ), respectively</pubPlace>
		</imprint>
	</monogr>
	<note>for any function H (even a perfect random oracle) does not resolve the UKS attack</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m">Â sends X to B</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m">The attacker M intercepts X</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">registers with the CA a key C = g c where c is computed by (and then known to</title>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
		<imprint/>
	</monogr>
	<note>M as: (a) Choose u ∈ R Z q</note>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Z</forename><surname>Set D = H(x)</surname></persName>
		</author>
		<author>
			<persName><surname>Xa D G -U , H = H</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m">M sends Z to B as coming from M</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m">B responds with Y to M</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">established by Â and B, respectively) are identical</title>
		<author>
			<persName><forename type="first">Â</forename></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Y )</forename></persName>
		</author>
		<author>
			<persName><forename type="first">( B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">)</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">M relays Y to Â as coming from B. Note that ZC h = XA d , and therefore the keys computed in sessions</title>
		<meeting><address><addrLine>X, Y )</addrLine></address></meeting>
		<imprint/>
	</monogr>
	<note>It is worth noting that the above specific attack can be prevented by making the values d, e, h depend on both exponents (e.g. d = H. a UKS attack in this case is still possible (as pointed out in Section 3.2, even one that works against the 3-message MQV protocol with key confirmation. What is needed to solve the attack is to bind the outgoing DH value and the peer&apos;s identity in the definition of e and d, as done in HMQV</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
