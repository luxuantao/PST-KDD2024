<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FENNEL: Streaming Graph Partitioning for Massive Scale Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Charalampos</forename><forename type="middle">E</forename><surname>Tsourakakis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Aalto University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christos</forename><surname>Gkantsidis</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Microsoft Research Espoo</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country>Finland, UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bozidar</forename><surname>Radunovic</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Microsoft Research Espoo</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country>Finland, UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Milan</forename><surname>Vojnovic</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Microsoft Research Espoo</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country>Finland, UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">FENNEL: Streaming Graph Partitioning for Massive Scale Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/2556195.2556213</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:10+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.4 [Database Systems]: [Distributed databases]</term>
					<term>D.2.8 [Software Engineering]: Metrics-complexity measures, performance measures</term>
					<term>G.2.2 [Mathematics of Computing]: [Graph Algorithms] Streaming</term>
					<term>Balanced Graph partitioning</term>
					<term>Distributed Computing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Balanced graph partitioning in the streaming setting is a key problem to enable scalable and efficient computations on massive graph data such as web graphs, knowledge graphs, and graphs arising in the context of online social networks. Two families of heuristics for graph partitioning in the streaming setting are in wide use: place the newly arrived vertex in the cluster with the largest number of neighbors or in the cluster with the least number of non-neighbors.</p><p>In this work, we introduce a framework which unifies the two seemingly orthogonal heuristics and allows us to quantify the interpolation between them. More generally, the framework enables a well principled design of scalable, streaming graph partitioning algorithms that are amenable to distributed implementations. We derive a novel one-pass, streaming graph partitioning algorithm and show that it yields significant performance improvements over previous approaches using an extensive set of real-world and synthetic graphs.</p><p>Surprisingly, despite the fact that our algorithm is a onepass streaming algorithm, we found its performance to be in many cases comparable to the de-facto standard offline software METIS and in some cases even superiror. For instance, for the Twitter graph with more than 1.4 billion of edges, our method partitions the graph in about 40 minutes achieving a balanced partition that cuts as few as 6.8% of edges, whereas it took more than 8 1 2 hours by METIS to produce a balanced partition that cuts 11.98% of edges. We also demonstrate the performance gains by using our graph partitioner while solving standard PageRank computation in a graph processing platform with respect to the communication cost and runtime.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The scale of graph data that needs to be processed in the context of online services is massive. For example, the Web graph amounts to at least one trillion of links, Facebook recently reported more than 1 billion of users and 140 billion of friend connections, and, in 2009, Twitter reported more than 40 million of users and about 1.5 billion of social relations <ref type="bibr" target="#b20">[21]</ref>. A standard approach for scalable computation on massive scale input graph data is to partition an input graph into smaller partitions and then use a large distributed system to process them. The partition sizes have to be balanced to exploit the speedup of parallel computing over different partitions. Furthermore, it is critical that the number of edges between distinct partitions is small, in order to minimize the communication cost incurred due to messages that are exchanged between different partitions. Many popular graph processing platforms such as Pregel <ref type="bibr" target="#b22">[23]</ref> that builds on MapReduce <ref type="bibr" target="#b6">[7]</ref>, and its open source cousin Apache Giraph, PEGASUS <ref type="bibr" target="#b12">[13]</ref> and GraphLab <ref type="bibr" target="#b21">[22]</ref> use as a default partitioner Hash Partition of vertices, which corresponds to assigning each vertex to one of the k partitions uniformly at random. This heuristic is efficient for balancing the number of vertices over different clusters, but ignores entirely the graph structure. In fact, the expected fraction of edges cut by a random partition of vertices into k ? 1 clusters is equal to 1 -1/k. Given the fact that real-world graphs tend to have sparser cuts <ref type="bibr" target="#b3">[4]</ref>, it is important to discover methods that are computationally efficient, practical, and yet yield high quality graph partitioning.</p><p>The problem of finding a balanced graph partition that minimizes the number of edges cut is known as the balanced graph partitioning problem, which has a rich history in the context of theoretical computer science. This problem is known to be NP-hard <ref type="bibr" target="#b18">[19]</ref> and several approximation algorithms have been derived in previous work, which we review in Section 2. In practice, systems aim at providing good partitions in order to enhance their performance, e.g., <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b26">27]</ref>. It is worth emphasizing that the balanced graph partitioning problem appears in various guises in numerous other domains, e.g., see <ref type="bibr" target="#b15">[16]</ref>.</p><p>Another major challenge in the area of big graph data is efficient processing of dynamic graphs. For example, new accounts are created and deleted every day in online services such as Facebook, Skype and Twitter. Furthermore, graphs  <ref type="table">1</ref>: Fraction of edges cut ? and the normalized maximum load ? for Fennel, the previously bestknown heuristic (linear weighted degrees <ref type="bibr" target="#b28">[29]</ref>) and hash partitioning of vertices for the Twitter graph with approximately 1.5 billion edges. Fennel and best competitor require around 40 minutes, METIS more than 8 1 2 hours.</p><p>created upon post-processing datasets such as Twitter posts are also dynamic, see for instance <ref type="bibr" target="#b1">[2]</ref>. It is crucial to have efficient graph partitioners of dynamic graphs. For example, in the Skype service, each time a user logs in, his/her online contacts get notified. It is expensive when messages have to be sent across different graph partitions since this would typically involve using network infrastructure. The balanced graph partitioning problem in the dynamic setting is known as streaming graph partitioning <ref type="bibr" target="#b28">[29]</ref>. Vertices (or edges) arrive and the decision of the placement of each vertex (edge) has to be done "on-the-fly" in order to incur as little computational overhead as possible.</p><p>It is worth noting that the state-of-the-art work on graph partitioning seems to roughly divide in two main lines of research. Rigorous mathematically work and algorithms that do not scale to massive graphs, e.g., <ref type="bibr" target="#b19">[20]</ref>, and heuristics that are used in practice <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b28">29]</ref>. Our work contributes towards bridging the gap between theory and practice.</p><p>Summary of our Contributions. Our contributions can be summarized in the following points:</p><p>? We introduce a general framework for graph partitioning that relaxes the hard cardinality constraints on the number of vertices in a cluster <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b19">20]</ref>. Our formulation provides a unifying framework that subsumes two of the most popular heuristics used for streaming balanced graph partitioning: the folklore heuristic of <ref type="bibr" target="#b25">[26]</ref> which places a vertex to the cluster with the fewest non-neighbors, and the degree-based heuristic of <ref type="bibr" target="#b28">[29]</ref>, which serves as the current state-of-the-art method with respect to performance.</p><p>? Our framework allows us to define formally the notion of interpolation between between the non-neighbors heuristic <ref type="bibr" target="#b25">[26]</ref> and the neighbors heuristic <ref type="bibr" target="#b28">[29]</ref>. This provides improved performance for the balanced partitioning problem in the streaming setting. Moreover, for a special case of our framework, we provide a O( log (k) k ) approximation algorithm, where k is the number of clusters.</p><p>? We evaluate our proposed streaming graph partitioning method, Fennel, on a wide range of graph datasets, both real-world and synthetic graphs, and show that it produces high quality graph partitions. For example, Table <ref type="table">1</ref> shows the performance of Fennel versus the best previously-known heuristic, which is the linear weighted degrees <ref type="bibr" target="#b28">[29]</ref>, and the baseline Hash Partition of vertices. We observe that Fennel achieves, simultaneously, significantly smaller fraction of edges cut and balanced cluster sizes.</p><p>? We compare Fennel to Hash Partition, the default partitioner of various major large-scale graph processing platforms. Specifically, we demonstrate significant performance gains with respect to the communication cost and the runtime while running Pagerank over a distributed graph in the graph processing platform Apache Giraph.</p><p>Structure of the Paper. The remainder of the paper is organized as follows. Section 2 discusses the related work. Section 3 introduces our graph partitioning framework and presents our main theoretical result. Section 4 presents a scalable, streaming algorithm. Section 5 evaluates our method versus the state-of-the-art work on an extensive set of real-world and synthetic graphs. Section 6 illustrates that Fennel is a choice for achieving fast and high-quality partitioning in a real system, by performing a baseline comparison to Hash Partition in Apache Giraph. Finally, Section 7 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Balanced graph partitioning is an NP-hard problem <ref type="bibr" target="#b9">[10]</ref>. It is a fundamental problem in every parallel and distributed application since data placement typically affects significantly the execution efficiency of jobs <ref type="bibr" target="#b16">[17]</ref>. The goal of balanced graph partitioning is to minimize an application's overall runtime. This is achieved by assigning to each processor/machine an equal amount of data and concurrently minimizing the parallel/distributed overhead by minimizing the number of edges cut by the corresponding partition. Formally, the (k, ?)-balanced graph partitioning asks to divide the vertices of a graph in components each of size less than ? n k , for some given positive integer k and ? ? 1. The case k = 2, ? = 1 is equivalent to the minimum bisection problem, an NP-hard problem <ref type="bibr" target="#b9">[10]</ref>. Several approximation algorithms and heuristics exist for this problem, see, e.g., <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b17">[18]</ref> respectively. When ? = 1 + ? for any desired but fixed ? &gt; 0 there exists a O(? -2 log 1.5 n) approximation algorithm <ref type="bibr" target="#b18">[19]</ref>. When ? = 2 there exists an O( ? log k log n) approximation algorithm based on semidefinite programming (SDP) <ref type="bibr" target="#b19">[20]</ref>. Due to the practical importance of k-paritioning there exist several heuristics, among which METIS <ref type="bibr" target="#b14">[15]</ref> and its parallel version <ref type="bibr" target="#b27">[28]</ref> stands out for its good performance. For this reason, METIS is used in many existing systems, e.g. <ref type="bibr" target="#b13">[14]</ref>. Recently, it was shown that label propagation <ref type="bibr" target="#b30">[31]</ref> is efficient and effective. An extensive summary of existing heuristics can be found in <ref type="bibr">[1]</ref>.</p><p>Online graph partitioning was introduced by Stanton and Kliot <ref type="bibr" target="#b28">[29]</ref>. The online setting is also well adapted to dynamic graphs, where offline methods incur an expensive computational cost, requiring to repartition the entire graph. Moreover, the newly obtained partitioning can significantly differ from the old one. This in turn implies a large reshuffle of the data, which is very expensive in a distributed system. Currently the most advanced online partitioning algorithm is by Stanton and Kliot <ref type="bibr" target="#b28">[29]</ref>, against which we extensively compare our approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROPOSED FRAMEWORK</head><p>Notation. Let G(V, E) be a simple undirected graph, where |V | = n, |E| = m. For a subset of vertices S ? V , let e(S, S) be the set of edges with both end-vertices in S, and let e(S, V \ S) be the set of edges across the cut (S, V \ S). For a given vertex v let tS(v) be the number of triangles (v, w, z) such that w, z ? S. We define a vertex partition P = (S1, . . . , S k ) to be a family of pairwise disjoint vertex sets whose union is V . We refer to each Si, i = 1, . . . , k, as a cluster of vertices. Let ?e(P) to be the set of edges that cross partition boundaries, i.e. ?e(P) = ? k i=1 e(Si, V \ Si). Finally, we refer to |?e(P)| as the edge-cut size.</p><p>Graph Partitioning Framework. We formulate a balanced graph partitioning framework that is based on accounting for the cost of internal edges and the cost of edges cut by the vertex partition in a single global objective function. The size of individual clusters. We denote with ?(Si) the size of the cluster of vertices Si, where ? is a mapping to the set of positive real numbers. Special instances of interest are (a) edge cardinality where the size of the cluster i is proportional to the total number of edges with at least one end-vertex in the set Si, i.e. |e(Si, Si)| + |e(Si, V \ Si)|, (b) interior-edge cardinality where the size of cluster i is proportional to the number of internal edges |e(Si, Si)|, and (c) vertex cardinality where the size of partition i is proportional to the total number of vertices |Si|. The edge cardinality is a measure of cluster size that is of interest in some applications, e.g. iterative computations on input graph data where the computational complexity within a cluster is linear in the number of edges with at least one vertex in the given cluster. The vertex cardinality is a standard measure of the size of a cluster and for some graphs, e.g., of bounded degree, may serve as a proxy for the edge cardinality. The global objective function. We define a global objective function that consists of two elements: (1) the interpartition cost cOUT : N k ? R+ and (2) the intra-partition cost cIN : N k ? R+. These functions are assumed to be increasing and super-modular (or convex, if extended to the set of real numbers). For every given partition of vertices P = (S1, S2, . . . , S k ), we define the global cost function as</p><formula xml:id="formula_0">f (P) = cOUT(|e(S1, V \ S1)|, . . . , |e(S k , V \ S k )|) + cIN(?(S1), . . . , ?(S k )).</formula><p>It is worth mentioning some particular cases of interest. Special instance of interest for the inter-partition cost is the linear function in the total number of cut edges |?e(P)|. This instance is of interest in cases where an identical cost is incurred per each edge cut, e.g. in cases where messages are exchanged along cut edges and these messages are transmitted through some common network bottleneck. For the intra-partition cost, a typical goal is to balance the cost across different partitions and this case is accommodated by defining cIN(?(S1), . . . , ?(S k )) = P k i=1 c(?(Si)), where c(x) is a convex increasing function such that c(0) = 0. In this case, the intra-partition cost function, being defined as a sum of convex functions of individual cluster sizes, would tend to balance the cluster sizes since the minimum is attained when sizes are equal.</p><p>We formulate the graph partitioning problem as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimal k-Graph Partitioning</head><p>Given a graph G = (V, E), find a partition P * = {S * 1 , . . . , S * k } of the vertex set V , such that f (P * ) ? f (P), for all partitions P such that |P| = k.</p><p>We refer to the partition P * as the optimal kgraph partition of the graph G.</p><p>Streaming setting. The streaming graph partitioning problem can be defined as follows. Let G = (V, E) be an input graph and let us assume that we want to partition the graph into k disjoint subsets of vertices. The vertices arrive in some order, each one with the set of its neighbors. We consider three different stream orders, as in <ref type="bibr" target="#b28">[29]</ref>.</p><p>? Random: Vertices arrive according to a random permutation.</p><p>? BFS: This ordering is generated by selecting a vertex uniformly at random and performing breadth first search starting from that vertex.</p><p>? DFS: This ordering is identical to the BFS ordering, except that we perform depth first search.</p><p>A k-partitioning streaming algorithm has to decide whenever a new vertex arrives to which cluster it is going to be placed. A vertex is never moved after it has been assigned to a cluster. Finally, it is worth mentioning that even if we focus on vertex balanced partitions in Section 5, Fennel also works for edge balanced parititions as well, see <ref type="bibr" target="#b28">[29]</ref>.</p><p>Application to Classical Balanced Partitioning. Classical balanced graph partitioning problem is the most common special case of our framework, in which the inter-partition cost is equal to the total number of edges cut, and the intrapartition cost is defined in terms of the vertex cardinalities. We will next explain the intuition behind our framework in this important case, and how to derive appropriate cost functions.</p><p>The starting point in the literature, e.g., <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref>, is to impose hard cardinality constraints, namely |S * i | ? ? n k for some small constant ?, i = 1, . . . , k. This set of constaints makes the problem significantly hard. Currently, the stateof-the-art work depends on the Arora-Rao-Vazirani barrier <ref type="bibr" target="#b2">[3]</ref> which results in a O( ? log n) approximation factor. The typical formulation is the following:</p><formula xml:id="formula_1">minimize P=(S 1 ,...,S k ) |?e(P)| subject to |Si| ? ? n k , ?i ? {1, . . . , k}</formula><p>The idea behind our approach is to relax the hard cardinality constraints by introducing a term in the objective cIN(P) whose minimum is achieved when |Si| = n k for all i = 1, 2, . . . , k. Therefore, our framework is based on a welldefined global graph partitioning objective function, which allows for a principled design of approximation algorithms and heuristics as shall be demonstrated. Our graph partitioning method is based on solving the following optimization problem: minimize P=(S 1 ,...,S k ) |?e(P)| + cIN(P)</p><p>(1)</p><p>Intra-partition cost. With the goal in mind to favor balanced partitions, we may define the intra-partition cost function by cIN(P) = P k i=1 c(|Si|) where c(x) is an increasing function choosen to be super-modular, so that the following increasing returns property holds c(x + 1) -c(x) ? c(y + 1) -c(y), for every 0 ? y ? x.</p><p>We focus on the following family of functions c(x) = ?x ? , for ? &gt; 0 and ? ? 1. By the choice of the parameter ?, this family of cost functions allows us to control how much the imbalance of cluster sizes is accounted for in the objective function. In one extreme case where ? = 1, we observe that the objective corresponds to minimizing the number of cut-edges, thus entirely ignoring any possible imbalance of the cluster sizes. On the other hand, by taking larger values for the parameter ?, the more weight is put on the cost of partition imbalance, and this cost may be seen to approximate hard constraints on the imbalance in the limit of large ?. Parameter ? is also important. We advocate a principled choice of ? independently of whether it is suboptimal compared to other choices. Specifically, we choose ? = m k ?-1 n ? . This provides us a proper scaling, since for this specific choice of ?, our optimization problem is equivalent to minimizing a natural normalization of the objective function</p><formula xml:id="formula_2">P k i=1 e(S i ,V \S i ) m + 1 k P k i=1 " |S i | n k ? ? .</formula><p>An equivalent maximization problem. We note that the optimal k-graph partitioning problem admits an equivalent formulation as a maximization problem which makes a connection with the concept of graph modularity <ref type="bibr" target="#b23">[24]</ref>. For a graph G = (V, E) and S ? V , we define the function h : 2 V ? R as:</p><formula xml:id="formula_3">h(S) = |e(S, S)| -c(|S|)</formula><p>where h(?) = h({v}) = 0 for every v ? V . Given k ? 1 and a partition P = {S1, . . . , S k } of the vertex set V , we define the function g as</p><formula xml:id="formula_4">g(P) = k X i=1 h(Si).</formula><p>Now, observe that maximizing the function g(P) over all possible partitions P of the vertex set V such that |P| = k corresponds to the k-graph partitioning problem. Indeed, this follows by noting that</p><formula xml:id="formula_5">g(P) = k X i=1 |e(Si, Si)| -c(|Si|) = m - `k X i=1 |e(Si, V \ Si)|) -c(|Si|) = m -f (P).</formula><p>Thus, maximizing function g(P) corresponds to minimizing function f (P), which is precisely the objective of our k-graph partitioning problem.</p><p>Modularity. We note that when the function c(x) is taken from the family c(x) = ?x ? , for ? &gt; 0 and ? = 2, our objective has a special combinatorial interpretation. Specifically, our problem is equivalent to maximizing the function</p><formula xml:id="formula_6">k X i=1 [|e(Si, Si)| -p |Si| 2 ! ]</formula><p>where p = 2?. In this case, each summation element corresponds to the difference between the realized and the expected number of edges within each cluster under the nullhypothesis that the graph is an Erd?s-R?nyi random graph with probability p. This is intimately related to the concepts of graph modularity <ref type="bibr" target="#b10">[11]</ref> and quasi-cliques <ref type="bibr" target="#b29">[30]</ref>. Approximation guarantees. For the special case of ? = 2 we can derive an approximation algorithm with provable guarantees. We design a semi-definite programming algorithm for a shifted version of our objective. Specifically, the objective is shifted by ? `n 2 ?to ensure that the optimal objective value is non-negative, a necessary condition for designing multiplicative approximation algorithms. Given that a typical real-world graph is sparse, e.g., m = O(n) or m = O(npolylog(n)), the objective is dominated by the main O(n 2 ) term. Therefore, the shifted objective guarantees performance at least as good as Hash Partitioning due to the main term and then optimizes a second order term which is O(m) = o(n 2 ). Our approximation guarantee provides an imrovement of O(log k) over hash partitioning, see Theorem 1.</p><p>Theorem 1. There exists a polynomial time algorithm which provides an ?( log k k )-approximation guarantee for the shifted by ? `n 2 ?Optimal k-Graph Partitioning.</p><p>The proof and algorithm along with the discussion about when the incurred additive error due to shifting does not render the algorithm useless will appear in an extended version of this work. An interesting research direction is to pursue additive rather than multiplicative guarantees for maximizing g(P).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ONE-PASS STREAMING ALGORITHM</head><p>General design. We derive a streaming algorithm by using a greedy assignment of vertices to clusters as follows: assign each arriving vertex to a partition such that the objective function of the k graph partitioning problem, defined as a maximization problem, is increased the most. Formally, given that current vertex partition is P = (S1, S2, . . . , S k ), a vertex v is assigned to partition i such that g(S1, . . . , Si ? {v}, . . . , Sj, . . . , S k ) ? g(S1, . . . , Si, . . . , Sj ? {v}, . . . , S k ), for all j ? [k].</p><p>Defining ?g(v, Si) = g(S1, . . . , Si ? {v}, . . . , Sj, . . . , S k )g(S1, . . . , Si, . . . , Sj, . . . , S k ), the above greedy vertex assignment naturally suggests the following streaming algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Greedy vertex assignment</head><formula xml:id="formula_7">? Assign vertex v to partition i such that ?g(v, Si) ? ?g(v, Sj), for all j ? [k]</formula><p>Application to Classical Balanced Partitioning. We treat the important special case of balancing edge-cuts and vertex cardinality in more detail, since we evaluate it experimentally in Section 5. In this case, ?g(v, S l ) = |N (v) ? S l | -?c(|S l |), where ?c(x) = c(x + 1) -c(x), for x ? R+, and N (v) denotes the set of neighbors of vertex v. The two summation terms in the greedy index ?g(v, S l ) account for the two underlying objectives of minimizing the number of cut edges and balancing of the partition sizes. Notice that the component |N (v) ? Si| corresponds to the number of neighbours of vertex v that are assigned to partition Si. In other words, this corresponds to the degree of vertex v in the subgraph induced by Si. On the other hand, the component ?c(|Si|) can be interpreted as the marginal cost of increasing the partition i by one additional vertex.</p><p>For our special family of cost functions c(x) = ?x ? , we have ?c(x) = ??x ?-1 . For ? = 1, the greedy index rule corresponds to assigning a new vertex v to partition i with the largest number of neighbours in Si, i.e |N (v)?Si|. This is one of the greedy rules considered by Stanton and Kliot <ref type="bibr" target="#b28">[29]</ref>, and is a greedy rule that may result in highly imbalanced partition sizes.</p><p>On the other hand, in case of quadratic cost c(x) = 1 2 x 2 , the greedy index is |N (v) ? Si| -|Si|, and the greedy assignment corresponds to assigning a new vertex v to partition i that minimizes the number of non-neighbors of v inside Si, i.e. |Si \ N (v)|. Hence, this yields the following heuristic: place a vertex to the partition with the least number of nonneighbors <ref type="bibr" target="#b25">[26]</ref>. This assignment accounts for both the cost of cut edges and the balance of partition sizes.</p><p>Finally, we outline that in many applications there exist very strict constraints on the load balance. Despite the fact that we investigate the effect of the parameter ? on the load balance, one may apply the following algorithm, which enforces to consider only machines whose load is at most ?? n k . This algorithm for 1 ? ? ? 2 amounts to interpolating between the basic heuristics of <ref type="bibr" target="#b28">[29]</ref> and <ref type="bibr" target="#b25">[26]</ref>. The overall complexity of our algorithm is O(n + m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Greedy vertex assignment with threshold ?</head><p>? Let I? = {i : ?i ? ? n k }. Assign vertex v to partition i ? I? such that ?g(v, Si) ? ?g(v, Sj), for all j ? I?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL EVALUATION</head><p>In this section we present our experimental findings. Specifically, Section 5.1 describes the experimental setup. Sections 5.2 and 5.3 present our findings for synthetic and real-world graphs respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>The real-world graphs used in our experiments are shown in Table <ref type="table" target="#tab_2">2</ref>. Multiple edges, self loops, signs and weights were removed, if any. Furthermore, we considered the largest connected component from each graph in order to ensure that there is a non-zero number of edges cut. All graphs are publicly available on the Web. All algorithms have been implemented in java, and all experiments were performed on a single machine, with Intel Xeon cpu at 3.6GHz, and 16GB of main memory. Wall-clock times include only the algorithm execution time, excluding the required time to load the graph into memory.</p><p>In our synthetic experiments, we use two random graph models. The first model is the hidden partition model <ref type="bibr" target="#b5">[6]</ref>. It is specified by four parameters parameters: the number of vertices n, the number of clusters k, the intercluster and intracluster edge probabilities p and q, respectively. First, each vertex is assigned to one of k clusters uniformly at random. We add an edge between two vertices of the same (different) cluster(s) with probability p (q) independently  of the other edges. We denote this model as HP(n, k, p, q). The second model we use is a standard model for generating random power law graphs. Specifically, we first generate a power-law degree sequence with a given slope ? and use the Chung-Lu random graph model to create an instance of a power law graph <ref type="bibr" target="#b4">[5]</ref>. The model CL(n, ?) has two parameters: the number of vertices n and the slope ? of the expected power law degree sequence.</p><p>We evaluate our algorithms by measuring two quantities from the resulting partitions. In particular, for a fixed partition P we use the measures of the fraction of edges cut ? and the normalized maximum load ?, defined as .</p><p>Notice that k ? ? ? 1 since the maximum load of a cluster is at most n and there always exists at least one cluster with at least n k vertices.  In Section 5.2, we use the greedy vertex assignment without any threshold. Given that we are able to control the ground truth, we are mainly interested in understanding the effect of the parameter ? on the tradeoff between the fraction of edges cut and the normalized maximum load. In Section 5.3, the setting of the parameters we use throughout our experiments is ? = 3  2 , ? = ? k m n 3/2 , and ? = 1.1. Despite the fact that one can choose ? based on the how skewed the degree sequence is in order to obtain superior performance, see Section 5.2, we use the same value ? for all graphs. This choice of ? is reasonable in the light of our findings in Section 5.2. The choice of ? is based on the related discussion in Section 3. Finally, ? = 1.1 is a small enough load balancing factor for any practical purposes.</p><p>For competitors, we consider the state-of-the-art heuristics. Specifically, in our evaluation we consider the following heuristics from <ref type="bibr" target="#b28">[29]</ref>, which we briefly describe here for completeness. Let v be the newly arrived vertex, then place v to a cluster Si with  <ref type="bibr" target="#b15">[16]</ref> averaged over 5 random graphs generated according to the HP(5 000, k, 0.8, 0.5) model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>? Exponentially Weighted Deterministic Greedy (EDG):</head><p>maximum</p><formula xml:id="formula_8">|N (v) ? Si|(1 -exp (|Si| -n/k)).</formula><p>? Triangles (T): maximum tS i (v).</p><p>? Linear Weighted Triangles (LT): maximum tS i (v)(1 -|Si|/(n/k)).</p><p>? Exponentially Weighted Triangles (ET): maximum</p><formula xml:id="formula_9">tS i (v)(1 -exp |Si| -n/k)). ? Non-Neighbors (NN): minumum |Si \ N (v)|.</formula><p>In accordance with <ref type="bibr" target="#b28">[29]</ref>, we observed that LDG is the best performing heuristic. Even if Stanton and Kliot do not compare with NN, LDG outperforms it also. Non-neighbors typically have very good load balancing properties, as LDG as well, but cut significantly more edges. Table <ref type="table" target="#tab_3">3</ref> shows the typical performance we observe across all datasets. Specifically, it shows ? and ? for both BFS and random order for amazon0312. DFS order is omitted since qualitatively it does not differ from BFS. We observe that LDG is the best competitor, Fennel outperforms all existing competitors and is inferior to METIS, but of comparable performance. In the following, the best competitor is LDG unless otherwise mentioned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Synthetic Datasets</head><p>In this section we present result that support the following main findings: (a) The value ? = 3  2 achieves good performance for all graphs considered. (b) The effect of the stream order is minimal on the results. Specifically, when ? ? 3  2 all orders result in the same qualitative results. When ? &lt; 3 BFS and DFS orders result in the same results which are worse with respect to load balancing -and hence better for the edge cuts-compared to the random order. (c) Fennel's performance is comparable to Metis. (d) It is possible to compute easy graph statistics such as the power-law exponent of the degree sequence of a power-law graph to fine-tune the choice of ?.</p><p>Hidden Partition: We report averages over five randomly generated graphs according to the model HP(5000, k, 0.8, 0.5) for each value of k we use. We study (a) the effect of the parameter ?, which parameterizes the function c(x) = ?x ? , and (b) the effect of the number of clusters k.</p><p>We range ? from 1 to 4 with a step of 1/4, for six different values of k shown in the second column of Table <ref type="table" target="#tab_4">4</ref>. For all k, we observed consistently the following behavior: for ? = 1, ? = 0 and ? = k, which means that cluster receives all vertices. For any ? greater than 1, we obtain good load balancing with ? ranging from 1 to 1.05, and the same fraction of edges cut with Metis up the the first decimal digit. It is noteworthy that this behavior was not expected a priori, since in general we expect the edge-cut ? to increase and ? to decrease as ? grows. Given the insensitivity of Fennel to ? in this setting, we present our findings for ? fixed to 3  2 , in Table <ref type="table" target="#tab_4">4</ref>. For each k shown in the second column we generate five random graphs. The first column shows the average number of edges. Notice that despite the fact that we have only 5,000 vertices, we obtain graphs with several millions of edges. The four last columns show the performance of Fennel and Metis. As we see, their performance is comparable and in one case (k=128) Fennel clearly outperforms Metis.</p><p>Power Law: It is well known that power law graphs have no good cuts <ref type="bibr" target="#b11">[12]</ref>, but power-law graphs are commonly observed in practice so we consider them. We examine the effect of parameter ? for k fixed to 10. In contrast to the hidden partition experiment, we observe the expected tradeoff between ? and ? as ? changes. We generate five random power law graphs CL(20 000,2.5), since this value matches the typical slope of real-world networks <ref type="bibr" target="#b23">[24]</ref>. Figure <ref type="figure" target="#fig_1">1</ref> shows the tradeoff when ? ranges from 1 to 4 with a step of 0.25 for the random stream order. The straight line shows the performance of Metis. As we see, when ? &lt; 1.5, ? assumes a value that may be considered unacceptably large for realworld applications. When ? = 1.5 we obtain essentially the same load balancing performance with Metis. Specifically, ? Fennel = 1.02, ?METIS = 1.03. The corresponding cut behavior for ? = 1.5 is ? Fennel = 62.58%, ?METIS = 54.46%. Furthermore, we experimented with the random, BFS and DFS stream orders. We observe that the only major difference between the stream orders is obtained for ? = 1.25. For all other ? values the behavior is identical. For ? = 1.25 we observe that BFS and DFS stream orders result in significantly worse load balancing properties. Specifically, ?BFS = 3.81, ?DFS = 3.73, ? Random = 1.7130. The corresponding fractions of edges cut are ?BFS = 37.83%, ?DFS = 38.85%, and ? Random = 63.51%.</p><p>Finally, we explore the graph-specific parameter selection. Specifically, we consider the degree sequence as an easy-tocompute graph statistic and we generate for a realistic range of power-law exponents <ref type="bibr">[8]</ref> twenty random power-law graphs on 3000 vertices. The number of vertices is chosen to be large enough in order to ensure that for large power-law exponents the graphs have sufficiently many edges to guarantee concentration of our findings. For each exponent, we compute the average optimal value ? * in the range [1.5, 3.2] using a step of 0.1 over twenty generated graphs that results in the smallest possible fraction of edges cut ? conditioning on a maximum normalized load ? = 1.2. Figure <ref type="figure" target="#fig_2">2</ref> shows the resulting error bars for 8 and 16 clusters respectively. The variance for each power-law exponent is very small compared to the square of the average, indicating a strong concentration around the mean as the error bars show. We observe that ? * tends to be non-increasing function with the power-law slope ?. Also, by comparing Figures <ref type="figure" target="#fig_2">2(a)</ref>,(b) we observe that ? * is less sensitive to k, with a general trend of a decreasing ? * as k increases. Understanding these functions and exploiting them for increasing systems' performance is an interesting problem for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Real-World Datasets</head><p>We summarize our main findings as follows: (a) Fennel is superior to existing streaming partitioning algorithms.   Specifically, over a wide range of k values and over all datasets Fennel consistently outperforms the current state-of-theart. Fennel achieves excellent load balancing with significantly smaller edge cuts. (b) For smaller values of k (less or equal than 64) the observed gain is more pronounced. (c) Fennel is fast. Our implementation scales well with the size of the graph. It takes about 40 minutes to partition the Twitter graph which has more than 1 billion of edges.</p><p>Twitter Graph. Twitter graph is the largest graph in our collection of graphs, with more than 1.4 billion edges. This feature makes it the most interesting graph from our collection, even if, admittedly, it is a graph that can be loaded into the main memory of a state-the-art personal computer. The performance of Fennel on this graph is remarkably good. Specifically, Table <ref type="table">1</ref> shows the performance of Fennel, the best competitor LDG, the baseline Hash Partition and Metis for k = 2, 4 and 8. All methods achieve balanced partitions, with ? ? 1.1. Fennel, is the only method that always attains this upper bound. However, this reasonable performance comes with a high gain for ?. Specifically, we see that Fennel achieves better performance of k = 2 than Metis. Furthermore, Fennel requires 42 minutes whereas Metis requires 8 1 2 hours. Most importantly, Fennel outperforms LDG consistently. Specifically, for k = 16, 32 and 64, Fennel achieves the following re-sults (?, ?) = (59%, 1.1), (67%, 1.1), and (73%, 1.1), respectively. Linear weighted degrees (LDG) achieves (76%, 1.13), (80%, 1.15), and (84%, 1.14), respectively. Now we turn our attention to smaller bur reasonably-sized datasets.</p><p>In Figure <ref type="figure" target="#fig_3">3</ref>, we summarize the results of comparison results of Fennel and all other heuristics that we consider on all graphs from our dataset in Table <ref type="table" target="#tab_2">2</ref>. In that figure, we show the distribution of the difference of the fraction of edges cut of our method and that of the best competitor, conditional on that the maximum observed load is at most 1.1. This distribution is derived from the values observed by partitioning each input graph from our set averaged over a range of values of parameter k that consists of values 2, 4, . . . , 1024. These results demonstrate that the fraction of edges cut by our method is smaller than that of the best competitor in all cases. Moreover, we observe that the median absolute difference (relative difference) is in the excess of 20% (15%), thus providing significant performance gain.</p><p>Furthermore, in Table <ref type="table" target="#tab_6">5</ref>, we present the average performance gains conditional on the number of partitions k. These numerical results amount to an average relative reduction of the fraction of edges cut in the excess of 18%. Moreover, the performance gains observed are consistent across different values of parameter k, and are more pronounced for smaller values of k.</p><p>Bicriteria. In our presentation of experimental results so far, we focused on the fraction of edges cut by conditioning on the cases where the normalized maximum load was smaller than a fixed threshold. Figures <ref type="figure" target="#fig_4">4(a),</ref><ref type="figure">(b</ref>) provide a closer look at both criteria and their relation. Specifically, we consider the difference of the fraction of edges cut versus the difference of normalized maximum loads of the best competitor and our method. We observe that in all the cases, the differences of normalized maximum loads are well within 10% while the fraction of edges cut by our method is significantly smaller. These results confirm that the observed reduction of the fraction of edges cut by our method is not at the expense of an increased maximum load.</p><p>Speed of partitioning. We comment on the efficiency of our method with respect to the run time to partition a graph. Our graph partitioning algorithm is a one-pass streaming algorithm, which allows for fast graph partitioning. In order to support this claim, in Figure <ref type="figure" target="#fig_5">5</ref>, we show the run time it took to partition each graph from our dataset versus the graph size m. We observe that few minutes suffice to partition large graphs of tens of millions of edges. As we also mentioned before, partitioning the largest graph from our dataset collection took about 40 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SYSTEM EVALUATION</head><p>Evaluating a partitioning algorithm is a non-trivial task from a systems perspective, since it depends on system characteristics. For instance, in a large-scale production data center, it may be more important to balance the traffic across clusters than the traffic or the amount of computation executed within a cluster. However, in a small-scale cluster consisting of few tens of nodes, rented by a customer from a large cloud provider such as Amazon's Elastic MapReduce, for example, it may be more important to well balance the computation load on each node. Given this diversity of scenaria, a detailed evaluation is out of the scope of this work. Here, we perform a basic experiment to verify the superiority of our proposed method versus the standard approach load balancing approach of hash partitioning with respect to speeding up a large-scale computation.</p><p>We consider Pagerank as the computational task. Notice, that an advantage of Fennel is that it gives a flexibility in choosing a suitable objective that accomodates the needs of the specific application. We demonstrate the efficiency and flexibility of Fennel with the typical Elastic MapReduce scenario in mind. We set up a cluster and we vary the number of nodes to 4, 8 and 16 nodes. Each node is equipped with Intel Xeon CPU at 2.27 GHz and 12 GB of main memory. On the cluster we run Apache Giraph, a graph processing Since the complexity of PageRank depends on the number of edges and not vertices, we use a version of Fennel objective (eq. 1) that balances the number of edges per cluster with ? = 1.5 We compare with hash partitioning, the default partitioning scheme used by Giraph, with respect to the following two metrics. The first metric is the average duration of an iteration of the PageRank algorithm. This metric is directly proportional to the actual run time and incorporates both the processing and the communication time. The second metric is the average number of Megabytes transmitted by a cluster node in each iteration. This metric directly reflects the quality of the cut and is proportional to the incurred network load.</p><p>The results are shown in Table <ref type="table" target="#tab_7">6</ref>. We see that Fennel has the best run time in all cases. This is because it achieves the best balance between the computation and communication load. Hash partitioning takes 25% more time than Fennel and it also has a much higher traffic load.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>In this work we provide a novel perspective on a recent line of research <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b28">29]</ref> for the balanced graph partitioning problem, which results in state-of-the-art performance in terms of speed and quality. Despite the fact that Fennel performs a single pass over the graph, it achieves performance comparable to Metis, see also <ref type="bibr" target="#b24">[25]</ref>. Furthermore, our general framework is particularly suitable for dynamic graph data. Also, it allows us to quantify the notion of interpolation between the two state-of-the-art heuristics <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b28">29]</ref> for streaming partitioning. Specifically, we evaluate our proposed framework extensively both on synthetic and realworld graphs. We verify consistently over a wide range of number of clusters, the superiority of our method compared to existing ones. Finally, we demonstrate the benefits of the method in the graph processing platform Apache Giraph.</p><p>An interesting research problem is to derive hard approximation guarantees for the class of algorithms defined by Fennel. We provide initial results in this direction for the special case related to the concept of graph modularity. However, additive error guarantees appear to be more suitable for our objective. Second, it would be of interest to understand on a firm mathematical ground, the function shown in Figure <ref type="figure" target="#fig_2">2</ref>. Potentially, this understanding can lead to choosing optimally the parameter values based on simple graph characteristics, such as the exponent of the degree distribution for a power-law graph.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Fraction of edges cut ? and maximum load normalized ? as a function of ?, ranging from 1 to 4 with a step of 0.25, over five randomly generated power law graphs with slope 2.5. The straight lines show the performance of METIS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Figure plots the average optimal value ? * by ranging the power-law exponent in the interval [1.5, 3.2] using a step of 0.1 over twenty generated graphs (for each exponent) that results in the smallest possible fraction of edges cut ? conditioning on a maximum normalized load ? = 1.2 versus the power-law exponent of the degree sequence. Error bars indicate the variance around the average optimal value ? * . Strong concentration around the average is observed. (a) k = 8 (b) k = 16.</figDesc><graphic url="image-1.png" coords="7,84.35,53.82,200.80,150.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: (Left) CDF of the relative difference ( ? Fennel -?c ?c) ? 100% of percentages of edges cut of our method and the best competitor for all graphs in our dataset. (Right) Same but for the absolute difference (? Fennel?c) ? 100%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Absolute difference ?? and relative gain versus the maximum load imbalance ??.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Elapsed running time for Fennel versus number of edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Datasets used in our experiments.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc><ref type="bibr" target="#b24">25</ref>, over five randomly generated power law graphs with slope 2.5. The straight lines show the performance of METIS. Performance of various existing methods on amazon0312 (k = 32).</figDesc><table><row><cell></cell><cell>BFS</cell><cell></cell><cell cols="2">Random</cell></row><row><cell>Method</cell><cell>?</cell><cell>?</cell><cell>?</cell><cell>?</cell></row><row><cell>H</cell><cell cols="4">96.9% 1.01 96.9% 1.01</cell></row><row><cell>B [29]</cell><cell cols="4">97.3% 1.00 96.8% 1.00</cell></row><row><cell>DG [29]</cell><cell>0%</cell><cell>32</cell><cell>43%</cell><cell>1.48</cell></row><row><cell>LDG [29]</cell><cell></cell><cell>1.01</cell><cell>40%</cell><cell>1.00</cell></row><row><cell>EDG [29]</cell><cell>39%</cell><cell>1.04</cell><cell>48%</cell><cell>1.01</cell></row><row><cell>T [29]</cell><cell>61%</cell><cell>2.11</cell><cell>78%</cell><cell>1.01</cell></row><row><cell>LT [29]</cell><cell>63%</cell><cell>1.23</cell><cell>78%</cell><cell>1.10</cell></row><row><cell>ET [29]</cell><cell>64%</cell><cell>1.05</cell><cell>79%</cell><cell>1.01</cell></row><row><cell>NN [26]</cell><cell>69%</cell><cell>1.00</cell><cell>55%</cell><cell>1.03</cell></row><row><cell>Fennel</cell><cell>14%</cell><cell>1.10</cell><cell>14%</cell><cell>1.02</cell></row><row><cell>METIS [16]</cell><cell>8%</cell><cell>1.00</cell><cell>8%</cell><cell>1.02</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 :</head><label>4</label><figDesc>Fraction of edges cut ? and normalized maximum load ? for Fennel and METIS</figDesc><table><row><cell></cell><cell></cell><cell>Fennel</cell><cell></cell><cell>METIS</cell><cell></cell></row><row><cell>m</cell><cell>k</cell><cell>?</cell><cell>?</cell><cell>?</cell><cell>?</cell></row><row><cell>7 185 314</cell><cell>4</cell><cell cols="4">62.5 % 1.04 65.2% 1.02</cell></row><row><cell>6 714 510</cell><cell>8</cell><cell cols="4">82.2 % 1.04 81.5% 1.02</cell></row><row><cell cols="6">6 483 201 16 92.9 % 1.01 92.2% 1.02</cell></row><row><cell cols="2">6 364 819 32</cell><cell cols="4">96.3% 1.00 96.2% 1.02</cell></row><row><cell cols="2">6 308 013 64</cell><cell cols="4">98.2% 1.01 97.9% 1.02</cell></row><row><cell cols="6">6 279 566 128 98.4 % 1.02 98.8% 1.02</cell></row></table><note><p>? Balanced (B): minimum cardinality |Si|. ? Hash partitioning (H): Si choosen uniformly at random. ? Deterministic Greedy (DG): maximum |N (v) ? Si|. ? Linear Weighted Deterministic Greedy (LDG): maximum |N (v) ? Si|(1 -|Si|/(n/k)).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5 :</head><label>5</label><figDesc>The relative gain (1 -? Fennel</figDesc><table><row><cell>?c load imbalance, where subindex c stands for the best ) ? 100% and</cell></row><row><cell>competitor, averaged over all datasets in Table 1 as</cell></row><row><cell>a function of k.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 6 :</head><label>6</label><figDesc>The average duration of a step and the average amount of MB exchanged per node and per step during the execution of PageRank on LiveJournal data set.</figDesc><table><row><cell></cell><cell cols="2">Run time [s]</cell><cell cols="2">Communication [MB]</cell></row><row><cell cols="4"># Clusters (k) Hash Fennel Hash</cell><cell>Fennel</cell></row><row><cell>4</cell><cell>32.27</cell><cell>25.49</cell><cell>321.41</cell><cell>196.9</cell></row><row><cell>8</cell><cell>17.26</cell><cell>15.14</cell><cell>285.35</cell><cell>180.02</cell></row><row><cell>16</cell><cell>10.64</cell><cell>9.05</cell><cell>222.28</cell><cell>148.67</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>At the time of the evaluation, the Twitter graph was too large for a 16-node Giraph cluster.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Dense subgraph maintenance under streaming edge weight updates for real-time story identification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Angel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sarkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>VLDB</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Expander flows, geometric embeddings and graph partitioning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Vazirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="222" to="231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">An experimental analysis of a compact graph representation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Blandford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kash</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>ALENEX</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The average distance in a random graph with given expected degrees</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R K</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internet Mathematics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="91" to="113" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Algorithms for graph partitioning on the planted partition model</title>
		<author>
			<persName><forename type="first">A</forename><surname>Condon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RANDOM-APPROX</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="221" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mapreduce: simplified data processing on large clusters</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="107" to="113" />
			<date type="published" when="2008-01">January 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Evolution of networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sergey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose Ff</forename><surname>Dorogovtsev</surname></persName>
		</author>
		<author>
			<persName><surname>Mendes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in physics</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="1079" to="1187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A polylogarithmic approximation of the minimum bisection</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Krauthgamer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Some simplified np-complete problems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Community structure in social and biological networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Girvan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the National Academy of Sciences</title>
		<imprint>
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="7821" to="7826" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Powergraph: Distributed graph-parallel computation on natural graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pegasus: A peta-scale graph mining system</title>
		<author>
			<persName><forename type="first">U</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E T</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Hermes: Clustering users in large-scale e-mail services</title>
		<author>
			<persName><forename type="first">T</forename><surname>Karagiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gkantsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cloud Computing</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Parallel multilevel graph partitioning</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPPS</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="314" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A fast and high quality multilevel scheme for partitioning irregular graphs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Sci. Comput</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="359" to="392" />
			<date type="published" when="1998-12">December 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Optimizing data partitioning for data-parallel computing</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotOS XIII</title>
		<imprint>
			<date type="published" when="2011-05">May 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An efficient heuristic procedure for partitioning graphs</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell Syst. Tech. J</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="291" to="307" />
			<date type="published" when="1970-02">February 1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Balanced graph partitioning</title>
		<author>
			<persName><forename type="first">A</forename><surname>Konstantin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>R?cke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPAA &apos;04</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="120" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Partitioning graphs into balanced components</title>
		<author>
			<persName><forename type="first">R</forename><surname>Krauthgamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">(</forename><forename type="middle">S )</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA &apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="942" to="949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">What is twitter, a social network or a news media?</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on World wide web, WWW &apos;10</title>
		<meeting>the 19th international conference on World wide web, WWW &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="591" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Graphlab: A new framework for parallel machine learning</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UAI</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="340" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Pregel: a system for large-scale graph processing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Malewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;10</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The structure and function of complex networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM review</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="167" to="256" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Restreaming graph partitioning: Simple versatile algorithms for advanced balancing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nishimura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ugander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM KDD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Managing large graphs on multi-cores with graph awareness</title>
		<author>
			<persName><forename type="first">V</forename><surname>Prabhakaran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC&apos;12</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The little engine(s) that could: Scaling online social networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pujol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM 2010</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Parallel static and dynamic multi-constraint graph partitioning</title>
		<author>
			<persName><forename type="first">K</forename><surname>Schloegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="219" to="240" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Streaming graph partitioning for large distributed graphs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kliot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM KDD</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1222" to="1230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Denser than the densest subgraph: Extracting optimal quasi-cliques with quality guarantees</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Tsourakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gullo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tsiarli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD&apos;13</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Balanced label propagation for partitioning massive graphs</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Ugander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lars</forename><surname>Backstrom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM &apos;13</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="507" to="516" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
