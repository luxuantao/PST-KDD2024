<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Serializability of Concurrent Database Updates</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christos</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<region>Massachusetts</region>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Massachusetts lnst,tute of Technology</orgName>
								<address>
									<addrLine>545 Technology Square</addrLine>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Umvers~ty of Waterloo</orgName>
								<address>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Serializability of Concurrent Database Updates</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8E287ABC7FB4728C148B9695BA6E9CA1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>PHRASES database management</term>
					<term>concurrent update problem</term>
					<term>transactions</term>
					<term>senahzabdlty</term>
					<term>schedulers</term>
					<term>concurrency control</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A sequence of interleaved user transactions in a database system may not be ser:ahzable, t e, equivalent to some sequential execution of the individual transactions Using a simple transaction model, it ~s shown that recognizing the transaction histories that are serlahzable is an NP-complete problem. Several efficiently recognizable subclasses of the class of senahzable histories are therefore introduced; most of these subclasses correspond to senahzabdity principles existing in the hterature and used in practice Two new principles that subsume all previously known ones are also proposed Necessary and sufficient conditions are given for a class of histories to be the output of an efficient history scheduler, these conditions imply that there can be no efficient scheduler that outputs all of senahzable histories, and also that all subclasses of senalizable histories studied above have an efficient scheduler Finally, it is shown how these results can be extended to far more general transaction models, to transactions with partly interpreted functions, and to distributed database systems</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In many situations many users may consult and update a common database. We can think of such independent user transactions as sequences of atomic database operations, interleaved with computauons that are local to the user, that ~s, they do not affect or depend on the current state of the database. It is a function of database management to handle the update and retrieval requests made by the users in such a way so that the resulting overall process is in some appropriate sense correct. It is generally accepted (see, e.g., <ref type="bibr">[3,</ref><ref type="bibr" target="#b4">7,</ref><ref type="bibr" target="#b15">18,</ref><ref type="bibr" target="#b16">19]</ref>) that the right notion of correctness in this context is that of serializability. A sequence of atomic user updates/retrievals is called serializable essentially if its overall effect is as though the users took turns, in some order, each executing their entire transaction indwtslbly. The s~mplest example of a nonseriahzable sequence is a primitive form of a "race." Imagine two users that increment a counter by first sensing its value and later registering an increased one. If both users retrieve the value of the counter before either of them has updated ~t, the resulting execution sequence--or h:story--is not serializable. This ~s because both possible serial execuuons of these transactions would have resulted in a larger total increment. Naturally, much subtler examples exist.</p><p>The appeal of senahzability as a correctness criterion Is quite easy to justify. Databases are supposed to be faithful models of parts of the world, and user transactions represent instantaneous changes in the world. Since such changes are totally ordered by temporal priority, the only acceptable interleavings of atomic steps of different transactions are those that are equivalent to some sequential execution of these transactions. Another way of viewing serializability is as a tool for ensuring system correctness. If each user transaction is correct--i.e., when run by itself, it is guaranteed to map consistent states of the database to consistent states--and transactions are guaranteed to be intermingled in a serializable way, then the overall system is also correct.</p><p>In this paper we consider transactions that consist of two atomic actions: a retrieval of the values of a set of database entities--called the read set of the transaction--followed by an update of the values of another set of entities--the write set. This is exactly the kind of transactions handled by the system SDD-I <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b14">17]</ref>. However, the main reason for considering this model here is that it provides a nice framework for understanding and comparing very different philosophies of senalizability that already exist in the literature (e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">4,</ref><ref type="bibr" target="#b4">7,</ref><ref type="bibr" target="#b16">19]</ref>). Despite its apparent simplicity, it yields a theory of serializability that is rich in combinatorial intricacies and raises interesting complexity questions. Since our model is the most general common restriction of the models in the various references cited above, our negative results apply verbatim to those models. Furthermore, most of our positive results and characterizations are also easily generalizable to more general situations, although their proofs--m many cases their very statements--would be extremely cumbersome. Hence we view our model as a convenient language, of the right degree of conceptual complexity, for developing and communicating our ideas about serializabihty, rather than as a set of restrictions that enable the proofs of certain theorems. We formahze our model of transactions in Section 2, where some preliminary results are also proved.</p><p>In Section 3 we prove that the question of whether a given sequence of read and write operations corresponding to several transactions (called a history) is senalizable is NPcomplete <ref type="bibr">[l, 9]</ref>. This suggests that, most probably, there is no efficient algorithm that distingmshes between senalizable and nonserializable histories.</p><p>In Section 4 we study some efficiently recognizable subsets of the set of serializable histories In other words, we present polynomial-time "heuristics" that approximate the NP-complete predicate of seriallzabihty, in a manner quite reminiscent of effficlent approximations of NP-complete optimization problems <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b13">16]</ref>. We show that the two-phase locking strategy of <ref type="bibr" target="#b4">[7]</ref> and the protocol P3 of <ref type="bibr" target="#b1">[2]</ref> are incommensurate special cases of two more general classes called Q and DSR--the latter is related to the model of <ref type="bibr" target="#b16">[19]</ref>. These two seriahzability principles are therefore very general (and apphcable) new serialization methods. We also introduce the class SSR of histories that can be serialized without reversing the order of temporally nonoverlapping transactions; it is not known whether this class is efficiently recognizable In Section 5 we observe that the quite intricate interrelations among these interesting classes are simplified considerably ff some "static" restrictions are imposed on the read and write sets. We point out there that the simple serializability theory of <ref type="bibr" target="#b16">[19]</ref> is due to such a restriction of their model.</p><p>For all efficiently recognizable classes of histories studied in Sections 4 and 5 there is also an efficient scheduler, an algorithm, that is, which takes any history and transforms it to its closest (according to some appropriate metric) history within the class considered. In Section 6 we show that this is no accident, a class of histories has an efficient scheduler if and only if it is efficiently recognizable plus a regularity condition, namely, that its set of prefixes is also efficiently recognizable. By this result, the complexity theory developed in Sections 3 through 5 ts practically relevant, because the practical question of the existence of an efficient scheduler for a given class of histories is explicitly linked to the complexity properties of the class. Another imphcatlon is the negative result that, unless ~ = ,A/'~, there is no efficient "serializer" of histories, and hence considering efficient but more restrictive schedulers--such as the ones discussed above--is a reasonable alternative. Finally, Section 7 concludes our treatment of the subject. We discuss there a number of possible extensions of our results, such as to general (multistep) transactions and distributed databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Defintttons and Notation</head><p>A history is a quadruple h = (n, ~r, V, S), where n is a positive integer; ~r is a permutation of the set ~ = {R,, W~, Re, W2 ..... R~, W~}--that is, a one-to-one function ~r:~n { 1, 2 ..... 2n)--such that ~r(RJ &lt; ~r(W,) for i = 1, 2 ..... n (a permutation ~r is represented by (~r-~(l), ~r-1(2) ..... ~r-~(2n))); and finally, S is a function mapping ~ to 2 v, where Vls a finite set of variables. Each pair (R,, W,) will be called a transaction T. S(R,) will be called the read set of T,, and S(t'E) its write set. We shall represent histories in a compact way by exhibiting ~r, with the sets S(-) given in brackets following each element of ~. For example, the history h = (3, (R~, Re, W~, R3, We, W3), {x,y}, S), where S(R1) = S(R3) = (x}, S(Re) = ~, S(W3) = {y}, and S(W~) = S(We) = {x,y}, is represented as</p><formula xml:id="formula_0">h = R~[x]R2 W~[x, y]R3[x] We[x, y] W3[y].</formula><p>The set of all histories is denoted by H.</p><p>We can think of each transaction T~ as starting with an instantaneous reading of the values in the variables m S(R,), performing a possibly lengthy local computation, and then instantaneously recording the results in a different set S(W,) of variables. We do not look into the details of the exact nature of the local computation. In fact, we view each transaction T, as a set of IS(W,)I uninterpreted I S(R,)l-ary function symbols (fi~ :j = 1 ..... IS(W,) 1}. ~r Is the sequence in which these atomic read and write operations take place. Thus, a history can be wewed as a special case of a fork-join parallel program schema m which the local computations involve a number of local temporary variables t v and are executed in parallel with other read-write operations (see Figure <ref type="figure" target="#fig_0">1</ref>).</p><p>The concatenatwn of two histories h~ = (n, ~r, V, S), he = (m, p, V, T) is a history hi o ha = (n + m, ~, V, P), where P(W,) = S(W,) ff i _&lt; n, and P(I.I'~) = T(I.E-~) for i &gt;'n. Similarly, P(R,) = S(R,) ff i _&lt; n, and P(R,) = T(R,-~) for t &gt; n. Also z(W,) = ~r(W,) if i _&lt; n, and ~(W3 = p(W,_~) + 2n for i &gt; n, ~'(R3 = ~r(R,) for i _&lt; n, z(R,) = o(R,-~) + 2n for i &gt; n. In other words hi o h~ is a juxtaposition of the two histories, only with the transactions of h2 renamed. Thus, if and then</p><formula xml:id="formula_1">h~ = R~[x]Re[y] We[y]R3 W~[z] W3[y] h2 = Ra[x, y]Re[x] W~[y] We[z], h, o he = R~[x]Re[y] We[y]R~ W~[z] W3[y]R,[x, y]Rs[x] W,[y] W~[z].</formula><p>We say that two histories hi = (n, ~r, V, S) and h2 = (n, C, V, S) are equivalent (written hi -= h2) if and only if the corresponding schemata are (strongly) equivalent. In other words, given any set of I V[ domains for the variables, any set of initial values for the variables from the corresponding domains, and, furthermore, any interpretation of the funeUonsfij, the values of the variables are identical after the execution of both histories. Notice that our definmon of equivalence reqmres that the two histories involve the same set of transactions. Thus hi</p><formula xml:id="formula_2">= R~[y]R2 We[x] W~[x] is not equivalent to he ffi Rl[y] Wl[X],</formula><p>despite the fact that their corresponding schemata are equivalent (essentially because Te is "dead" in hi). This is a matter of convenience, and little change to our derivations would be necessary in order to broaden equivalence in this sense.</p><p>To give a syntactic characterization of equivalence, it Is necessary to first introduce some terminology. Let h = (n, ~r, V, S) be a history. The augmented version of h is the history/~ = (n + 2, ~', V, S), where ~" = (R~+t, Wn+l, ~r, Rn+e, Wn+e) and g(R~) = S(R,), S(W~) = In other words, /~ is h preceded by a transaction that initializes all variables without sensing any, and followed by a transacuon that reads the final values of all the variables, without changing them. Suppose that x ~ S(R,). We say that R, reads x from Wj in h if W~ is the latest occurrence of a write symbol before R, in ~ such that x E S(W~). Notice that since /~ contains Wn+l with S(W,+0 = V, such a write symbol always exists. The definition of a live transaction in h is as follows: The following is now a simple syntactic characterization of history equiyalence, essentially a restatement of the characterization of schema equivalence m terms of Herbrand interpretations <ref type="bibr" target="#b11">[14]</ref>: PROPOSITION 1. Two histories hi = (n, ~r, V, S) and h2 = (n, ~r', V, S) are equivalent tf and only if they have the same sets of live transactions, and a live R~ reads x from W~ m hi if and only if R, reads x from Wj in h2.</p><p>One of the implications of Proposition 1 is that equivalence of histories can be decided efficiently. The sets of live transactions can be found in O(n. I VI) time by applying the recurslve definition given above, and so can the reads from relation for transactions. Hence The main theme of this paper is the notion of serializability. A history h = (n, ~r, V, S) is sertal if 7r(W,) = ~R,) + 1 for all i = 1, 2 ..... n; in other words, a history is serial if R, immediately precedes W, in it for i = l ..... n. A history h is serializable (notation: h E SR) if and only if there is a serial history h8 such that h m hs. In the next section we shall present a syntactic characterization of serializable histories analogous to (and based on) Proposition I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The Complexity of Serializability</head><p>In order to examine the complexity of the serializability problem, we need first to introduce some graph-theoretic terminology. Definition 1. Apolygraph I P = (N, A, B) is a digraph (N, A) together with a set B of bipaths; that is, pairs of arcs--not necessarily in A--of the form ((v, u), (u, w)) such that (w, v) ~ A.</p><p>Alternatively, a polygraph (N, A, B) can be viewed as a family ~(N, A, B) of digraphs. A digraph (N, A ') is in ~(N, A, B) if and only if A C A ', and, for each bipath (al, a2) E B, A' contains at least one of al, a2. Polygraphs will be represented schematically as in Figure <ref type="figure" target="#fig_3">2</ref>(a). Arcs in A will be drawn as ordinary arrows, and pairs of arcs in B will be marked by a circular arc centered on their common node. For example, the digraph of Figure <ref type="figure" target="#fig_3">2</ref>(b) is both in ~(N, A, B) and acyclic; it follows that (N, A, B) of Figure <ref type="figure" target="#fig_3">2</ref>(a) is acyclic. Notice that for a polygraph (N, A, B) to be acyclic, the digraph (N, A) must definitely be acyclic.</p><p>Given any history h = (n, 7r, V, S), we are going to define a polygraph P(h) = (N, A, B). N is the set of live transactions of/~, the augmented version of h. First, A contains the arcs {(Tn+l, v):v E N --{Tn+l}}, and also the arcs {(v, Tn+2):v E N -{Tn+2}}. Second, whenever transaction u reads some variable x from v in h, we add the arc (v, u) in A. Furthermore, if for a third transaction w, x is in the write set of w, then we add the bipath ((u, w), (w, v)) in B. This concludes the construction of P(h).</p><p>Intuitively, P(h) captures a partial order that can be interpreted as "happened before" and with which any history that is equivalent to h must be consistent. Each arc (v, u) means that u read some variable from v and hence must follow it. Also, a bipath ((u, w), (w, v)) means that w wntes on the same variable and hence cannot be in between v and u; it must either precede v or follow u. This is stated as a lemma:</p><p>LEMMA 1.  1, P(h) = P(hJ However P(hJ = (N, A, B) is acyclic. To see this, let (Ti ..... T,) be ordered according to their occurrence m h~. We construct a digraph (N, A ') ~ ~(P(hs)) as follows:</p><p>A' contains the arcs m A, and for each bipath ((T, T~), (Tj, Tk)) in B we add to A the arc (T, Tj) if i &lt;j, or (T~, Tk) ifj &lt; k. To show that exactly one of these must occur, recall that in hs, T, reads a variable x E S(V~) from Tk, and hence k &lt; i and not k &lt; j &lt; i. Consequently, the above construction yields a &amp;graph (N, A ') in .~(P, A, B). Next, not]ce that (N, A ') is acyclic since it is a subgraph of the total order (T,+i, T1 .... , T,, T,+2). So P(h) is also acyclic. Now let (N, A ') be an acychc digraph in .~(P(h)). The serial history hs resulting from topologically sorting (N, A ') is then eqmvalent to h. This follows from Proposition 1 and from the fact that since one of the two arcs of each bipath in B is in A ', all transactions m he read all variables from the same transaction in h as they do in h~. [] Unfortunately, the combinatorial characterization of serial reproducibility shown in Lemma 2 does not directly suggest an efficient test. In fact, the theorem below is strong evidence that no such test exists.</p><p>THEOREM 1. Testing whether a history h is serializable is NP-complete, even if h has no dead transactwns.</p><p>In order to proceed with the proof of Theorem 1 we first need another lemma. It is well known (see <ref type="bibr">[ 1,</ref><ref type="bibr" target="#b6">9]</ref>) that the satisfiability problem of Boolean formulas in conjuncuve normal form with two or three literals in each clause (abbreviated SAT) is NP-complete. We can show that a more restricted version of this problem is still NP-complete, Call a clause mixed if it contains both variables and negations of variables, and call a formula nonclrcular ff at most one of the occurrences of each variable ts m a mtxed clause.</p><p>LEMMA 3. SA T is N P-complete even if the formulas are restricted to be noncircular. PROOF. Consider any instance F of SAT and a variable x in it. Let m be the number of occurrences of x m the formula F, and let xl, x2 ..... xm be new variables. We replace x in its first occurrence by x~, in its second by .,~2, in its third by x3, etc. Finally, we add the clauses (xl V x2) A (xl V Y:2) A (x~ V x3) A (.~2 V £a) A ... , which is the conjunctive normal form of x~ ~ .~2 -= xa ~ .~4 =-.... Repeating this for all variables, we observe that ~aj bj FIG 3</p><p>the resulting formula is trivially nonclrcular, and the construction requires only a polynomml amount of time. [] PROOF Or THEOREM 1. The set of SR histories is definitely in X~, since to show that h is SR, one only needs to construct a serial history hs (of length not greater than that of h) and check by Proposmon 1 that h and hs are equivalent.</p><p>We will show next that a known NP-complete problem, the noncircular SAT problem of Lemma 3 above, reduces to SR-testmg in polynomial time.</p><p>Given any such formula F, we are going to construct a polygraph Pr = (N, A, B) such that PF is acychc if and only If F is satisfiable. We will then show that Pe can be considered as P(h) for a suitable history h, without dead transactions. In view of Lemma 2, this will conclude the proof.</p><p>We Finally, we add to N the nodes no, n, and nf, together with the arcs (no, n), (n, n~), and (n, nf) for all n E N -{no, n~, nf}, and also the arc (n, nf). This concludes the construction of PF. In Figure <ref type="figure" target="#fig_7">4</ref>(a) we dlustrate the construction for the Boolean formula</p><formula xml:id="formula_3">F = (xl V x2) A (xl V 22 V X3) A (22 V 2a).</formula><p>For s~mphoty, m Figure <ref type="figure" target="#fig_7">4</ref> we have omitted the nodes no and nf.</p><p>We will now argue that PF is acychc if and only if F is satisfiable. Suppose that PF is acyclic. This means that there is an acychc digraph (N, A ') E ~(PF). Obviously, for each j, exactly one of the edges (b:, c:) and (c:, ag) is in A' Consider the fact that (c:, a:) ~ A' means that x: is assigned the value true. We may immediately note that if a literal X,k is given the value false by this assignment, the correspondmg arc (z,k, y,k) is also in A', since otherwise, a cycle of the form (c:, y,k, b~)--or (z,k, c:, a:) if X,k = .,t--would exist in (N, A '). Hence, the only way for (N, A ') not to have a cycle of the form (za, ya, z,z ..... y,a) is that at least one hteral m each clause is assigned the value true, which means that F is satisfiable.</p><p>Conversely, suppose that F is satisfied by some truth assignment T. We will construct an _//I~/// '\ \'--\\ "' </p><formula xml:id="formula_4">// / / \ I \\ \ \ / // \ J I \ \ !x / / z22 ~--J..--.,.6 yzz \\ ! y12 ~-3.4Zlz ./ \ ~w,2~-~, \ \ / ~ / Y31 / L31 \ \ / \ / / / \ / \ X I \ I I x \ / \ / I \\ ~Yll ..q/Y21 Z2x' ~ ,ct~z32 / / ~. Z3\ .,'L~ z . "~,, is&amp; / _ K "~\ ,/i \ 21 rz3~',,t-1,/ "" "\ .,&gt;" ..... ;\\ Y32 \\.~V" \ I \\ ~ b I a~ "~I ,J3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>In order to conclude the proof we need to construct a history h such that P(h) --Pr. All nodes of PF correspond to distinct transactions. To construct the read and write sets of the transactions (except for no, no, and nr), we start by having all read sets empty and a variable xv in the write set of each transaction v. For each arc (v, u) E A we add a variable xv, to the write set of v and the read set of u, and for each bipath ((v, u), (u, w)) ~ B we add xwv to the write set of u. Finally, R(no) = 0, W(no) = {xv:v E N}, R(nf) = {xuv:(u, v) E A}, R(nc) = {xv:u E N}, W(nf) = ~5, W(n~) = {x,o:(u, v) E A}. In order to sketch the construction of h, we represent the read and write operations corresponding to the node v of PF by R(v), W(v) respectively. We use v to stand for R(v) W(v). We start the construction of h from left to right. First, for each clause C, consisting of just negations we add the subhistory h(C,) = yn ... y,m,. Next, for each variable x~ that appears unnegated in the mixed clause Ct (i.e., Xtk ffi xj) we add the subhistory h(x~) = R(aj)z,mc~ W(aj)R(bj)yt&amp; W(b~).</head><p>The Z,m part appears only if C, is purely negated and A,m = .fj. Further, ifXm = xj for some purely unnegated clause Cp then Ym appears also after ylk. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Then follow subhistories corresponding to the remaming variables. If xj does not appear unnegated in a mixed clause, then we add to h the subhistory h(x~) = R(a~)z,,cj W(aj)R(bj)ytk W(b~). Again, ylk appears only if</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Efficwntly Recognizable Classes of Serializable Histories</head><p>Given that SR Is NP-complete, it is reasonable to look for subsets of SR that are efficiently recognizable. In this section we study several such classes of serlahzable histories.</p><p>4.1 THE CLASS DSR. Definition 3. Let hi = (n, ~r, V, S) and h2 = (n, ~r', V, S) be histories. W e write that hi h2 whenever It(a) = ~r'(o) for all o E Z~ except for two elements ~rl, o2 ~ ~ with ~r(o~) = ~r'(o2) = J, ¢r(oz) --~r'(ol) = j + 1 for some 1 _&lt; j &lt;_ n -1, and (a) ol = R,, o2 = R~ for some i, j _&lt; n, or (b) ol = R,, o2 = W:, i # j, i, j _&lt; n, and S(R,) f') S(W:) = ~, or (c) ol = W,, o[ = W:, t,j _&lt; n, and S(W,) N S(W:) = f~.</p><p>As an dlustration, we have that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R,[x]R2[x] W~[x] W~[y] ~ R~[x]R2[x] W2[y] W~[x] ~ R~[x]R~[x] W2[y] W~[y] ~ R2[x] W2[y]g~[x] W~[x],</head><p>because at each step the next history is obtained from the previous one by switching two adjacent symbols obeying one of the conditions (a), (b), and (c) of Definition 3 above.</p><p>The following is a direct consequence of Proposition l and the above definition:</p><formula xml:id="formula_5">PROPOSITION 2. I f hi ~ h2, then hi ~ h2.</formula><p>Let L be the reflexive-transitive closure of ~. Since ~ is symmetric, ~* is an equivalence relation that is, by Proposmon 2, a restriction of ---. We can show that -* is a proper restriction of ---by observing that for the two histories</p><formula xml:id="formula_6">hi = R1R2 W~[x, y] W2[x, z]Ra[x] W3[x] and we have but hz = RiR2 Wz[x, z]Ra[x] Wl[x, .y] W3[x] hi ~ h2, hl ~ h2.</formula><p>We say that the history h is D-serializable (DSR) if there is a serial history hs such that h ~ hs. Obviously, if a history is DSR, it is certainly SR.</p><p>We can associate with a history h = (n, It, V, S) a digraph D(h) defined as follows: The nodes of D(h) are the transactions {T~ . . . . . Tn} of h, and the pair (T,, T1) is an arc of D(h) if and only if one of the following holds: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LEMMA 4. Suppose that for two histories hi = (n, ~r, V, S) and h2 --(n, ~r', V, S), D(hl) and D(h2) have no cycles of length 2. Then hi ~" h2 if and only if D(hl) ffi D(h2).</head><p>PROOF. It should be obvious from the definition of D(h) and the ~ relation that whenever hi ~ h2, also D(hl) = D(h2). Consequently, hi ,L h~ implies D(hl) --D(h2).</p><p>For the other direction, assume that D(hl) ffi D(h2). We shall transform h2 to hi by a sequence of ~ transformations as follows: Take the symbol in ~n that is the first symbol in hi (i.e., tr-1(1)) and bring it to the first place of hz by successively switching it with all symbols preceding it in h2; then take w-l(2) and bring it to the second position by switching it with all symbols preceding it, except ~r-l(l); and so on, until h2 is transformed to hi. It remains to show that all these switchings have been legal ~ transformations. Suppose that at some time we had to swatch ol and 02 in a manner not allowed by Definition 3; that as, one of the following holds:</p><p>(a) ol = R~, 02 = I4,~. This means, however, that in hi, W, precedes R~, and hence hi is not a history.</p><p>( For the other direction, assume that h is DSR. We have two cases:</p><p>(a) D(h) has a cycle (T~, Tj, T,) of length 2. This means that qr(R,) &lt; ~r(W~) &lt; ~r(W,), and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S(R~) N S(W~) ~ ~, S(W~) N (S(W~) U S(Rj)) ~ ~. It is easy to show that in all histories h'</head><p>for which h ~* h' we will also have ~r'(R,) &lt; ~r'(Wj) &lt; ~'(WJ, as otherwise h ~ h' and h ~ h', by Proposition 2. Hence there is no serial history hs such that h ~* hs, a contradicUon. PROOF. Suppose that h E Q, and let S~ . . . . . Sn be appropriate numbers. Without loss of generahty S~ &lt; $2 &lt; ..-&lt; Sn. We shall show that whenever (T,, Tj) is m D'(h), then i &lt; j. Suppose that i &gt; j; by the definmon of D'(h) one of the foUowmg must hold:</p><p>(a) ~r(W,) &lt; ~r(Rj). However, S, &lt; ~r(W,) &lt; ~r(R~) &lt; Sj, which contradicts our assumption that $1 &lt; $2 &lt; ... &lt; Sn and i &gt; j. Consequently, D'(h) is acychc, since it is a subgraph of a total order. For the other direction, suppose that D'(h) is acyclic. We can sort its nodes topologically to obtain the order, say, (T1, T2 . . . . Tn). We can define the real numbers S~, $2 ..... Sn, and S~+1 (for convenience) as follows. It is clear that the Sj's are distract, increasing, noninteger real numbers, and that they satisfy (b) and (c) of Definmon 4. It suffices thus to prove (a) of Definition 4, in particular, that S, &gt; ~r(R,) for all t. Suppose that, for some i, S, _&lt; ~r(R,). L e t j be the smallest index, no smaller than ~, for which ~r(14,~) &lt; S~+a Thus S, = ¢r(l,l,~) -( j -i + l)/(n + 1) &gt; ~r(/,t,~) -1.</p><p>Consequently ~r(R,) &gt; rr(Wj) -1, or ~r(R,) &gt; ~r(l,V~). Hence (T~, T,) ~ A, which contradicts the fact that j _&gt; i in the topological sorting of D'(h) [] COROLLARY. Testing whether a history h = (n, ~r, V, S) is m Q can be done in 0(I V In 2) trine.</p><p>4.3 Two-PHASE LOCKING aND THE PROTOCOL P3. A very influential proposal for guaranteeing senahzability of update systems has been the two-phase locking mechanism of <ref type="bibr" target="#b4">[7]</ref>, also d~scussed extensively in <ref type="bibr">[4]</ref>. Also, the essence of a qmte different serializability principle (which was used in the development of the SSD-I distributed system <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b14">17]</ref>) ~s captured by the so-called protocol P3 (see <ref type="bibr">[4]</ref>). In this subsection we show that these two different philosophies of serializability are reduced, in our model, to two efficiently recogmzable incommensurate subsets of our class DSR.</p><p>The two-phase locking strategy requests and releases actual locks--i.e., mechanisms that guarantee exclusive data access--during the execution of the different operations of an update. The rule that ~s proven sufficient for guaranteeing senalizability is: Never request a lock after a lock has been released. We have, therefore, two phases: one during which locks may only be requested, followed by one during which locks can only be released. The first release of a lock dehm~ts the two phases. In our model of two-step updates the To understand Defimtion 5, consider a transaction (R~, Wj) in a history h E 2PL, and its lockpoint/1. The intuitive meaning of the lockpoint is the following: During the interval [~r(Rj), l:] all variables in S(R~) are "'protected" from writing by other transacuons, by virtue of (b). Also, during the interval [/j, 0r(Wj)] the variables in S(Wj) are protected from reading and writing. Conditions (b) and (c) therefore essentially say that the interval [lj, ~Wj)] overlaps no interval [lk, ~r(Wk)] with S(Wk) N S(Wj) # ~5 and no interval lARk), Ik] with S(Wj) 1"3 S(Rk) # ~5. Thus, the second lock is granted before the first is released, in accordance with the two-phase locking principle.</p><p>Although Defimtions 4 and 5 differ only slightly in condition (c), the latter is a substantial restriction. First, we nonce that 2PL C_ Q. Indeed, if h ~ 2PL then the lockpomts li ..... In are automatically valid serializability points S~ ..... Sn m Definition 4. To see this, just notice that condition (c) of Definition 5 (~W,) &lt; 1j) and (a) (l, &lt; ~W,)) together imply (c) of Definition 4 (namely, S, &lt; Sj). To show that the inclusion is proper, notice that for the history</p><formula xml:id="formula_7">h = Rd~2R3[x]W~[x]W2[y, z]W3[y],</formula><p>we have that h E Q (see Figure <ref type="figure">5</ref>(a) for D'(h)) but h ~ 2PL. The explanation for the latter fact is that transacuon 3 has no lockpoint/3, since if it had,/3 should obey/3 &lt; l~ &lt; 4 (by (b)) and also/3 &gt; 5 (by (c)).</p><p>We can, however, check very efficiently whether a history h is two-phase locked. Given any history h = (n, ~r, V, S) we define the history h* ffi (2n, ~r*, V, S*), where h* is obtained from h by inserting a transaction R~+j, Wn+~ after I¢~ in h forj = 1 ..... n; S*(Rn+~) = ~, and S*(W~+~) = S(B¢). For example, the history h* for h of the example above is To illustrate the theorem, the history h above is in Q, since D'(h) is acyclic (Figure <ref type="figure">5(a)</ref>). However, it is not in 2PL, because D'(h *) is not acyclic (Figure <ref type="figure">5(b)</ref>). Naturally, Theorem 5 yields</p><formula xml:id="formula_8">h * = RIR2R3[x] WI[X]R4 W4[X] W2[y, z]R~ W~[y, z] W3[y]R 6 W6[y].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TH~ORnM 5. For a history h = (n, ~r, V, S), h ~ 2PL if and only if h</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>COROLLARY. Testing whether a history h = (n, It, V, S) is two-phase locked can be done in O(n2l V D time.</head><p>We now turn to formalizing and studying in our model the protocol P3 of <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr">[4]</ref>.</p><p>Recall the &amp;graph D(h) defined for any history h in Subsection 4.1; see Figure <ref type="figure" target="#fig_15">6</ref>(a) for an illustration in the case of </p><formula xml:id="formula_9">h -~ Ri[z]R3 W3[xlR2[x] Wi[z]R4 W2[y, z] W4[x].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S(RO n S(W,2) ~ ~.</head><p>Notice that in the above definition the first node of a cycle and the order of listing of the nodes are important. For example, in Figure <ref type="figure" target="#fig_15">6</ref> (Ti, Tz) is a bad cycle, whereas (Tz, T1) is not. Bad cycles are, intuitively, those cycles that can correspond to a direct cycle in D(h') for some other history h' involving the same transactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (continued)</head><p>. Let h = (n, m V, S) be a history. We say that Tj is a guardian of T, if there exists a bad cycle (T,, Tj ....</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. Tk) in G(h). We say that h obeys" the protocol P3</head><p>(notation h ~ P3) if whenever Tj is a guardian of T, we do not have ~r(R3 &lt; ~r(Wj) &lt; ~(W,).</p><p>For example, consider the history h of Figure <ref type="figure" target="#fig_15">6</ref>. The only bad cycle in G(h) (Figure <ref type="figure" target="#fig_15">6(b)</ref>) is (/'1, T2), and hence the guardian relation is simple: just T2 is a guardian of T~. Since ~r(W2) &gt; ~z(Wl), we have that h E/3. THEOREM 6. Suppose that h = (n, ~r, V, S) is in 1'3. Then it is also in DSR. PROOF. We shall show that h E P3 implies that D(h) is acyclic. Suppose that D(h) has a cycle (/'1, T2 ..... Tin), m &gt; 2. Consider the arc (Tj, T~+~) of D(h)--addition rood m; we have three cases: Notice that in both cases (a) and (b) we have that ~r(Wj) &lt; ~Wj+i) and that more than one ease may be applicable to the same arc. Case (c) is spht into two subcases: ¢HRISTOS H. PAPAD1MITRIOU (el) Cases (a) and (c) do not apply to the arc (T~-l, Tj). (c2) j --l, or case (a) or case (c) applies to (T~-i, T~).</p><p>In case (el) we have that Ir(W~-l) &lt; ¢r(Rj) &lt; ~r(B'~+l). In case (c2), however, we notice that Tj+i is a guardian of T~. Consequently, since ~r(R~) &lt; ~Wj+i) we must necessarily have that ~w~) &lt; ~(w~+l). Now consider the operations Oj, j = 1 ..... m, where Oj --Rj if case (el) is applicable to the arc (Tj, Tj+i), and O~ = W~ otherwise. We have shown that ~r(Oj) &lt; ~(Oj+l) for j = 1 ..... m (addition mod m) This is a contradiction, since it implies that ~r(Wl) &lt;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>~.(w~). []</head><p>Theorem 6 implies the following, independently proved in [4]: COROLLARY. Histories that obey the protocol P3 are seriahzable. Our next result concerns the complexity of recognizing those histories that obey protocol P3. By the definition of this class, this complexity is determined by the complexity of computing the guardian relation among the transactions in a history. We shall show how this relation can be computed efficiently. For each transaction T~, let F(T~) be the set of all transactions T, that satisfy S(R~) N S(W~) # 0. Thus F(T~) is the set of all transactions that are possibly guardians of Tj. To determine whether a transaction T, ~ F(Tj) is indeed a guardian of Tj, we delete all edges [T~, Tk] such that S(Wj) A [S(Wk) O S(R~)] = O from G(h) and then determine whether T, and Tj are on the same biconnected component of the resulting graph. This can be done in O(n 2) time by the algorithm of <ref type="bibr" target="#b17">[20]</ref>. If T, and T~ are on the same biconnected component, this means that there is a bad cycle (Tj, T, ..... Tk) in G(h), and hence T, is a guardian of Tj; otherwise, it is not. Repeating this for all T/s, we get an algorithm of total complexity O(n2(I V I + n2)). Hence we have THEOREM 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Testing whether a history h --(n, ~r, V, S) ~ P3 can be done in</head><formula xml:id="formula_10">O(n2(I V[ + n2)) time.</formula><p>4.4 THE CLASS SSR. Certain histories, though perfectly senalizable, have a curious-and, according to some, undesirable--property. Consider, for example, the history</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>h --R~[x]R2 W2[x]R3 W3[y, z] W~[ y].</head><p>This history is serializable. However, the only serial history equivalent to h is easily shown to be</p><formula xml:id="formula_11">hs = R3 Wa[y, Z]Rl[X] Wi[y]R2 W2[x].</formula><p>What is interesting is that in h transaction 2 has completed execution before transactmn 3 has started executing, whereas the order in hs has to be the reverse. This phenomenon is quite counterintuitive, and It has been thought that perhaps the notion of correctness in transaction systems has to be strengthened so as to exclude, besides histories that are not serializable, also histories that present this kind of behavior. This leads to the following definition: Definition 7. A history h = (n, ~r, V, S) is said to be serializable in the strict sense (notation: h E SSR), if there is a serial history hs = (n, ~r', V, S) such that h -~ hs and ~r(W,) &lt; ~Rj) implies ~r'(W,) &lt; ~r'(R~).</p><p>It is not hard to verify that all histories in the class Q satisfy Definition 7. To see this, recall that a history h in Q has a set of serializability points S~ &lt; $2 &lt; ... &lt; Sn, say, such that hs = Ri W~ ... R~ W~ ~-h. Now if ~r(W,) &lt; z'(Rj), we have, by the definition of S~, S, &lt; qr(I'I4) &lt; ~Rj) &lt; S~, and therefore i &lt; j. Hence transactions i and j have the same order in hs that they have in h. It follows that Q c SSR.</p><p>Nevertheless, the classes Q and SSR are not the same, as conjectured in <ref type="bibr" target="#b19">[22]</ref>. A counterexample is</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>h = R,[z]R2[z] W2[x, z]Ra[x] WI[x, y] W3[z]R4[y] W,[x].</head><p>This history is equivalent to the serial history  <ref type="figure">7</ref> is not acychc. It is not known whether the class S S R is efficiently recognizable. 4.5 SUMMARY. The topography of the set of all histories H and its subclasses SR, S (the serial histories), Q, SSR, DSR, P3, and 2PL is depicted in Figure <ref type="figure">8</ref>. The inclusions shown either follow from the results of this section or are straightforward. We also show below an example of a history for each of the 12 regions in this diagram.</p><formula xml:id="formula_12">hs ----RI[Z] WI[X, y]R2[z] W2[x, z]Ra[x] Wa[z]R4[T] W4[x]</formula><formula xml:id="formula_13">h, = R,[x] W,[x]R2[x] W2[x] h2 = R][x]Rz[y] W][x] W2[y] ha = R,R2Ra[x] W,[x]W2[y, z] Wa[y] h4 = Ri[x]R2 W2[x, y] W~[z]RaWa[y, z] h5 = ha ° h4 h6 = R2[z]R~ W2[x, z]R3[x] Wa[z] W~[x, y]R4[y] W4[x] h7 = Ra[x]R] W~[x]R2[y] W2Wa[y] h8 = R2[z]Ri[z] W2[x, z]R3[x] Wl[X, y] W3[z]R4[y] W4[x]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>h, = R~Ra Wa[x]R2[x] W][x] W~[x]</head><formula xml:id="formula_14">hlo = h7 o h4 hi1 = h7°h, h]2 = R][x]R2[x] Wl[x] W2[x]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Restrictions on the Read and Write Sets</head><p>It turns out that if we impose certain restrictions on the structure of the map S of a history--i.e., the read and write sets of the transactions in the history--the topography of H (shown in Figure <ref type="figure">8</ref> for the general case) is simplified considerably. The most striking such result is that of <ref type="bibr" target="#b16">[19]</ref>. A basic assumption in the model of <ref type="bibr" target="#b16">[19]</ref>--which is otherwise more general than the present in that it allows more than two steps--is that no database entity (or variable) is updated unless it has been previously read. In our model and notation this means that S(W~) C S(Rj). What is surprising is that serializability, an NP-complete predicate in our model, is efficiently decidable in theirs. We explain this in view of our previous discussion as follows:</p><p>THEOREM 8. Suppose that for a history h = (n, ~r, V, S ) we have S(W~) .C S(Rj) for j = 1 ....</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. n. Then h is serializable if and only ifh is in DSR.</head><p>PROOF. It suffices to show that if S(al) N S(a2) # ~ and ~r(o]) &lt; ~r(02) for o], 02 E ~n such that at least one of 01, a2 is a write symbol, then ~r'(a]) &lt; ~r'(a2) in any history (n, ~r', V, S) equivalent to h. Suppose that a] = Wi, o2 = W2. S(W~) and S(W2) share a variable x, which by hypothesis is also in S(R]) and S(R2). Consequently, in h, T2 reads x from either Ti or from another transaction which, by the same argument, reads x from another,</p><formula xml:id="formula_15">H SR =-DSR Q~SSR 2PL P3F-1 FIG 9</formula><p>and so on, up to T1. Now notice that the S(R~) D S(Wj) assumpUon Implies that in any serlahzable htstory there can be no dead transactions. Hence, by Proposition 1, in any history (n, ~r', V, S) equivalent to h we must also have ~r'(W1) &lt; ~r'(W2). The other two cases are settled very similarly. [] It turns out that the rest of the classes of histories discussed previously have a considerably simpler structure under the assumption that S(W~) C S(R~). We show in Figure <ref type="figure">9</ref> without proofs the corresponding dmgram.</p><p>Under a different restriction on S, the class SSR coincides with SR: THEOREM 9. Suppose that in a history h = (n, ~r, V, S) there is a subset X = {xl, x2 ..... xn} C V such that for j --1, 2 ....</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. n we have (a) X _C S(R~), (b) xj E S( W,) if and only if i = j. Then h is senalizable if and only f h ~ SSR.</head><p>SKETCH OF PROOF. Imagine that the variable xj is a Boolean signaling whether transaction T1 has completed. Therefore, if T~ completed in h before T, started, the same must hold in any other htstory equivalent to h. []</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Schedulers of Histories</head><p>The practical importance of the classes of histories 2PL and P3 discussed in Section 4 stems from the fact that they are known to correspond to simple schedulers. A scheduler for a class of histories (to be defined formally below) is generally an algorithm that takes as an input an arbttrary history--possibly nonserializable--and returns a history which is the "closest" to the gwen one among those belonging to the class. If the class is a subset of SR, therefore, the scheduler guarantees that its output Mstory is seriahzable. Such a scheduler can be used in the seriahzability component of the database management system. Of course, in practice one would expect that a scheduler operates on-hne and is reasonably efficient.</p><p>The history-input of the scheduler is the sequence of arriving user requests. The output of the scheduler is the actual execution sequence. The basic fact that makes our approach very different from previous work on concurrency control which was motivated by operating systems (e.g., the notion of determinacy of <ref type="bibr" target="#b3">[6]</ref>) is that the supplier of this input history is a populaUon of users, each user being unaware of the actions of the others. This implies that the order of arrival of these requests has no semantic content whatsoever, and therefore the scheduler is not bound to produce an output which is equivalent (or related in any prescribed way) to the input. In fact, the operation of the scheduler becomes interesting and important exactly when the scheduler must necessarily transform the input to an ineqmvalent output, because the input is nonsenalizable, say.</p><p>There are, however, certain performance criteria that the input-output mapping of a scheduler should satisfy. For example, a trivial scheduler which guarantees serializabihty is the one that outputs only serial histories. This is, however, too restrictive a mechanism to be of practical value. Intuitively, the richer the output class, the more powerful the scheduler, because a less restnctwe class of histories will require less reshuffling of the operations and will cause fewer and shorter unnecessary delays. Ideally, we would like to have a serializer whose output spans all of SR. Unfortunately, we shall soon see that the existence of such a practically useful device is very improbable.</p><p>Defimtion 8. The metric d(., .) on the set H is defined as follows:</p><p>(a) d((n, or, V, S), (n, p, V, S)) = n -max(j. 7r-l(i) --p-t(i), I = 1 ..... j}.</p><p>(b) d((m, ~r, V, S), (n, p, W, T)) = oo if any one ofm # n, V# W, S# Tholds.</p><p>The d~stance between two histories defined on the same set of transactions is therefore n minus the length of their longest common prefix. Notice that d(., .) satisfies the metric axioms. A variety of other metrics would suffice for what follows.</p><p>Definition 8 (continued). Let C be a nonempty subset of H. A scheduler for C is a function A c : H ~ C such that d(h, At(h)) = min{d(h, h'): h' E C}. Thus, A c can be thought of as projecting H onto C under the metric d(., .). Notice that At(h) and h will not be eqmvalent in general. The metric d(., .) requires that Ac leaves histories m C intact, and m fact it leaves intact as long prefixes of arbitrary histories as possible.</p><p>Let us restate now the assumptions of our model of schedulers: (a) A scheduler Ac minimizes the d-distance between its input and its output, This intuitively means that the scheduler operates online, and furthermore that it acts in an opttmtstw way: As long as the history seen so far could possibly be extended to a correct history (here by "correct history" we mean one that the scheduler, in its limited sophistication, recogmzes as correct, or, equivalently, an element of C = Ac(H)), the scheduler does not intervene to rearrange read and write requests. As a corollary, if the scheduler is fed wRh Rs own output, it leaves it intact; it is therefore ldempotent, or a projection. This is a quite reasonable assumpuon to make. Although we cannot totally exclude the posslbihty of schedulers that operate otherwise (for example, anticipating future requests that will make the history nonseriahzable), all schedulers proposed in the past satisfy this assumpuon. Any scheduler implemented by natural constructs such as locks <ref type="bibr">[7, I l]</ref> or queues has this property.</p><p>(b) Among all histories in C that have the longest possible common prefix with the input history, Ac selects any one as its output. Clearly, in practice this choice would be made so as to mimm~ze some more refined metric d'. However, the results obtained below for our weaker metric d would apply to more relaxed metrics, too.</p><p>We say that Acts an efficwnt scheduler lfAc is computable in polynomial time. Our goal m this section Is to understand which classes of histories have efficient schedulers. It is tempting to conjecture that if a class is in ~, then it has an effioent scheduler. To show that this conjecture is not plausible, consider the following:</p><p>Example. Let E = { h o hs : hs is serial, and h -= hs}. Obviously, E can be recogmzed in polynomial time; the algorithm involves splitting a given history m two halves, testing whether the second half is serial, and whether the second half is equivalent to the first. However, it as also easy to see that E cannot have any efficient scheduler, unless ~ffi Suppose that E has an efficient scheduler AE. Then we could test whether an arbitrary history h is senalizable by first computing A E(h o h), and then checking whether AE(h o h) starts with h. Smce AE is supposed to leave unchanged as long prefixes of its input as possible, at will alter the first half of h o h only ff h is not serializable. Since serializabihty is known to be NP-complete, E cannot have an efficient scheduler unless ~--Our next result essentmlly says that effioently recognizable classes have efficient schedulers, unless they are as pathological as our example E above. Let h --(n, ~r, V, S) be a history, considered now as a string of symbols representing n, V, S and the permutation ~r. A prefix of h is an imtial segment of this representatzon, containing the encoding of n, V, S, as well as an mmal part of at--i.e., (¢r-~(l), ~r-l(2) ..... ~r-l(j)) for some 0 _&lt;j &lt;_ 2n. If C is a class of histories, then PR(C) is the set of all prefixes of all htstories in C. THEOREM 10. Let C be a subset of H. C has an efficient scheduler ~f and only if PR(C)  <ref type="figure">end,</ref><ref type="figure">end,</ref><ref type="figure">return (n,</ref><ref type="figure">p,</ref><ref type="figure">V,</ref><ref type="figure">S)</ref>; end <ref type="bibr">FiG 10</ref> PROOF. Suppose that C has an efficient scheduler Ac. In order to determine whether a string g is a prefix of a history h ~ C we may act as follows: We first verify that g contains encodmgs of n, V, and S, together with an initial segment p of a permutation ~r of Xn. We then generate a completion ~ of p by juxtaposing to p the symbols tV~ such that R~ but not I4~ ts present in p, and then the strings Rfl.Vj for allj's such that neither Rj nor W~ appears in p. We then calculate h' = Ac((n, ~, V, S)). It is straightforward to see that g is a prefix of h' if and only if g ~ PR(C). Thus we can efficiently determine whether g PR(C). "PROOF. We have shown that these sets are in #; it is usually straightforward to show that their sets of prefixes are also in ~ (this ns not a general property of ~; there are languages in # that have nonrecursive sets of prefixes). As an illustration, we will sketch a proof that PR(P3) ~ #. First, given an encoding of n, V, S, and a segment p of It, we compute from S the digraph F of the guardian relation among { T1 ..... Tn}. We next make sure that whenever Tj is a guardian of T, and p(I4~) is defined, then either p(W3 &lt; p(B'~), or p(R,) &gt; p(Wj), or p(R,) is undefined. Finally, we make sure that p can be completed in a manner not violating P3. It turns out that this amounts to verifying that the restriction of F to the transactions that are active (i.e., p(Rj) is defined but p(Wj) is not) is acyclic (a discussion of this part follows the proof). Hence we have an efficient algorithm for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PR(P3). []</head><p>We show in Figure <ref type="figure" target="#fig_0">11</ref>, wtthout proofs, stylized versions of efficient schedulers for the classes P3 (1 l(a)), 2PL (1 l(b)), and DSR and Q (1 l(c); for Q we also include the two statements labeled Q). Besides serializabihty, these algorithms must also guarantee the absence of deadlocks. The issue of deadlocks appears to be orthogonal to that of serializ-ability, and, in fact, clever serializability methods are known to introduce increased danger of deadlocks of the "circular waiting" variety <ref type="bibr">[6, pp. 40-60]</ref>. A unified treatment of serializability and deadlocks in a restricted data model is attempted in <ref type="bibr" target="#b15">[18]</ref>. In all cases of interest to us, deadlocks can be prevented by testing a dynamically changing deadlock graph for acyclicity. For example, in two-phase lockmg deadlock can occur if a number of transactions have each locked their read set, and are waiting for each other to release their locks. Hence, in this case the deadlock graph has variables as nodes and has an arc from x to y if and only if some transaction currently on phase l reads x and writes y. In P3 the deadlock graph is the restriction of the guardian relation to the currently active transactions-this was mentioned in the proof of Corollary 2 to Theorem 10. Finally, the deadlock graph in DSR (respectively, Q) has as nodes the active transactions and includes the arc (T,, Tj) if and only if there is a path from T~ to T~ in D(h)--respectively D'(h)--and S(W~) n s(w ) e.</p><p>Our notation in Figure <ref type="figure" target="#fig_0">11</ref> assumes that the process Rj or W~ is initiated as soon as corresponding read or write requests arrive. We use constructs such as when (denoting the waiting for a condttion) and ibegin...iend (bracketing statements that are to be executed indivisibly). It should be obvious that these algorithms can be implemented deterministically and efficiently on any-standard model of computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Discussion</head><p>We shall consider extensions of our results in three directions: general multistep transactions, interpreted transactions, and distributed databases.</p><p>7.1 MULTISTEP TRANSACTIONS. We shall briefly discuss how our entire development of Sections 2 through 6 can be easily extended to a far more gerteral multistep model of transactions. We consider transactions that consist of sequences of steps; each step may involve both reading and writing. The values written must be considered as uninterpreted functions of all variables read at the present or previous steps of the same transaction. Our definition of !iveness now applies to individual steps of transactions. No further modifications are necessary for stating the analog of Proposition 1.</p><p>Serializability is obviously NP-complete in this model, as it subsumes ours. Assuming that no transaction reads intermediate results'of another or reads two different versions of the same variable at two different steps--in which case the history is not serializable--Lemma 2 is also valid. The four serializability principles discussed in Section 4 remain virtually unchanged--in fact, two-phase locking was initially proposed for a similar model in <ref type="bibr" target="#b4">[7]</ref>. For another example, we shall describe in a somewhat more detailed manner the generalized P3 class of histories. In the multistep model a step s of a transaction can be an (i, j )-guardian of another transaction, where i &lt;j are steps. This means that s mteracts with /--i.e., either its write set includes variables of i or vice-versa--and there is a chain of interactions from s toj. If this is the case, s is not allowed to occur between i andj. This P3 protocol always yields DSR (and hence serializable) histories. For the classes DSR and Q, we have similar graphs D(h) and D'(h). An arc (T,, T~) is in D(h) if a step of T, interacts with a subsequent step of Tj. For D'(h) it may just be that the last step of T, precedes the first step of T~. The acyclicity of D(h) again guarantees serializability and that of D'(h) strict serializability. Hence, these remain two most general serializability techniques, subsuming two-phase locking and P3, in this general setting, too.</p><p>Finally, it is easy to see that the results of Section 6--the necessary and sufficient condition for the existence of efficient schedulers and its corollaries--apply even more directly to multistep histories. We hope that the reader is by now convinced that introducing general multistep transactions would have resulted in an unmanageably cumbersome notation but in very few new important ideas.</p><p>7.2 INTERPRETED TRANSACTIONS. A significant departure from our model would be to look more closely into the computations performed by the transactions and exploit their details for studying serializability--or correctness, in general. If only syntactic information about the transactions is available (e.g., the read and write sets) then serializability can be formally proved to be the right concurrency concept [111. if, however, semantics of the functions performed, or even the integrity constraints, are known, then it may be the case that more liberal concurrency principles than serializability are applicable. An example is the correctness theory proposed in <ref type="bibr" target="#b9">[12]</ref>, where the concurrency control mechanism takes into account information about the semantics and integrity constraints supplied by correctness proofs of the individual transactions. The extent to which such information is helpful is investigated in <ref type="bibr" target="#b8">[11]</ref>.</p><p>It is doubtful whether complete semantic information can be used effectively for concurrency control. Any reasonably complex domain of interpretation (e.g., arithmetic ) would soon make the serializability problem undecidable. There should be, however, ways to use parual semantic reformation in order to improve our understanding of serializability. One possibdlty is to use the fact that two transactions perform precisely the same function; one of the implications ~s that they commute. It is not too hard to see that this adds nothing to the model developed thus far. Incidentally, this allows us to extend our original model so as to permit multiple occurrences of a transaction in a history.</p><p>Another poss~bday would be to selectively consider certain very simple transactions to be interpreted. A good example of a very common transaction that performs a wellunderstood function is the copter, a transaction that reads x and later records its value at y. Serlalizability becomes trickier. For example the history</p><formula xml:id="formula_16">h = Rl[x]R2Ra[x] W2[x] Wa[y]R4[y] W4[x]Rs[x] Ws[z] Wl[Z]</formula><p>is not sermhzable in our ordinary sense, but becomes equivalent to the serial history hs --T~TiT2T3T4 once we assume that transactions 3 and 4 are copiers. Proposition 1 becomes somewhat more complex in the presence of copiers. However, it is interesting to note that if copiers are restricted not to read variables from other copiers, then the introduction of copiers adds no strength to our model, and Proposition 1 and Lemma 2 remain unchanged under this assumption. This remark plays an important role in the next topic of our discussion.</p><p>7.3 DISTRmUTED DATABASES. There is a large body of literature aiming at the understanding of the quite elusive notion of distributed computing (see, e.g., <ref type="bibr" target="#b10">[13]</ref>). Distributed databases have inherited some of the intricactes of this area <ref type="bibr" target="#b14">[17,</ref><ref type="bibr" target="#b18">21]</ref>. We shall limit our &amp;scussion to the case of two complete copies of the database in different locations, although there are difficulties which first appear in the cases of three copies oi" of selective redundancy <ref type="bibr" target="#b2">[5]</ref>. A major problem is, what happens when a transaction is run in one location, thus changing only one of the two copies. A simple technique for solving this would be to send an update message <ref type="bibr" target="#b1">[2]</ref> to the other location as soon as the transaction has completed. We have therefore a sequence of genuine transactions and update messages running in the system, and we can thus view the two copies of the database as a single database--think of the two copies of the variable x as two variables x~ and x2.</p><p>A difficulty appears when we try to define a history. The distributed nature of our computation, the communication delays and imperfect clocks, make temporal priority-on which our ordinary notion of history was based--less tangible. The observation here is that mistakes in our arrangement of the events that are due to the above factors preserve history equivalence. Hence, we can pu t together a history--the global log of <ref type="bibr" target="#b1">[2]</ref>--as long as it is consistent with local priorities and arrivals of messages. Now the update messages are in fact just copiers, and they only read variables that were updated by ordinary transactions. Hence the last remark of the previous subsection is applicable, and the seriahzability problem has been reduced to the one already studied! Of course, we are not just looking for serializability but for the existence of an equivalent serial history in which an update message immediately follows the corresponding transaction. This,however, does not change the essence of the task All our special case results hold with very minor modifications.</p><p>What is considerably more complex in the distributed context is the subject of schedulers. There is no obvious neat way to compile syntactic restrictions on the global history into distributed algorithms that achieve them. It therefore appears that distributed history schedulers must concern themselves with the details of the underlying model of distributed computation in order to implement the intended serializability principle; the formidable algorithms of <ref type="bibr" target="#b18">[21]</ref> and <ref type="bibr" target="#b2">[5]</ref> illustrate this point. Nevertheless, it is stall natural to conjecture that the more general ideas related to the classes DSR and Q would prove advantageous m the d~strlbuted environment as well.</p><p>7.4 OPEN PROBLEMS. We have proposed a formalism for the concurrency control problem for databases. There are two aspects of this formalism that may limit its applicability and must the/'efore be modified in a second attempt. One is our basic assumption, manifested throughout the paper, that the syntactic description of all transactions to occur in the history is known to the scheduler a priori. It is not clear how to remove this assumption and still retain the wealth of available solutions. One way would be to have, following <ref type="bibr" target="#b2">[5]</ref>, a certain number of prototype transactions--or classes--to one of which any arriving transaction can be matched. Another way out would be to adopt only transaction-driven concurrency controls. Two-phase locking <ref type="bibr" target="#b4">[7]</ref> is an example of such a concurrency control, and so would be any other locking scheme. The limitations of such approaches are studied in <ref type="bibr" target="#b8">[11]</ref>. On the other hand, it is possible that variants of the schedulers presented here could also be implemented in a transaction-driven manner.</p><p>Second, our way of evaluating the performance of schedulers is also in need of an improvement. We propose only a qualitative measure of the performance of a scheduler-namely, the set of all output histories. This leads to only a partial order of schedulers. This was shown to be a reasonable and useful approximation of reality when the goal is to derive indicative results or compare general principles of serializability. It is clear, however, that a more concrete measure of performance is needed for more practical applications. One promising direction would be to somehow count the total number of delays imposed on requests--at a first approximation, the number of transaction steps that cannot execute immediately upon arrival. This would be a refinement of our measure: our measure, roughly speaking, assigns a perfect score to all histories that remain the same and zero score to all histories that are changed, however small the change. A more refined measure might even put to test some of our assumptions, like the "optimistic scheduler" assumption (Section 6): in certain cases It may be preferable to intervene and modify slightly the history when seriahzable completion becomes extremely unlikely, although not impossible. Naturally, adopting a more concrete measure of performance for schedulers will most likely require the introduction of specific and pragmatic details of the particular application, and the overall approach may have to be probabilistic.</p><p>By considering only serializability as our notion of correctness we have somehow limited our scope. Examples of concurrency control techniques more general than serializability can be found in <ref type="bibr" target="#b9">[12]</ref> and <ref type="bibr" target="#b7">[10]</ref>. They are arrived at by assuming that the scheduler has more than syntactic reformation about the transaction system that it handles--e.g., semantic reformation or understanding of the integrity constraints. It is pointed out m <ref type="bibr" target="#b8">[11]</ref> that seriahzability is just one point in the trade-off between information and performance of schedulers. However, we feel that there is something natural about the use of syntactic information for concurrency control, and the importance of concurrency techniques stronger than serializability is of limited practical value.</p><p>Finally, we recall two other problems that are left open here: the complexity of recognizing the class SSR, and developing techniques for designing distributed schedulers from syntactic specifications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIG. 1</head><label>1</label><figDesc>FIG. 1 The history h = Ri[x]R2 W~[x, y]R3[x] W2[x, y] W3[y] viewed as a program schemaS(W,) for i _&lt; n, and also S(R,+i) --S(Wn+2) --~, S(Wn+I) --S(l~n+2) --V. In other words, /~ is h preceded by a transaction that initializes all variables without sensing any, and followed by a transacuon that reads the final values of all the variables, without changing them. Suppose that x ~ S(R,). We say that R, reads x from Wj in h if W~ is the latest occurrence of a write symbol before R, in ~ such that x E S(W~). Notice that since /~ contains Wn+l with S(W,+0 = V, such a write symbol always exists. The definition of a live transaction in h is as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(a) T,+2 is live in h. (b) If for some hve transaction Tj, Rj reads a variable from W~ in h, then ~ is also live inh. (c) The only kinds of live transactions in h are defined by (a) and (b) above.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Equivalence of histories can be decided in O(n. [ VI) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 2 .</head><label>2</label><figDesc>A polygraph (N, A, B) is acyclic If there is an acydic digraph in ~(N, A, B).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>FIG 2    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>start from the construcuon ofPF = (N, A, B). Fhas m clauses Cx ..... Cm and revolves n Boolean variables x~ ..... xn. Each clause C, consists of three literals h,1 V 2,,2 V ~,a, where A:k is either a variable or a negation of one. N contains the nodes a:, b:, cj for each variable x:, and y,k, z,k, k = 1 ..... m, for each clause C with m, literals. For each variable x: we add the arc (a:, b:) to A and the blpath ((b:, Cg), (c:, a:)) to B. For each clause C,, we add the arcs (y,~, z,.k+l) (addmon mod m,) to A. FmaUy, if ~,k = x:, we add the arcs (c:, y,k) and (b:, z,k) to A and the blpath ((z,~, y,k), (y,h, b:)) to B. If h,k = 2:, then we add the arcs (z,k, c:) and (y,k, a:) to A, and the btpath ((a:, z,k), (z,~, y,k)) to B. For example, ff the literal X,k is &amp;, the subpolygraph of Figure 3 wdl appear in PF.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>acychc digraph (N, A ') ~ ~(PF). A' contains all of A and the arcs (q, aj) if T(x:) = true, (/b, c:) if T(x:) =false, and the arcs (z,,, y,~) ff T(X,~) =false, (y,~, ib) ifh,~ = &amp; and T(x:) = true, and (a:, Z,k) If ~,:~ = X: and T(x:) = false. Obviously, (N, A ') is m g~(Pe); the claim is that it ~s acychc. We first note that since F ~s by hypothesis noncircular, (N, A) is acyclic. This ~s because by the constructmn of A, the clauses containing variables only or negations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fro. 4</head><label>4</label><figDesc>only correspond to node sets with only incoming or, respectively, only outgoing arcs; node sets corresponding to mixed clauses have both incoming and outgoing arcs, but no two such node sets are reachable from each other in (N, A) by F's noncirculanty; it follows that (N, A) is indeed acyclic. It is easy to check that the arcs in A' -A can harm the dlgraph's acyclicity only by introducing a (zn, y,1 ..... y,a) cycle; however, this would mean that some clause has no true (under T) literal, and hence T does not satisfy F, a contradiction. In Figure 4 we show in broken lines the arcs of an acyclic digraph in ~(PF); this digraph corresponds to the truth assignment T(x]) --true, T(x2) = false, T(xa) = false, which sausfies F.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Xth = x~ for some purely unnegated clause Ct, and if x~ also appears in a purely negated clause Cp (Apq = Xj), then Zpq comes after Z,m. Finally, we have h(C,) = zn ... Z,m, for each purely negated clause C,, and at the end the transaction n,. To argue that PF = p(h), first note that all (Yv, z,,j+~) (mad m,) arcs are realized by h, and that the subpolygraph of Figure 3 is realized for each xj = ?~,k and the s y m m e m c subpolygraph for ggj = A,R. Furthermore, it is quite easy to check that no other arcs and bipaths are added by the construction. Hence PF = P(h), which completes the proof of Theorem 1. []</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(a) S(R,) N S(Wj) ~ f~ and ~R , ) &lt; Ir(I4"~), or (b) S(W,) f3 S(Rj) ~ f~ and ~r(W,) &lt; 7r(R:), or (c) S(W,) f3 S(I4"~) # ~ and It(W,) &lt; ~ I4,~).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>(b) D(h) has no cycles of length 2. By Lemma 4, there is a serial history hs such that D(h) = D(hs). However, serial histories hs have acyclic D(hs), and hence D(h) is acychc. [] Theorem 2 suggests that histories that are DSR can be detected efficiently by checking D(h) for acyclicity: COROLLARY I. Checking whether a history h = (n, ~r, V, S) is DSR can be done in O([ V[n 2) time. Also, we can rephrase Theorem 2 as follows (compare with Definition 4 below): COROLLARY 2. A history h ffi (n, ~, V, S) is DSR if and only if we can find real numbers {$1 ..... S~} such that (a) If S(W,) N S(Rj) ~ ~ and ~ W,) &lt; w(Rj), then S, &lt; Sj; (b) If S(R~) N s(Ir~) ~ ~ and ~'r(R,) &lt; ~(W~), then S, &lt; S~; (c) If S(W,) N S(W~) ~ 0 and ~ W,) &lt; ~ Wj), then S~ &lt; Sj. 4.2 THE CLASS Q. Definition 4. A history h = (n, 7r, V, S) is in Q if there exist noninteger, distinct real numbers S~, $2 ..... S~ with the following properties:(a) ~(R,) &lt; S, &lt; ~W,). (b) If S(R,) ~ S(W~) # ~, i ~ j, and ~R~) &lt; ~ W~), then S, &lt; Ss. (c) If S( WJ ~ S(W~) # ~ and ~ W,) &lt; ~ W~), then S, &lt; S~. The real numbers $1 ..... S, in Definition 4 are called serializabilitypomts. Their intuitive meaning is that the history h is the same as though transaction T~ had executed indivisibly at the time instance $1 (during which, by (a) above, it was active), transaction T~ at S~, and so on. As an illustration, the history h = R~[x]~[z] W~[y]R~[z] W~[x] Wily] is in the class Q, since the values Sa ffi 3.5, $2 = 2.5, and $3 ffi 4.5 satisfy, as the reader can check, the requirements of the definition. The class Q was independently introduced in [22]. THEOREM 3. I f h Is m Q, then h is DSR PROOF. Condmons (b) and (c) of the definmon of the class Q above are identical to (b) and (c) of Corollary 2 to Theorem 2. Hence it suffices to show that condmon (a) above implies condition (a) of Corollary 2. But this is immediate, because if ~r(W,) &lt; ~r(Rj) we have that S, &lt; ~r(l'V,) &lt; ~r(Rj) &lt; Sj, no matter what S(Rj) and S(W,) are. [] Given a history h = (n, ~r, V, S) we can construct another digraph D ' ( h ) --a superdlgraph of D(h)--with node set again {T1 . . . . . Tn} and (T,, Tj) an arc if and only if one of the foUowmg holds: (a) ~r(W,) &lt; ~r(R~). (b) or(R,) &lt; ~r(Wj) and S(R,) 0 S(V~) ~ f~. (c) ~r(W,) &lt; ~r(I'Ve) and S(W,) N S(Wj) ~ ~3. In other words, D'(h) contains all the arcs of D(h) and possibly some other arcs for the cases m which ~r(W,) &lt; ~r(R~) and S(Rj) tq S(W,) = f~. THEOREM 4. The history h = (n, ~r, V, S) is in the class Q if and only if D'(h) is acyclic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>(b) ~r(W,) &lt; ~r(14"~) and S(W,) N S(I,I,~) ~ ~3. By (c) of Definition 4, however, S, &lt; Sj, again a contradiction. (c) ~r(R,) &lt; ~r(l'l'~) and S(R,) f3 S(14~) ~ ~. Similarly, a contradiction is reached by (b) of Defimtlon 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>(a) S~+~ = 2n + 1. (b) S~ = min{Sj+a, ~I4.~)} -l/(n + 1), j = n, n -1 ..... 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>note that two-phase locking for a history h = (n, ~r, V, S) essentially amounts to divtding the interval from ~R:) to ~ Wj) into two intervals: one during which no symbol with S(Rj) N S(W,) # (3 can exist, followed by one during which no symbol e ~ Xn with S(e) N S(Wj) # 0 can exist. This is captured by the following definition: Definition 5. A history h = (n, ~r, V, S) ts two-phase locked (notation: h ~ 2PL) if and only if there exist dlstmct nonmteger real numbers l~ ..... In (the loekpoints) such that: (a) ~r(R~) &lt; l~ &lt; 0r(W~) for i = 1 ..... n. (b) If S(R,) N S(W~) # ~5, t #j, and ~(R,) &lt; ~r(Wj), then I, &lt; Ij. (c) If S( W3 N S(Wj) ~ ~5 and ~ W,) &lt; ~ Wj), then ~ W,) &lt;/~.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>* ~ Q. PROOf. Let {l~ ..... l,) be a set of distinct, noninteger, real numbers, and let a(j) be the number of positions to the right that the symbol ~r-~(j) was shifted in h*; in other words, a(j) = 2-[ {IV, : ~r(W,) &lt;j} I. Consider the set {S~ ..... S2n}, where S, = l~ + a([l,]) for i _&lt; Serializability of Concurrent Database Updates ~r(W,-n) + a(~r(W,-n)) + ~ for i &gt; n. We claim that (l,} ts an acceptable set of lockpomts satisfying Definition 5 if and only if (Sj} is a set of serializability points according to Definition 4. Both &amp;rections follow from the defimtions. The formal derivation is omitted. []</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Definition 6 .</head><label>6</label><figDesc>Let CG(h) be the undirected graph corresponding to D(h) (Figure 6(b)). A cycle in G(h) is a sequence (T,,, T,~) of m _&gt; 2 transactions such that [T,,, T,,+,] are edges of G(h),j = 1 ..... m -1, and so is [T, m, T,,]. Notice that all edges are cycles according to this definition. A cycle (T~ ...... T,m) is bad If IS(Rim) ~J S(Wtm) ] N S(W,l) ~ ~, and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>(a) S(Wj) N S(Wj+i) # ~ and ~W~) &lt; ~r(Wj+0. (b) S(W~) N S(R~+a) # ~ and ~Wj) &lt; ~R~+,). (c) S(Rj) N S(Wj+,) # 0 and ~R~) &lt; ~Wj+i).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>hnstory h = (n, ~, V, S) Output. a history h' = (n, O, V, S) E C such that d(h, h') ts the smallest posstble, if such an h' exists begin if(n, ( ), V, S) ~E PR(C) then return comment ( ) ts the empty permutatton, else begin p'=(), forj = l .... 2n do begin done .= false, fort=j,j+ 1, ,2ndountildone if (n, (p, ~r-lO)), V, S) E PR(C) then begin done = true, interchange *-l(l) and ~-i(j ), p .= (p, ~-~(I)), end,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>For the other direction, suppose that PR(C) ~ ~. Based on the recognition algorithm for PR(C) we design an efficient scheduler Ac, shown in Figure 10. Ac computes Ac(h) --(n, p, V, S) by determining p element by element. It should be obvious that A c operates as prescribed within a time bound of O(n2C(n, [VD), where C(n, iV[) is the complexity of recognizing PR(C). The theorem follows. [] It is now easy to link the discussion of Sections 3 and 4 with the existence of efficient schedulers We get two types of results: COROLLARY I. Unless ~ = ~ SR has no efficzent scheduler. COROLLARY 2. The classes S, 2PL, P3, Q, DSR have efficient schedulers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>PROOF. Ifh is serializable, there exists a serial history h, such that h -= h~ or, by Lemma We resist on this terminology only because it has already become notorious for tts impropriety.</figDesc><table><row><cell>Two histories hi --(n, ~r, V, S) and h2 = (n, or', V, S) are equivalent if and only</cell></row><row><cell>if P(hl) and P(h2) are identical.</cell></row><row><cell>PROOF. Both directions follow from Proposition l and the definition of P(h). []</cell></row><row><cell>LEMMA 2. A history h = (n, ~r, V, S) without dead transactions is serializable if and only</cell></row><row><cell>if P(h) is acyclic.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Think of this order as a serial history hs. It is immediate that D(hs) = D(h), and hence, by Lemma 4, h ~ hs. It follows that h is DSR.</figDesc><table><row><cell>b) ol --R~, o~ --Wj, and S(R,) N S(W~) ~ f~. This would mean, however, that (T~, T~)</cell></row><row><cell>is in D(h2) and (T~, TJ is in D(hl). Since D(hO and D(h2) have no cycles of length 2,</cell></row><row><cell>we can conclude that D(hl) ~ D(h2).</cell></row><row><cell>(c) A similar argument holds for ol = W~, 02 = Wj, and S(W~) N S(I4'~) # ~. []</cell></row><row><cell>We can now prove the following theorem.</cell></row><row><cell>THEOREM 2. A history h = (n, ~r, V, S) is DSR if and only if D(h) is acyclic.</cell></row></table><note><p>PROOF. Suppose that D(h) is acychc. We can thus sort topologically the set {T1 .... Tn} of nodes of D(h).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Serializabdity of Concurrent Database Updates</figDesc><table><row><cell>H</cell><cell></cell><cell>ol2</cell></row><row><cell>SR</cell><cell></cell><cell></cell></row><row><cell>DSR</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>o 8</cell></row><row><cell>I0 i 0</cell><cell>O</cell><cell>2PL</cell></row><row><cell></cell><cell>e5</cell><cell>°4</cell></row><row><cell>6 7 •</cell><cell>o 3</cell><cell></cell></row><row><cell>FIG 7</cell><cell></cell><cell>FIG 8</cell></row></table><note><p>e, II 645 satisfying Definmon 7. However, h is not in Q; to check thts, just notice that the digraph D'(h) shown in Figure</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>BERNSTEIN, P A, PAPADIMITRIOU, C H., AND ROTHNIE, J B Resolving certain concurrent update problems without locking an abstract Proc IEEE Workshop on OS and DBMS, Chicago, lU, 1977</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>BERNSTE1N, P A, AND SHIPMAN, D W A formal model of concurrency control mechamsms for database systems Proc 1978 Berkeley Workshop on Distributed Databases and Comptr Networks, Berkeley, Callf, Sept 1978, pp 189-205,</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ACKNOWLEDGMENTS. Many lllummating discussions with Phil Bernstein have influenced this work Also, we acknowledge helpful discussions with H. T. Kung, Dan Rosenkrantz, Jim Rothnie, and Jeff Ullman, and careful reading of the manuscript by Marco Casanova and an anonymous referee.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research was supported by the National Science Foundation under Grants MCS-77-01193 and MCS-77-05314 A prehmlnary version of Sections 2 and 3 was presented at the Conference for Theoretical Computer Science,</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>process lj when the deadlock graph with Ta is acychc do output <ref type="bibr">(Rj)</ref> process Wj when Tj is not the guardian of an active transaction do output (W~) (a) </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Design and Analysts of ComputerAlgoruhms Addison</title>
		<author>
			<persName><forename type="first">!</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<pubPlace>Wesley, Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Analysts of senahzablhty of SDD-I&apos; a system of distributed databases ~the fully redundant case</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rothnie</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EEE Trans. on Software Eng SE-4</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="154" to="168" />
			<date type="published" when="1978-05">May 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">N The concurrency control mechanism of SDD-I a system for distributed databases (the general case</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Shipman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rothnie</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Goodman</surname></persName>
		</author>
		<idno>TR CCA-77-09</idno>
		<imprint>
			<date type="published" when="1977">1977</date>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Corporation of America</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Cofeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P Operating</forename><surname>Denning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Theory</forename><surname>Systems</surname></persName>
		</author>
		<author>
			<persName><surname>Prentice-Hall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<pubPlace>Englewood Cliffs, N J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">1 L The notions of consistency and predicate locks in a database system</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Eswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gray</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Lorie</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Traiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="624" to="633" />
			<date type="published" when="1976-11">Nov 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Computers and lntractabthty A Guide to the Theory of NP-Completeness Freeman</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Reducibihtles among combinatorial problems In Complexay of Computer Computa</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<editor>ons, R E Miller and J W Thatcher</editor>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Plenum Press</publisher>
			<biblScope unit="page" from="85" to="103" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A concurrent database problem binary search trees, an abstract</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lehman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page">498</biblScope>
			<pubPlace>West Berlin, Germany</pubPlace>
		</imprint>
	</monogr>
	<note>Proc 4th Int Conf on Very Large Databases. Full paper to appear in ACM Trans Data Base Syst</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An optimality theory of concurrency control for databases</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 1979 SIGMOD Conf</title>
		<meeting>1979 SIGMOD Conf<address><addrLine>Boston, Mass</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1979-05">May, 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Towards a theory of correctness for multi-user data base systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<idno>TR CA-7610-0712</idno>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Massachusetts Computer Associates</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">clocks and ordering of events in a distributed system TR CA-7603-2911</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><surname>Time</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Massachusetts Computer Associates</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Luckham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Park</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">On formalized computer programs J Comptr. Syst Scl</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="220" to="249" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">C H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rothnie</surname></persName>
		</author>
		<title level="m">Computational problems related to database concurrency control Proc Conf on Theor Comptr Sci, U of Waterloo</title>
		<meeting><address><addrLine>Ontario, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Steiglitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorial Opnmlzanon Algorithms</title>
		<imprint/>
	</monogr>
	<note>In preparation</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">N An overview of the preliminary design ofSSD-I: a system of distributed databases Proc</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rothnie</surname></persName>
		</author>
		<author>
			<persName><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Berkeley Workshop on Distributed Data Management and Comptr. Networks</title>
		<imprint>
			<date type="published" when="1977-05">1977. May 1977</date>
			<pubPlace>Berkeley, Cahf</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
		<author>
			<persName><surname>Kedem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Consistency in hierarchical database systems</title>
		<imprint/>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Stearns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rosenkrantz</surname></persName>
		</author>
		<title level="m">Concurrency control for database systems Proc. 16th Conf Found Comptr Sct</title>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="19" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Depth-first search and linear graph algorithms SLam</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Comptg</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="146" to="160" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A solution to the update problem for multiple copy databases which uses distributed control TR 3340, Bolt, Beranek and Newman</title>
		<author>
			<persName><forename type="first">R</forename><surname>Thomas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Analysis of senahzable logs Unpubhshed manuscript</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1978">1978. 1979. October 1979</date>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Harvard University</orgName>
		</respStmt>
	</monogr>
	<note>RECEIVED AUGUST 1978, REVISED MARCH</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
