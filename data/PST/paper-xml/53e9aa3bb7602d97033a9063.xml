<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bisimulation Congruences in Safe Ambients*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Massimo</forename><surname>Merro</surname></persName>
							<email>massimo@cogs.susx.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">COGS</orgName>
								<orgName type="institution" key="instit2">University of Sussex</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Matthew</forename><surname>Hennessy</surname></persName>
							<email>matthewh@cogs.susx.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">COGS</orgName>
								<orgName type="institution" key="instit2">University of Sussex</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Bisimulation Congruences in Safe Ambients*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4E076A9A7561C2357454702E3C51F82A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>V~ study a variant of Levi and Sangiorgi's Sa% Ambients (SA) enriched with passwords (SAP). In SAP by managing passwords, for example generating new ones and distributing them selectively, an ambient may now program who may migrate into its computation space, and when. Moreover in SAP an ambient may provide dift~rent services depending on the passwords exhibited by its incoming clients.</p><p>~V~ give an lts based operational semantics for SAP and a labelled bisimulation based equivalence which is proved to coincide with barbed congruence.</p><p>Our notion of bisimulation is used to prove a set of algebraic laws which are subsequently exploited to prove more significant examples.</p><p>'4P] represents an agent, or arr~bient, named n, executing the code P. Intuitively n[P] represents a bounded and protected space in which the computation P can take place. In turn P may contain other ambients, may eft~ct communications, or may exercise capabilities, which allow entry to or exit fl'om named ambients. Thus ambient names, such as n, are used to control access to the ambient's computation space and</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The calculus of Mobile Ambients, abbreviated MA, has been introduced in <ref type="bibr" target="#b5">[5]</ref> as a novel process calculus for describing mobile agents. The term Picalculus. Thus, tbr example, an ambient may now only exercise the capability in(~}, if the ambient 'r~ is also willing to exercise the corresponding co-capability ~(@. In 'r,~ can migrate inside 'r~ if P has the form ~(@.P~ I P~, in which case the system evolves to That is the ambient 'm may only enter ' r~ if ' r~ allows it. The resulting calculus, called S@ Arr~bier~ts, abbreviated SA, is shown to have a much more satisfactory equational theory, and numerous equations, often type dependent, may be tbund in <ref type="bibr" target="#b8">[8]</ref>. Nevertheless these equations are expressed relative to a contextually defined equivalence. Establishing them requires, tbr the most part, reasoning about the eftbct arbitrary contexts may have on ambients.</p><p>}¥~ extend the syntax of ambients even further, by allowing capabilities to be defined relative to passwo~'ds. Cocapabilities give a certain amount of control to ambients over the ability of others to exercise capabilities on them; in('r~} can only be exercised if 'r~ is also willing to pertbrm ~&lt;@. However 'r~ has no control over who obtains the capability in(@. But if we generalise capabilities (and co-capabilities) to contain an extra component, a password, then this extra component may be used by 'r~ to exercise control over, and dift~rentiate between, dift~rent ambients who may wish to exercise a capability. Now an ambient wishing to migrate inside 'r~ must exercise a capability of the tbrm in(~, h}, tbr some password h; but the capability will only have an ef-t~ct if 'r~ exercises the corresponding co-capability, with the sarr~e password, ~(~, h}. By managing passwords, tbr example generating new ones and distributing them selectively, ' r~ may now program who may migrate into its computation space, and when. Moreover an ambient may provide dif-t~rent services depending on the passwords exhibited by its clients. ~V~ call this extended language S@ Arr~bier~ts with Passwo~'ds, abbreviated SAP. It is formally defined, with a reduction semantics in Section 2.</p><p>Following the ideas of <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b13">12]</ref> it is straighttbrward to define a contextual equivalence between terms in SAP, or indeed any of the many other variants of ambients. }¥~ let ~ be the largest equivalence relation between terms which i) is a congruence tbr the language, that is is preserved by all constructs of the language, ii) preserves, in some sense, the reduction semantics of the language iii) preserves bar'bs, that is preserves some simple observational property of terms. A tbrmal definition is given in Definition 2.3. This relation has all of the extensional properties we require of semantic equivalence but it is very difficult to reason about; see tbr example the proof of the equational laws in <ref type="bibr" target="#b8">[8]</ref>. However bisimulation relations, because of their co-inductive nature, provide powerful proof techniques for establishing equivalences, <ref type="bibr" target="#b14">[13,</ref><ref type="bibr" target="#b18">17,</ref><ref type="bibr" target="#b15">14]</ref>; these are based on descriptions of processes in terms of a labelled tr~r~sitior~ systerr~, or lts, a collection of relations of the tbrm P ~ &gt; Q. Intuitively this means that the system P may pertbrm the action c~, typically by interacting with its environment or context, and be thereby transformed into the system Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The main result of the paper is</head><p>• an its based operational semantics for SAP • a bisimulation based equivalence over this its, denoted ~, which coincides with ~.</p><p>In principle this opens up the theory of ambients, or at least those definable in SAP, to the co-inductive proof techniques associated with bisimulations. The its contains, as expected, actions for all of the capabilities and co-capabilities in the language 1. These take the form P ~ &gt; P', a typical exampie being These actions do not prescribe any direct behaviour to individual ambients although they indirectly induce behaviour ibr particular ambients. For example, the ambient now has the ability to er~teT" an ambient named 'r~, because its body has the capability to peribrm the action in(r@ So our its will also require actions of the form enter('@, whose eft&gt;cts are in general higher-order. When such an action is peribrmed we must prescribe i) which ambient enters 'r~ and ii) what residual code remains behind. Such actions will have the tbrm</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&gt; ~,'.~(AL@</head><p>Here A is the migrating ambient, 'r~ the target, Q' is the residual code and '5~ the shared names.</p><p>The details, including a ibrmal definition of the higher-order its, are given in Section 3.</p><p>In order to obtain our its based characterisation of ~ we use these higher-order actions to define a version of weak rr~oves between processes. These weak moves are defined in two steps. The first replaces actions whose residuals are concretions with actions whose residuals are simple processes. For example, the enter(~} action above is replaced by the family of moves</p><p>The weak moves ~ are defined in the standard manner as</p><formula xml:id="formula_0">T ~ (x T _--+ ._--+_...._--~ ,</formula><p>The main result of the paper is that, in SAP, the resulting (weak) bisimulation equivalence ~, based on these weak moves, coincides with ~.</p><p>Most of the paper uses a pure tbrm of ambients, without any communication. In Section 5 we show that our results extend to a calculus in which messages can be sent and received within ambients, as in <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b8">8]</ref>. In the following section we give some </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">THE CALCULUS SAP</head><p>The syntax of processes is given in Table <ref type="table">1</ref> and is basically the same as that in <ref type="bibr" target="#b5">[5]</ref>, except that each of the original capabilities has a co-capability, as in <ref type="bibr" target="#b8">[8]</ref>, and that now each capability has an extra argument h, which may be looked upon as a password. The calculus has replicated prefixing, rather than full replication, or recursion; this results in an image-finite labelled transition system. Finally for simplicity we have omitted communication; this will be added in Section 5.</p><p>}¥~ fi'equently write in(n} to denote in(n, n} and similarly for the other capabilities; in other words we will often use the name of an ambient as a password. The operator ~"r~ is a binder for names, leading to the usual notions of free and bound occurrences of names, fn(.) and bn(.), and (xconversion.</p><p>As in the Picalculus the reduction semantics is based on an auxiliary relation called structural congruence which brings the participants of a potential interaction into contiguous positions. The full definitions of structural congruence, ~_, and the reduction relation, -+, can be ibund in the Appendix in Table <ref type="table">5</ref>. Both definitions are similar to those for SA, except ibr the passwords and the following crucial rule for emigration:</p><formula xml:id="formula_1">(Red Out) rn[n[oug(m,h}.PIQ]lR ] I + ,,4P I (2] I -4R] I x</formula><p>The ambient n may attempt to emigrate from ambient rn by exercising the capability owe(m, h}; but the target computation space must allow entry, by exercising the corresponding co-capability with the same password, 7ff~(rn, h}. Note that in <ref type="bibr" target="#b8">[8]</ref> this co-capability is exercised by rn rather than the target computation space; we t&gt;el that with our definition there is a clearer distinction between the role of an ambient in a reduction and the corresponding role of its environment.</p><p>As usual, we write ~ to denote the reflexive and transitive closure of -+.</p><p>~¥~ end this section with the definition of what we believe to be an appropriate behavioural equivalence in SAP: barbed congruence <ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b7">7]</ref>, based on a notion of observation. In ambients the observation predicate P $~ is used to denote the possibility of process P of interacting with the environment via the ambient n. In MA, <ref type="bibr" target="#b5">[5]</ref>, this is true whenever P I Pz) where n ~ {&lt;}. This is because in MA no authorisation is required to cross a boundary, and the presence of an ambient n at top level denotes a potential interaction between the process and the environment via n. However in SA, <ref type="bibr" target="#b8">[8]</ref>, and our language SAP, the process ~"5~(n[P1] I P2) only represents a potential interaction if P1 can exercise an appropriate co-capability. For exampie in <ref type="bibr" target="#b8">[8]</ref> the predicate P$~ is defined to be true whenever and n f~ {'~}. ~¥~ use a slight simplification of this definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 2.1 (BARBS). We write P$,~ if and only if therv exist names h, '5~, and processes P1, laz, and Pa such that P z v"5~(n[~(n, h}.P~ I Pz] I P a&gt;, wharf n, h ~ '5~. We write Pg~ if P ~ P' and P'$~.</head><p>Notice that our notion of barb is simpler than that in <ref type="bibr" target="#b8">[8]</ref>. Notice also that the barb only mentions the ambient n and not the password used to open it; we could of course define a more detailed barb P$~,l~ but as we shall see this is unnecessary (see Theorem 4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 2.2. A rvlation 7¢ is i) reduction closed if P 7¢ Q and P -~ P' implies the eaistence of some</head><formula xml:id="formula_2">Q' such that Q ~ Q' and zP' 7~ Q'; i O barb preserving if P T~ Q and P$.,~ implies Qg~.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>DEFINITION 2.3 (BARBED CONGRUENCE), Barbed congruence, written ~, is the largest congruence relation over processes which is reduction closed and barb preserving.</head><p>Our choice of observation here may i&gt;el arbitrary. But in Section 4.1 we will show that ~ remains invariant under a large choice of possible observation predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">LABELLED TRANSITION SEMANTICS</head><p>The capabilities or prefixes C in our language give rise, in the standard manner, <ref type="bibr" target="#b11">[10]</ref>, to actions of the ibrm C.P ~ c&gt; Q. These actions could be used to define a versions of weak bisimulation equivalence over processes, ~0~e, again in the standard manner, <ref type="bibr" target="#b11">[10]</ref>. However it should be obvious that ~0~e is unsatisfactory as a notion of equivalence %r SAP. For example these actions cannot be performed by ambients and therefore we would have the identity n[P] ~o~d 0 regardless of P. However the actions above can be considered the basis of further capabilities. For example in the system n[ia(m,h}.P] I Q Exercising this capability has a dual efi~ct; on the one hand the ambient 'n[P] will actually move into the ambient rn, on the other the process Q will remain executing at the point at which the capability is exercised. In general each of the simple prefix actions C will induce diKerent, more complicated capabilities in ambients, and more generally processes. These will be formulated as actions of the ibrm P ~ O where the range of c~ and of O, the outcomes, are given in Table <ref type="table" target="#tab_1">2</ref>. These outcomes may be a simple process Q, if for example (x is a prefix from the language, or a concretion, of the %rm ~"~&lt;P}~/~. Here, intuitively, process P represents what must stay inside an ambient n whereas process Q must stay outside n, and '~ is the set of private names shared by F and Q.</p><p>The rules defining our labelled transition semantics, inspired by <ref type="bibr" target="#b8">[8]</ref>, are given in Table <ref type="table">3</ref>. Here we only explain the rules for emigration. A full explanation of the its can be ibund in [91.</p><p>The driving tbrce behind the emigration is the activation of the prefix oat(n, h}. It induces a capability in an ambient rn to emigrate fl'om n with password h, which we %rmalise as a new action exit(n, h}. Thus, ibr k g~ {n, h}, an application of the rule (Exit), followed by (Par Exit) and (Res) gives</p><formula xml:id="formula_3">v'k('rn[out(n,h}.P1] I P~) °~&lt;~'~&gt; &gt; -k(&lt;v2&gt;~;r,4vd)</formula><p>Here, when this capability is exercised, the code /z2 will remain inside the ambient n while the ambient 'rn[P1] will move outside. The structural rule (Res) allows the migrating ambient to share private names with its point of origin, in the same manner as in the Picalculus. This rule employs the convention that if O is the concretion ~"5~(P}~Q, then ~'rO is a shorthand for v"fi~(F}~wrQ, if r ~ fit(P), and the concretion v'(r'~O&lt;P}~Q otherwise. ~V~ have a similar convention for the rule (Par): O I R is defined to be the concretion u'm(/'),~((? I/0, where 'g~ are chosen, using c&gt;conversion if necessary, so that fit(R) A {'g~} = 0. However, in the example above, to actually eft&gt;ct the emigration of rn we need a further context, namely the ambient n from which to emigrate. This leads to another action, called pop(n, h}, with the associated rule (Pop); an applica-tion of which gives: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE CHARACTERISATION</head><p>In the first subsection we re-examine our definition of barbed congruence, ~, showing that it is very robust under changes to the precise definition of barbs. This is followed by our co-inductive characterisation of ~.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Barbs</head><p>According to <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b8">8]</ref>, the predicate P$~ (cf. Definition 2.1) detects the ability of a process P to interact with its environment via the ambient n. However, in other process calculi, like the Picalculus, barbs are defined using (visible) actions. So, one may wonder how our definition of barbed congruence would be afi&gt;cted by inheriting the notion of barb fl'om our its. In fact we can show that our definition of barb coincides with the choice of a particular action: LEMMA 4.1. P$~ iffP e=,,&lt;~,l~&gt; p, &gt; for some h and P'.</p><p>In this subsection, we prove that for all possible labels generated in our its the resulting definitions of barbed congruence collapse and coincide with ~. ~¥~ recall that o: ranges over the labels defined in It is very easy to establish that if P ~x Q then i) P~x&lt;~,l~&gt; iff Q~'x&lt;~,l~&gt;; ii) P ~ P' implies Q ~ Q' Ibr some Q' such that P' ~x Q'. In the sequel we will use these properties without comment. As to the implication Dora right to let~, let P ~t~-Q and RSvp, then we want to conclude that Q.~. By Lemma 4.1, if P$~ then there exists h such that P performs an action free(n, h}. Thus, we define a context:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S~[ "] = ['] I open(n, h}.gi~(g} ].</head><p>If g is fl-esh to /~, then the context SSI ~[.] has the required properties that: i) S~[R]~=~&lt;~&gt; implies R~; ii) R~ implies 3h. S~[R]go=~o=&lt;~&gt;. This suffices to establish Qg~. [] In the proof above, the use of the fresh password k in the definition of &amp;[.] is essential. Note also that the case A = enter shows that the Levi and Sangiorgi's definition of barb, <ref type="bibr" target="#b8">[8]</ref>, can be simplified, to coincide with our original definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Labelled Bisimilarity</head><p>One possible approach to defining a behavioural equivalence would be to adapt to our language SAP the notion of higherorder weak bisimilarity given in <ref type="bibr" target="#b16">[15]</ref> tbr HOTr. This uses weak actions of the tbrm --~ ~ &gt;, and since certain actions have concretions as residuals it also requires a method for comparing concretions.</p><p>In the full version of the paper we show that the resulting equivalence, which we call delay bisimilarity, is strictly contained in barbed congruence. This is not surprising since it uses weak actions which do not permit T-moves after visible actions.</p><p>The co-inductive characterisation of barbed congruence presented here is based on an extension of the lts of Table <ref type="table">3</ref> in which the use of concretions is eliminated. Y¥~ do this by "applying" them to arbitrary processes: DmNmON 4.5. ~'m&lt;P&gt;JJ./~ %f ~'m04P I /q I (J) where {'&amp;} is chosen so that {'&amp;} A flz(R) = O.</p><p>With this form of application we can now replace the higherorder actions which have concretions as residuals, that is, er~ter(n,h&gt;, exit(n,h&gt;, and e~(n,h&gt;, with the family of actions enter(n, h}R, exit(n, h}R, e~(n, h}m[R], respectively, whose residuals will be processes; here R and rn[R] represent part of the contribution of the environment to the performance of the higher-order actions. Notice that the bisimilarity above considers only actions from processes to processes. TItEOREM 4.8. Ambient bisimilarity is a congruence. PROOF SKETCIt, Let ,.9 be the least equivalence relation which i) contains the relation ~, and ii) is preserved by restriction, parallel composition, and ambient operators. YV~ prove that ,.9 is an ambient bisimilarity up to ~-, by induction on the definition of ,.9 .</p><p>~V~ only consider the case when P I R $ Q I R because P ,. [] }V~ believe that the distinguishing contexts in the proof above can be defined without the use of passwords, except when o: is an er~ter action. In this case however the use of fresh passwords is essential. In order to test that a process can allow entry to an ambient we can send it an ambient which contains a fresh password. Probing for this fresh password ensures that the ambient we have sent has indeed been accepted. Without fresh passwords there would be no distinguishing t&gt;ature of the ambient sent which could be used in the probe. Moreover our rules for SK~, different from those in <ref type="bibr" target="#b8">[8]</ref>, play a crucial role in the distinguishing contexts %r both eater and ±~ actions. The alternative semantics for out(n} given in <ref type="bibr" target="#b8">[8]</ref> uses an auxiliary action ?n %r which it is difficult to conceive of a distinguishing context.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ADDING COMMUNICATION</head><p>In this section we extend SAP to allow local communication inside ambients. The basic idea is to have an output process such as (E}.P, which outputs the message E and then continues as P, and an input process (x).Q which on receiving a message binds it to x in Q which then executes; here occurrences of x in Q are bound. Notice that we have synchronous output; as discussed in <ref type="bibr" target="#b20">[19,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b1">1]</ref> this is not unrealistic because communication is always local. The syntax of our extended language is given in the Appendix in Table <ref type="table">6</ref>.</p><p>The operational semantics is defined over processes, i.e. terms which have no free occurrences of variables, by introducing two new labels: (E) for input, (-} for output, and a new form of concretion @(E}Q. In Table <ref type="table" target="#tab_2">4</ref> we give all the defining rules which should be added to those of Table <ref type="table">8</ref> and Definition 4.6 to obtain the its P ~ O for the processes, that is dosed terms, of our extended language. The rules are straighttbrward and require no comment. However note that in the structural rules of Table <ref type="table">8</ref> we are now assuming that parallel composition and restriction distribute over the new forms of concretions viS(E}P in the same manner as ,.,~(P&gt;j~.</p><p>In order to obtain a reasonable semantic equivalence we must now transform these transitions into ones which do not involve concretions. The only problem is the output rule, which delivers a new form of concretion. First we define the application of these concretions to terms; this is then used, {-&gt; as in Section 4, to transform a transition P &gt; w~(E}Q into a transition P L p, &gt; for some process P' and label L.</p><p>Let R be any term such that x is the only free variable in R; intuitively x represents the placeholder for the rues-&lt;-&gt; sage E which will be received via an output action P &gt; v'iS(E}Q. Then, we define where the bound variables/~ are chosen so that fn(R)A/~ = 0. The above transitions can be used to generalise, in the standard manner, the definition of ambient bisimilarity, ~, to arbitrary terms of our extended message-passing language.</p><p>For any two arbitrary terms T, U we write T ~ U if for all substitutions ~, mappings from variables to names, we have Ta ~ Utr.</p><p>TUEOREM 5.1. Relations ~ and ~ coincide over" arbitrar'y Set'ms in She message-passing language.</p><p>In <ref type="bibr" target="#b0">[9]</ref> we point out how a simpler, and perhaps more natural, rule for output processes which avoids concretions would make the ambient bisimilarity strictly included in barbed congruence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXAMPLES</head><p>In this section we briefly outline how our results could form the basis for reasoning techniques for ambients.</p><p>First of all our language is expressive. By simply using the names of ambients as passwords we can consider the language of Safe ambients <ref type="bibr" target="#b8">[8]</ref> as a sub-language, although the semantics of the out is slightly different. Thus the various examples programmed in that paper could now be be analysed using our bisimulations.</p><p>In <ref type="bibr" target="#b0">[9]</ref> we show how passwords can be used to rewrite the protocol to route packets to various destinations given in <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b8">8]</ref>. Here we focus on the protocol for controlling accesses through a firewall <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b8">8]</ref>. Our version is inspired by that in <ref type="bibr" target="#b8">[8]</ref> but now passwords are used. Ambient f represents the firewall and h/ is the password to cross it; ambient a represents a trusted agent inside which is a process Q that is supposed to cross the firewall, h~ is the password to access U,. Note that here, unlike <ref type="bibr" target="#b8">[8]</ref>, the names f and a, of the firewall and agent respectively, can be considered punic information; the security of the system resides in keeping the passwords h~ and h~ private.</p><p>YV~ now turn our attention to some example laws which we can justiI~y straightforwardly using bisimulations. In <ref type="bibr" target="#b8">[8]</ref> it is shown that by establishing a set of basic laws between ambients non-trivial reasoning can be carried out. Indeed most of our laws are taken directly from that paper, or are simple modifications thereof. Here we show how they can be established using bisimulations, rather than the more complicated contextual reasoning in <ref type="bibr" target="#b8">[8]</ref>.</p><p>The simplest example is n[ ] = 0. These two processes are bisimilar because the singleton set {(hi0] , 0)} is a trivial bisimulation; neither side can perform any action. Note that this law is not true in MA.</p><p>An important law in MA, is the perfect firewall equation v"n n[P] = 0 where n q~ fit(P). This law is not true in our setting, nor does it hold in SA. For example, consider the case when P is given by P = in(k}.  PROOF. Similar to the proof in <ref type="bibr" target="#b8">[8]</ref>, but now applying Laws 5, 1, 4, 6, 1, 4 of Theorem 6.2. [] Note that, because the security of the system is only mainrained by keeping the passwords secret, in this law we have to restrict on these, rather than on the names f and a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">v'h(rn[ir~(n, h}.P]</head><formula xml:id="formula_4">I '~[~(~, h}.Q]) ~ v,h(n[Q I -4P]])<label>2</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION AND RELATED WORK</head><p>Higher-order ltss fbr Mobile Ambients can be tbund in <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b19">18]</ref>. However we are not aware of any tbrm of bisimilarity defined using these ltss. Our its is inspired by that in <ref type="bibr" target="#b8">[8]</ref> which dift&gt;rs t¥om ours mainly in two respects. The first is that in our its the co-capability out is exercised by the target computation space and not by the surrounding ambient; this allows us to avoid the action ?n of <ref type="bibr" target="#b8">[8]</ref> for which it is difficult to conceive of a distinguishing context. The second point is that we have a dift&gt;rent kind of concretion with a dift~rent meaning. In SA a concretion @(P}(~ means that P is moving whereas (] stays where it is; in SAP we are more precise, a concretion @(P}~(] means that P is the computation inside ambient n and (~ is the computation outside n.</p><p>This allows us to define a reasonable its and theretbre use a standard notion of bisimilarity (c.f. Definitions 4.6 and 4.7 ) for SAP.</p><p>A simple first-order its for MA without restriction operator is proposed by Sangiorgi in <ref type="bibr" target="#b17">[16]</ref>. Using this its the author defines an ir~tensional bisimilarity for MA which separates terms on the basis of their internal structure. Sangiorgi shows that his bisimilarity coincides with the equivalence induced by the logic for MA given in <ref type="bibr" target="#b4">[4]</ref> and and more surprisingly with structural congruence s . This result somehow shows that the algebraic theory of Mobile Ambient is quite poor.</p><p>With some work our its can be adapted to both MA and SA. }V~ believe that in both cases it is possible to derive a bisimulation congruence similar to our ambient bisimilarity. However in both cases there are severe difficulties in proving that such bisimilarity completely characterise barbed congruence. In MA ambient movements are completely asynchronous (there are no co-capabilities) and this leads to a stuttering phenomena originated by ambients that may repeatedly enter and exit another ambient. As a consequence, it is far i¥om trivial to find a distinguishing context tbr actions like enter(n}. Stuttering does not show up in SA and SAP because movements are achieved by means of synchronisation between a capability and a co-capability. However characterisations results for SA, similar to Theorem 4.9, are very difficult to prove. The technical problem is due to the difficulty in conceiving a distinguishing context ibr actions like 7fffg~(n}. Roughly, in order to test that a process can allow entry to an ambient n, a distinguishing context has to move an ambient rn into n. In SAP probing for this using iYesh passwords ensures that ambient rn has indeed been accepted at n. Without fresh passwords there would be no distinguishing i~ature of the particular ambient rn which could be used in the probe. Alternatively, instead of using SThis is proved in synchronous MA where communication, like in SAP, is synchronous; in asynchronous MA the difference between bisimilarity and z is captured by a single axiollL passwords, one may think of equipping SAa with guarded choice ~ la CC8. }¥~ believe that in SA with guarded choice ambient bisimilarity coincides with barbed congruence. The proof that ambient bisimilarity implies barbed congruence does not present particular difficulties. The interesting part is the converse where guarded choice plays a crucial role in the proof. However, a general implementation of guarded choice is problematic as it involves non-local consensus decisions. For this reason we prater our version of ambients with passwords, SAP, which we believe is a good basis for developing interesting typing disciplines tbr mobile code making use of passwords. Even more, we think we can derive a labelled characterisation of typed barbed congruence along the lines of Hennessy and Rathke's <ref type="bibr" target="#b6">[6]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Table 2 :</head><label>2</label><figDesc>Labels~ Concretions~ and Outcoinesthere is the capability to enter ambient rn with password h.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>,</head><label></label><figDesc>4~.k(.4o~t&lt;r~,h&gt;.±.d Ip~)] ~°~&lt;~"'~&gt;&gt; ~.k(,4p2]l.4pd ) Finally the action pop(n, h} is only possible if the environment allows the emigration of ambient n, controlled by the co-action bTff~(n, h}, and codified in the rule (r Out); an application of which gives: k(,4eA I -4Pd) I ~¥~ end this section with a theorem which asserts that the its based semantics coincides with the reduction semantics of Section 2. TtIEOREM 3.1. If P ~ P' then P ~ P'. If P ~ P' then P ---~z P'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>TtIEOREM 4 . 4 .</head><label>44</label><figDesc>Let IP and Q be two processes, then for any A in 12 it holds that IP ~ Q iff lp ~x Q. (Act) /~.P ~ P (Repl Act) !~.P ~ P i!~. P P in(rs,£&gt; &gt; pt [~] --% ,40] (*) In rule (~ In) we require ((fn(P~) U fn(Iaz)) F/ {(~}) --((fn(O~) U fn(O2)) F/ {fi}) --0 Table 3: Labelled Transition Systein PROOF SKIGTCtt, Since the ~ and ~x dift~r only in the barb which is used it suffices to show $~ and Sxu,14 imply each other. }¥~ only examine the case A = enter. The other cases are similar. Let us consider first the implication Dora left to right. Let P ~ Q and P$~o~&lt;~,l~&gt;; we will conclude that Q$o~o~&lt;~,14" Consider the context &amp;['] = ['] I /[in&lt;n, h}.out(n, k}] I ~&lt;~, k&gt;.g[SF~&lt;g&gt;]. If f, g and k are Desh to R, then the context Sz[.] has the property that R~=~=&lt;~,l~ &gt; iff Si[R]~. For P ~ Q implies S1 [P] ~ S1 [Q] which in turn implies S1 [Q]g~, Dora which we have the required Q#o=~o=&lt;~,14"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>DEFINITION 4, 6 (</head><label>6</label><figDesc>AMBIENT TRANSITIONS). Let m be an arbitrary name and R an arbitrary process. Then:• IP ~&gt; K.R ~flP ~ K, ]'or'c~ = eater(n,h} or" c~ = exit(n, h} * P &gt; K*'rn[/~] ifP &gt; K.The ambient transitions are defined from processes to processes and therefore give rise to weak transitions of a stan-) A symmet tic relation $ is an ambient bisimulation if P $ Q and P ~ &gt; P' implies that there exists Q' ~uch that Q ~ Q' and P' $ Q'. IP and Q are arr~bient bisimilar, written P ~ (2, if P $<ref type="bibr" target="#b2">(2 ]</ref>'or some arr~bient bisimulation $.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>TttEOREM 4 . 9 .</head><label>49</label><figDesc>9 Q. Then, we carry out an inductive analysis on the transition P I R ~ O. The most interesting case is when c~ = r. Let us consider the case when P I R ~ &gt; 0 because P *~*~(~'~&gt; *~*~(~'~&gt; &gt; K~ and R &gt; inition, P ~(~,z~&gt;~4~h] &gt; K~ • 'rn[R~] = P'. By the induction hypothesis, P $ Q and so there is Q' such that Q ~ &gt; Kz,'rn[R~] ~Q' with P' $ Q', Thus, rla ~O~_~(r'la~)~ndqla ~ ,~((K~-,,[~d) I ~) ~ "~(~/ I ~) = 0'. As ~' S ~' and ,.9 is preserved by parallel composition and restriction, we get O $ O', as desired. The other cases are similar. [] By Theorem 4.8 and Lemma 4.1, we can now conclude that ambient bisimilarity ~ is contained in barbed congruence ~. The next step is to prove that ambient bisimilarity completely characterises barbed congruence. Ambient bisimilarity and barbed congruence coincide. PROOF SKETCtt, By Theorem 4.8 and Lemma 4.1 ambient bisimilarity is contained in barbed congruence. As to the completeness part, by Theorem 4.4, it suffices to prove that the relation $ = {(P, Q) : P ~pop (]} is an ambient bisimilarity up to ~_. }V~ just show one of the most interesting cases, that is when c~ = enter(n, h}'m[/{]. ) P', that is P ) K~ = -~(~&gt;~s2, where m= C~['-4a]] ~nd C~[.] = "~04['] I S~] let). Here we need to find some Q' such that Q ~(~-~&gt;-4~1 &gt; Q, and P' ,$ Q', ~V~ define: C~7.[R] ['] d c'f [.] I "4i~(~, h}.((R. I o~t(~, hi}) .~ owt;(n, hz})] where hi are fresh names and ~) denotes internal choice. As P ~pop (~ it follows that C~.41~][P ] ~pop C&lt;xs~[l{][(~]. So, if C~41~][P ] ~ ~ Cl[m[R I out(n, hi}]], then there is a process Z such that C~,4~][Q] ~ Z and C~["4~ I o~t(~, h~}]] ~pop Z. As a consequence, Zgsos(~,z~ } and ZgsosU, z~ }. This implies that in the reductions sequence C~,4~][Q] ~ Z the prefix in(n, h} is consumed. More precisely, one can prove that there exist static contexts (in which the hole is not underneath prefixing or replication) C'[.], C"[.] and C~[.] such that: C~,4~r][Q ] = Q I'rn[i~(n,h}.((/~l out('n,h~})Q out(n, hz})] ~ c'[.4(z~ I o~t(,,~, hi}) .~ owt;(n, hz}]] = Z Since h, is fresh and contexts C,[] and Cz[] are static, Cl['fl~[RlOllt(r~,hl}]] ~pop Z implies Cl[m[R]] ~pop C2[0]. ~V~ now have the required Q', namely Cz [0]. An analysis of the above reductions gives Q ~ &gt; C'['rn[R]], and again, since h~ is fresh, it holds that C['rn[R]] ~_ Q'.So, Q ~u,l~}~41~]&gt;~_ Q, and P' $ Q', as required.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Eps) e.P ---~ P &gt; O' fl~(O') n {p} = o</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>define the extra ambient transition, for any such R to add to those in Definition 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>FW d~=f v'</head><label></label><figDesc>h/(f[~(f,h/}.oper~(@.P I k[o~t(f, hz&gt;.*~(&lt; h~&gt;.~(k&gt;.(x~(f, hz&gt;&gt;] ] I a~(f, hy&gt; )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>. k[,,4,=(~, h&gt;.P] I ',~(~, h&gt;.O]] ~ k[',~[O I "4PIll 3. ~h(ope~(rn, h&gt;.P I "4~('~, h&gt;.@ ~ ~,h(P I(~) 4. kEop~(,~, h&gt;.P I '-4o~(-~, h&gt;.(~]] ~ kEPI (~2 5. v,h(n[rn[owc(n, h}.(~]] I o~(,~, h}.e) ~ v,h(rn[(~] I P) 6. ',4(E&gt;.P I (,').C~] ~ ',4P I &lt;~{E/~.}] PROOF. By exhibiting the appropriate bisimulation. In all cases the bisimulation has a similar and very simple form: S = {(LHS, RHS)}U where LHS, RHS denote the left hand side, right hand side respectively of the identity. [] These laws may now be used to prove our version of crossing a firewall: THeOReM 6.3. If h~ ~ fit(P) and hf ~ fn((~), then v'h~(AG I FFW) ~ v'(h~hf ) f[P I C~].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 . DEFINITION 4.2. We write P$~ if P ~ &gt;. We write</head><label>2</label><figDesc>Pg~ DEFINITION 4.3. Let 12 denote the labels in, out, open, in, out, open, enter, enter, exit, pop and free. For each k C 12 let ~x be the laryest congruence over" processes which is reduction closed and preserves A barbs.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 4 :</head><label>4</label><figDesc>Labelled Transition System -Communication</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>The authors would like to thank Julian Rathke and Davide Sangiorgi for insightful discussions on higher-order process calculi and Saf~ Ambients, respectively. Many thanks also to the anonymous ref&gt;rees for detailed comments. Research funded by EPSRC grant GR/M71169.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ii) is preserved by all operators except prefixing and replication.  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Boxed ambients</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bugliesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Castagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Crafa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Sth Int. Confervnce on Theorvtical Aspects of Corr~puter Science</title>
		<title level="s">Lecturv Notes in Corr~puter Science</title>
		<meeting>of the Sth Int. Confervnce on Theorvtical Aspects of Corr~puter Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2215</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A commitment relation for the ambient calculus</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Gordon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>UnpuNished notes</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Types for mobile ambients</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 26th A CM SIGPLAN-SIGACT Symposium on Principles of Prvgrumming Languages</title>
		<meeting>of the 26th A CM SIGPLAN-SIGACT Symposium on Principles of Prvgrumming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="79" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Anytime, anywhere: Modal logics ibr mobile ambients</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Prvc. of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Prvgr~mming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="365" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Mobile ambients</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theorvtical Corr~puter Science</title>
		<imprint>
			<biblScope unit="volume">240</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">98</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Typed behavioural equivalences for processes in the presence of subtyping</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rathke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Report</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">01</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>University of Sussex</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On reduction-based process semantics</title>
		<author>
			<persName><forename type="first">K</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theorvtical Corr~puter Science</title>
		<imprint>
			<biblScope unit="volume">152</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="437" to="486" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Controlling interi~rence in ambients</title>
		<author>
			<persName><forename type="first">F</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2?th Symposium on Principles of Programming Languages</title>
		<meeting>2?th Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">SMote precisely, SA with our operational semantics for out</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Bisimulation congruences in saf~ ambients</title>
		<author>
			<persName><forename type="first">M</forename><surname>Merro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Report</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">01</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>University of Sussex</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Corr~munication and Concurrency</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A calculus of mobile processes, (Parts I and II)</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>~¥31ker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Corr~putation</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
	<note>i00:i 77</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Barbed bisimulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Prvc. 19th ICALP</title>
		<title level="s">Lecturv Notes in Corr~puter Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="685" to="695" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Eaprvssing Mobility in Process Algebras: First-Order and Higher-Order Paradigms</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
		<idno>CST 99 93</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The lazy lambda calculus in a concurrency scenario</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Corr~putation</title>
		<imprint>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="120" to="153" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Bisimulation tbr Higher-Order Process Calculi</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Corr~putation</title>
		<imprint>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="141" to="178" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Extensionality and intensionality of the ambient logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pwc. of the 28th ACM SIGPLAN-SIGACT Symposium on Principles of Prwr~mming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The problem of &quot;Weak Bisimulation up to</title>
		<author>
			<persName><forename type="first">D</forename><surname>Sangiorgi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Prvc. CONCUR &apos;92</title>
		<title level="s">Lecturv Notes in Corr~puter Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">630</biblScope>
			<biblScope unit="page" from="32" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Transitions systems for the ambient calculus</title>
		<author>
			<persName><forename type="first">Grazia</forename><surname>Maria</surname></persName>
		</author>
		<author>
			<persName><surname>Vigliotti</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
		</imprint>
		<respStmt>
			<orgName>Imperial College of Science, Technology and Medicine (University of London)</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Seal: A framework tbr secure mobile computations</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Castagna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Internet Prwr~mming Languages</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
