<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Neural Architecture Search with Bayesian Optimisation and Optimal Transport</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kirthevasan</forename><surname>Kandasamy</surname></persName>
							<email>kandasamy@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Petuum Inc</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Willie</forename><surname>Neiswanger</surname></persName>
							<email>willie@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Petuum Inc</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jeff</forename><surname>Schneider</surname></persName>
							<email>schneide@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Petuum Inc</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Barnabás</forename><surname>Póczos</surname></persName>
							<email>bapoczos@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Petuum Inc</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eric</forename><forename type="middle">P</forename><surname>Xing</surname></persName>
							<email>epxing@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<settlement>Petuum Inc</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Neural Architecture Search with Bayesian Optimisation and Optimal Transport</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Bayesian Optimisation (BO) refers to a class of methods for global optimisation of a function f which is only accessible via point evaluations. It is typically used in settings where f is expensive to evaluate. A common use case for BO in machine learning is model selection, where it is not possible to analytically model the generalisation performance of a statistical model, and we resort to noisy and expensive training and validation procedures to choose the best model. Conventional BO methods have focused on Euclidean and categorical domains, which, in the context of model selection, only permits tuning scalar hyper-parameters of machine learning algorithms. However, with the surge of interest in deep learning, there is an increasing demand to tune neural network architectures. In this work, we develop NASBOT, a Gaussian process based BO framework for neural architecture search. To accomplish this, we develop a distance metric in the space of neural network architectures which can be computed efficiently via an optimal transport program. This distance might be of independent interest to the deep learning community as it may find applications outside of BO. We demonstrate that NASBOT outperforms other alternatives for architecture search in several cross validation based model selection tasks on multi-layer perceptrons and convolutional neural networks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In many real world problems, we are required to sequentially evaluate a noisy black-box function f with the goal of finding its optimum in some domain X . Typically, each evaluation is expensive in such applications, and we need to keep the number of evaluations to a minimum. Bayesian optimisation (BO) refers to an approach for global optimisation that is popularly used in such settings. It uses Bayesian models for f to infer function values at unexplored regions and guide the selection of points for future evaluations. BO has been successfully applied for many optimisation problems in optimal policy search, industrial design, and scientific experimentation. That said, the quintessential use case for BO in machine learning is model selection <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b39">40]</ref>. For instance, consider selecting the regularisation parameter λ and kernel bandwidth h for an SVM. We can set this up as a zeroth order optimisation problem where our domain is a two dimensional space of (λ, h) values, and each function evaluation trains the SVM on a training set, and computes the accuracy on a validation set. The goal is to find the model, i.e. hyper-parameters, with the highest validation accuracy.</p><p>The majority of the BO literature has focused on settings where the domain X is either Euclidean or categorical. This suffices for many tasks, such as the SVM example above. However, with recent successes in deep learning, neural networks are increasingly becoming the method of choice for many machine learning applications. A number of recent work have designed novel neural network architectures to significantly outperform the previous state of the art <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b44">45]</ref>. This motivates studying model selection over the space of neural architectures to optimise for generalisation performance. A critical challenge in this endeavour is that evaluating a network via train and validation procedures is very expensive. This paper proposes a BO framework for this problem.</p><p>While there are several approaches to BO, those based on Gaussian processes (GP) <ref type="bibr" target="#b34">[35]</ref> are most common in the BO literature. In its most unadorned form, a BO algorithm operates sequentially, starting at time 0 with a GP prior for f ; at time t, it incorporates results of evaluations from 1, . . . , t−1 in the form of a posterior for f . It then uses this posterior to construct an acquisition function ϕ t , where ϕ t (x) is a measure of the value of evaluating f at x at time t if our goal is to maximise f . Accordingly, it chooses to evaluate f at the maximiser of the acquisition, i.e. x t = argmax x∈X ϕ t (x). There are two key ingredients to realising this plan for GP based BO. First, we need to quantify the similarity between two points x, x in the domain in the form of a kernel κ(x, x ). The kernel is needed to define the GP, which allows us to reason about an unevaluated value f (x ) when we have already evaluated f (x). Secondly, we need a method to maximise ϕ t .</p><p>These two steps are fairly straightforward in conventional domains. For example, in Euclidean spaces, we can use one of many popular kernels such as Gaussian, Laplacian, or Matérn; we can maximise ϕ t via off the shelf branch-and-bound or gradient based methods. However, when each x ∈ X is a neural network architecture, this is not the case. Hence, our challenges in this work are two-fold. First, we need to quantify (dis)similarity between two networks. Intuitively, in Fig. <ref type="figure">1</ref>, network 1a is more similar to network 1b, than it is to 1c. Secondly, we need to be able to traverse the space of such networks to optimise the acquisition function. Our main contributions are as follows. Related Work: Recently, there has been a surge of interest in methods for neural architecture search <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b51">[51]</ref><ref type="bibr" target="#b52">[52]</ref><ref type="bibr" target="#b53">[53]</ref><ref type="bibr" target="#b54">[54]</ref>. We discuss them in detail in the Appendix due to space constraints. Broadly, they fall into two categories, based on either evolutionary algorithms (EA) or reinforcement learning (RL). EA provide a simple mechanism to explore the space of architectures by making a sequence of changes to networks that have already been evaluated. However, as we will discuss later, they are not ideally suited for optimising functions that are expensive to evaluate. While RL methods have seen recent success, architecture search is in essence an optimisation problemfind the network with the lowest validation error. There is no explicit need to maintain a notion of state and solve credit assignment <ref type="bibr" target="#b42">[43]</ref>. Since RL is a fundamentally more difficult problem than optimisation <ref type="bibr" target="#b15">[16]</ref>, these approaches need to try a very large number of architectures to find the optimum. This is not desirable, especially in computationally constrained settings.</p><p>None of the above methods have been designed with a focus on the expense of evaluating a neural network, with an emphasis on being judicious in selecting which architecture to try next. Bayesian optimisation (BO) uses introspective Bayesian models to carefully determine future evaluations and is well suited for expensive evaluations. BO usually consumes more computation to determine future points than other methods, but this pays dividends when the evaluations are very expensive. While there has been some work on BO for architecture search <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b43">44]</ref>, they have only been applied to optimise feed forward structures, e.g. Fig. <ref type="figure">1a</ref>, but not Figs. <ref type="figure">1b, 1c</ref>. We compare NASBOT to one such method and demonstrate that feed forward structures are inadequate for many problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Set Up</head><p>Our goal is to maximise a function f defined on a space X of neural network architectures. When we evaluate f at x ∈ X , we obtain a possibly noisy observation y of f (x). In the context of architecture search, f is the performance on a validation set after x is trained on the training set. If x = argmax X f (x) is the optimal architecture, and x t is the architecture evaluated at time t, we want f (x ) − max t≤n f (x t ) to vanish fast as the number of evaluations n → ∞. We begin with a review of BO and then present a graph theoretic formalism for neural network architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A brief review of Gaussian Process based Bayesian Optimisation</head><p>A GP is a random process defined on some domain X , and is characterised by a mean function µ : X → R and a (covariance) kernel κ : </p><formula xml:id="formula_0">X 2 → R. Given n observations D n = {(x i , y i )} n i=1 ,</formula><p>Figure <ref type="figure">1</ref>: An illustration of some CNN architectures. In each layer, i: indexes the layer, followed by the label (e.g conv3), and then the number of units (e.g. number of filters). The input and output layers are pink while the decision (softmax) layers are green. x i ∈ X , y i = f (x i ) + i ∈ R, and i ∼ N (0, η 2 ), the posterior process f |D n is also a GP with mean µ n and covariance</p><formula xml:id="formula_2">κ n . Denote Y ∈ R n with Y i = y i , k, k ∈ R n with k i = κ(x, x i ), k i = κ(x , x i ),</formula><p>and K ∈ R n×n with K i,j = κ(x i , x j ). Then, µ n , κ n can be computed via,</p><formula xml:id="formula_3">µ n (x) = k (K + η 2 I) −1 Y, κ n (x, x ) = κ(x, x ) − k (K + η 2 I) −1 k .<label>(1)</label></formula><p>For more background on GPs, we refer readers to Rasmussen and Williams <ref type="bibr" target="#b34">[35]</ref>. When tasked with optimising a function f over a domain X , BO models f as a sample from a GP. At time t, we have already evaluated f at points {x i } t−1 i=1 and obtained observations {y i } t−1 i=1 . To determine the next point for evaluation x t , we first use the posterior GP to define an acquisition function ϕ t : X → R, which measures the utility of evaluating f at any x ∈ X according to the posterior. We then maximise the acquisition x t = argmax X ϕ t (x), and evaluate f at x t . The expected improvement acquisition <ref type="bibr" target="#b30">[31]</ref>,</p><formula xml:id="formula_4">ϕ t (x) = E max{0, f (x) − τ t−1 } {(x i , y i )} t−1 i=1 ,<label>(2)</label></formula><p>measures the expected improvement over the current maximum value according to the posterior GP.</p><p>Here τ t−1 = argmax i≤t−1 f (x i ) denotes the current best value. This expectation can be computed in closed form for GPs. We use EI in this work, but the ideas apply just as well to other acquisitions <ref type="bibr" target="#b2">[3]</ref>.</p><p>GP/BO in the context of architecture search: Intuitively, κ(x, x ) is a measure of similarity between x and x . If κ(x, x ) is large, then f (x) and f (x ) are highly correlated. Hence, the GP effectively imposes a smoothness condition on f : X → R; i.e. since networks a and b in Fig. <ref type="figure">1</ref> are similar, they are likely to have similar cross validation performance. In BO, when selecting the next point, we balance between exploitation, choosing points that we believe will have high f value, and exploration, choosing points that we do not know much about so that we do not get stuck at a bad optimum. For example, if we have already evaluated f (a), then exploration incentivises us to choose c over b since we can reasonably gauge f (b) from f (a). On the other hand, if f (a) has high value, then exploitation incentivises choosing b, as it is more likely to be the optimum than c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">A Mathematical Formalism for Neural Networks</head><p>Our formalism will view a neural network as a graph whose vertices are the layers of the network. We will use the CNNs in Fig. <ref type="figure">1</ref> to illustrate the concepts. A neural network G = (L, E) is defined by a set of layers L and directed edges E. An edge (u, v) ∈ E is a ordered pair of layers. In Fig. <ref type="figure">1</ref>, the layers are depicted by rectangles and the edges by arrows. A layer u ∈ L is equipped with a layer label (u) which denotes the type of operations performed at the layer. For instance, in Fig. <ref type="figure">1a</ref>, (1) = conv3, (5) = max-pool denote a 3 × 3 convolution and a max-pooling operation.</p><p>The attribute u denotes the number of computational units in a layer. In Fig. <ref type="figure">1b</ref>, u(5) = 32 and u(7) = 16 are the number of convolutional filters and fully connected nodes.</p><p>In addition, each network has decision layers which are used to obtain the predictions of the network. For a classification task, the decision layers perform softmax operations and output the probabilities an input datum belongs to each class. For regression, the decision layers perform linear combinations of the outputs of the previous layers and output a single scalar. All networks have at least one decision layer. When a network has multiple decision layers, we average the output of each decision layer to obtain the final output. The decision layers are shown in green in Fig. <ref type="figure">1</ref>. Finally, every network has a unique input layer u ip and output layer u op with labels (u ip ) = ip and (u op ) = op. It is instructive to think of the role of u ip as feeding a data point to the network and the role of u op as averaging the results of the decision layers. The input and output layers are shown in pink in Fig. <ref type="figure">1</ref>. We refer to all layers that are not input, output or decision layers as processing layers.</p><p>The directed edges are to be interpreted as follows. The output of each layer is fed to each of its children; so both layers 2 and 3 in Fig. <ref type="figure">1b</ref> take the output of layer 1 as input. When a layer has multiple parents, the inputs are concatenated; so layer 5 sees an input of 16 + 16 filtered channels coming in from layers 3 and 4. Finally, we mention that neural networks are also characterised by the values of the weights/parameters between layers. In architecture search, we typically do not consider these weights. Instead, an algorithm will (somewhat ideally) assume access to an optimisation oracle that can minimise the loss function on the training set and find the optimal weights. We next describe a distance d : X 2 → R + for neural architectures. Recall that our eventual goal is a kernel for the GP; given a distance d, we will aim for κ(x, x ) = e −βd(x,x ) p , where β, p ∈ R + , as the kernel. Many popular kernels take this form. For e.g. when X ⊂ R n and d is the L 2 norm, p = 1, 2 correspond to the Laplacian and Gaussian kernels respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The OTMANN Distance</head><p>To motivate this distance, note that the performance of a neural network is determined by the amount of computation at each layer, the types of these operations, and how the layers are connected. A meaningful distance should account for these factors. To that end, OTMANN is defined as the minimum of a matching scheme which attempts to match the computation at the layers of one network to the layers of the other. We incur penalties for matching layers with different types of operations or those at structurally different positions. We will find a matching that minimises these penalties, and the total penalty at the minimum will give rise to a distance. We first describe two concepts, layer masses and path lengths, which we will use to define OTMANN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Layer masses:</head><p>The layer masses m : L → R + will be the quantity that we match between the layers of two networks when comparing them. m(u) quantifies the significance of layer u. For processing layers, m(u) will represent the amount of computation carried out by layer u and is computed via the product of u(u) and the number of incoming units. For example, in Fig. <ref type="figure">1b</ref>, m(5) = 32 × (16 + 16) as there are 16 filtered channels each coming from layers 3 and 4 respectively. As there is no computation at the input and output layers, we cannot define the layer mass directly as we did for the processing layers. Therefore, we use m(u ip ) = m(u op ) = ζ u∈PL m(u) where PL denotes the set of processing layers, and ζ ∈ (0, 1) is a parameter to be determined. Intuitively, we are using an amount of mass that is proportional to the amount of computation in the processing layers. Similarly, the decision layers occupy a significant role in the architecture as they directly influence the output. While there is computation being performed at these layers, this might be problem dependent -there is more computation performed at the softmax layer in a 10 class classification problem than in a 2 class problem. Furthermore, we found that setting the layer mass for decisions layers based on computation underestimates their contribution to the network. Following the same intuition as we did for the input/output layers, we assign an amount of mass proportional to the mass in the processing layers. Since the outputs of the decision layers are averaged, we distribute the mass among all decision layers; that is, if DL are decision layers, ∀ u ∈ DL, m(u) = ζ |DL| u∈PL m(u). In all our experiments, we use ζ = 0.1. In Fig. <ref type="figure">1</ref>, the layer masses for each layer are shown in parantheses.</p><p>Path lengths from/to u ip /u op : In a neural network G, a path from u to v is a sequence of layers u 1 , . . . , u s where u 1 = u, u s = v and (u i , u i+1 ) ∈ E for all i ≤ s − 1. The length of this path is the number of hops from one node to another in order to get from u to v. For example, in Fig. <ref type="figure">1c</ref>, (2, 5, 8, 13) is a path from layer 2 to 13 of length 3. Let the shortest (longest) path length from u to v be the smallest (largest) number of hops from one node to another among all paths from u to v. Additionally, define the random walk path length as the expected number of hops to get from u to v, if, from any layer we hop to one of its children chosen uniformly at random. For example, in Fig. <ref type="figure">1c</ref>, the shortest, longest and random walk path lengths from layer 1 to layer 14 are 5, 7, and 5.67 respectively. For any u ∈ L, let δ sp op (u), δ lp op (u), δ rw op (u) denote the length of the shortest, longest and random walk paths from u to the output u op . Similarly, let δ sp ip (u), δ lp ip (u), δ rw ip (u) denote the corresponding lengths for walks from the input u ip to u. As the layers of a neural network can be topologically ordered<ref type="foot" target="#foot_1">1</ref> , the above path lengths are well defined and finite. Further, for any s ∈ {sp,lp,rw} and t ∈ {ip,op}, δ s t (u) can be computed for all u ∈ L, in O(|E|) time (see Appendix A.3 for details).</p><formula xml:id="formula_5">conv3 conv5 max-pool avg-pool fc conv3 0 0.2 ∞ ∞ ∞ conv5 0.2 0 ∞ ∞ ∞ max-pool ∞ ∞ 0 0.25 ∞ avg-pool ∞ ∞ 0.25 0 ∞ fc ∞ ∞ ∞ ∞ 0</formula><p>We are now ready to describe OTMANN. Given two networks G 1 = (L 1 , E 1 ), G 2 = (L 2 , E 2 ) with n 1 , n 2 layers respectively, we will attempt to match the layer masses in both networks. We let Z ∈ R n1×n2 + be such that Z(i, j) denotes the amount of mass matched between layer i ∈ G 1 and j ∈ G 2 . The OTMANN distance is computed by solving the following optimisation problem.</p><formula xml:id="formula_6">minimise Z φ lmm (Z) + φ nas (Z) + ν str φ str (Z)<label>(3)</label></formula><formula xml:id="formula_7">subject to j∈L2 Z ij ≤ m(i), i∈L1 Z ij ≤ m(j), ∀i, j</formula><p>The label mismatch term φ lmm , penalises matching masses that have different labels, while the structural term φ str penalises matching masses at structurally different positions with respect to each other. If we choose not to match any mass in either network, we incur a non-assignment penalty φ nas . ν str &gt; 0 determines the trade-off between the structural and other terms. The inequality constraints ensure that we do not over assign the masses in a layer. We now describe φ lmm , φ nas , and φ str .</p><p>Label mismatch penalty φ lmm : We begin with a label penalty matrix M ∈ R L×L where L is the number of all label types and M (x, y) denotes the penalty for transporting a unit mass from a layer with label x to a layer with label y. We then construct a matrix C lmm ∈ R n1×n2 with C lmm (i, j) = M ( (i), (j)) corresponding to the mislabel cost for matching unit mass from each layer i ∈ L 1 to each layer j ∈ L 2 . We then set φ lmm (Z) = Z, C lmm = i∈L1,j∈L2 Z(i, j)C(i, j) to be the sum of all matchings from L 1 to L 2 weighted by the label penalty terms. This matrix M , illustrated in Table <ref type="table" target="#tab_2">1</ref>, is a parameter that needs to be specified for OTMANN. They can be specified with an intuitive understanding of the functionality of the layers; e.g. many values in M are ∞, while for similar layers, we choose a value less than 1.</p><p>Non-assignment penalty φ nas : We set this to be the amount of mass that is unassigned in both networks, i.e. φ nas (Z) = i∈L1 m(i) − j∈L2 Z ij + j∈L2 m(j) − i∈L1 Z ij . This essentially implies that the cost for not assigning unit mass is 1. The costs in Table <ref type="table" target="#tab_2">1</ref> are defined relative to this. For similar layers x, y, M (x, y) 1 and for disparate layers M (x, y) 1. That is, we would rather match conv3 to conv5 than not assign it, provided the structural penalty for doing so is small; conversely, we would rather not assign a conv3, than assign it to fc. This also explains why we did not use a trade-off parameter like ν str for φ lmm and φ nas -it is simple to specify reasonable values for M (x, y) from an understanding of their functionality.</p><p>Structural penalty φ str : We define a matrix C str ∈ R n1×n2 where C str (i, j) is small if layers i ∈ L 1 and j ∈ L 2 are at structurally similar positions in their respective networks. We then set φ str (Z) = Z, C str . For i ∈ L 1 , j ∈ L 2 , we let C str (i, j) = 1   6  s∈{sp, lp, rw} t∈{ip,op} |δ s t (i) − δ s t (j)| be the average of all path length differences, where δ s t are the path lengths defined previously. We define φ str in terms of the shortest/longest/random-walk path lengths from/to the input/output, because they capture various notions of information flow in a neural network; a layer's input is influenced by the paths the data takes before reaching the layer and its output influences all layers it passes through before reaching the decision layers. If the path lengths are similar for two layers, they are likely to be at similar structural positions. Further, this form allows us to solve (3) efficiently via an OT program and prove distance properties about the solution. If we need to compute pairwise distances for several networks, as is the case in BO, the path lengths can be pre-computed in O(|E|) time, and used to construct C str for two networks at the moment of computing the distance between them. This completes the description of our matching program. In Appendix A, we prove that (3) can be formulated as an Optimal Transport (OT) program <ref type="bibr" target="#b47">[47]</ref>. OT is a well studied problem with several efficient solvers <ref type="bibr" target="#b32">[33]</ref>. Our theorem below, shows that the solution of ( <ref type="formula" target="#formula_6">3</ref>) is a distance. Table <ref type="table" target="#tab_3">2</ref>: Descriptions of modifiers to transform one network to another. The first four change the number of units in the layers but do not change the architecture, while the last five change the architecture.</p><formula xml:id="formula_8">Theorem 1. Let d(G 1 , G 2 ) be the solution of (3) for networks G 1 , G 2 . Under mild regularity condi- tions on M , d(•, •) is a pseudo-distance. That is, for all networks G 1 , G 2 , G 3 , it satisfies, d(G 1 , G 2 ) ≥ 0, d(G 1 , G 2 ) = d(G 2 , G 1 ), d(G 1 , G 1 ) = 0 and d(G 1 , G 3 ) ≤ d(G 1 , G 2 ) + d(G 2 , G 3 ). For what follows, define d(G 1 , G 2 ) = d(G 1 , G 2 )/(tm(G 1 )+tm(G 2 )) where tm(G i ) = u∈Li m(u)</formula><p>is the total mass of a network. Note that d ≤ 1. While d does not satisfy the triangle inequality, it provides a useful measure of dissimilarity normalised by the amount of computation. Our experience suggests that d puts more emphasis on the amount of computation at the layers over structure and vice versa for d. Therefore, it is prudent to combine both quantities in any downstream application. The caption in Fig. <ref type="figure">1 gives d, d</ref> values for the examples in that figure when ν str = 0.5.</p><p>We conclude this section with a couple of remarks. First, OTMANN shares similarities with Wasserstein (earth mover's) distances which also have an OT formulation. However, it is not a Wasserstein distance itself-in particular, the supports of the masses and the cost matrices change depending on the two networks being compared. Second, while there has been prior work for defining various distances and kernels on graphs, we cannot use them in BO because neural networks have additional complex properties in addition to graphical structure, such as the type of operations performed at each layer, the number of neurons, etc. The above work either define the distance/kernel between vertices or assume the same vertex (layer) set <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b49">49]</ref>, none of which apply in our setting. While some methods do allow different vertex sets <ref type="bibr" target="#b48">[48]</ref>, they cannot handle layer masses and layer similarities. Moreover, the computation of the above distances are more expensive than OTMANN. Hence, these methods cannot be directly plugged into BO framework for architecture search.</p><p>In Appendix A, we provide additional material on OTMANN. This includes the proof of Theorem 1, a discussion on some design choices, and implementation details such as the computation of the path lengths. Moreover, we provide illustrations to demonstrate that OTMANN is a meaningful distance for architecture search. For example, a t-SNE embedding places similar architectures close to each other. Further, scatter plots showing the validation error vs distance on real datasets demonstrate that networks with small distance tend to perform similarly on the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NASBOT</head><p>We now describe NASBOT, our BO algorithm for neural architecture search. Recall that in order to realise the BO scheme outlined in Section 2.1, we need to specify (a) a kernel κ for neural architectures and (b) a method to optimise the acquisition ϕ t over these architectures. Due to space constraints, we will only describe the key ideas and defer all details to Appendix B.</p><p>As described previously, we will use a negative exponentiated distance for κ. Precisely, κ = αe −βd + ᾱd − β d, where d, d are the OTMANN distance and its normalised version. We mention that while this has the form of popular kernels, we do not know yet if it is in fact a kernel. In our experiments, we did not encounter an instance where the eigenvalues of the kernel matrix were negative. In any case, there are several methods to circumvent this issue in kernel methods <ref type="bibr" target="#b41">[42]</ref>.</p><p>We use an evolutionary algorithm (EA) approach to optimise the acquisition function <ref type="bibr" target="#b1">(2)</ref>. For this, we begin with an initial pool of networks and evaluate the acquisition ϕ t on those networks. Then we generate a set of N mut mutations of this pool as follows. First, we stochastically select N mut candidates from the set of networks already evaluated such that those with higher ϕ t values are more likely to be selected than those with lower values. Then we modify each candidate, to produce a new architecture. These modifications, described in  increasing or decreasing the number of computational units in a layer, by adding or deleting layers, or by changing the connectivity of existing layers. Finally, we evaluate the acquisition on this N mut mutations, add it to the initial pool, and repeat for the prescribed number of steps. While EA works fine for cheap functions, such as the acquisition ϕ t which is analytically available, it is not suitable when evaluations are expensive, such as training a neural network. This is because EA selects points for future evaluations that are already close to points that have been evaluated, and is hence inefficient at exploring the space. In our experiments, we compare NASBOT to the same EA scheme used to optimise the acquisition and demonstrate the former outperforms the latter.</p><p>We conclude this section by observing that this framework for NASBOT/OTMANN has additional flexibility to what has been described. If one wishes to tune over drop-out probabilities, regularisation penalties and batch normalisation at each layer, they can be treated as part of the layer label, via an augmented label penalty matrix M which accounts for these considerations. If one wishes to jointly tune other scalar hyper-parameters (e.g. learning rate), they can use an existing kernel for euclidean spaces and define the GP over the joint architecture + hyper-parameter space via a product kernel. BO methods for early stopping in iterative training procedures <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b21">22</ref>] can be easily incorporated by defining a fidelity space. Using a line of work in scalable GPs <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b50">50]</ref>, one can apply our methods to challenging problems which might require trying a very large number (∼100K) of architectures. These extensions will enable deploying NASBOT in large scale settings, but are tangential to our goal of introducing a BO method for architecture search.  Experimental Set up: Each method is executed in an asynchronously parallel set up of 2-4 GPUs, That is, it can evaluate multiple models in parallel, with each model on a single GPU. When the evaluation of one model finishes, the methods can incorporate the result and immediately re-deploy the next job without waiting for the others to finish. For the blog, indoor, slice, naval and protein datasets we use 2 GeForce GTX 970 (4GB) GPUs and a computational budget of 8 hours for each method. For the news popularity dataset we use 4 GeForce GTX 980 (6GB) GPUs with a budget of 6 hours and for Cifar10 we use 4 K80 (12GB) GPUs with a budget of 10 hours. For the regression datasets, we train each model with stochastic gradient descent (SGD) with a fixed step size of 10 −5 , a batch size of 256 for 20K batch iterations. For Cifar10, we start with a step size of 10 −2 , and reduce it gradually. We train in batches of 32 images for 60K batch iterations. The methods evaluate between 70-120 networks depending on the size of the networks chosen and the number of GPUs.</p><p>Results: Fig. <ref type="figure" target="#fig_2">2</ref> plots the best validation score for each method against time. In Table <ref type="table" target="#tab_5">3</ref>, we present the results on the test set with the best model chosen on the basis of validation set performance. On the Cifar10 dataset, we also trained the best models for longer (150K iterations). These results are in the last column of Table <ref type="table" target="#tab_5">3</ref>. We see that NASBOT is the most consistent of all methods. The average time taken by NASBOT to determine the next architecture to evaluate was 46.13s. For RAND, EA, and TreeBO this was 26.43s, 0.19s, and 7.83s respectively. The time taken to train and validate models was on the order of 10-40 minutes depending on the model size. Fig. <ref type="figure" target="#fig_2">2</ref> includes this time taken to determine the next point. Like many BO algorithms, while NASBOT's selection criterion is time consuming, it pays off when evaluations are expensive. In Appendices B and C, we provide additional details on the experiment set up and conduct synthetic ablation studies by holding out different components of the NASBOT framework. We also illustrate some of the best architectures found-on many datasets, common features were long skip connections and multiple decision layers.</p><p>Finally, we note that while our Cifar10 experiments fall short of the current state of the art <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b53">53]</ref>, the amount of computation in these work is several orders of magnitude more than ours (both the computation invested to train a single model and the number of models trained). Further, they use constrained spaces specialised for CNNs, while NASBOT is deployed in a very general model space.</p><p>We believe that our results can also be improved by employing enhanced training techniques such as image whitening, image flipping, drop out, etc. For example, using our training procedure on the VGG-19 architecture <ref type="bibr" target="#b36">[37]</ref> yielded a test set error of 0.1018 after 150K iterations. However, VGG-19 is known to do significantly better on Cifar10. That said, we believe our results are encouraging and lay out the premise for BO for neural architectures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We described NASBOT, a BO framework for neural architecture search. NASBOT finds better architectures for MLPs and CNNs more efficiently than other baselines on several datasets. A key contribution of this work is the efficiently computable OTMANN distance for neural network architectures, which may be of independent interest as it might find applications outside of BO. Our code for NASBOT and OTMANN will be made available.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>From Section 3 :</head><label>3</label><figDesc>Figure 1: An illustration of some CNN architectures. In each layer, i: indexes the layer, followed by the label (e.g conv3), and then the number of units (e.g. number of filters). The input and output layers are pink while the decision (softmax) layers are green. From Section 3: The layer mass is denoted in parentheses. The following are the normalised and unnormalised distances d, d . All self distances are 0, i.e. d(G, G) = d(G, G) = 0. Unnormalised: d(a, b) = 175.1, d(a, c) = 1479.3, d(b, c) = 1621.4. Normalised: d(a, b) = 0.0286, d(a, c) = 0.2395, d(b, c) = 0.2625.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>at random and decrease the number of units by 1/8. dec_en_masse Pick several layers at random and decrease the number of units by 1/8 for all of them. inc_single Pick a layer at random and increase the number of units by 1/8. inc_en_masse Pick several layers at random and increase the number of units by 1/8 for all of them. dup_path Pick a random path u1, . . . , u k , duplicate u2, . . . , u k−1 and connect them to u1 and u k . remove_layer Pick a layer at random and remove it. Connect the layer's parents to its children if necessary. skip Randomly pick layers u, v where u is topologically before v. Add (u, v) to E. swap_label Randomly pick a layer and change its label. wedge_layer Randomly remove an edge (u, v) from E. Create a new layer w and add (u, w), (w, v) to E.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Cross validation results: In all figures, the x axis is time. The y axis is the mean squared error (MSE) in the first 6 figures and the classification error in the last. Lower is better in all cases. The title of each figure states the dataset and the number of parallel workers (GPUs). All figures were averaged over at least 5 independent runs of each method. Error bars indicate one standard error.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>1. We develop a (pseudo-)distance for neural network architectures called OTMANN (Optimal Transport Metrics for Architectures of Neural Networks) that can be computed efficiently via an optimal transport program. 2. We develop a BO framework for optimising functions on neural network architectures called NASBOT (Neural Architecture Search with Bayesian Optimisation and Optimal Transport). This includes an evolutionary algorithm to optimise the acquisition function.</figDesc><table /><note><ref type="bibr" target="#b2">3</ref>. Empirically, we demonstrate that NASBOT outperforms other baselines on model selection tasks for multi-layer perceptrons (MLP) and convolutional neural networks (CNN). Our python implementations of OTMANN and NASBOT are available at github.com/kirthevasank/nasbot.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>where</figDesc><table><row><cell>0: ip</cell><cell>0: ip</cell><cell></cell><cell></cell><cell>0: ip</cell></row><row><cell>(235)</cell><cell cols="2">(235)</cell><cell></cell><cell>(240)</cell></row><row><cell>1: conv3, 16</cell><cell cols="2">1: conv3, 16</cell><cell cols="2">1: conv7, 16</cell></row><row><cell>(16)</cell><cell>(16)</cell><cell></cell><cell></cell><cell>(16)</cell></row><row><cell>2: conv3, 16</cell><cell>2: conv3, 16</cell><cell></cell><cell>2: conv5, 32</cell><cell></cell><cell>4: conv3, 16</cell></row><row><cell>(256)</cell><cell>(256)</cell><cell></cell><cell>(512)</cell><cell></cell><cell>(256)</cell></row><row><cell>3: conv3, 32</cell><cell>4: conv3, 16</cell><cell>3: conv3, 16</cell><cell cols="2">3: conv3 /2, 16</cell><cell>7: max-pool, 1</cell></row><row><cell>(512)</cell><cell>(256)</cell><cell>(256)</cell><cell></cell><cell>(256)</cell><cell>(16)</cell></row><row><cell>4: conv5, 32</cell><cell cols="2">5: conv5, 32</cell><cell>5: avg-pool, 1</cell><cell></cell><cell>9: conv3, 16</cell></row><row><cell>(1024)</cell><cell cols="2">(1024)</cell><cell>(32)</cell><cell></cell><cell>(256)</cell></row><row><cell>5: max-pool, 1</cell><cell cols="2">6: max-pool, 1</cell><cell cols="2">6: max-pool, 1</cell><cell>11: max-pool, 1</cell></row><row><cell>(32)</cell><cell>(32)</cell><cell></cell><cell></cell><cell>(16)</cell><cell>(16)</cell></row><row><cell>6: fc, 16</cell><cell cols="2">7: fc, 16</cell><cell>8: fc, 16</cell><cell>12: fc, 16</cell></row><row><cell>(512)</cell><cell cols="2">(512)</cell><cell>(512)</cell><cell>(512)</cell></row><row><cell>7: softmax</cell><cell cols="2">8: softmax</cell><cell>10: softmax</cell><cell>13: softmax</cell></row><row><cell>(235)</cell><cell cols="2">(235)</cell><cell>(120)</cell><cell>(120)</cell></row><row><cell>8: op</cell><cell cols="2">9: op</cell><cell cols="2">14: op</cell></row><row><cell>(235)</cell><cell cols="2">(235)</cell><cell cols="2">(240)</cell></row><row><cell>(a)</cell><cell cols="2">(b)</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>An example label mismatch cost matrix M . There is zero cost for matching identical layers, &lt; 1 cost for similar layers, and infinite cost for disparate layers.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 ,</head><label>2</label><figDesc>might change the architecture either by</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="3">Blog Feedback, #workers = 2</cell><cell></cell><cell></cell><cell></cell><cell cols="4">Indoor Location, #workers = 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">Slice Localisation, #workers = 2</cell><cell>Naval Propulsion, #workers = 2</cell></row><row><cell></cell><cell></cell><cell>1.2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">0.25</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">1</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Cross Validation MSE</cell><cell>0.8 0.9 1 1.1</cell><cell></cell><cell></cell><cell></cell><cell>Cross Validation MSE</cell><cell cols="2">0.15 0.2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Cross Validation MSE</cell><cell>0.6 0.7 0.8 0.9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Cross Validation MSE</cell><cell>10 -2 10 -1</cell></row><row><cell></cell><cell></cell><cell>0.7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell></cell><cell>0</cell><cell>2</cell><cell>4</cell><cell></cell><cell>6</cell><cell>8</cell><cell></cell><cell></cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Time (hours)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Time (hours)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Time (hours)</cell><cell></cell><cell>Time (hours)</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="3">Protein, #workers = 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">News, #workers = 4</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0.98</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1.1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.17</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Cross Validation MSE</cell><cell cols="2">0.86 0.88 0.9 0.92 0.94 0.96</cell><cell></cell><cell></cell><cell></cell><cell cols="2">Cross Validation MSE</cell><cell>0.8 0.9 1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Cross Validation Error</cell><cell>0.13 0.14 0.15 0.16</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">0.84</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0.12</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell></cell><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell></cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell>10</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Time (hours)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Time (hours)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Time (hours)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>The first row gives the number of samples N and the dimensionality D of each dataset in the form (N, D). The subsequent rows show the regression MSE or classification error (lower is better) on the test set for each method. The last column is for Cifar10 where we took the best models found by each method in 24K iterations and trained it for 120K iterations. When we trained the VGG-19 architecture using our training procedure, we got test errors 0.1718 (60K iterations) and 0.1018 (150K iterations).</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="32" xml:id="foot_0">32nd Conference on Neural Information Processing Systems (NeurIPS 2018), Montréal, Canada.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1">A topological ordering is an ordering of the layers u1, . . . , u |L| such that u comes before v if (u, v) ∈ E.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2">ExperimentsMethods: We compare NASBOT to the following baselines. RAND: random search; EA (Evolutionary algorithm): the same EA procedure described above. TreeBO<ref type="bibr" target="#b14">[15]</ref>: a BO method which only searches over feed forward structures. Random search is a natural baseline to compare optimisation methods. However, unlike in Euclidean spaces, there is no natural way to randomly explore the space of architectures. Our RAND implementation, operates in exactly the same way as NASBOT, except that the EA procedure is fed a random sample from Unif(0, 1) instead of the GP acquisition each time it evaluates an architecture. Hence, RAND is effectively picking a random network from the same space explored by NASBOT; neither method has an unfair advantage because it considers a different space. While there are other methods for architecture search, their implementations are highly nontrivial and are not made available.Datasets: We use the following datasets: blog feedback<ref type="bibr" target="#b3">[4]</ref>, indoor location<ref type="bibr" target="#b45">[46]</ref>, slice localisation<ref type="bibr" target="#b10">[11]</ref>, naval propulsion<ref type="bibr" target="#b4">[5]</ref>, protein tertiary structure<ref type="bibr" target="#b33">[34]</ref>, news popularity<ref type="bibr" target="#b6">[7]</ref>, Cifar10<ref type="bibr" target="#b23">[24]</ref>. The first six are regression problems for which we use MLPs. The last is a classification task on images for which we use CNNs. Table3gives the size and dimensionality of each dataset. For the</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3">first 6 datasets, we use a 0.6 − 0.2 − 0.2 train-validation-test split and normalised the input and output to have zero mean and unit variance. Hence, a constant predictor will have a mean squared error of approximately 1. For Cifar10 we use 40K for training and 10K each for validation and testing.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknolwedgements</head><p>We would like to thank Guru Guruganesh and Dougal Sutherland for the insightful discussions. This research is partly funded by DOE grant DESC0011114, NSF grant IIS1563887, and the Darpa D3M program. KK is supported by a Facebook fellowship and a Siebel scholarship.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Otkrist</forename><surname>Gupta</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.02167</idno>
		<title level="m">Nikhil Naik, and Ramesh Raskar. Designing neural network architectures using reinforcement learning</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Making a science of model search: Hyperparameter optimization in hundreds of dimensions for vision architectures</title>
		<author>
			<persName><forename type="first">James</forename><surname>Bergstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Yamins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">Daniel</forename><surname>Cox</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A Tutorial on Bayesian Optimization of Expensive Cost Functions, with Application to Active User Modeling and Hierarchical Reinforcement Learning</title>
		<author>
			<persName><forename type="first">Eric</forename><surname>Brochu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vlad</forename><forename type="middle">M</forename><surname>Cora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nando</forename><surname>De Freitas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Feedback prediction for blogs</title>
		<author>
			<persName><forename type="first">Krisztian</forename><surname>Buza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data analysis, machine learning and knowledge discovery</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="145" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Machine learning approaches for improving condition-based maintenance of naval propulsion plants</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Coraddu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Oneto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aessandro</forename><surname>Ghio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Savio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Anguita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Figari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Institution of Mechanical Engineers</title>
				<meeting>the Institution of Mechanical Engineers</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">230</biblScope>
			<biblScope unit="page" from="136" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Adanet: Adaptive structural learning of artificial neural networks</title>
		<author>
			<persName><forename type="first">Corinna</forename><surname>Cortes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavi</forename><surname>Gonzalvo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vitaly</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mehryar</forename><surname>Mohri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Yang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1607.01097</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A proactive intelligent decision support system for predicting the popularity of online news</title>
		<author>
			<persName><forename type="first">Kelwin</forename><surname>Fernandes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Vinagre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paulo</forename><surname>Cortez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Portuguese Conference on Artificial Intelligence</title>
				<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Neuroevolution: from architectures to learning</title>
		<author>
			<persName><forename type="first">Dario</forename><surname>Floreano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Dürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Mattiussi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolutionary Intelligence</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="62" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A survey of graph edit distance</title>
		<author>
			<persName><forename type="first">Xinbo</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bing</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dacheng</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuelong</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Analysis and applications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="113" to="129" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dealing with asynchronicity in parallel gaussian process based global optimization</title>
		<author>
			<persName><forename type="first">David</forename><surname>Ginsbourger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janis</forename><surname>Janusevskis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rodolphe</forename><surname>Le Riche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ERCIM</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">2d image registration in ct images using radial image descriptors</title>
		<author>
			<persName><forename type="first">Franz</forename><surname>Graf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans-Peter</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Pölsterl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Cavallaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Medical Image Computing and Computer-Assisted Intervention</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="607" to="614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Deep residual learning for image recognition</title>
		<author>
			<persName><forename type="first">Kaiming</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaoqing</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE conference on computer vision and pattern recognition</title>
				<meeting>the IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="770" to="778" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Densely connected convolutional networks</title>
		<author>
			<persName><forename type="first">Gao</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhuang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kilian</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurens</forename><surname>Van Der Maaten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CVPR</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Sequential model-based optimization for general algorithm configuration</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Hutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Holger H Hoos</surname></persName>
		</author>
		<author>
			<persName><surname>Leyton-Brown</surname></persName>
		</author>
		<editor>LION</editor>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Bayesian optimization with tree-structured dependencies</title>
		<author>
			<persName><forename type="first">Rodolphe</forename><surname>Jenatton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cedric</forename><surname>Archambeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>González</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Contextual decision processes with low bellman rank are pac-learnable</title>
		<author>
			<persName><forename type="first">Nan</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Akshay</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alekh</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Langford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Schapire</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1610.09512</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Gaussian process bandit optimisation with multi-fidelity evaluations</title>
		<author>
			<persName><forename type="first">Kirthevasan</forename><surname>Kandasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Dasarathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Junier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Oliva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barnabás</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><surname>Póczos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="992" to="1000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">Kirthevasan</forename><surname>Kandasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Dasarathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Junier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Oliva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barnabas</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><surname>Poczos</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1603.06288</idno>
		<title level="m">Multifidelity gaussian process bandit optimisation</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The multi-fidelity multi-armed bandit</title>
		<author>
			<persName><forename type="first">Kirthevasan</forename><surname>Kandasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Dasarathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barnabas</forename><surname>Poczos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1777" to="1785" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Multi-fidelity Bayesian Optimisation with Continuous Approximations</title>
		<author>
			<persName><forename type="first">Kirthevasan</forename><surname>Kandasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Dasarathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barnabas</forename><surname>Poczos</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.06240</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Designing neural networks using genetic algorithms with graph generation system</title>
		<author>
			<persName><forename type="first">Hiroaki</forename><surname>Kitano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Complex systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="461" to="476" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Fast bayesian optimization of machine learning hyperparameters on large datasets</title>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Falkner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Bartels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Hennig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Hutter</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1605.07079</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Diffusion kernels on graphs and other discrete input spaces</title>
		<author>
			<persName><forename type="first">Imre</forename><surname>Risi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Kondor</surname></persName>
		</author>
		<author>
			<persName><surname>Lafferty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
				<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="315" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Learning multiple layers of features from tiny images</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">Chenxi</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barret</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathon</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Hua</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li-Jia</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Fei-Fei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Yuille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Murphy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1712.00559</idno>
		<title level="m">Progressive neural architecture search</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">Hanxiao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karen</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chrisantha</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koray</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.00436</idno>
		<title level="m">Hierarchical representations for efficient architecture search</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Visualizing data using t-sne</title>
		<author>
			<persName><forename type="first">Laurens</forename><surname>Van Der Maaten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of machine learning research</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="2579" to="2605" />
			<date type="published" when="2008-11">Nov. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Towards automatically-tuned neural networks</title>
		<author>
			<persName><forename type="first">Hector</forename><surname>Mendoza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Feurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jost</forename><surname>Tobias Springenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Hutter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Automatic Machine Learning</title>
				<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="58" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A new algorithm for error-tolerant subgraph isomorphism detection</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Horst</forename><surname>Messmer</surname></persName>
		</author>
		<author>
			<persName><surname>Bunke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="493" to="504" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">Jason</forename><surname>Risto Miikkulainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elliot</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Meyerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Rawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bala</forename><surname>Francon</surname></persName>
		</author>
		<author>
			<persName><surname>Raju</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.00548</idno>
		<title level="m">Arshak Navruzyan, Nigel Duffy, and Babak Hodjat. Evolving deep neural networks</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Bayesian approach to global optimization and application to multiobjective and constrained problems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Mockus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Mockus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Optimization Theory and Applications</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Deeparchitect: Automatically designing and training deep architectures</title>
		<author>
			<persName><forename type="first">Renato</forename><surname>Negrinho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoff</forename><surname>Gordon</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1704.08792</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Peyré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Cuturi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Computational Optimal Transport. Available online</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Physicochemical properties of protein tertiary structure data set</title>
		<author>
			<persName><forename type="first">Rana</forename><surname>Ps</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Gaussian Processes for Machine Learning. Adaptative computation and machine learning series</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Rasmussen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K I</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>University Press Group Limited</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Large-scale evolution of image classifiers</title>
		<author>
			<persName><forename type="first">Esteban</forename><surname>Real</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sherry</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Selle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saurabh</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yutaka</forename><surname>Leon Suematsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quoc</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Kurakin</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.01041</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">Karen</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Zisserman</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.1556</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Kernels and regularization on graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alexander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Risi</forename><surname>Smola</surname></persName>
		</author>
		<author>
			<persName><surname>Kondor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Learning theory and kernel machines</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="144" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Sparse gaussian processes using pseudo-inputs</title>
		<author>
			<persName><forename type="first">Edward</forename><surname>Snelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zoubin</forename><surname>Ghahramani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
				<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1257" to="1264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Practical Bayesian Optimization of Machine Learning Algorithms</title>
		<author>
			<persName><forename type="first">Jasper</forename><surname>Snoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugo</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
				<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Evolving neural networks through augmenting topologies</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kenneth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Risto</forename><surname>Stanley</surname></persName>
		</author>
		<author>
			<persName><surname>Miikkulainen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolutionary computation</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="99" to="127" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Scalable, Active and Flexible Learning on Distributions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dougal</surname></persName>
		</author>
		<author>
			<persName><surname>Sutherland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<pubPlace>Pittsburgh, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Reinforcement learning: An introduction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Richard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">G</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName><surname>Barto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>MIT press Cambridge</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Swersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Duvenaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jasper</forename><surname>Snoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Hutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Osborne</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1409.4011</idno>
		<title level="m">Raiders of the lost architecture: Kernels for bayesian optimization in conditional parameter spaces</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Going deeper with convolutions</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yangqing</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Sermanet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dragomir</forename><surname>Anguelov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dumitru</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Rabinovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE conference on computer vision and pattern recognition</title>
				<meeting>the IEEE conference on computer vision and pattern recognition</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Ujiindoorloc: A new multi-building and multi-floor database for wlan fingerprint-based indoor localization problems</title>
		<author>
			<persName><forename type="first">Joaquín</forename><surname>Torres-Sospedra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raúl</forename><surname>Montoliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adolfo</forename><surname>Martínez-Usó</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joan</forename><forename type="middle">P</forename><surname>Avariento</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tomás</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauri</forename><surname>Arnau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joaquín</forename><surname>Benedito-Bordonau</surname></persName>
		</author>
		<author>
			<persName><surname>Huerta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Indoor Positioning and Indoor Navigation (IPIN)</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m">International Conference on</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="261" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Optimal transport: old and new</title>
		<author>
			<persName><forename type="first">Cédric</forename><surname>Villani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Springer Science &amp; Business Media</publisher>
			<biblScope unit="volume">338</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Graph kernels</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vichy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicol</forename><forename type="middle">N</forename><surname>Vishwanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Risi</forename><surname>Schraudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karsten</forename><forename type="middle">M</forename><surname>Kondor</surname></persName>
		</author>
		<author>
			<persName><surname>Borgwardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1201" to="1242" />
			<date type="published" when="2010-04">Apr. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Graph distances using graph union</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Walter D Wallis</surname></persName>
		</author>
		<author>
			<persName><surname>Shoubridge</surname></persName>
		</author>
		<author>
			<persName><surname>Kraetz</surname></persName>
		</author>
		<author>
			<persName><surname>Ray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recognition Letters</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6-7</biblScope>
			<biblScope unit="page" from="701" to="704" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Kernel interpolation for scalable structured gaussian processes (kiss-gp</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Nickisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
				<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1775" to="1784" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Lingxi</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Yuille</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1703.01513</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Genetic cnn. arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<author>
			<persName><forename type="first">Zhao</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junjie</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cheng-Lin</forename><surname>Liu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1708.05552</idno>
		<title level="m">Practical network blocks design with q-learning</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<author>
			<persName><forename type="first">Barret</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName><surname>Le</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1611.01578</idno>
		<title level="m">Neural architecture search with reinforcement learning</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Learning transferable architectures for scalable image recognition</title>
		<author>
			<persName><forename type="first">Barret</forename><surname>Zoph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Vasudevan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathon</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Quoc V</forename><surname>Le</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1707.07012</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
