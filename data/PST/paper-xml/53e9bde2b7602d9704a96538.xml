<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Verifying Higher-Order Functional Programs with Pattern-Matching Algebraic Data Types</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">C.-H</forename><forename type="middle">Luke</forename><surname>Ong</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Oxford University Computing Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Steven</forename><forename type="middle">J</forename><surname>Ramsay</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Oxford University Computing Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Verifying Higher-Order Functional Programs with Pattern-Matching Algebraic Data Types</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D654B2E9466E19199F05810F8083A1BE</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D</term>
					<term>2</term>
					<term>4 [Software Engineering]: Software/Program Verification; F</term>
					<term>3</term>
					<term>1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs General Terms Languages, Verification</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Type-based model checking algorithms for higher-order recursion schemes have recently emerged as a promising approach to the verification of functional programs. We introduce pattern-matching recursion schemes (PMRS) as an accurate model of computation for functional programs that manipulate algebraic data-types. PMRS are a natural extension of higher-order recursion schemes that incorporate pattern-matching in the defining rules.</p><p>This paper is concerned with the following (undecidable) verification problem: given a correctness property ϕ, a functional program P (qua PMRS) and a regular input set I, does every term that is reachable from I under rewriting by P satisfy ϕ? To solve the PMRS verification problem, we present a sound semi-algorithm which is based on model-checking and counterexample guided abstraction refinement. Given a no-instance of the verification problem, the method is guaranteed to terminate.</p><p>From an order-n PMRS and an input set generated by a regular tree grammar, our method constructs an order-n weak PMRS which over-approximates only the first-order pattern-matching behaviour, whilst remaining completely faithful to the higher-order control flow. Using a variation of Kobayashi's type-based approach, we show that the (trivial automaton) model-checking problem for weak PMRS is decidable. When a violation of the property is detected in the abstraction which does not correspond to a violation in the model, the abstraction is automatically refined by 'unfolding' the pattern-matching rules in the program to give successively more and more accurate weak PMRS models.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In the past decade, huge strides have been made in the development of finite-state and pushdown model checking for software verification. Though highly effective when applied to first-order, imperative programs such as C, these techniques are much less useful for higher-order, functional programs. In contrast, the two standard A model of functional programs. Our first contribution is the introduction of pattern-matching recursion schemes, which are HORS extended with a notion of pattern matching. A PMRS is a kind of restricted term-rewriting system. We believe that PMRS have a very natural syntax into which large classes of functional programs can readily be translated. A typical rule, which is required to be well typed, has the shape:</p><formula xml:id="formula_0">F x 1 • • • xm p(y1, • • • , y k ) -→ t</formula><p>where the variables x 1, • • • , xm are (possibly higher-order) formal parameters of the non-terminal (or defined operator) F . The expression p(y 1, • • • , y k ), which takes the place of the final parameter, is a pattern constructed from terminal (or constructor) symbols and variables y 1, • • • , y k . The patterns in the second argument position are used both to decompose compound data structures (so as to select the required components), and to determine control flow. Selected components are communicated to the right-hand side of the chosen rule by means of binding to the variables in the pattern.</p><p>Remark 1. Our work is not the first to propose a pattern-matching extension to HORS. A recent paper by Kobayashi, Tabuchi and Unno <ref type="bibr" target="#b8">[9]</ref> introduces an extension of HORS called higher-order multi-parameter tree transducers (HMTT). HMTT model functions that may employ pattern matching but, in return, must satisfy a rigid type constraint. An HMTT function takes tree arguments of input sort i (which are trees that can only be destructed) and returns a tree of sort o (which are trees that can only be constructed). Pattern matching is only allowed on trees of sort i. Consequently HMTT functions are not compositional in the natural way. We believe our PMRS model to be both simpler and more natural.</p><p>A verification problem. This paper is concerned with the following verification problem. Given a correctness property ϕ, a functional program P (qua deterministic PMRS) and a regular set I of input (constructor) terms, does every term that is reachable from I under rewriting by P satisfy ϕ? It is straightforward to see that the problem is undecidable. The input set I is given by a regular tree grammar G (equivalently order-0 recursion scheme). The defining rules of G are:</p><formula xml:id="formula_1">S -→ ListN N -→ z N -→ s N ListN -→ nil ListN -→ cons N ListN</formula><p>As usual, the start symbol of G is taken to be S. The correctness property ϕ is: "any outcome of the program is a list containing no zeros". This is easily expressible as a trivial automaton A, whose definition is omitted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An algorithmic solution.</head><p>Our second contribution is a sound but incomplete semi-algorithm for solving the problem, which is based on a counterexample-guided abstraction refinement loop <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>The input to the algorithm consists of a PMRS P representing the program, a regular tree grammar G (equivalently an order-0 recursion scheme) representing the set I of possible inputs to the program and a trivial tree automaton A (which is to say, an automaton on infinite trees with a trivial acceptance condition) representing a specification ϕ of good behaviour. The algorithm proceeds according to the diagram in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>In step <ref type="bibr" target="#b0">(1)</ref> we compute a sound abstraction of the behaviour of P when started from terms in I. From an order-n PMRS P and an order-0 recursion scheme G, we build an order-n weak patternmatching recursion scheme (wPMRS) which over-approximates the set of terms that are reachable from I under rewriting by P. A wPMRS is similar to a PMRS, except that its pattern matching mechanism is only able to determine control flow; it is unable to decompose data structure.</p><p>Our method is a kind of flow analysis. The first -and key -stage of the algorithm is a binding analysis which is inspired by Jones and Andersen <ref type="bibr" target="#b4">[5]</ref>. It performs a fixpoint construction of a finite set Ξ of variable-term bindings such that, for every variable x (formal parameter of rewrite rule), every term that is ever bound to x during the computation is derivable from Ξ. In the second stage, we use the fixpoint set Ξ to build rules of the over-approximating wPMRS. These rules model the bindings of all non-pattern-matching (including all higher-order) variables precisely; they only approximate the binding behaviours of the pattern-matching variables. This is in contrast to Jones and Andersen's algorithm, which builds a regular tree grammar that over-approximates the binding set of every variable. For an order-n PMRS, our algorithm produces an ordern wPMRS f P G as an abstraction, which is a tighter approximation of the order-n PMRS being analysed than regular tree grammars (which are equivalent to order-0 wPMRS). To our knowledge, our algorithm gives the most accurate reachability / flow analysis of its kind.</p><p>The weakened pattern-matching mechanism of wPMRS makes it possible to decide a model checking problem for it, which is the content of step <ref type="bibr" target="#b1">(2)</ref>. Given a wPMRS W, a closed term t and a Büchi automaton with a trivial acceptance condition A, we decide if every (possibly infinite) tree generated by W on input t is accepted by A. The proof uses a variation of Kobayashi's type-based approach.</p><p>If the model-checker fails to find any violation of the property then, since the approximating wPMRS f P G defines a superset of the terms reachable under P from I, the loop in Figure <ref type="figure" target="#fig_0">1</ref> will terminate because P satisfies A on I. However, if the model-checker reports a counterexample, then it may be that P also violates the property (for some term in I), but it may also be that the counterexample is an artifact of an inaccuracy in the abstraction. To determine which of these possibilities is the case, in step (3) we analyse the nondeterminism introduced in the abstraction to see whether, in this particular counterexample, it behaves well or behaves badly.</p><p>In step (4) the abstraction process is refined. Due to the fact that the abstractions only ever approximate the (first-order) pattern matching variables, whilst remaining faithful to all the others, there is a simple notion of automatic abstraction-refinement, whereby patterns are "unfolded" to a certain depth in the PMRS P, forming a new PMRS P . In the abstraction f P G of P , the rules that define the approximation will be more accurate and, in particular, the spurious counterexample will no longer be present. Since any rule in a wPMRS abstraction f P G is perfectly accurate whenever the pattern parameter contains no free variables, this method of unfolding gives rise to a semi-completeness property. Given any no-instance of the PMRS verification problem, the loop in Figure <ref type="figure" target="#fig_0">1</ref> will eventually terminate with the answer "No".</p><p>Returning to Example 2, whilst performing step (1) we obtain an over-approximation of the binding behaviour of the variables in the program Ξ. This fixpoint set contains, amongst others, the bindings: x → N and xs → ListN . From this set, we construct an approximating wPMRS f P G , whose rule-set contains the following:</p><formula xml:id="formula_2">Filter p nil -→ Nil Filter p (cons x xs) -→ If (Cons X (Filter p XS)) (Filter p XS) (p X) X -→ N XS -→ ListN</formula><p>together with, amongst others, all the P and G rules in Example 2 except those for Filter . Unfortunately the wPMRS is too coarse to be useful: there are trees (representing lists) that are obtained by rewriting from 'Main S' that are not accepted by the trivial automaton A. However, these are spurious counterexamples. For an illustration, consider the error trace in the wPMRS:</p><formula xml:id="formula_3">Main S → * Main (cons (s z) nil) → * Filter Nz (cons (s z) nil) → If (Cons X (Filter Nz XS )) (Filter Nz XS ) (Nz X ) → * If (cons z (Filter Nz nil)) (Filter Nz XS ) (Nz (s z)) → * cons z (Filter Nz nil) → * cons z nil</formula><p>The problem can be traced to the second clause of Filter in the wPMRS: when replacing the variable x by the non-terminal X, the connection between the two occurrences of x in the RHS is lost, as the reduction of one occurrence of X is independent of that of the other. The refinement algorithm produces a new, unfolded PMRS P that replaces the two defining rules of Filter by five new rules. The two rules that cover the case when the list is a singleton are shown below:</p><formula xml:id="formula_4">Filter p (cons z nil) -→ If (cons z (Filter p nil)) (Filter p nil) (p z) Filter p (cons (s v2) nil) -→ If (cons (s v2) (Filter p nil)) (Filter p nil) (p (s v2))</formula><p>Applying the approximation algorithm to PMRS P (and input grammar G), we obtain a wPMRS f P G that does accurately capture the set of reachable terms.</p><formula xml:id="formula_5">(VAR) Γ, x : σ x : σ ξ : σ ∈ Σ ∪ N (CONST) Γ ξ : σ Γ t 0 : σ → τ Γ t1 : σ (APP)</formula><p>Γ t0 t1 : τ Figure <ref type="figure" target="#fig_1">2</ref>. A simple type system for applicative terms.</p><p>Outline. The rest of the paper is organised as follows. Section 2 introduces PMRS, wPMRS and other technical preliminaries. In Section 3, the abstraction algorithm, which takes a program (PMRS) and an input set (order-0 recursion scheme) and returns a wPMRS, is presented; termination and soundness of the approximation are proved. Section 4 presents a type-inference algorithm for deciding if every tree generated by a given wPMRS is accepted by a trivial automaton. The abstraction refinement algorithm is the topic of Section 5. Finally Section 6 presents related work. Note: a long version of the paper is available <ref type="bibr" target="#b14">[15]</ref>, which contains the proofs and additional material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>We introduce PMRS, a model for functional programs manipulating algebraic data types; wPMRS, a restriction of PMRS with good algorithmic properties and the PMRS Verification Problem, whose solution is the subject of the remainder of this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Types, terms and substitutions</head><p>Fix a finite set (b, o ∈) B of base types. The simple types (σ, τ ∈) S are those expressions that can be constructed from the base types using the arrow:</p><formula xml:id="formula_6">σ, τ ::= b | σ → τ.</formula><p>We adopt the usual convention that arrows associate to the right and omit parenthesis accordingly. The order of a type τ , denoted ord(τ ), is a measure of the nestedness of the arrow constructor on the left; it is defined by ord(b) = 0 and ord(σ → τ ) = max{ord(σ) + 1, ord(τ )}.</p><p>Applicative terms. Fix a finite, simply-typed alphabet (f, g, a ∈) Σ of first-order terminal symbols (or constructors), a finite, simplytyped alphabet (F, G, H ∈) N of (arbitrary-order) non-terminal symbols (or defined operators) and a denumerable set (x, y, z ∈) V of variables.</p><p>• The constructor terms T (Σ) are those expressions that can be built from terminals using application. • The closed terms T (Σ, N ) are those expressions that can be built from terminals and non-terminals using application. • The patterns are those expressions p, q of base type that can be built from variables of base type and terminals. • The applicative terms T (Σ, N , V) are those expressions that can be built from terminals, non-terminals and variables using application.</p><p>We denote the free variables of a term t by FV(t).</p><p>Standardly, applicative terms may be assigned simple types via a formal system of typing judgements, Γ s : τ (where Γ is a finite set of type bindings) defined by the rules in Figure <ref type="figure" target="#fig_1">2</ref>. When an applicative term t can be assigned a simple type τ 1 → • • • → τ m → b we say that it has arity m and write ar(t) = m. Henceforth, by term we shall mean well-typed, applicative term.</p><p>Labelled trees. Given a ranked alphabet Ω, an Ω-labelled tree t is a map from { 1, • • • , m } * to Ω, where m is the largest arity of symbols in Ω, such that dom(t) is prefix-closed, and if t</p><formula xml:id="formula_7">(x) = f then { i | x i ∈ dom(t) } = { 1, • • • , ar(f ) }.</formula><p>Standardly we identify T (Σ) with finite Σ-labelled trees, and write T ∞ (Σ) for the collection of (possibly infinite) Σ-labelled trees.</p><p>Let Σ ⊥ be Σ ∪ { ⊥ } with ar(⊥) = 0. Given a closed term t, we write t ⊥ for the finite, Σ ⊥ -labelled tree defined by recursion as follows: for m ≥ 0</p><formula xml:id="formula_8">(ξ s 1 • • • sm) ⊥ := ( ⊥ if ξ = F ∈ N f s ⊥ 1 • • • s ⊥ m otherwise ξ = f ∈ Σ E.g. (f (g(G a))b) ⊥ = f (g ⊥)b.</formula><p>Σ ⊥ -labelled trees can be endowed with a natural complete partial order in which, for all trees t, ⊥ t and</p><formula xml:id="formula_9">f s 1 • • • sm f t1 • • • tm iff for all i, s i ti.</formula><p>Substitutions. A substitution is just a partial function θ in V → T (Σ, N , V). By convention, we do not distinguish between a substitution and its homomorphic extension to the free algebra T (Σ, N , V) and we will write the application of both using prefix juxtaposition. A term t is said to match a term u precisely when there exists a substitution θ such that t = θu. We shall say that a substitution θ is closed whenever every term in its image is closed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Pattern-matching recursion scheme (PMRS)</head><p>A pattern-matching recursion scheme (PMRS) is a quadruple P = Σ, N , R, Main with Σ and N as above. R is a finite set of rewrite rules, each of which is one of the following shapes (m ≥ 0):</p><formula xml:id="formula_10">(pure) F x 1 • • • xm -→ t (pattern-matching) F x1 • • • xm p -→ t</formula><p>where p is a pattern (which may be trivial). Main : b → o is a distinguished non-terminal symbol whose defining rules are always pattern-matching rules. In this paper we will assume that the variables appearing as formal parameters to defining rules in a PMRS will always be distinct.</p><formula xml:id="formula_11">A pure rule F x 1 • • • xm -→ t is well-typed when F : τ1 → • • • → τ m → o ∈ N</formula><p>and the judgement: are provable. We say that a PMRS is well-typed just when each of its rules is well-typed. We will only consider well-typed PMRS in the following. We define the order of a PMRS to be the maximum order of (the type of) any of the non-terminal symbols in N . Since a pure rule can be simulated by a pattern-matching rule with a trivial pattern (e.g. a nullary terminal of a distinguished base type), we shall sometimes find it convenient to treat all PMRS rules as patternmatching rules.</p><formula xml:id="formula_12">x 1 : τ1, . . . , xm : τm t : o is provable. A pattern-matching rule F x 1 • • • xm p -→ t is well-typed when F : τ 1 → • • • → τm → b → o ∈ N</formula><p>Reduction. We associate with each PMRS a notion of reduction as follows. A redex is a term of the form</p><formula xml:id="formula_13">F θx 1 • • • θxm θp whenever θ is a closed substitution and F x 1 • • • xm p -→ t is a rule in P. The contractum of the redex is θ t. We define the one-step reduction relation, ⇒ ⊆ T (Σ, N ) × T (Σ, N ), by C[s] ⇒ C[t]</formula><p>whenever s is a redex, t is its contractum and C is a one-hole context.</p><p>We say that a PMRS is deterministic just if, given some redex</p><formula xml:id="formula_14">F s 1 • • • sn there is exactly one rule l -→ r ∈ R such that F s 1 • • • sn = θl for some θ.</formula><p>Given a PMRS P = Σ, N , R, Main , let s ∈ T (Σ, N ) be a closed term of base type. We write L(P, s) to mean the language of Σ ⊥ -labelled trees obtained by infinitary rewriting of the term s. More precisely, define L(P, s) as the collection of Σ ⊥labelled trees t such that there are t i i∈ω with s ⇒ t1 ⇒ t2 ⇒ t 3 • • • a fair reduction sequence (in the sense that for each i, every outermost redex in t i is eventually contracted) and</p><formula xml:id="formula_15">t = F { t ⊥ i | i ∈ ω }.</formula><p>In case P is a deterministic PMRS, L(P, s) is a singleton set; we write the unique Σ ⊥ -labelled tree as</p><formula xml:id="formula_16">[[s]] P . Example 3. Let Σ = {zero : nat, succ : nat → nat, nil : natlist, cons : nat → natlist → natlist} and N = {Rev : natlist → natlist, RevA : natlist → natlist → natlist}.</formula><p>The following deterministic, order-1 PMRS contains rewrite rules that implement list reversal with an accumulating parameter:</p><formula xml:id="formula_17">Main zs -→ RevA nil zs RevA xs nil -→ xs RevA xs (cons y ys) -→ RevA (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>cons y xs) ys</head><p>When started from the term t = cons z nil, the only possible reduction sequence is:</p><formula xml:id="formula_18">Main t ⇒ RevA nil t ⇒ RevA t nil ⇒ t</formula><p>and hence [[M ain t]] P = t, as expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Weak pattern matching recursion schemes (wPMRS)</head><p>A weak pattern-matching recursion scheme (wPMRS) is a quadruple W = Σ, N , R, Main with Σ, N and Main as for PMRS. The (finite) set R consists of rewrite rules of the shape (m ≥ 0):</p><formula xml:id="formula_19">(pure) F x 1 • • • xm -→ t (weak-matching) F x1 • • • xm p -→ t in which FV(p) ∩ FV(t) = ∅.</formula><p>A pure rule is well typed according to the same criteria as for pure PMRS rules. A weak-matching rule are provable (note that none of the pattern-matching variables y j occurs in t). Henceforth we will only consider wPMRS with welltyped rules. wPMRS have exactly the same notion of reduction as PMRS: a redex is a term of the form</p><formula xml:id="formula_20">F x 1 • • • xm p -→ t is well-typed just when F : τ1 → • • • → τ m → b → o ∈ N</formula><formula xml:id="formula_21">F θx 1 • • • θxm θp whenever θ is a substitution and F x 1 • • • xm p -→ t is a rule in P. The contractum of the redex is θ t = t[θ x 1/x1] • • • [θ xm/xm]</formula><p>(as the pattern-matching variables do not occur in t). The one-step reduction relation, →, is defined as for PMRS.</p><p>We define the order, determinism and language of a wPMRS analogously with PMRS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">A verification problem</head><p>We are interested in solving the following verification problem. Given a program in the form of a PMRS P, a regular set I of "input" terms, and a correctness property ϕ, does the output [[Main t]] of the program 'Main t' satisfy ϕ, for every input t ∈ I? To propose a solution, we require two further stipulations, both of which concern the representation of the entities involved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Higher-order recursion schemes.</head><p>A higher-order recursion scheme (HORS) is a quadruple G = Σ, N , R, S with Σ and N as before and R is a finite set of well-typed, pure wPMRS rewrite rules. The component S is a distinguished non-terminal called the "start symbol". The reduction relation for HORS, →, is just that of wPMRS, noting that all redexes will necessarily be of the form F θx 1 • • • θxm since there are no pattern-matching arguments. We can associate with a recursion scheme G its language L(G) of terms in T (Σ) that can be derived from the start symbol S by rewriting away all occurrences of non-terminals. More precisely, we make the following definition:</p><formula xml:id="formula_22">L(G) := { t | S → * t, t ∈ T (Σ) }</formula><p>We define the order of a recursion scheme analogously with PMRS and wPMRS. Note that (as generators of finite ranked trees) order-0 recursion schemes are equivalent to regular tree grammars.</p><p>Trivial automata. Let Σ be as before. A Büchi tree automaton with a trivial acceptance condition (or simply, trivial automaton) is a quadruple A = Σ, Q, Δ, q 0 where Σ is as before, Q is a finite set of states, q 0 ∈ Q is the initial state, and Δ, the transition relation, is a subset of Q×Σ×Q * such that if (q, f, q1</p><formula xml:id="formula_23">• • • qn) ∈ Δ then n = ar(f ). A Σ-labelled tree t is accepted by A if there is a Q-labelled tree r such that (i) dom(t) = dom(r), (ii) for every x ∈ dom(r), (r(x), t(x), r(x 1) • • • r(x m)) ∈ Δ</formula><p>where m = ar(t(x)).</p><p>The tree r is called a run-tree of A over t. We write L(A) for the set of Σ-labelled trees accepted by A.</p><p>The PMRS Verification Problem. Given a deterministic PMRS P = Σ, N P , RP , Main , a (non-deterministic) order-0 recursion scheme G = Σ, N G , RG, S , and a Büchi tree automaton with a trivial acceptance condition A = Σ, Q, Δ, q 0 , we write:</p><formula xml:id="formula_24">(P, G, A) iff ∀t ∈ L(G) • [[Main t]] P ∈ L(A)</formula><p>The PMRS Verification Problem is to decide the truth of (P, G, A).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Constructing an abstraction</head><p>In this section we will present an algorithm which, given an ordern deterministic PMRS P and an order-0 recursion scheme G, constructs an order-n wPMRS f P G whose language of Σ-labelled trees is an over-approximation of the set of Σ-labelled trees reachable from L(G) under rewriting by P.</p><p>At the heart of the algorithm is an analysis of the composite PMRS P G := Σ, NG ∪ NP , RG ∪ RP , Main . Since every term s reachable from L(G) under rewriting by P (i.e. Main t ⇒ * P s, for some t ∈ L(G)) is certainly reachable from S under rewriting by P G (i.e. Main S ⇒ * P G Main t ⇒ * P G s), it suffices to look only at the behaviours of P G in order to construct a safe abstraction of those of P. We detail the nature of this analysis and its properties separately before showing how it underlies the construction of the approximating wPMRS f PG. Some nomenclature. A simple term is a subterm of the RHS of a P G -rule or is the "starting term" Main S . A compound term has the shape ξ t 1 • • • tm with m ≥ 0, where the head symbol ξ is either a variable, or a terminal, or a non-terminal, and each t i is simple. It follows from the definition that a simple term is compound, but the converse is not true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Binding analysis</head><p>In a PMRS, the pattern matching rules use pattern matching both to determine control flow (by selecting which of a number of defining rules is used to reduce a redex) as well as to decompose compound data structure (by binding components to variables in the pattern that then occur on the RHS of the rule). However, the weak pattern matching mechanism in a wPMRS exhibits only the former capability: although patterns are matched, since there are no pattern-matching variables on the RHS of defining rules, data structures cannot be decomposed. Therefore, to build an effective abstraction of a PMRS requires some knowledge of the substitutions that can occur in redex/contractum pairs during PMRS reduction.</p><p>To this end, we define a binding analysis, which determines a (finitary) over-approximation Ξ to the set of variable-term bindings</p><formula xml:id="formula_25">S { θ | Main S ⇒ * C[F θx1 • • • θxm θp] ⇒ C[θt] } which</formula><p>occur in redex/contractum substitutions θ arising in P G -reductions from 'Main S'. The analysis is based on the observation that every such redex is either 'Main S', or arises as an instance of a simple term. It proceeds by an iterative process in which bindings, by which instances of simple terms can be derived, give rise to redexes which in turn give rise, via contraction, to more bindings, until the desired set Ξ is reached in the limit.</p><p>Before we give the details of the analysis, let us make precise what it means for a set of bindings S to give rise to an instance of a term. Given such a set S, we define the relation s S t, which is a subset of T (Σ, N , V) × T (Σ, N ), inductively, by the system RS:</p><formula xml:id="formula_26">(R) t S t (S) If x → s ∈ S and C[s] S t, then C[x] S t</formula><p>where C ranges over one-hole contexts. We say that an instance of rule (S) is a head-instance just if the hole in C[ ] occurs in head position.</p><formula xml:id="formula_27">Example 4. Let S 1 = {x → y b, x → N , y → f z, z → a}.</formula><p>Then, using the system RS, it is possible to derive:</p><formula xml:id="formula_28">F x z S 1 F (f a b) a and F x z S 1 F N a</formula><p>Note that the form of rule (S) does not constrain bindings to be used consistently within non-linear terms. Let S 2 = {x → f y z, y → z, y → a, z → b}. Then we have, for example:</p><formula xml:id="formula_29">F x (G x) S 2 F (f a b) (G (f b b))</formula><p>in which the binding y → a has been used in the derivation of the first argument of F whereas y → z has been used in the derivation of the second argument.</p><p>To ensure that the analysis is computable, we cannot afford to work with instances of simple terms directly. We instead work with terms in which bindings have been applied only where strictly necessary in order to uncover new redexes. The construction of such terms is the purpose of the function head.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The head function.</head><p>Given a set S of bindings, we define the head function, head S : T (Σ, N , V) -→ 2 T (Σ,N ,V) given by:</p><formula xml:id="formula_30">head S (ξ t1 • • • tm) = { δ t1 • • • tm | δ ∈ hsS (ξ, ∅) }</formula><p>where hs S is an auxiliary function defined by the following:</p><formula xml:id="formula_31">hsS (k, X) = {k} (whenever k ∈ Σ ∪ N ) hsS (x, X) = if x ∈ X then ∅ else { δ t1 • • • tm | x → ζ t1 • • • tm ∈ S, δ ∈ hsS (ζ, X ∪ {x}) }</formula><p>Thus head S (u) is the set of terms that are obtainable from u by iteratively replacing the head symbol-provided it is a variableby a term bound to it in S. The second argument of hs S disregards any cyclic chain of bindings. For example, let</p><formula xml:id="formula_32">S = { x → y, y → x }, then: head S (x) = hsS (x, ∅) = hsS (y, { x }) = hs S (x, { x, y }) = ∅ Example 5.</formula><p>Let S 1 and S2 be as in Example 4. Then:</p><formula xml:id="formula_33">headS 1 (x c) = { N c, f z b c } headS 2 (x c) = {f y z c} headS 2 (F x (G x)) = {F x (G x)}</formula><p>Notice that since head performs variable-substitutions according to bindings from S, its behaviour is consistent with a strategy for constructing initial prefixes of derivations in the system RS. Each use of the recursive clause of hs S corresponds to a headinstance of rule (S). A consequence of this relationship is made precise by the following lemma.</p><formula xml:id="formula_34">Lemma 1. If u S ξ v1 • • • vm then there is a compound term ξ u 1 • • • um ∈ headS (u) and, for all 1 ≤ i ≤ m, ui S vi.</formula><p>One final property to note about head is that, whenever its argument is compound and all the variables in S are bound to simple terms, the terms in (sets in) its image are all compound. This is due to the fact that, in this case, the action of the head function is to construct new, compound terms by prepending old, simple terms into head position. This limited behaviour of the head-function will contribute towards guaranteeing the termination of the analysis. Lemma 2. We say that a set of bindings S is image-simple just if every term in the image of S is simple. Suppose S is image-simple. If u is compound, then every term in head S (u) is compound.</p><p>The goal of the analysis is to discover the possible redexes F θx 1 • • • θxm θp that occur during reduction sequences of PG starting from Main S . The head function headS (u) is able to determine, in a way that is computable, when an F -redex is an instance (according to S) of a simple term u. In this case, according to Lemma 1, a term of the shape F t 1 • • • tm s is an element of head S (u). However, to know which defining rule of F is triggered, it is necessary to find out which patterns are matched by residuals of instances of s.</p><p>The approximate reduction. To this end, we introduce a new notion of reduction S ⊆ T (Σ, N , V) × T (Σ, N , V) parametrised by a set of bindings S. This reduction approximates the usual PMRS reduction by performing redex/contractum substitutions only where absolutely necessary and only when the relevant bindings are contained in S. A S -redex is a term of the form F θx 1 • • • θxm θp whenever there is a PG 0 -rule of the form F x 1 • • • xm p -→ t and θ is a substitution (not necessarily closed). The contractum of the redex is t, no substitution is performed upon contraction.</p><p>We define the one step reduction S by the following rules. Let C range over one-hole contexts.</p><p>(s, t) a -redex/contractum pair</p><formula xml:id="formula_35">C[s] S C[t] t ∈ headS (x t1 • • • tm) C[x t1 • • • tm] S C[t]</formula><p>As is standard, we write * S to mean the reflexive, transitive closure of S , and n S to mean a n-long chain of S . Example 6. Consider the composite PMRS PG constructed from the PMRS and grammar given in Example 2 and let S contain the bindings p → Nz and x → N . Then the following:</p><formula xml:id="formula_36">p x S Nz x S Nz N S Nz (s N ) S true</formula><p>is a S -reduction. Observe how, as demonstrated by the third step, approximate reduction is accurate for order-0 G-rules.</p><p>Given a substitution θ and a pattern p, we say that a Sreduction s i S θp is minimal just if it is not the case that there exist j &lt; i and substitution θ such that s j S θ p. Consider the two rules defining S -reduction. In the RHS of the conclusion of each rule is the term t. In both cases, assuming S is image simple, t is a compound term. Since there are only finitely many such terms t and since there are only finitely many patterns (drawn from the PMRS) p, the problem of finding such minimal reductions is computable. Lemma 3. Assume S is image-simple. Given a compound term s and a pattern p drawn from the defining rules of P G , the problem of finding a substitution θ and a minimal reduction s * S θp is computable.</p><p>The fixpoint construction. Let S be a set of bindings. We define F(S) as the least set X of bindings that contains S and is closed under</p><formula xml:id="formula_37">Rule C: if (i) u is simple term of base type, (ii) F t 1 • • • tm s ∈ headS (u), (iii) F x1 • • • xm p -→ t is a PG 0 -rule, (iv) there is a minimal reduction s * S θ p then θ ∪ { x i → ti | 1 ≤ i ≤ m } ⊆ X.</formula><p>Thus F : 2 V×T (Σ,N ,V) -→ 2 V×T (Σ,N ,V) is, by construction, a monotone (endo)function on the complete lattice 2 V×T (Σ,N ,V) ordered by subset-inclusion. By the Tarski-Knaster Fixpoint Theorem, the least fixpoint of F, which we shall denote Ξ, exists, and is constructable as the supremum of the chain</p><formula xml:id="formula_38">∅ ⊆ F ∅ ⊆ F(F ∅) ⊆ F(F(F ∅)) ⊆ • • • Example 7.</formula><p>Consider again the composite PMRS P G composed from the PMRS P and tree grammar G given in Example 2. We shall apply the fixpoint construction to this structure.</p><p>Initially, the only fruitful choice of simple term is the "starting term" Main S which otherwise trivially satisfies the premises of Rule C and yields the single binding m → S. Subsequently, taking u = Filter Nz m matches both the defining rules for Filter after approximate-reductions of: Though the complete lattice 2 V×T (Σ,N ,V) is infinite, the least fixpoint Ξ is finitely constructable (i.e. the closure ordinal of F is finite); it is in fact a finite set. Observe that, in Example 7, the form of every binding in the fixpoint is v → t in which t is a simple term. This is the key to showing the convergence of the analysis. Since every term F t 1 • • • tm s ∈ headS (u) is compound (whenever S is image-simple and u is compound) so every binding x i → ti is image-simple. Since, whenever S is image-simple, every Scontractum is compound, so the bindings due to θp are imagesimple. Since there are only finitely many simple terms, termination follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Termination). The least fixpoint of F, Ξ, is a finite set.</head><p>To see that this finite set of bindings Ξ is sufficient to describe all the all the substitutions that occur during redex contractions in reduction sequences of P G starting from Main S , one should first notice that the approximate reduction, when instantiated with the fixpoint, acts on simple terms in a way which is consistent with the way PMRS reduction acts on their instances in a trivial context. To lift this fact to the level of arbitrary reduction sequences starting from Main S , it is enough to observe that any redex in such a sequence (apart from the first), can be seen either to be itself a simple term or to arise as a subterm of some previous contractum, regardless of the context in which the redex occurs. As a consequence of Lemma 4, the variable-term bindings necessary to derive the redex as an instance of the corresponding simple term will already be contained in the fixpoint. Hence, if the reduction sequence reaches any contractum, the fixpoint will contain the bindings necessary to reconstruct the substitution associated with the contraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma</head><formula xml:id="formula_39">Lemma 5. Assume θt is a contractum. If Main S ⇒ + C[θt] is a P G -reduction sequence then t Ξ θt.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Construction of the over-approximating wPMRS</head><p>We are now ready to define the wPMRS which is an abstraction of the composite PMRS P G = Σ, N , R, Main . Let Ξ be the fixpoint set of bindings and let</p><formula xml:id="formula_40">N V = { Vx | x ∈ V } and NΣ = { K a | a ∈ Σ }</formula><p>be two sets of fresh non-terminal symbols which we call pattern-symbols and accounting-symbols respectively. We define the approximating wPMRS:</p><formula xml:id="formula_41">f PG := Σ, N ∪ NV ∪ NΣ, R , Main</formula><p>where R consists of the following three kinds of rules:</p><p>I. Weak pattern-matching rules. For each (pure or patternmatching)</p><formula xml:id="formula_42">P G -rule F x1 • • • xm p -→ t, R contains the following rule: F x1 • • • xm p -→ t † II. Instantiation rules. For each binding x → t in Ξ where FV(t † ) = { x1, • • • , x l }, R contains the following rule: Vx z1 • • • z ar(x) -→ (t † [Vx 1 /x1] • • • [Vx l /x l ]) z1 • • • z ar(x)</formula><p>where each zi is a fresh variable of the appropriate types.</p><p>III. Accounting rules. For each terminal symbol a : b1 → • • • → bn → o in Σ, R contains the following rule:</p><formula xml:id="formula_43">K a z1 • • • zn -→ a z1 • • • zn</formula><p>where each zi is a fresh variable of type bi.</p><p>where we have written t † to denote the term t in which every occurrence of a pattern matching variable y ∈ FV(p) has been replaced by the corresponding pattern-symbol V y and every occurrence of a terminal symbol a has been replaced by the corresponding accounting-symbol K a.</p><p>Example 8. Consider the following order-2 PMRS, whose defining rules are given by:</p><formula xml:id="formula_44">Main m -→ Map2 KZero KOne m Map2 ϕ ψ nil -→ nil Map2 ϕ ψ (cons x xs) -→ cons (ϕ x) (Map2 ψ ϕ xs) KZero x 1 -→ 0 KOne x2 -→ 1</formula><p>and input grammar G consisting of two rules:</p><formula xml:id="formula_45">S -→ nil | cons 0 S</formula><p>The function Map2 behaves like the standard Map function, except that it swaps the first two function arguments as it filters through the successive elements of the list argument. The reachable constructor terms are finite lists that are prefixes of</p><formula xml:id="formula_46">[0 1 0 1 0 1 • • • ].</formula><p>After applying the fixpoint construction to this example, the set of bindings Ξ consists of the following:</p><formula xml:id="formula_47">m → S ϕ → KZero ϕ → ψ x → 0 ψ → KOne ψ → ϕ x 1 → x x2 → x x s → S</formula><p>and hence the approximating wPMRS f P G is as follows.</p><formula xml:id="formula_48">Main m -→ Map2 KZero KOne M Map2 ϕ ψ nil -→ Nil Map2 ϕ ψ (cons x xs) -→ Cons (ϕ X ) (Map2 ψ ϕ XS ) KZero x 1 -→ Zero KOne x2 -→ One M -→ S X -→ Zero XS -→ S S -→ Nil | Cons Zero S Zero -→ 0 One -→ 1 Nil -→ nil Cons v 1 v2 -→ cons v1 v2</formula><p>Since ϕ, ψ, x1 and x2 are not pattern-matched variables, the rules for V ϕ, V ψ , Vx 1 and Vx 2 are, in this case, never used and so play no part in the approximation process: they have been omitted. It is easy to see that the constructor terms in L( f PG, Main S) are exactly the finite prefixes of [0 1 0 1 • • • ] i.e. the approximation is exact in this case.</p><p>Given any P G -reduction Main S ⇒ + t, the reduction can be faithfully simulated in the abstraction f PG using the weak pattern-matching rules and the instantiation rules. Whenever the P G -reduction contracts a P-rule which binds data θy to a pattern matching variable y, the simulation can contract the corresponding redex using a weak pattern-matching rule and, by Lemma 5, can then reconstruct the bound data θy from V y using the instantiation rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 (Soundness). Let the composite PMRS PG and the approximating wPMRS f</head><p>PG be as before. Then L(PG, Main S) ⊆ L( f PG, Main S).</p><p>The third class of rules is not essential to the achieving soundness. The purpose of the accounting rules is to enforce a strict correspondence between the length of a f PG reduction sequence and the maximum size of any constructor term created within it. This eases the justification of the semi-completeness property of refinement in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Model checking by type inference</head><p>In this section, we exhibit an algorithm to decide the wPMRS Model Checking Problem: given a non-deterministic wPMRS W = Σ, N , R, M ain in which Main : b → o, a closed term t : b and a trivial automaton A, is L(W, Main t) ⊆ L(A)? Following work by Kobayashi <ref type="bibr" target="#b5">[6]</ref> and Kobayashi and Ong <ref type="bibr" target="#b7">[8]</ref>, we characterise the model checking problem as a type inference problem in a particular, finitary intersection type system induced by the automaton.</p><p>Eliminating non-determinism. The first step we take is to simplify the problem at hand by eliminating the non-determinism in W. To this end we construct a new wPMRS W # in which multiple defining rules for a given non-terminal are collapsed using a family B := { br b | b ∈ B } of "non-deterministic choice" terminal symbols br b of type b → b → b. We define:</p><formula xml:id="formula_49">W # := Σ ∪ B, N , { l -→ BR(l) | ∃r • l -→ r ∈ R }, Main</formula><p>in which, by way of a short-hand, we define:</p><formula xml:id="formula_50">BR(F t 1 • • • tn) := br b r1 (br b r2 (• • • (br b rm-1 rm) • • • ))</formula><p>where {r 1, . . . , rm}</p><formula xml:id="formula_51">= { r | F t1 • • • tn -→ r ∈ R } and the type of F is of the form τ 1 → ••• → τn → b.</formula><p>We must modify the automaton A accordingly, so we define:</p><formula xml:id="formula_52">A # := Σ ∪ B, Q, Δ ∪ { (q, brb, q q | q ∈ Q, b ∈ B }, q0</formula><p>Lemma 6. For all terms t of base-type:</p><formula xml:id="formula_53">L(W, Main t) ⊆ L(A) iff [[Main t]] W # ∈ L(A # )</formula><p>Model checking as type inference. We first introduce recursion schemes with weak definition-by-cases, which is a term rewriting system similar to (in fact, equi-expressive with) wPMRS; the difference is that (weak) matching is explicitly provided by a case construct. Assume for each base type b, an exhaustive and nonoverlapping family of patterns</p><formula xml:id="formula_54">P b = { p1, • • • , p k }.</formula><p>A recursion scheme with weak definition-by-cases (wRSC) is a quadruple G = Σ, N , R, S where Σ, N , and S are as usual, and R is a set of (pure) rules of the form</p><formula xml:id="formula_55">F x 1 • • • xm -→ t We write rhs(F ) = λx 1 • • • xm.t.</formula><p>The set of applicative terms is defined as before, except that it is augmented by a definition-bycases construct case b (t; t1, • • • , t k ) with typing rule:</p><formula xml:id="formula_56">Γ t : b Γ ti, o (for 1 ≤ i ≤ k) Γ case b (t; t1, • • • , t k ) : o</formula><p>We say that G is deterministic just if there is one rule for each F ∈ N . There are two kinds of redexes:</p><formula xml:id="formula_57">(i) F s 1 • • • sm which contracts to t[s1/x1] • • • [sm/xm] for each rule F x 1 • • • xm -→ t in R (ii) case b (t; t1, • • • , t k ) which contracts to ti, provided t of base type b matches pattern p i ∈ P b = { p1, • • • , p k }.</formula><p>We define evaluation contexts E as follows</p><formula xml:id="formula_58">E ::= [ ] | f t 1 • • • ti-1 E ti+1 • • • t ar(f )</formula><p>and write → for the one-step reduction relation</p><formula xml:id="formula_59">E[Δ] → E[ • Δ] where (Δ, •</formula><p>Δ) ranges over redex/contractum pairs and E over evaluation contexts. Assuming G is deterministic, we define the Σ ⊥labelled tree generated by G by infinitary rewriting from S as</p><formula xml:id="formula_60">[[G]] := { t ⊥ | S → * t }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7. Deterministic wPMRS and deterministic wRSC are equi-expressive as generators of Σ-labelled trees.</head><p>We present an intersection type system for characterising the model checking problem. The intersection types of the system are given by the grammar:</p><formula xml:id="formula_61">σ, τ ::= q | p | m î=1 τi → τ</formula><p>where q ∈ Q and p is one of the finitely many patterns associated with a definition by cases in the scheme G. Judgements of the type system are sequents of the form</p><formula xml:id="formula_62">Γ i=1 τi → τ Γ t : τ i (for each 1 ≤ i ≤ n) Γ s t : τ (APP) Γ, x : τ 1, • • • , x : τn t : τ Γ λx.t : V n i=1 τi → τ (ABS)</formula><p>Note that we have the following derived rule from (Match): if a term s (of the appropriate type) matches the pattern p, then Γ s : p. We write A G : Γ if Γ rhs(F ) : τ is provable for every F : τ ∈ Γ. A wRSC is well-typed, written A G, just if there exists Γ such that (i) A G : Γ, (ii) S : q0 ∈ Γ, (iii) for each F : τ ∈ Γ, τ :: κ, where F : κ ∈ N , meaning that τ is an intersection type compatible with type κ (as assigned to F by the wRSC), which is defined by: (i) q :: o, (ii) p :: b for each p ∈ P b , (iii)</p><p>V k i=1 τi → τ :: κ → κ if τ :: κ and for each 1 ≤ i ≤ k, τi :: κ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3. Let A be a trivial automaton, and G be wRSC. Then A G if and only if [[G]] ∈ L(A).</head><p>The proof is omitted as it is very similar to the proof of the soundness and completeness theorems in <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 1. The wPMRS model checking problem is decidable.</head><p>Proof. This follows from Lemma 6, Lemma 7 and Theorem 3, and the decidability of typability A G. The latter follows from the fact that for each non-terminal, there are only finitely many candidate intersection types compatible with a given type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Abstraction refinement</head><p>When the model checking stage reports a counterexample in the form of an error trace, the trace may be "feasible", that is, it corresponds to a concrete reduction sequence in the original PMRS P, or it may be "spurious": an artifact of the abstraction process. In the case the counterexample is spurious, we will want to ignore it and perform the process again, but in a new setting in which we are guaranteed never again to encounter this unwanted trace. To achieve this we restart the cycle from a modified PMRS P , which has had some of its defining rules unfolded, so as to reduce the amount of non-determinism in the corresponding wPMRS abstraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Counterexamples and feasibility.</head><p>When the model-checker reports a violation of the property, a counterexample error trace is returned. This error trace is a reduction sequence in the abstract wPMRS f PG. Since f PG is not completely faithful to the PMRS P, it is necessary to determine whether such a counterexample trace corresponds to a reduction sequence in P which itself witnesses the violation or whether it is an artifact of the abstraction.</p><p>Anatomy of a counterexample. It is useful to highlight two important features of any given counterexample trace, namely, (i) the shape of the last term in the reduction sequence and (ii) the "type" of each constituent reduction .</p><p>Any counterexample trace must end in a term t which witnesses the violation of the property ϕ. Since the property is a collection of (possibly infinite) Σ-labelled trees, the witnessing term can be seen to be of the form θq where q is a pattern which does not match any prefix of a tree t ∈ ϕ. We say that the pattern q which witnesses the violation of the property is the error witness.</p><p>In any f P G reduction sequence, each reduction u → v can be classified into one of two kinds based on the head symbol occurring in the redex. In case we want to emphasise that the head symbol is a non-terminal belonging to P we say the contraction of this redex is an abstract P-reduction and write u → P v. Otherwise the head symbol is either a pattern-symbol, an accounting-symbol or it belongs to G. In this case we say that the head symbol in question is a live-symbol and that the contraction of this redex is an abstract f P G -reduction; we write u → g P G v. Example 9. Consider the following abstract error trace which is derived from the abstraction f PG of the PMRS P and grammar G given in Example 2:</p><formula xml:id="formula_63">Main S → Filter Nz M → * Filter Nz (cons N ListN ) → If (Cons X (Filter Nz XS )) (Filter Nz XS ) (Nz X ) → * If (Cons X (Filter Nz XS )) (Filter Nz XS ) (Nz (s N )) → If (Cons X (Filter Nz XS )) (Filter Nz XS ) True → * Cons X (Filter Nz XS ) → cons X (Filter Nz XS ) → * cons z (Filter Nz XS )</formula><p>which violates the property since it is the start of a list that contains a zero. The error-witness for this trace is cons z v (for some variable v). The first reduction is an abstract P-reduction, as is the reduction written over lines 3 and 4 and that of lines 5 and 6. All the other reductions in the sequence are abstract f P G -reductions.</p><p>The trace in the above example is spurious since there are no reduction sequences of the PMRS P (starting from terms in L(G)) from Example 2 which result in a list headed by a zero. Intuitively, we can see that this trace is infeasible because the non-determinism introduced by the abstraction has been resolved in an inconsistent way during the sequence. The data bound by the pattern match for Filter , which is given as N (i.e. some number) has been resolved on the one hand (line 5) to a non-zero number and on the other hand (line 9) to zero.</p><p>In the following, we define a process of labelling of the counterexample trace that will reveal information about the resolution of non-determinism that has been introduced as a consequence of the abstraction. The information that is exposed will allow us to see whether or not this abstract trace in f P G has any corresponding trace in P starting form I, that is, whether the trace is feasible.</p><p>Labelling. The labelling procedure, labelSeq, keeps track of how non-determinism is resolved in an abstract reduction sequence by annotating each live-symbol X with a set of (possibly open) terms, which represent all the closed terms to which it reduces. When the terms are given by the set l, we write the annotated term X l and we identify an unlabelled live-symbol X with X ∅ . Given a term t which may include labelled subterms, we define the resolution of t, which is a set of terms t, defined as follows:</p><formula xml:id="formula_64">t = 8 &gt; &gt; &gt; &lt; &gt; &gt; &gt; : {a} when t = a ∈ Σ {F } when t = F is not a live-symbol l when t = F l is a live-symbol { u v | u ∈ t0, v ∈ t1 } when t = t0 t1</formula><p>where l denotes the set l when l is non-empty and {z} for some fresh variable z otherwise. If any pattern-symbol reduces to two incompatible terms or to a term which is inconsistent with the term that it represents in the matching, then the procedure will detect a conflict and record it in the set Failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>labelSeq(Main S )</head><p>If S is labelled by l and there is a term t ∈ L(G) which is an instance of mgci(l) then do nothing else add (Main, l) to Failures.</p><formula xml:id="formula_65">labelSeq(Main S → * u → v) 1. Analyse the reduction u → v: C[F θx1 • • • θxm] → g P G C[t θx1 • • • θxm]: Label the head symbol F by t. C[F θx1 • • • θxm θp] →P C[θt † ]:</formula><p>For each y ∈ FV(p), let {V l<ref type="foot" target="#foot_1">1</ref> y , . . . , V l k y } be the labelled pattern-symbols in v created by the contraction. where mgci(l) denotes the most general common instance (MGCI) of the set of terms l (regarding a single fresh variable as the MGCI of the empty set) 1 . We call a counterexample trace that has been labelled by labelSeq a labelled trace. Refinement. Given a PMRS P and an infeasible error trace α in the abstraction of P, we can obtain refined abstractions by unfolding the rules of P according to the depths of terms in the Failures set, then using the unfolded PMRS as the input to the next cycle of the abstraction-refinement loop.</p><p>Lemma 9. Let P = Σ, N , R, Main be a PMRS and f P G be the abstraction of P (starting from terms in L(G)). Let α be a counterexample trace of f PG which is spurious with Failures set S. Let d be the depth profile with domain N defined by:</p><formula xml:id="formula_66">d(F ) = dp(R)(F ) + G N { depth(t) | (F, P ) ∈ S, t ∈ P }</formula><p>and let P be the d-unfolding of P. Then α is not a reduction sequence in the abstraction f P G of P .</p><p>Although it is clear that, given any spurious trace in some abstraction f P G , it is possible to construct a refinement that eliminates it from any future abstraction f P G , the set of traces of f PG and the set of traces of f P G are incomparable since, in general, there are new pattern-variables introduced in the refinement and hence new pattern-symbols into f P G . However, there is a very close relationship between the depth of a PMRS and the feasibility of reduction sequences in its abstraction. A consequence of this close relationship between depth and feasibility is that, under the assumption that the model-checker always reports the shortest counterexample trace, if the PMRS P (when run from a term in I) does violate the property then eventually the abstraction-refinement cycle will produce a feasible counterexample trace demonstrating the fact.</p><p>Theorem 4 (Semi-completeness). Let (P, I, A) be a no-instance of the verification problem. Then the algorithm terminates with a feasible counterexample trace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related work</head><p>We compare and contrast our work with a number of topics in the literature broadly related to flow analysis and verification of functional programs.</p><p>Higher-order multi-parameter tree transducer. As discussed in the Introduction, <ref type="bibr">Kobayashi [6]</ref> introduced a type-based verification method for temporal properties of higher-order functional programs generated from finite base types. In a follow-up paper <ref type="bibr" target="#b8">[9]</ref>, Kobayashi et al. introduced a kind of tree transducer, called HMTT, that uses pattern-matching, taking trees as input and returning an output tree. They studied the problem of whether the tree generated by a given HMTT meets the output specification, assuming that the input trees meet the input specification, where both input and output specifications are regular tree languages. A sound but incomplete algorithm has been proposed for the HMTT verification problem by reduction to a model checking problem for recursion schemes with finite data domain (which can then be solved by a variation of Kobayashi's type-based algorithm). Though our algorithm in the present paper solves a similar kind of verification problem, it is not straightforward to compare it with the HMTT work <ref type="bibr" target="#b8">[9]</ref>. It would appear that PMRS is a more general (and natural) formalism than HMTT. What is clear is that our approach to the over-approximation is very different: we use binding analysis to obtain a wPMRS which generates an over-approximation of the reachable term-trees, whereas Kobayashi et al. use automaton states to approximate input trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Approximating collecting semantics and flow analysis.</head><p>In a seminal paper <ref type="bibr" target="#b4">[5]</ref>, Jones and Andersen studied the (data) flow analysis of functional programs by safely approximating the behaviour of a certain class of untyped, first-order, term rewriting systems with pattern matching. Their algorithm takes a regular set I of input terms, a program P and returns a regular tree grammar which is a "safe" description of the set of all reachable (constructor) terms of the computation of P with inputs form I. Precisely, the algorithm computes a safe approximation of the collecting semantics of P relative to I, which assigns to each rewrite rule a set of pairs (θ, g θ ) such that θ is a substitution (realisable in the course of such a computation) of actual parameters to the formal parameters of the rule, and g θ is a term reachable from the RHS of the rule with the substitution θ. The collecting semantics is undecidable in general. Jones and Andersen was able to obtain, for each rewrite rule, a regular over-approximation of the set of realisable bindings { x → θ x | realisable θ } for each formal parameter x of the rule, and the set of reachable terms { g θ | realisable θ }, by decoupling the pair (θ, g θ ).</p><p>There are two directions in which Jones and Andersen's algorithm may be refined. Consider the setting of simply-typed functional programs with pattern-matching algebraic data types. Recent advances in the model checking of higher-order recursion schemes (notably the decidability of MSO theories of trees generated by higher-order recursion schemes <ref type="bibr" target="#b13">[14]</ref>) indicate that the bindings of non pattern-matching variables, whether higher-order or not, can be precisely analysed algorithmically (though with extremely high asymptotic complexity). Jones and Andersen's algorithm builds a regular approximation of the binding set of every variable. A natural question is whether one can improve it by approximating only the bindings of pattern-matching variables, while analysing other variables (including all higher-order variables) precisely using the method in <ref type="bibr" target="#b13">[14]</ref>. The work presented here offers a positive answer to the question. Another direction worth investigating is to seek to preserve, for each rewrite rule, as much of the connection between realisable substitutions θ and reachable terms g θ as one can get away with. In an recent dissertation <ref type="bibr" target="#b9">[10]</ref>, Kochems has presented just such an algorithm using a kind of linear indexed tree grammars (which are equivalent to context-free tree grammars) whereby the indices are the realisable substitutions.</p><p>To compare our algorithm with Jones and Andersen's, it is instructive to apply their algorithm to our Example 8. Their framework can be extended to simply-typed and higher-order programs. It is an old idea in functional programming that an higher-order expression, such as an "incompletely applied" function (• • • (f e 1) • • • )em where the type of f has arity greater than m, may be viewed as a closure. (Indeed, closures are a standard implementation technique.) From this viewpoint, a higher-order non-terminal is regarded, not as a defined operator, but as a constructor, and closures are formed using a binary closure-forming operator @. Thus, the second clause of Map2 is written in their system as @ (@ (@ Map2 ϕ) ψ) (cons x xs) -→ cons (@ ϕ x) (@ (@ (@ Map2 ψ) ϕ) xs)</p><p>Observe that in this setting, Map2 is a constructor (i.e. terminal) symbol, and the expression (@ (@ Map2 ϕ) ψ) a pattern. Call the binding set of a variable the set of terms that may be bound to it at some point in the course of a computation. The approximating grammar produced by Jones and Andersen's algorithm is always regular (equivalently an order-0 recursion scheme). This is achieved by over-approximating the binding set of every variable (including higher-order ones, such as ϕ). The resultant grammar generates all finite lists of 0's and 1's, which is less precise than our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Control flow analysis.</head><p>Established in the 80's by Jones <ref type="bibr" target="#b3">[4]</ref>, Shivers <ref type="bibr" target="#b16">[17]</ref> and others, Control Flow Analysis (CFA) of functional programs has remained an active research topic ever since (see e.g. Midtgaard's survey <ref type="bibr" target="#b11">[12]</ref> and the book by Nielson et al. <ref type="bibr" target="#b12">[13]</ref>).</p><p>The aim of CFA is to approximate the flow of control within a program phrase in the course of a computation. In a functional computation, control flow is determined by a sequence of function calls (possibly unknown at compile time); thus CFA amounts to approximating the values that may be substituted for bound variables during the computation. Since these values are (denoted by) pieces of syntax, CFA reduces to an algorithm that assigns closures (subterms of the examined term paired with substitutions for free variables) to bound variables. Reachability analysis and CFA are clearly related: for example, the former can aid the latter because unreachable parts of the term can be safely excluded from the range of closure assignment. There are however important differences: on one hand, CFA algorithms are approximation algorithms designed to address a more general problem; on the other, because CFA considers terms in isolation of its possible (program) contexts, the corresponding notion of reachability essentially amounts to reachability in the reduction graph.</p><p>Functional reachability. Based on the fully abstract game semantics, traversals <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b13">14]</ref> are a (particularly accurate) model of the flow of control within a term; they can therefore be viewed as a CFA method. Using traversals, a new notion of reachability of higher-order functional computation (in the setting of PCF) is studied in <ref type="bibr" target="#b15">[16]</ref>, called Contextual Reachability: given a PCF term M of type A and a subterm N α with occurrence α, is there a program context C[-] such that C[M ] is a closed term of ground type and the evaluation of C[M ] causes control to flow to N α ?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>Recursion schemes with pattern matching (PMRS) are an accurate and natural model of computation for functional programs have pattern-matching algebraic data types. We have given an algorithm that, given a PMRS P and a regular set I of input terms, constructs a recursion scheme with weak pattern-matching (wPMRS) that (i) over-approximates the set of terms reachable from under rewriting from P (ii) has a decidable model checking problem (relative to trivial automata). Finally, because of the precise analysis at higher-orders, we show that there is a simple notion of automatic abstraction-refinement, which gives rise to a semi-completeness property.</p><p>For future work, we plan to build an implementation of the verification algorithm for a real functional programming language. We shall be especially interested in investigating the scalability of our approach.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 1 .</head><label>1</label><figDesc>The following PMRS defines a function Merge : ablist → ablist → ablist that merges two lists of a and b by recursively destructing them.Merge x nil-→ x Merge x (cons a y) -→ cons a (Merge y x) Merge x (cons b y) -→ cons b (Merge y x)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 2 .</head><label>2</label><figDesc>Consider the PMRS P which, when started from Main takes as input a list of natural numbers and returns the same list with all occurrences of the number zero removed. The defining rules of P are given by: Main m -→ Filter Nz m If a b true -→ a If a b false -→ b Nz z -→ false Nz (s n) -→ true Filter p nil -→ nil Filter p (cons x xs) -→ If (cons x (Filter p xs)) (Filter p xs) (p x)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Counterexample-guided abstraction-refinement loop.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>and there exist base-types b 1, . . . , b k such that the judgements: y 1 : b1, . . . , y k : b k p : b and x1 : τ1, . . . , xm : τm, y1 : b1, . . . , y k : b k t : o</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>and there exist base-types b1, . . . , b k such that the judgements: y 1 : b1, . . . , y k : b k p : b and x1 : τ1, . . . , xm : τm t : o</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>→S} cons N ListN respectively. This choice adds the bindings p → Nz , x → N and xs → ListN . Examining the term p x in the RHS of the second defining rule for Filter then gives n → N . Finally, taking u as the entire RHS of the second defining rule for Filter and approximate-reducing p x as in Example 6 gives bindings a → cons x (Filter p xs) and b → Filter p xs. In this case, no other choices of simple term yield any new bindings, so the fixpoint Ξ is obtained as: m → S, p → Nz , x → N , xs → ListN n → N , a → cons x (Filter p xs), b → Filter p xs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FilterFigure 3 .</head><label>3</label><figDesc>Figure 3. Depth-2 unfolding of the defining rules for Filter .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Lemma 10 .</head><label>10</label><figDesc>Fix n ∈ N. Then given any PMRS P and input grammar G, there is a depth-profile d such that, if f P G is the abstraction of the d-unfolding of P, then all length-m ≤ n reduction sequences in f P G are feasible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>If ∀i a matches si then do nothing else fail. If F is not a live-symbol and ∀i F matches si then do nothing else, if F is a live-symbol and w = mgci({s 1, . . . , s k }) exists then label F by {w} else fail. If ∀i either si is a variable or si = si 0 si 1 then (let s j 0 = z0 and sj 1 = z1 for fresh z1, z2 whenever sj is a variable) and perform labelTm(t 0)({s1 0 , . . . , s k 0 }) and perform labelTm(t 1)({s1 1 , . . . , s k 1 }) else fail.</figDesc><table><row><cell>Perform labelTm(θy)( S {l 1, . . . , l k }) on the corre-</cell></row><row><cell>sponding occurrence of θy in θp. If labelTm fails, then add (F, S {l 1, . . . , l k }) to Failures.</cell></row><row><cell>2. For each occurrence of an unlabelled live-symbol N in u,</cell></row><row><cell>let {N l 1 1 , . . . , N Label this occurrence of N with l k k } be the set of labelled descendants in v. S {l 1, . . . , l k }.</cell></row><row><cell>3. Perform labelSeq(M ain S →  *  u).</cell></row><row><cell>where the procedure labelTm, which is designed to resolve the data</cell></row><row><cell>bound in a pattern match and the data created by the abstraction, is</cell></row><row><cell>given by:</cell></row><row><cell>labelTm(t)({s 1, . . . , s k })</cell></row><row><cell>Analyse the form of t:</cell></row><row><cell>t = a: t = t0 t1:</cell></row></table><note><p>t = F :</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>t : τ , in which Γ is simply a set of type bindings ξ : σ where ξ ∈ N ∪ V. The defining rules of the system are as follows:Γ, x : τ x : τ (VAR) (q, f, q 1 • • • qn) ∈ Δ A # Γ f : q1 → • • • → qn → q (TERM) ∃θ • s p 1 • • • pn = θ p Γ s : p1 → • • • → pn → p (MATCH) Γ t : p i Γ ti : τ Γ case b (t; t1, • • • , ti, • • • , tn) : τ (CASE) Γ s : V n</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>For the purposes of calculating MGCIs, terms are considered as first order entities constructed from atomic constants and a single (silent) application operator.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We would like to thank the anonymous reviewers for many useful comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Example 10. Consider again the abstract reduction sequence in Example 9, after performing labelSeq the following labelled trace is produced (the set bracket notation has been elided since all labels are singleton sets):</p><p>After labelling, we have Failures = {(Filter , {z, s v0})}. Observe that there are no labels on N in line 2, due to the fact that labelTm failed.</p><p>Feasibility. For a trace α in f P G to be feasible two properties are required. First, the non-determinism introduced by the abstraction should be well behaved and second, there should be a term in the input that is able to trigger the trace, i.e. when given as an argument to Main, the rest of the trace follows. The first of these conditions is the subject of the step case in labelSeq, the second is the subject of the base case. Hence, if after performing labelSeq(α) it is the case that Failures = ∅, then we say α is feasible. The justification is the following lemma. Lemma 8. Let α be a feasible reduction sequence in f P G with error-witness q. Then there exists a term t ∈ L(G) and a finite reduction sequence Main t ⇒ • • • in P with error witness q.</p><p>The witness to soundness, which appears in the proof of Theorem 2, will always be feasible. We say that any trace that is not feasible is spurious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Refinement</head><p>When a reduction sequence in f P G is shown to be spurious, the problem can always be traced back to an occurrence of patternmatching (notice that, by definition, the single parameter of the defining rule for Main is always a pattern). Since the only loss of accuracy in the abstraction is in the way that data bound in pattern matches is handled during reduction, our remedy for infeasibility is to increase precision in the pattern matching rules of f P G . Our strategy is based on the observation that, due to the particular way in which the abstract wPMRS is constructed from the composite PMRS, the terminal symbol-labelled parts of each pattern are accurately preserved in the RHS of the defining rules of the abstraction. Based on the depth of pattern matches in the counterexample trace, we unfold patterns in the defining rules of P in a way that preserves the the set of possible reduction sequences.</p><p>Pattern-matching depth. To determine how much to unfold we define a measure depth : T (Σ, N , V) → N, which quantifies the extent to which a term can be matched, as follows:</p><p>Given a set of non-terminals N , a depth profile for N is a map N → N. We assign a depth profile to a set of rules to quantify, for each non-terminal F , how accurately the defining rules for F model pattern-matching. Given a set of rules R defining non-terminals from N , let the depth profile of R, denoted dp(R), be the function:</p><p>Depth profiles can be naturally ordered pointwise, so that if d and d are depth profiles over the same domain N , then</p><p>Unfolding. To capture the result of unfolding we first introduce two auxiliary definitions. To aid readability, in each of them we will annotate fresh variables with their implied types by a superscript. The set of atomic patterns of type b, A b is the set</p><p>For each n ∈ N we define the non-overlapping, exhaustive set of patterns of type b and depth n, pats b (n):</p><p>| ϕ } where ϕ stands for the conjunction:</p><p>Hence, the depth 2 family of patterns of type natlist are given by (n, x and xs arbitrary variables):</p><p>nil, cons z nil, cons z (cons x xs),</p><p>To unfold the rules of a PMRS P according to a depth profile d, one constructs a new PMRS P whose rule-set is enlarged so that, for a given non-terminal</p><p>there is a number of defining rules which is equal to the number of patterns of type b and depth d(F ). For each of these rules the corresponding right-hand side is constructed by using the existing P rules as a template.</p><p>Let P = Σ, N , R, Main be a PMRS and let d be a depth profile with domain N such that dp(R) ≤ d. The d-unfolding of P is the PMRS Σ, N , R , Main , where R is the set such that, for all substitutions σ, F x</p><p>(ii) and p is of type b (iii) and q ∈ pats b (d(F )) (iv) and q = σp Example 11. Let P be as in Example 2 and let d be the depth profile given by the following rule:</p><p>Then the d-unfolding of P is the PMRS P , whose rules are the same as P except that the two rules for Filter have been replaced by the five rules in Figure <ref type="figure">3</ref>.</p><p>Consider an abstraction f P G of the PMRS P in Example 11 (with G as given in Example 2). The only non-determinism that is introduced in constructing the abstraction is in replacing the pattern-matching variables in the right-hand sides of the defining rules by pattern-symbols. Due to the unfolding of the Filter rules in P (and hence in f P G ), there is no longer a possibility to make the problematic reduction:</p><p>Filter (Nz (cons N ListN ) → If (Cons X (Filter Nz XS )) (Filter Nz XS ) (Nz X ) since the unfolded rules require more of the non-determinism (in the non-terminal symbols N and ListN ) to be resolved earlier.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Path-correspondence theorems and their applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-H</forename><forename type="middle">L</forename><surname>Ong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note type="report_type">Preprint</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV &apos;00: Proceedings of the 12th International Conference on Computer Aided Verification</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="154" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Resource usage analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="264" to="313" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Flow analysis of lambda expressions (preliminary version)</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Colloquium on Automata, Languages and Programming</title>
		<meeting>the 8th Colloquium on Automata, Languages and Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="114" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Flow analysis of lazy higher-order functional programs</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Andersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">375</biblScope>
			<biblScope unit="page" from="120" to="136" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Types and higher-order recursion schemes for verification of higher-order programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of POPL 2009</title>
		<meeting>POPL 2009</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="416" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Model-checking higher-order functions</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PPDP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A type theory equivalent to the modal mu-calculus model checking ofhigher-order recursion schemes</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-H</forename><forename type="middle">L</forename><surname>Ong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LICS 2009</title>
		<meeting>LICS 2009</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Higher-order multiparameter tree transducers and recursion schemes for program verification</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tabuchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Unno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="495" to="508" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Approximating reachable terms of functional programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kochems</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>University of Oxford MMathsCompSc thesis</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Kurshan</surname></persName>
		</author>
		<title level="m">Computer Aided Verification of Coordinating Processes</title>
		<imprint>
			<publisher>Princeton University Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Control-flow analysis of functional programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Midtgaard</surname></persName>
		</author>
		<idno>BRICS RS-07-18</idno>
		<ptr target="http://www.brics.dk/RS/07/18/BRICS-RS-07-18.pdf" />
		<imprint>
			<date type="published" when="2007-12">Dec 2007</date>
			<pubPlace>Aarhus, Denmark</pubPlace>
		</imprint>
		<respStmt>
			<orgName>DAIMI, Department of Computer Science, University of Aarhus</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Principles of Program Analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hankin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On model-checking trees generated by higherorder recursion schemes</title>
		<author>
			<persName><forename type="first">C.-H</forename><forename type="middle">L</forename><surname>Ong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 21st Annual IEEE Symposium on Logic in Computer Science</title>
		<meeting>21st Annual IEEE Symposium on Logic in Computer Science<address><addrLine>Seattle</addrLine></address></meeting>
		<imprint>
			<publisher>Computer Society Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
	<note>Long version (55 pp.) downloadable at users.comlab.ox.ac.uk/luke.ong/</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Verifying higherorder functional programs with pattern-matching algebraic data types. Long version</title>
		<author>
			<persName><forename type="first">C.-H</forename><forename type="middle">L</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Ramsay</surname></persName>
		</author>
		<ptr target="https://mjolnir.comlab.ox.ac.uk/papers/pmrs.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Functional reachability</title>
		<author>
			<persName><forename type="first">C.-H</forename><forename type="middle">L</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tzevelekos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="286" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Control-flow analysis of higher-order languages</title>
		<author>
			<persName><forename type="first">O</forename><surname>Shivers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie-Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
