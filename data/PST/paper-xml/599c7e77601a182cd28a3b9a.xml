<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Cyclic Obfuscation for Creating SAT-Unresolvable Circuits</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kaveh</forename><surname>Shamsi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">ECE Department</orgName>
								<orgName type="institution">University of Central Florida</orgName>
								<address>
									<settlement>Orlando</settlement>
									<region>FL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Meng</forename><surname>Li</surname></persName>
							<email>meng_li@utexas.edu</email>
							<affiliation key="aff1">
								<orgName type="department">ECE Department</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<settlement>Austin</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Travis</forename><surname>Meade</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">ECE Department</orgName>
								<orgName type="institution">University of Central Florida</orgName>
								<address>
									<settlement>Orlando</settlement>
									<region>FL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zheng</forename><surname>Zhao</surname></persName>
							<email>zzhao@utexas.edu</email>
							<affiliation key="aff1">
								<orgName type="department">ECE Department</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<settlement>Austin</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
							<email>dpan@utexas.edu</email>
							<affiliation key="aff1">
								<orgName type="department">ECE Department</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<settlement>Austin</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yier</forename><surname>Jin</surname></persName>
							<email>yier.jin@eecs.ucf.edu</email>
							<affiliation key="aff0">
								<orgName type="department">ECE Department</orgName>
								<orgName type="institution">University of Central Florida</orgName>
								<address>
									<settlement>Orlando</settlement>
									<region>FL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Cyclic Obfuscation for Creating SAT-Unresolvable Circuits</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3455F6F24D1BA63AC72D358BD005D539</idno>
					<idno type="DOI">10.1145/3060403.3060458</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Logic locking and IC camouflaging are proactive circuit obfuscation methods that if proven secure can thwart hardware attacks such as reverse engineering and IP theft. However, the security of both these schemes is called into question by recent SAT based attacks. While a number of methods have been proposed in literature that exponentially increase the running time of such attacks, they are vulnerable to "find-and-remove" attacks, and only slightly hide the circuit functionality. In this paper, we present a novel approach towards creating SAT attack resiliency based on creating densely cyclic obfuscated circuit topologies by adding dummy paths to the circuit. Our methodology is applicable to both IC camouflaging and logic locking. We demonstrate that cyclic logic locking creates SAT resilient circuits with 40% less area and 20% less delay compared to an insecure XOR/XNOR-obfuscation with the same key length. Furthermore, we show that cyclic IC camouflaging can be implemented at the layout level with no substrate area overhead and little delay and power overhead with respect to the original circuit.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>With the globalization of the IC supply chain and the advent of fabless design houses, several security concerns have been raised <ref type="bibr" target="#b22">[22]</ref>. These include reverse engineering by end-users, and malicious modification or overproduction by foundries. VLSI design for trust (DfTr) <ref type="bibr" target="#b12">[12]</ref> refers to design-time techniques for thwarting these threats. Among them, IC camouflaging <ref type="bibr" target="#b4">[4]</ref> and logic locking/encryption <ref type="bibr" target="#b14">[14]</ref> are two promising directions. With these approaches the designer can hide design information from a malicious foundry or end-user. We therefore categorize both schemes as circuit obfuscation, since they rely on the concept of "security through obscurity". IC camouflaging is based upon creating indistinguishable silicon layout structures that hamper reverse engineering of the IC by the end-user. In logic locking the circuit is augmented with additional key inputs such that it operates incorrectly without the correct key values applied. Therefore logic locking can prevent reverse engineering, as well as cloning or theft of intellectual property (IP) by the foundry or any other party that does not posses the correct key. Table <ref type="table" target="#tab_0">1</ref> lists the protection provided by these circuit obfuscation schemes.</p><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.</p><p>GLSVLSI <ref type="bibr">'</ref> The security of these schemes has been the topic of research over the past several years through a competition of obfuscation defenses and deobfuscation attacks <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b18">18]</ref>. Deobfuscation attacks are developed under various assumptions on the capabilities of the adversary. A prominent adversary-model in deobfuscation assumes the attacker has access to the inputs and outputs of a functional or unlocked chip. With such oracle-access to the chip the attacker can query the circuit for different inputs and use correct input-output pairs to find the correct key values or camouflaged functions. The most recent and strongest attack under this assumption is a disagreement based approach that queries the oracle circuit on input patterns that results in different outputs for different key values or camouflaged function hypotheses <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b18">18]</ref>. These patterns are referred to as discriminating input patterns (DIP). Since the attack is formulated as a Boolean Satisfiability (SAT) problem and uses SAT-solvers, it is commonly referred to as the SAT attack. The SAT attack is successful in deobfuscating almost all known gatelevel obfuscation solutions that have reasonable overhead <ref type="bibr" target="#b18">[18]</ref>.</p><p>To counter the SAT attack a number of defenses have been presented in literature <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr">7,</ref><ref type="bibr" target="#b23">23]</ref>. In these obfuscation schemes it is ensured that each DIP removes a limited number of key possibilities and therefore, the SAT attack will require an exponential number of queries to resolve the correct key. However, almost all these defenses rely on large low-activity blocks that can either be found and removed as was shown in <ref type="bibr" target="#b25">[25]</ref>, or are fundamentally capable of hiding only a few input patterns from the attacker due to their low corruptibility <ref type="bibr" target="#b17">[17]</ref>.</p><p>In this paper we present a novel SAT-resilient obfuscation scheme. This methodology is inspired by how configurable and cyclic interconnection networks allow modern programmable logic to implement a large set of Boolean functions with small logic components. The key idea is that if a logical loop is created in the circuit (which is typically avoided in prior work <ref type="bibr" target="#b16">[16]</ref>), through adding dummy wires and gates, the adversary cannot launch the existing SAT attacks, since the circuit can no longer be represented as a directed acyclic graph (DAG). We show that from a graph theoretic perspective the number of possible ways for opening these loops can be made excessively large. In summary we make the following contributions:</p><p>• We present cyclic obfuscation as the first topological, wire-based approach to creating SAT attack resiliency;</p><p>• We discuss implementation details for ensuring the hardness of the attack, as well as silicon level techniques to implement the idea in both of IC camouflaging and logic locking flavors;</p><p>• We implement prototype cyclic logic locking and cyclic IC camouflaging schemes using the Nangate OpenCell 15nm technology library <ref type="bibr" target="#b1">[1]</ref>. The results show both area and delay improvements for for cyclic logic locking compared to traditional schemes, and much smaller overheads for cyclic IC camouflaging.</p><p>The rest of the paper is organized as follows: Section 2 presents background information and prior work. Section 3 discusses SAT attack resiliency through topology obfuscation. Section 4 presents our cyclic obfuscation scheme and security and implementation aspects. Section 5 presents experimental results and section 6 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND 2.1 Circuit Obfuscation</head><p>IC camouflaging. the goal in IC camouflaging is to prevent recovery of the netlist from layer-by-layer images of the IC. There exists an array of industrial fabrication technologies for creating indistinguishable layout structures <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b20">20]</ref>. Some notable techniques include, using dummy vias, altering doping patterns, or using filler cells. Dummy vias are metal-to-metal or metal-to-diffusion contacts that appear to be connected from the top view while they are not in fact conducting. Modifying doping patterns allows altering the type of transistors or junctions while conventional IC imaging techniques cannot detect the difference <ref type="bibr" target="#b8">[8]</ref>. Dummy cells can also be inserted in the empty areas of the chip and connected to active logic. With these techniques, camouflaging logic units can be built such that their overall Boolean function cannot be resolved to a specific function. Inserting these camouflaged units with different strategies creates obscurity during the reverse engineering process. This can be seen in Fig. <ref type="figure" target="#fig_0">1a</ref>.</p><p>Logic Locking. Figure <ref type="figure" target="#fig_0">1b</ref> shows a circuit obfuscated with logic locking. Logic locking was originally presented for hiding design details from the foundry and allowing for authenticated usage of the IC <ref type="bibr" target="#b14">[14]</ref>. The first logic locking scheme was based on XOR/XNORing randomly selected wires in the circuit with key inputs <ref type="bibr" target="#b14">[14]</ref>. Later proposals included more complex strategies for improving security. These techniques include inserting XOR/XNOR or MUX gates at locations that maximize properties such as output hamming-distance <ref type="bibr" target="#b9">[9]</ref>, or the size of cliques in the interference graph of key inputs <ref type="bibr" target="#b10">[10]</ref>. Interconnect obfuscation schemes were also proposed such as shuffling wires in bus architectures <ref type="bibr" target="#b15">[15]</ref>, combinational logic <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b3">3]</ref>, or most recently, inserting dummy wires into the circuit through chip-level modification <ref type="bibr" target="#b16">[16]</ref>. All of these schemes avoid creating logical cycles in the circuit. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">SAT Attacks</head><p>The SAT attack assumes the oracle-guided attack threat-model where the attacker has input-output access to an operational chip (as black-box) and a netlist of the obfuscated chip layout. The first step in the SAT attack is to model the obfuscated circuit with a Boolean function, Cenc, from input space I, and an obfuscationsecret (key)<ref type="foot" target="#foot_0">1</ref> space, K, to outputs (Cenc : K × I → O). For logic locking this is a direct transformation. Most camouflaging scheme can also be represented in such a form with polynomial overhead. For instance, a camouflaged gate can be modeled as a key-controlled MUX selecting among a set of possible functionalities of the camouflaged gate.</p><p>The attack begins by satisfying a mitter SAT problem, Cenc(i, k1) = Cenc(i, k2) with some i, k1, k2. The solution input, i, is called a discriminating input pattern (DIP) since it differentiates k1 and k2. i is queried on the black-box Co and the output yi is obtained. The input-output relation, (Cenc(i, k1) = yi) ∧ (Cenc(i, k2) = yi), is appended to the mitter SAT problem as a new constraint. The process continues until no more DIPs can be found. At this point satisfying the constraints will return a key, k * ∈ K * , which agrees with the black-box on all the input-output observations and cannot be differentiated by a query. El massed <ref type="bibr" target="#b5">[5]</ref> showed that any key from K * is necessarily a correct key (∀i</p><formula xml:id="formula_0">∈ I, Cenc(i, k * ) = Co(i)).</formula><p>The SAT attack is successful in deobfuscating almost all traditional logic locking schemes <ref type="bibr" target="#b18">[18]</ref>, and gate-level IC camouflaging schemes <ref type="bibr" target="#b5">[5]</ref>. Furthermore, Shamsi et al. <ref type="bibr" target="#b17">[17]</ref> extended the SAT attack to include approximation which allows the SAT attack to approximate the original circuit defeating the recently proposed SATresilient obfuscation schemes <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr">7,</ref><ref type="bibr" target="#b23">23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SAT-RESILIENT OBFUSCATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Security Criteria</head><p>Defining general and meaningful security criteria for circuit obfuscation is an elusive task. However, in the context of SAT attacks on combinational logic locking and camouflaging schemes the following criteria can be defined: 1) High query complexity: The query complexity measure, QC, of an obfuscated circuit, Cenc, with black-box access to the original circuit, Co, is the minimum number of queries required to resolve the key. 2) High corruptibility: the corruptibility measure of the obfuscation, Cr, captures the effect of the key on the output. This can be defined as the disagreement probability:</p><formula xml:id="formula_1">Cr = Pr i∈I, k∈K [Cenc(i, k) = Co(i)].</formula><p>3) As for approximation resiliency which is a stricter criteria there should not exist an algorithm that learns an -approximation of the original circuit with a success rate of 1 -δ where and δ are small factors <ref type="bibr" target="#b17">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Existing Defenses Against SAT Attacks</head><p>A number of defenses against the SAT attack have been proposed in literature <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr">7,</ref><ref type="bibr" target="#b23">23]</ref>. These methods all rely on limiting the number of incorrect keys that each DIP can exclude. All these methods require tree structures that will output 1 for only a single input pattern and output 0 for all others. Therefore these schemes have a very low output corruptibility <ref type="bibr" target="#b23">[23]</ref> and are hence all combined with high-corruptibility obfuscation schemes such as XOR/XNOR locking etc. The low-corruptibility schemes are generally vulnerable to "find-and-remove" style attacks that search the circuit structure or its function for the tree-like blocks and remove them as was shown in <ref type="bibr" target="#b25">[25]</ref>. Furthermore, with the approximate SAT attack the high-corruptibility schemes can be attacked independent of the low-corruptibility obfuscation <ref type="bibr" target="#b17">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Obfuscating Topology</head><p>It is easy to see that a fully programmable function is difficult to deobfuscate using the SAT attack. A function Xn : {0, 1} n ×K → {0, 1}, which we define to be a function that implements all 2<ref type="foot" target="#foot_1">2</ref> n different Boolean functions from {0, 1} n to {0, 1} by configuring k ∈ K, is secure against SAT attacks. Each query will reveal a single entry in the truth-table and hence QC(Xn) = |I| = 2 n . Furthermore, corruptibility is high since the probability of predicting the correct output given an incorrect key is no better than random guessing. Approximation resiliency is also high since the rate of discovering the truth-table is no faster than linear with respect to the queries.</p><p>It is well known that modern programmable logic such as FPGAs are practically fully programmable functions. An FPGA achieves this large expressiveness through combining small LUTs with 6 or less inputs and programmable interconnects as seen in Fig. <ref type="figure" target="#fig_1">2a</ref> . With programmable interconnections, the small units can be arranged in different topologies to implement a large number of possible functionalities. A sea of AND/OR/NOT gates, plus a sea of configurable wires is capable of implementing a prohibitively large number of functionalities 2 .</p><p>With respect to SAT attacks, one difficulty in deobfuscating programmable interconnects is to model the fabric with an acyclic Boolean circuit of keys and inputs. When reverse engineering a sea of programmable wires, any terminal on a logic unit can potentially be connected to any other logic unit. Therefore, in the graph model of such a circuit there are many edges and potentially many loops. However, existing SAT attacks require an directed acyclic graph (DAG) to begin the attack. It seems that at least additional abstract key-bits are required to represent the cyclic topology as a DAG. Cyclic obfuscation exploits this idea to create a highly complex circuit structure in ASICs without incurring the high overheads of fully programmable logic (30X area, 3X delay, and 10X power). Note that if such overhead is acceptable simply using programmable devices and using the configuration bitstream as the key is a secure defense against SAT based deobfuscation. (a) (b) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LUT LUT LUT LUT</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SECURE AND LIGHT-WEIGHT CYCLIC-OBFUSCATION</head><p>While it is possible to flood the circuit with dummy interconnections to achieve a highly complex and expressive cyclic structure, our light-weight cyclic obfuscation scheme relies on using the minimum number of dummy edges to create loops that are difficult to remove.</p><p>We will model circuits with a directed graph. Consider the original Boolean circuit Co as seen in Fig. <ref type="figure" target="#fig_2">3</ref>. In the graph representation of Co, input wires are represented by nodes with no incoming edges. Similarly, output wires are represented by nodes with no outgoing edges. Each gate is represented by a node where the gate inputs are incoming edges and the gate output is represented by outward edges. The fanout cone of a node u includes every node v reachable from u, and the fanin cone of u includes every node v that can reach u. </p><formula xml:id="formula_2">i 3 g 1 g 0 i 0 i 1 i 2 i 4 O 1 g 2 g 3 O 0 O 1 O 0 i 3 i 0 i 1 i 2 i 4 g 1 g 2 g 0 g 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Creating Hard Loops</head><p>We can begin adding edges to the circuit DAG to create logical loops. In order for an edge to create a logical loop it has to connect a node in the fanout cone of u to a node in the fanin cone of u which will create a loop with u being on the loop. The goal of the defender is to first ensure that there are more than one ways to open the loop, all of which are feasible from the attacker perspective. Furthermore, the defender wants to maximize the number of possible ways to open this loop. These require two conditions that are discussed herein. CONDITION 1. Any created loop has to be non-reducible.</p><p>Given a general cyclic graph the problem of finding edges in the graph to remove to obtain an acyclic graph is known as the feedback arc set problem <ref type="bibr" target="#b2">[2]</ref> which is NP-complete. However, the NP-complete hardness of this problem may not necessarily be used to ensure the difficulty of recovering the original acyclic circuit in our case. The inputs and outputs of a circuit graph are known as sources and sinks to the attacker which help infer a general direction in the graph and potentially remove edges that oppose this direction. More precisely, a cyclic circuit graph is a flow-graph <ref type="bibr" target="#b6">[6]</ref>.</p><p>Flow-graphs and loops are studied in depth in the context of programs <ref type="bibr" target="#b6">[6]</ref>. Loops in flow-graphs can be reducible or non-reducible. If a flow-graph has only reducible loops, the depth-first-search (DFS) traversal of this graph is unique. This unique DFS tree will allow all reducible loops to be opened by removing a unique set of edges which can be found efficiently. Since this would be greatly detrimental to the security of cyclic obfuscation any loop created during the obfuscation has to be non-reducible. A sufficient condition for a loop to be non-reducible is for it to have multiple entry points. An entry point in a loop is an edge arriving on one of the vertices in the loop from a vertex outside the loop.</p><p>Example: Consider graph in Fig. <ref type="figure" target="#fig_3">4a</ref>. In this graph if we add edge e3, the loop {e1, e2, e3} is reducible since it has a single entry through g1 and in the DFS traversal of this graph e3 will always be a backward edge. On the other hand in graph Fig. <ref type="figure" target="#fig_3">4b</ref>, the loop {e1, e2, e3} is non-reducible since if we enter the loop from g1, e2 will be a backward edge, but if we enter the loop from g2, a different edge, e1, will be opposing the flow. CONDITION 2. At least n ≥ 2 edges in a loop have to be "removable". This will result in a loop complexity of 2 n .</p><p>An edge is removable if 1) the attacker is able to modify the key to remove that edge from the graph; 2) removing the edge through a key value, should not create gates with no inputs or no outputs. Otherwise, even though the edge removal is controlled by the key, its removal is not possible without introducing errors into the circuit.</p><p>Example: In the graph in Fig. <ref type="figure" target="#fig_3">4b</ref>, if the removal of edge e1 is controlled by a key-bit it would still not be a removable edge, since removing e1 will leave the gate, g1, with no outputs.</p><p>If an edge is removable, then it creates a dilemma for the attacker during reverse engineering. If a loop has n removable edges, there </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Dummy Logic as Extra Nodes</head><p>Thus far we only discussed adding edges (wires) to the design to create obscurity. However, dummy gates can also be added to the circuit as extra nodes and included in loops. This will have the following benefits: 1) inserting dummy gates in realistic designs can have a virtually zero area overhead, since they can be inserted in empty areas that would be otherwise filled with filler cells. Therefore, dummy gates can be easily used to increase the length of a given loop at no cost. 2) As was discussed, for an edge to be removable, its removal should not result in a gate with empty fanout or fanin. However, if the attacker is faced with the possibility of dummy cells, this condition can be relaxed, since if the gate is dummy it can have an empty fanout or fanin.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Light-Weight Implementation Algorithm</head><p>We will first discuss a logic locking implementation of the obfuscation scheme. For logic locking, from a graph level, we first need to identify a path (v1, v2) and make sure that at least one node between v1 and v2 has more than one incoming edges to ensure the non-reducibility of the loop. If this is the case then we can feed v2 back into v1. We then have to ensure that edges on this loop are removable.</p><p>To create removable feedback wires we can either use a gate to nullify the effect of a a wire on a gate as seen in Fig. <ref type="figure">5a</ref>, or use a MUX gate to select between two wires as seen in Fig. <ref type="figure">5b</ref>. To make edges along the path (v1,v2) removable, depending on the fanout count of the nodes on the path we can use one or two MUX gates to implement this as is discussed in the bellow example. a general algorithm for performing the above cyclic logic locking is presented in Algorithm 1.</p><p>Example: Per Fig. <ref type="figure">6</ref>, we first feedback the wire w3 into w0 and then we need to make the edges on the path (w1, w3) removable. For wire w1, the wire already connects to more than one location. Therefore, simply including the MUX gate, M1, in this path will allow the key-bit k1 to open this edge. When k1 opens the loop, the end while 16: end function input of gate g2 is fed from a randomly selected wire in the circuit r0. For the wire w2 however, since it is driving the gate g2 only, two MUXs are used to make this edge removable. First, M2 selects between w2 and the random wire r1. Second, M3 is used to open a path from w2 to a randomly selected location r2. MUXs M2 and M3 are controlled by the same key-bit k2 which will remove the edges from the loop and redirect them to other locations.</p><p>For IC camouflaging a similar procedure can be used, except that MUXs in IC camouflaging can be implemented with dummy vias with virtually zero gate area overhead as seen in Fig. <ref type="figure">7</ref>. Even for the case of logic locking one-time-programmable contacts, such as anti-fuse vias, high Ron/R of f non-volatile memory devices, or other metal-to-metal programmable switches can be used to implement a light-weight and non-volatile MUX element for cyclic logic locking. We note that cyclic obfuscation heavily relied on the security of such silicon level techniques. We allow the attacker to tell the difference between true vias and potentially-true vias, however, the attacker should not be able to tell apart true and fake vias. For instance, doping based programmable/camouflaged connections can be revealed with selective etching, or capacitive imaging <ref type="bibr" target="#b19">[19]</ref> and should not be used, whereas Mg/MgO connections <ref type="bibr" target="#b3">[3]</ref> are more difficult to differentiate at least with current scanning electron microscopy techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTATION RESULTS</head><p>We implemented cyclic obfuscation in both IC camouflaging and logic locking. We begin with cyclic logic locking. The benchmark netlists were analyzed and modified using a C++ framework. Synthesis and delay and area characterization were performed using Design Compiler (DC) with the Nangate OpenCell 15nm library <ref type="bibr" target="#b1">[1]</ref>. It is important to inform the synthesis tool that the loops created in the circuit are not part of the critical path. Otherwise the synthesis tool will try to fix design-rule violations for such paths which would create large unnecessary overheads. The results for cyclic logic locking on the c432 ISCAS benchmark circuit are shown in Table <ref type="table" target="#tab_3">3</ref>. Since c432 is the smallest benchmark, overhead trade-offs are more significant. Larger circuits will have negligible overheads.</p><p>We then applied the cyclic logic locking to a larger set of ISCAS and MCNC benchmarks as shown in Table <ref type="table">2</ref>, for N = 6 (loop count) and M = 6 (loop length). The same benchmark circuits were obfuscated with a traditional random XOR/XNOR obfuscation with the same number of key-bits (72). The area and delay results from synthesis in the 15nm OpenCell library are shown in Figs. <ref type="figure" target="#fig_6">8</ref> and<ref type="figure" target="#fig_7">9</ref> which shows the feasibility of a low overhead implementation of cyclic logic locking in comparison with traditional methods. Note that SAT resilient proposals <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr">7,</ref><ref type="bibr" target="#b23">23]</ref>  Table <ref type="table">2</ref>: Benchmark circuits adopted from <ref type="bibr" target="#b18">[18]</ref>. Gate count is in terms of number primitive gates.</p><p>included in the comparison since they all utilize XOR/XNOR obfuscation internally to increase corruptibility. As for cyclic IC camouflaging, we created a set of dummy vias and MUXs using Cadence Virtuoso and utilized them in Encounter as part of a physical-only library. As seen in Figure <ref type="figure" target="#fig_9">10c</ref> the dummy vias are automatically placed and routed using Encounter. Our layout experiments with three benchmark circuits, c432, c1908 and c3540 showed that with a core utilization of 70%, the cyclic camouflaged circuit does not increase the core area and only contributes to additional congestion and wire-length. The maximum wire-length increase was for 8 cycles of 6 edges long inserted in the c1908 benchmark circuit with 32% wire-length overhead and all designs converged without design-rule violations. Accurate delay and power overhead analysis require capacitance details from the camouflaged vias, however, by assuming capacitance values of two crossing wires for the fake vias, delay overhead was a maximum of 6.2% and power overhead was a maximum of 5% for 8 cycles of length 8 across the benchmarks. Extensive layout implementation and characterization is a topic of our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>In this paper a novel approach towards thwarting SAT attacks was proposed based on creating interconnection cyclic obscurity. The method is applicable to both logic locking and IC camouflaging and as was demonstrated in this paper can be performed with very low performance and area overhead. While the current SAT attacks are incapable of reverse engineering cyclic circuits, investigating novel oracle-guided attacks that are able to model such circuits is essential to further evaluating the security of cyclic obfuscation. Extensive layout level characterization and implementation utilizing dummy gates is also a significant future direction.     </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (a) IC camouflaging by replacing gates with camouflaged gates. (b) Logic locking with tamper-proof key inputs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: (a) FPGA programmable logic with configurable interconnects. (b) A circuit with known components but unknown interconnects is greatly unintelligible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Directed graph model of Boolean circuit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Reducible and non-reducible loops.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>are n m ways to open it by removing m edges. Thus in total there are n m=1 n m = 2 n -1 ways to open a loop with n removable edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 1 6 :feed v back to u 8 :</head><label>168</label><figDesc>Obfuscate circuit Co with N loops of length M (attack complexity is (2 M ) N ). 1: function CYCLICOBFUSCATE(Co, N , u to find path of length M until path of length M found 7:for each g on path (u, v) do</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Area overhead of cyclic logic locking with 6 loops of length 6 versus XOR/XNOR locking with the same number of keybits(72).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Delay overhead (M = N = 6).</figDesc><graphic coords="6,377.87,384.73,411.46,111.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Layout-level cyclic camouflaging with 4 loops of length 4 on the small c432 circuit. Figure (a) shows the original circuit and Figure (b) shows the original routing. In Figure (c) the placement of the dummy vias are shown. As seen from Figure (d) the routed camouflaged circuit only contributes to wire overhead.</figDesc><graphic coords="6,156.71,384.25,411.16,114.11" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>17, May 10-12, 2017, Banff, AB, Canada c 2017 ACM. ISBN 978-1-4503-4972-7/17/05. . . 15.00 DOI: http://dx.doi.org/10.1145/3060403.3060458 Protection provided by obfuscation schemes against a malicious end-user or foundry.</figDesc><table><row><cell>Defense</cell><cell>Reverse engineering</cell><cell>Trojan Insertion</cell><cell>Overproduction</cell></row><row><cell>IC Camouflaging</cell><cell>by user only</cell><cell>no protection</cell><cell>no protection</cell></row><row><cell>Logic Locking</cell><cell>by user &amp; foundry</cell><cell>by foundry</cell><cell>by foundry</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>are notFigure 5: Add-edge operations: (a) Nullify with key-gate. (b) Choose with key-controlled MUX.Figure 6: Cyclic logic locking example ensuring the removabillity of edges on path.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>w 0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>w 0</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>w 1</cell><cell>g 1 (a)</cell><cell></cell><cell></cell><cell>w 1 k 0 w 0</cell><cell></cell><cell cols="2">g 1 g 1</cell><cell></cell><cell></cell><cell>w 1</cell><cell>g 1 (b)</cell><cell>w 0 w 1</cell><cell>k 0</cell><cell>g 1 g 1</cell></row><row><cell></cell><cell>w 0</cell><cell>g 1 g 1</cell><cell></cell><cell>w 1</cell><cell>g 2 g 2</cell><cell cols="2">w 2</cell><cell>g 3</cell><cell>w 3</cell><cell></cell><cell></cell><cell>w 0</cell><cell>M0 k 0</cell><cell>g 1 g 1</cell><cell>w 1</cell><cell>M1 k 1</cell><cell>g 2 g 2</cell><cell>w 2</cell><cell>M2</cell><cell>g 3</cell><cell>w 3</cell></row><row><cell></cell><cell>r 0</cell><cell></cell><cell></cell><cell></cell><cell>r 1</cell><cell></cell><cell></cell><cell>r 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>r 0</cell><cell></cell><cell>r 1</cell><cell>M3 k 2 k 2 r 2</cell></row><row><cell>i 2</cell><cell></cell><cell></cell><cell>o</cell><cell cols="3">Dummy or Programmable Contacts</cell><cell>i 2</cell><cell>o</cell><cell>i 1</cell><cell>i 1 i 2</cell><cell>MUX</cell><cell>o</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>i 1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>k</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="13">Figure 7: 2-to-1 MUX with dummy contacts or one-time-</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">programmable vias.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">ISCAS</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">MCNC</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>circuit</cell><cell cols="2">#inputs</cell><cell cols="2">#outputs</cell><cell>#gates</cell><cell cols="2">circuit</cell><cell cols="2">#inputs</cell><cell cols="2">#outputs</cell><cell cols="2">#gates</cell><cell></cell><cell></cell><cell></cell></row><row><cell>c432</cell><cell>36</cell><cell></cell><cell cols="2">7</cell><cell>160</cell><cell cols="2">apex2</cell><cell cols="2">39</cell><cell>3</cell><cell></cell><cell>610</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>c499</cell><cell>41</cell><cell></cell><cell cols="2">32</cell><cell>202</cell><cell></cell><cell>ex5</cell><cell cols="2">8</cell><cell>63</cell><cell></cell><cell cols="2">1055</cell><cell></cell><cell></cell><cell></cell></row><row><cell>c880</cell><cell>60</cell><cell></cell><cell cols="2">26</cell><cell>383</cell><cell></cell><cell>i9</cell><cell cols="2">88</cell><cell>63</cell><cell></cell><cell cols="2">1315</cell><cell></cell><cell></cell><cell></cell></row><row><cell>c1355</cell><cell>41</cell><cell></cell><cell cols="2">32</cell><cell>546</cell><cell></cell><cell>i7</cell><cell cols="2">199</cell><cell>67</cell><cell></cell><cell cols="2">1581</cell><cell></cell><cell></cell><cell></cell></row><row><cell>c1908</cell><cell>33</cell><cell></cell><cell cols="2">25</cell><cell>880</cell><cell></cell><cell>k2</cell><cell cols="2">46</cell><cell>45</cell><cell></cell><cell cols="2">1815</cell><cell></cell><cell></cell><cell></cell></row><row><cell>c2670</cell><cell>157</cell><cell></cell><cell cols="2">64</cell><cell>1193</cell><cell cols="2">ex1010</cell><cell cols="2">10</cell><cell>10</cell><cell></cell><cell cols="2">5066</cell><cell></cell><cell></cell><cell></cell></row><row><cell>c3540</cell><cell>50</cell><cell></cell><cell cols="2">22</cell><cell>1669</cell><cell></cell><cell>des</cell><cell cols="2">256</cell><cell>245</cell><cell></cell><cell cols="2">6437</cell><cell></cell><cell></cell><cell></cell></row><row><cell>c5315</cell><cell>178</cell><cell></cell><cell cols="2">123</cell><cell>2307</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>c7552</cell><cell>207</cell><cell></cell><cell cols="2">108</cell><cell>3512</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Loop count and length versus loop complexity (number of possible ways to open loops), and delay/area overhead% for the c432 circuit. loop complexity can be a measure of security.</figDesc><table><row><cell>cycle length</cell><cell></cell><cell>3</cell><cell></cell><cell></cell><cell>4</cell><cell></cell><cell></cell><cell>6</cell><cell></cell><cell></cell><cell>8</cell><cell></cell><cell></cell><cell>12</cell><cell></cell></row><row><cell>cycle count</cell><cell>area</cell><cell>delay</cell><cell>comp</cell><cell>area</cell><cell>delay</cell><cell>comp</cell><cell>area</cell><cell>delay</cell><cell>comp</cell><cell>area</cell><cell>delay</cell><cell>comp</cell><cell>area</cell><cell>delay</cell><cell>comp</cell></row><row><cell>2</cell><cell>12.21</cell><cell>2.88</cell><cell>64</cell><cell>24.59</cell><cell>5.08</cell><cell>256</cell><cell>19.07</cell><cell>11.47</cell><cell>4096</cell><cell>18.12</cell><cell>11.95</cell><cell>10 4</cell><cell>29.74</cell><cell>13.19</cell><cell>10 7</cell></row><row><cell>3</cell><cell>17.93</cell><cell>6.07</cell><cell>512</cell><cell>17.74</cell><cell>7.64</cell><cell>4096</cell><cell>24.02</cell><cell>9.31</cell><cell>10 5</cell><cell>46.88</cell><cell>43.79</cell><cell>10 7</cell><cell>50.89</cell><cell>16.04</cell><cell>10 10</cell></row><row><cell>4</cell><cell>20.21</cell><cell>4.42</cell><cell>4096</cell><cell>23.64</cell><cell>7.41</cell><cell>10 4</cell><cell>28.02</cell><cell>18.34</cell><cell>10 7</cell><cell>46.50</cell><cell>16.07</cell><cell>10 9</cell><cell>52.41</cell><cell>14.22</cell><cell>10 14</cell></row><row><cell>6</cell><cell>23.45</cell><cell>8.02</cell><cell>10 5</cell><cell>34.31</cell><cell>-3.40</cell><cell>10 7</cell><cell>39.45</cell><cell>22.58</cell><cell>10 10</cell><cell>76.60</cell><cell>46.30</cell><cell>10 14</cell><cell>102.51</cell><cell>44.64</cell><cell>10 21</cell></row><row><cell>8</cell><cell>48.22</cell><cell>36.40</cell><cell>10 7</cell><cell>50.50</cell><cell>38.27</cell><cell>10 9</cell><cell>54.50</cell><cell>14.47</cell><cell>10 14</cell><cell>91.85</cell><cell>30.31</cell><cell>10 19</cell><cell>111.85</cell><cell>36.81</cell><cell>10 28</cell></row><row><cell>200</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>150</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>xor</cell><cell>cyclic</cell><cell></cell></row><row><cell>100</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>50</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For most logic locking schemes the obfuscation secret or key is the physical key. For IC camouflaging the key is an abstract variable that decides the function of camouflaged logic. We will use key to refer to both.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Note that having g gates and infinite interconnect resources may not implement all 2 2 n Boolean functions but for sufficiently large values of g implements a prohibitively large number of functions for an attacker to prune.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.nangate.com/?page_id=2328" />
		<title level="m">Nangate freepdk15 open cell library</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The minimum feedback arc set problem is np-hard for tournaments</title>
		<author>
			<persName><forename type="first">P</forename><surname>Charbit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thomassé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yeo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorics, Probability and Computing</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">01</biblScope>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Chip-level anti-reverse engineering using transformable interconnects</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Di</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tehranipoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Symp. Defect and Fault Tolerance in VLSI and Nanotechnology Systems</title>
		<meeting>IEEE Int. Symp. Defect and Fault Tolerance in VLSI and Nanotechnology Systems</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="109" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Circuit camouflage integration for hardware ip protection</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Cocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Baukus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">W</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Integrated circuit (ic) decamouflaging: Reverse engineering camouflaged ics within minutes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">El</forename><surname>Massad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Tripunitara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Characterizations of reducible flow graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Hecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="367" to="375" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Provably secure camouflaging strategy for ic protection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shamsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Meade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. on Computer Aided Design</title>
		<meeting>Int. Conf. on Computer Aided Design</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">28</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A survey on chip to system reverse engineering</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Quadir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Asadizanjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shahbazmohamadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tehranipoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Journal on Emerging Technologies in Computing Systems (JETC)</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">6</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Logic encryption: A fault analysis perspective</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design, Automation and Test in Eurpoe</title>
		<meeting>Design, Automation and Test in Eurpoe</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="953" to="958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Security analysis of logic obfuscation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="83" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Vlsi testing based security metric for ic camouflaging</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Test Conf</title>
		<meeting>IEEE Int. Test Conf</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Regaining trust in vlsi design: Design-for-trust techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1266" to="1282" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fault analysis-based logic encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Rose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="410" to="424" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Epic: Ending piracy of integrated circuits</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Koushanfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Markov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design, Automation and Test in Eurpoe, DATE &apos;08</title>
		<meeting>Design, Automation and Test in Eurpoe, DATE &apos;08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1069" to="1074" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Protecting bus-based hardware ip by secret sharing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Koushanfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Markov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 45th annual Design Automation Conference</title>
		<meeting>the 45th annual Design Automation Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="846" to="851" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Chip editor: leveraging circuit edit for logic obfuscation and trusted fabrication</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shakya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Asadizanjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tehranipoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th International Conference on Computer-Aided Design</title>
		<meeting>the 35th International Conference on Computer-Aided Design</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">30</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Appsat: Approximately deobfuscating integrated circuits</title>
		<author>
			<persName><forename type="first">K</forename><surname>Shamsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Meade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Z</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Hardware-Oriented Security and Trust</title>
		<meeting>IEEE Symp. Hardware-Oriented Security and Trust</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Evaluating the security of logic encryption algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Subramanyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Hardware-Oriented Security and Trust</title>
		<meeting>IEEE Symp. Hardware-Oriented Security and Trust</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="137" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Reversing stealthy dopant-level circuits</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sugawara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suzuki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fujii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shiozaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Fujino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="112" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Physical design obfuscation of hardware: A comprehensive investigation of device and logic-level techniques</title>
		<author>
			<persName><forename type="first">A</forename><surname>Vijayakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Holcomb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Paar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kundu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="77" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Tpad: Hardware trojan prevention and detection for trusted integrated circuits</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ganesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-S</forename><forename type="middle">P</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mitra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Hardware trojans: Lessons learned after one decade of research</title>
		<author>
			<persName><forename type="first">K</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Forte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhunia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tehranipoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Design Automation of Electronic Systems (TODAES)</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">6</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Mitigating sat attack on logic locking</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Srivastava</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2016/590.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Sarlock: Sat attack resistant logic locking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yasin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mazumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Hardware-Oriented Security and Trust</title>
		<meeting>IEEE Symp. Hardware-Oriented Security and Trust</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="236" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Yasin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mazumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2016/896.pdf" />
		<title level="m">Security analysis of anti-sat</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Camoperturb: secure ic camouflaging for minterm protection</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yasin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mazumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Sinanoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rajendran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. on Computer Aided Design</title>
		<meeting>Int. Conf. on Computer Aided Design</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">29</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
