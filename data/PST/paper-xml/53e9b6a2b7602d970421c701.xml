<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Local closed world reasoning with description logics under the well-founded semantics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-01-26">26 January 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Matthias</forename><surname>Knorr</surname></persName>
							<email>mknorr@di.fct.unl.pt</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Departamento de Informática</orgName>
								<orgName type="department" key="dep2">FCT/UNL</orgName>
								<orgName type="institution" key="instit1">CENTRIA</orgName>
								<orgName type="institution" key="instit2">Quinta da Torre</orgName>
								<address>
									<postCode>2829-516</postCode>
									<settlement>Caparica</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">José</forename><forename type="middle">Júlio</forename><surname>Alferes</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Departamento de Informática</orgName>
								<orgName type="department" key="dep2">FCT/UNL</orgName>
								<orgName type="institution" key="instit1">CENTRIA</orgName>
								<orgName type="institution" key="instit2">Quinta da Torre</orgName>
								<address>
									<postCode>2829-516</postCode>
									<settlement>Caparica</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pascal</forename><surname>Hitzler</surname></persName>
							<email>pascal@pascal-hitzler.de</email>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Kno.e.sis Center</orgName>
								<orgName type="department" key="dep2">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Wright State University</orgName>
								<address>
									<addrLine>3640 Colonel Glenn Hwy</addrLine>
									<postCode>45435</postCode>
									<settlement>Dayton</settlement>
									<region>OH</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Local closed world reasoning with description logics under the well-founded semantics</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-01-26">26 January 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">D2A4A6F750E9378E67030B93948E4A17</idno>
					<idno type="DOI">10.1016/j.artint.2011.01.007</idno>
					<note type="submission">Received 24 September 2009 Received in revised form 21 January 2011 Accepted 23 January 2011</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Knowledge representation Description logics and ontologies Non-monotonic reasoning Logic programming Semantic Web</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An important question for the upcoming Semantic Web is how to best combine open world ontology languages, such as the OWL-based ones, with closed world rule-based languages. One of the most mature proposals for this combination is known as hybrid MKNF knowledge bases (Motik and Rosati, 2010 [52]), and it is based on an adaptation of the Stable Model Semantics to knowledge bases consisting of ontology axioms and rules. In this paper we propose a well-founded semantics for nondisjunctive hybrid MKNF knowledge bases that promises to provide better efficiency of reasoning, and that is compatible with both the OWL-based semantics and the traditional Well-Founded Semantics for logic programs. Moreover, our proposal allows for the detection of inconsistencies, possibly occurring in tightly integrated ontology axioms and rules, with only little additional effort. We also identify tractable fragments of the resulting language.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction and motivation</head><p>The Semantic Web has recently become a major source of inspiration for Knowledge Representation and Reasoning (KRR). The underlying idea of the Semantic Web is to use KRR techniques to enhance data in the World Wide Web with knowledge bases, making this data available for processing by intelligent systems. Semantic Web has become a mature field of research, and industrial applications of Semantic Web technologies are on the way. Semantic Web is a topic that is clearly here to stay.</p><p>However, we believe that the KRR formalisms used in the Semantic Web are not adequate for several application areas within the Semantic Web. We therefore motivate in this section why KRR formalisms combining open and closed world reasoning are sometimes preferable over fragments of classical first-order logics, and we present application scenarios illustrating the requirement for that combination. Then, we show the limitations of already existing approaches, and we state the main contributions of our proposal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Open vs. closed world reasoning</head><p>The most prominent expressive KRR approach employed in Semantic Web research is based on Description Logics <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>In particular, the Web Ontology Language OWL <ref type="bibr" target="#b25">[26]</ref> is based on the description logic SROIQ(D), and it is a recommended standard by the World Wide Web Consortium (W3C) for modelling Semantic Web knowledge bases (commonly known as ontologies).</p><p>Description Logics (DLs), in turn, bear a first-order predicate logic semantics. DLs are monotonic and adhere to the Open World Assumption (OWA). This means that (negative) conclusions drawn from a knowledge base must be based on information explicitly present in the knowledge base. Being based on classical first-order logic, DLs differ from other KRR formalisms, e.g., those studied in the non-monotonic reasoning field, that usually apply the Closed World Assumption (CWA). Under that assumption, all non-provable expressions are assumed to be false.</p><p>The decision to rely on the OWA appears to be a natural one in light of the envisioned applications related to the World Wide Web: the absence of a piece of knowledge should not generally be taken as an indication that this piece of knowledge is false. However, there are also application scenarios where the CWA, or at least the partial closure of the knowledge base, is a more natural choice. Such scenarios can occur, e.g., if ontology-based reasoning is done in conjunction with data stored in a database. Database data is usually considered to be complete, and so statements not in the database should be taken as false.</p><p>As an example where a combination of open and closed world assumption is desired, consider the large case study described in <ref type="bibr" target="#b53">[54]</ref>, containing millions of assertions about matching patient records with clinical trials criteria. In this clinical domain, open world reasoning is needed in radiology and laboratory data. For example, unless a lab test asserts a negative finding, no arbitrary assumptions about the results of the test can be made. That is, we can only be certain that some patient does not have a specific kind of cancer if the corresponding test has a negative result. However, as observed in <ref type="bibr" target="#b53">[54]</ref>, the closed world assumption can and should be used with data about medical treatment to infer that a patient is not on a medication unless otherwise stated. The work of <ref type="bibr" target="#b53">[54]</ref> applies only open world reasoning but claims that the usage of closed world reasoning in data about medical treatment would be highly desirable and that the combination of OWA and CWA is an open problem in their work. Similar situations occur, e.g., in matchmaking using Semantic Web Services (cf. <ref type="bibr" target="#b21">[22]</ref>), and in other scenarios in the medical domain.</p><p>In fact, life sciences, including medicine, is a prominently studied application area for OWL. Several large-scale ontologies have been developed in this area that are being used in practice, such as GALEN <ref type="foot" target="#foot_0">1</ref> and SNOMED. <ref type="foot" target="#foot_1">2</ref> These ontologies provide unified medical terminologies for the management and exchange of clinical information. The knowledge bases typically consist of information about anatomy, diseases, procedures, drugs, etc., and their applications range from medical record management to diagnostics support. SNOMED is used, for example, in the case study described above. All of these applications use ontology reasoning based on the OWA. But it is not difficult to foresee situations in these domains that would benefit from local closed world reasoning. Consider, for example, that such a medical knowledge base is used to decide whether a certain anaesthetic should be applied before surgery, depending on whether the patient is allergic to the anaesthetic or not. This information might not be available, and it should be modelled using the CWA: in an emergency situation, unless we know explicitly about an allergy, we assume that the patient is not allergic, and we apply the anaesthetic. Other examples can be found if we were to model exceptions in anatomical terminology; e.g., the existence of persons whose heart is actually on the right-hand side. Exception modelling is not directly possible in classical first-order logic (this is a problem usually known in Artificial Intelligence as the specification problem) and so also not possible in OWL using only the OWA.</p><p>All of these examples demonstrate why application developers frequently voice that it would be favourable to have local closed world modelling as an additional feature for ontology-based systems. More precisely, it would be desirable to have a KRR formalism that allows us to interpret some parts of the knowledge base under the CWA, and others under the OWA. Such capabilities would considerably enhance the usability of OWL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Combining rules and ontologies</head><p>Ontologies are a standard OWA formalism while rules usually apply the CWA. A combination of ontologies and rules would clearly yield a combination of the OWA and the CWA. However, combining rules and ontologies is a non-trivial task, since a naive combination of ontologies and OWA-based rules is already undecidable <ref type="bibr" target="#b31">[32]</ref>. In fact, formalisms for rules and formalisms for ontologies differ substantially on how decidability is achieved. For ontologies, decidability is achieved by specific syntactic restrictions on the available first-order predicates, and by restricting the way these predicates can be related. Rules do not have such syntactic restrictions, but are usually limited in their applicability to the finitely many different objects explicitly appearing in the knowledge base. An immediate effect of these differences is that some expressive features of one of the approaches are not available in the other approach. Namely, rules make it possible to express: nontreeshape-like relationships <ref type="bibr" target="#b61">[62]</ref> <ref type="foot" target="#foot_2">3</ref> such as "an uncle is the brother of one's father"; integrity constraints <ref type="bibr" target="#b55">[56]</ref> to state, e.g., that a certain piece of information is explicitly present in the database; and closed world reasoning and specification of exceptions, as discussed above. Ontologies, on the contrary, make it possible to express open world reasoning, reason with unbounded or infinite domains, and they are thus well suited to represent many types of incomplete information and schema knowledge. For example, in rule-based formalisms one typically cannot say that "every person has a father and a mother who are both persons" without listing all the parents explicitly. Our stance is that a combination of rules and ontologies is not only of interest for current applications in the web, but also as a highly sophisticated means of knowledge representation in general.</p><p>As argued in <ref type="bibr" target="#b51">[52]</ref>, a hybrid formalism combining rules and DL ontologies should satisfy certain criteria:</p><p>• Faithfulness: The integration of DLs and rules should preserve the semantics of both formalisms -that is, the semantics of a hybrid knowledge base in which one component is empty should be the same as the semantics of the other component. In other words, the addition of rules to a DL should not change the semantics of the DL and vice versa.</p><p>• Tightness: Rules should not be layered on top of a DL or vice versa; rather, the integration between a DL and rules should be tight in the sense that both the DL and the rule component should be able to contribute to the consequences of the other component.</p><p>• Flexibility: The hybrid formalism should be flexible and allow one to view the same predicate under both open and closed world interpretation. This allows us to enrich a DL with non-monotonic consequences from rules, and to enrich the rules with the capabilities of ontology reasoning described by a DL.</p><p>• Decidability: To obtain a useful formalism that can be used in applications such as the Semantic Web, the hybrid formalism should be at least decidable, and preferably of low worst-case complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Hybrid MKNF and stable models vs. well-founded semantics</head><p>As shown in <ref type="bibr" target="#b51">[52]</ref>, among the various proposals for combining rules and ontologies (e.g. <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b38">[39]</ref><ref type="bibr" target="#b39">[40]</ref><ref type="bibr" target="#b40">[41]</ref><ref type="bibr" target="#b41">[42]</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b51">52,</ref><ref type="bibr" target="#b57">58]</ref>) the only one satisfying all four criteria above are Hybrid MKNF knowledge bases <ref type="bibr" target="#b51">[52]</ref>, which build on the logics of Minimal Knowledge and Negation as Failure (MKNF) <ref type="bibr" target="#b46">[47]</ref>. A detailed discussion about the importance of Hybrid MKNF knowledge bases for modelling knowledge in the Semantic Web can be found in <ref type="bibr" target="#b30">[31]</ref>, and <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref> provide arguments for the usefulness of epistemic reasoning in the way it is done in MKNF logics. The proposal by Motik and Rosati <ref type="bibr" target="#b51">[52]</ref> seamlessly integrates arbitrary decidable description logics with essentially (disjunctive) logic programming rules, making it possible to reason over a combination of monotonic open world knowledge and non-monotonic closed world knowledge within a single (hybrid) framework.</p><p>Several reasoning algorithms are presented in <ref type="bibr" target="#b51">[52]</ref> for Hybrid MKNF knowledge bases, and it is shown that the data complexity of reasoning within this framework is in many cases not higher than reasoning in the corresponding fragment of logic programming. Thus, adding an ontology to rules does not in general increase the data complexity when compared to rules alone. But the same cannot be said about adding rules to ontologies. E.g., we have at least a data complexity of coNP for a combination of normal logic programming rules with ontologies even if the data complexity of the Description Logics fragment is in the complexity class P. Indeed, although the approach of Hybrid MKNF knowledge bases is powerful, whenever we add rules with arbitrary non-monotonic negation to an ontology, we in general loose tractability. Only a specific limited use of non-monotonic negation, i.e. stratified rules, admits to maintain tractability (see <ref type="bibr" target="#b51">[52]</ref>). However, we claim that robustness w.r.t. updates and the combination of different sources of information is an important property of a combination of rules and ontologies. Since it cannot be guaranteed that this property is maintained in such cases, we obtain a higher computational complexity in general.</p><p>The reason for that increase in the complexity lies in the fact that, as shown in <ref type="bibr" target="#b46">[47]</ref>, rules are interpreted in a similar way as in the Stable Model Semantics (SMS) <ref type="bibr" target="#b18">[19]</ref> for logic programs, whose reasoning algorithms are NP-hard. So, if a semantics based on the SMS is adopted, then any improvements on the complexity of the combination of rules and ontologies are bound by NP-hardness.</p><p>The other major semantics for Logic Programming (LP) -the Well-Founded Semantics (WFS) <ref type="bibr" target="#b60">[61]</ref> -seems to offer a solution. WFS is a three-valued semantics, where propositions can be 'true', 'false' or 'undefined' (while in SMS propositions can only be 'true' or 'false'), and WFS assigns a single model -the well-founded model -to every nondisjunctive logic program. The WFS is sound with respect to the SMS, in that whenever a proposition is true (resp. false) under the WFS, then it is also true (resp. false) in all stable models. Though the WFS is semantically weaker than SMS (in terms of the derivable true and false consequences), reasoning in the WFS has a lower computational complexity than in SMS -for normal programs the data complexity is P for the WFS instead of coNP for SMS <ref type="bibr" target="#b6">[7]</ref>. Our stance is that the lower complexity bound makes WFS more promising than SMS as a basis for the semantics of hybrid knowledge bases. This is even more the case in application areas such as the one mentioned above <ref type="bibr" target="#b53">[54]</ref> where huge amounts of data are involved.</p><p>Additionally, reasoning in SMS requires one to obtain the entire model of a knowledge base (just like <ref type="bibr" target="#b51">[52]</ref> for combinations of rules and ontologies), while the WFS is amenable to top-down, query-driven reasoning, in which only the part of the knowledge base "relevant" to a specific query is accessed <ref type="bibr" target="#b5">[6]</ref>. This makes a WFS based approach all the more suitable for large scale applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4.">Contribution</head><p>In this paper, we define a new semantics for Hybrid MKNF knowledge bases, restricted to nondisjunctive rules, that soundly approximates the semantics of <ref type="bibr" target="#b51">[52]</ref> but is, in some important cases, in a strictly lower complexity class. In particular, when dealing with a tractable description logic, our combined approach remains tractable w.r.t. data complexity. We achieve this by extending the two-valued MKNF semantics from <ref type="bibr" target="#b51">[52]</ref> to three truth values where each two-valued model from <ref type="bibr" target="#b51">[52]</ref> corresponds to a total three-valued model of our approach (and vice versa) and where the least (w.r.t. derivable knowledge) three-valued MKNF model is the well-founded MKNF model. Our proposal straightforwardly satisfies the four criteria presented above for the combination of rules and ontologies. Moreover, the proposed semantics also guarantees the following properties:</p><p>• The well-founded MKNF model is faithful w.r.t. the two-valued MKNF models of <ref type="bibr" target="#b51">[52]</ref>, i.e. each query that is true (resp. false) in the well-founded MKNF model is also true (resp. false), in each two-valued MKNF model.</p><p>• Our proposal coincides with the original DL-semantics when no rules are present, and the original WFS of logic programs if the DL component is empty.</p><p>• If the knowledge base is consistent, then the approach is coherent in the sense of <ref type="bibr" target="#b54">[55]</ref>, i.e. if a formula ϕ is first-order false in the ontology, then the non-monotonic interpretation of ϕ in the rules is enforced to be false as well.</p><p>• If the knowledge base is inconsistent, then our approach allows us to detect inconsistencies without any substantial additional computational effort apart from the consistency check of the ontology alone.</p><p>• The computational data complexity of our approach depends on the computational complexity of the applied DL, but if the considered DL is of polynomial data complexity, then the combination with rules remains polynomial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5.">Outline and running example</head><p>The rest of the paper is structured as follows. We first recall, in Section 2, preliminaries on Description Logics, the logics of Hybrid MKNF, and Hybrid MKNF knowledge bases. Then, in Section 3, we present our semantic framework that extends MKNF semantics to three truth values, based on which the well-founded MKNF model is defined. In Section 4 we show how to construct the well-founded MKNF model and also how the inconsistency detection works. A comparison to related work is presented in Section 5, before we conclude in Section 6. <ref type="foot" target="#foot_3">4</ref>Throughout the paper, we make use of the following toy example.</p><p>Example 1. Consider an online store selling audio CDs. In order to attract more clients and raise sales, the store manager decided to introduce more sophisticated tools for recommending and searching CDs.</p><p>For that purpose, an ontology is used for structuring and maintaining the database of CDs. Each CD is associated with a unique identifier, a publisher, a release date, and the pieces of music the CD contains. Each piece of music has at least one track, and it is possible that a piece has several tracks (as is common for classical music). Additionally, each piece has a unique identifier and can be associated with the artist, composer, genre, origin of the piece. Moreover, the system should be able to express guidelines for recommendations, either based on general criteria or based on customer specifications. For example, the store may want to automatically recommend to all customers CDs that are on offer or top sellers. Or some customer may want to get recommendations for CDs that he does not already own and that, according to some preference criteria, he probably likes. Whereas the first guideline can be represented in the ontology, the second one requires the closed world assumption (e.g., for inferring "by default", i.e., in the absence of evidence to the contrary, that the customer does not have the CD) and can be represented by a non-monotonic rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>In this section we recall preliminary notions that are needed in the rest of the paper. In detail, we present general notions for Description Logics, the logics of minimal knowledge and negation as failure, and Hybrid MKNF knowledge bases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Description logics</head><p>We focus the presentation in this subsection on the description logic ALC, a foundational description logic for the research around OWL. However, our approach is basically independent of the underlying description logic, and the reader familiar with description logics will have no difficulty in applying our approach to more expressive description logics such as SHOIN or SROIQ, that underlie OWL, resp. OWL 2. <ref type="foot" target="#foot_4">5</ref> We also recall some standard extensions appearing, for example, in lightweight description logics such as EL ++ <ref type="bibr" target="#b1">[2]</ref>. For further background on description logics we refer to <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>The basic elements to represent knowledge in DLs are: individuals, which represent objects in a domain of discourse; concepts, which group together individuals with common properties; and roles, which relate individuals. Based on the sets N I , N C , and N R of individual names, concept names, and role names, respectively, the syntactic elements of ALC are constructed according to the following grammar (in which A ∈ N C denotes an atomic concept, C (i) denote complex concepts, r ∈ N R denotes a role, and a i ∈ N I denote individuals):</p><formula xml:id="formula_0">C (i) -→ ⊥ | | A | ¬C | C 1 C 2 | C 1 C 2 | ∃r.C | ∀r.C</formula><p>The semantics of the syntactic elements of ALC is defined in terms of interpretations. An interpretation I = ( I , • I ) consists of a non-empty set I -the domain of I -and an interpretation function • I that maps each individual a ∈ N I to a distinct element a I ∈ I , each concept name A ∈ N C to a set A I ⊆ I , and each role name r ∈ N R to a relation r I ⊆ I × I .</p><p>An interpretation can be extended to complex concepts as follows: ALC can be extended in several ways, and one common extension is the addition of role inclusion axioms in the TBox.</p><formula xml:id="formula_1">I = I ⊥ I = ∅ (C 1 C 2 ) I = C I 1 ∩ C I 2 (C 1 C 2 ) I = C I 1 ∪ C I 2 (¬C) I = I \ C I (∀r.C) I = x ∈ I ∀y.(x,</formula><p>Since we use role inclusions in the running example, we recall them here as well. A role inclusion is an axiom of the form </p><p>HasArtist(BlueTrain, JohnColtrane)</p><p>Axiom <ref type="bibr" target="#b0">(1)</ref> states that each CD consists of at least one piece, and axiom (2) expresses that each piece of music has an artist. The role composition axiom (3) states that if x is related to y by HasPiece and y is related to z by HasArtist, then x is related to z by HasArtist, i.e. HasArtist is a left-identity role. (1)-(3) alone allow us to derive, e.g., that the artist of a piece on a certain CD is an artist of that CD. Note that this conclusion can be drawn without any present CDs, artists or pieces of music, as intended when reasoning with schema knowledge in an infinite domain. Of course, once specific information is available (assertions (5) and ( <ref type="formula" target="#formula_3">6</ref>)), we are able to derive, e.g., that John Coltrane is an artist of the album BNAW, and likewise for all the other artists on that CD not explicitly mentioned in the example.</p><p>Axiom (4) expresses one general guideline for recommendations: CDs that are on offer or top sellers are automatically recommended to the customers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Logics of minimal knowledge and negation as failure</head><p>The logic of minimal knowledge and negation as failure (MKNF) <ref type="bibr" target="#b46">[47]</ref> extends first-order logic with two modal operators K and not that inspect the knowledge base: intuitively, given a first-order formula ϕ, K ϕ asks whether ϕ is known while not ϕ is used to check whether ϕ is not known. The two modal operators permit local closed world reasoning. In particular, the operator not allows one to draw conclusions from the absence of information, in a way similar to that of default negation in Logic Programming. We present below the syntax and the semantics of MKNF as introduced in <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b51">52]</ref>.</p><p>Let Σ = (Σ c , Σ f , Σ p ) be a first-order signature, where Σ c is a set of constants, Σ f is a set of function symbols, and Σ p is a set of predicates containing the binary equality predicate ≈. The syntax of MKNF formulas over Σ is defined as follows.</p><p>A first-order atom P (t 1 , . . . , t n ) is an MKNF formula where P is a predicate and t i are first-order terms. If ϕ is an MKNF formula, then ¬ϕ, ∃x: ϕ, K ϕ, and not ϕ are MKNF formulas and likewise ϕ 1 ∧ ϕ 2 for MKNF formulas ϕ 1 , ϕ 2 . Moreover, ϕ 1 ∨ ϕ 2 , ϕ 1 ⊃ ϕ 2 , ϕ 1 ≡ ϕ 2 , ∀x: ϕ, t, f, t 1 ≈ t 2 , and t 1 ≈ t 2 are abbreviations, respectively, for ¬(¬ϕ 1 ∧ ¬ϕ 2 ), ¬ϕ 1 ∨ ϕ 2 , (ϕ 1 ⊃ ϕ 2 ) ∧ (ϕ 2 ⊃ ϕ 1 ), ¬(∃x: ¬ϕ), a ∨ ¬a, a ∧ ¬a, ≈ (t 1 , t 2 ), and ¬(t 1 ≈ t 2 ). First-order atoms of the form t 1 ≈ t 2 (resp. t 1 ≈ t 2 ) are called equalities (resp. inequalities), and ϕ[t 1 /x 1 , . . . , t n /x n ] denotes the formula obtained by substituting the free variables x i in ϕ (i.e. the variables that are not in the scope of any quantifier) by the terms t i . Given a (first-order) formula ϕ, K ϕ is called a modal K-atom and not ϕ a modal not-atom; modal K-atoms and not-atoms are modal atoms. An MKNF formula ϕ is called strict, if there is no modal atom in ϕ that occurs in the scope of a modal operator. An MKNF formula ϕ without any free variables is closed, and an MKNF formula ϕ is ground if ϕ does not contain variables at all. An MKNF formula ϕ is modally closed if all modal operators (K and not) are applied in ϕ only to closed subformulas, and ϕ is positive if ϕ does not contain the operator not. An MKNF formula ϕ is subjective if all first-order atoms of ϕ occur within the scope of a modal operator, and ϕ is flat if ϕ is subjective and all occurrences of modal atoms in ϕ are strict.</p><p>Let Σ be a signature and a universe. A first-order interpretation I over Σ and assigns an object a I ∈ to each constant a ∈ Σ c , a function f I : n → to each n-ary function symbol f ∈ Σ f , and a relation P I ⊆ n to each n-ary predicate P ∈ Σ p . Furthermore, I interprets the predicate ≈ as equality -i.e., for α, β ∈ , we have (α, β)</p><formula xml:id="formula_4">∈ ≈ I iff α = β. Unlike in standard first-order logic, for each element α ∈ Σ , the signature Σ is required to contain a special constant n α - called a name -such that n I α = α. The interpretation of a variable-free term t = f (s 1 , . . . , s n ) is defined recursively as t I = f I (s I 1 , . . . , s I n ).</formula><p>The semantics of an MKNF formula over a signature Σ (henceforth considered implicit in all definitions) is defined as follows. An MKNF structure is a triple (I, M, N) where I is a first-order interpretation over and Σ , and M and N are nonempty sets of first-order interpretations over and Σ . Given an MKNF structure (I, M, N), satisfiability of closed MKNF formulas is defined as follows:</p><formula xml:id="formula_5">(I, M, N) | P (t 1 , . . . , t n ) iff t I 1 , . . . , t I n ∈ P I (I, M, N) | ¬ϕ iff (I, M, N) | ϕ (I, M, N) | ϕ 1 ∧ ϕ 2 iff (I, M, N) | ϕ 1 and (I, M, N) | ϕ 2 (I, M, N) | ∃x: ϕ iff (I, M, N) | ϕ[n α /x] for some α ∈ (I, M, N) | K ϕ iff ( J , M, N) | ϕ for all J ∈ M (I, M, N) | not ϕ iff ( J , M, N) | ϕ for some J ∈ N</formula><p>Note that the evaluation of K and not are kept separate in this definition of satisfiability. The relation between these operators is established in the notion of a two-valued MKNF model defined below.</p><p>An MKNF interpretation M over a universe is a non-empty set of first-order interpretations. For a closed MKNF formula ϕ, we say that M satisfies ϕ,</p><formula xml:id="formula_6">written M | ϕ, if (I, M, M) | ϕ for each I ∈ M.</formula><p>The notion of a two-valued MKNF model of a closed MKNF formula ϕ is based on a preference relation on MKNF interpretations that satisfy ϕ. More precisely, an</p><formula xml:id="formula_7">MKNF interpretation M over is a two-valued MKNF model of a closed MKNF formula ϕ if (1) M satisfies ϕ, and (2) for each MKNF interpretation M such that M ⊃ M we have (I , M , M) | ϕ for some I ∈ M . An MKNF formula ϕ is MKNF sat- isfiable if a two-valued MKNF model of ϕ exists; otherwise ϕ is MKNF unsatisfiable. Furthermore, ϕ MKNF entails ψ , written ϕ | MKNF ψ , if M | ψ for each two-valued MKNF model M of ϕ.</formula><p>Note that this definition of model is asymmetric in the treatment of the modal operators K and not. In fact, the maximisation of M in (2) is only done in the component of the structure used for evaluating the operator K. This results in a minimisation of the derivable K-atoms in any two-valued MKNF model of a given formula ϕ. The MKNF semantics, as originally defined in <ref type="bibr" target="#b46">[47]</ref>, shows certain undesirable properties such as counterintuitive semantics caused by the usage of arbitrary universes and the differing interpretation of constants in different interpretations. To overcome these problems, <ref type="bibr" target="#b51">[52]</ref> additionally applies the standard name assumption to hybrid MKNF knowledge bases. We briefly recall two such problems from <ref type="bibr" target="#b51">[52]</ref> and the notion of standard names assumption introduced to overcome them, and we refer for the complete discussion to <ref type="bibr" target="#b51">[52]</ref>.</p><p>One problem when using MKNF as in <ref type="bibr" target="#b46">[47]</ref> for the integration of rules and ontologies is the usage of arbitrary universes.</p><p>Consider the MKNF formula ϕ = ϕ 1 ∧ ϕ 2 , where ϕ 1 = K P (a) and ϕ 2 = not P (b) ⊃ f. Intuitively, one would not expect that ϕ is satisfiable since there is no indication that P (b) should be true. However, if the universe contains only one element, then a and b are interpreted as the same object, and ϕ is satisfied. In this case one unintendedly derives that ϕ | a ≈ b holds. Another problem is caused by constants that are interpreted differently in different interpretations. Consider ϕ 1 = K P (a) and ϕ 2 = ∃x: K P (x). In this case one would expect that ϕ 1 | ϕ 2 , that is, every two-valued MKNF model of ϕ 1 is also a two-valued MKNF model of ϕ 2 . However, let M be an MKNF interpretation containing two elements I 1 and I 2 where I 1 is a first-order interpretation in which a is interpreted as a name α 1 and I 1 | P (α 1 ), and I 2 is a first-order interpretation in which a is interpreted as some other name α 2 and I 2 | P (α 2 ). We thus have that M | ϕ 1 but not M | ϕ 2 since this would require to have an x in the domain such that P (x) is true in all I ∈ M.</p><p>To avoid such unintended behaviour, the standard name assumption is imposed on top of MKNF. <ref type="bibr" target="#b51">[52]</ref>.) A first-order interpretation I over a signature Σ employs the standard name assumption if (1) the universe of I contains all constants of Σ and a countably infinite number of additional constants called parameters;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1. (See Standard Name Assumption</head><p>(2) t I = t for each ground term t constructed using the function symbols from Σ and the constants from ; and (3) the predicate ≈ is interpreted in I as a congruence relation -that is, ≈ is reflexive, symmetric, transitive, and allows for the replacement of equals by equals <ref type="bibr" target="#b17">[18]</ref>.</p><p>Consequences of first-order formulas under the standard first-order semantics and the standard name assumption cannot be distinguished <ref type="bibr" target="#b51">[52]</ref>. Thus, in the rest of the paper we use the standard name assumption for first-order inferences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Hybrid MKNF knowledge bases</head><p>Hybrid MKNF knowledge bases as introduced in [51,52]<ref type="foot" target="#foot_6">7</ref> essentially are MKNF formulas restricted to a certain form. They consist of two components: a decidable description logic knowledge base translatable into first-order logic and a finite set of rules of modal atoms.</p><p>More precisely, the approach of hybrid MKNF knowledge bases is applicable to any first-order fragment DL satisfying the following conditions: (i) each knowledge base O ∈ DL can be translated<ref type="foot" target="#foot_7">8</ref> into a formula π(O) of function-free first-order logic with equality; (ii) DL supports A-Box-assertions of the form P (a 1 , . . . , a n ), where P is a predicate and each a i a constant of DL; and (iii) satisfiability checking and instance checking (i.e. checking entailments of the form O | P (a 1 , . . . , a n )) are decidable. In particular, description logics around OWL satisfy these conditions. Note that we limit ourselves to functionfree first-order logic since otherwise decidability would not be possible. Thus for the rest of the paper, we will not allow function symbols in hybrid MKNF knowledge bases.</p><p>We recall MKNF rules and hybrid MKNF knowledge bases from <ref type="bibr" target="#b50">[51]</ref>. </p><formula xml:id="formula_8">K H 1 ∨ • • • ∨ K H l ← K A 1 , . . . , K A n , not B 1 , . . . , not B m (<label>7</label></formula><formula xml:id="formula_9">)</formula><p>The sets {K H i }, {K A i }, and {not B i } are called the rule head, the positive body, and the negative body, respectively. A rule r</p><formula xml:id="formula_10">is nondisjunctive if l = 1; r is positive if m = 0; r is a fact if n = m = 0. A program P is a finite set of MKNF rules. A hybrid MKNF knowledge base K is a pair (O, P) and K is nondisjunctive if all rules in P are nondisjunctive.</formula><p>Hybrid MKNF knowledge bases rules, <ref type="foot" target="#foot_8">9</ref> as defined above, do not coincide syntactically with any MKNF formula. For interpreting hybrid MKNF knowledge bases in terms of MKNF logic, the transformation π that transforms a DL ontology into first-order formulas is extended to knowledge bases as follows:</p><p>Definition 3. Let K = (O, P) be a hybrid MKNF knowledge base. We extend π to rules r of the form <ref type="bibr" target="#b6">(7)</ref>, P, and K as follows, where x is the vector of the free variables of r:</p><formula xml:id="formula_11">π(r) = ∀ x: (K H 1 ∨ • • • ∨ K H l ⊂ K A 1 ∧ • • • ∧ K A n ∧ not B 1 ∧ • • • ∧ not B m ) π(P) = r∈P π(r), π(K) = K π(O) ∧ π(P)</formula><p>To simplify the presentation, we will abuse notation in the rest of the paper and identify K with π(K). It will be obvious from the context when K represents its first-order transformation π(K).</p><p>Hybrid MKNF knowledge bases, even without function symbols, are in general undecidable, unless they are restricted in some way. The reason for that is that rules can be applied to all the objects in the infinite domain. The basic idea to make reasoning with hybrid MKNF knowledge bases decidable is to apply rules only to the individuals that appear in the knowledge base. This restriction is achieved by DL-safety. Definition 4. An MKNF rule r is DL-safe if every variable in r occurs in at least one non-DL-atom K B occurring in the body of r. A hybrid MKNF knowledge base K is DL-safe if all the rules in K are DL-safe.</p><p>In the rest of the paper, unless otherwise stated, we only consider DL-safe knowledge bases. Grounding the knowledge base, as defined below, ensures that rules apply to all the individuals appearing in the knowledge base, whereas DL-safety guarantees that no other individual can be used. Definition 5. Given a hybrid MKNF knowledge base K = (O, P), the ground instantiation of K is the KB K G = (O, P G ) where P G is obtained from P by replacing each rule r of P with a set of rules substituting each variable in r with constants from K in all possible ways. It was shown in <ref type="bibr" target="#b51">[52]</ref> that, for a DL-safe hybrid knowledge base K, the two-valued MKNF models of K and K G coincide.</p><p>Example 4. Consider again the scenario of Example 1, together with the axioms and assertions of Example 2. These axioms can be part of an ontology O of a hybrid MKNF knowledge base K = (O, P). In P we can encode further recommendation guidelines, in particular those that require closed world reasoning. For example, imagine that we want to give customers recommendations for interesting CDs they do not own and that do not have a low evaluation. This can be encoded with the rules shown below<ref type="foot" target="#foot_9">10</ref> : K Recommend(x) ← K CD(x), not owns(x), not LowEval(x), K interesting(x) <ref type="bibr" target="#b7">(8)</ref> K interesting(x) ← K CD(x), K CD( y), K owns( y), not owns(x), K similar(x, y)</p><formula xml:id="formula_12">(9) K similar(x, y) ← K CD(x), K CD( y), K Artist(z), K HasArtist(x, z), K HasArtist( y, z) (10) K owns(EnConcert) ← (11) K HasArtist(EnConcert, JackJohnson) ← (12) K HasArtist(ToTheSea, JackJohnson) ← (13) K OnOffer(BNAW) ←<label>(14)</label></formula><p>Note that closed world reasoning is used for owns and lowEval. In the case of predicate owns, it is reasonable to assume that the knowledge about owned CDs is fully available. So, if there is no fact stating that a given CD is owned, one should assume that the CD is not owned. In the case of predicate lowEval it might happen that there is no evaluation yet available, and we want the recommendation anyway: a CD is not considered for recommendation only when there actually is a (known) low evaluation for the CD. Such an evaluation could be taken from other customers of the store or from a web page of professional reviews. Here, for simplicity, we keep this part of the reasoning process implicit.</p><p>Moreover, in the rules above, a CD is interesting if the customer owns another CD which is similar <ref type="bibr" target="#b8">(9)</ref>, and two CDs are similar if they have a common artist <ref type="bibr" target="#b9">(10)</ref>. Note that the predicate CD is used to ensure DL-safety, and we assume that the instances of that predicate relevant to any drawn conclusion are always appropriately defined.</p><p>If we now add facts ( <ref type="formula">11</ref>)-( <ref type="formula" target="#formula_12">14</ref>), then we can derive Recommend(ToTheSea), since no low evaluation is known for ToTheSea, and Recommend(BNAW) since BNAW is on offer.</p><p>This example illustrates that hybrid MKNF knowledge bases allow us to obtain consequences for predicates that are 'defined' both in the ontology and in the rules. The result may then be further applied to derive subsequent consequences either in rules or in the ontology. Note that the facts ( <ref type="formula">12</ref>) and ( <ref type="formula">13</ref>) are here explicitly added, representing the implicit consequences derivable from the appropriate ontology alone, similar to HasArtist(BNAW, JohnColtrane) in Example 2. In <ref type="bibr" target="#b51">[52]</ref>, several reasoning algorithms were provided for combinations of arbitrary description logic fragments and rules of differing expressivity. Table <ref type="table" target="#tab_3">1</ref> presents the data complexity of instance checking for combinations of nondisjunctive rules (with arbitrary or stratified 11 negation or without not in the rules) with description logics fragments of differing computational complexity. We point out that allowing arbitrary non-monotonic negation increases data complexity drastically and in particular beyond tractability. This is not the case of the rules in Example 4, since these are stratified. However, this is just an initial set of rules for our running example, which is further elaborated below and becomes non-stratified (e.g., the addition of rule <ref type="bibr" target="#b16">(17)</ref> in Example 8 renders the set of rules non-stratified). With the proposal we present in the following sections these sets of non-stratified rules do not constitute a problem regarding complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Three-valued MKNF semantics</head><p>In this section we introduce a three-valued semantics for hybrid MKNF knowledge bases. The rationale and the main goal behind this three-valued semantics is to define a semantics that is closely related to the well-founded semantics of logic programs. This is done in order to take advantage of the (data) complexity of the WFS that is lower than the (data) complexity of the corresponding two-valued semantics. Nevertheless, the DL-part of a hybrid MKNF knowledge base is still interpreted under the two-valued semantics. Thus, we achieve a faithful integration, in the sense that without rules the meaning of the knowledge base exactly coincides with the usual semantics from DLs.</p><p>The definition of the three-valued semantics presented in this section applies equally with or without the standard name assumption. However, since we want to achieve a semantics that is faithful w.r.t. the two-valued MKNF semantics as presented in Section 2, we assume standard name assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Evaluation in MKNF structures</head><p>The two-valued hybrid MKNF semantics <ref type="bibr" target="#b51">[52]</ref> is closely related (cf. <ref type="bibr" target="#b46">[47]</ref>) to the stable models semantics <ref type="bibr" target="#b18">[19]</ref>. In both of them, the meaning of a knowledge base is determined by a set of models. In fact, an MKNF formula such as ϕ = ((not p ⊃ K q) ∧ (not q ⊃ K p)) (and the corresponding set of rules) has two models -one model in which p is true and q is false, and another one in which p is false and q is true. Moreover, these two-valued models are, in general, obtained by a guess and check process, thus having a high computational complexity.</p><p>The well-founded semantics of logic programs <ref type="bibr" target="#b60">[61]</ref> generalises the two-valued models of the stable model semantics to a three-valued setting. In this way, it is possible to determine the meaning of a knowledge base solely on the basis of a single (minimal) model that is obtained with a lower computational complexity. Intuitively, a third truth value u, denoting undefined, is introduced as an alternative to the values t and f, enabling one to delay the evaluation to any of the two latter values until further information is available. We want to follow this idea when defining a three-valued MKNF semantics. There is however one more problem to be taken into account: since we are interested in applying the semantics to hybrid MKNF knowledge bases containing two-valued ontologies, which we want to integrate faithfully, we are going to define the semantics in such a way that an MKNF formula corresponding to a DL fragment is ensured to be just two-valued.</p><p>We therefore define a three-valued MKNF semantics that extends the two-valued semantics of <ref type="bibr" target="#b51">[52]</ref>, but remains twovalued for the case of MKNF formulas without modal operators. We start by defining MKNF structures for this three-valued setting. Definition 6. A three-valued (partial) MKNF structure (I, M, N ) consists of a first-order interpretation I and two pairs M = M, M 1 and N = N, N 1 of sets of first-order interpretations where</p><formula xml:id="formula_13">M 1 ⊆ M and N 1 ⊆ N. An MKNF structure is called total if M = M, M and N = N, N .</formula><p>In the two-valued semantics, an MKNF structure (I, M, N) contains sets of interpretations M and N for evaluating a modal atom K ϕ, respectively not ϕ, to t or f, depending on whether ϕ is contained in all elements of M, respectively N. This clearly leaves no space for an extension to a third truth value u. So, we turn sets of interpretations into pairs of sets of interpretations. Then, as we show below, a modal atom K ϕ is true w.r.t. M, M 1 if ϕ is true in all elements of M; a modal atom K ϕ is false if ϕ is not true in all elements of M 1 ; a modal atom K ϕ is undefined otherwise (i.e. if ϕ is true in all elements of M 1 ). The additional restrictions, saying that M 1 ⊆ M and N 1 ⊆ N, are needed to ensure that no modal atom can be both true and false at the same time, and it can easily be shown via induction that the same holds for any MKNF 11 Essentially, rules can be separated into strata that can be evaluated separately -see Section 4.4 in <ref type="bibr" target="#b51">[52]</ref>.</p><p>formula ϕ. In this way, we guarantee that no fourth truth value 'both' is needed. Nevertheless, given an MKNF formula ϕ, three-valued MKNF structures may evaluate K ϕ and not ϕ to true at the same time, just like in the two-valued case, and we show below how to prevent this from happening when defining MKNF interpretation pairs. We now define the evaluation of closed MKNF formulas in such three-valued MKNF structures.</p><p>Definition 7. Let (I, M, N ) be a three-valued MKNF structure and {t, u, f} the set of truth values with the order f &lt; u &lt; t,</p><p>where the operator max (resp. min) chooses the greatest (resp. least) element with respect to this ordering. We define:</p><formula xml:id="formula_14">• (I, M, N )(P (t 1 , . . . , t n )) = t iff (t I 1 , . . . , t I n ) ∈ P I f iff (t I 1 , . . . , t I n ) / ∈ P I ; • (I, M, N )(¬ϕ) = ⎧ ⎨ ⎩ t iff (I, M, N )(ϕ) = f u iff (I, M, N )(ϕ) = u f iff (I, M, N )(ϕ) = t; • (I, M, N )(ϕ 1 ∧ ϕ 2 ) = min{(I, M, N )(ϕ 1 ), (I, M, N )(ϕ 2 )}; • (I, M, N )(ϕ 1 ⊃ ϕ 2 ) = t iff (I, M, N )(ϕ 2 ) (I, M, N )(ϕ 1</formula><p>) and f otherwise;</p><formula xml:id="formula_15">• (I, M, N )(∃x: ϕ) = max{(I, M, N )(ϕ[α/x]) | α ∈ }; • (I, M, N )(K ϕ) = ⎧ ⎨ ⎩ t iff ( J , M, M 1 , N )(ϕ) = t for all J ∈ M f iff ( J , M, M 1 , N )(ϕ) = f for some J ∈ M 1 u otherwise; • (I, M, N )(not ϕ) = ⎧ ⎨ ⎩ t iff ( J , M, N, N 1 )(ϕ) = f for some J ∈ N 1 f iff ( J , M, N, N 1 )(ϕ) = t for all J ∈ N u otherwise.</formula><p>As intended, this evaluation is not a purely three-valued one, since first-order atoms are evaluated as in the two-valued case. In fact, an MKNF formula ϕ without modal operators (and thus also a pure description logic knowledge base) is only two-valued. It can easily be seen that such a ϕ is evaluated in exactly the same way as in the scheme presented in Section 2. This is desired in particular when the knowledge base consists just of the DL part. So, the third truth value only affects MKNF formulas containing modal atoms, which in the case of hybrid MKNF knowledge bases can only occur in the rules. These rules, corresponding to implications, are, however, no longer interpreted in a way one would expect from a boolean perspective: u ⊃ u is true in the evaluation defined above, while u ∨ ¬u is actually undefined. The reason for this change is that, in this way rules can only be true or false, similarly to what happens in logic programming, even when they contain undefined modal atoms. Intuitively, the advantage for hybrid MKNF knowledge bases is that we can leave single modal atoms undefined, thus not necessarily having to create several models, while the entire knowledge base is only true or false. We point out that the evaluation of not w.r.t. N, N 1 is symmetrical to the evaluation of K w.r.t. M, M 1 , only that the conditions are switched. E.g., the condition for true modal K-atoms w.r.t. M yields false modal not-atoms w.r.t. N. In case of M = N and M 1 = N 1 this corresponds to the two-valued (monotonic) evaluation in Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Three-valued MKNF models</head><p>Given the above definition of evaluation of MKNF formulas, we are now ready to extend (two-valued) MKNF interpretations and MKNF models to three truth values. For that purpose, we have to generalise (two-valued) MKNF interpretations M to pairs of MKNF interpretations (M, N), since otherwise no formula could ever be undefined. The set M contains all interpretations that model only truth, while N models everything that is true or undefined. Evidently, just as in the two-valued case, anything not being modelled in N is false. The subset relation between M and N ensures that MKNF interpretation pairs are defined in accordance with the three-valued MKNF structures, so that each formula is evaluated to exactly one truth value. Note the striking similarity compared to MKNF interpretations in the twovalued case by using the MKNF interpretation pair (M, N) to evaluate both K and not simultaneously.</p><p>We now define the preference relation on MKNF interpretation pairs that is required for the notion of (non-monotonic) three-valued MKNF models, following an approach similar to the one in the two-valued case -i.e. by minimising non-falsity (truth or undefinedness, in this case) of formulas w.r.t. K. Definition 9. Any MKNF interpretation pair (M, N) is a three-valued MKNF model for a given closed MKNF formula ϕ if (1) (M, N) satisfies ϕ and</p><p>(2) for each MKNF interpretation pair (M , N ) with M ⊆ M and N ⊆ N , where at least one of the inclusions is proper and</p><formula xml:id="formula_16">M = N if M = N, there is I ∈ M such that (I , M , N , M, N )(ϕ) = t.</formula><p>Condition (1) checks whether (M, N) evaluates ϕ to t while the second condition verifies that (M, N) contains only knowledge necessary to obtain this evaluation to t. This is achieved by generalising the corresponding notion in the twovalued MKNF semantics to the three-valued case: for each MKNF interpretation pair (M , N ) that properly subsumes (M, N), it is checked that ϕ does not evaluate to t for all I ∈ M , where (M , N ) is used to evaluate K while (M, N) evaluates not.</p><p>Intuitively, one may consider an MKNF interpretation pair as a guess for the true evaluation of the considered formula, and condition (2) checks, having fixed the evaluation of modal not-atoms, whether the evaluation of modal K-atoms is actually minimal w.r.t. to the order f &lt; u &lt; t of truth values. We illustrate in the example below how this minimisation is achieved.</p><p>Example 5. Consider the MKNF formula ϕ (corresponding to two rules):</p><p>(not p ⊃ K q) ∧ (not q ⊃ K p)</p><p>An MKNF interpretation pair (M, N) that satisfies condition (1) of Definition 9 has to evaluate both conjuncts to true.</p><p>The MKNF interpretation pair ({{p}, {p, q}}, {{p, q}}) that evaluates K p to t and K q to u satisfies the first condition but is not a three-valued MKNF model of ϕ since, e.g., (M , N ) = ({∅, {p}, {q}, {p, q}}, {{p, q}}) violates condition <ref type="bibr" target="#b1">(2)</ref>. In fact, this MKNF interpretation pair (M , N ) is a three-valued MKNF model. The operator not is always evaluated w.r.t. the MKNF interpretation pair (M, N), even when considering condition (2) of Definition 9, so, for N = {{p, q}}, the two implications are true anyway, and M has to be the set of all possible interpretations {∅, {p}, {q}, {p, q}} to satisfy condition <ref type="bibr" target="#b1">(2)</ref>. Thus, we obtain the MKNF interpretation pair that evaluates K p and K q to u. In other words, the initial MKNF interpretation pair was not minimal w.r.t. the evaluation of modal K-atoms. Similar to the minimisation of the evaluation of K p from t to u, changes from u to f are possible: maintain the original M = {{p}, {p, q}} and set N = M. Now the evaluation of K q is minimised from u to f, and it is easy to verify that the resulting MKNF interpretation pair is in fact a three-valued MKNF model of ϕ.</p><p>It should be pointed out that the larger the set M or N is, the less true or undefined knowledge is inferred. So, minimisation is achieved by increasing the sets in consideration. Note that N ⊆ M for MKNF interpretation pairs (M , N ) ensures that we only check reasonable candidates for augmenting (M, N). <ref type="foot" target="#foot_10">12</ref>We now adapt some notions needed in the rest of the paper from the two-valued MKNF semantics to the three-valued setting. Definition 10. If there is a three-valued MKNF model for a given closed MKNF formula ϕ, then ϕ is called MKNF-consistent, otherwise ϕ is called MKNF-inconsistent. If (I, M, N , M, N )(ψ) = t for all three-valued MKNF models (M, N) of ϕ, then ϕ entails ψ , written ϕ | 3 MKNF ψ . Note that MKNF-inconsistent MKNF formulas do not necessarily evaluate to f. For example, ϕ = K u ∧ not u evaluates to u for the MKNF interpretation pair ({{u}, ∅}, {{u}}). In fact, an MKNF-inconsistent formula can even evaluate to t and that was already the case for the two-valued MKNF semantics of <ref type="bibr" target="#b51">[52]</ref>. E.g., ϕ = ¬ not p is MKNF-inconsistent, and it evaluates to t in some MKNF interpretation pairs (and also in some MKNF interpretations of <ref type="bibr" target="#b51">[52]</ref>). This does not constitute a problem since it does not affect the definitions of MKNF models or MKNF-consistency.</p><p>Though the notions of inconsistency and unsatisfiability are usually applied in the same technical sense, we want to distinguish between MKNF-satisfiability in the two-valued case and MKNF-consistency for three-valued MKNF models. Likewise, we distinguish between the two-valued notion 'MKNF entails' and the three-valued 'entails'.</p><p>In spite of keeping the notions separate, two-and three-valued MKNF models are closely related: we now show that any two-valued MKNF model M corresponds exactly to a (total) three-valued one and vice versa. For that purpose, we first prove that evaluation in an MKNF structure (I, M, N) and evaluation in a total three-valued structure (I, M, M , N, N ) are identical. Intuitively, this holds because nothing can be undefined in a total three-valued structure. </p><formula xml:id="formula_17">(I, M, M , N, N )(ϕ) = t.</formula><p>Proof. The proof is done by induction on the formula ϕ.</p><p>Let ϕ be P (t Assume that the lemma holds for ϕ 1 . We show the induction steps for ¬ and K, all the other cases follow analogously.</p><p>Let ϕ be ¬ϕ 1 . We have that (I, M, N) | ¬ϕ 1 iff (I, M, N) | ϕ 1 iff, by the induction hypothesis, (I, M, M , N, N )(ϕ 1 ) = f iff by definition of evaluation in partial structures (I, M, M , N, N )(¬ϕ 1 ) = t.</p><p>Let ϕ be K ϕ 1 . We have (I, M, N) | K ϕ 1 iff (I, M, N) | ϕ 1 holds for each I ∈ M iff (I, M, M , N, N )(ϕ 1 ) = t for all I ∈ M by the induction hypothesis iff (I, M, M , N, N )(K ϕ 1 ) = t. 2</p><p>This lemma can be used to show that every two-valued MKNF model M corresponds to a three-valued MKNF model (M, M), like in <ref type="bibr" target="#b35">[36]</ref>, and also the converse, i.e. that every three-valued MKNF model (M, M) corresponds to a two-valued MKNF model in the sense of <ref type="bibr" target="#b51">[52]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 1. Given a closed MKNF formula ϕ, M is a two-valued MKNF model of ϕ if and only if (M, M) is a three-valued MKNF model of ϕ.</head><p>Proof. Let (M, M) be a three-valued MKNF model of ϕ, i.e. (M, M) satisfies the two conditions of Definition 9. We show that M is a two-valued MKNF model of ϕ. It follows from the first of the two conditions of Definition 9 that (I, M, M , M, M )(ϕ) = t for all I ∈ M and therefore, by Lemma 1, that (I, M, M) | ϕ for each I ∈ M. The second con- dition states, for each MKNF interpretation pair (M , M ) with M ⊂ M , that we have (I , M , M , M, M )(ϕ) = t for some I ∈ M . We conclude from Lemma 1 that for any M with M ⊃ M there is an I ∈ M such that (I , M , M) | ϕ.</p><p>Now, let M be a two-valued MKNF model of ϕ. We show that (M, M) is a three-valued MKNF model of ϕ. We know that (I, M, M) | ϕ for each I ∈ M since M is a two-valued MKNF model of ϕ. As such, (I, M, M , M, M )(ϕ) = t holds for all I ∈ M by Lemma 1, and so the first of the two conditions of Definition 9 is satisfied. Furthermore, since M is a two-valued MKNF model of ϕ, we know that for all M with M ⊃ M we have (I , M , M) | ϕ for some I ∈ M . Again, from Lemma 1, we know that for any MKNF interpretation pair (M , M ) with M ⊃ M we have (I , M , M , M, M )(ϕ) = t for some I ∈ M . This is sufficient since, according to Definition 9, for (M, M) we only need to consider total MKNF interpretation pairs (M , M ). 2 MKNF interpretation pairs can be compared by an order that resembles the knowledge order from logic programming.</p><p>Intuitively, given such an order and two MKNF interpretation pairs (M 1 , N 1 ) and (M 2 , N 2 ), we have that (M 1 , N 1 ) is greater than (M 2 , N 2 ) w.r.t. such an order if (M 1 , N 1 ) allows us to derive more true and false knowledge than (M 2 , N 2 ). Taking into account that a larger set of interpretations derives less true and more false knowledge, we can define the following order on MKNF interpretation pairs. Definition 11. Let (M 1 , N 1 ) and (M 2 , N 2 ) be MKNF interpretation pairs. We have that (</p><formula xml:id="formula_18">M 1 , N 1 ) k (M 2 , N 2 ) iff M 1 ⊆ M 2 and N 1 ⊇ N 2 .</formula><p>Such an order is of particular interest for comparing models. In logic programming the least model w.r.t. derivable knowledge among all three-valued models for a given program is the well-founded model. Here, we want to introduce a similar notion referring to the minimal three-valued MKNF models, i.e. the ones among all three-valued MKNF models that leave as much as possible undefined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 12. Let ϕ be a closed MKNF formula and (M,</head><formula xml:id="formula_19">N) a partial MKNF model of ϕ such that (M 1 , N 1 ) k (M, N) for all three-valued MKNF models (M 1 , N 1 ) of ϕ. Then (M, N) is a well-founded MKNF model of ϕ.</formula><p>Of course, if ϕ is inconsistent, then there are no three-valued MKNF models and thus no well-founded MKNF models of ϕ. However, if ϕ is a consistent hybrid MKNF knowledge base, it is guaranteed that a well-founded MKNF model of ϕ exists. Moreover, this well-founded model is unique. As we shall see, this model is especially important in that a modal atom K H is true in the well-founded MKNF model iff K H is true in all three-valued MKNF models. This way, performing sceptical reasoning in three-valued MKNF models amounts to determining the well-founded MKNF model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. If K is an MKNF-consistent nondisjunctive DL-safe hybrid MKNF KB, then a well-founded MKNF model exists, and it is unique.</head><p>The respective proofs for the uniqueness/existence of the well-founded MKNF model, and how to calculate this unique model, are presented in Section 4 (as a direct consequence of Theorem 5). The following example gives at least an intuitive insight into the correspondence between two-valued and three-valued MKNF models, and the well-founded MKNF model. Example 6. Consider the knowledge base K corresponding to the MKNF formula ϕ from Example 5:</p><formula xml:id="formula_20">K q ← not p K p ← not q</formula><p>The two-valued MKNF models of K are {{p}, {p, q}} and {{q}, {p, q}}, i.e. K p and not q are true in the first model, and K q and not p are true in the second one. We obtain two total three-valued MKNF models: ({{p}, {p, q}}, {{p}, {p, q}}) and ({{q}, {p, q}}, {{q}, {p, q}}). As we have already seen in Example 5, the only other three-valued MKNF model of K is M = ({∅, {p}, {q}, {p, q}}, {{p, q}}). This MKNF model satisfies the condition given in Definition 12, and M is thus a well-founded MKNF model of K. In fact, M is the only well-founded MKNF model.</p><p>In the rest of this section we lift two important properties proven in <ref type="bibr" target="#b49">[50]</ref> from the two-valued MKNF semantics to the new three-valued MKNF semantics. The first property states that K can be introduced in front of an arbitrary closed MKNF formula ϕ without changing the three-valued MKNF models of ϕ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2. Let σ be a closed MKNF formula and (M, N) an MKNF interpretation pair. Then, (M, N) is a three-valued MKNF model of σ if and only if (M, N) is a three-valued MKNF model of K σ .</head><p>Proof. Suppose that (M, N) is a three-valued MKNF model of σ . We know for all I ∈ M that (I, M, N , M, N )(σ ) = t. So (I, M, N , M, N )(K σ ) = t holds for all I ∈ M as well. Since for each (M , N ) there is an I ∈ M such that (I , M , N , M, N )(σ ) = t, we also obtain the same for K σ , and (M, N) is a three-valued MKNF model of K σ . The converse direction follows in an analogous fashion. 2</p><p>The second property we adapt from the two-valued to the three-valued MKNF semantics says that grounding a hybrid MKNF knowledge base K does not affect the three-valued MKNF models of K. This shows that K and K G derive exactly the same consequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. Let K be a DL-safe hybrid MKNF knowledge base and ψ a ground MKNF formula. Then</head><formula xml:id="formula_21">K | 3 MKNF ψ if and only if K G | 3 MKNF ψ .</formula><p>Proof. The argument showing the contrapositive statement K | 3 MKNF ψ if and only if K G | 3 MKNF ψ is absolutely identical to the one in <ref type="bibr" target="#b49">[50]</ref>. So we simply refer to the proof given there. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The well-founded MKNF model</head><p>In this section we prove that the well-founded MKNF model is unique, and we define a procedure for computing this unique model. For that purpose, the alternating fixpoint construction of <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b59">60]</ref> for the well-founded semantics of logic programs is adapted to hybrid MKNF knowledge bases, taking into account possible conflicts resulting from the combination of classical negation in ontologies and non-monotonic negation in rules.</p><p>The well-founded semantics for logic programs, originally defined in <ref type="bibr" target="#b60">[61]</ref>, only applies to nondisjunctive logic programs, and there is no established well-founded semantics that allows for disjunction in the rule heads (see, e.g., <ref type="bibr" target="#b37">[38]</ref>). To avoid the problems encountered when extending the well-founded semantics to disjunctive logic programs, and to be compatible with the well-founded semantics of normal programs, we have to restrict to rules that are nondisjunctive. Thus, our approach is more restrictive in the form of rules than the approach of <ref type="bibr" target="#b51">[52]</ref>. Note that we can partially compensate this restriction by using first-order disjunction whenever this is available in the considered DL. Therefore, in the rest of the paper we assume that all hybrid MKNF knowledge bases contain only nondisjunctive rules, i.e. no disjunction occurs in the head of any rule.</p><p>We start by adapting partitions from <ref type="bibr" target="#b51">[52]</ref> as the means of representing MKNF interpretation pairs. Then, based on that representation, we define operators that allow us to compute a unique model for hybrid MKNF knowledge bases. We show that this model is indeed the (unique) well-founded MKNF model, and we present several important properties including the computational complexity, faithfulness w.r.t. the well-founded semantics of logic programs, and discovery of inconsistencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Partitions of modal atoms</head><p>As argued in <ref type="bibr" target="#b51">[52]</ref>, since there are infinitely many two-valued MKNF models of an arbitrary hybrid MKNF knowledge base with a countably infinite domain, working directly with two-valued MKNF models is cumbersome. The same holds for MKNF interpretation pairs in the three-valued semantics presented in Section 3. So, some finite representation is required. The solution, applied in <ref type="bibr" target="#b51">[52]</ref> and originally from <ref type="bibr" target="#b10">[11]</ref>, is to represent a two-valued MKNF model by a finite first-order formula whose set of (first-order) models corresponds to the two-valued MKNF model itself. Intuitively, such a first-order formula is obtained in <ref type="bibr" target="#b51">[52]</ref> by first dividing the modal atoms occurring in the ground hybrid MKNF knowledge base into true and false modal atoms, and then constructing the first-order formula from the true modal atoms and the ontology. We extend this construction, and the related notions from <ref type="bibr" target="#b51">[52]</ref>, to three truth values by partitioning atoms into three sets. Definition 13. Let K G = (O, P G ) be a ground, nondisjunctive hybrid MKNF knowledge base. The set of K-atoms of K G , written KA(K G ), is the smallest set that contains (i) all ground K-atoms occurring in P G , and (ii) a modal atom K ξ for each ground modal atom not ξ occurring in P G . A partial partition (T , F ) of KA(K G ) consists of two sets, where T , F ⊆ KA(K G ) and T ∩ F = ∅. A third set U is implicitly defined as KA(K G ) \ (T ∪ F ).</p><p>The set KA(K G ) contains all modal atoms occurring in K G , only with not-atoms substituted by corresponding modal K-atoms. This set is partitioned into three sets T , F , and U where, intuitively, T contains true modal atoms, F contains false modal atoms, and U contains all the remaining that are considered to be undefined.</p><p>In <ref type="bibr" target="#b51">[52]</ref>, given a knowledge base K G , a set of first-order formulas is defined with the aim of using the models of this set of formulas to represent the models of both the ontology and a set of true modal atoms. If this set of true modal atoms is properly chosen, then the set of first-order interpretations satisfying that set of formulas corresponds to one two-valued</p><formula xml:id="formula_22">MKNF model of K G .</formula><p>Here, this construction will not suffice, and we show below how to adapt the idea to a three-valued setting. The definition of the set of first-order formulas can be recalled from <ref type="bibr" target="#b51">[52]</ref>.</p><formula xml:id="formula_23">Definition 14. Let K G = (O, P G ) be a ground hybrid MKNF knowledge base. For a subset S of KA(K G ), the objective knowl- edge of S w.r.t. K G is the set of first-order formulas OB O,S = {π (O)} ∪ {ξ | K ξ ∈ S}.</formula><p>This notion is used below to establish a link between three-valued MKNF models and partial partitions. But for this purpose, we need to adapt one more notion from <ref type="bibr" target="#b51">[52]</ref>. Definition 15. Let S be a set of ground modal K-atoms. The partial partition (T , F ) of S is induced by an MKNF interpretation pair (M, N) as follows:</p><formula xml:id="formula_24">(1) K ξ ∈ T implies ∀I ∈ M: (I, M, N , M, N )(K ξ) = t, (2) K ξ ∈ F implies ∀I ∈ M: (I, M, N , M, N )(K ξ) = f, and (3) K ξ / ∈ T and K ξ / ∈ F implies ∀I ∈ M: (I, M, N , M, N )(K ξ) = u.</formula><p>Based on this relation, we can show that the objective knowledge derived from the partial partition induced by a threevalued MKNF model is identical to that model. This result is used below to show that the specific partition we compute produces a three-valued MKNF model (Theorem 4). Proof. For K G = (O, P G ) a ground hybrid MKNF knowledge base, let (M, N) be a three-valued MKNF model of K G , (T , F ) the partition of KA(K G ) induced by (M, N), and (M ,</p><formula xml:id="formula_25">N ) = ({I | I | OB O,T }, {I | I | OB O,KA(K G )\F }). We show that (M, N) = (M , N ).</formula><p>First, we show that M ⊆ M . Let I be an interpretation in M. We show that  <ref type="formula">3</ref>) in that definition are true. We show for both cases that I | ξ . This suffices to show that I ∈ N , i.e. that I | OB O,KA(K G )\F , which shows N ⊆ N . In the case of (1), we already know that I | ξ for each I ∈ M, and, since N ⊆ M holds, we also have I | ξ for each I ∈ N. In the case of (3), we know that (I, M, N , M, N )(K ξ) = u for each I ∈ M. Thus, I | ξ holds for each I ∈ N.</p><formula xml:id="formula_26">I ∈ M = {I | I | OB O,T }, i.e. that I | {π (O)} ∪ {ξ | K ξ ∈ T }. Since (M, N) is a three-valued MKNF model of K G , we know that (M, N) | K π(O).</formula><p>We now show that each of the two sets are in fact identical, i.e. M = M and N = N . Note first that T ⊆ KA(K G ) \ F . Thus, for any I ∈ N , we have I ∈ {I | I | OB O,T } and therefore N ⊆ M , i.e. (M , N ) is an MKNF interpretation pair. So assume that (M , N ) is an MKNF interpretation pair with M ⊆ M and N ⊆ N , where at least one of the inclusions is proper. We show that (I , M , N , M, N )(K G ) = t for all I ∈ M , and we thus derive a contradiction to (M, N) being a three-valued MKNF model of K G . For the former, it suffices to prove that (I , M , N , M, N )(K π(O) ∧ π(P G )) = t for all I ∈ M . By definition of M we know that (I , M , N , M, N )(K π(O)) = t for all I ∈ M . We only have to show the same for π(P G ). We achieve that by showing that, for each case of Definition 15, the modal atoms appearing in π(P G ) are evaluated to identical truth values in (M, N) and (M , N ). This suffices to show that (I , M , N , M, N )(π (P G )) = t for all I ∈ M since (M, N), as a three-valued MKNF model of K G , ensures that (I , M, N , M, N )(π (P G )) = t. We thus obtain a contradiction to (M, N) being a three-valued MKNF model.</p><p>• Consider each K ξ ∈ T . We obtain (I , M , N , M, N )(K ξ) = t for all I ∈ M by definition of M just as we have (I, M, N , M, N )(K ξ) = t for all I ∈ M by Definition 15. • Consider each K ξ ∈ F . We obtain (I, M, N , M, N )(K ξ) = f, by Definition 15. We derive that, by Definition 7, (I, M, N , M, N )(K ξ) = f for some I ∈ N. Because of that, and since N ⊆ N , we also have (I , M , N , M, N )(K ξ) = f for some I ∈ N . Thus, by Definition 7, (I,</p><formula xml:id="formula_27">M , N , M, N )(K ξ) = f. • Consider each K ξ with K ξ / ∈ F and K ξ / ∈ T . By Definition 15, we obtain (I, M, N , M, N )(K ξ) = u. By definition of N we have (I , M , N , M, N )(K ξ) = f. From (I, M, N , M, N )(K ξ) = u and M ⊆ M we conclude that only (I , M , N , M, N )(K ξ) = u is possible.</formula><p>• Consider any modal not-atom appearing in π(P G ). Since the evaluation of these is done in both cases w.r.t. (M, N), we straightforwardly obtain the identical evaluation. 2</p><p>The following example illustrates the previously introduced notions.</p><p>Example 7. Consider K consisting only of rule <ref type="bibr" target="#b7">(8)</ref> from Example 4 and an ontology containing just one assertion:</p><formula xml:id="formula_28">CD(BNAW)<label>(15)</label></formula><p>The ground KB K G contains one rule that results from (8) by substituting x with BNAW. We thus obtain</p><formula xml:id="formula_29">KA(K G ) = K Recommend(BNAW), K CD(BNAW), K owns(BNAW), K lowEval(BNAW), K interesting(BNAW)</formula><p>One can easily check that there is only one three-valued MKNF model (M, N) of K G , namely the one in which each I ∈ M, N satisfies I | CD(BNAW). This three-valued MKNF model induces the partition in which CD(BNAW) appears in T and all other modal K-atoms in F . The related set of first-order formulas just contains CD(BNAW). This is reasonable since the ground version of ( <ref type="formula">8</ref>) does not allow us to derive anything, and so we can ignore (8) when considering three-valued MKNF models of K G .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Computation of the alternating fixpoint</head><p>As we have seen in Section 3, a knowledge base may in general have several three-valued MKNF models. But we have a special interest in the least one w.r.t. derivable knowledge -the well-founded MKNF model -and the computation of that model. In order to obtain the well-founded MKNF model and the corresponding partial partition, we resort to several existing relations and correspondences with semantics from Logic Programming.</p><p>The stable models of a normal logic program Π are the fixpoints of the Gelfond-Lifschitz operator Γ Π <ref type="bibr" target="#b18">[19]</ref>. The same operator can be used to compute the (three-valued) well-founded model of Π by the so-called alternating fixpoint computation (cf. <ref type="bibr" target="#b59">[60]</ref>). Intuitively, an operator, which results from applying Γ Π twice, is used to compute a least and a greatest fixpoint, which correspond, respectively, to the true and non-false knowledge. The term "alternating" stems from the fact that Γ Π is antitonic, and so successive applications will, in turn, overestimate and underestimate derivable knowledge in the well-founded model, ultimately alternating between the two fixpoints. More precisely, by iteratively applying Γ Π starting with an empty set of atoms, we first obtain a set of atoms that includes all the true atoms in the well-founded model of Π , i.e. an overestimate of the true atoms in the well-founded model (in other words, a set whose complement is an underestimate of the set of all false atoms). If we apply Γ Π again to that result, then we obtain a set of atoms that are true for sure, i.e. an underestimate of the set of all true atoms. If we continue the iteration, we obtain alternating smaller overestimates and larger underestimates until eventually the iteration alternates between two fixpoints -one with all true atoms, and the other one with all atoms that are true or undefined in the well-founded model of Π .</p><p>Since stable models of logic programs and two-valued MKNF models are closely related, we adapt this scheme to hybrid MKNF knowledge bases. We define operators that provide a stable condition for nondisjunctive hybrid MKNF knowledge bases, and we use these operators to obtain an alternating fixpoint that corresponds to the well-founded MKNF model.</p><p>We start by defining an operator T K G that, given a set of K-atoms, draws conclusions from a positive ground hybrid MKNF knowledge base K G , i.e. a ground hybrid MKNF knowledge base where rules are of the form:</p><formula xml:id="formula_30">K H ← K A 1 , . . . , K A n (<label>16</label></formula><formula xml:id="formula_31">)</formula><p>Definition 16. Let K G = (O, P G ) be a positive, ground hybrid MKNF knowledge base. The operators R K G , D K G , and T K G are defined on subsets of KA(K G ) as follows:</p><p>R K G (S) = K H P G contains a rule of the form ( <ref type="formula" target="#formula_30">16</ref>) such that, for all i,</p><formula xml:id="formula_32">1 i n, K A i ∈ S D K G (S) = K ξ K ξ ∈ KA(K G ) and OB O,S | ξ T K G (S) = R K G (S) ∪ D K G (S)</formula><p>The operator R K G derives immediate consequences from the rules in K G while D K G yields consequences from the ontology combined with the already known information in S. The operator T K G , which combines the other two, is monotonic:</p><formula xml:id="formula_33">Proposition 4. Let K G = (O, P G ) be a positive ground hybrid MKNF knowledge base, and S ⊆ S ⊆ KA(K G ). Then T K G (S) ⊆ T K G (S ). Proof. Suppose that K H ∈ T K G (S). By Definition 16, K H ∈ R K G (S) ∪ D K G (S) holds. If K H ∈ R K G (S)</formula><p>, then P G contains a rule of the form (16) such that K A i ∈ S for each 1 i n. Since S ⊆ S , we also have that K A i ∈ S for each 1 i n and</p><formula xml:id="formula_34">K H ∈ T K G (S ). If K H ∈ D K G (S), then K H ∈ M and OB O,S | H .</formula><p>By monotonicity of first-order logic and since S ⊆ S , we also have</p><formula xml:id="formula_35">OB O,S | H . We conclude that K H ∈ T K G (S ). 2</formula><p>Since T K G is monotonic, it has a unique least fixpoint (by the Knaster-Tarski Theorem <ref type="bibr" target="#b58">[59]</ref>) which we denote using T K G ↑ ω in reference to the limit ordinal of natural numbers ω. It is important to note that the Knaster-Tarski Theorem in general only says that this fixpoint is reached for some ordinal that might easily be greater than ω. However, in MKNF knowledge bases, since we do not allow function symbols or infinite sets of rules, the iteration is performed over a finite knowledge base (with finitely many ground rules). As such, the iteration of T K G terminates for some finite ordinal below ω.</p><p>The least fixpoint is obtained as follows:</p><formula xml:id="formula_36">T K G ↑ 0 = ∅ T K G ↑ (n + 1) = T K G (T K G ↑ n) T K G ↑ ω = i 0 T K G ↑ i</formula><p>Similarly to stable models of normal logic programs a fixpoint operator can be defined that performs a Gelfond-Lifschitzlike transformation <ref type="bibr" target="#b18">[19]</ref> that turns hybrid MKNF knowledge bases into positive ones, and that then applies the operator T K G to the resulting knowledge base.</p><formula xml:id="formula_37">Definition 17. Let K G = (O, P G ) be a ground hybrid MKNF knowledge base and S ⊆ KA(K G ). The MKNF transform K G /S is defined as K G /S = (O, P G /S), where P G /S contains all rules K H ← K A 1 , . . . , K A n</formula><p>for which there exists a rule</p><formula xml:id="formula_38">K H ← K A 1 , . . . , K A n , not B 1 , . . . , not B m in P G with K B j / ∈ S for all 1 j m.</formula><p>This definition indeed resembles the transformation used to compute stable models <ref type="bibr" target="#b18">[19]</ref> of logic programs. I.e., we remove all rules that contain negated atoms contradicting the given set S, and we remove all remaining negated atoms from the other rules. Following <ref type="bibr" target="#b18">[19]</ref>, we define an operator that computes the least fixpoint of the resulting knowledge base.</p><formula xml:id="formula_39">Definition 18. Let K G = (O, P G ) be a ground hybrid MKNF knowledge base and S ⊆ KA(K G ). We define Γ K G (S) = T K G /S ↑ ω.</formula><p>Inspired by the similarities between the definition of Γ K G and Γ in <ref type="bibr" target="#b18">[19]</ref>, the correspondence of stable models for logic programs and two-valued MKNF models for knowledge bases without ontology axioms, and the results in alternating fixpoints of normal logic programs <ref type="bibr" target="#b59">[60]</ref>, one might wonder whether iteratively applying the operator Γ K G would yield the least three-valued MKNF model. In fact, as shown below in Lemma 3, the operator Γ K G is antitonic. Thus, Γ 2 K G is monotonic and guaranteed to have a least fixpoint, which can be obtained by iteratively applying Γ 2 K G starting from the empty set. One may then ask whether this least fixpoint corresponds to the well-founded MKNF model. However, as shown in the following example, this is not the case, and, thus, an adaptation of alternating fixpoints to hybrid MKNF knowledge bases cannot be as straightforward.</p><p>Example 8. Consider the hybrid MKNF knowledge base presented in Examples 2 and 4 for recommending CDs, and suppose now that the user wants to stall recommendations until an evaluation is available. This can be achieved, e.g., by adding the rule <ref type="bibr" target="#b16">(17)</ref>, K LowEval(x) ← not Recommend(x) <ref type="bibr" target="#b16">(17)</ref> With this rule, together with (8), a CD is not recommended unless one adds explicit information that the CD has no low evaluation. To ease the reading, we recall here rule (8): K Recommend(x) ← K CD(x), not owns(x), not LowEval(x), K interesting(x) <ref type="bibr" target="#b7">(8)</ref> In fact, if one adds, e.g., ¬LowEval(ToTheSea) <ref type="bibr" target="#b17">(18)</ref> then all three-valued MKNF models contain K Recommend(ToTheSea). However, as shown next, K Recommend(ToTheSea) is not contained in the least fixpoint of Γ 2 K G . To simplify the computation and presentation of this least fixpoint, we ground all the rules only with ToTheSea (thus ignoring any other CDs), and we add explicitly that ToTheSea is a CD <ref type="bibr" target="#b18">(19)</ref>, CD(ToTheSea) <ref type="bibr" target="#b18">(19)</ref> We also limit ourselves to the following set of modal atoms (using appropriate abbreviations):</p><p>KA(K G ) = K Rec(Tts), K LowEv(Tts), K CD(Tts), K owns(Tts), K int(Tts)</p><p>We start with S 0 = ∅, so we compute Γ K G (S 0 ) and</p><formula xml:id="formula_40">S 1 = Γ K G (Γ K G (S 0 )): Γ K G (S 0 ) = KA(K G ) S 1 = K CD(Tts), K int(Tts)</formula><p>Note that, since K LowEv(Tts) ∈ T K G /S 0 (∅), then, by <ref type="bibr" target="#b17">(18)</ref>, OB O,T K G /S 0 (∅) is inconsistent. So, the subsequent application of D K G allows us to derive everything, and thus Γ K G (S 0 ) = KA(K G ).</p><p>We continue with Γ K G (S 1 ) and</p><formula xml:id="formula_41">S 2 = Γ K G (Γ K G (S 1</formula><p>)) and obtain:</p><formula xml:id="formula_42">Γ K G (S 1 ) = KA(K G ) S 2 = K CD(Tts), K int(Tts)</formula><p>Now, since S 1 = S 2 , the fixpoint is reached, and, indeed, does not contain K Rec(Tts). This is so because, since K LowEv(Tts) ∈ Γ K G (S 1 ), rule (8) grounded with Tts is removed in P G /Γ K G (S 1 ).</p><p>Note that K LowEv(Tts) ∈ Γ K G (S 1 ) because rule (17) is not removed in P G /S 1 , given that K Rec(Tts) / ∈ S 1 . In an analogy with <ref type="bibr" target="#b59">[60]</ref>, K LowEv(Tts) is thus either true or undefined, since it belongs to the overestimate in the alternating fixpoint. This shows that, in opposite to the three-valued MKNF semantics, ¬LowEv(Tts) does not imply not LowEv(Tts). <ref type="foot" target="#foot_11">13</ref> In fact, for any three-valued MKNF model (M, N) of the restricted knowledge base, if ¬LowEv(Tts) holds, then, for all I ∈ M, LowEv(Tts) / ∈ I . Thus, since N ⊆ M, we also have, for all I ∈ N, LowEv(Tts) / ∈ I , i.e. not LowEv(Tts) should be true in any three-valued MKNF model of the knowledge base.</p><p>One way of guaranteeing that the classical negation of some DL-atom H in the ontology imposes the truth of not H (despite the existence of rules with head K H ) is to change the MKNF transform defined above, so that rules with head K H are removed whenever ¬H holds: Definition 19. Let K G = (O, P G ) be a ground hybrid MKNF knowledge base and S ⊆ KA(K G ). The MKNF-coherent transform K G //S is defined as K G //S = (O, P G // S ), where P G //S contains all rules</p><formula xml:id="formula_43">K H ← K A 1 , . . . , K A n</formula><p>for which there exists a rule</p><formula xml:id="formula_44">K H ← K A 1 , . . . , K A n , not B 1 , . . . , not B m in P G with K B j /</formula><p>∈ S for all 1 j m and OB O,S | ¬H.</p><p>Note the difference between this definition and Definition 17: we also remove a rule from the MKNF-coherent transform, in case the classical negation of the head is derivable from the ontology augmented by S. Definition 20. Let K G = (O, P G ) be a ground hybrid MKNF knowledge base and S ⊆ KA(K G ). We define Γ K G (S) = T K G // S ↑ ω.</p><p>The operator Γ K G is also antitonic (cf. Lemma 3), and so applying Γ K G twice is guaranteed to have a least fixpoint.</p><p>Clearly, in the case of the knowledge base of Example 8, this least fixpoint includes K Rec(Tts). The reason is that the new MKNF-coherent transform does not contain any rule with head K LowEval(Tts) once ¬LowEval(Tts) is derived, and so rule (8) instantiated with Tts is not removed at some step of the iteration. However, the next example shows that the operator Γ K G literally hides inconsistencies from the iteration. A modal atom K H may be simply considered false, even though there is a rule with head K H such that the body is true in all three-valued MKNF models of the respective knowledge base.</p><p>Example 9. Consider again only the hybrid MKNF knowledge base presented in Examples 2 and 4 for recommending CDs. Now suppose that the user wants to ensure that only inexpensive CDs are to be recommended. Note that this is different from recommending CDs that have a discount. The ontology axiom <ref type="bibr" target="#b19">(20)</ref> states that any expensive CD must never be recommended. In general, comparing prices requires some predicates from the numerical domain, such as concrete domains for the DL EL ++ <ref type="bibr" target="#b1">[2]</ref>. For simplicity, we assume here that this is handled internally, so we simply add a fact <ref type="bibr" target="#b20">(21)</ref> saying that ToTheSea is expensive, Expensive ¬Recommend <ref type="bibr" target="#b19">(20)</ref> K Expensive(ToTheSea) ← <ref type="bibr" target="#b20">(21)</ref> This knowledge base is clearly MKNF-inconsistent: simply note that we can conclude that ToTheSea is recommended (from (8) instantiated by ToTheSea) and not recommended at the same time (by ( <ref type="formula">20</ref>)-( <ref type="formula">21</ref>)). However, it is easy to check that the least fixpoint of applying Γ K G twice does not include K Rec(Tts), simply because the MKNF-coherent transform removes the rule (8) instantiated with Tts once ¬Recommend(Tts) is true, even though the rule body is true.</p><p>This example shows that Γ K G cannot be applied always in the alternating fixpoint. Examining again the computation of Example 8, we may see that the application of Γ K G would only be required when we compute overestimates of the true knowledge. In this case, it would suffice to apply Γ K G for computing Γ K G (S 1 ). Then, S 2 could be obtained by simply applying Γ K G to the previous result, thus computing S 2 now by Γ K G (Γ K G (S 1 )). At the same time, in case of Example 9, the partial usage of Γ K G would ensure that Recommend(Tts) is kept in one part of the iteration so that inconsistencies may still be detectable.</p><p>This suggests that the computation of the well-founded MKNF model could be obtained by alternating the application of the operators Γ K G and Γ K G . In fact, as we will show, this interaction of the two operators yields the well-founded MKNF model. But before we formally define this interaction and prove its correspondence to the well-founded MKNF model, we show that both operators are indeed antitonic.</p><formula xml:id="formula_45">Lemma 3. If K G is a ground hybrid MKNF knowledge base and S ⊆ S ⊆ KA(K G ), then Γ K G (S ) ⊆ Γ K G (S) and Γ K G (S ) ⊆ Γ K G (S).</formula><p>Proof. We show the argument for Γ K G . The proof for Γ K G is identical.</p><p>By Definition 18, we have to show that T K G /S ↑ ω ⊆ T K G /S ↑ ω. We prove by induction on</p><formula xml:id="formula_46">n that T K G /S ↑ n ⊆ T K G /S ↑ n holds. The base case for n = 0 is trivial since ∅ ⊆ ∅. Assume that T K G /S ↑ n ⊆ T K G /S ↑ n holds and consider K H ∈ T K G /S ↑ (n + 1). Then K H ∈ T K G /S (T K G /S ↑ n)</formula><p>and there are two cases to consider. First, K G /S contains a rule of the form</p><formula xml:id="formula_47">K H ← K A 1 , . . . , K A n such that K A i ∈ T K G /S ↑ n for each 1 i n. Since S ⊆ S , we also have K H ← K A 1 , . . . , K A n in K G /S</formula><p>and, by the induction hypothesis,</p><formula xml:id="formula_48">K A i ∈ T K G /S ↑ n for each 1 i n. Hence, K H ∈ T K G /S ↑ (n + 1). Alternatively, K H is a consequence obtained from D K G /S (T K G /S ↑ n). By the induction hypothesis, T K G /S ↑ n ⊆ T K G /S</formula><p>↑ n holds, and we conclude from the monotonicity of first-order logic that</p><formula xml:id="formula_49">K H ∈ D K G /S (T K G /S ↑ n). 2</formula><p>Since both operators are antitonic, we can define an alternating iteration for the two operators as motivated above: Definition 21. Let K G be a ground hybrid MKNF knowledge base. We define two sequences P i and N i as follows:</p><formula xml:id="formula_50">P 0 = ∅, N 0 = KA(K G ) P n+1 = Γ K G (N n ), N n+1 = Γ K G (P n ) P ω = P i , N ω = N i</formula><p>The sequence of P i is intended to compute modal atoms that are true, while the sequence N i computes modal atoms that are not false. The former is an increasing sequence, while the latter is decreasing: Lemma 4. Let K G be a ground hybrid MKNF knowledge base. Then P α ⊆ P β and N β ⊆ N α for all ordinals α, β with α β ω. For similarity with the computation presented in Example 8, we compute the fixpoints as sketched in the proof of Proposition 5. We start with P 0 = ∅ and compute N 1 = Γ K G (P 0 ) and P 2 = Γ K G (N 1 ):</p><p>N 1 = K CD(Tts), K int(Tts), K Rec(Tts)</p><formula xml:id="formula_51">P 2 = K CD(Tts), K int(Tts), K Rec(Tts)</formula><p>It is easy to check that P 2 is already the least fixpoint. Note the difference to the iteration in Example 8. Now, K LowEv(Tts)</p><p>does not occur in N 1 , since OB O,P 0 | ¬LowEv(Tts). So rule (17) instantiated with Tts is removed in the MKNF coherenttransform, and thus K LowEv(Tts) / ∈ Γ K G (P 0 ). As a consequence, we obtain K Rec(Tts) in P 2 . We can compute the greatest fixpoint N ω = Γ K G (P ω ), and we obtain that N ω equals N 1 . Note that if axiom ( <ref type="formula">18</ref>) is omitted, then both K LowEv(Tts) and K Rec(Tts) remain undefined. Thus, operator Γ K G , in combination with <ref type="bibr" target="#b17">(18)</ref>, shows how the formula ¬LowEv(Tts) imposes that not LowEv(Tts) holds, ensuring in this example the derivability of K Rec(Tts).</p><p>The knowledge base in Example 9 is MKNF-inconsistent. Thus, there cannot be a well-founded partition as in Definition 22. Nevertheless, we present the computation of the alternating fixpoint, in order to show the difference to the computation in Example 9, and to hint on how to detect inconsistencies, a topic that is detailed in the next section.</p><p>Example 11. Consider the ground hybrid MKNF knowledge base K G presented in Example 9, where all rules are only grounded with Tts, and the following restricted set of modal atoms is used: KA(K G ) = K Rec(Tts), K CD(Tts), K LowEv(Tts), K owns(Tts), K int(Tts), K Exp(Tts)</p><p>To further simplify the presentation, we only consider rule <ref type="bibr" target="#b7">(8)</ref>, axioms ( <ref type="formula">19</ref>)-( <ref type="formula">21</ref>), and we simplify (9) to the fact <ref type="bibr" target="#b25">(26)</ref>. To ease the reading we repeat here the complete knowledge base obtained after all simplifications: Exp ¬Rec </p><p>K Exp(Tts) ←</p><p>K Rec(Tts) ← K CD(Tts), not owns(Tts), not LowEval(Tts), K int(Tts)</p><p>K int(Tts) ←</p><p>For computing the two fixpoints, we start with P 0 = ∅ and N 0 = KA(K G ). We continue with P 1 = Γ K G (N 0 ) and N 1 = Γ K G (P 0 ):</p><formula xml:id="formula_56">P 1 = K CD(Tts), K int(Tts), K Exp(Tts) N 1 = KA(K G )</formula><p>Note that once K Rec(Tts) is derived in the computation of N 1 and added to the set S of derived knowledge of T K G /∅ , then D K G /∅ allows us to derive everything, simply because OB O,S with {K Exp(Tts), K Rec(Tts)} ⊆ S is inconsistent.</p><p>We continue with P 2 = Γ K G (N 1 ) and N 2 = Γ K G (P 1 ), and obtain:</p><formula xml:id="formula_57">P 2 = K CD(Tts), K int(Tts), K Exp(Tts) N 2 = K CD(Tts), K int(Tts), K Exp(Tts)</formula><p>Since OB O,P 1 | ¬Rec(Tts), the rule (25) no longer appears in the transform used for computing N 2 , and the explosive behaviour of D K G /∅ disappears as well. As a consequence, in the next iteration we obtain K Rec(Tts) ∈ P 3 , which again yields the explosive inconsistency and the derivation of KA(K G ),</p><formula xml:id="formula_58">P 3 = KA(K G ) N 3 = K CD(Tts), K int(Tts), K Exp(Tts)</formula><p>It is easy to check that these are the fixpoints. We have K Rec(Tts) ∈ P 3 but K Rec(Tts) / ∈ N 3 . Intuitively, this means that K Rec(Tts) is true and false at the same time, something that is already a clear indication for the inconsistency of the considered knowledge base.</p><p>Proof. We know from Theorem 3 that (I P , I N ) satisfies K G . By Proposition 3, this MKNF interpretation pair exactly corresponds to the one that equals to a three-valued MKNF model inducing that partition. Thus (I P , I N ) is a three-valued MKNF model of K G . 2</p><p>In fact, (I P , I N ) is the unique well-founded MKNF model, i.e. the least partial MKNF model w.r.t. derivable knowledge.</p><p>Theorem 5. Let K G be an MKNF-consistent ground hybrid MKNF KB and (I P , I N ) the three-valued MKNF model of K G induced by the well-founded partition (T W , F W ). For any three-valued MKNF model (M, N) of K G we have (M, N) k (I P , I N ). Indeed, (I P , I N ) is the well-founded MKNF model of K G .</p><p>Proof. We have shown in Proposition 3 that any three-valued MKNF model (M, N) of K G induces a partition (T , F ) which in turn gives rise to the same three-valued MKNF model (via the objective knowledge). By Proposition 7, K H ∈ T W implies that K H is true (and not H is false) in all three-valued MKNF models (M, N) of K G , and K H ∈ F W implies that K H is false (and not H is true) in all three-valued MKNF models (M, N) of K G . We conclude that T W ⊆ T and F W ⊆ F . Furthermore, we know that This central theorem not only shows that the well-founded MKNF model is unique and well defined, since the wellfounded MKNF model is exactly the three-valued MKNF model that is least w.r.t. k , but also that the well-founded MKNF model is a sound approximation of any total three-valued MKNF model and therefore of any two-valued MKNF model. Thus, the well-founded partition can also be used in the algorithms presented in <ref type="bibr" target="#b51">[52]</ref> for computing a subset of the knowledge that holds in all partitions corresponding to a two-valued MKNF model.</p><formula xml:id="formula_59">I P = {I | I | OB O,T W } and I N = {I | I | OB O,KA(K G )\F W },</formula><p>The Finally, the following theorem is obtained from the data complexity results for positive nondisjunctive MKNF knowledge bases in <ref type="bibr" target="#b51">[52]</ref>, where data complexity is measured in terms of A-Box assertions and rule facts. Theorem 7. Let K be a hybrid MKNF KB. Assuming that entailment of ground DL-atoms in DL is decidable with data complexity C, the data complexity of computing the well-founded partition is in P C .</p><p>For comparison, the data complexity for reasoning with two-valued MKNF models in nondisjunctive programs is shown to be E P C where E = NP if C ⊆ NP, and E = C otherwise. Thus, computing the well-founded partition ends up in a strictly smaller complexity class than deriving the two-valued MKNF models. In fact, if the description logic fragment is tractable, <ref type="foot" target="#foot_12">15</ref>then we obtain a formalism whose model is computed with a data complexity in P. This is remarkable, since to the best of our knowledge this is the first time that a general tractable local closed world extension for DLs has been identified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related work</head><p>Several proposals exist for combining rules and ontologies (see, e.g., <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b27">28]</ref> for a brief survey). They can be split into two groups, namely those semantically based on first-order logics solely (such as description logics alone), and the hybrid approaches (such as hybrid MKNF) providing a semantics combining elements of first-order logics with non-monotonicity.</p><p>The most general approach in the first group is SWRL <ref type="bibr" target="#b31">[32]</ref>, an unrestricted combination of OWL-DL with function-free Horn rules (i.e., rules without negation). The approach is very expressive but undecidable, yet nevertheless generalises many approaches in this group. Applying, e.g., DL-safety to SWRL rules yields DL-safe rules <ref type="bibr" target="#b52">[53]</ref>, a decidable subset of SWRL. <ref type="bibr" target="#b9">[10]</ref>, a combination of DL-safe positive rules and ALC, and CARIN <ref type="bibr" target="#b45">[46]</ref> are also notable formalisms generalised by SWRL. In both cases, the ontology only serves as input to the rules and not vice versa, i.e., information flow is one way. Description Logic Programs (DLP) <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b43">44]</ref> are a fragment of OWL that can be transformed into logic programs of positive rules. In the same spirit, Horn-SHIQ <ref type="bibr" target="#b32">[33]</ref> is a fragment of OWL that can be translated into Datalog, and (like DLP) is of tractable data complexity. 16 Recently, DLP has been generalised to Description Logic Rules <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b40">41]</ref>, i.e. rules that may contain description logic expressions. This enriches the DL, on which the description logic rules are based, with sophisticated constructs normally only available to more expressive description logics, without increasing the complexity. Similarly, ELP <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b44">45]</ref> is a polynomial language covering important parts of OWL 2. ELP also allows some axioms that cannot be expressed in OWL 2. All of these approaches have the advantage of fitting semantically into the original (firstorder) OWL semantics, which also means that existing reasoners for ontologies alone can be used for reasoning in the combined knowledge bases. On the other hand, none of these approaches can express non-monotonic negation, and as such none cover the motivating cases discussed in the introduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AL-log</head><p>In the second group, which includes hybrid MKNF, the approach in <ref type="bibr" target="#b13">[14]</ref> combines ontologies and rules in a modular way, i.e. both parts and their semantics are kept separate. The two reasoning engines nevertheless interact bidirectionally (with some limitations in the direction of the ontology to rules) via interfaces, and the dlvhex system <ref type="bibr" target="#b14">[15]</ref> provides an implementation that generalises the approach by allowing multiple sources for external knowledge (with differing semantics). This work has been extended in various ways (e.g., probabilities, uncertainty, and priorities; for references see the related work section of <ref type="bibr" target="#b13">[14]</ref>). A related well-founded semantics <ref type="bibr" target="#b15">[16]</ref> has been proposed with a computational complexity quite similar to the one of our well-founded MKNF semantics. However, the integration is less tight, and the formalism restricts the transfer of information from ontologies to rules. The only other well-founded semantics approach is called hybrid programs <ref type="bibr" target="#b11">[12]</ref> but this approach only allows the transfer of information from the ontology to the rules. Thus, <ref type="bibr" target="#b11">[12]</ref> is strictly less expressive than the well-founded MKNF semantics. The advantage of such a restriction is that, contrary to <ref type="bibr" target="#b15">[16]</ref> and the well-founded MKNF semantics, the semantics remains compatible with the standard semantics: consider two DL-atoms B 1 and B 2 and an ontology that expresses that at least one of them is true but none is a logical consequence of the ontology. Then, given rules p ← B 1 and p ← B 2 , p is obtained by <ref type="bibr" target="#b11">[12]</ref> but not in our work or in the formalism described by Eiter et al. <ref type="bibr" target="#b13">[14]</ref>.</p><p>There are several further approaches related to stable models of logic programs. <ref type="bibr" target="#b7">[8]</ref> uses an embedding into autoepistemic logic to tightly combine ontologies and rules. The approach is quite similar in spirit to hybrid MKNF <ref type="bibr" target="#b51">[52]</ref>. In fact, the embedding with epistemic rule bodies and epistemic rule heads seems to be the one most closely related, not only syntactically but also with respect to the semantic consequences. However, a precise relation to hybrid MKNF is far from obvious since an autoepistemic interpretation in <ref type="bibr" target="#b7">[8]</ref> is a pair of a first-order interpretations and a set of beliefs and both are not necessarily related. DL+log <ref type="bibr" target="#b57">[58]</ref> provides a combination of rules and ontologies that separates predicates into rule and ontology predicates and evaluates the former w.r.t. the answer set semantics and the latter w.r.t. a first-order semantics with weak DL-safety, i.e. each variable in the head of a rule appears in an arbitrary positive atom in the body of the rule. Like <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b51">52]</ref> generalises <ref type="bibr" target="#b57">[58]</ref> and several earlier related works (e.g. <ref type="bibr" target="#b56">[57]</ref>) within the framework of equilibrium logics. Quite similar to <ref type="bibr" target="#b57">[58]</ref> is <ref type="bibr" target="#b47">[48]</ref>, although this approach does not distinguish between ontology and rules predicates. In fact, the work originates from <ref type="bibr" target="#b13">[14]</ref> and it is thus from the perspective of rules but permits a much tighter integration. Open answer set programming <ref type="bibr" target="#b24">[25]</ref> extends rules with open domains and adds some syntactic limitations for ensuring decidability. Based on that, an algorithm has been provided for f-hybrid knowledge bases <ref type="bibr" target="#b16">[17]</ref>, i.e. a combination of ontologies and rules without DL-safety but which limits predicates to tree-shapedness. A loose layering of Prolog on top of DLs, employing four-valued logic, is presented in <ref type="bibr" target="#b48">[49]</ref>.</p><p>An alternative way of introducing non-monotonicity into ontologies is to enrich DLs with further syntactic constructs representing non-monotonic features. Among these approaches the most closely related to our work is Description Logics of MKNF <ref type="bibr" target="#b10">[11]</ref>, which allows two modal operators in ontology axioms. An algorithm was provided in <ref type="bibr" target="#b10">[11]</ref> for ALC with MKNF, and it has been improved in <ref type="bibr" target="#b33">[34]</ref>. In <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b20">21]</ref>, circumscription was used for adding non-monotonic reasoning to DLs, and several other formalisms introducing defaults to ontologies exist (e.g., <ref type="bibr" target="#b3">[4]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and future work</head><p>Summarising, we have defined a well-founded semantics of (tightly integrated) hybrid KBs that is sound w.r.t. the semantics defined in <ref type="bibr" target="#b51">[52]</ref> for MKNF KBs but has a strictly lower complexity. In particular, we obtain tractability whenever the underlying description logic is tractable. To the best of our knowledge, the well-founded MKNF semantics is the first approach for the combination of arbitrary non-monotonic rules and ontologies without any limitations on the transfer of information between the two. Our approach coincides with the first-order semantics of the DL fragment if there are no rules, and with the well-founded semantics of normal programs if the DL-part is empty. Moreover, we defined a construction for computing the well-founded MKNF model that is also capable of detecting inconsistencies in a straightforward way.</p><p>Several lines of future research can be considered. First of all, we are working towards a general query-driven procedure capable of answering conjunctive queries under the well-founded semantics of hybrid MKNF knowledge bases. In fact, we already have some results on this issue: in <ref type="bibr" target="#b0">[1]</ref>, a procedure is defined using tabled resolution that is sound and complete w.r.t. the well-founded semantics defined here, and that is terminating for several classes of knowledge bases. This 16 Further analyses of Horn description logics are provided in <ref type="bibr" target="#b42">[43]</ref>.</p><p>procedure, which takes an oracle capable of answering queries in the underlying description logic as a parameter, is able to answer DL-safe conjunctive queries (i.e., conjunctive predicates with variables, where queries have to be ground when processed in the ontology) returning all correct answer substitutions for variables in the query. An implementation of this procedure, that is based on XSB Prolog<ref type="foot" target="#foot_13">17</ref> for the tabling resolution, is already part of the CVS version of XSB Prolog, and the description of this implementation can be found at <ref type="bibr" target="#b19">[20]</ref>.</p><p>Another line of current research is the specialisation of the semantics defined here (with corresponding procedures and implementations) to particular tractable description logics, as opposed to considering DLs in general. This specific study aims at EL ++ <ref type="bibr" target="#b1">[2]</ref> and ELP <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b44">45]</ref>, one extension of EL ++ . We intend to provide a transformation of such hybrid knowledge bases into rules that can be used as input to a logic programming system capable of computing the well-founded MKNF model of a set of rules. We have advanced already in this work, by providing just that for EL + <ref type="bibr" target="#b34">[35]</ref>.</p><p>Another topic that we are pursuing is the definition of a paraconsistent version of the semantics defined here. It is worth noting that when inconsistencies come from the combination of rules and the DL-part (i.e. for inconsistent KBs with a consistent DL-part), the construction still yields some results, e.g., in Example 11 we still derive that Bts is interesting. This suggests that the method could be further exploited in the direction of defining a paraconsistent semantics for hybrid KBs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3 .</head><label>3</label><figDesc>Though M = {{p}} satisfies both K p and ¬ not p, M is only a two-valued MKNF model of the first formula. M is not a two-valued MKNF model of the second one since (I , M , M) | ¬ not p holds for any M with M ⊃ M.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 8 .</head><label>8</label><figDesc>An MKNF interpretation pair (M, N) consists of two MKNF interpretations M, N with ∅ ⊂ N ⊆ M. An MKNF interpretation pair satisfies a closed MKNF formula ϕ, written (M, N) | ϕ, if and only if I, M, N , M, N (ϕ) = t for each I ∈ M. If M = N, then the MKNF interpretation pair (M, N) is called total. If there exists an MKNF interpretation pair satisfying ϕ, then ϕ is consistent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Lemma 1 .</head><label>1</label><figDesc>Given a closed MKNF formula ϕ, (I, M, N) | ϕ if and only if</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Proposition 3 .</head><label>3</label><figDesc>Let (M, N) be a three-valued MKNF model of a ground hybrid MKNF knowledge base K G = (O, P G ), and (T , F ) the partition of KA(K G ) induced by (M, N). Then (M, N) = ({I | I | OB O,T }, {I | I | OB O,KA(K G )\F }).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Thus, we have I | π(O). Consider each K ξ ∈ T . Since (M, N) induces the partition (T , F ) we have (I, M, N , M, N )(K ξ) = t and thus I | ξ . Hence, I | OB O,T . Consequently, I ∈ M holds and therefore M ⊆ M .Next, we show that N ⊆ N . Let I be an interpretation in N. We show thatI ∈ N = {I | I | OB O,KA(K G )\F }, i.e. that I | {π (O)} ∪ {ξ | K ξ ∈ KA(K G ) \ F }.We already know that, for each I ∈ M, I | π(O). Since N ⊆ M, we also have that I | π(O) for each I ∈ N. Consider each K ξ / ∈ F . The premise of condition (2) in Definition 15 is false, but the premises of conditions (1) and (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Example 10 .</head><label>10</label><figDesc>Consider the hybrid MKNF knowledge base presented in Example 8, with the same limitation on the set of modal atoms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>and also that M = {I | I | OB O,T } and N = {I | I | OB O,KA(K G )\F }. It is straightforward to see that M ⊆ I P and I N ⊆ N, which by Definition 11 finishes the proof. 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>y) ∈ r I implies y ∈ C I (∃r.C) I = x ∈ I ∃y.(x, y) ∈ r I and y ∈ C I An ALC knowledge base O is a finite set of axioms formed using concepts, roles, and individuals. A concept assertion is an axiom of the form C (a) that assigns an individual a to a concept C . A role assertion is an axiom of the form r(a 1 , a 2 ) that relates two individuals a 1 , a 2 by the role r. Concept and role assertions form the ABox. A concept inclusion is an axiom of the form C 1 C 2 that states the subsumption of the concept C 1 by the concept C 2 . A concept equivalence axiom C 1 ≡ C 2 is a shortcut for two inclusions C 1 C 2 and C 2 C 1 . Concept inclusions and concept equivalences form the TBox, and the TBox and the ABox form the knowledge base O. An interpretation I satisfies a concept assertion C(a) if a I ∈ C I , a role assertion r(a 1 , a 2 ) if (a I 1 , a I 2 ) ∈ r I , a concept inclusion C 1 C 2 if C I 1 ⊆ C I 2 ,and a concept equivalence C 1 ≡ C 2 if C I 1 = C I 2 . An interpretation that satisfies all axioms of a knowledge base O is called a model of O. A concept C is called satisfiable with respect to O if O has a model I in which C I = ∅. ALC is a decidable logic, and reasoning under ALC is ExpTime-complete</figDesc><table><row><cell>[3].</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>r s that states that role r is subsumed by the role s. A role composition axiom is of the form r • s t, and it states that role t subsumes the composition of roles r and s. An interpretation I satisfies a role inclusion r s if r I s I and a role composition axiom r • s t if ∀a 1 , a 2 , a 3 ∈ I : (a 1 , a 2 ) ∈ r I ∧ (a 2 , a 3 ) ∈ s I → (a 1 , a 3 ) ∈ t I . Note that role compositions can be used to express transitivity of roles and left-and right-identity roles.</figDesc><table><row><cell cols="2">Example 2. Consider the online store scenario of Example 1. The following axioms and assertions could be part of the</cell></row><row><cell>ontology that the store uses 6 :</cell><cell></cell></row><row><cell>CD ∃HasPiece.Piece</cell><cell>(1)</cell></row><row><cell>Piece ∃HasArtist.Artist</cell><cell>(2)</cell></row><row><cell>HasPiece • HasArtist HasArtist</cell><cell>(3)</cell></row><row><cell>TopSeller OnOffer Recommend</cell><cell>(4)</cell></row><row><cell>HasPiece(BNAW, BlueTrain)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1</head><label>1</label><figDesc>Data complexity of instance checking in MKNF.</figDesc><table><row><cell>Rules</cell><cell>DL = ∅</cell><cell>DL ∈ P</cell><cell>DL ∈ coNP</cell></row><row><cell>Definite</cell><cell>P</cell><cell>P</cell><cell>coNP</cell></row><row><cell>Stratified Normal</cell><cell>P coNP</cell><cell>P coNP</cell><cell>p 2 p Π 2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>1 , . . . , t n ). We have (I, M, N) | P (t 1 , . . . , t n ) iff (t I 1 , . . . , t I n ) ∈ P I iff (I, M, M , N, N )(P (t 1 , . . . , t n )) = t.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>well-founded partition of knowledge bases consisting of only rules, coincides with the well-founded model of the corresponding (normal) logic program. Let K G be a ground program of MKNF rules, Π a normal logic program obtained from P G by transforming each MKNF rule K H ← K A 1 , . . . , K A n , not B 1 , . . . , not B m A 1 , . . . , A n , not B 1 , . . . , not B m of Π , (T W , F W ) the well-founded partition of K G , and W Π the well-founded model of Π . Then K H ∈ T W if and only if H ∈ W Π , and K H ∈ F W if and only if not H ∈ W Π .</figDesc><table><row><cell>Theorem 6. into a rule</cell></row></table><note><p>H ←</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.opengalen.org/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.ihtsdo.org/snomed-ct/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The DL SROIQ<ref type="bibr" target="#b29">[30]</ref> also provides role composition axioms, which can be used to address some, but by no means all, use cases.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>A preliminary, and much shorter version of this work was presented in<ref type="bibr" target="#b36">[37]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>See, e.g.,<ref type="bibr" target="#b26">[27]</ref> for the definitions of these and other description logics and their relationships to OWL and OWL 2.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>In these axioms, and throughout the paper, we adopt the convention that names starting with a capital letter represent concepts and roles (termed DL-atoms as defined later in the paper), while names starting with a lower case letter represent variables and predicates not appearing in the ontology (that will be called non-DL-atoms as defined later in the paper). In general, names of individuals/objects also start with a lower case letter. We only make an exception for the names in our running example as these are usually proper names.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>We focus here on the presentation as in<ref type="bibr" target="#b50">[51]</ref>, and we thus omit classical negation and arbitrary first-order formulas in rules as presented in<ref type="bibr" target="#b51">[52]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>See<ref type="bibr" target="#b2">[3]</ref> for standard translations of Description Logic axioms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>As mentioned before, our main results only apply to nondisjunctive rules, i.e. l = 1 for each rule of the form<ref type="bibr" target="#b6">(7)</ref>. However, to keep to the original definition of<ref type="bibr" target="#b51">[52]</ref>, we present the definition of the more general form of MKNF rules.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>In this encoding, for simplicity, we consider that the program part of the knowledge base is specific to each customer. This avoids an explicit representation of several customers, of the relation stating which CDs are owned by each customer, etc.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_10"><p>In comparison to<ref type="bibr" target="#b36">[37]</ref> the definition has been slightly altered to simplify proofs and computation: in case of a total MKNF interpretation pair (M, M), it is sufficient to check that no other total MKNF interpretation pair (M , M ) actually yields a true evaluation for all I ∈ M . This simplification is also justified by the intuition of enlarging N separately: there is no undefinedness in a total MKNF interpretation pair, and minimisation of undefinedness is thus not necessary.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_11"><p>This problem is akin to the coherence problem<ref type="bibr" target="#b54">[55]</ref> in extended logic programs, where a (classical false) formula ¬ϕ has to impose not ϕ explicitly.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_12"><p>See, e.g., the OWL 2 profiles at http://www.w3.org/TR/owl2-profiles/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_13"><p>http://xsb.sourceforge.net/.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank the reviewers of a previously submitted version of this paper for their very helpful comments and suggestions for improvement. We thank Frederick Maier for a thorough proofreading. Matthias Knorr acknowledges support by Fundação para a Ciência e a Tecnologia under the grant SFRH/BD/28745/2006. Pascal Hitzler acknowledges support by the National Science Foundation under award 1017225 "III: Small: TROn -Tractable Reasoning with Ontologies".</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof. Whenever α = β, the statement holds automatically. It thus suffices to consider α &lt; ω and to show via induction over α that the statement holds. If β is a successor ordinal, then it is sufficient to show the property for β = α + 1, all the other successor cases follow by transitivity of ⊆.</p><p>If α = 0, then P 0 = ∅ and P 0 ⊆ P β holds for any β. Equivalently, N 0 = KA(K G ), thus N β ⊆ N 0 also holds for any β. Suppose the property holds for all α n. We must show that P n+1 ⊆ P n+2 and N n+2 ⊆ N n+1 . We have P n+1 = Γ (N n ) and P n+2 = Γ (N n+1 ). Since N n+1 ⊆ N n by the induction hypothesis, P n+1 ⊆ P n+2 holds in virtue of the antimonotonicity of Γ . Likewise, we know that N n+1 = Γ (P n ) and N n+2 = Γ (P n+1 ). Since P n ⊆ P n+1 by the induction hypothesis, we obtain by antitonicity of Γ that N n+2 ⊆ N n+1 .</p><p>The only case left is the one where β = ω. But this case holds by definition. 2</p><p>Like the iteration of T K , and for the very same reasons, these iterations are finite and reach a fixpoint before ω -in the case of P i a least fixpoint, and in the case of N i a greatest fixpoint: Proposition 5. Let K G be a ground hybrid MKNF knowledge base. Then P ω is the least fixpoint of the sequence of P i and N ω is the greatest fixpoint of the sequence of P i .</p><p>Proof. We show the argument for P ω . The argument for N ω is analogous.</p><p>We define an operator Φ(S) = Γ K G (Γ K G (S)) on subsets S of KA(K G ), iterated as usual. It is easy to see that Φ ↑ i = P 2i and, thus, that Φ is monotonic. By the Knaster-Tarski Theorem we conclude that P ω is equal to the least fixpoint of the sequence of P i . 2</p><p>This proposition also allows us to show that the least fixpoint can be directly computed from the greatest one and vice versa.</p><p>Proof. We show the case of N ω = Γ (P ω ); the other case proceeds identically. By Proposition 5, we know that P ω is the least fixpoint of the sequence of P i . Since the ground knowledge base is finite, there is an n such that P n = P ω , and so P n = P m for any m n. Subsequently, we have N n+1 = N m for any m with m n + 1, i.e. N n+1 = Γ K G (P ω ) is a fixpoint of the sequence N i . Assume that N n+1 is not the greatest fixpoint. Then there is an N l , l &lt; n + 1, with N l = N l+2 and N l ⊃ N n+1 .</p><p>Then P l+1 also equals a fixpoint in the sequence P i with P l+1 being necessarily smaller than P n . This contradicts the initial assumption that P n is the least fixpoint and finishes the proof. 2 Thus, we can either compute the two sequences P i and N i in parallel until we reach an n such that P n = P n+1 and N n = N n+1 or we compute just one of the two fixpoints in the manner sketched in the proof of Proposition 5 (alternating between Γ K G and Γ K G ) and let the other one follow by one application of either Γ K G or Γ K G .</p><p>The two fixpoints can be used to define the well-founded partition which is, as we show in Section 4.3, the partition inducing the well-founded MKNF model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 22.</head><p>The well-founded partition of an MKNF-consistent ground hybrid MKNF knowledge base K G = (O, P G ) is defined by:</p><p>Note that we restrict the definition to MKNF-consistent hybrid MKNF knowledge bases. This is reasonable since in many cases the pair (T W , F W ) obtained for an MKNF-inconsistent knowledge base would not satisfy the conditions imposed in the definition of a partition (cf. Definition 13). Therefore, in Section 4.3, we show that all modal K-atoms derived in P ω , KA(K G ) \ N ω respectively, are true, false respectively, in all three-valued MKNF models of K G (see <ref type="bibr">Proposition 7)</ref>, including the special case, in which K G is MKNF-inconsistent. This can be used to present necessary and sufficient conditions to check for MKNF-consistency (see Theorem 2), which are based on two comparisons, each of which compares a further iteration of the operators Γ K G and Γ K G w.r.t. one of the fixpoints. Given an established check for MKNF-consistency, we can show that the well-founded partition is in fact a partial partition (see <ref type="bibr">Proposition 8)</ref>, if the considered knowledge base K G is consistent. In this case, we can also show that a corresponding MKNF interpretation pair exists that satisfies K G (see Theorem 3), and that this interpretation pair is a three-valued MKNF model of K G (see <ref type="bibr">Theorem 4)</ref>. This allows us to conclude that this specific MKNF interpretation pair corresponding to the well-founded partition is the well-founded MKNF model (see <ref type="bibr">Theorem 5)</ref>. We can then show that, given K G with empty O, the well-founded partition and the well-founded model for logic programs coincide (see Theorem 6) and finish with the results for data complexity (see <ref type="bibr">Theorem 7)</ref>. But before we come to that (in Section 4.3), we illustrate the alternating fixpoint construction in the two motivating examples (Examples 8, 9) presented before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">The well-founded MKNF model and related properties</head><p>The well-founded partition (T W , F W ) consists of modal atoms that are intended to be true (T W ), false (F W ) or undefined (those modal atoms neither occurring in T W nor in F W ). But this is not merely an intention. The two sequences of P i and N i allow us to show that any modal atom that is added to an element of the sequence of P i (resp. removed from an element of the sequence of N i ) must be true in all three-valued MKNF models of K G (resp. false). For that purpose we need to define a notion of dependency that captures more precisely the derivations from OB O,S , for some S, by the operator D K G . Definition 23. Let K G be a ground hybrid MKNF knowledge base, K H a modal K-atom with K H ∈ KA(K G ), and S a (possibly empty) set of modal K-atoms with S ⊆ KA(K G ). We say that K H depends on S if and only if</p><p>Intuitively, S is a minimal set that, in combination with O, allows us to derive K H . Note that there may exist several such minimal sets. Furthermore, S may also be minimal such that OB O,S is inconsistent. An appropriate restriction in the proof of the following proposition then ensures that this notion can be used properly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 7. Let K G be a ground hybrid MKNF knowledge base and (T ,</head><p>Proof. According to Proposition 5, we have to show that, for all i, K H ∈ P i implies that K H is true (and not H is false) in all three-valued MKNF models (M, N) of K G , and K H / ∈ N i implies that K H is false (and not H is true) in all three-valued MKNF models (M, N) of K G . We show the argument for K H by an induction on i. This also shows the argument for not H since, for all partial MKNF models (M, N) of any given K, we have that</p><p>The base case i = 0 trivially holds, since P 0 is empty and N 0 is equal to KA(K G ).</p><p>(i) Suppose that the property holds for all i n. We consider i = n + 1 for two cases, namely</p><p>we know that K H ∈ T K G /N n ↑ j for some j, and we show by induction on j that K H is true in all three-valued MKNF models (M, N) of K G . The base case holds trivially, since T K G /N n ↑ 0 is empty.</p><p>(ii) Suppose that the claim holds for all j m, and consider</p><p>If K H already occurs in T K G /N n ↑ m, then the claim holds automatically by the induction hypothesis (ii). Otherwise, there are two cases to consider. Either there is a positive rule</p><p>In the first case, by the induction hypothesis (ii), all K A i are true in all three-valued MKNF models (M, N) of K G . Additionally, there is a rule K H ← K A 1 , . . . , K A n , not B 1 , . . . , not B m in K G , and since the positive version of this rule occurs in K G /N n , no K B j occurs in N n , and thus (by the induction hypothesis (i)), all K B j are false in all three-valued MKNF models (M, N) of K G . Consequently, K H has to be true in all three-valued MKNF models (M, N) of K G . In the second case, OB O,S | H with S = T K G /N n ↑ m holds. Since O and all modal atoms occurring in T K G /N n ↑ m are true in all three-valued MKNF models of K G (by the induction hypothesis (ii)), we can immediately conclude that K H also has to be true in all three-valued MKNF models (M, N) of K G .</p><p>Alternatively, consider all</p><p>Note that OB O,P n has to be consistent, otherwise U would be empty. Now, from the definition of Γ K G (P n ) we can conclude that, for each modal K-atom K H in U , the following conditions are satisfied 14 :</p><p>(Ui) for each rule K H ← body in P G at least one of the following holds.</p><p>(Uia) Some modal K-atom K A appears in body and in U ∪ KA(K G ) \ N n .</p><p>(Uib) Some modal not-atom not B appears in body and in P n .</p><p>(Uic) OB O,P n | ¬H; (Uii) for each (possibly empty) S with S ⊆ P n , on which K H depends, there is at least one modal K-atom K A such that</p><p>The cases of (Uib) and (Uic) correspond to the removal of rules performed for the MKNF-coherent transform (cf. Definition <ref type="bibr" target="#b18">19)</ref>. By the induction hypothesis (i), we know that, for all K B ∈ P n , K B is true for all three-valued MKNF models of K G . Thus, in case of (Uib), body is false in all three-valued MKNF models of K G , and, in case of (Uic), ¬H is true in all three-valued MKNF models of K G . In case of (Uia), the corresponding rule with head K H still appears in the MKNFcoherent transform but some modal K-atom K A is not derivable and, thus, K H is not derivable either. Likewise, in case of (Uii), some modal K-atom K A is not (any longer) derivable, so that K H cannot be derived from the ontology. If K A appears in KA(K G ) \ N n , then, by the induction hypothesis (i), we know that K A is false in all three-valued MKNF models of K G . The only remaining case are those K A in U . Assume first that all conditions are satisfied without reference to U . Then, clearly, all modal K-atoms have to be false in all three-valued MKNF models of K G . Now, consider the complete conditions (Uia)-(Uii): since all K H satisfy the conditions (Uia)-(Uii), and since three-valued MKNF models minimise derivable knowledge in the order t &gt; u &gt; f, we derive that all K H are false in all three-valued MKNF models of K G . 2</p><p>For an MKNF-consistent knowledge base K G , the pair (T , F ) in Proposition 7 is defined exactly in the same way as the well-founded partition, and we show below that this correspondence indeed holds. Of course, there is still the issue of determining, based on the iterations and the consistency of O alone, whether or not the knowledge base is MKNF-consistent.</p><p>The next theorem presents the necessary and sufficient conditions for MKNF-inconsistency:</p><p>Theorem 2. Let K G = (O, P G ) be a ground hybrid MKNF knowledge base, P ω the fixpoint of the sequence P i , and N ω the fixpoint of the sequence</p><p>Proof. First, we show that if any of the three conditions holds, then K G is MKNF-inconsistent. For the two cases w.r.t. N ω and P ω , we present the proof for N ω . The other case can be proven analogously.</p><p>From Proposition 6 we know that Γ K G (N ω ) = P ω . Furthermore, by Proposition 7, we have that all modal atoms K H ∈ P ω are true in all three-valued MKNF models (M,</p><p>Either K H = K A or K H and K A appear in a set U that is constructed as in the proof of Proposition 7, e.g., for each rule K H ← body in K G //N ω , we have K A in body. In both cases, K A is true in all three-valued MKNF models of K G but the addition of all modal K-atoms that are not false in all three-valued MKNF models of K G (including K A) to O derives ¬A. We conclude that K G is MKNF-inconsistent.</p><p>The third case is a direct consequence of the way evaluation of MKNF formulas is defined: if O is inconsistent, then there is no first-order model of O. Assume that (M, N) is a three-valued MKNF model of K G . Then, (M, N) satisfies K G and thus also O, i.e., for each I ∈ M, we have (I, M, N , M, N )(π (O)) = t. Since M must not be empty, we derive a contradiction.</p><p>For the other direction, we have to show that any possibly occurring MKNF-inconsistency is detected. So, suppose that K G is MKNF-inconsistent. If O is inconsistent, then we are done immediately. Otherwise, the rules in P G alone cannot be MKNF-inconsistent, since they only consist of modal atoms without any appearance of classical negation. Likewise, rules without DL-atoms or rules without DL-atoms in at least some head cannot be inconsistent since the derivation from the ontology O never conflicts with any rule. Consider thus such an arbitrary DL-atom K H with a rule K H ← K A 1 , . . . , K A n , not B 1 , . . . , not B m in P G . If H is true as a consequence of O, then the operator D K G ensures that K H is true as well, and no inconsistency occurs.</p><p>So, let H be first-order false and K H ∈ P ω , i.e. K H is true in all three-valued MKNF models of K G . But then Γ K G (N ω ) ⊂ Γ K G (N ω ) and the inconsistency is detected. Alternatively, K H could be undefined but then K H ∈ N ω , and this is not possible since H is first-order false and Γ K G suppresses K H . So the only case missing is the one where K H is false in all threevalued MKNF models (as enforced by the operator Γ K G ) but the body of at least one rule with head K H is undefined. Thus</p><p>We apply this check for consistency to our previous examples: Example 12. Consider again K G from Example 11. We have P ω = P 3 and N ω = N 3 . We check for inconsistency (assuming O is consistent) and obtain</p><p>Now reconsider K G from Example 10. We have P ω = P 2 and N ω = N 1 . We check for consistency and obtain</p><p>Hence, the knowledge base is consistent, and we obtain the well-founded partition (T W , F W ) = K CD(Tts), K int(Tts), K Rec(Tts) , K owns(Tts), K LowEv(Tts)</p><p>The following example shows that we in fact need both the calculations w.r.t. the two fixpoints. Only the test using N ω is able to detect this inconsistency. For KA(K G ) = {K P (a)}, we obtain P ω = {K P (a)} and N ω = ∅ and thus</p><p>On the other hand, the following knowledge base is also MKNF-inconsistent, but only the test with P ω allows us to discover this, R ¬P R(a)</p><p>For KA(K G ) = {K P (a), K u} we obtain P ω = ∅ and N ω = {K u} and thus</p><p>The difference between the two examples is that in the first example there is a rule with true body and false head, while in the second example there is a rule with undefined body and false head. Each of the two conditions captures one of the cases, which explains why two conditions need to be checked.</p><p>As already said, normal rules alone cannot be inconsistent, unless integrity constraints (i.e. rules whose head is K f, cf. <ref type="bibr" target="#b51">[52]</ref>) are allowed. In this simpler case, inconsistencies are easily detected since K f must occur in KA(K G ) \ N ω .</p><p>If K G is MKNF-consistent, then the well-founded partition is in fact a partial partition.</p><p>Proposition 8. Let K G be an MKNF-consistent ground hybrid MKNF knowledge base and (T W ,</p><p>Those two equalities also yield that</p><p>It can also be shown that the well-founded partition yields an MKNF interpretation pair that satisfies K G .  Now consider π(P G ) which consists of a set of implications, each corresponding to one rule in P G . To show (I, I P , I N , I P , I N )(π (P G )) = t, we only have to guarantee that the three cases that map an implication ⊃ to false do not occur, i.e. the cases where the body of the original rule is true but the head is not (respectively, the body is undefined and the head is false). Assume that any of the three cases holds. If the body of such a rule is true, then by the alternating fixpoint construction we have that the head is true as well, contradicting these two cases. If the rule body is undefined, then (by N K G and the alternating fixpoint) we obtain that the head has to be undefined or true, again contradicting our assumption. Thus, (I, I P , I N , I P , I N )(π (P G )) = t holds. 2</p><p>This result can be combined with Proposition 3 to show that the well-founded partition results in a three-valued MKNF model. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Queries to hybrid MKNF knowledge bases through oracular tabling</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Alferes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Knorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<editor>
			<persName><forename type="first">Abraham</forename><surname>Bernstein</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tom</forename><surname>Heath</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lee</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Diana</forename><surname>Maynard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Enrico</forename><surname>Motta</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Krishnaprasad</forename><surname>Thirunarayan</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Pushing the EL envelope further</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the OWLED 2008 DC Workshop on OWL: Experiences and Directions</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Clark</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<meeting>the OWLED 2008 DC Workshop on OWL: Experiences and Directions</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
		<title level="m">The Description Logic Handbook: Theory, Implementation, and Applications, 2nd edition</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Embedding defaults into terminological representation systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hollunder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Automat. Reason</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="149" to="180" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Expressive non-monotonic description logics based on circumscription</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bonatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;06)</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Doherty</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Welty</surname></persName>
		</editor>
		<meeting>the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;06)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="400" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Tabled evaluation with delaying for general logic programs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="20" to="74" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Complexity and expressive power of logic programming</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dantsin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="374" to="425" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Embedding non-ground logic programs into autoepistemic logic for knowledge-base combination</title>
		<author>
			<persName><forename type="first">J</forename><surname>De Bruijn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tompits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI-07)</title>
		<meeting>the Twentieth International Joint Conference on Artificial Intelligence (IJCAI-07)<address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2007">January 6-12, 2007. 2007</date>
			<biblScope unit="page" from="304" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Quantified equilibrium logic and hybrid rules</title>
		<author>
			<persName><forename type="first">J</forename><surname>De Bruijn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Valverde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on Web Reasoning and Rule Systems</title>
		<meeting>the First International Conference on Web Reasoning and Rule Systems</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">AL-log: Integrating datalog and description logics</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Donini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schaerf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Intelligent Inform. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="227" to="252" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Description logics of minimal knowledge and negation as failure</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Donini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Log</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="177" to="225" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Well-founded semantics for hybrid rules</title>
		<author>
			<persName><forename type="first">W</forename><surname>Drabent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Małuszynski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on Web Reasoning and Rule Systems (RR 2007)</title>
		<meeting>the First International Conference on Web Reasoning and Rule Systems (RR 2007)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Rules and ontologies for the semantic web</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ianni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Krennwallner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reasoning Web, 4th International Summer School</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Baroglio</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bonatti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Maluszynski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Marchiori</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Schaffert</surname></persName>
		</editor>
		<meeting><address><addrLine>Venice, Italy; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008-09-07">2008. September 7-11, 2008. 2008</date>
			<biblScope unit="volume">5224</biblScope>
			<biblScope unit="page" from="1" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Combining answer set programming with description logics for the semantic web</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ianni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schindlauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tompits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">172</biblScope>
			<biblScope unit="issue">12-13</biblScope>
			<biblScope unit="page" from="1495" to="1539" />
			<date type="published" when="2008-08">August 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Effective integration of declarative rules with external evaluations for semantic web reasoning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ianni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schindlauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tompits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd European Conference on Semantic Web (ESWC 2006)</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Sure</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Domingue</surname></persName>
		</editor>
		<meeting>the 3rd European Conference on Semantic Web (ESWC 2006)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="273" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Well-founded semantics for description logic programs in the semantic web</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schindlauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tompits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rules and Rule Markup Languages for the Semantic Web, RuleML&apos;04</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Antoniou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Boley</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="81" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Hybrid reasoning with forest logic programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Feier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heymans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th Annual European Semantic Web Conference (ESWC 2009)</title>
		<imprint>
			<date type="published" when="2009-06">June 2009</date>
			<biblScope unit="page" from="338" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Fitting</surname></persName>
		</author>
		<title level="m">First-Order Logic and Automated Theorem Proving</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The stable model semantics for logic programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conference on Logic Programming, ICLP</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Bowen</surname></persName>
		</editor>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1070" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Implementing query answering for hybrid mknf knowledge bases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Alferes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Practical Aspects of Declarative Languages, 12th International Symposium</title>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">January 18-19, 2010. 2010</date>
			<biblScope unit="page" from="25" to="39" />
		</imprint>
	</monogr>
	<note>PADL 2010</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A preferential tableaux calculus for circumscriptive ALCO</title>
		<author>
			<persName><forename type="first">S</forename><surname>Grimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Web Reasoning and Rule Systems, Third International Conference</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Swift</surname></persName>
		</editor>
		<meeting><address><addrLine>Chantilly, VA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009-10">2009. October 2009. 2009</date>
			<biblScope unit="page" from="197" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Semantic matchmaking of web resources with local closed-world reasoning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Grimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internat. J. e-Commerce</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="89" to="126" />
			<date type="published" when="2007">2007-2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Matching semantic service descriptions with local closed-world reasoning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Grimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Preist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Semantic Web: Research and Applications, 3rd European Semantic Web Conference</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Sure</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Domingue</surname></persName>
		</editor>
		<meeting><address><addrLine>Budva, Montenegro</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-06-11">2006. June 11-14, 2006. 2006</date>
			<biblScope unit="page" from="575" to="589" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Description logic programs: Combining logic programs with description logics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Grosof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Volz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Decker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the World Wide Web Conference</title>
		<meeting>the World Wide Web Conference<address><addrLine>Budapest, Hungary</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="page" from="48" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Open answer set programming for the semantic web</title>
		<author>
			<persName><forename type="first">S</forename><surname>Heymans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Van Nieuwenborgh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vermeir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Appl. Log</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="144" to="169" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/owl2-primer/" />
		<title level="m">OWL 2 Web Ontology Language: Primer, W3C Recommendation</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2009-10-27">27 October 2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Foundations of Semantic Web Technologies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Chapman &amp; Hall/CRC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Ontologies and rules</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook on Ontologies, 2nd edition</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Staab</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Studer</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="111" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A uniform approach to logic programming semantics, Theory Pract</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wendt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Log. Program</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="123" to="159" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<title level="m">Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Doherty</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Welty</surname></persName>
		</editor>
		<meeting>of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="page" from="57" to="67" />
		</imprint>
	</monogr>
	<note>The even more irresistible SROIQ</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Can OWL and logic programming live together happily ever after</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5th Int. Semantic Web Conference (ISWC 2006)</title>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Decker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Allemang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Preist</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Schwabe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Mika</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><surname>Uschold</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lora</forename><surname>Aroyo</surname></persName>
		</editor>
		<meeting>of the 5th Int. Semantic Web Conference (ISWC 2006)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4273</biblScope>
			<biblScope unit="page" from="501" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A proposal for an OWL rules language</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th Int. World Wide Web Conference</title>
		<meeting>of the 13th Int. World Wide Web Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page" from="723" to="731" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Data complexity of reasoning in very expressive description logics</title>
		<author>
			<persName><forename type="first">U</forename><surname>Hustadt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19th Int. Joint Conference on Artifical Intelligence (IJCAI)</title>
		<meeting>of the 19th Int. Joint Conference on Artifical Intelligence (IJCAI)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="466" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Next steps for description logics of minimal knowledge and negation as failure</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2008 Description Logic Workshop</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</editor>
		<meeting>of the 2008 Description Logic Workshop</meeting>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Querying in EL + with nonmonotonic rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Knorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Alferes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th European Conference on Artificial Intelligence, ECAI 2010</title>
		<meeting>the 19th European Conference on Artificial Intelligence, ECAI 2010</meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1079" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Towards tractable local closed world reasoning for the semantic web</title>
		<author>
			<persName><forename type="first">M</forename><surname>Knorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Alferes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Progress in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Neves</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Santos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Machado</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="3" to="14" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A coherent well-founded model for hybrid MKNF knowledge bases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Knorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Alferes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th European Conference on Artificial Intelligence, ECAI 2008</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Ghallab</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Spyropoulos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Fakotakis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Avouris</surname></persName>
		</editor>
		<meeting>the 18th European Conference on Artificial Intelligence, ECAI 2008</meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="99" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A comparison of disjunctive well-founded semantics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Knorr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAInt-07, Foundations of Artificial Intelligence, Workshop at KI 2007, CEUR Workshop Proceedings</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">277</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Description Logic Rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Stud. Semantic Web.</title>
		<imprint>
			<biblScope unit="volume">008</biblScope>
			<date type="published" when="2010">2010</date>
			<publisher>IOS Press/AKA</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<title level="m">Proc. of the 12th European Conf. on Logics in Artificial Intelligence (JELIA&apos;10)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Janhunen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Niemelä</surname></persName>
		</editor>
		<meeting>of the 12th European Conf. on Logics in Artificial Intelligence (JELIA&apos;10)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="234" to="246" />
		</imprint>
	</monogr>
	<note>Efficient inferencing for OWL EL</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Description logic rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th European Conference on Artificial Intelligence, ECAI 2008</title>
		<editor>
			<persName><forename type="first">Malik</forename><surname>Ghallab</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Constantine</forename><forename type="middle">D</forename><surname>Spyropoulos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Nikos</forename><surname>Fakotakis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Nikos</forename><surname>Avouris</surname></persName>
		</editor>
		<meeting>the 18th European Conference on Artificial Intelligence, ECAI 2008</meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="80" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">ELP: Tractable rules for OWL 2</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Semantic Web Conference (ISWC-08)</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Staab</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Dean</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Paolucci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Maynard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Finin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Thirunarayan</surname></persName>
		</editor>
		<meeting>the 7th International Semantic Web Conference (ISWC-08)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="649" to="664" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Complexity boundaries for Horn description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd AAAI Conference on Artificial Intelligence (AAAI&apos;07)</title>
		<meeting>the 22nd AAAI Conference on Artificial Intelligence (AAAI&apos;07)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="452" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">On the semantic relationship between datalog and description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">H</forename><surname>Schmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Interational Conference on Web Reasoning and Rule Systems (RR&apos;10)</title>
		<meeting>the 4th Interational Conference on Web Reasoning and Rule Systems (RR&apos;10)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="88" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A better uncle for OWL: Nominal schemas for integrating rules and ontologies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Krisnadhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<ptr target="http://knoesis.org/library/" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International World Wide Web Conference</title>
		<meeting>the 20th International World Wide Web Conference</meeting>
		<imprint>
			<publisher>WWW</publisher>
			<date type="published" when="2011-03">2011. March/April 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Combining Horn rules and description logics in CARIN</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="165" to="209" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Nonmonotonic databases and epistemic queries</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Joint Conference on Artifical Intelligence, IJCAI&apos;91</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="381" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A novel combination of answer set programming with description logics for the semantic web</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th European Semantic Web Conference (ESWC 2007)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Franconi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>May</surname></persName>
		</editor>
		<meeting>the 4th European Semantic Web Conference (ESWC 2007)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="384" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Any-world access to OWL from Prolog</title>
		<author>
			<persName><forename type="first">T</forename><surname>Matzner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KI 2007: Advances in Artificial Intelligence, 30th Annual German Conference on AI</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Hertzberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Beetz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Englert</surname></persName>
		</editor>
		<meeting><address><addrLine>Osnabrück, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007-09">September 2007. 2007</date>
			<biblScope unit="page" from="84" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Closing semantic web ontologies</title>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>University of Manchester, UK</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A faithful integration of description logics with logic programming</title>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI-07)</title>
		<meeting>the Twentieth International Joint Conference on Artificial Intelligence (IJCAI-07)<address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2007">January 6-12, 2007. 2007</date>
			<biblScope unit="page" from="477" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Reconciling description logics and rules</title>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="93" to="154" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Query-answering for OWL-DL with rules</title>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Studer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semantics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="60" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Matching patient records to clinical trials using ontologies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Cimino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dolby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fokoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kalyanpur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kershenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Schonberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Srinivas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC/ASWC</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="816" to="829" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Well founded semantics for logic programs with explicit negation</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Alferes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Artifical Intelligence, ECAI</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="102" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">What should a database know?</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Log. Program</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="127" to="153" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">On the decidability and complexity of integrating ontologies and rules</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semantics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="60" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">DL+Log: A tight integration of description logics and disjunctive datalog</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tenth International Conference on the Principles of Knowledge Representation and Reasoning, KR&apos;06</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Doherty</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Mylopoulos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Welty</surname></persName>
		</editor>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="68" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Lattice-theoretic fixpoint theorem and its applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tarski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pacific J. Math</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="285" to="309" />
			<date type="published" when="1955">1955</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">The alternating fixpoint of logic programs with negation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Database Systems</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">The well-founded semantics for general logic programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Schlipf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="620" to="650" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Why is modal logic so robustly decidable?</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Descriptive Complexity and Finite Models, Proceedings of a DIMACS Workshop</title>
		<editor>
			<persName><forename type="first">Neil</forename><surname>Immerman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</editor>
		<editor>
			<persName><surname>Kolaitis</surname></persName>
		</editor>
		<meeting><address><addrLine>Princeton University</addrLine></address></meeting>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1996">January 14-17, 1996. 1996</date>
			<biblScope unit="page" from="149" to="184" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
