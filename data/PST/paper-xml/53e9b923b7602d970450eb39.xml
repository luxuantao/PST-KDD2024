<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">BLAS : An Efficient XPath Processing System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yi</forename><surname>Chen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Susan</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Yifeng</forename><surname>Zheng</surname></persName>
							<email>yifeng@cis.upenn.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">INRIA-FUTURS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">BLAS : An Efficient XPath Processing System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2FDA4E5E318088FC751A2BFAA22A3DEB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present BLAS , a Bi-LAbeling based System, for efficiently processing complex XPath queries over XML data. BLAS uses Plabeling to process queries involving consecutive child axes, and D-labeling to process queries involving descendant axes traversal. The XML data is stored in labeled form, and indexed to optimize descendent axis traversals. Three algorithms are presented for translating complex XPath queries to SQL expressions, and two alternate query engines are provided. Experimental results demonstrate that the BLAS system has a substantial performance improvement compared to traditional XPath processing using D-labeling.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>XML is rapidly emerging as the de facto standard for exchanging data on the Web. Due to its complex, tree-like structure, languages for querying XML are based on path navigation (e.g. XPath <ref type="bibr" target="#b13">[11]</ref>), and typically include the ability to traverse from a given node to a child node (the "child axis") or from a given node to a descendant node (the "descendant axis"). XML query languages also give the ability to qualify traversals based on branches, wildcards and value predicates.</p><p>As an example, suppose a biologist is interested in proteins belonging to the "cytochrome c" family. He remembers that Dr. Evans, M.J. wrote an important paper about this family of proteins in 2001, but cannot remember the title of the paper. Using the XML protein repository shown in figure <ref type="figure" target="#fig_0">1</ref>, the XPath query shown in figure <ref type="figure" target="#fig_1">2</ref> could be used to retrieve the desired information.</p><p>Since data sets may be large and complex, efficiently querying XML data is a major concern. To address this problem, several techniques for storing XML in relational databases have been proposed in order to leverage the power of relational technology for query processing. The simplest and most generic proposal is to treat an XML document as a graph <ref type="bibr" target="#b19">[17]</ref>, and generate a tuple for every XML node with its parent identifier. In this way, the parentchild relationship over two lists of XML nodes can be found out by a join. To reduce the number of joins required to answer an XML query, techniques which depend on a schema graph <ref type="bibr" target="#b29">[27,</ref><ref type="bibr" target="#b6">4,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b10">8,</ref><ref type="bibr" target="#b9">7]</ref> have been proposed to inline each distinct child into the parent tu-  ple. However, in general many joins are needed to evaluate a single descendant axis. Furthermore, we have to rely on auxiliary code in some general-purpose program language together with SQL to express some XML queries (for example, descendant axis).</p><p>Recently, a labeling technique <ref type="bibr" target="#b18">[16,</ref><ref type="bibr" target="#b25">23,</ref><ref type="bibr" target="#b3">1,</ref><ref type="bibr" target="#b5">3,</ref><ref type="bibr" target="#b33">31,</ref><ref type="bibr" target="#b15">13]</ref> was proposed to efficiently handle descendant axis traversal. In this paper, we refer to the technique as D-labeling, where D stands for descendant axis. D-labeling encodes every XML node by a pair of numbers (an interval) such that the ancestor-descendant relationship between two nodes can be determined simply by comparing intervals. The level of the node is also used to distinguish the parent-child relationship from the ancestor-descendant relationship. In this way, either a descendant or child axis can be processed by one join, and no auxiliary code except SQL is necessary to express an XML query. <ref type="bibr" target="#b15">[13]</ref> shows the effectiveness of XQuery processing using D-labeling compared with other XQuery implementations.</p><p>However, D-labeling is not efficient for complex queries such as that in figure 2. To evaluate this query using D-labeling, we first find all nodes tagged with proteinDatabase and all nodes tagged with proteinEntry, and join them according to their D-labels. We must then join the result with all nodes tagged with protein, and so on. Essentially, any two tags connected by a descendant axis, child Q = /proteinDatabase/proteinEntry[protein//superfamily ="cytochrome c"]/reference/refinfo[//author = "Evans, M.J." and year = "2001"]/title axis, or a branch will involve a join. Thus in our example a total of 8 joins are needed. Furthermore, all nodes whose tags appear in the query must be visited to answer the query. Since joins are used extensively for query processing with Dlabeling, <ref type="bibr" target="#b4">[2,</ref><ref type="bibr" target="#b8">6,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b12">10,</ref><ref type="bibr" target="#b21">19,</ref><ref type="bibr" target="#b31">29,</ref><ref type="bibr" target="#b22">20]</ref> have proposed several new techniques to optimize this type of join. These techniques yield a significant performance improvement over the joins of a relational database. However, as seen in the example above, the sheer number of joins and disk accesses needed renders D-labeling inefficient for complex queries even using these techniques. Since the primary bottleneck for evaluating complex queries efficiently is the number of joins and disk accesses, in this paper we therefore address the problem of reducing the number of joins and disk accesses required for complex XPath queries, as well as optimizing the join operations.</p><p>Motivated by the compression scheme of XPRESS <ref type="bibr" target="#b28">[26]</ref>, we propose a labeling scheme called P-labeling (P stands for path) which optimizes an important class of queries called suffix path queries. Suffix path queries start with an optional descendant axis step followed by zero or more child axis steps.</p><p>Based on P-labeling and D-labeling, we build a system called BLAS (a Bi-LAbeling based System) to efficiently process XPath queries which can be represented as trees. BLAS is composed of three parts: an index generator, a query translator and a query engine. The index generator stores the P-labeling, D-labeling as well as data values of an XML document. The query translator decomposes an XPath query into a set of suffix path queries, encodes each suffix path query using P-labeling, generates a corresponding SQL query for each suffix path query, and finally composes the SQL subqueries into a complete SQL query plan using D-labeling. The query engine can be either a RDBMS or can use the optimized join techniques of <ref type="bibr" target="#b4">[2,</ref><ref type="bibr" target="#b8">6,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b12">10,</ref><ref type="bibr" target="#b21">19,</ref><ref type="bibr" target="#b31">29,</ref><ref type="bibr" target="#b22">20]</ref>. In particular, we focus on the holistic twig join of <ref type="bibr" target="#b8">[6]</ref>.</p><p>We propose and evaluate three query translation algorithms to translate a complex XPath query into SQL: Split, Push-Up and Unfold. The first algorithm splits an XPath query recursively according to the descendant axes and branches, resulting in a set of suffix path subqueries. Each suffix path subquery can be transformed into an efficient SQL subquery using P-labels. These SQL subqueries are then combined using D-labels to obtain the final SQL query plan. We show that the query plan generated by Split algorithm requires fewer joins, much fewer disk accesses and produces smaller intermediate results than approaches based solely on D-labeling. The next query translation algorithm, Push-up, enhances Split by producing more specific subqueries and further reducing disk accesses and the size of intermediate results. Finally, Unfold uses schema information to further improve the query processing of the Push Up algorithm. Within BLAS , we use Push-Up when schema information is not available, and Unfold otherwise.</p><p>The outline and contributions of this paper are:</p><p>1. Section 3: We present a new labeling scheme called P-labeling, which can efficiently evaluate suffix path queries using selections on P-labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Section 4:</head><p>We present the BLAS system based on P-labeling and D-labeling as a generic framework for XML storage and query processing. We close by discussing related and future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">QUERY LANGUAGE</head><p>In this paper, we focus on a commonly used subset of XPath queries consisting of child axis navigation (/), descendant axis navigation (//), and branches (or qualifiers, denoted as [..]). Since such queries can be represented as trees, we call them tree queries. Queries without branches can be represented as paths, and are called path queries.</p><p>For example, the query in figure <ref type="figure" target="#fig_1">2</ref> is represented as the query tree of figure <ref type="figure">3</ref>. We create a node for each tag in the query, and annotate the node with the tag. The return node is darkened. An unannotated line between two nodes represents a child axis, and a line annotated with // represents a descendant axis. The root has an incoming edge to indicate that it starts with axis / or //. If a node has more than one child then it is a branching point. For example, the nodes tagged with ProteinEntry and refinfo are two branching points. If the return node is not a leaf then it is also a branching point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1:</head><p>The evaluation of a path expression P returns the set of nodes in an XML tree T which are reachable by P starting from the root of T . This set of XML nodes is denoted as</p><formula xml:id="formula_0">[[P ]].</formula><p>Since a path expression P can be evaluated to retrieve a set of XML nodes, we use "path expression" and "query" interchangeably.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.2:</head><p>A path expression P is contained in a path expression Q, denoted P ⊆ Q, if and only if for any XML tree T ,</p><formula xml:id="formula_1">[[P ]] ⊆ [[Q]]. Path expressions P and Q are non-overlapping, denoted P ∩ Q = ∅, if and only if for any XML tree T , [[P ]] ∩ [[Q]] = ∅.</formula><p>We process a complex XPath query by decomposing it to a set of subqueries called suffix path expressions. Suffix path expressions have special properties that enable efficient evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.3:</head><p>A suffix path expression is a path expression P which optionally begins with a descendant axis step (//), followed by zero or more child axis steps (/). A simple path expression, which only contains child axis steps, is a special type of suffix path expression.</p><p>For example, //protein/name is a suffix path expression. Another example is /proteinDatabase/proteinEntry/protein/name, which is also a simple path expression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.4:</head><p>A source path of a node n in an XML tree T , denoted as SP (n), is the unique simple path P from the root to itself.</p><p>Evaluating a suffix path query Q entails finding all the nodes n such that SP (n) ⊆ Q. Notice that a simple path expression q is contained in a suffix path expression Q if and only if q has suffix Q, excluding the leading "//". Therefore the evaluation of a suffix path query Q yields all XML nodes whose source paths have a suffix Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE LABELING SCHEME</head><p>In this section, we present a bi-labeling scheme which transforms XML data into relations, and XPath queries into SQL which can be efficiently evaluated over the transformed relations. The labeling scheme consists of two labels, one for speeding up descendant axis steps (D-label), and the other for speeding up consecutive child axis steps (P-label). We then build a generic B + tree index on the labels. Using a combination of labeling and indexing, we achieve significant speed up for a large class of XPath queries.</p><p>For simplicity, we focus the discussion on a single document. The algorithm can be easily extended to multiple documents by introducing document id information into the labeling scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">D-labeling</head><p>An XPath query frequently contains descendant axes //. For example, the query //t1//t2 asks for all nodes tagged with t2 which are descendants of some node tagged with t1. Recently, D-labeling was applied <ref type="bibr" target="#b18">[16,</ref><ref type="bibr" target="#b25">23,</ref><ref type="bibr" target="#b3">1,</ref><ref type="bibr" target="#b5">3,</ref><ref type="bibr" target="#b33">31,</ref><ref type="bibr" target="#b15">13]</ref>  In this way, the ancestor-descendant relationship between any two nodes can be determined solely by checking their D-labels.</p><p>In this paper, we adopt the implementation of D-labeling suggested in <ref type="bibr" target="#b33">[31,</ref><ref type="bibr" target="#b15">13]</ref>. Let the interval of a node n denote the area between the start tag and end tag of n. The implementation is based on the following observation: an XML node m is a descendant of another node n if and only if m is nested within n in the XML document. Let d1 and d2 for a node n be the position of the start tag and end tag of n in the XML document, respectively. To distinguish child from descendant, d3 is set to be the level of n in the XML tree. Here, the level of n is defined as the length of the path from the root to n. For example, in figure <ref type="figure" target="#fig_0">1</ref> the first node tagged classification begins at position 7 and ends at position 11 (we treat each start tag, end tag and text as a separate unit). Its level is 4. It is easy to see that this implementation satisfies all the requirements of a D-label. In what follows, a D-label will be represented as &lt; start, end, level &gt;.</p><p>To use this labeling scheme for processing descendant axis queries such as //t1//t2, we first retrieve all the nodes reachable by t1 and by t2, resulting in two lists l1 and l2. We then test for the ancestordescendant relationship between nodes in list l1 and those in list l2. Interpreting l1 and l2 as relations, this test is a join with "descendant" property as the join predicate. We therefore call this a D-join.</p><p>Example 3.1: As an example, consider the query //proteinDatabase //refinfo and let pDB and refinfo be relations which store nodes tagged by proteinDatabase and refinfo, respectively. The D-join could be expressed in SQL as follows: select pDB.start, pDB.end, refinfo.start, refinfo.end from pDB, refinfo where pDB.start &lt; refinfo.start and pDB.end &gt; refinfo.end</p><p>The key idea of D-labeling is to speed up descendant axis navigation. Since queries typically involve several child axis steps, it is also important to implement child axis navigation efficiently. For example, consider the following XPath query: /proteinDatabase/proteinEntry/protein/name This query retrieves the names of proteins for each protein entry in the XML file. Using D-labeling, each child axis is processed as a D-join, resulting in a query with 3 D-joins. Since the join operation is very expensive compared to relational select and project operations, an immediate question is whether we can reduce the number of D-joins in queries with multiple child axis steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">P-labeling</head><p>The P-labeling scheme is used to efficiently process consecutive child axis steps (a suffix path query). The intuition of P-labeling is that each XML node n is annotated with a label according to its source path SP (n), and a suffix path query Q is also annotated with a label, such that the containment relationship between SP (n) and Q can be determined by examining their labels. Hence suffix path queries can be evaluated efficiently. Using the definition of a suffix path expression, it is not hard to prove that for any two suffix paths P and Q, either P and Q have a containment relationship (that is, P ⊆ Q or Q ⊆ P ), or they are non-overlapping. Therefore if P.p1 is contained in the P-label of Q (an interval), then P.p2 is also contained in the P-label of Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">P-labeling Properties</head><p>Since the evaluation of a suffix path query Q entails finding all XML nodes n such that SP (n) ⊆ Q, the evaluation can be implemented as finding all n such that the P-label of SP (n) is contained in the P-label of Q. As discussed above, this is equivalent to finding all nodes n such that Q.p1 ≤ SP (n).p1 ≤ Q.p2. Therefore, we call SP (n).p1 the P-label for an XML node, and evaluate suffix path query Q by obtaining the set of XML nodes whose P-labels are contained in the P-label of Q. Formally, Definition 3.3: For an XML node n, such that SP (n) =&lt; p 1, p2 &gt;, the P-label for this XML node,denoted as n.plabel, is the integer p1.</p><p>Notice that here the concept of P-label is overloaded for suffix paths and XML nodes. Though we could define the P-label of an XML node n to be the P-label of its source path SP (n), using the start position of the interval (p1) saves space without affecting the result of query evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3.2:</head><p>Let Q be a suffix path query. Then  </p><formula xml:id="formula_2">[[Q]] = {n|Q.p 1 ≤ n.plabel ≤ Q.p2} 0 10000 / //</formula><formula xml:id="formula_3">1: &lt; p 1 , p 2 &gt; = &lt; 0, m -1 &gt; 2: for i = n; i ≥ 1; i --do 3: Find t j such that t j = l i 4: p 1 = p 1 + (p 2 -p 1 + 1) * Σ j-1 k=0 r k 5: p 2 = p 1 + (p 2 -p 1 + 1) * Σ j k=0 r k -1 6: p 1 = p 1 , p 2 = p 2 7: end for 8: if α == / then 9: p 2 = p 1 + (p 2 -p 1 + 1) * r 0 -1 10: end if 11: return &lt; p 1 , p 2 &gt; Furthermore, if Q is a simple path, then: [[Q]] = {n|Q.p1 = n.plabel}</formula><p>If we consider the P-label of a node to be an attribute in a relation, this test is essentially a select operation using "containment" on Plabel as the predicate. If we build a B + tree on P-labels, this can be evaluated very efficiently.</p><p>The advantage of P-labeling is that we do not need to evaluate every child axis in a suffix path P ; qualified nodes can be found by checking their P-labels. In contrast, using D-labeling, every child axis is evaluated one after another, and a total of (l -1) D-joins are needed where l is the number of axis steps (/ or //) in P .</p><p>As we can see, D-labeling takes advantage of the well-nestedness of XML data and provides a "node containment" labeling scheme to detect ancestor-descendant relationship efficiently. P-labeling takes advantage of suffix path expressions, providing a "path containment" labeling scheme to implement child axis steps. </p><formula xml:id="formula_4">Algorithm 2 P-Label(XML tree: T) 1: Stack s 2: for all i do 3: &lt; p i1 , p i2 &gt; = P-Label(//t i ) 4: end for 5: push(s, &lt; 0, m -1 &gt;) 6: Depth-first search(T){ 7: if current tag is &lt; t i &gt; then 8: &lt; p 1 , p 2 &gt; = top(s) 9: p 1 = p i1 + p 1 * (p i2 -p i1 + 1)/m 10: p 2 = p i1 + (p 2 + 1) * (p i2 -p i1 + 1)/m -</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">P-labeling Construction</head><p>Our approach is described as follows. Suppose that there are n distinct tags (t1, . . . , tn). We assign "/" a ratio r0, and each tag ti a ratio ri , such that n i=0 ri = 1. Let ri = 1/(n + 1) for all i. Define the domain of the numbers in a P-label to be integers in [0, m -1]. The m is chosen such that m ≥ (n + 1) h , where h is the longest path in an XML tree. The length of a P-label of a suffix path expression is the number of integers contained in the P-label interval. Suppose there is an ordering for tags, where the particular ordering used is not important. Using the tag ratios and the order, we construct P-labels for suffix path expressions as follows:</p><p>1. Path // is assigned an interval (P-label) of &lt; 0, m -1 &gt;.</p><p>2. Partition the interval &lt; 0, m -1 &gt; in tag order proportional to ti's ratio ri for each path //ti and /'s ratio r0. Assuming that the order of tags is t1, t2, ..., tn, this means that we allocate an interval &lt; 0, m * r0 -1 &gt; to / and &lt; pi, pi+1 -1 &gt; to each ti, such that (pi+1pi)/m = ri and p1/m = r0.</p><p>Intuitively, we allocate &lt; 0, p1 &gt; to suffix paths starting with "/", and &lt; pi, pi+1 -1 &gt; to suffix paths starting with "//ti".</p><p>3. For the interval of a path //ti, we further partition it into subintervals by tags in order according to their ratios. Each path //tj/ti (or /ti) is now assigned a subinterval, and the proportion of the length of interval of //tj/ti (or /ti) over the length of interval of //ti is the ratio rj (or r0).</p><formula xml:id="formula_5">Intuitively, since [[//tj/ti]] ⊆ [[//ti]] and [[/ti]] ⊆ [[//ti]],</formula><p>we partition the interval for //ti into subintervals according to the ratio of all tags tj and the ratio for /.</p><p>4. Continue to partition over each subinterval as needed.</p><p>As an example, the partitioning procedure for m = 10001 and tags t 1, t2, t3, . . . , t9 is illustrated in figure <ref type="figure" target="#fig_4">4</ref>. The P-label assigned to path /t1/t2 is &lt; 2100, 2110 &gt;.</p><p>It is easily seen that this implementation of the P-labeling scheme is valid, i.e. it satisfies the properties in definition 3.2 . The detailed algorithms for constructing the P-label of suffix paths and of XML nodes are presented in algorithms 1 and 2, respectively.</p><p>To evaluate a suffix path query P , we check whether the P-label of a node is contained in P 's P-label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.3:</head><p>Let us look at how to construct P-labels for the sample XML data in figure <ref type="figure" target="#fig_0">1</ref>. For simplicity, assume m = 10 12 and that there are 99 tags. Each tag is assigned a ratio 0.01. Suppose the order is /, ProteinDatabase, ProteinEntry, protein, name, . . .. Figure <ref type="figure">5</ref> shows how to construct a P-label for suffix path P =/ProteinDatabase/ProteinEntry/protein/name according to algorithm 1. We begin by assigning P-label &lt; 4 × 10 10 , 5 × 10 10 -1 &gt; to suffix path //name. Then we extract a subinterval from it according to the tag order and the ratio of tag protein, and get the P-label for path //protein/name, and so on. Finally we get the P-label for suffix path P as &lt; 4.030201 × 10 10 , 4.03020101 × 10 10 -1 &gt;. According to the definition 3.3, every node reachable by P is assigned a P-label 4.030201 × 10 10 .</p><p>As an example of evaluating a suffix path query, suppose we wish to evaluate query //protein/name. First we compute its P-label: &lt; 4.03×10 10 , 4.04×10 10 -1 &gt; as shown in figure <ref type="figure">5</ref>. Then we find all the nodes n such that 4.03×10 10 ≤ n.plabel ≤ 4.04×10 10 -1. Suppose all the XML nodes are stored in a relation nodes, and each node corresponds to a tuple. The attribute plabel records the Plabel of the node. The suffix path query can be evaluated by the following SQL statement:  As illustrated above, nodes with source path /ProteinDatabase/-ProteinEntry/protein/name have a plabel 4.030201 × 10 10 , and are therefore part of the answer to this query. P-labeling works very well for suffix path queries as shown in this section. However, many practical examples have branch predicates and/or descendent axis navigation in the middle of the query. Used alone, P-labeling is not helpful for processing these complex queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">BLAS SYSTEM</head><p>To efficiently answer complex queries, we propose BLAS , which is based on P-labeling and D-labeling schemes. The architecture of BLAS is presented in Figure <ref type="figure" target="#fig_5">6</ref>. BLAS is composed of three parts: an index generator, a query translator and a query engine.</p><p>The BLAS index generator handles events generated by a SAX parser over an XML document. It builds P-labels and D-labels for each element node, and stores text values. Specifically, a tuple &lt;plabel, start, end, level, data&gt; is generated for every node n, where plabel is the P-label of n, start and end are the start and end tag positions of n in the XML document, respectively, level is the level of n, and data is used to store the value of n if there is any (otherwise, data is set to null). Notice that &lt;start, end, level&gt; is the D-labeling of the XML document. Furthermore, the tuples are clustered by {plabel, start}, and B + tree indexes are built on start, plabel and data to facilitate searches.</p><p>The BLAS query translator translates an input XPath query into standard SQL. It is composed of three modules: query decomposition, SQL generation and SQL composition. The query decom-position module generates a tree representation of the input XPath query, splits the query into a set of suffix path queries, and records the ancestor-descendant relationship between the results of these suffix path queries. For each suffix path query, the SQL generation module computes the query's P-labeling and generates a corresponding subquery in SQL. Finally, the subqueries are combined into a single SQL query plan by the SQL composition module based on D-labeling and the ancestor-descendant relationship between the suffix path queries results.</p><p>There are two alternative query engines. One is an RDBMS and the other is a file system implementing holistic twig joins <ref type="bibr" target="#b8">[6]</ref>. <ref type="foot" target="#foot_0">1</ref>We have discussed the index generator in section 3; next we will present the query translator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Query Translator</head><p>In this section, we will present three query translation algorithms -Split, Push-up and Unfold -that translate a complex XPath query into an efficient SQL query plan. Split is used only for purposes of exposition; for reasons that will become clear in section 5, Unfold is used in BLAS when schema information is present and Push-up when it is absent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Split Algorithm</head><p>The simplest query translator algorithm is called Split. The algorithm splits the query tree into one or more parts, where each part is a suffix path query.</p><p>Split consists of two steps: descendent axis elimination and branch elimination. Exchanging the order of these two steps will not affect the query result. The two steps can also be interleaved. The basic operation of descendant-axis elimination (shown in algorithm 3) is to take a query as input, do a depth-first traversal and split any descendent axis of form p//q, into p and //q.</p><p>In algorithm 3, answer is an abstract function which invokes the next step (B-elimination) if there are branching points in the query tree Q; otherwise, it evaluates Q using P-labeling. A D-join is then used to join intermediate results by their D-labels. as discussed in section 3.1.</p><p>The basic operation of branch elimination is to take a query as input, do a depth-first traversal and split any branch axis of form p[q1, q2, . . . , q l ]/r into p, //q1, //q2, . . . , //q l , //r (see algorithm 4). As in algorithm 3, answer is an abstract function. If Q is a suffix path query, Q is evaluated using P-labeling. Otherwise, if Q contains descendant axes, D-elimination is called to further decompose it into suffix path queries. A D-join is then used to join intermediate results by their D-labels. Different than the Djoins discussed in section 3.1, we use level information in the where clause of a SQL statement to specify the level difference between the intermediate results.   <ref type="figure">3</ref>. Figure <ref type="figure">7</ref> illustrates how to eliminate the descendent axis. Since Q1 contains branching points, the branch elimination procedure must be invoked to further decompose it. Branch axis is further eliminated in Figure <ref type="figure">8</ref>. After that, we can see that each resulting subquery is a suffix path query, which can be evaluated directly using P-labeling as discussed in section 3.2.</p><p>Suppose the evaluation of Q4 results in a list of nodes pEntry that are reachable by path /ProteinDatabase/ProteinEntry, and the evaluation of Q7 results in a list of nodes refinfo that are reachable by path //reference/refinfo. pEntry and refinfo are D-joined as follows: select pEntry.start, pEntry.end, refinfo.start, refinfo.end from pEntry, refinfo where pEntry.start &lt; refinfo.start and pEntry.end &gt; refinfo.start and pEntry.level = refinfo.level -2</p><p>Note that we have pEntry.level = refinfo.level -2 in the where clause, which is different from the general D-join algorithm where no level predicate is needed in the where clause. This is because the paths ProteinDatabase/ProteinEntry and reference/refinfo are connected directly in the original query (figure <ref type="figure">3</ref>), therefore the Pro-teinEntry nodes returned by the query ProteinDatabase/ProteinEntry are grandfather of the refinfo nodes returned by the query //reference/refinfo rather than an general ancestor. This information about level difference can be obtained from the branch elimination procedure. Also the D-labels of both pEntry and refinfo are recorded since they may be involved in D-joins with other intermediate results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Push-up Algorithm</head><p>As illustrated in section 4.1.1, Split decomposes a complex query into a set of subqueries, each of which is a suffix path query. Observe that the branch elimination algorithm, which eliminate a branch of form p[q1, q2, . . . , q l ]/r into p, //q1,//q2, . . . , //q l , //r, ignores the fact that the root of qi, 1 ≤ i ≤ l and r is a child of the  This observation causes us to redesign the basic operation of branch elimination so as to split a query of form p[q1, q2, . . . , q l ]/r into p, p/q1,p/q2, . . . , p/q l , p/r (see algorithm 5). The intuition is that during branch elimination, for each branching point n we push up the path expression of n's children toward the root. We call this step push-up branch elimination, and the whole query processing algorithm the Push-up algorithm. The key difference between algorithm 4 and algorithm 5 is that we use a variable SP to record the complete path from the root of the input query tree Q to the root of a subtree Q . Then we concatenate SP with Q and evaluate SP/Q .</p><p>In contrast to the Split algorithm, the ordering of the descendantaxis elimination and push-up branch elimination in the Push-up algorithm matters in terms of performance. If we apply descendantaxis elimination first, as shown in the example in figure <ref type="figure" target="#fig_10">9</ref>, each SP/Q is a suffix path expression and can be evaluated using Plabeling. This is because the input of push-up branch elimination is a subquery tree obtained from the descendant-axis elimination algorithm, which eliminates all descendant axis steps in the middle of query. Therefore SP is suffix path, Q is a simple path, and their concatenation is a suffix path. However, if we apply push-up branch elimination first, the same descendant axis may be pushed up by all subquery trees below it. Although all descendant edges will eventually be cut, the descendant elimination will be invoked over the same path fragment repeatedly. We therefore apply descendantelimination before push-up branch elimination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Unfold Algorithm</head><p>A further optimization of descendant-axis elimination is possible when schema information is available. For non-recursive schemas, path expressions with wildcards can be evaluated over the schema graph and wildcards can be substituted with actual tags. Thus a query of form p//q can be enumerated by all possibilities (p/r1/q, p/r2/q, . . ., p/r l /q), and the result of the query is the union of the results of p/r1/q, p/r2/q, . . ., p/r l /q. For a recursive schema, given statistics about the depth of the XML tree, queries can be unfolded to this depth and the occurrences of // can be eliminated. Since descendant axis traversals are substituted with child axis traversals, we call this optimization unfold descendant-axis elimination, and the resulting algorithm which splits a query Q into suffix path subqueries the Unfold algorithm.</p><p>One advantage with Unfold is that we replace D-joins with a process that first performs selections on P-labels and then unions the results. This is very efficient because selections using an index are cheap, and the union is very simple since there are no duplicates.  Another advantage is that the subqueries are all simple path queries, which can be implemented as a select operation with equality predicates instead of range predicates.</p><p>Furthermore, we also reduce the number of disk accesses. For example, to process query t1//t2, let the list of nodes tagged with t1 be l1, and the list of nodes tagged with t2 be l2, where the cardinality of l1 and l2 are n1 and n2, respectively. A D-join of l1 and l2 requires O(n1 + n2) node accesses. However, unfold t1//t2 produces queries t1/p1/t2, . . ., t1/ps/t2, where p1, . . ., ps are simple path expressions. The query can then be implemented as a select operation over l 2, resulting in at most n2 node accesses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 4.2:</head><p>For our sample query Q, first we apply push-up branch-elimination and get the following set of subqueries: Q 4, Q 5 ,Q 7 , Q 8 , Q 9 and Q 2 = /ProteinDatabase/ProteinEntry/protein//superfamily ="cytochrome c" , Q 3 = /ProteinDatabase/ProteinEntry/reference/refinfo// author="Evans, M.J.". Applying the unfold descendant-axis elimination to subqueries Q 2 and Q 3 , we get Q 2 = /ProteinDatabase/ProteinEntry/protein/classification/ superfamily="cytochrome c" , Q 3 = /ProteinDatabase/ProteinEntry/reference/refinfo/ authors/author="Evans, M.J.". Now all the subqueries of Q are simple path queries and can be evaluated by a select operation on their P-labels with equality predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Efficiency of the Algorithms</head><p>We claim that our algorithms are more efficient than an approach which only uses D-labeling because:</p><p>1. The number of joins are reduced. Recall that with D-labeling, a query which contains l tags requires (l -1) D-joins. However, if b is the number of outgoing edges, which are not annotated with "//", of a branching point and d is the number  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTAL RESULTS</head><p>To evaluate the effectiveness of BLAS , we compare its performance with the traditional D-labeling scheme. We test the performance on two alternative query engines: a relational database query engine, and a file system using the holistic twig join algorithm <ref type="bibr" target="#b8">[6]</ref> for joins. The experiments were performed over three XML data sets with different schema characteristics. The XPath queries used were chosen to represent suffix path queries, path queries with descendant axis traversal, and general tree queries. A benchmark query set was also used for the Auction data set. Experimental results show a substantial performance improvement of BLAS over the traditional D-labeling scheme for both query engines tested. Furthermore, they show that Unfold outperforms both Split and Push-up when XML schema information is available, and Push-up outperforms Split in the absence of such information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>The experiments were performed on a 1.5GHz Pentium 4 machine running Windows 2000, with 512MB memory and one 40GB hard disk (7200rpm). All experiments were repeated 10 times independently on a cold cache, and the average processing time was calculated disregarding the maximum and minimum values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Data Sets</head><p>The three data sets are Shakespeare <ref type="bibr" target="#b7">[5]</ref>, Protein <ref type="bibr" target="#b20">[18]</ref> and Auction <ref type="bibr" target="#b32">[30]</ref>, and are described below:  Auction: This data set contains information about auctions. It is a synthetic benchmark data set generated by the XML Generator from XMark. The data generated conforms to the default benchmark DTD provided. Its DTD is recursive, and the instance data is relatively deep (12 levels).</p><p>Characteristics of these data sets are summarized in figure <ref type="figure" target="#fig_12">12</ref>. Size denotes the disk space used to store the original XML file. Nodes is the number of nodes in the XML file, including element and attribute nodes. Tags is the number of distinct tags. Depth is the length of the longest simple path in the XML file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Queries</head><p>For each data set, we tested several types of XPath queries. The first is a suffix path query, in which a descendant axis appears only at the beginning (if it presents) and branches are not allowed. The second is a path query in which a descendant axis can appear anywhere in the query, but branches are not allowed. The third is a general tree query in which branches and descendant axes are both allowed to appear anywhere in the query.</p><p>We choose these types of queries for the following reasons. The first type of query tests the performance of P-labeling versus Dlabeling for long suffix path queries. The second type of query evaluates how to use the bi-labeling scheme of BLAS to optimize path query processing. The third type, twig queries, occur frequently in practice.</p><p>For the Auction dataset, we also tested a set of benchmark queries provided by XMark <ref type="bibr" target="#b32">[30]</ref> which only contains "/", "//" and branches.</p><p>The non-benchmark queries are listed in figure <ref type="figure" target="#fig_11">10</ref>. The names of the queries are encoded by "QXY", where 'X' is one of 'S'(Shakespeare), 'P'(Protein) or 'A'(Auction), and 'Y' is one of '1'(type 1, suffix path), '2' (type 2, path with no branching) or '3' (type 3, general tree query). We also use the original query names Q1,..., Q6 for the benchmark queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Relational Database Implementation</head><p>Although holistic twig joins have been shown to be much more efficient than relational database joins for implementing twig joins with no value predicates <ref type="bibr" target="#b8">[6]</ref>, relational databases are still heavily used for storing XML data. We therefore start by comparing the system with the Split, Push-up and Unfold query translators with the D-Labeling algorithm using a relational database query engine. πT 6.start((ρ(T 1, σ tag='P LAY S ∧level=1 (SD))  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Storage Setup</head><p>The XML data sets were stored in DB2 universal version 7.2 using the high-performance option installed in the same machine. We created two relations for each data set, one to implement our approach and the other to implement D-labeling. The schema of the relation for our approach is SP(plabel, start, end, level, data), with primary key {start}. Attribute {data} stores string (PCDATA) values. The relation is clustered by {plabel, start}. The schema of the relation SD implementing D-labeling is the same, except that the plabel attribute is replaced by a tag attribute. The relation is clustered by {tag, start}. Indexes are built for all the attributes involved in the queries to achieve the best possible performance for both approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Query Translation</head><p>First we compare the SQL queries generated for schemas SD and SP . The queries for QS3 are shown in figure <ref type="figure" target="#fig_0">11</ref>, where the big numbers are the plabels of the corresponding paths for Split, Pushup and Unfold. (We use relational algebra for the queries instead of SQL to conserve space). As we can see, D-labeling requires 5 D-joins, whereas Split, Push-up and Unfold only require 2 D-joins. Furthermore, Split requires two range selections and one equality selection, Push-up requires one range selection and two equality selections, and Unfold requires three equality selections. Since equality selection has better performance and generates a smaller intermediate result than range selection, Push-up has better performance than Split, and Unfold has the best performance, as shown in section 5.2.3. The other queries have similar results and are omitted here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Performance Analysis</head><p>Figure <ref type="figure" target="#fig_13">13</ref> shows the query processing time for queries on the Shakespeare, Protein and Auction data sets. Since the cost of output generation (XML tree reconstruction) is the same regardless of the algorithm applied, it is not contained in any of our measurements.</p><p>For each query, we compare the conventional approach using Dlabeling, the Split algorithm, the Push-up algorithm and the Unfold algorithm. The results of these experiments show that significant speed-up is achieved using our approach.</p><p>For the first type of query, suffix path queries, our approach is 100 times faster than the conventional approach using D-labeling. This is because D-labeling requires (l -1) D-joins with a lot of disk accesses to answer a suffix path query with l tags, while our approach uses a select operation with fewer disk accesses over the P-labels. Observe also that for suffix path queries, the Split, Pushup and Unfold algorithms are the same and therefore have the same performance.</p><p>For the second type of query, the conventional approach using Dlabeling again requires (l -1) D-joins. Split and Push-up are the same algorithms; both involve one D-join and two selections with fewer disk accesses, which is more efficient than D-labeling. On the other hand, Unfold translates the query into a select operation, and is therefore the fastest.</p><p>Similarly, for the third type of query the conventional approach using D-labeling requires (l -1) D-joins. The number of D-joins needed in Split and Push-up depends on the number of branches and descendant axis steps rather than the number of tags, and therefore require fewer D-joins and disk accesses. The size of intermediate results is also smaller. Hence Split and Push-up are both more efficient than the D-labeling approach. Since Push-up restricts each subquery to be as specific as possible, it further reduces disk accesses and the size of intermediate results, and performs better than Split. Unfold removes D-joins which are related to descendant axes, and therefore has fewer D-joins and disk accesses than either Split or Push-up. Overall, it has the best performance for the third type of query, and is 3-7 times faster than the D-labeling algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Holistic Twig Join Implementation</head><p>In the second experiment, we compared the Split, Push up and Unfold algorithms with the D-Labeling algorithm based on the holistic twig join technique of <ref type="bibr" target="#b8">[6]</ref>, using a file system as the storage engine. All queries ran significantly faster in this implementation than in the relational database implementation, concurring with the results of <ref type="bibr" target="#b8">[6]</ref>. These speed-ups are not presented since the purpose of our experiments is to show the benefit of BLAS over D-labeling in either implementation rather than to show the benefit of holistic twig joins.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Modifications to Query Set</head><p>Holistic twig join techniques focus on the core operations in XML query languages, that is, path and twig queries. They have not been developed to support other operations such as value predicates and unions. In this experiment, we therefore removed value predicates from the queries. Furthermore, since the Unfold algorithm uses unions, we only compared the Split and Push-up algorithms with the D-Labeling algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Queries of Different Types</head><p>We studied the efficiency of D-labeling, Split and Push-up across all three data sets: Auction (a recursive DTD), Shakespeare (a graph DTD) and Protein (a tree DTD). In all cases, we test queries on larger data sets by repeating the original data set 20 times to highlight the differences in running time. The result is shown in Figure14. Experiments show that for all test queries and data sets, our algorithms are more efficient than the traditional D-labeling algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Benchmark Queries</head><p>We also tested the benchmark queries using the Auction data with size 69.7M. As seen by the results in Figure <ref type="figure" target="#fig_0">15</ref>, Push-up has as good or better performance than Split, and Split has better performance than D-labeling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.4">Scalability</head><p>To test the scalability of the algorithms, we replicated the Auction data set between 10 and 60 times to get increasingly large experimental data sets.</p><p>Figure <ref type="figure" target="#fig_5">16</ref>(a) shows the execution time for suffix path query QA1 on different data set sizes. The Split and Push-up algorithms have the same performance since they share the same query plan on suffix path queries (recall the analysis of Section 5.2.2). Furthermore, the execution time for Split and Push-up is almost constant because they only use selection to get the result. On the other hand, Dlabeling needs to read all the data with a tag appearing in the query and do a join for each axis in the query. Notice that as the file size increases the difference between execution time of D-labeling and that of split and Push up algorithm increases. This proves that for suffix path queries, Split and Push up algorithm have better performance and scalability comparing to the D-labeling algorithm. The number of elements read by each approach is shown in the Figure <ref type="figure" target="#fig_5">16(b)</ref>.</p><p>Performance results for D-labeling, Split and Push-up on path query QA2 are shown in Figure <ref type="figure" target="#fig_0">17</ref>. Compared to suffix path queries, Split and Push-up need more time to answer path queries since joins and more disk accesses are necessary. However, they still outperform D-Labeling. One reason is that Split and Pushup use fewer joins (recall the analysis of Section 5.2.2), and another is that D-labeling accesses up to 4 times as many elements as Split and Push (see Figure <ref type="figure" target="#fig_0">17(b)</ref>). Figure <ref type="figure" target="#fig_0">17</ref>   between Split/Push-Up and D-labeling increases as the file grows larger, hence Split/Push-Up is more scalable than D-labeling.</p><p>Performance results for twig query QA3 are shown in Figure <ref type="figure" target="#fig_16">18</ref>, and again Split and Push-Up outperform D-labeling. An importance difference between this result and the result for the path queries, however, is that Push-up outperforms Split. The reason for this is the difference in query plans (see Section 5.2.2): Although Push-Up uses the same number of joins as Split, the select operations are more selective. Therefore the number of disk access is fewer (see Figure <ref type="figure" target="#fig_16">18(b</ref>)), and the execution time is smaller for Push-Up. Figure <ref type="figure" target="#fig_16">18</ref> also shows that the performance differences increase with the file size.</p><p>As shown in the experiments, BLAS outperforms the traditional approach which only uses D-labeling scheme on various data sets and queries for both query engines we have tested. The performance enhancement is achieved by reducing the number of joins and disk accesses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>XML storage and query processing. One approach is to store XML data natively as a file <ref type="bibr" target="#b30">[28]</ref>. However, since the whole file needs to be traversed whenever we process a query, it is not efficient for large XML data sets. There are many ideas of how to store XML using commercial RDBMS, leveraging its indexing and querying processing capabilities <ref type="bibr" target="#b19">[17,</ref><ref type="bibr" target="#b29">27,</ref><ref type="bibr" target="#b6">4,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b10">8,</ref><ref type="bibr" target="#b24">22]</ref>. <ref type="bibr" target="#b19">[17]</ref> treats an XML document as a graph, and generates a tuple for every edge. The main advantage is that the approach is simple and general, and the mapping between an XML query and SQL can be automatically generated. However, an XML query may involve many self-joins. <ref type="bibr" target="#b29">[27,</ref><ref type="bibr" target="#b6">4,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b10">8,</ref><ref type="bibr" target="#b24">22]</ref> eliminate joins between a node and its distinct child by inlining the distinct child information into the parent tuple. However, the mapping from an XML query to SQL is very complex, and needs schema information. In all above approaches, we typically need to rely on auxiliary code in a general-purpose programming language together with SQL to express an XML query.</p><p>Indexing. Various indexing techniques have been proposed for XML query processing and optimization. Structural indexes <ref type="bibr" target="#b26">[24,</ref><ref type="bibr" target="#b27">25,</ref><ref type="bibr" target="#b24">22,</ref><ref type="bibr" target="#b14">12,</ref><ref type="bibr" target="#b23">21]</ref> create a structural summary which is extracted from the XML document as a directed graph. Queries can then be evaluated over the structural summary by pruning the search space. <ref type="bibr" target="#b26">[24,</ref><ref type="bibr" target="#b24">22,</ref><ref type="bibr" target="#b14">12]</ref> only support path queries. <ref type="bibr" target="#b27">[25]</ref> supports tree queries which match some predefined template. <ref type="bibr" target="#b23">[21]</ref> discussed covering indexes for branching path queries and proposes to restrict the class of queries being indexed to achieve performance benefit. <ref type="bibr" target="#b16">[14]</ref> addresses the XML query optimization problem in the presence of materialized views.</p><p>Labeling. Several D-labeling implementations have been proposed <ref type="bibr" target="#b18">[16,</ref><ref type="bibr" target="#b25">23,</ref><ref type="bibr" target="#b3">1,</ref><ref type="bibr" target="#b5">3]</ref>. <ref type="bibr" target="#b3">[1,</ref><ref type="bibr" target="#b5">3]</ref> addresses the problem of how to build D-labels with the smallest label size. <ref type="bibr" target="#b25">[23,</ref><ref type="bibr" target="#b33">31,</ref><ref type="bibr" target="#b15">13]</ref> apply D-labeling for answering XML queries. Since D-labeling does not depend on the query workload or features of a document, a generic B + tree index can be built over D-labels to support tree queries. The most recent work, <ref type="bibr" target="#b15">[13]</ref>, shows the effectiveness of D-labeling for translating XQuery to SQL as compared with other XQuery processing techniques. XPRESS <ref type="bibr" target="#b28">[26]</ref> proposes an XML data compression technique which uses reverse arithmetic encoding to encode label paths as a distinct interval within [0.0,1). Furthermore, it supports query evaluation over the compressed document using the containment relationship among the intervals. Our P-labeling borrows the idea of labeling a path, but focuses on the optimization of query processing. We use integers rather than floating point numbers to enable efficient process. During P-label construction, the intervals are partitioned uniformly in order to compute the P-label of a query efficiently. Since the join operation is commonly used for query processing with D-labeling, <ref type="bibr" target="#b4">[2,</ref><ref type="bibr" target="#b8">6,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b12">10,</ref><ref type="bibr" target="#b21">19,</ref><ref type="bibr" target="#b31">29,</ref><ref type="bibr" target="#b22">20]</ref> study various join optimization techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>We present the BLAS system for processing complex XPath queries over XML data. The system is based on a labeling scheme which combines P-labeling (for processing suffix path queries efficiently) with D-labelings (for processing queries involving the descendant axis). Since we use 4 numbers in our labeling scheme to replace tag names, the space used to represent an XML document is comparable to the size of the original document. Three query translator algorithms were considered for BLAS : Split, Push-up and Unfold. In these algorithms, an XPath query is first decomposed into a set of suffix path sub-queries. P-labels of these sub-queries are then calculated, and the sub-queries translated into SQL expressions. The final SQL query plan is obtained by taking their D-join. BLAS provides a generic and efficient implementation by creating special indexes (B + tree and/or R tree) for optimizing D-joins.</p><p>Our experiments show that BLAS improves a large class of XML data sets and queries with comparable storage cost when compared to the D-labeling strategy, using both RDBMS and the holistic twig join technique of <ref type="bibr" target="#b8">[6]</ref>. Our experiments also show that the Push-up algorithm is the best query translator when there is no schema information, and that when such information is available Unfold should be used.</p><p>In future work, we plan to extend the techniques to handle more complex XPath queries.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Sample XML protein repository</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Sample XPath Query Q</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>3. Section 4 . 1 :Figure 3 :</head><label>413</label><figDesc>Figure 3: Query tree of Q</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 3 . 2 :</head><label>32</label><figDesc>A P-label for a suffix path P is an interval IP = &lt; p1, p2 &gt;, such that for any two suffix path expressions P , Q:Validation: P.p1 ≤ P.p2 Containment: P ⊆ Q if and only if interval I P is contained in IQ, i.e. Q.p1 ≤ P.p1 and Q.p2 ≥ P.p2. Nonintersection: P ∩ Q = ∅ if and only if IP and IQ do not overlap, i.e. P.p1 &gt; Q.p2 or P.p2 &lt; Q.p1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Illustration of interval partition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The architecture of BLAS system</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Algorithm 3 DFigure 7 :</head><label>37</label><figDesc>Figure 7: Descendant-axis elimination for Q</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 4 B 1 :</head><label>41</label><figDesc>-elimination(query tree Q) 1: List intermediate-result 2: Depth-first search(Q){ 3: if current node has more than one child then 4: for all child of Q: Q' .add(B-elimination(Q')) 8: end for 9: end if 10: } 11: result = answer(Q) 12: for all r in intermediate-result do 13: result = D-join(result,r) 14: end for 15: return result Algorithm 5 PushUp B-elimination(query tree Q) 1: return PushUp B-eliminate-sub(Q,'/'); function PushUp B-eliminate-sub(query tree Q, path expression P) List intermediate-result 2: Boolean Path = true 3: Depth-first search(Q){ 4: if current node has more than one child then 5: Path = false 6: for all child of Q: Q' do 7: cut Q' from Q 8: end for 9: SP = P/Q 10: for all child of Q: Q' do 11: intermediate-result.add( 12: PushUp B-eliminate-sub(Q',SP))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Push up branch elimination for Q1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Query Sets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: XML Data Sets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Query time for Shakespeare, Protein and Auction data sets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 14 :Figure 15 :</head><label>1415</label><figDesc>Figure 14: The performance of D-labeling, Split and Push up for the queries on different data sets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 16 :Figure 17 :</head><label>1617</label><figDesc>Figure 16: The performance of D-labeling, Split and Push up for the suffix path query QA2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 18 :</head><label>18</label><figDesc>Figure 18: The performance of D-labeling, Split and Push up for the tree query</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>to speed up descendant axis processing.</figDesc><table><row><cell>Definition 3.1: A D-label of an XML node is a triplet:</cell></row><row><cell>&lt; d 1, d2, d3 &gt;, such that for any two nodes n and m, n = m:</cell></row><row><cell>Validation: n.d1 ≤ n.d2.</cell></row><row><cell>Descendant: m is a descendant of n if and only if n.d1 &lt; m.d1</cell></row><row><cell>and n.d2 &gt; m.d2.</cell></row><row><cell>Child: m is a child of n if and only if m is a descendant of n and</cell></row><row><cell>n.d3 + 1 = m.d3.</cell></row><row><cell>Nonoverlap: n and m have no ancestor-descendant relationship</cell></row><row><cell>if and only if n.d2 &lt; m.d1 or n.d1 &gt; m.d2.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1 11: push(s, &lt; p 1 , p 2 &gt;)</figDesc><table /><note><p>12: label this node with p 1 13: end if 14: if current tag is &lt; /t i &gt; then 15: pop(s) 16: end if 17: }</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Figure 5: P-labels for some suffix path expressions</head><label></label><figDesc>× 10 10 , 5 × 10 10 -1 &gt; //protein/name &lt; 4.03 × 10 10 , 4.04 × 10 10 -1 &gt; //ProteinEntry/protein/name &lt; 4.0302 × 10 10 , 4.0303 × 10 10 -1 &gt; //ProteinDatabase/ProteinEntry/protein/name &lt; 4.030201 × 10 10 , 4.030202 × 10 10 -1 &gt; /ProteinDatabase/ProteinEntry/protein/name &lt; 4.030201 × 10 10 , 4.03020101 × 10 10 -1 &gt;</figDesc><table><row><cell cols="2">Path expression</cell><cell></cell><cell></cell><cell>P-label</cell></row><row><cell>//name XPath Query</cell><cell cols="2">Query translator Query decomposition</cell><cell cols="3">engine &lt; 4 Query SQL SQL Subquery Ancestor-descendant relationship between the results of the suffix path queries generator Suffix Path Suffix Path Query P-labelings P-labeling Subquery Query SQL Generator (based on P-labeling) … SQL composition D-labeling) Plan (based on SQL Query …</cell></row><row><cell>XML</cell><cell>SAX Parser</cell><cell>Events</cell><cell></cell><cell>Data values</cell><cell>Index</cell></row><row><cell></cell><cell>Index Generator</cell><cell></cell><cell>D-labeling generator</cell><cell>D-labelings</cell><cell>Query result</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>As an example, suppose we want to translate the query in figure</figDesc><table><row><cell>13: end for</cell></row><row><cell>14: end if</cell></row><row><cell>15: }</cell></row><row><cell>16: if Path then</cell></row><row><cell>17: SP = P/Q</cell></row><row><cell>18: end if</cell></row><row><cell>19: result = answer(SP)</cell></row><row><cell>20: for all r in intermediate-result do</cell></row><row><cell>21: result = D-join(result,r)</cell></row><row><cell>22: end for</cell></row><row><cell>23: return result</cell></row><row><cell>Example 4.1:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Rather than evaluate //qi and //r, we should therefore evaluate p/qi and p/r. Since p/qi and p/r are more specific than //qi and //r (recall that we cluster T-labels by {plabel,start }), the number of disk accesses and the size of the intermediate results is reduced without affecting the final result.</figDesc><table><row><cell>//</cell><cell>//</cell></row><row><cell>//</cell><cell>//</cell></row><row><cell>Figure 8: Branch elimination for Q1</cell><cell></cell></row><row><cell>leaf of p.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Relational algebra expressions generated for QS3 by D-labeling, Split, Push up and Unfold</head><label></label><figDesc>T 1.start&lt;T 2.start∧T 1.end&gt;T 2.end∧T 1.level=T 2.level-1 ρ(T 2, σ tag='P LAY (SD)) T 2.start&lt;T 3.start∧T 2.end&gt;T 3.end∧T 2.level=T 3.level-1 ρ(T 3, σ tag='ACT (SD)) D-labeling T 3.start&lt;T 4.start∧T 3.end&gt;T 4.end∧T 3.level=T 4.level-1 ρ(T 4, σ tag='SCENE (SD)) T 4.start&lt;T 5.start∧T 4.end&gt;T 5.end∧T 4.level=T 5.level-1 ρ(T 5, σ tag='T IT LE ∧data='SCENEIII.Apublicplace. (SD))) T 4.start&lt;T 6.start∧T 4.end&gt;T 6.end∧T 4.level=T 6.level-1 ρ(T 6, σ tag='LIN E (SD))) πT 3.start(ρ(T 1, σ plabel=345830491796013056 (SP ))</figDesc><table><row><cell></cell><cell></cell><cell cols="8">T 1.start&lt;T 2.start∧T 1.end&gt;T 2.end</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>QS3 Split</cell><cell></cell><cell cols="13">ρ(T 2, σ plabel=≥396316767208603648∧plabel≤432345564227567616 (SP ))</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="8">T 1.start&lt;T 3.start∧T 1.end&gt;T 3.end</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="12">ρ(T 3, σ plabel≥576460752303423488∧plabel≤612489549322387456 (SP )))</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="10">πT 3.start(ρ(T 1, σ plabel=345830491796013056 (SP ))</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Push up</cell><cell cols="18">T 1.start&lt;T 2.start∧T 1.end&gt;T 2.end∧T 1.level=T 2.level-1 ρ(T 2, σ plabel=407123970077229056 (SP ))</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="8">T 1.start&lt;T 3.start∧T 1.end&gt;T 3.end</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="12">ρ(T 3, σ plabel≥576460752303423488∧plabel≤612489549322387456 (SP )))</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="10">πT 3.start(ρ(T 1, σ plabel=345830491796013056 (SP ))</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Unfold</cell><cell cols="18">T 1.start&lt;T 2.start∧T 1.end&gt;T 2.end∧T 1.level=T 2.level-1 ρ(T 2, σ plabel=407123970077229056 (SP ))</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="14">T 1.start&lt;T 3.start∧T 1.end&gt;T 3.end ρ(T 3, σ plabel=579050277206753280 (SP )))</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="4">Figure 11: Shakespeare</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Protein</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Auction</cell><cell></cell><cell></cell></row><row><cell></cell><cell>5.00</cell><cell>30.03</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>25.00</cell><cell></cell><cell></cell><cell></cell><cell>21.74</cell><cell></cell><cell>3.00</cell><cell>4.66</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>4.00</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>20.00</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>2.50</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Time(s)</cell><cell>0.00 1.00 2.00 3.00</cell><cell>0.37 0.37 0.37</cell><cell>1.48</cell><cell>0.30 0.03 0.30</cell><cell>1.00 0.50</cell><cell>0.49 0.24</cell><cell>Time(s)</cell><cell>0.00 5.00 10.00 15.00</cell><cell>4.90 0.05</cell><cell>0.05 0.05</cell><cell>2.37 2.37 1.67 3.96</cell><cell>14.27 3.20 3.14</cell><cell>Time(s)</cell><cell>0.00 0.50 1.00 1.50 2.00</cell><cell>0.03 0.03</cell><cell>0.03</cell><cell>1.59</cell><cell>0.04 0.08 0.08</cell><cell>0.85 0.65</cell><cell>0.25 0.24</cell></row><row><cell></cell><cell></cell><cell>QS1</cell><cell></cell><cell>QS2</cell><cell cols="2">QS3</cell><cell></cell><cell></cell><cell cols="2">QP1</cell><cell>QP2</cell><cell>QP3</cell><cell></cell><cell></cell><cell>QA1</cell><cell></cell><cell></cell><cell>QA2</cell><cell cols="2">QA3</cell></row><row><cell></cell><cell></cell><cell cols="5">D-labeling Split Push Up Unfold</cell><cell></cell><cell></cell><cell></cell><cell cols="3">D-labeling Split Push Up Unfold</cell><cell></cell><cell></cell><cell cols="6">D-labeling Split Push Up Unfold</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>also shows that the difference</figDesc><table><row><cell></cell><cell></cell><cell cols="2">QA1</cell><cell></cell><cell></cell><cell></cell><cell cols="2">QA1</cell><cell></cell></row><row><cell></cell><cell>1.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>450</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Time(seconds)</cell><cell>0.2 0.4 0.6 0.8 1 1.2 1.4 1.6</cell><cell></cell><cell></cell><cell></cell><cell>Visited elements(K)</cell><cell>50 100 150 200 250 300 350 400</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>34.8M</cell><cell>69.7M</cell><cell>104.5M</cell><cell>139M</cell><cell>174M</cell><cell>34.8M</cell><cell>69.7M</cell><cell>104.5M</cell><cell>139M</cell><cell>174M</cell></row><row><cell></cell><cell></cell><cell cols="2">FileSize(Byte)</cell><cell></cell><cell></cell><cell></cell><cell cols="2">FileSize(Byte)</cell><cell></cell></row><row><cell></cell><cell></cell><cell>DLabeling</cell><cell>Split</cell><cell>PushUp</cell><cell></cell><cell></cell><cell>DLabeling</cell><cell>Split</cell><cell>PushUp</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The prototype implementation of holistic twig joins takes a tree pattern query as input. However, it is not hard to show that SQL input can be translated to a tree pattern query, so we can consider all input to the query engine to be SQL.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We would like to thank Val Tannen and Wang-Chiew Tan for their constructive and valuable comments. Furthermore, we thank Nicolas Bruno for sharing his efficient implementation of the holistic twig join algorithms. Research is partially supported by NSF DBI-9975206.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">TITLE =&apos;SCENE III. A public place</title>
		<idno>/PLAYS/PLAY/ACT/SCENE</idno>
		<ptr target="LINEQP1/ProteinDatabase/ProteinEntry/protein/name" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">QP3 /ProteinDatabase/ProteinEntry[reference/refinfo</title>
		<ptr target="QA1//category/description/parlist/listitemQA2/site/regions//item/descriptionQA3/site/regions/asia/item[shipping]/description" />
		<imprint/>
	</monogr>
	<note>citation and year</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Compact labeling schemes for ancestor queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SODA</title>
		<meeting>SODA</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Structural joins: A primitive for efficient XML query pattern matching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Al-Khalifa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Improved labeling scheme for ancestor queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Alstrup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rauhe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SODA</title>
		<meeting>SODA</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">From XML-Schema to Relations: A Cost-Based Approach to XML Storage</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simeon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Bosak</surname></persName>
		</author>
		<author>
			<persName><surname>Shakespeare</surname></persName>
		</author>
		<ptr target="http://www.ibiblio.org/xml/examples/shakespeare/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Holistic twig joins: Optimal XML pattern matching</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bruno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">RRXS: Redundancy reducing XML storage in relations</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Constraint Preserving XML Storage in Relations</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WebDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient complex query support for multiversion XML documents</title>
		<author>
			<persName><forename type="first">S.-Y</forename><surname>Chien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EDBT</title>
		<meeting>EDBT</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient Structural Joins on Indexed XML Documents</title>
		<author>
			<persName><forename type="first">S.-Y</forename><surname>Chien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Vagena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">XML Path language (XPath)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Derose</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/xpath" />
		<imprint>
			<date type="published" when="1999-11">November 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A fast index for semistructured data</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sample</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Hjaltason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shadmon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A comprehensive XQuery to SQL translation using dynamic interval encoding</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dehaan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Consens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Ozsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An Experimental Evaluation of the MARS System</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Excerpt from PhD Thesis Alin Deutsch</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Storing semistructured data with STORED</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Query Processing for Semistructured Data and Non-Standard Data Formats</title>
		<meeting>the Workshop on Query Processing for Semistructured Data and Non-Standard Data Formats</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="431" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Maintaining order in a linked list</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Dietz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of STOC</title>
		<meeting>eeding of STOC</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Storing and querying XML data using an RDBMS</title>
		<author>
			<persName><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Bulletin of the Technical Committee on Data Engineering</title>
		<imprint>
			<date type="published" when="1999-09">September 1999</date>
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<ptr target="http://www.cs.washington.edu/research/xmldatasets/" />
	</analytic>
	<monogr>
		<title level="j">Georgetown Protein Information Resource. Protein Sequence Database</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Accelerating Xpath location steps</title>
		<author>
			<persName><forename type="first">T</forename><surname>Grust</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">XR-Tree: Indexing XML Data for Efficient Structural Joins</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Covering indexes for branching path queries</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Exploiting local similarity for efficient indexing of paths in graph structured data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shenoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gudes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Indexing and querying XML data for regular path expressions</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The VLDB Journal</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="361" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Indexing semistructured data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mchugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rajaraman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Index structures for path expressions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDT</title>
		<meeting>ICDT</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">XPRESS: A queriable compression for XML data</title>
		<author>
			<persName><forename type="first">J.-K</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Chung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Relational databases for querying XML documents: Limitations and opportunities</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tufte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The VLDB Journal</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="302" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fernndez</surname></persName>
		</author>
		<author>
			<persName><surname>Galax</surname></persName>
		</author>
		<ptr target="http://db.bell-labs.com/galax" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">PBiTree Coding and Efficient Processing of Containment Joins</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<ptr target="http://monetdb.cwi.nl/xml/index.html" />
		<title level="m">XMARK the XML-benchmark project</title>
		<imprint>
			<date type="published" when="2001-04">April 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">On supporting containment queries in relational database management systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Lohman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Proceedings of SIGMOD</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
