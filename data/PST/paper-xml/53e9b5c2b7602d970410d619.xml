<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Two-Output Secure Computation with Malicious Adversaries</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Abhi</forename><surname>Shelat</surname></persName>
							<email>shelat@virginia.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Virginia</orgName>
								<address>
									<postCode>22904</postCode>
									<settlement>Charlottesville</settlement>
									<region>VA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Chih-Hao</forename><surname>Shen</surname></persName>
							<email>shench@virginia.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Virginia</orgName>
								<address>
									<postCode>22904</postCode>
									<settlement>Charlottesville</settlement>
									<region>VA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Two-Output Secure Computation with Malicious Adversaries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C77A880BD8FF721046437C8CE7BA19A7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Witness indistiguishability</term>
					<term>Yao garbled circuits</term>
					<term>signature schemes</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a method to compile Yao's two-player garbled circuit protocol into one that is secure against malicious adversaries that relies on witness indistinguishability. Our approach can enjoy lower communication and computation overhead than methods based on cut-andchoose <ref type="bibr" target="#b14">[13]</ref> and lower overhead than methods based on zero-knowledge proofs [8] (or Σ-protocols [14]). To do so, we develop and analyze new solutions to issues arising with this transformation:</p><p>-How to guarantee the generator's input consistency -How to support different outputs for each player without adding extra gates to the circuit of the function f being computed -How the evaluator can retrieve input keys but avoid selective failure attacks -Challenging 3/5 of the circuits is near optimal for cut-and-choose (and better than challenging 1/2)</p><p>Our protocols require the existence of secure-OT and claw-free functions that have a weak malleability property. We discuss an experimental implementation of our protocol to validate our efficiency claims.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Yao <ref type="bibr" target="#b25">[23]</ref> proposed a method that allows two honest-but-curious players-a generator (denoted by P 1 ) with secret input x, and an evaluator (denoted by P 2 ) with secret input y-to jointly compute a function f (x, y) such that P 1 receives nothing and P 2 receives f (x, y) 1 . In this paper, we propose an approach for transforming Yao's garbled circuit protocol for honest-but-curious players into a protocol that is secure against malicious players. Our main goal is to improve the efficiency of this transformation and to do so using more general assumptions.</p><p>There are two well-known methods to achieve this transformation: the commitand-prove and cut-and-choose. The commit-and-prove method suggested by Goldreich, Micali, and Widgerson <ref type="bibr" target="#b4">[6]</ref> only requires the weak general assumption of zero-knowledge proofs of knowledge. However, this approach requires costly NPreductions, which have never been implemented. On the other hand, an efficient transformation based on the cut-and-choose method was recently proposed by Lindell and Pinkas <ref type="bibr" target="#b14">[13]</ref> and implemented by Pinkas et al. <ref type="bibr" target="#b21">[20]</ref>. The general idea in cut-and-choose is for P 1 to prepare multiple copies of the circuit to be evaluated. A randomly selected set of the circuits (called check-circuits) are then opened to show if they were constructed correctly. Finally, the unopened circuits (called evaluation-circuits) are evaluated by P 2 and the majority of the results is taken as the final output. This approach has only constant round complexity, but the replication incurs both communicational and computational overhead.</p><p>The starting point for our work is the cut-and-choose method. A natural question we aim to study is to understand the fundamental limitations (in terms of efficiency) of the cut-and-choose method. This method does not require NPreductions; however, it faces other efficiency problems stemming from the new security problems introduced by evaluating e out of s copies of the circuit. In this paper, we address several of these issues: (1) ensuring input consistency, (2) handling two-output functions, (3) preventing selective failure attacks, and (4) determining the optimal number of circuits to open versus evaluate. Moreover, we identify weak and generic properties that admit efficient solutions to these issues. In several of the cases, using witness indistinguishable protocols suffice. Thus, in the case of input consistency, we are able to use an extremely efficient protocol as long as claw-free functions with a minimal malleability property exist (they do under the standard algebraic assumptions). We will later demonstrate the benefits of our approach by both asymptotic analysis of complexity and experimental results from an implementation. We now give an overview of our contributions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Generator's Input Consistency</head><p>According to the cut-and-choose method, P 1 needs to send e copies of her garbled input to P 2 . Since the circuits are garbled, P 1 could cheat by sending different inputs for the e copies of the garbled circuit. For certain functions, there are simple ways for P 1 to extract information about P 2 's input ( § 3 of <ref type="bibr" target="#b14">[13]</ref>). Therefore, the protocol must ensure that all e copies of P 1 's input are consistent. Related work. Let n be P 1 's and P 2 's input size, and let s be a statistical security parameter for the cut-and-choose method. Mohassel and Franklin <ref type="bibr" target="#b17">[16]</ref> proposed the equality-checker scheme, which has O(ns 2 ) computation and communication complexity. Woodruff <ref type="bibr" target="#b24">[22]</ref> later suggested an expander-graph framework to give a sharper bound to P 1 's cheating probability. The asymptotic complexity is O(ns), however, in practice, the constant needed to construct the expander graphs is prohibitively large. Lindell and Pinkas <ref type="bibr" target="#b14">[13]</ref> develop an elegant cut-and-choose based construction that enjoys the simulation-based security against malicious players. This approach requires O(ns 2 ) commitments to be computed and exchanged between the participants. Although these commitments can be implemented using lightweight primitives such as collision-resistant hash functions, communication complexity is still an issue. Jarecki and Shmatikov <ref type="bibr" target="#b6">[8]</ref> presented an approach that is based on commit-and-prove method. Although only a single circuit is constructed, their protocol requires hundreds of heavy cryptographic operations per gate, whereas approaches based on the cut-and-choose method require only such expensive operations for the input gates. Nielsen and Orlandi <ref type="bibr" target="#b19">[18]</ref> proposed an approach with Lego-like garbled gates. Although it is also based on the cut-and-choose method, via an alignment technique only a single copy of P 1 's input keys is needed for all the e copies of the garbled circuit. However, similar to Jarecki and Shmatikov's approach, each gate needs several group elements as commitments resulting both computational and communicational overhead. Lindell and Pinkas propose a Diffie-Hellman pseudorandom synthesizer technique in <ref type="bibr" target="#b15">[14]</ref>; their approach relies on finding efficient zero-knowledge proofs for specifically chosen complexity assumptions, which is of complexity O(ns).</p><p>Our approach to consistency. We solve this problem not by explicitly using zeroknowledge protocols (or Σ-protocols) but by communicating merely O(ns) group elements. Our novel approach is to first observe that witness indistinguishable proofs suffice for consistency, and to then use claw-free functions 2 that have a weak malleability property to generate efficient instantiations of such proofs.</p><p>Intuitively, P 1 's input is encoded using elements from the domain of the clawfree collections which can later be used to prove their consistency among circuits. The elements are hashed into random bit-strings which P 1 uses to construct keys for garbled input gates. The rest of the gates in the circuit use fast symmetric operations as per prior work. A concrete example is to instantiate the claw-free functions under the Discrete Logarithm assumption by letting f b (m) = g b h m for some primes p and q such that p = 2q + 1, and distinct group elements g and h of Z * p such that g = h = q. It is well-known that such a pair of functions have efficient zero-knowledge proofs. An example instantiation of our solution built on this pair of claw-free functions works as follows: P 1 samples [m 0,1 , . . . , m 0,s ] and [m 1,1 , . . . , m 1,s ] from f 0 and f 1 's domain Z q . The range elements [h m0,1 , . . . , h m0,s ] and [gh m1,1 , . . . , gh m1,s ] are then used to construct garbled circuits in the way that g b h m b,j is associated with P 1 's input bit value b in the j-th garbled circuit. The cut-and-choose method verifies that the majority of the evaluation-circuits are correctly constructed. Let [j 1 , . . . , j e ] be the indices of these evaluation-circuits. At the onset of the evaluation phase, P 1 with input bit x reveals [g x h mx,j 1 , . . . , g x h mx,j e ] to P 2 and then proves that these range elements are the commitments of the same bit x. Intuitively, by the identical range distribution property, P 2 with f x (m x,i ) at hand has no information about x. Furthermore, after P 1 proves the knowledge of the pre-image of [f x (m x,j1 ), . . . , f x (m x,je )] under the same f x , by the claw-free property, P 1 proves the consistency of his input keys for all the evaluation-circuits.</p><p>Furthermore, in the course of developing our proof, we noticed that witness indistinguishable proofs suffice in place of zero-knowledge proofs. Even more 2 Loosely speaking, a pair of functions (f0, f1) are said to be claw-free if they are</p><p>(1) easy to evaluate, (2) identically distributed over the same range, and (3) hard to find a claw. A claw is a pair of elements, one from f0's domain and the other from f1's domain, that are mapped to the same range element.</p><p>generally, when the claw-free collection has a very weak malleability property (which holds for all known concrete instantiations), sending a simple function of the witness itself suffices. We will get into more details in §2.1.</p><p>It is noteworthy that both the committed-input scheme in <ref type="bibr" target="#b17">[16]</ref> and Diffie-Hellman pseudorandom synthesizer technique in <ref type="bibr" target="#b15">[14]</ref> are special cases of our approach, and thus, have similar complexity. However, the committed-input scheme is not known to enjoy simulation-based security, and the pseudorandom synthesizer technique requires zero-knowledge proofs that are unnecessary in our case, which means that our approach is faster by a constant factor in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Two-Output Functions</head><p>It is not uncommon that both P 1 and P 2 need to receive outputs from a secure computation, that is, the goal function is f (x, y) = (f 1 , f 2 ) such that P 1 with input x gets output f 1 , and P 2 with input y gets f 2 <ref type="foot" target="#foot_0">3</ref> . In this case, the security requires that both the input and output are hidden from the other player. When both players are honest-but-curious, a straightforward solution is to let P 1 choose a random number c as an extra input, convert f (x, y) = (f 1 , f 2 ) into a new function f * ((x, c), y) = (λ, (f 1 ⊕ c, f 2 )), run the original Yao protocol for f * , and instruct P 2 to pass the encrypted output f 1 ⊕ c back to P 1 , who can then retrieve her real output f 1 with the secret input c chosen in the first place. However, the situation gets complicated when either of the players could potentially be malicious. Note that the two-output protocols we consider are not fair since P 2 may always learn its own output and refuse to send P 1 's output. However, they can satisfy the notion that if P 1 accepts output, it will be correctly computed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work.</head><p>One straightforward solution is for the players to run the singleoutput protocol twice with roles reversed. Care must be taken to ensure that the same inputs are used in both executions. Also, this approach doubles the computation and communication cost. Other simple methods to handle twooutput functions also have subtle problems. Suppose, for example, P 1 encrypts all copies of her output and has P 2 send these s random strings (or encryptions) in the last message. In a cut-and-choose framework, however, a cheating P 1 can use these random strings to send back information about the internal state of the computation and thereby violate P 2 's privacy. As an example, the cheating P 1 can make one bad circuit in which P 1 's output bit is equal to P 2 's first input bit. If P 2 sends all copies of P 1 's output bit back to P 1 , then with noticeable probability, the cheating P 1 can learn P 2 's first input bit. The problem remains if instead of sending back all bits, only a randomly chosen output bit is sent. Besides, P 1 should not be convinced by a cheating P 2 with an arbitrary output.</p><p>As described in <ref type="bibr" target="#b14">[13]</ref>, the two-output case can be reduced to the single-output case as follows: (1) P 1 randomly samples a, b, c ∈ {0, 1} n as extra input; (2) the original function is converted into f * ((x, a, b, c), y) = (λ, (α, β, f 2 )) where α = f 1 ⊕ c is an encryption of f 1 and β = a • α + b is the Message Authentication code (MAC) of α, and (3) P 2 sends (α, β) back to P 1 , who can then check the authenticity of the output α = f 1 ⊕ c. However, this transformation increases the size of P 1 's input from n bits to 4n bits. As a result, the complexity of P 1 's input consistency check is also increased. A second drawback is that the circuit must also be modified to include extra gates for computing the encryption and MAC function. Although a recent technique <ref type="bibr" target="#b12">[12]</ref> can be used to implement XOR gates "for free," the MAC function a • α + b still requires approximately O(n 2 ) extra gates added to the circuit. Since all s copies of the circuit have to be modified, this results in additional communication of O(sn 2 ) encrypted gates. Indeed, for simple functions, the size of this overhead exceeds the size of the original circuit.</p><p>Kiraz and Schoenmakers <ref type="bibr" target="#b10">[11]</ref> present a fair two-party computation protocol in which a similar issue for two-output functions arises. In their approach, P 2 commits to P 1 's garbled output. Then P 1 reveals the two output keys for each of her output wires, and P 2 finds one circuit GC r which agrees with "the majority output for P 1 ." The index r is then revealed to P 1 . However, informing P 1 the index of the majority circuit could possibly leak information about P 2 's input. As an anonymous reviewer has brought to our attention an unpublished follow-up work from Kiraz <ref type="bibr" target="#b8">[9]</ref>, which elaborated this issue (in § 6.6 of <ref type="bibr" target="#b8">[9]</ref>) and further fixed the problem without affecting the overall performance. Particularly, in the new solution, the dominant computational overhead is an OR-proof of size O(s), and the dominant communicational overhead is the commitments to P 1 output keys, where the number of such commmitments is of order O(ns). Their techniques favorably compare to our approach, but we do not have experimental data to make accurate comparisons with our implementation.</p><p>Our approach to two-output functions. We present a method to evaluate twooutput function f without adding non-XOR gates to the original circuit for f .</p><p>In order for P 2 to choose one output that agrees with the majority, similar to Kiraz and Schoenmakers' approach in <ref type="bibr" target="#b10">[11]</ref>, we add extra bits to P 1 's input as a one-time pad encryption key by changing the function from</p><formula xml:id="formula_0">f (x, y) = (f 1 , f 2 ) to f * ((c, x), y) = (λ, (f 1 ⊕ c, f 2 )), where x, c, y, f 1 , f 2 ∈ {0, 1} n .</formula><p>With this extra random input c from P 1 , P 2 is able to do the majority function on the evaluation output f 1 ⊕ c without knowing P 1 's real output f 1 . Next, P 2 needs to prove the authenticity of the evaluation output f 1 ⊕ c that she has given to P 1 . Here, our idea is that P 1 's i-th output gate in the j-th garbled circuit is modified to output 0||σ sk (0, i, j) or 1||σ sk (1, i, j) instead of 0 or 1, where σ sk (b, i, j) is a signature of the message (b, i, j) signed by P 1 under the signing key sk. In other words, the garbled gate outputs P 1 's output bit b and a signature of b, bit index i, and circuit index j. Therefore, after the circuit evaluation, P 2 hands f 1 ⊕ c to P 1 and proves the knowledge of the signature of each bit under the condition that the j-index for all signatures are the same and valid (among the indices of the evaluation-circuits). Naively, this proof would have been a proof of O(ns) group elements. However, we will show that a witness indistinguishable proof suffices, which reduces the complexity by a constant factor. Furthermore, by using the technique of Camenisch, Chaabouni, and Shelat for efficient set membership proof <ref type="bibr" target="#b2">[4]</ref>, we are able to reduce the complexity to O(n + s) group elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">The Problem of Selective Failure</head><p>Another problem with compiling garbled circuits occurs during the Oblivious Transfer (OT) phase, when P 2 retrieves input keys for the garbled circuits. A malicious P 1 can attack the protocol with selective failure, where the keys used to construct the garbled circuit might not be the ones used in the OT so that P 2 's input can be inferred according to her reaction after OT. For example, a cheating P 1 could use (K 0 , K 1 ) to construct a garbled circuit but use (K 0 , K * 1 ) instead in the corresponding OT, where K 1 = K * 1 . As a result, if P 2 's input bit is 1, she will get K * 1 after OT and cannot evaluate the garbled circuit properly. In contrast, if her input bit is 0, P 2 will get K 0 from OT and complete the evaluation without complaints. P 1 can therefore infer P 2 's input. This issue is identified by both Mohassel and Franklin <ref type="bibr" target="#b17">[16]</ref> and Kiraz and Schoenmakers <ref type="bibr" target="#b9">[10]</ref>.</p><p>Related work. Lindell and Pinkas <ref type="bibr" target="#b14">[13]</ref> replace each of P 2 's input bits with s additional input bits. These s new bits are XOR'ed together, and the result is used as the input to the original circuit. Such an approach makes the probability that P 2 must abort due to selective failure independent of her input. This approach, however, increases the number of input bits for P 2 from n to ns. Woodruff later pointed out that the use of clever coding system can reduce the overhead to max(4n, 8s). To be sure, Lindell, Pinkas, and Smart <ref type="bibr" target="#b16">[15]</ref> implement the method described in <ref type="bibr" target="#b14">[13]</ref> and empirically confirm the extra overhead from this step. In particular, a 16-bit comparison circuit that originally needs fifteen 3-to-1 gates and one 2-to-1 gate will be inflated to a circuit of several thousand gates after increasing the number of inputs. Since the number of inputs determines the number of OT operations, an approach that keeps the number of extra inputs small is preferable. In fact, we show that increasing the number of inputs and number of gates in the circuit for this problem is unnecessary.</p><p>Independent of our work, Lindell and Pinkas <ref type="bibr" target="#b15">[14]</ref> propose to solve this problem by cut-and-choose OT. This new solution indeed provides a great improvement over <ref type="bibr" target="#b14">[13]</ref> and shares roughly the same complexity with our solution. Furthermore, both the cut-and-choose OT and our solution can be built upon the efficient OT proposed by Naor and Pinkas <ref type="bibr" target="#b18">[17]</ref> or Peikert, Vaikuntanathan, and Waters <ref type="bibr" target="#b20">[19]</ref>. However, the particular use the latter OT in <ref type="bibr" target="#b15">[14]</ref> needs two independently chosen common reference strings, while our solution needs only one.</p><p>Our approach to selective failure. Inspired by the idea of committing Oblivious Transfer proposed by Kiraz and Schoenmakers <ref type="bibr" target="#b9">[10]</ref>, we solve the problem of selective failure by having the sender (P 1 in Yao protocol) of the OT post-facto prove that she ran the OT correctly by revealing the randomness used in the OT. Normally, this would break the sender-security of the OT. However, in a cutand-choose framework, the sender is already opening many circuits, so the keys used as inputs for the OT are no longer secret. Thus, the idea is that the sender can prove that he executed the OT correctly for all circuits that are opened by simply sending the random coins used in the OT protocol for those instances. We stress that not every OT can be used here. Intuitively, a committing OT is the OT with the binding property so that it is hard for a cheating sender to produce random coins different from what she really used.</p><p>A critical point with this approach is that in order to simulate a malicious P 2 , we need to use a coin-flipping protocol to pick which circuits to open. Consequently, P 1 cannot open the circuits to P 2 until the coin-flipping is over; yet the OT must be done before the coin-flipping in order to guarantee a proper cut. So the order of operations of the protocol is critical to security. An efficient committing OT based on Decisional Diffie-Hellman problem is presented in §2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Optimal Cut-and-Choose Strategy</head><p>We find that most cut-and-choose protocols open s/2 out of the s copies of the garbled circuit to reduce the probability that P 1 succeeds in cheating. We show that opening 3s/5-out-of-s is a better choice than s/2-out-of-s. In particular, when s circuits are used, our strategy results in security level 2 -0.32s in contrast to 2 -s/17 from [13] and 2 -0.31s from <ref type="bibr" target="#b15">[14]</ref>. Although the difference with the latter work is only 1% less, we show the optimal parameters for the cut-and-choose method in Appendix A, thereby establishing a close characterization of the limits of the cut-and-choose method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Comparison of Communication Complexity</head><p>We attempt to compare communication efficiency between protocols that use a mix of light cryptographic primitives (such as commitments instantiated with collision-resistant hash functions) and heavy ones (such as group operations that rely on algebraic assumptions like discrete logarithm). To meaningfully do so, we consider asymptotic security under reasonable assumptions about the growth of various primitives with respect to the security parameter k. We assume that:</p><p>1. light cryptographic primitives have size Θ(k); 2. heavy cryptographic operations that can be instantiated with elliptic curves or bilinear groups take size õ(k 2 ). 3. heavy cryptographic operations that require RSA or prime order groups over Z take size õ(k 3 ).</p><p>The size assumption we make is quite conservative. It is based on the observation that in certain elliptic curve groups, known methods for computing discrete logarithms of size n run in time L n (1, 1/2). Thus, to achieve security of 2 k , it suffices to use operands of size õ(k 2 ) by which we mean a value that is asymptotically smaller than k 2 by factors of log(k). The computation bound follows from the running time analysis of point multiplication (or exponentiation in the case of Z * p ) algorithms. As we discuss below, for reasonable security parameters, however, the hidden constants in this notation make the difference much smaller. Let k be a security parameter for cryptographic operations, let s be a statistical security parameter, and let |C| be the number of gates in the base circuit computing f :</p><formula xml:id="formula_1">{0, 1} n × {0, 1} n → {0, 1} n × {0, 1} n .</formula><p>-Jarecki and Shmatikov <ref type="bibr" target="#b6">[8]</ref>: For each gate, the number of the communicated group elements is at least 100, including the commitments of the garbled values for input wires, the commitments of the doubly-encrypted entries, and the ZK proof for the correctness of the gate. Moreover, for each input or output wires, a ZK proof for conjunction/disjunction is required. Each of the ZK proofs needs constant number of group elements. Finally, this protocol assumes the decisional composite residuosity problem in an RSA group; thus, each group element is of size õ(k 3 ). - <ref type="bibr">Kiraz [9]</ref>: This approach uses an equality-checker framework that requires O(ns 2 ) commitments for checking P 1 's input consistency. They solve the selective failure attack with committing OT as we do. Moreover, to deal with two-output functions, they add n extra bits to P 1 's input, commit to all of P 1 's output keys, which include 2ns commitments and 2ns decommitments, and a zero-knowledge OR-proof of size O(s). -Lindell and Pinkas <ref type="bibr" target="#b14">[13]</ref>: Each of the garbled gates requires 4k space for four doubly-encrypted entries. Thus, for this approach, the communication analysis is as follows: (1) s copies of the base circuit itself require s|C| gates;</p><p>(2) each of P 1 's n input bits requires s 2 light commitments for the consistency check;</p><p>(3) P 2 's n input bits require max(4n, 8s) OT's. Also, the MAC-based two-output function computation add additional O(n 2 ) gates to each of the s copies of the circuit and additional 3n bits to P 1 's input. Thus, the overall communication cost to handle two-output function is O(n 2 sk + ns 2 k). </p><formula xml:id="formula_2">|C| • õ(k 3 ) n • õ(k 3 ) n OT's n • õ(k 3 ) K [9] Θ(|C| • sk) Θ(ns 2 k) n OT's Θ(nsk) + Θ(s) • õ(k 2 ) LP07 [13] Θ(|C| • sk) Θ(ns 2 k) m a x ( 4 n, 8s) OT's Θ(n 2 sk + ns 2 k) LP10 [14] Θ(|C| • sk) Θ(ns) • õ(k 2 ) n OT's Θ(n 2 sk + ns 2 k) Our work Θ(|C| • sk) Θ(ns) • õ(k 2 ) n OT's Θ(ns) • õ(k 2 )</formula><p>The recent work of <ref type="bibr" target="#b15">[14]</ref> also considers a more efficient way to implement twoparty computation based on cut-and-choose OT and specific security assumptions. They report 13sn exponentiations and communication of 5sn + 14k + 7n group elements. (Note we count bits above to compare commitments versus other primitives.) Concretely, these parameters are similar to our parameters but rely on more specific assumptions, and do not consider two-party outputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Building Blocks</head><p>For clarity purpose, the standard checks that are required for security have been omitted. For example, in many cases, it is necessary to verify that an element that has been sent is indeed a member of the right group. In some cases, it is implicit that if a player detectably cheats in a sub-protocol, then the other player would immediately abort execution of the entire protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Consistency Check for the Generator's Input</head><p>The cut-and-choose approach to compiling Yao circuits ensures that P 1 submits consistent input values for each copy of the evaluation-circuits. Recall that there are e copies of the circuit which must be evaluated. Thus, for each input wire, P 1 must send e keys corresponding to an input bit 0 or 1. It has been welldocumented <ref type="bibr" target="#b17">[16,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b24">22,</ref><ref type="bibr" target="#b14">13]</ref> that in some circumstances, P 1 can gain information about P 2 's input if P 1 is able to submit different input values for the e copies of this input wire. The main idea of our solution is inspired by the claw-free collections <ref type="foot" target="#foot_1">4</ref> defined as follows:</p><p>Definition , where I = (g, h, p, q) includes two primes p and q such that p = 2q + 1, and distinct generators g and h of Z * p such that g = h = q. After revealing [g b h m b,j 1 , . . . , g b h m b,je ] to P 2 , it is a natural solution that P 1 proves in zero-knowledge to P 2 the knowledge of (m b,jim b,j1 ) given common input g b h m b,j i (g b h m b,j 1 ) -1 = h m b,j i -m b,j 1 , for 2 ≤ i ≤ e.</p><p>The key insight here is that it is unnecessary for P 1 to hide (m b,jim b,j1 ) from P 2 since [m b,j1 , . . . , m b,je ] are new random variables introduced by P 1 and b is the only secret needed to be hidden from P 2 . Simply sending (m b,ji -m b,j1 ) to P 2 will suffice a proof of checking P 1 's input consistency without compromising P 1 's privacy. In other words, given [g b h m b,j 1 , . . . , g b h m b,je , m 2 , . . . , m e ], if P 2 confirms that g b h m b,j 1 = g b h m b,j i • h m i for 2 ≤ i ≤ e, then either P 1 's input is consistent so that m i = m b,jim b,j1 , or P 1 is able to come up with a claw.</p><p>Note that extra work is only done for the input gates-and moreover, only those of P 1 . All of the remaining gates in the circuit are generated as usual, that is, they do not incur extra commitments. So, unlike solutions with committed OT such as <ref type="bibr" target="#b6">[8]</ref>, asymmetric cryptography is only used for the input gates rather than the entire circuit. To generalize the idea, we introduce the following notion. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Malleable Claw-Free Collections). A four-tuple of algorithms (G, D, F, R) is a malleable claw-free collection if the following conditions hold. 1. A subset of claw-free collections</head><formula xml:id="formula_3">m 1 , m 2 ∈ G 1 , f b I (m 1 m 2 ) = f b I (m 1 ) R I (m 2</formula><p>). Consider the claw-free collection constructed above under the Discrete Logarithm assumption, we know that it can become a malleable claw-free collection simply by letting G 1 = Z q , G 2 = Z * p , and R I (m) = h m for any m ∈ G 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Two-Output Functions</head><p>To handle two-output functions, we want to satisfy the notion that it might be unfair in the sense that P 2 could abort prematurely after circuit evaluation and she gets her output. However, if P 1 accepts the output given from P 2 , our approach guarantees that this output is genuine. Namely, P 2 cannot provide an arbitrary value to be P 1 's output. In particular, P 2 cannot learn P 1 's output more than those deduced from P 2 's own input and output.</p><p>Recall that it is a well-accepted solution to convert the garbled circuit computing f (x, y) = (f 1 , f 2 ) into the one computing g((x, p, a, b), y) = ((α, β), f 2 ), where α = f 1 + p as a ciphertext of f 1 and β = a • α + b as a MAC for the ciphertext. Since P 2 only gets the ciphertext of P 1 's output, she does not learn anything from the ciphertext. Also, given (α, β), P 1 can easily verify the authenticity of her output. However, we are not satisfied with the additional O(s 2 ) gates computing the MAC (s is the statistical security parameter) to each of the s copies of the garbled circuit, which results in O(s 3 ) extra garbled gates in total. Indeed, the number of extra gates can easily exceed the size of the original circuit when f is a simple function. Hence, we propose another approach to authenticate P 1 's output without the extra gates computing the MAC function.</p><p>While our approach also converts the circuit to output the ciphertext of P 1 's output, that is, from f (x, y) = (f 1 , f 2 ) to f * ((c, x), y) = (λ, (f 1 ⊕ c, f 2 )), we solve the authentication problem by the use of the public-key signature scheme and its corresponding witness-indistinguishable proof. Each bit value of the output of P 1 's output gates is tied together with a signature specifying the value and the location of the bit. On one hand, P 2 can easily verify the signature during the cut-and-choose phase (to confirm that the circuits are correctly constructed). On the other hand, after the evaluation and giving P 1 the evaluation result (f 1 ⊕ c), P 2 can show the authenticity of each bit of the result by proving the knowledge of its signature, that is, the signature of the given bit value from the right bit location. Note that a bit location includes a bit index and a circuit index. In other words, a bit location (i, j) indicates P 1 's i-th output bit from the j-th garbled circuit. While the bit index is free to reveal (since P 1 and P 2 have to conduct the proof bit by bit anyway), the circuit index needs to be hidden from P 1 ; otherwise, P 1 can gain information about P 2 's input as we discussed above. We stress that it is critical for P 2 to provide a signature from the right location. Since during the cut-and-choose phase, many properly signed signatures are revealed from the check-circuits, if those signatures do not contain location information, they can be used to convince P 1 to accept arbitrary output.</p><p>Normally, an OR-proof will suffice the proof that the signature is from one of the evaluation-circuits. Nevertheless, an OR proof of size O(s) for each bit of P 1 's n-bit output will result in a zero-knowledge proof of size O(ns). We therefore adopt the technique from <ref type="bibr" target="#b2">[4]</ref> in order to reduce the size of the proof to O(n + s). Let S = {j 1 , . . . , j e } be the indices of all the evaluation-circuits. The idea is for P 1 to send a signature of every element in S, denoted by [δ(j 1 ), . . . , δ(j e )]. By reusing these signatures, P 2 is able to perform each OR proof in constant communication. More specifically, after the evaluation, P 2 chooses one evaluation-circuit, say the j l -th circuit, the result of which conforms with the majority of all the evaluationcircuits. Let M = [m 1 , . . . , m n ] be P 1 's output from the j l -th circuit. Recall that P 2 has both m i and the signature to (m i , i, j l ), denoted by σ(m i , i, j), due to the way the garbled circuits were constructed. To prove the authenticity of m i , P 2 sends m i to P 1 , blinds signature δ(j l ) and σ(m i , i, j l ), and proves the knowledge of "σ(m i , i, j) for some j ∈ S." In other words, P 2 needs to prove the knowledge of σ(m i , i, j) and δ(j * ) such that j = j * for i = 1, . . . , n. The complete proof is shown in Protocol 1. Due to the nonforgeability property of signature schemes, P 2 proves the knowledge of the signature and thus the authenticity of M.</p><p>One particular implementation of our protocol can use the Boneh-Boyen short signature scheme <ref type="bibr" target="#b0">[2]</ref> which is briefly summarized here. The Boneh-Boyen signature scheme requires the q-SDH (Strong Diffie-Hellman) assumption 5 and bilinear maps 6 . Based on these two objects, the Boneh-Boyen signature scheme includes a three-tuple of efficient algorithms (G, S, V ) such that 5 q-SDF assumption in a group G of prime order p states that given g, g x , g x 2 , . . . , g x q , it is infeasible to output a pair (c, g 1/(x+c) ) where c ∈ Z * p . 6 Let G1 and G2 be two groups of prime order p. A bilinear map is a map e : G1 ×G1 → G2 with the following properties: (1) for any u, v ∈ G1 and a, b ∈ Z, e(u a , v b ) = e(u, v) ab ; (2) for any generator g of G1, e(g, g) = 1; and (3) for any u, v ∈ G1, it is easy to compute e(u, v).</p><p>1. G(1 k ) generates key pair (sk, vk) such that sk = x ∈ Z * p and vk = (p, g, G 1 , X), where G 1 is a group of prime order p, g is a generator of G 1 , and X = g x . 2. S(sk, m) signs the message m with the signing key sk by σ(m) = g 1/(x+m) . 3. V (vk, m, σ) verifies the signature σ with vk by calculating e(σ, g m X). If the result equals e(g, g), V outputs valid; otherwise, V outputs invalid.</p><p>Protocol 1. Proof of P1's output authenticity</p><p>Common Input: ciphertext of P1's output f1 ⊕ c = [m1, . . . , mn], the indices of the evaluation-circuits S = {j1, . . . , je} and the public key (p, G, g, X, Y ) of the Boneh-Boyen signature scheme. In particular, X = g x , and Y = g y . P1 Input: the corresponding private key (x, y) of the signature scheme. P2 Input: the signature vector [σ(b1, 1, j l ), . . . , σ(bn, n, j l )] such that σ(b, i, j) = g 1/(bx+iy+j) and j l ∈ S.</p><p>P1 Z,{δ(j)} j∈S -P2 P1 picks another generator h of G and a random z ∈ Z * p . Then P1 sends [Z, δ(j1), . . . , δ(je)] to P2 such that </p><formula xml:id="formula_4">Z = h z and δ(j) = h 1/(z+j) . P1 U 1 ,...,Un,V P2 P2 picks u1, . . . , un, v ∈ Zp and computes Ui ← σ(bi, i, j l ) u i and V ← δ(j l ) v . Then [U1, . . . , Un, V ] is sent to P1. P1 a 1 ,...</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Committing Oblivious Transfer</head><p>The oblivious transfer (OT) primitive, introduced by Rabin <ref type="bibr" target="#b23">[21]</ref>, and extended by Even, Goldreich, and Lempel <ref type="bibr" target="#b3">[5]</ref> and Brassard, Crépeau and Robert <ref type="bibr" target="#b1">[3]</ref> works as follows: there is a sender with messages [m 1 , . . . , m n ] and a receiver with a selection value σ ∈ {1, . . . , n}. The receiver wishes to retrieve m σ from the sender in such a way that (1) the sender does not "learn" anything about the receiver's choice σ and (2) the receiver "learns" only m σ and nothing about any other message m i for i = σ. Kiraz and Schoenmakers <ref type="bibr" target="#b9">[10]</ref> introduced another notion of OT called committing OT in which the receiver also receives a perfectly-hiding and computationally-binding commitment to the sender's input messages, and the sender receives as output the values to open the commitment. Indeed, Kiraz and Schoenmakers introduced this notion specifically for use in a Yao circuit evaluation context. We adopt the idea behind their construction.</p><p>Formally, a one-out-of-two committing oblivious transfer OT 2  1 is a pair of interactive probabilistic polynomial-time algorithms sender and receiver. During the protocol, the sender runs with input messages ((m 0 , r 0 ), (m 1 , r 1 )), while the receiver runs with input the index σ ∈ {0, 1} of the message it wishes to receive. At the end of the protocol, the receiver outputs the retrieved message m σ and two commitments com h (m 0 ; r 0 ), com h (m 1 ; r 1 ), and the sender outputs the openings (r 0 , r 1 ) to these commitments. Correctness requires that m σ = m σ for all messages m 0 , m 1 , for all selections σ ∈ {0, 1} and for all coin tosses of the algorithms. Here, we use the standard notion of simulation security.</p><p>Theorem 1. <ref type="bibr" target="#b20">[19]</ref> If the Decisional Diffie-Hellman assumption holds in group G, there exists a protocol that securely computes the committing OT 2 1 .</p><p>Protocol 2 constructively proves Theorem 1. This protocol is a simple modification of the OT protocols designed by Peikert, Vaikuntanathan, and Waters <ref type="bibr" target="#b20">[19]</ref> and later Lindell and Pinkas <ref type="bibr" target="#b15">[14]</ref>. We simply add a ZK proof of knowledge in intermediate steps. Intuitively, the receiver-security is achieved due to the Decisional Diffie-Hellman assumption and the fact that the ZK proof of knowledge is independent of the receiver's input. On the other hand, the sender security comes from the uniform distributions of X i,j and Y i,j over G given that r i,j and s i,j are uniformly chosen and that the ZK proof has an ideal-world simulator for the verifier (or the receiver in the OT). As described in <ref type="bibr" target="#b16">[15]</ref>, it is possible to batch the oblivious transfer operations so that all n input keys (one for each bit) to s copies of the garbled circuit are transferred in one execution.</p><p>Protocol 2. Oblivious transfer for retrieving P2's input keys <ref type="bibr" target="#b15">[14]</ref> Common: A statistical security parameter s, a group G of prime order p, and G's generator g0 P1 Input: Two s-tuples [K0,1, . . . , K0,s] and [K1,1, . . . , K1,s]. P2 Input: σ ∈ {0, 1} P1 Output: Commitment openings {Ki,j , ri,j, si,j } i∈{0,1},1≤j≤s P2 Output: [Kσ,1, . . . , Kσ,s] and {comh(Ki,j ; ri,j, si,j )} i∈{0,1},1≤j≤s</p><formula xml:id="formula_5">P1 h 0 ,g 1 ,h 1 P2 P2 picks y, a ∈ Zp and sends (g1, h0, h1) ← (g y 0 , g a 0 , g a+1 1 ) to P1. P1 ZK PoK - P2 P2 proves that (h0, g1, h1) satisfies (h0 = g a 0 ) ∧ ( h 1 g 1 = g a 1 ). P1 g,h P2 P2 picks r ∈ Zp and sends g ← g r σ and h ← h r σ to P1. P1 {X i,j ,Y i,j } -P2 For i ∈ {0, 1}, 1 ≤ j ≤ s, P1</formula><p>picks ri,j, si,j ∈ Zp and sends Xi,j and Yi,j to P1, where Xi,j = g r i,j i h s i,j i and Yi,j = g r i,j h s i,j • Ki,j. P2 gets comh(Ki,j ; ri,j, si,j ) = (Xi,j , Yi,j) and computes key Kσ,j ← Yσ,j • X -r σ,j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Main Protocol</head><p>Here we put all the pieces together to form the complete protocol. Note that com h (K; t) denotes a perfectly-hiding commitment to K with opening t, and com b (K; t) denotes a perfectly-binding commitment to K with opening t. , for b ∈ {0, 1}, 1 ≤ i ≤ 2n, 1 ≤ j ≤ s. Next, P 1 constructs s independent copies of garbled version of C, denoted by GC 1 , . . . , GC s . In addition to Yao's construction, circuit GC j also satisfies the following: (a) J b i,j is associated with value b to P 1 's i-th input wire, where J b i,j is extracted from group element F clw (b, I, m b i,j ), ie., )) is associated with value b to P 1 's i-th input wire; -K b i,j is associated with bit value b to P 2 's i-th input wire; -V sig (pk 1 , (b, i, j), σ(b, i, j)) = valid, where σ(b, i, j) is the signature comes along with bit value b from P 1 's i-th output wire; -the truth table of each boolean gate is correctly converted to the doubly-encrypted entries of the corresponding garbled gate. If any of the above checks fails, P 2 aborts. 6. Consistency check for P 1 's inputs: Let e = 2s/5 and {j 1 , . . . , j e } be the indices of evaluation-circuits. P 1 then decommits to her input keys for the evaluation-circuits by sending ([r is able to do the evaluation on circuit GC j and get P 1 's output [m 1,j ||σ(m 1,j ), . . . , m n,j ||σ(m n,j )] and P 2 's output [n 1,j , . . . , n n,j ], where m i,j , n i,j ∈ {0, 1}. Let M j = [m 1,j , . . . , m n,j ] and N j = [n 1,j , . . . , n n,j ] be the n-bit outputs for P 1 and P 2 , respectively. P 2 then chooses index j l such that M j l and N j l appear more than e/2 times in vectors [M j1 , . . . , M je ] and [N j1 , . . . , N je ], respectively. P 2 sends M j l to P 1 and takes N j l as her final output. If no such j l exists, P 2 aborts. 8. Verification to P 1 's output: To convince P 1 the authenticity of M j l without revealing j l , P 1 generates another signature key pair (sk 2 , pk 2 ). Then P 1 signs the indices of all the evaluation-circuits and sends the results to P 2 .</p><formula xml:id="formula_6">J b i,j = H(F clw (b, I, m b i,j )). (b) K b i,j chosen</formula><p>In particular, P 1 sends to P 2 the public key pk 2 and a signature vector [δ(j 1 ), . . . , δ(j e )], where δ(j) = S sig (sk 2 , j). The signature is verified by P 2 by checking V sig (pk 2 , j, δ(j)) = valid, for every j ∈ {j 1 , . . . , j e }. Next, P 2 proves to P 1 in witness-indistinguishable sense the knowledge of σ(m i,j l , i, j) (a signature signed with sk 1 ) and δ(j * ) (a signature signed with sk 2 ) such that j and j * are equivalent, for 1 ≤ i ≤ n. P 1 aborts if the proof is not valid; otherwise, P 1 takes M j l ⊕ (x n+1 , . . . , x 2n ) as her final output.</p><p>Theorem 2. Let f : {0, 1} n ×{0, 1} n → {0, 1} n ×{0, 1} n be any function. Given a secure committing oblivious transfer protocol, a perfectly-hiding commitment scheme, a perfectly-binding commitment scheme, a malleable claw-free family, and a pseudo-random function family, the Main protocol securely computes f .</p><p>We have omitted the standard simulation-based definition of "securely computes f " for space. Roughly, this definition requires a simulator for the corrupted evaluator, and a simulator for the corrupted generator that is able to generate transcripts given only oracle access to either the evaluator or generator (respectively) that are indistinguishable from the transcripts produced in real interactions between the corrupted generator and honest evaluator or honest generator and corrupted evaluator. (A simulator for when both parties are corrupted is also required but trivial.) The proof of Theorem 2 is omitted for space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Results</head><p>We produced an implementation of our protocol to demonstrate its practical benefits. Our implementation takes the boolean circuit generated by Fairplay compiler as input. The encryption function used to construct garbled gates is defined as Enc J,K (m) = (m⊕SHA-256(J)⊕SHA-256(K)) 1...k , where |J| = |K| = |m| = k, and S 1...k denotes the least significant k bits of S. Here SHA-256 is modeled as a pseudorandom function. The choice of SHA-256 is to make a fair comparison as it is used in <ref type="bibr" target="#b21">[20]</ref>. Following Pinkas et. al <ref type="bibr" target="#b21">[20]</ref>, we set the security level to 2 -40 and the security parameter k (key length) to 128-bit. In the first experiment, P 1 and P 2 hold a 32bit input x = (x 31 x 30 . . . x 0 ) 2 and y = (y 31 y 30 . . . y 0 ) 2 , respectively. They want to compute f (x, y) = (f 1 , f 2 ) such that after the secure computation, P 1 receives f 1 = 31 i=0 x i ⊕ y i , and P 2 receives f 2 as the result of comparison between x and y. The 6 gates of overhead we incur in the first experiment relate to our method for two-output functions. In the second experiment, P 2 has a 128-bit message block while P 1 has a 128-bit encryption key. They want to securely compute the AES encryption, and only P 2 gets the ciphertext.</p><p>We ran our experiments on two machines: slower and fast, where slower runs OS X 10.5 with Intel Core 2 Duo 2.8 GHz and 2GB RAM, and fast runs CentOS with Intel Xeon Quad Core E5506 2.13 GHz and 8GB RAM. slower is not as powerful as the machine used in <ref type="bibr" target="#b21">[20]</ref> (Intel Core 2 Duo 3.0 GHz, 4GB RAM), and fast is the next closest machine that we have.</p><p>Table <ref type="table" target="#tab_3">2</ref> reports the best numbers from <ref type="bibr" target="#b21">[20]</ref>. We note that <ref type="bibr" target="#b21">[20]</ref> applies the Garbled Row Reduction technique so that even non-XOR gates can save 25% of    <ref type="bibr" target="#b21">[20]</ref> (which also ensures the cheating probability is limited below 2 -40 ).</p><p>the communication overhead. A future version of our protocol can also reap this 25% reduction since the technique is compatible with our protocol. Our implementation involves a program for P 1 and one for P 2 . For the purpose of timing, we wrote another program that encapsulates both of these programs and feeds the output of one as the input of the other and vice versa. Timing routines are added around each major step of the protocol and tabulated in Table <ref type="table" target="#tab_4">3</ref>. This timing method eliminates any overhead due to network transmission, which we cannot reliably compare. The reported values are the averages from 5 runs.</p><p>We implemented our solution with the PBC (Pairing Based Cryptography) library [1] for testing. The components of our protocol, including the claw-free collections, the generator's input consistency check, and the generator's output validity check, are built on top of the elliptic curve y 2 = x 3 +3 over the field F q for some 80-bit prime q. We have made systems-level modifications to the random  bit sampling function of the PBC library (essentially to cache file handles and eliminate unnecessary systems calls).</p><p>In Table <ref type="table" target="#tab_6">4</ref>, we list the results of the MAC-based two-output function handling and ours. The MAC approach introduces extra 16,384 (128 2 ) non-XOR gates to the AES circuit, whereas the original AES circuit has only 11,286 non-XOR gates. Since the number of non-XOR gates is almost doubled in the MAC-based approach, their circuit construction and evaluation need time about twice as much as ours. Moreover, the MAC-based approach has twice as many input bits as ours so that the time for P 1 's input consistency has doubled. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 . 3 .</head><label>23</label><figDesc>1 (Claw-Free Collections in [7]). A three-tuple of algorithms (G, D, F ) is called a claw-free collection if the following conditions hold 1. Easy to evaluate: Both the index selecting algorithm G and the domain sampling algorithm D are probabilistic polynomial-time, while the evaluating algorithm F is a deterministic polynomial-time. Identical range distribution: Let f b I (x) denote the output of F on input (b, I, x). For any I in the range of G, the random variable f 0 I (D(0, I)) and f 1 I (D(1, I)) are identically distributed. Hard to form claws: For every non-uniform probabilistic polynomial-time algorithm A, every polynomial p(•), and every sufficiently large n's, it is true that Pr[I ← G(1 n ); (x, y) ← A(I) : f 0 I (x) = f 1 I (y)] &lt; 1/p(n).With the claw-free collections, our idea works as follows: P 2 first generates I by invoking the index generating algorithm G(1 k ), where k is a security parameter. For each of her input bits, P 1 invokes sampling algorithms D(I, 0) and D(I, 1) to pick [m 0,1 , . . . , m 0,s ] and [m 1,1 , . . . , m 1,s ], respectively. P 1 then constructs s copies of garbled circuit with range elements [f 0 I (m 0,1 ), . . . , f 0 I (m 0,s )] and [f 1 I (m 1,1 ), . . . , f 1 I (m 1,s )] by associating f b I (m b,j ) with P 1 's input wire of bit value b in the j-th garbled circuit. Let [j 1 , . . . , j e ] denote the indices of the garbled circuits not checked in the cut-and-choose (evaluation-circuits). During the evaluation, P 1 reveals [f b I (m b,j1 ), . . . , f b I (m b,je )] to P 2 and proves in zero-knowledge that P 1 gets f b I (m b j1 ) and f b I (m b ji ) via the same function f b I , for 2 ≤ i ≤ e. However, in the course of developing our solution, we noticed that witness indistinguishable proofs suffice in place of zero-knowledge proofs. For example, consider the claw-free collection instantiated from the Discrete Logarithm assumption, that is, let f b I (m) = g b h m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>: (G, D, F ) is a claw-free collection, and the range of D and F are groups, denoted by (G 1 , ) and (G 2 , ) respectively. 2. Uniform domain sampling: For any I in the range of G, random variable D(0, I) and D(1, I) are uniform over G 1 , and denoted by D(I) for simplicity. 3. Malleability: R : G 1 → G 2 runs in polynomial time, and for b ∈ {0, 1}, any I in the range of G, and any</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>,an,b P2 P2 picks α, β1, . . . , βn, γ ∈ Zp and sends [a1, . . . , an, b] to P1, where ai ← e(Ui, g) α e(g, g) β i and b ← e(V, h) α e(h, h) γ . P1 c -P2 P1 picks c ∈ Zp at random and sends it to P2. P1 zα,{z β i },zγ P2 P2 sends zα ← α+c•j l , z β i ← βi -c•ui, and zγ ← γ-c•v back to P1, who checks ai ? = e(Ui, X m i Y i ) c • e(Ui, g) zα • e(g, g) z β i for i = 1, . . . , n and b ? = e(V, Z) c • e(V, h) zα • e(h, h) zγ . P1 aborts if any of the checks fails.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>in Step 2 is associated with value b to P 2 's i-th input wire. (c) b||S sig (sk 1 , (b, i, j)) is associated with bit value b to P 1 's i-th output wire. 4. For b ∈ {0, 1}, 1 ≤ i ≤ 2n, 1 ≤ j ≤ s, P 1 sends circuits GC 1 , . . . , GC s and the commitments to F clw (b, I, m b i,j ), denoted by com b (F clw (b, I, m b i,j ); r b i,j ) to P 2 . 5. Cut-and-choose: P 1 and P 2 conduct the coin flipping protocol to generate a random tape, by which they agree on a set of check-circuits. Let T be the resulting set, that is, T ⊂ {1, . . . , s} and |T | = 3s/5. For every j ∈ T , P 1 sends to P 2 P 1 s of garbled circuit GC j , including [K b 1,j , . . . , K b n,j ], [t b 1,j , . . . , t b n,j ], [m b 1,j , . . . , m b 2n,j ], [r b 1,j , . . . , r b 2n,j ], for b ∈ {0, 1}, and the random keys associated with each wire of GC j . P 2 check the following: (a) The commitment from Step 2 is revealed to K b i,j with t b i,j . (b) The commitment from Step 4 is revealed to F clw (b, I, m b i,j ) with r b i,j . (c) GC j is a garbled version of C * that is correctly built. In particular, -H(F clw (b, I, m b i,j</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. (a) Communication cost for Experiment 1 by stages for our solution given statistical security parameter s = 125 and security parameter k = 128. (b) The circuit size and communication cost comparison with<ref type="bibr" target="#b21">[20]</ref> (which also ensures the cheating probability is limited below 2 -40 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. (a) Communication cost for Experiment 2 by stages for our solution given statistical security parameter s = 125 and security parameter k = 128.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Asymptotic Analysis of various two-party secure computation</figDesc><table><row><cell></cell><cell>communication</cell><cell></cell></row><row><cell>Base circuit P1's input</cell><cell>P2's input</cell><cell>Two-output</cell></row><row><cell>JS [8]</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Common input: a security parameters k, a statistical security parameter s, a malleable claw-free collection (G clw , D clw , F clw , R clw ), a signature scheme (G sig , S sig , V sig ), a two-universal hash function H : {0, 1} * → {0, 1} k , and the description of a boolean circuitC computing f (x, y) = (f 1 , f 2 ), where |x| = 2n (including the extra n-bit random input) and |y| = |f 1 | = |f 2 | = n.Private input: P 1 has the original input x 1 . . . x n and the extra random input x = x n+1 . . . x 2n , while P 2 has input y = y 1 y 2 . . . y n . Private output: P 1 receives output f 1 (x, y), while P 2 receives output f 2 (x, y).1. P 2 runs the index selecting algorithm I ← G clw (1 k ) and sends I to P 1 . 2. Committing OT for P 2 's input: For every 1 ≤ i ≤ n and every 1 ≤ j ≤ s, P 1 picks a random pair of k-bit strings (K 0 i,j , K 1 i,j ), which is associated with P 2 's i-th input wire in the j-th circuit. Both parties then conduct n instances of committing OT in parallel. In the i-th instance, (a) P 1 uses input ([K 0</figDesc><table><row><cell>i,1 , . . . , K 0 i,s ], [K 1 i,1 , . . . , K 1 i,s ]), whereas P 2 uses input y i .</cell></row><row><cell>(b) P 1 gets the openings ([t 0 i,1 , . . . , t 0 i,s ], [t 1 i,1 , . . . , t 1 i,s ]) to both commitment vectors, whereas P 2 gets the vector of her choice [K yi i,1 , . . . , K yi i,s ] and the</cell></row><row><cell>commitments to both vectors, ie., [com h (K 0 i,1 ; t 0 i,1 ), . . . , com h (K 0 i,s ; t 0 i,s )]</cell></row><row><cell>and [com h (K 1 i,1 ; t 1 i,1 ), . . . , com h (K 1 i,s ; t 1 i,s )].</cell></row><row><cell>3. Garbled circuit construction: P 1 runs the key generating algorithm</cell></row><row><cell>G sig (1 k ) to generate a signature key pair (sk 1 , pk 1 ) and the domain sam-</cell></row><row><cell>pling algorithm D clw (I) to generate domain element m b i,j</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>. Let [M 1,j1 , . . . , M 2n,j1 ], . . ., [M 1,je , . . . , M 2n,je ] be the resulting decommitments. Next, P 1 proves the consistency of her i-th input bit by sending [m xi</figDesc><table><row><cell></cell><cell cols="2">x1 1,j1 , . . . , r x2n 2n,j1 ], . . . , [r x1 1,je , . . . , r x2n 2n,je ]) to</cell></row><row><cell>P 2 i,j2</cell><cell cols="2">(m xi i,j1 ) -1 , . . . , m xi i,je (m xi i,j1 ) -1 ] to P 2 , who then checks if</cell></row><row><cell></cell><cell>M i,j l = M i,j1 R clw (I, m xi i,j l</cell><cell>(m xi i,j1 ) -1 ), for l = 2, . . . , e.</cell></row><row><cell cols="3">P 2 aborts if any of the checks fails. Otherwise, let J xi i,j</cell></row></table><note><p>l = H(M i,j l ). 7. Circuit evaluation: For every j ∈ {j 1 , . . . , j e }, P 2 now has key vectors [J x1 1,j , . . . , J x2n 2n,j ] (from Step 6) representing P 1 's input x and [K y1 1,j , . . . , K yn n,j ] (from Step 2) representing P 2 's input y. So P 2</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>The performance comparison with<ref type="bibr" target="#b21">[20]</ref> </figDesc><table><row><cell></cell><cell></cell><cell># Gates</cell><cell></cell><cell cols="2">Time (s)</cell><cell cols="2">Totals</cell></row><row><cell></cell><cell cols="7">Base Overhead Non-XOR Precomp OT Calc Time (s) KBytes</cell></row><row><cell>(f1, f2)</cell><cell>531</cell><cell>2,250</cell><cell>278</cell><cell>117</cell><cell>16 39</cell><cell>172</cell><cell>140,265</cell></row><row><cell>Ours (on slower)</cell><cell>531</cell><cell>6</cell><cell>237</cell><cell>35</cell><cell>15 21</cell><cell>71</cell><cell>5,513</cell></row><row><cell>Ours (on fast)</cell><cell>531</cell><cell>6</cell><cell>237</cell><cell>27</cell><cell>11 15</cell><cell>53</cell><cell>5,513</cell></row><row><cell>(λ, AESx(y))</cell><cell cols="2">33,880 12,080</cell><cell>11,490</cell><cell>483</cell><cell>34 361</cell><cell>878</cell><cell>406,010</cell></row><row><cell cols="2">Ours (on slower) 33,880</cell><cell>0</cell><cell>11,286</cell><cell>138</cell><cell>58 69</cell><cell cols="2">265 190,122</cell></row><row><cell>Ours (on fast)</cell><cell>33,880</cell><cell>0</cell><cell>11,286</cell><cell>98</cell><cell>44 50</cell><cell>192</cell><cell>190,122</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 .</head><label>3</label><figDesc>The running time (in seconds) of two experiments on machine slower f (x, y) = (f1, f2) f (x, y) = (λ, AESx(y))</figDesc><table><row><cell></cell><cell>P1</cell><cell cols="2">P2 Sum (s)</cell><cell>P1</cell><cell cols="2">P2 Sum (s)</cell></row><row><cell>Precomp Time</cell><cell>35.4</cell><cell>0.0</cell><cell>35.4</cell><cell>137.7</cell><cell>0.0</cell><cell>137.7</cell></row><row><cell>OT Time</cell><cell>7.9</cell><cell>6.7</cell><cell>14.6</cell><cell>31.9</cell><cell>26.3</cell><cell>58.2</cell></row><row><cell>Cut-and-Choose</cell><cell>0.0</cell><cell>14.7</cell><cell>14.7</cell><cell>0.0</cell><cell>44.4</cell><cell>44.4</cell></row><row><cell>Input Check</cell><cell>0.0</cell><cell>3.0</cell><cell>3.0</cell><cell>0.0</cell><cell>10.0</cell><cell>10.0</cell></row><row><cell>Eval Time</cell><cell>0.0</cell><cell>3.4</cell><cell>3.4</cell><cell>0.0</cell><cell>14.1</cell><cell>14.1</cell></row><row><cell>Two-output</cell><cell>0.1</cell><cell>0.0</cell><cell>0.1</cell><cell>0.0</cell><cell>0.0</cell><cell>0.0</cell></row><row><cell>Total (s)</cell><cell>43.4</cell><cell>27.8</cell><cell>71.2</cell><cell>169.6</cell><cell>94.8</cell><cell>264.4</cell></row><row><cell cols="3">comm. for each stage (KBytes)</cell><cell></cell><cell cols="3">Semi-honest Adversaries</cell></row><row><cell>Circuit construction</cell><cell cols="2">2, 945 53.42%</cell><cell></cell><cell></cell><cell>This work</cell><cell>[20]</cell></row><row><cell>Oblivious transfer</cell><cell cols="2">675 12.25%</cell><cell cols="2">No. of gates</cell><cell>531</cell><cell>531</cell></row><row><cell>Cut-and-choose</cell><cell cols="2">1, 813 32.89%</cell><cell cols="2">Comm. (KBytes)</cell><cell>23</cell><cell>22</cell></row><row><cell>P1's input consistency P1's output validity</cell><cell cols="2">76 1.38% 3 0.01%</cell><cell></cell><cell cols="3">Malicious Adversaries</cell></row><row><cell cols="3">Total communication 5,513 100.00%</cell><cell cols="2">No. of gates Comm. (KBytes)</cell><cell>537 5, 513</cell><cell>781 167, 276</cell></row><row><cell>(a)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(b)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>comm. for each stage (KBytes)</figDesc><table><row><cell></cell><cell></cell><cell cols="3">Semi-honest Adversaries</cell></row><row><cell>Circuit construction</cell><cell>99, 408 52.29%</cell><cell></cell><cell>This work</cell><cell>[20]</cell></row><row><cell>Oblivious transfer</cell><cell>2, 699 1.42%</cell><cell>No. of gates</cell><cell>33, 880</cell><cell>33, 880</cell></row><row><cell>Cut-and-choose</cell><cell>87, 585 46.16%</cell><cell>Comm. (KBytes)</cell><cell>795</cell><cell>503</cell></row><row><cell>P1's input consistency P1's output validity</cell><cell>256 0.13% 0 0.00%</cell><cell cols="3">Malicious Adversaries</cell></row><row><cell cols="2">Total communication 190,122 100.00%</cell><cell cols="2">No. of gates Comm. (KBytes) 190, 122 33, 880</cell><cell>45, 960 406, 010</cell></row><row><cell>(a)</cell><cell></cell><cell></cell><cell>(b)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 .</head><label>4</label><figDesc>Computation time (in seconds) of f (x, y) = (AESx(y), λ) running on machine slower under different two-output handling methods MAC two-output approach Our two-output approach</figDesc><table><row><cell></cell><cell>P1</cell><cell cols="2">P2 Subtotal</cell><cell>P1</cell><cell cols="2">P2 Subtotal</cell></row><row><cell>Precomp Time</cell><cell>498.9</cell><cell>0.0</cell><cell>498.9</cell><cell>294.1</cell><cell>0.0</cell><cell>294.1</cell></row><row><cell>OT Time</cell><cell>32.0</cell><cell>26.3</cell><cell>58.3</cell><cell>31.9</cell><cell>26.2</cell><cell>58.1</cell></row><row><cell>Cut-and-Choose</cell><cell cols="2">0.0 158.6</cell><cell>158.6</cell><cell>0.0</cell><cell>185.3</cell><cell>185.3</cell></row><row><cell>Input Check</cell><cell>0.0</cell><cell>40.4</cell><cell>40.4</cell><cell>0.0</cell><cell>19.8</cell><cell>19.8</cell></row><row><cell>Eval Time</cell><cell>0.0</cell><cell>50.6</cell><cell>50.6</cell><cell>0.0</cell><cell>24.4</cell><cell>24.4</cell></row><row><cell>Two-output</cell><cell>0.0</cell><cell>0.0</cell><cell>0.0</cell><cell>0.7</cell><cell>0.6</cell><cell>1.3</cell></row><row><cell>Total</cell><cell cols="2">530.9 275.9</cell><cell>806.8</cell><cell>326.7</cell><cell>256.3</cell><cell>583.0</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>Here f1 and f2 are abbreviations of f1(x, y) and f2(x, y) for simplicity purpose.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>It is well known that claw-free collections exist under either the Discrete Logarithm assumption or Integer Factorization assumption<ref type="bibr" target="#b5">[7]</ref>.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Optimal Choice in Cut-and-Choose Strategy</head><p>According to the cut-and-choose strategy, P 2 chooses e copies of the garbled circuits and asks P 1 to open the rest (se). After the verification, P 2 evaluates the rest e copies of the circuits and takes the majority output as her output. A natural question is: Under the assumption that P 1 's inputs are consistent, how many circuits does P 2 evaluate in order to minimize the probability for P 1 's best cheating strategy to succeed?</p><p>The assumption is valid due to the consistency check on P 1 's input. Given that s and e are fixed and known to P 1 , let b be the number of bad circuits created by P 1 . A circuit is bad if either the circuit is wrongly constructed or P 2 's inputs are selectively failed via OT. The goal is to find e and b such that the probability that P 1 cheats without getting caught s-b s-e / s s-e is minimized. We first claim that P 1 's best cheating strategy is to produce b = e/2 + 1 bad circuits. Indeed, if b ≤ e/2 , P 2 's output will not get affected since the faulty outputs will be overwhelmed by majority good ones. Also, the more bad circuits, the more likely that P 1 will get caught since s-(b-1) s-e &gt; s-b s-e . So the best strategy for P 1 to succeed in cheating is to construct as few bad circuits as possible while the majority of evaluation circuits are bad, which justifies the choice of b.</p><p>Our next goal is to find the e that minimizes Pr(e) = s-e 2 -1 s-e / s s-e . To get rid of the troublesome floor function, we will consider the case when e is even and odd separately. When e = 2k for some k ∈ N such that k ≤ s 2 , let Pr even (k) = s-k-1 s-2k / s s-2k . Observer that Preven(k+1) Preven(k) = (2k+1)(2k+2) (s-k-1)k . It is not hard to solve the quadratic inequality and come to the result that Pr even (k + 1) Pr even (k)</p><p>In other words, Pr even (k) ≥ Pr even (k + 1) when 0 &lt; k ≤ α; and Pr even (k) &lt; Pr even (k + 1) when α &lt; k ≤ s 2 . Therefore, Pr even is minimal when k = α . Similarly, when e = 2k + 1, the probability Pr odd (k) = s-k-1 s-2k-1 / s s-2k-1 is minimal when k = β , where β = 1 5 (s -7). In summary, Pr even (e) is minimal when e = 2 α ; Pr odd (e) is minimal when e = 2 β + 1, and Pr(e)'s minimum is one of them.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Short Signatures Without Random Oracles and the SDH Assumption in Bilinear Groups</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="149" to="177" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">All-or-Nothing Disclosure of Secrets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Robert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1986</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Odlyzko</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">263</biblScope>
			<biblScope unit="page" from="234" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient Protocols for Set Membership and Range Proofs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chaabouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shelat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2008</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Pieprzyk</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5350</biblScope>
			<biblScope unit="page" from="234" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Randomized Protocol for Signing Contracts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="637" to="647" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">How to Play ANY Mental Game</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th Annual ACM Symposium on Theory of Computing</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">How to Construct Constant-Round Zero-Knowledge Proof Systems for NP</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="167" to="189" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient Two-Party Secure Computation on Committed Inputs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2007</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4515</biblScope>
			<biblScope unit="page" from="97" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Kiraz</surname></persName>
		</author>
		<title level="m">Secure and Fair Two-Party Computation</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universiteit Eindhoven</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Protocol Issue for The Malicious Case of Yao&apos;s Garbled Circuit Construction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kiraz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schoenmakers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th Symposium on Information Theory in the Benelux</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="283" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Efficient Protocol for Fair Secure Two-Party Computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kiraz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schoenmakers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2008</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4964</biblScope>
			<biblScope unit="page" from="88" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Improved Garbled Circuit: Free XOR Gates and Applications</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2008, Part II</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Aceto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Goldberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Halldórsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Ingólfsdóttir</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Walukiewicz</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5126</biblScope>
			<biblScope unit="page" from="486" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An Efficient Protocol for Secure Two-Party Computation in the Presence of Malicious Adversaries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2007</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4515</biblScope>
			<biblScope unit="page" from="52" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Secure Two-Party Computation Via Cut-and-Choose Oblivious Transfer</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2010/284" />
	</analytic>
	<monogr>
		<title level="j">Crypto ePrint Archive</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Implementing Two-Party Computation Efficiently with Security Against Malicious Adversaries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN 2008</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>De Prisco</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Visconti</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5229</biblScope>
			<biblScope unit="page" from="2" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficiency Tradeoffs for Malicious Two-Party Computation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mohassel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2006</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3958</biblScope>
			<biblScope unit="page" from="458" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Oblivious transfer with adaptive queries</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1999</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Wiener</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1666</biblScope>
			<biblScope unit="page">791</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">LEGO for Two-Party Secure Computation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Orlandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2009</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5444</biblScope>
			<biblScope unit="page" from="368" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A framework for efficient and composable oblivious transfer</title>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="554" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Secure Two-Party Computation Is Practical</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2009</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">5912</biblScope>
			<biblScope unit="page" from="250" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">How to Exchange Secrets by Oblivious Transfer</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rabin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Harvard Aiken Computation Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. TR-81</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Revisiting the Efficiency of Malicious Two-Party Computation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Woodruff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2007</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4515</biblScope>
			<biblScope unit="page" from="79" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Protocols for Secure Computations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="160" to="164" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
