<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Data Streaming Algorithms for Efficient and Accurate Estimation of Flow Size Distribution</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Abhishek</forename><surname>Kumar</surname></persName>
							<email>akumar@cc.gatech.edu</email>
							<affiliation key="aff0">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Minho</forename><surname>Sung</surname></persName>
							<email>mhsung@cc.gatech.edu</email>
							<affiliation key="aff0">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jim</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jia</forename><surname>Wang</surname></persName>
							<email>jiawang@research.att.com</email>
							<affiliation key="aff0">
								<orgName type="department">College of Computing</orgName>
								<orgName type="institution">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Data Streaming Algorithms for Efficient and Accurate Estimation of Flow Size Distribution</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">01813AA54E67A799C8D89F86B3BF934D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.3 [COMPUTER-COMMUNICATION NETWORKS]: Network Operations -Network Monitoring E.1 [DATA STRUCTURES] Algorithms</term>
					<term>Measurement</term>
					<term>Theory Network Measurement</term>
					<term>Traffic Analysis</term>
					<term>Data Streaming</term>
					<term>Statistical Inference</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Knowing the distribution of the sizes of traffic flows passing through a network link helps a network operator to characterize network resource usage, infer traffic demands, detect traffic anomalies, and accommodate new traffic demands through better traffic engineering. Previous work on estimating the flow size distribution has been focused on making inferences from sampled network traffic. Its accuracy is limited by the (typically) low sampling rate required to make the sampling operation affordable. In this paper we present a novel data streaming algorithm to provide much more accurate estimates of flow distribution, using a "lossy data structure" which consists of an array of counters fitted well into SRAM. For each incoming packet, our algorithm only needs to increment one underlying counter, making the algorithm fast enough even for 40 Gbps (OC-768) links. The data structure is lossy in the sense that sizes of multiple flows may collide into the same counter. Our algorithm uses Bayesian statistical methods such as Expectation Maximization to infer the most likely flow size distribution that results in the observed counter values after collision. Evaluations of this algorithm on large Internet traces obtained from several sources (including a tier-1 ISP) demonstrate that it has very high measurement accuracy (within 2%). Our algorithm not only dramatically improves the accuracy of flow distribution measurement, but also contributes to the field of data streaming by formalizing an existing methodology and applying it to the context of estimating the flow-distribution.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The problem of estimating flow distribution on a highspeed link has received considerable attention recently <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref>. In this problem, given an arbitrary flow size s, we are interested in knowing the number of flows that contain s packets, within a monitoring interval. In other words, we would like to know how the total traffic volume splits into flows of different sizes. An estimate of the flow distribution contains knowledge about the number of flows for all possible flow sizes, including elephants (large flows), "kangaroos/rabbits" (medium flows), and "mice" (small flows).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivation</head><p>Flow distribution information can be useful in a number of applications in network measurement and monitoring <ref type="foot" target="#foot_0">1</ref> . First, flow distribution information may allow service providers to infer the usage pattern of their networks, such as the approximate number of users with dial-up or broadband access. Such information on usage patterns can be important for the purpose of pricing, billing, infrastructure engineering, and resource planning. In addition, network operators may also infer the type of applications that are running over a network link without looking into the details of traffic such as how many users are using streamed music, streamed video, and voice over IP. In the future, we expect more network applications to be recognizable through flow distribution information.</p><p>Second, flow distribution information can help locally detect the existence of an event that causes the transition of the global network dynamics from one mode to another. An example of such mode transition is a sudden increase in the number of large flows (i.e., elephants) in a link. Possible events that may cause this include link failure or route flapping. Merely looking at the total load of the link may not detect such a transition since this link could be consistently heavily used anyway.</p><p>Furthermore, flow distribution information may also help us detect various types of Internet security attacks such as DDoS and Internet worms. In the case of DDoS attacks, if the attackers are using spoofed IP addresses, we will observe a significant increase in flows of size 1. In the case of Internet worms, we may suddenly find a large number of flows of a particular size in Internet links around the same time, if the worm is a naive one that does not change in size. Also, the historical flow distribution information stored at various links may help us study its evolution over time.</p><p>Finally, knowing the flow distribution of each link may help other network measurement applications such as traffic matrix estimation <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>. Recent work <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref> show that it is possible to use tomography techniques to infer the traffic matrix from link load and aggregate input/output traffic at each node. We have preliminary evidence to believe that flow distribution at each node will make such tomography much more accurate, since it allows the correlation of not only the total traffic volume (load), but also the correlation of its distribution into different flows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Problem statement</head><p>The problem of computing the distribution of the sizes of the flows can be formalized as follows. The set of possible flow sizes is the set of all positive integers between 1 to z.</p><p>Here z is the maximum flow size that can be determined from the observed data. We denote the total number of flows as n, and the number of flows that have i packets as ni. We denote the fraction of flows that have i packets as φi, i.e., φi = n i n . The data that need to be estimated are the values of n and φ = {φ1, φ2, • • • , φz}. Our goal is to find an efficient scheme to estimate this flow distribution information on a high-speed link (e.g., OC-192 to OC-768) with high accuracy.</p><p>A naive solution to this problem is to use a hash table of per-flow counters to keep track of all active flows. These counters will later be examined to obtain the flow distribution. Although this approach is straightforward, it is not suitable for a high-speed link for the following reasons. Each flow entry in the hash table is large (∼160 bits) because it needs to store flow labels (∼100 bits), a pointer (∼ 32 bits) to the next entry if chaining is used to resolve hash collision 2 , and a packet counter (∼32 bits). Since there can be a large number of flows (e.g., 0.5 million) on backbone links during a typical measurement period, a hash table of this size typically can only fit into DRAM. However, DRAM speed cannot keep up with the link rate of OC-192 and higher 3 .</p><p>Another possible approach <ref type="bibr" target="#b0">[1]</ref> is to sample a small percentage of packets and then infer the flow distribution from the sampled traffic. The algorithm proposed in <ref type="bibr" target="#b0">[1]</ref> may well be the best algorithm in getting as much information from the sampled data as possible. However, its accuracy is limited by the typically low sampling rate (e.g., 1%) required to make the sampling operation affordable. Recent work <ref type="bibr" target="#b1">[2]</ref> has provided theoretical insights into the limitation of inferring flow distribution from sampled traffic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Our approach and contributions</head><p>The main contribution of this paper is a novel data streaming algorithm to provide much more accurate estimates of 2 Linear probing and double hashing will not help save space since there is a tradeoff between the occupancy ratio and probe length. 3 With an average packet size of 1000 bits, per-packet processing time can be no more than 100 ns and 25 ns, for OC-192 and OC-768, respectively. A hash table operation in DRAM will take hundreds of nanoseconds due to the need to retrieve the correct flow entry, compare the flow labels, and increment and write back the counter. flow distribution. Our algorithm uses a "lossy data structure" that consists of an array of counters. Its total size is small enough to fit easily in fast SRAM. For each incoming packet, our algorithm only needs to increment one underlying counter (in SRAM), making the algorithm fast enough even for 40 Gbps (OC-768) links. The data structure is lossy in the sense that, due to collision in hashing, sizes of multiple flows may be accumulated in the same counter. Therefore, the raw information obtained from the counters can be far away from the actual flow distribution. Our algorithm then uses Bayesian statistical methods such as Expectation Maximization (EM) to infer the most likely flow size distribution that results in the observed counter values after collision. Experiments of this algorithm on a number of large traces demonstrate that it has very high measurement accuracy (within 2% relative error).</p><p>However, to achieve this level of accuracy, our algorithm needs to know the approximate (± 50%) value of n, the total number of flows, in order to provision sufficient number of counters for streaming. Provisioning for the worst case (i.e., when the number of concurrent flows are the largest) leads to unnecessary waste of precious SRAM resource in the average case. To address this challenge, we propose a multi-resolution variant of our algorithm that uses a small and fixed amount of SRAM and does not require any prior knowledge about the approximate range of n. It guarantees high accuracy in the average case and graceful degradation in accuracy in the worst case.</p><p>Our algorithm not only dramatically improves the accuracy of flow distribution measurement, but also contributes to the field of data streaming by formalizing an existing yet implicit methodology, and exploring it in a new direction. Data streaming <ref type="bibr" target="#b10">[11]</ref> is concerned with processing a long stream of data items in one pass using a small working memory in order to answer a class of queries regarding the stream. The challenge is to use this small memory to "remember" as much information pertinent to the queries as possible. In designing this algorithm, we formalize the following methodology.</p><p>Lossy data structure + Bayesian statistics = Accurate streaming Its main idea is to first perform data streaming at very high speed in a small memory to get the streaming results that are lossy. There are two causes for this loss to be inevitable. First, due to the stringent computational complexity requirement of the application (e.g., 25ns per packet when processing OC-768 traffic), the streaming algorithm does not have enough processing time to "put the data into the exact place". Second, the streaming algorithm does not have enough space to store all the relevant data. Due to the loss, the streaming result is typically far away from the information we would like to estimate. Bayesian statistics is therefore used to recover information from the streaming result as much as possible. While Bayesian statistics is typically used in existing streaming algorithms to recover the second cause of loss, our algorithm uses it mainly to recover the first cause of loss. Also, to the best of our knowledge, our algorithm is the first to use sophisticated Bayesian tools such as EM in this recovery.</p><p>The rest of this paper is organized as follows. In the next section, we provide an overview of the data collection portion of our solution and describe the design of our streaming data structure in detail. Section 3 describes our estimation mechanism. We formalize the estimation mechanism and analyze its correctness in Section 4. Section 5 presents a multi-resolution version of our mechanism that can operate with an array of fixed size. Section 6 evaluates the proposed scheme over a number of large packet header traces obtained from various places including a tier-1 ISP backbone network. We present a brief look at related work with a discussion about the context of our work in Section 7 before concluding in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">DATA STREAMING USING A LOSSY DATA STRUCTURE</head><p>In this section, we first give an overview of the system model and the design philosophy of our approach. Then we describe our online update scheme (i.e., the "lossy data structure") and analyze its computational and storage complexity. Finally, we show how our scheme interfaces with the technique in <ref type="bibr" target="#b11">[12]</ref> to reduce the storage complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">System model</head><p>The overall architecture of our solution is shown in Figure <ref type="figure" target="#fig_0">1</ref>. The online streaming module is updated upon each packet arrival (arc 1 in Figure <ref type="figure" target="#fig_0">1</ref>). The measurement proceeds in epochs. At the end of each measurement epoch, the counter values, which we refer to as the raw data, will be paged out from the online streaming module, and these counters will be reset to 0 for the next measurement epoch. This raw data will be processed by an offline processing module (arc 2 in Figure <ref type="figure" target="#fig_0">1</ref>) that produces a final estimate (arc 3 in Figure <ref type="figure" target="#fig_0">1</ref>) of the flow distribution<ref type="foot" target="#foot_1">4</ref> using statistical inference techniques. This system model reflects our aforementioned design philosophy of collecting as much pertinent information as possible at the streaming module, and then compensating for the information loss during data collection using Bayesian statistics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Online streaming module</head><p>Our algorithm for updating the data-streaming module upon packet arrivals is shown in Figure <ref type="figure" target="#fig_1">2</ref>. The streaming data structure used by our mechanism is extremely simplean array of counters. Upon arrival of a packet at the router, its flow label<ref type="foot" target="#foot_2">5</ref> is hashed to generate an index into this array,  and the counter at this index is incremented by 1. Collisions due to hashing might cause two or more flow labels to be hashed to same indices. Counters at such an index would contain the total number of packets belonging to all of the flows colliding into this index. We do not have any explicit mechanisms to handle collisions as any such mechanism would impose additional processing and storage overheads that are unsustainable at high speeds. This makes the encoding process very simple and fast. Efficient implementations of hash functions <ref type="bibr" target="#b12">[13]</ref> allow the online streaming module to operate at speeds as high as OC-768 without missing any packets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Complexity of online streaming module</head><p>In this section, we discuss the storage and computational complexities of operating the data streaming module. 1. Storage complexity. This refers to both the amount of fast memory required for implementing the array of counters, and the amount of space (in DRAM or disk) to store the raw counter values for later retrieval and estimation by the offline estimation module. Leveraging on the techniques for efficient implementation of a counter array proposed in <ref type="bibr" target="#b11">[12]</ref>, we require 9 bits of SRAM per counter (to be discussed in Section 2.4). This allows us to implement about 1 million counters with 1.1 MB of SRAM.</p><p>Interestingly, this raw data can be summarized to a very small size when paged to DRAM or disk. The key fact here is that our estimation mechanism does not need to know the mapping between counter values and indices. Instead, it only needs to know, for each possible counter value, the number (i.e., frequency) of counters that have this value. Therefore, we can summarize this raw data into a list of &lt;counter value, frequency&gt; tuples. It turns out that, while the number of flows is large, the unique flow sizes (and consequently, unique counter values) are usually quite small. For example, in a trace with 2.6 million packets and 192,000 flows, we observed only about 500 unique counter values. This implies that most counter values do not occur (i.e., occur with a frequency of zero) in the array, resulting in a very small list of &lt;counter value, frequency&gt; tuples. For the above example, the summary can be stored in 8KB on persistent storage, thus requiring less than 0.025 bits per packet, or 1 bit for 40 packets. 2. Computational complexity. For each packet, the data streaming module needs to compute exactly one hash of flow label. It can be any combination of fields from the packet header.</p><p>function and increment exactly one counter. This is manageable even at OC768 (40 Gbps) speeds with off-the-shelf 10ns SRAM. We will show that our efficient (compact) implementation of counters (discussed in Section 2.4) causes very little overhead, allowing operation at OC-768 speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Efficient implementation of an array of counters</head><p>Internet traffic is known to have the property that a few flows can be very large, while most other flows are small. Thus, the counters in our array need to be large enough to accommodate the largest flow size. On the other hand, the counter size needs to be made as small as possible to save precious SRAM. Recent work on efficient implementation of statistical counters <ref type="bibr" target="#b11">[12]</ref> provides an ideal mechanism to balance these two conflicting requirements, which we will leverage on in our scheme. For each counter in the array, say 32 bits wide, this mechanism uses 32 bits of slow memory (DRAM) to store a large counter and maintains a smaller counter, say 7 bits wide, in fast memory (SRAM). As the counters in SRAM exceed a certain threshold value (say 64) due to increments, it increments the value of the corresponding counter in DRAM by 64 and resets the counter in SRAM to 0. There is a 2-bit per counter overhead that covers the cost of keeping track of counters above the threshold, bringing the total number of bits per counter in SRAM to 9. For suitable choices of parameters, this scheme allows an efficient implementation of wide counters using a small amount of SRAM. This technique can be applied seamlessly to implementing the array of counters required in our data streaming module. In our algorithm 6 , the size of each counter in SRAM is 9 bits and in DRAM is 32. Also, since the scheme in <ref type="bibr" target="#b11">[12]</ref> incurs very little extra computational and memory access overhead, our streaming algorithm running on top of it can still achieve high speeds such as OC-768.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ESTIMATION MECHANISMS</head><p>In this section, we describe a collection of estimation mechanisms used in the offline processing module (shown in Figure <ref type="figure" target="#fig_0">1</ref>). They help to infer the actual flow distribution from the counter values collected by the online streaming module. Consider the hypothetical case where there are no hash collisions. In this case the distribution of counter values is the same as the actual flow distribution. However, collisions do occur with real-world hash functions, thus distorting the distribution of counter values away from the true flow distribution. This effect 7 is shown in Figure <ref type="figure" target="#fig_2">3</ref>, where we process a traffic trace (with 560K flows in it) on arrays of 1024K, 512K, 256K, and 128K counters, respectively. We can see that, as the "load factor" (formally defined later in this section) of the array increases, the number of collisions increases, which further exacerbates this distortion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Estimating the total number of flows</head><p>The first quantity that we can estimate from our counter array is the total number of flows during the measurement interval. The first mechanism for estimating this quantity (in a different application) using a (0-1) bitmap is proposed 6 We have carefully checked these parameters against the specifications in <ref type="bibr" target="#b11">[12]</ref>. 7 Our experiments on other traffic traces exhibit similar distortion effects. in <ref type="bibr" target="#b13">[14]</ref>. It can be used in our context with slight adaptation. The process of inserting (with collisions) flow counts into our counter array can be modeled as a coupon collector's problem, under the assumption of uniform hashing. As shown in <ref type="bibr" target="#b13">[14]</ref>, in an array of m counters, if the number of zero entries is m0 after the insertion of n flows, the maximum likelihood estimator for n is</p><formula xml:id="formula_0">n = m ln m m0<label>(1)</label></formula><p>This result is also exploited in <ref type="bibr" target="#b5">[6]</ref> to design a more general multi-resolution bitmap scheme to estimate n using much smaller memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Estimating the number of flows of size 1</head><p>The total number of flows containing exactly one packet is arguably the most significant single piece of information hidden in the distribution of flow sizes. From a modeling perspective, this number helps affirm or reject statistical hypotheses such as whether the flow size distribution is Zipfian. More importantly, abnormal or malicious behavior in the Internet, such as port-scanning and DDoS attacks, often manifests itself as a significant increase in the number of flows of size 1.</p><p>To estimate the number of flows of size 1 (denoted by n1), let us look at the process of inserting flow counts into the counter array. Note that a counter of value 1 must contain exactly one flow of size 1 (i.e., no collision). Based on this insight, we can derive a very accurate estimator for n1. Let λ = n m be the estimated load factor (in terms of the average number of flows that are mapped to the same index) on the array. Our simple estimator for n1 is n1 = y1e λ, where y1 is the number of counters with value 1. This surprisingly simple estimator n1 turns out to be very accurate. In our experiments shown later, we observed an accuracy of ±2% using n1. Next, we explain the reasoning behind n1.</p><p>Since the order of packet or flow arrivals does not affect the final values in the counter array, we consider a hypothetical situation where all flows of size 2 and above were inserted in the counter array first. There are altogether n -n1 of them. At this point, none of the flows of size 1 has been inserted. The number of flows hashed to an index can be modeled as a binomial distribution Binom(n -n1, 1 m ), which in turn can be approximated by Poisson( n-n 1 m ). The total number of indices that are not hit by any flow at this point (i.e., indices where the counter value is 0) can be estimated as</p><formula xml:id="formula_1">m ′ 0 ≈ m • e -n-n 1 m</formula><p>. Now, assume all the flows of size 1 are inserted into this array. Due to this insertion, some of these m ′ 0 counters will become non-zero. The counters with value 1 will be those out of a total of m ′ 0 that were zero before the insertion of n1 flows of size 1, and were hit by exactly one of these new insertions. By the same argument as above, the total number of such indices is m ′ 0 λ1e -λ 1 , where λ1 = n 1 m . But this number should be equal to y1. Therefore we have</p><formula xml:id="formula_2">y1 = m ′ 0 λ1e -λ 1 = m • e -n-n 1 m • n1 m • e -n 1 m = n1e -n m</formula><p>which can be simplified as</p><formula xml:id="formula_3">n1 = y1e n m</formula><p>(2)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Estimating the flow distribution</head><p>One is tempted to generalize the above process to derive an estimator for the number of flows of size 2, 3, and so on (i.e., estimating n2, n3, ..., nz). However, this proves to be difficult due to the following reason. While a counter of value 1 is definitely not involved in a collision, countervalues of 2 and above could be caused by the collision of two or more flows. For example, among the counters of value 2, some correspond to a flow of size 2, while the others could be two flows of size 1 hashing to the same index. Thus, while the estimate for n1 (i.e., the number of flows of size 1) depends only on our estimate of n, the estimate of n2 will depend on both n and n1. More generally, the estimate of ni will depend on our estimates of n, n1, n2, • • • , ni-1. Thus for a large flow size i, the estimate is more susceptible to errors due to this cumulative dependence effect, resulting in a sharp increase in estimation errors. Therefore, to accurately estimate flow distribution, we will take a more holistic approach, rather than estimating each quantity step by step. This approach, based on Expectation Maximization (EM) method for computing Maximum Likelihood Estimation (MLE), is the sole topic of the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">ESTIMATING FLOW DISTRIBUTION US-ING EXPECTATION MAXIMIZATION</head><p>In this section, we describe our Maximum Likelihood Estimation (MLE) algorithm that computes the flow distribution that is most likely to result in the observed counter values after the hash collisions. To find this MLE directly is difficult because there is neither a closed-form formula nor a computation procedure for p(φ|y), the distribution of the flow distribution φ conditioned on the observation y. The difficulty of computing p(φ|y) can be attributed to the fact that our observed data is incomplete.</p><p>To address this problem, we adopted a powerful method in statistics called Expectation Maximization (EM) to iteratively compute the local<ref type="foot" target="#foot_3">8</ref> MLE. EM is especially effective in finding MLE when the observation can be viewed as incomplete data. In our context, the observed counter values can be viewed as incomplete data, and the missing part is how flows collide with each other during hashing. The evaluation in Section 6 shows that our EM algorithm accurately estimates the flow distribution among all traces we have experimented with. To the best of our knowledge, this is the first work that applies EM algorithm to computing the MLE from a lossy data structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Background on EM</head><p>Let y denote our observation and φ denote the random variable whose value we would like to estimate. In MLE, we would like to find out φ * that maximizes p(φ|y). However, it is usually hard to compute such a φ * because the formula p(φ|y) is either complicated or does not have a closed form due to missing data. The EM algorithm, which captures our intuition on handling missing data, works as follows. It starts with a guess of the parameters, and then replaces missing values by their expectations given the guessed parameters, and finally estimates the parameters assuming the missing data are equal to their estimated values. This new estimate of missing values gives us a better estimate of parameters. This process will be iterated multiple times until the estimated parameters converge to a set of values (typically a local maximum as mentioned above).</p><p>Formally, EM begins with a guess of the parameter φ ini , which will serve as φ old for the first iteration. Then the following two alternating steps will be executed iteratively. Expectation step. E old (log p(γ, φ|y)) = Ê (log p(γ, φ|y)) p(γ|φ old , y)dγ, where the expectation averages over the conditional posterior distribution of the missing data γ, given the current estimate φ old . We use the notation Q(φ, φ old ) to denote E old (log p(γ, φ|y)) per the convention in statistics literature. For many applications, both p(γ|φ, y) and p(φ|γ, y) inside the integration formula above are straightforward to compute. Maximization step. Let φ new be the value of φ that maximizes Q(φ, φ old ). This φ new will serve as φ old for the next iteration.</p><p>These two steps will be iterated for a number steps until φ old and φ new are close enough to each other, a notion that will become rigorous later in Section 6.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Applying EM to our context</head><p>Our observation y, obtained from the output of online streaming module, is yi (i = 1, 2, ..., z), the number of counters that have value i. Our goal is to estimate φi, the fraction of flows that are of size i (i = 1, 2, ..., z). Here z is the maximum counter value observed from the array.</p><p>Our EM algorithm for estimating φ is shown in Figure <ref type="figure" target="#fig_3">4</ref>. We first need a guess of the flow distribution φ ini , and the total number of flows n ini . In our algorithm, we simply use the distribution obtained from the raw counter values as φ ini and the total number of non-zero counters as n ini . Based on this φ ini and n ini , we can compute, for each possible way of "splitting" an observed counter value, its average number of occurrences. Then the counts ni for flows of corresponding sizes will be credited according to this average. For example, when the value of a counter is 3, there are three possible events that result in this observation: (i) 3 = 3 (no hash collision); (ii) 3 = 1 + 2 (a flow of size 1 colliding with a flow of size 2); and (iii) 3 = 1 + 1 + 1 (three flows of size 1 hashed to the same index). Given a guess of the flow distribution, we can estimate the posterior probabilities of these three cases. Say the respective probabilities of these three events Input: y i , number of counters that have value i (1 ≤ i ≤ z) Output: MLE for the flow distribution φ 1. Initialization: pick an initial flow distribution φ (ini) and estimate the total flow count n ini from Section 3.1. 2. φ new := φ ini ; n new = n ini 3. while (convergence condition is not satisfied) 4.</p><p>φ old := φ new ; n old := n new 5.</p><p>for i :=1 to z 6.</p><p>foreach β ∈ Ω i 7.</p><p>/*Ω i is the set of all "collision patterns" 8.</p><p>that add up to i, defined in Theorem 1*/ 9.</p><p>Suppose β is that f 1 flows of size s 1 , f 2 flows of 10.</p><p>size s 2 , ..., and fq flows of size sq collide into 11.</p><p>a counter of value i, then 12.</p><p>for j := 1 to q 13. ns j := ns j + y i * f j * p(β|φ old , n, V = i) 14.</p><p>/* Procedure for computing p(β|φ old , n, V = i) 15.</p><p>is shown in Theorem  Then we estimate that, on the average, 500, 300, and 200 counters split in the three above ways, respectively. So we credit 300 * 1 + 200 * 3 = 900 to n1, the count of flows of size 1, and credit 300 and 500 to n2 and n3, respectively. Finally, after all observed counter values are split this way, we get the new counts n1, n2, ..., nz, and obtain n new (= È z i=1 ni). We then renormalize them into a new (and refined) flow distribution φ new . We will prove in Section 4.3 that this program is indeed an instance of the EM algorithm. Computing the probability p(β|φ, n, v). Let both n and m (size of counter array) be very large so that we can proximate binomial distribution using Poisson. This approximation is necessary since our estimates of flow counts can be non-integers. Let λi denote the average number of size i flows (before collision) that are hashed to an (arbitrary) index in the array. In other words, λi = n i m = nφ i m . We define λ = È z i=1 λi, which is the average number of flows (of all sizes) that is hashed to an (arbitrary) index. Let ind be an arbitrary index into the array and v be the observed value at this index. Let β be the event that f1 flows of size s1, f2 flows of size s2, ..., fq flows of size sq collide into this slot, where 1 ≤ s1 &lt; s2 &lt; ... &lt; sq ≤ z.</p><p>Lemma 1. Given φ and n, the a priori (i.e., before observing this value v) probability that event β happens is</p><formula xml:id="formula_4">p(β|φ, n) = e -λ É q i=1 λ f i s i f i ! .</formula><p>Proof. Let Bi be the event that fi flows of size si be mapped to the counter indexed by ind. Let C be the event that all other flows have zero arrivals to ind. Since the hashing is uniform, these events B1, B2, ..., Bq, and C are independent. Therefore, p(β|φ, n) = p(C|φ, n) É q i=1 p(Bi|φ, n).</p><formula xml:id="formula_5">Let I = {s1, s2, ..., sq}. Then p(Bi|φ, n) = e -λs i λ f i s i f i ! by Pois- son approximation of binomial distribution. So, É q i=1 p (Bi|φ, n) = É q i=1 e -λs i λ f i s i f i ! = É j∈I e -λ j É q i=1 λ f i s i f i ! Also, p (C|φ, n) = É j∈I e -λ j . Therefore, p (β|φ, n) = ¼ j∈I e -λ j ½ j∈I e -λ j q i=1 λ f i s i fi! = e -λ q i=1 λ f i s i fi!</formula><p>However, the situation changes after we have already seen v, the value at the counter indexed by ind.</p><p>Theorem 1. Let Ωv be the set of all collision patterns that add up to v. Then p(β|φ, n, v) = p(β|φ,n) È α∈Ωv p(α|φ,n) , where p(β|φ, n) and p(α|φ, n) can be computed using Lemma 1.</p><p>Proof. Let Ω be the set of all possible collision patterns as defined before. Let us choose an arbitrary index ind and let V be the counter value at this index. By Bayes' rule,</p><formula xml:id="formula_6">p(β|φ, n, V = v) = p(V = v|β, φ, n)p(β|φ, n) È α∈Ω p(V = v|α, φ, n)p(α|φ, n) However, note that p(V = v|α, φ, n) = 1 for all α ∈ Ωv (including β) and p(V = v|α, φ, n) = 0 for all α ∈ Ω -Ωv. Therefore, p(β|φ, n, v) = p(β|φ, n) È α∈Ωv p(α|φ, n)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Our algorithm is an EM algorithm</head><p>We next prove that the algorithm shown in Figure <ref type="figure" target="#fig_3">4</ref> is indeed an EM algorithm. This proof is important since the fact that the algorithm is an instance of EM guarantees that the outputs from the iterations of the algorithm will converge to a set of local MLEs, according to <ref type="bibr" target="#b14">[15]</ref>. Theorem 2. The algorithm in Figure <ref type="figure" target="#fig_3">4</ref> is an EM algorithm.</p><p>Proof. Let γij denote the number of size i flows that are collided (merged) into counters of value j (1 ≤ i ≤ j ≤ z). These are the missing data that the algorithm in Figure <ref type="figure" target="#fig_3">4</ref> needs to guess in order to estimate the flow distribution φ. The complete data likelihood function L(φ) (i.e., p(γ, φ|y) defined in Section 4.1), assuming γij is known, is</p><formula xml:id="formula_7">È z i=1 È z j=i γij log φi.</formula><p>Then in the expectation step, ni (i = 1, 2, ..., z) are constants and φ ′ i s are the variables. Using the method of Lagrange multiplier, we know that the maximum value is achieved when φi = n i È z j=1 n j . This is exactly the renormalization step in our program (lines 19 to 23) shown in Figure <ref type="figure" target="#fig_3">4</ref>. Therefore, our algorithm is indeed an EM algorithm.</p><formula xml:id="formula_8">E (φ old ,n) [L(φ)|y] = È z i=1 È z j=i E[γij|φ old , y, n] log φi</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Computational complexity of the EM algorithm.</head><p>It is easy to enumerate all possible events that give rise to a small counter value. But, for large counter values, the number of possible events (hash collisions) that could give rise to the observed value is immense. Thus it is not possible to exhaustively compute the probabilities for all such events. The "Zipfian" nature of flow-size distribution comes to our rescue here. To reduce the complexity of enumerating all events that could give rise to a large counter value (say larger than 300), we ignore the cases involving the collision of 4 or more flows at the corresponding index. Since the number of counters with a value larger than 300 is quite small, and collisions involving 4 or more flows occur with a low probability, this assumption has very little impact on the overall estimation mechanism. With similar justifications we ignore events involving 5 or more collisions for counters larger than 50 but smaller than 300 and those involving 7 or more collisions for all other counters. This reduces the asymptotic computational complexity of "splitting" a counter-value j to O(j 3 ) (for j &gt; 300). Note that we need to do this computation only once for all counters that have a value j, and the number of unique counter-values is quite small (as discussed earlier in Section 2.3).</p><p>Finally, since the numbers of counters with very large values (say larger than 1000) is extremely small, we can ignore splitting such counter values entirely and instead report the counter value as the size of a single flow. This will clearly lead to a slight overestimation of the size of such large flows, but since the average flow size (≈ 10) is two to three orders of magnitude smaller than these large flows, this error is minuscule in relative terms.</p><p>These optimizations bring the overall computational complexity well under control. On a 3.2 GHz Intel Pentium 4 desktop, each iteration of the EM takes about 20 seconds. If the measurement epoch is 100 seconds long and we terminate the estimation after five iterations, then the estimation can run as fast as the data streaming module.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">MULTI-RESOLUTION ESTIMATION OF FLOW DISTRIBUTION</head><p>As shown in Figure <ref type="figure" target="#fig_2">3</ref>, the raw counter value distribution deviates more and more from the actual flow distribution as the size of the counter array decreases. Our experiments in Section 6 show that the accuracy of estimation falls sharply if the size of the array is less than 2  3 of the total number of flows n. Therefore, for the accurate estimation of flow distribution, we need a counter array that contains at least 2 3 n entries. However, in real-world Internet traffic, the number of flows in the worst case can be many times more than in the average case. Provisioning enough counters for the worst case would result in excessive waste of precious SRAM in the average case. In this section, we present a multi-resolution version of our solution that uses a fixed-size array of counters, and allows a graceful degradation in estimation accu-  </p><formula xml:id="formula_9">m m m m m m 2m m 2 A A 1 r A 2 R r-1 R r R 1 R A r+1 A r+1 R r-2 m 2 r-1 m 2 r-1</formula><formula xml:id="formula_10">. Initialize 2. r = log 2 (M/m) 3. R i = ´ (1 -1 2 i-1 )M, (1 -1 2 i )M i = 1, 2, 3, ..., r ¢ (1 -1 2 r )M, M ¡ i = r + 1 µ 4. Arrays A 1 , A 2 ,• • • , A r+1 are all initialized to 0 5. Update 6.</formula><p>Upon the arrival of a packet pkt 7.</p><p>ind := hash(pkt.f low label); 8.</p><p>if (ind ∈ R j ) 9.</p><p>A j [ind mod m]++; racy when the total number of flows increases. This makes the scheme accurate and memory-efficient for the average case while its accuracy degrades only slightly for the worst case. Our design is inspired by a multi-resolution scheme used in <ref type="bibr" target="#b5">[6]</ref>. We apply it here to a different context. Our Multi-Resolution Array of Counters (MRAC) scheme works as follows. Imagine a virtual array of counters that is large enough to accurately estimate the flow distribution even in the worst case. However, the physical (actual) counter array size is much smaller. Therefore, the virtual array needs to be mapped/folded to the actual physical array as shown in Figure <ref type="figure" target="#fig_5">5</ref>. Here we describe a base-2 version of our mapping. Its generalization to any arbitrary base 'b' is straightforward. In the base-2 version, we map a logical array of M = 2 r m counters to r + 1 physical arrays of size m each. Half of the hash space will be mapped to (folded into) array 1, half of the remaining hash space (i.e., 1  4 of the total hash space) will be mapped to array 2, and so on. Finally, we are left with two blocks of hash space of size m each. They are directly mapped to arrays r and (r +1). The total space taken by the arrays is m(log 2 M m + 1). This actual mapping/folding algorithm is shown in Figure <ref type="figure" target="#fig_7">6</ref>. As described above, the arrays A1, A2, ..., Ar, Ar+1 cover the respective hash ranges of [0,</p><formula xml:id="formula_11">1 2 M ), [ 1 2 M, 3 4 M ), [ 3 4 M , 7 8 M ) , • • • , [(1 -1 2 r-1 )M , (1 -1 2 r )M ), [(1 -1 2 r )M, M</formula><p>). If a hash index ind is mapped to a array, the counter indexed by (ind mod m) in that array will be incremented. Therefore, the values of 2 r-1 counters in the virtual array map to (fold into) 1 counter in array A1, and the values of 2 r-2 virtual counters map to 1 counter in array A2, and so on. The (r + 1) arrays together cover the entire virtual hash space. The regions covered by any two arrays are disjoint.</p><p>Such a mapping is implicitly a flow sampling (not packet sampling) scheme. Array A1 processes approximately 1  2 of the flows (i.e., every packet in approximately half of the flows), array A2 processes approximately 1  4 of the flows, and so on. Note that the computational complexity of this scheme is almost the same as the baseline approach, which is one hash function computation and one memory access to SRAM. The only additional processing here is to recognize the range that a hash value falls into and to perform a modulo operation ("ind mod m" in line 9 of Figure <ref type="figure" target="#fig_7">6</ref>). Since all operations involve 2's powers, they can be implemented efficiently using simple binary logic.</p><p>The estimation algorithm works as follows. It first picks an array that will result in the best estimate of the original flow distribution. The criteria of picking such an array will be discussed next. Suppose the array we pick is 2 -i of the size of the virtual array, that is, this array samples approximately 2 -i fraction of the flows. The algorithm first estimates the flow distribution from the array using the baseline approach described in the previous two sections, and then scales the result by 2 i to obtain the estimate for the overall traffic. Since the number of very large flows (say larger than 1000 packets) is quite small, we can use the counter values larger than 1000 from all resolutions to refine our estimation for the tail of the distribution. For each of these large counter values, we subtract the average counter value in the corresponding resolution and use the result as the estimated size of the large flows hashed to this counter.</p><p>In general, the arrays where the sampling rate is high (i.e., the arrays that cover large portions of the virtual hash space) tend to be "over-crowded" (i.e., with higher average number of flows mapped to the same slot). This corresponds to using a very small array of counters, which results in inaccurate estimation. On the other hand, when the sampling rate is low (i.e., when the array covers a very small portion of the virtual hash space), the estimation from the corresponding array will be accurate, but the errors due to (flow) sampling become high. Therefore, there is a clear tradeoff between the loss of accuracy due to "over-crowding" on the one hand and due to sampling on the other. We find that there exists an optimal array size in the middle that minimizes the overall loss of accuracy, which can be found using the following criteria. We pick an array with as high sampling rate as possible, under the constraint that no more than 1.5 flows are mapped to the same slot on the average. The reasoning behind this rule is similar to that used in two existing multiresolution based schemes <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b15">16]</ref> (for different applications). We omit the details here in the interest of space.</p><p>Finally, the above design with base-2 can be generalized to any arbitrary base. Choosing a base that is a power of 2 allows efficient hardware and software implementation. Our implementation evaluated in Section 6 uses base-4. The base-4 algorithm needs 50% less memory than base-2, with nominal loss in estimation accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EVALUATION</head><p>In this section, we evaluate the accuracy of our estimation mechanism using real-world Internet traffic traces. We also compare our results with those obtained in <ref type="bibr" target="#b0">[1]</ref> from sampled traffic. Our experiments demonstrate that our mechanism achieves very high accuracy, which is typically an order of magnitude better than sampling-based approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Traffic traces</head><p>We use three sets of traces in our evaluation. The first set comprises of two packet header traces obtained from a tier-1 ISP backbone, collected by a Gigascope server <ref type="bibr" target="#b16">[17]</ref> on a high speed link leaving a data center in October, 2003. Each of the packet header traces lasts a few hours, consists of ∼700 million packet headers and carries ∼350 GB traffic. In our experiments, we used segments taken from these two traces, one for heavier traffic load on a weekday and the other for light traffic load at a weekend. Table <ref type="table" target="#tab_2">1</ref> lists the number of flows and packets in each trace.</p><p>The second set of traces we used are publicly available traffic traces from NLANR. We use three NLANR traces<ref type="foot" target="#foot_4">9</ref> named "Long", "Medium", and "Short", based on the number of flows in each trace (Table <ref type="table" target="#tab_2">1</ref>). Notice that the trace "Long" actually has fewer packets than "Medium". However, the attribute of significance in our evaluation is the number of flows in each trace, and the names are intuitive in this light.</p><p>Finally, we use a set of three traces from <ref type="bibr" target="#b0">[1]</ref> to compare with previous work on estimating flow-distribution from sampled statistics. Trace "CAMPUS" was collected at a LAN near the border of a campus network during a period of 300 minutes. Trace "COS" was collected at an OC3 link at Colorado State University during January 25 and 26, 2003. This period overlaps the onset of Slammer worm <ref type="bibr" target="#b17">[18]</ref>. Trace "PEERING" was collected at a peering link for a period of 37 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Evaluation metrics</head><p>For comparing the estimated flow distribution with the actual distribution, we considered two possible metrics, Mean Relative Difference (MRD) and Weighted Mean Relative Difference (WMRD). We eventually adopt WMRD as our evaluation metric. The rationale for this choice is given below.</p><p>The metric MRD is often used in measuring the distance between two probability distributions or mass functions, defined in our context as follows. Suppose the number of flows of size i is ni and our estimate of this number is ni. The relative error in estimation (i.e., relative difference) is given by |ni -ni|/(</p><formula xml:id="formula_12">n i + ni 2</formula><p>). The mean relative difference over all flow sizes is obtained by taking the mean of relative difference over all possible flow sizes 1, 2, 3, ..., z. Therefore, the MRD between the estimated and actual distribution is given by:</p><formula xml:id="formula_13">M RD = 1 z i |ni -ni| n i + ni 2</formula><p>However, this metric is not suitable for estimating flow distribution for the following reason. The "Zipfian" nature of the Internet traffic implies that there are a large number of small flows and only a few large flows. In other words, when i becomes larger, ni becomes smaller, and |ni -ni|/(</p><formula xml:id="formula_14">n i + ni 2</formula><p>) becomes larger. Therefore, the errors in estimating the tail of the distribution (i.e., |ni -ni|/(</p><formula xml:id="formula_15">n i + ni 2</formula><p>) for large values of i) dominate the value of MRD. This makes no sense since the main body of the distribution is the large number of small flows, the estimation accuracy of which is discounted in MRD.</p><p>To reflect the errors in estimating the number of large and small flows in proportion to their actual population, we adopt the aforementioned second metric called Weighted Mean Relative Difference (WMRD). It is proposed and used in <ref type="bibr" target="#b0">[1]</ref>, for the same purpose of evaluating the accuracy of estimated flow distribution. In WMRD, we assign a weight of n i + ni 2 to the relative error in estimating the number of flows of size i. Thus the value of WMRD is given by:</p><formula xml:id="formula_16">W M RD = È i |n i -ni | n i + ni 2 × n i + ni 2 È i n i + ni 2 = È i |n i -ni | È i n i + ni 2</formula><p>WMRD is also used in our EM algorithm to determine how close our estimate is to the convergence point. In our algorithm, we choose a threshold ǫ, and terminate our iterative estimation procedure when the WMRD of the estimates produced by two consecutive estimates falls below ǫ. The intuition here is that, as estimates get closer to the convergence point, the improvement from one iteration to the next becomes smaller, implying a smaller WMRD between the estimates produced by two consecutive estimates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Bucketing flow distribution</head><p>As can be seen from Figure <ref type="figure" target="#fig_2">3</ref>, the tail of the flow distribution plot is very noisy. This is due to the fact that a small number of large flows are distributed in a large size range in a very sparse way. To obtain a more intuitive visual depiction of the flow distribution, we use a bucketing scheme to smooth out the noise. Buckets are sets of one or more consecutive integers. The total number of flows in a bucket is the sum of the number of flows of each unique size in the bucket. For small flow sizes, where there are a large number of flows for each unique size, we use a bucket size of 1, implying no smoothing. As we proceed towards large flow sizes, gaps between two flow sizes that have non-zero counts start appearing (and then widening). We scale the bucket size appropriately so that most buckets have at least one flow. In the figures depicting flow distribution, each bucket is depicted as a data point, with the mid-point of the bucket as its x-coordinate and the total number of flows in the bucket divided by the bucket size as its y-coordinate. We emphasize that this bucketing scheme is used only for better visualization of results. Our estimation mechanism and numerical results (in WMRD) reported later in this section do not use smoothing of any form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Estimation using array of counters</head><p>As mentioned earlier in Section 5, we show that the estimation procedure is likely to be more accurate when the number of counters is close to or larger than the total number of flows in the measurement epoch. Table <ref type="table" target="#tab_3">2</ref> shows the effect of the choice of number of counters over estimation accuracy for the NLANR traces. The deviation of both the initial guess (taken from the observed counter value distribution) and the final estimate after 20 iterations of the EM algorithm becomes larger when the number of counters become smaller. However, this increase in WMRD is very small when the number of counters stay larger than or equal  to the number of flows. The increase becomes pronounced only after the number of counters drops to less than 2 3 of the number of flows.</p><p>Figure <ref type="figure" target="#fig_8">7</ref> shows how the WMRD of the estimates decreases when the number of EM iterations increases. The trace used for this experiment is trace "Long" containing 563,080 flows. Each curve corresponds to a different choice of the number of counters, ranging from 128K (2 17 ) to 1M (2 20 ). The points for iteration 0 correspond to the WMRD of the initial guess, obtained from the distribution of the raw counter values. All the curves show a downward trend on WMRD to approach zero, indicating progress toward convergence. The curves for m = 1024K and m = 512K begin with much better initial guesses, thus achieving a much smaller WMRD (in absolute value) within a small number of iterations. This reinforces the notion that using approximately the same number of counters as the number of flows provides much better estimation accuracy than using a significantly smaller number of counters. We observe similar results on other traces.</p><p>Figure <ref type="figure" target="#fig_11">8</ref> presents the results of running our estimation mechanism on the trace "Long" (similar results are observed on all traces in Table <ref type="table" target="#tab_3">2</ref>). In this experiment, the number of counters m was set to a 2's power that is closest to the number of flows n. Each figure has three curves, corresponding to the actual distribution of flow sizes, the distribution of raw counter values, and the result of our estimation mechanism, respectively. The near overlap of our estimate with the actual distribution indicates the high accuracy of the estimation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Comparison with sampling-based estimation</head><p>We compare the accuracy of our mechanism against the best known mechanism <ref type="bibr" target="#b0">[1]</ref> for estimating flow distribution from sampled traffic. It should be noted that this comparison is not to point out any shortcomings of <ref type="bibr" target="#b0">[1]</ref>. Indeed, we believe that the solution in <ref type="bibr" target="#b0">[1]</ref> is close to the best that can be done on the sampled data. The gain of accuracy in our mechanism comes from the highly efficient online data streaming algorithm, which saves us from having to skip 90% or 99% of traffic as done in the sampling-based approach.</p><p>The comparison is performed on the same data used in <ref type="bibr" target="#b0">[1]</ref> for best fairness. Figure <ref type="figure" target="#fig_15">9</ref> shows the performance of our mechanism, as well as that of <ref type="bibr" target="#b0">[1]</ref> on two sub-traces containing Web and DNS traffic, extracted from the trace "COS". There are four curves in each figure. Two of them correspond to the actual flow distribution and estimation from our mechanism (using similar number of counters as flows, as described before) respectively. The other two curves are plotted using the data corresponding to the flow distribution estimated from sampled traffic <ref type="bibr" target="#b0">[1]</ref>, with sampling rates of 10% and 1% respectively. The accuracy of our mechanism is highlighted by the nearly complete overlap between the estimate curve and the actual flow-size distribution curve. This perfect overlap actually makes the four curves look like three curves in each figure. Estimation based on sampled traffic, on the other hand, deviates much more from the actual flow distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Estimation of flows of size 1</head><p>As mentioned in Section 3.2, the number of flows of size 1 can be very accurately estimated using the estimator n1 = y1e n m . Table <ref type="table" target="#tab_5">3</ref> lists the estimated values of the number of flows of size 1 vs. the actual values for three different NLANR traces. In all cases, the estimates were within 2% of the actual value, thus demonstrating the high accuracy of the estimator.</p><p>Table <ref type="table" target="#tab_6">4</ref> measures the effectiveness of our mechanism in detecting sharp changes in the number of flows of size 1 compared with sampling-based approach. The trace "COS" contains a large number of single-packet UDP flows sent to random destination IP addresses by hosts infected with MS SQL server worm. For evaluating the mechanisms on their abilities to estimate the number of flows of size 1, a sanitized version of the trace, with all the worm packets removed, was also processed. Table <ref type="table" target="#tab_6">4</ref> compares results from the sampling-based approach <ref type="bibr" target="#b0">[1]</ref> with estimates using our mechanism (sampling rate<ref type="foot" target="#foot_5">10</ref> is 0.001). We can see that the sampling-based approach reports an increase of 20% (19,433 to 24,275) in the number of flows of size 1, while going from the sanitized trace to the complete trace. However, the actual increase (451,489 to 5,059,379) is close to 95%. This indicates the difficulty of detecting sharp changes in the number of flows of size 1 using sampling. The estimates from our mechanism, on the other hand, are quite accurate, and closely reflect the change (from 453,703 to 5,025,940).   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7">Estimation using MRAC</head><p>In this section, we present the results of estimating the flow distribution using Multi-Resolution Array of Counters (MRAC). The following base-4 configuration is used in all experiments in the sequel. The MRAC consists of three virtual arrays of logical range 87,382 (64K*4/3), 349,525 (64K*16/3) and 1,048,576 (64K*16). All these virtual arrays are implemented using a single hash function with range 0 to 2 20 -1 (=1,048,575). Each physical array has 64K counters, and the total space requirement of this MRAC configuration is 192K counters. Note that this size can be much smaller than the total number of flows in the three traces we will experiment on, which ranges from 55K to 563K.</p><p>Figure <ref type="figure" target="#fig_19">10</ref> shows our estimation results on three traces of different sizes. Except for some local fluctuations, which can be attributed to information loss due to sampling, the estimates are very close to the actual distribution most of the time, as reflected by near overlaps of the curves. In all these estimates, the most accurate resolution (virtual array) is determined automatically using the mechanism described in Section 5 (without using the undue knowledge about the actual number of flows). The WMRD values of the three traces in Figure <ref type="figure" target="#fig_19">10</ref> are 0.08557, 0.05001, and 0.03911, respectively. Note that although the WMRD values are worse than obtainable from a single counter array of suitable size, multi-resolution schemes saves considerable amount of SRAM (e.g., the "Long" trace would require 512K counters in the single resolution scheme). Moreover, MRAC's accuracy is still better than the best estimation accuracy obtainable using sampling based approaches (WMRD around 0.1 in the best cases as shown in <ref type="bibr" target="#b0">[1]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>Previous work on estimating the flow distribution has mostly focused on inferring it from sampled traffic. In <ref type="bibr" target="#b3">[4]</ref>, the authors studied the statistical properties of packet-level sampling using real-world Internet traffic traces. This is followed by <ref type="bibr" target="#b0">[1]</ref> in which the flow distribution is inferred from the sampled statistics. After showing that the naive scaling of the flow distribution estimated from the sampled traffic is in general not accurate, the authors propose an EM algorithm to iteratively compute a more accurate estimation. EM is also used in this paper, but in a very different way.</p><p>Here we try to use EM to compensate for the information loss due to hash collisions while they use EM to compensate           for the information loss due to the low sampling rate (10% or 1%). Our algorithm is much more accurate because the information loss due to hash collisions is much less than due sampling that skips 90% to 99% of packets.</p><p>Recent work <ref type="bibr" target="#b1">[2]</ref> discusses the inaccuracy of estimating flow distribution from sampled traffic, when the sampling is performed at the packet level. The authors also find that sampling at the flow level leads to more accurate estimations.</p><p>The study in <ref type="bibr" target="#b1">[2]</ref> is focused mostly on the theoretical aspects of sampling. Although they suggest that Bloom filters or bitmap algorithms can be used for flow-based sampling, no concrete mechanism is proposed. The multi-resolution version of our data structure uses sampling at the flow level, which is in line with the findings of <ref type="bibr" target="#b1">[2]</ref>.</p><p>Counter-arrays have been used in a number of systems and applications within the area of network measurement and monitoring. For example, they have been the building blocks for detecting traffic changes <ref type="bibr" target="#b18">[19]</ref>, identifying large flows <ref type="bibr" target="#b4">[5]</ref>, and constructing Bloom filters <ref type="bibr" target="#b19">[20]</ref> that allow both insertions and deletions (called counting Bloom filter) <ref type="bibr" target="#b20">[21]</ref>. To the best of our knowledge, there is no prior work in the direction of "inverting" the hash collision process in the counter array using Bayesian statistics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>Estimating the distribution of flow sizes is important in a number of network applications. Current solutions rely on extrapolating the distribution learned from packet-level sampling. Although sophisticated methods have been developed for this, the loss of information due to packet sampling ultimately restricts the accuracy of any estimates recovered from it. We propose a novel data streaming scheme that achieves much more accurate estimation than samplingbased approaches. The scheme is based on a very simple data structure -an array of counters. Due to this simplicity, the scheme is able to operate at very high link speed (e.g., 40 Gbps) using a small amount of SRAM. However, since our scheme does not have enough space and time to resolve hash collisions, our observation from the counter arrays is a highly distorted version of the flow distribution. We develop a sophisticated mechanism based on expectation maximization to invert this distortion. We evaluate our mechanism on multiple Internet traffic traces, including the traces obtained from a tier-1 ISP's backbone network, and publicly available traces from NLANR. The experimental results demonstrate that our scheme achieves an order of magnitude better accuracy than sampling based approaches. We also develop a multi-resolution version of the scheme that achieves a graceful degradation in estimation accuracy when the number of flows is much larger than the size of counter array. This allows us to provision memory resources for the average case, while losing estimation accuracy only slightly in the worst case. Our algorithm not only dramatically improves the accuracy of flow distribution measurement, but also contributes to the field of data streaming by formalizing a methodology and applying it to a new context.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: System model of using data-streaming to estimate flow distribution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Algorithm for updating the online streaming module</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The distribution of flow sizes and raw counter values using varies number of counters (both x and y axes are in log-scale). m = number of counters.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: EM algorithm for computing flow distribution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>This corresponds to Q(φ, φ old ) in Section 4.1. Let γi = È z j=i γij . Define nij = E[γij|φ old , y, n] and ni = E[γi|φ old , y, n]. By the linearity of expectation, we know that ni = È z j=i nij . Therefore, E (φ old ,n) [L(φ)|y] = È z i=1 ni log φi. Note that the definition of ni here matches the computation of ni in our algorithm (lines 5 to 18). Finally in the maximization step, we need to maximize È z i=1 ni log φi, subject to the constraint È z i=1 φi = 1. Here</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The Multi-Resolution Array of Counters.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1</head><label>1</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Algorithm for updating MRAC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The WMRD of the estimate vs. the number of iterations of the estimation algorithm, for the trace "Long".</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Estimation using our algorithm (a) Complete range of flow-sizes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Estimation using our algorithm (c) Zoomed-in further.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Actual, raw, and estimated distributions for the trace "Long".</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Inferred from sampling,N=10 Inferred from sampling,N=100 Estimation using our algorithm (a) Sampling vs. array of counters -Web traffic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Inferred from sampling,N=10 Inferred from sampling,N=100 Estimation using our algorithm (b) Replot with bucket-based smoothing -Web traffic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Inferred from sampling,N=10 Inferred from sampling,N=100 Estimation using our algorithm (c) Sampling vs. array of counters -DNS traffic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Comparison of sampling and estimation based on array of counters.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>Trace "Long" (563,080 flows).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>Trace "Medium" (192,380 flows).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>Trace "Short" (55,515 flows).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Original and estimated distributions using MRAC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Traces used in our evaluation.</figDesc><table><row><cell>Source</cell><cell>Trace</cell><cell cols="2"># of flows # of packets</cell></row><row><cell>ISP</cell><cell>Weekday</cell><cell>11,341,289</cell><cell>68,595,755</cell></row><row><cell></cell><cell>Weekend</cell><cell>1,239,746</cell><cell>8,861,457</cell></row><row><cell cols="2">NLANR Long</cell><cell>563,080</cell><cell>1,769,431</cell></row><row><cell></cell><cell>Medium</cell><cell>192,380</cell><cell>2,668,269</cell></row><row><cell></cell><cell>Short</cell><cell>55,515</cell><cell>158,243</cell></row><row><cell>[1]</cell><cell>CAMPUS</cell><cell>425,702</cell><cell>10,065,600</cell></row><row><cell></cell><cell>COS</cell><cell>6,038,554</cell><cell>37,000,000</cell></row><row><cell></cell><cell>PEERING</cell><cell>1,289,825</cell><cell>10,000,000</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>WMRD of initial guesses and final estimates.</figDesc><table><row><cell>Trace</cell><cell cols="4"># of flows Array WMRD of in trace size raw data</cell><cell>WMRD of final estimate</cell></row><row><cell></cell><cell></cell><cell>1024K</cell><cell></cell><cell>0.38195</cell><cell>0.00643</cell></row><row><cell>Long</cell><cell>563,080</cell><cell>512K 256K</cell><cell></cell><cell>0.70140 1.13521</cell><cell>0.02664 0.25858</cell></row><row><cell></cell><cell></cell><cell>128K</cell><cell></cell><cell>1.59242</cell><cell>0.95548</cell></row><row><cell></cell><cell></cell><cell>512K</cell><cell></cell><cell>0.23010</cell><cell>0.01715</cell></row><row><cell>Medium</cell><cell>192,380</cell><cell>256K 128K</cell><cell></cell><cell>0.43337 0.75778</cell><cell>0.03424 0.10895</cell></row><row><cell></cell><cell></cell><cell>64K</cell><cell></cell><cell>1.19023</cell><cell>0.42463</cell></row><row><cell></cell><cell></cell><cell>128K</cell><cell></cell><cell>0.31478</cell><cell>0.01138</cell></row><row><cell>Short</cell><cell>55,515</cell><cell>64K 32K</cell><cell></cell><cell>0.59331 1.01238</cell><cell>0.01929 0.14560</cell></row><row><cell></cell><cell></cell><cell>16K</cell><cell></cell><cell>1.48354</cell><cell>0.66332</cell></row><row><cell></cell><cell>1.6</cell><cell></cell><cell></cell><cell>m=1024K</cell></row><row><cell></cell><cell>1.4</cell><cell></cell><cell></cell><cell>m=512K m=256K</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>m=128K</cell></row><row><cell></cell><cell>1.2</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell></row><row><cell>WMRD</cell><cell>0.8</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.6</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.4</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.2</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>5</cell><cell>10</cell><cell>15</cell><cell>20</cell></row><row><cell></cell><cell></cell><cell cols="2">Iteration</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Estimation of the number of flows of size 1.</figDesc><table><row><cell>Trace</cell><cell>Flows of size 1</cell><cell cols="2">Flows of size 1 in Estimated sampled data set value</cell></row><row><cell>Original</cell><cell>5,059,379</cell><cell>24,275</cell><cell>5,025,940</cell></row><row><cell>Worm-excluded</cell><cell>451,489</cell><cell>19,433</cell><cell>453,703</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>Detecting changes in the number of flows of size 1 in trace "COS".</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Here we minimized the overlap with the motivation provided in<ref type="bibr" target="#b0">[1]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>In practice, the raw data collected at the streaming module can also be summarized and paged to persistent storage, where it can be stored till subsequent retrieval and estima-</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>tion.<ref type="bibr" target="#b4">5</ref> Our design does not place any constraints on the definition</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_3"><p>EM algorithms in general can only guarantee to converge to a local maximum<ref type="bibr" target="#b14">[15]</ref>, while MLE often refers to the global maximum. With this understanding, we will omit the word local from subsequent discussions of MLE using EM.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_4"><p>We experimented on many other NLANR traces, which yield similar results as reported in this paper.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_5"><p>The same sampling rate is used in<ref type="bibr" target="#b0">[1]</ref> in the same context. Similar sampling rates are also adopted by large commercial ISPs due to the high volume of Internet traffic.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGMENTS</head><p>This work is supported in part by NSF ITR Grant ANI-0113933 and NSF CAREER Award ANI-0238315. We would like to thank Dr. Nick Duffield for generously giving us access to the Internet traffic traces and results from his work on sampling-based estimation <ref type="bibr" target="#b0">[1]</ref>, which enabled our comparison of the two approaches. We also thank Dr. Oliver Spatscheck for providing us the Internet packet header traces collected by Gigascope servers. Finally, we thank the anonymous reviewers whose insightful comments have helped improve the quality of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Estimating flow distributions from sampled flow statistics</title>
		<author>
			<persName><forename type="first">N</forename><surname>Duffield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thorup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Inverting sampled traffic</title>
		<author>
			<persName><forename type="first">N</forename><surname>Hohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Veitch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Internet Measurement Conference</title>
		<meeting>ACM SIGCOMM Internet Measurement Conference</meeting>
		<imprint>
			<date type="published" when="2003-10">Oct. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Charging from sampled network usage</title>
		<author>
			<persName><forename type="first">N</forename><surname>Duffield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thorup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Internet Measurement Workshop</title>
		<meeting>ACM SIGCOMM Internet Measurement Workshop</meeting>
		<imprint>
			<date type="published" when="2001-11">Nov. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Properties and prediction of flow statistics from sampled packet streams</title>
		<author>
			<persName><forename type="first">N</forename><surname>Duffield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thorup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Internet Measurement Workshop</title>
		<meeting>ACM SIGCOMM Internet Measurement Workshop</meeting>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">New directions in traffic measurement and accounting</title>
		<author>
			<persName><forename type="first">C</forename><surname>Estan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Bitmap algorithms for counting active flows on high speed links</title>
		<author>
			<persName><forename type="first">C</forename><surname>Estan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Internet Measurement Conference</title>
		<meeting>ACM SIGCOMM Internet Measurement Conference</meeting>
		<imprint>
			<date type="published" when="2003-10">Oct. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Traffic matrix estimation: Existing techniques and new directions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Medina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Taft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Salamatian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhattacharyyaand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Diot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Iterative bayesian estimation of network traffic matrices in the case of bursty flows</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vaton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gravey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Internet Measurement Workshop</title>
		<meeting>ACM SIGCOMM Internet Measurement Workshop</meeting>
		<imprint>
			<date type="published" when="2002-11">Nov. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast accurate computation of large-scale IP traffic matrices from link loads</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roughan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Duffield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMETRICS</title>
		<meeting>ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An information-theoretic approach to traffic matrix estimation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roughan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Donoho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Data streams: Algorithms and applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<ptr target="http://athos.rutgers.edu/muthu/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient implementation of a statistics counter architecture</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ramabhadran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMETRICS</title>
		<meeting>ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient hardware hashing functions for high performance computers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ramakrishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bahcekapili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Computers</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1378" to="1381" />
			<date type="published" when="1997-12">Dec. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A linear-time probabilistic counting algorithm for database applications</title>
		<author>
			<persName><forename type="first">K</forename><surname>Whang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Vander-Zanden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Maximum likelihood from incomplete data via the em algorithm</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dempster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Laird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rubin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Statistical Society, Series B</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="38" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Space-Code Bloom Filter for Efficient per-flow Traffic Measurement</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Spatschek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Infocom</title>
		<meeting>IEEE Infocom</meeting>
		<imprint>
			<date type="published" when="2004-03">Mar. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Gigascope: a stream database for network applications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cranor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Spatscheck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD 2003</title>
		<meeting>SIGMOD 2003</meeting>
		<imprint>
			<date type="published" when="2003-06">Jun 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The spread of the sapphire/slammer worm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Moor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Shannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staniford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Weaver</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>CAIDA</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sketch-based change detection: methods, evaluation, and applications</title>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Internet Measurement Conference</title>
		<meeting>ACM SIGCOMM Internet Measurement Conference</meeting>
		<imprint>
			<date type="published" when="2003-10">Oct. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Space/time trade-offs in hash coding with allowable errors</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="422" to="426" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Summary cache: a scalable wide-area Web cache sharing protocol</title>
		<author>
			<persName><forename type="first">L</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Broder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="281" to="293" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
