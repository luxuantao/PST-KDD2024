<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Open Architecture for Developing Processor Features</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Siyao</forename><surname>Zhao</surname></persName>
							<email>sy2zhao@uwaterloo.ca</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Waterloo</orgName>
								<address>
									<settlement>Waterloo</settlement>
									<region>Ontario</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Open Architecture for Developing Processor Features</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3593856.3595915</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T08:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In recent years, an increasing number of hardware devices started providing programming interfaces to developers such as smart NICs. Processor vendors use microcode to extend processors' features such as Intel SGX and VT-x. This enables processor architects to quickly evolve processor designs and features. However, modern processors still lack general programmability as microcode is inaccessible to system developers. Developers still cannot define custom processor features. We argue that processors should expose this capability to developers, which enables new operating system and application designs.</p><p>We propose Metal, a novel open architecture that enables system developers to define custom instructions with microcode level overhead. We implement a prototype of Metal on a 5-stage pipelined RISC processor with minimal additional hardware resources. We demonstrate Metal's capability by building a variety of architectural extensions such as user defined privilege levels. We also discuss other potential applications and future directions for Metal.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>and flexibility. For example, the Linux kernel offers eBPF <ref type="bibr" target="#b3">[4]</ref> to modify system behavior without needing to write kernel modules. Smart NICs and storage devices enable custom computation inline with network and storage processing before reaching the OS. Programmable P4 switches <ref type="bibr" target="#b1">[2]</ref> expand programmability outside the host to process and manipulate network traffic flows.</p><p>In recent years, the number of extensions to popular instruction set architectures (ISA) has skyrocketed. Most of these extensions are implemented largely in microcode <ref type="bibr" target="#b11">[13]</ref>, e.g., Intel SGX and VT-x.</p><p>Unfortunately, processors have seen little effort to enable programmability for developers. Processor vendors commonly use microcode to implement processor programmability, which is complex even for processor architects. Higher level intermediate instruction encodings, such as Intel Xu-Code, enable processor architects to write microcode almost as efficiently as native assembly. However, processor vendors have yet to open up this programmability to developers.</p><p>The growing popularity of microcode as a way to deploy processor features raises security concerns <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b13">15]</ref>. Due to the lack of transparency, microcode auditing is difficult, which leads to security through obscurity. Recent works <ref type="bibr" target="#b30">[32,</ref><ref type="bibr" target="#b31">33]</ref> manage to reverse engineer x86 microcode and inject vulnerabilities. Implementing complex software concepts, such as virtualization, in low level microcode also increases the probability of introducing security vulnerabilities.</p><p>We group microcode into two categories: horizontal and vertical. Horizontal microcode is relatively simple and decodes into a few micro-ops that expose an optimized hardware function. However, implementing complex architectural features using horizontal microcode is difficult. To address the complexity, processor vendors develop intermediate instruction encodings called vertical microcode, such as Intel XuCode <ref type="bibr" target="#b0">[1]</ref>, IBM's Millicode <ref type="bibr" target="#b22">[24]</ref> and Alpha's PALcode <ref type="bibr" target="#b17">[19]</ref>. Vertical microcode is much closer to the processor's native assembly and often thousands of micro-ops long. This simplifies complex architectural feature development.</p><p>To promote the evolution of processor architectures and new operating system designs, we propose that processor vendors should provide an open architecture to system developers to define new instructions. This enables developers to build new architectural features and applications. Implementing this open architecture should involve relatively simple logic and a few basic hardware components.</p><p>This paper presents Metal, a processor hardware extension that enables developers to rapidly evolve the processor's architecture through software instead of hardware. Metal offers a vertical microcode like programming interface consisting of the native instruction set plus a few Metal specific instructions. To achieve microcode level overhead, we dedicate a RAM for storing Metal code which is collocated with the processor's instruction fetch unit.</p><p>Unlike other intermediate instruction encodings discussed above, Metal enables not only processor architects but also system developers to create new architectural extensions. Processors expose the fundamental building blocks, which Metal uses to create higher level extensions and abstractions. OSes can share a common set of extensions across different architectures to enhance compatibility and portability.</p><p>We provide a proof-of-concept Metal implementation on a 5-stage pipelined RISC processor, adding 14% more logic cells. Our processor exposes various architectural features to Metal, such as direct physical memory access and instruction interception. This enables us to implement high level architectural extensions, such as user defined privilege levels and custom page tables. We also discuss other potential Metal applications, such as virtualization and security enclaves.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DESIGN</head><p>Metal is an open architecture that exposes underlying microarchitectural features to system developers. Developers can use Metal to add architectural extensions to processors such as user defined privilege levels and custom page tables. Metal introduces a new privileged operation mode Metal mode and a microcode-like programming interface mcode, which developers use to program custom extensions. Unlike microcode, mcode consists of the host processor's native assembly plus several Metal specific instructions.</p><p>In Metal mode, the processor executes mcode and accesses internal architectural features. caches as the locality of the RAM already offers cache-like access speed. This also prevents side channels on the RAM. We develop a proof-of-concept implementation of Metal on a 5-stage pipelined RISC processor. Figure <ref type="figure">1</ref> shows the high level workflow and additional components. We add a small RAM (MRAM) to store up to 64 mroutines and a Metal register file (MReg.) containing 32 Metal exclusive registers m0-m31 to store Metal's internal state. menter is not a privileged instruction in the traditional sense as Metal does not define privilege levels besides normal mode vs. Metal mode. Developers can freely define custom privilege levels that suit their use cases by checking callers' privilege levels in mroutines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Metal Instruction Extension</head><p>Upon entering Metal mode, the processor gains full access to architectural features and the rest of Metal instructions. Applications use rmr and wmr to read and write Metal registers. mexit exits Metal mode and resumes the execution from the stored address in Metal register m31.</p><p>Metal provides mld and mst instructions to load and store from MRAM's data segment. The data segment holds mroutine private data used for bookkeeping, e.g., the pointer to the page table structure for custom page tables.</p><p>Metal mroutine programming resembles embedded system development. To avoid allocation failures, developers must statically allocate resources including Metal registers used across invocations or the MRAM data segment. Metal mroutines are non-interruptible for simplicity and to allow Metal to implement interrupt delivery mechanisms. Static allocation and non-interruptibility improve performance, security and reliability by eliminating potential resource exhaustion and simplifying mroutine verification.</p><p>Metal only defines a few new instructions and leaves the flexibility of exposing architectural features to the processor. Processors expose architectural features as either Metal instructions, control registers or memory mapped IO.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Fast Metal Mode Transition</head><p>Metal mode transitions must be fast to make extending the instruction set practical. Metal achieves low overhead in two ways. Critically, we collocate MRAM that stores mroutines with the processor's instruction fetch unit to achieve microcode level overhead.</p><p>We also optimize menter and mexit. When entering and exiting Metal mode, the processor replaces menter with the first instruction from the target mroutine during the decode stage. We stall instruction fetching to also replace mexit with the next instruction in the original stream. When returning to the application, Metal achieves virtually zero overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Exposing Architectural Features</head><p>A key feature of Metal is accessing low level architectural features through mroutines. In our implementation, the processor exposes the following architectural features to Metal that enable the example applications in Section 3. The processor exposes these features to Metal through instructions and memory mapped registers only available in Metal mode.</p><p>Access Interrupt and Exception Delivery. Our processor delegates all exception and interrupt delivery to Metal. We assign specific mroutines to handle interrupts and exceptions. This allows Metal to define custom privilege levels and deliver interrupts to any privilege level, e.g., user level interrupts.</p><p>Instruction Interception. Our implementation allows intercepting any instruction with an mroutine. For instance, developers can intercept loads and stores dynamically to implement transactional memory or patch an insecure instruction at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Hardware Resources</head><p>To estimate the hardware resources required to build Metal. We develop a proof-of-concept 5-stage pipelined RISC processor in Verilog with and without Metal. We synthesize our processor using the Yosys <ref type="bibr" target="#b6">[8]</ref> open source synthesis tool and the Synopsys <ref type="bibr" target="#b5">[7]</ref> standard cell library.</p><p>Table <ref type="table" target="#tab_2">2</ref> shows the hardware resources in terms of wires and cells used by our processor with and without Metal. In our implementation, Metal only consumes 14% more cells and 16% more wires. This serves as an upper bound of the required hardware resources as most modern processors have more complex pipelines with multiple issue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">APPLICATIONS</head><p>To demonstrate the capabilities of Metal, we developed multiple architectural extensions. This helps us understand what systems can benefit from Metal's encapsulation of architectural features and the ability to intercept instructions with low overhead. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">User Defined Privilege Levels</head><p>Metal enables new OS privilege separation models beyond the basic user mode vs. kernel mode distinction. Developers can implement multiple privilege levels with defined transitions using mroutines.</p><p>To demonstrate this, we first implement a traditional kerneluser privilege model in Metal. We provide two mroutines, kenter and kexit, which transition from userspace to the kernel and back. We reserve the Metal register m0 to hold the current privilege level. All mroutine calls that access or modify privileged resources, e.g., the TLB, are protected by a privilege check that triggers an exception if violated.</p><p>The assembly of both mroutines is shown in Listing 2. kenter takes a system call entry number as the parameter in GPR a0. It updates the current privilege level in m0, computes the syscall entry point, and jumps to the kernel system call entry point. We use temporary register t0, as defined in the ABI, to compute the entry point and save the userspace return address in register ra. kexit loads the address stored in ra and calls mexit to return to userspace.</p><p>In general, processor privilege switching involves setting architectural state and returning control to the target entry point regardless of the number of privilege levels. All privileged mroutines, such as interrupt handlers, in our traditional kernel-user model should check or set Metal register m0 and raise an exception in case of privilege violation.</p><p>In-process Isolation. Alternatively, applications can use multiple privilege levels internally to implement in-process isolation to protect sensitive data. For example, isolating sensitive cryptographic keys in OpenSSL from the rest of the application. On modern processors, in-process isolation usually requires a form of control flow integrity (CFI) <ref type="bibr" target="#b43">[45]</ref> to protect the transition code. However, recent works show that CFI is inherently unsafe <ref type="bibr" target="#b18">[20]</ref>. Metal enables developers to safely encapsulate the transition code without CFI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Custom Page Tables</head><p>OSes can implement custom memory management data structures with Metal. The Linux kernel team has pressured multiple processor vendors to implement radix tree based page tables similar to x86. This comes at the cost of restricting multiple page size support into fewer buckets, leading to poor performance <ref type="bibr" target="#b38">[40]</ref>. With Metal, OSes can implement custom memory management data structures in the page fault exception handling mroutine.</p><p>Critically, the proximity of MRAM to the instruction fetch unit enables fast exception dispatching with costs similar to microcode implementations. This greatly closes the performance gap between hardware and software managed TLBs with the flexibility of user defined data structures.</p><p>We implement a radix tree based page table using direct physical memory access and exception handling provided by the processor. In a few lines of assembly, we walk an x86style radix tree on page fault. We populate the processor's TLB mappings from the page table. If the page is not present or the access violates the page protection, we deliver the exception to the OS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Transactional Memory</head><p>We also implemented a proof-of-concept transactional memory extension based on software transactional memory (STM) techniques. We created several new mroutines: tstart starts a transaction, tabort aborts the transaction, and tcommit commits the transaction. We intercept all memory access instructions within a transaction and invoke tread and twrite instead, which perform and record the memory accesses. Upon tcommit, all accessed memory addresses within the transaction are inspected for conflict.</p><p>The benefit of using Metal is that neither compilers nor developers need to replace loads and stores with calls into an STM library. Instead, Metal turns on and off interception of loads and stores at runtime when it needs to track memory accesses for transactional memory. Our implementation is under 100 instructions and closely resembles TL2 <ref type="bibr" target="#b16">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">User Level Interrupt</head><p>User level interrupt is a new processor feature that allows unprivileged userspace processes to handle hardware interrupts and perform userspace IO. Intel plans to support user level interrupt in their next generation processors <ref type="bibr">[5]</ref>. User level interrupt is especially useful for high performance kernel bypass libraries such as DPDK <ref type="bibr" target="#b2">[3]</ref> and SPDK <ref type="bibr" target="#b4">[6]</ref>.</p><p>Currently, both DPDK and SPDK interact with NICs or storage devices by polling in user mode, which consumes all cores used by the application. With user level interrupt, such applications only need to be notified via interrupts when data is available from underlying devices, reducing CPU occupancy and power consumption.</p><p>Metal supports user level interrupt by handling the processor's interrupt delivery. When an interrupt occurs, Metal invokes specific mroutines to optionally redirect the interrupt to processes running at lower privilege levels. The mroutines ensure that the target process to receive the interrupt is currently running on the core and interrupt the process without changing the privilege level. Developers control whether a specific privilege level is allowed to process interrupts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Other Applications</head><p>Metal is a great platform to develop architectural extensions by combining and encapsulating architectural features. We present a few potential architectural extensions including capabilities, security enclaves, virtualization and control flow protection, which are often implemented in microcode. We also discuss nesting Metal to accommodate multitenancy.</p><p>Hardware Capabilities. Capability based security is not a new idea. The IBM System/38 <ref type="bibr" target="#b23">[25]</ref> and Intel iAPX 432 processors <ref type="bibr" target="#b33">[35]</ref> implement capabilities in hardware using microcode. The CHERI processor <ref type="bibr" target="#b44">[46]</ref> implements a capability based security model with a coprocessor. Similar to prior systems, Metal can support capabilities by writing mroutines to create and manipulate domains and capabilities.</p><p>Security Enclaves. Security enclaves offer code and data integrity. Intel SGX <ref type="bibr" target="#b12">[14]</ref>, AMD Secure Encrypted Virtualization (SEV) <ref type="bibr" target="#b27">[29]</ref>, and ARM TrustZone <ref type="bibr" target="#b9">[11]</ref> all implement enclaves using both hardware and microcode. Sanctum <ref type="bibr" target="#b13">[15]</ref> and Sanctorum <ref type="bibr" target="#b32">[34]</ref> offer software security enclaves with little hardware support. PrivateCore, a security startup, builds hypervisor-based memory encryption that offers similar functionality to AMD SEV without hardware support <ref type="bibr" target="#b40">[42]</ref>.</p><p>Metal's flexibility in defining privilege levels enables developers to implement enclave extensions. Developers create a trusted execution layer that runs at a higher privilege level than the host OS. After Metal loads and verifies an enclave, the enclave runs in the trusted execution layer which the host OS cannot access.</p><p>Virtualization. Virtualization consolidates multiple workloads into a single machine. Virtualization was first introduced in the IBM VM/370 <ref type="bibr" target="#b14">[16]</ref> and implemented in numerous other architectures including VAX <ref type="bibr" target="#b21">[23]</ref>, Alpha <ref type="bibr" target="#b28">[30]</ref>, POWER <ref type="bibr" target="#b24">[26]</ref>, Intel VT-x <ref type="bibr" target="#b25">[27]</ref>, AMD SVM <ref type="bibr" target="#b8">[10]</ref>, ARM <ref type="bibr" target="#b10">[12]</ref>, SPARC <ref type="bibr" target="#b42">[44]</ref>, and MIPS <ref type="bibr" target="#b37">[39]</ref>. Most architectures implement virtualization in microcode. For example, the IBM zSeries virtualization extensions are implemented mostly in Millicode <ref type="bibr" target="#b22">[24]</ref>, and the Alpha hypervisor is built exclusively using PALcode <ref type="bibr" target="#b28">[30]</ref>.</p><p>Developers can use Metal to implement virtualization. For example, Metal allows hypervisors to implement nested page tables. Multiple privilege rings also provide better hostguest isolation. Privileged instructions can be intercepted and trapped by Metal for proper handling.</p><p>Control Flow Protection. Metal can offer similar application control flow protection as existing techniques such as shadow stacks <ref type="bibr" target="#b39">[41]</ref> and control flow integrity <ref type="bibr" target="#b7">[9]</ref>. Metal eliminates the compiler dependency for protecting key materials from existing CFI systems such as cryptographic control flow integrity <ref type="bibr" target="#b36">[38]</ref>. Instead, applications can store cryptographic keys inside Metal registers or MRAM.</p><p>Nested Metal. Modern data centers often host multiple applications in separate VMs on a single machine. Metal should allow VMMs, OSes and applications to define their own mroutines for performance and security. For example, defining VM abstractions for a VMM and in-process isolation for a TLS enabled webserver.</p><p>The challenge is composing mroutines from different layers without undermining the integrity of other layers. For example, a higher guest OS layer can define custom memory management, but should not affect the lower VMM layer's memory management. Furthermore, the layered design also requires that mroutines are reentrant as instruction intercept can occur during mroutine execution. Reentrancy increases the difficulty of mroutine development and verification.</p><p>We are actively exploring nested Metal that supports multiple layers of mroutines where mroutines belonging to a layer can be swapped during a context switch. Interrupts propagate from lower to higher layers so that VMMs and OS kernels can decide which VM or application the interrupt belongs to. Instruction interception proceeds in reverse, with higher layers intercepting the instruction first so that applications can customize individual intercept behavior. The intercept propagates downward through layers that intercept the same instruction, which only occurs when the higher layer's intercept handling mroutine reuses the instruction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>Vendor Incentives. Metal provides an open architecture to processor architects and system developers to rapidly develop and evolve processor features. Existing processor vendors do not document microcode to protect intellectual property (IP). Metal proposes using vertical microcode in the native instruction set to separate IP concerns and provide a new layer for innovation.</p><p>We propose that processor vendors should provide developers with fundamental architectural features and delegate higher level abstractions and encapsulation to developers via Metal. Metal offers three major advantages to vendors.</p><p>First, vendors can implement architectural features in microcode to protect intellectual property while offering the flexibility of Metal. Metal does not expose internal details of the processor's microarchitecture.</p><p>Second, processor vendors differentiate themselves by developing new performance enhancing architectural features. For example, software implementations of memory encryption, such as PrivateCore's, suffer from high CPU overhead. Processor vendors then introduce hardware memory encryption, such as Intel SGX, to significantly accelerate the process.</p><p>Third, delegating abstraction and encapsulation to Metal accelerates the adoption and evolution of new technologies. Metal enables system developers to encapsulate an architectural feature, e.g., memory encryption, into higher level extensions such as security enclaves and encrypted virtual machines based on end user needs.</p><p>Intel is replacing SGX with Trust Domain Extensions (TDX) <ref type="bibr" target="#b26">[28]</ref> that resembles AMD SEV. Had Intel and AMD instead offered memory encryption as an architectural feature, system developers could have iterated on high level abstractions like SGX and TDX more rapidly.</p><p>Security. Currently, Metal disables interrupts in mroutines as interrupts complicate development and verification. Developers must consider the consequences of interrupts occurring at any instruction and mroutine reentrancy. For example, VMWare spent years making the world switch between the VMM and the ESX kernel safe to non-maskable interrupts (NMI), because the code had to handle interrupts while reconfiguring all processor state. Additionally, Intel and AMD recently announced solutions to problems with interrupt and exception handling dating back decades <ref type="bibr" target="#b34">[36]</ref>.</p><p>Recent processors suffer from timing and speculation side channel attacks such as Spectre <ref type="bibr" target="#b29">[31]</ref> and Meltdown <ref type="bibr" target="#b35">[37]</ref>. Metal does not cache MReg. or MRAM and shifts the responsibility to developers for main memory accesses. For sensitive mroutines, developers should insert speculation barriers and cache control instructions to eliminate side channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATED WORK</head><p>Processor architects commonly use microcode to simplify instruction decoding and support complex instructions consisting of hundreds to thousands of micro-ops.</p><p>Processor architects often find microcode limiting how quickly they can introduce and develop features. At least three intermediate instruction sets have been developed including Millicode <ref type="bibr" target="#b22">[24]</ref> on the IBM zSeries, PAL code <ref type="bibr" target="#b17">[19]</ref> on the Alpha and XuCode <ref type="bibr" target="#b0">[1]</ref> on Intel's recent x86 processors.</p><p>IBM uses Millicode <ref type="bibr" target="#b22">[24]</ref> to implement complex instructions and achieve backward compatibility. For example, the zSeries processors have two types of transactional memory. First, a hardware transactional memory that supports small transactions of just a few cache lines. Second, a hybrid software transactional memory written in Millicode that supports large transactions. Virtualization instructions and other complex ISA features are also written in Millicode.</p><p>Intel develops XuCode <ref type="bibr" target="#b0">[1]</ref> as an intermediate microcode to aid their developers in implementing Intel SGX <ref type="bibr" target="#b12">[14]</ref> features. XuCode is tightly coupled with SGX, running in the SGX reserved memory region. Rather than writing complex microcode, SGX developers implement features in a higher level instruction set.</p><p>Finally, Alpha PALcode <ref type="bibr" target="#b17">[19]</ref> is unusual because it is written in native assembly, but still serves the same purpose as other intermediate microcodes. PALcode bridges the architectural features with the OS and firmware through an API. DEC supplies two PALcode implementations to support running Unix vs. VMS and Windows NT. Alpha implements its privilege model through PALcode, which allows the processor to support two rings on Unix and four rings on VMS. In many ways, PALcode is the inspiration for Metal. One major difference is that PALcode resides in main memory. A no-op PALcode call takes approximately 18 cycles on the Alpha <ref type="bibr" target="#b41">[43]</ref>, making it impractical to encapsulate or emulate low latency instructions, unlike Metal.</p><p>Historically, many architectures have provided access to their microcode. Despite the difficulties of microcode programming, this open architecture enables research and development including optimizing Prolog on the VAX <ref type="bibr" target="#b19">[21]</ref> and improving game performance on the Xerox Alto <ref type="bibr" target="#b15">[17]</ref>.</p><p>Recently, researchers have reverse engineered newer processors. One group of researchers reverse engineered the AMD K8 and K10 microcode <ref type="bibr" target="#b31">[33]</ref>, and even created benign and malicious microcode updates <ref type="bibr" target="#b30">[32]</ref>. Several researchers extracted the entire Intel microcode ROM and the keys used to encrypt microcode updates <ref type="bibr" target="#b20">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We propose that processor vendors implement an open architecture for developing architectural extensions. Vertical microcode, such as Intel's XuCode, IBM's Millicode and Alpha's PALcode, proves the viability of developing architectural extensions in intermediate instruction encodings. Metal gains inspiration from vertical microcode and offers a microcodelike programming interface for system developers and researchers to develop new architectural extensions. With compiler support, it can be practical to write hardware features in high level languages such as C.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1 #Figure 2 :</head><label>12</label><figDesc>Figure 2: The assembly of system call entry (kenter) and exit (kexit) mroutines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : New Metal instructions. Applications execut- ing in normal mode invoke menter to enter Metal mode. The rest are only available in Metal mode.</head><label>1</label><figDesc></figDesc><table><row><cell>At boot time, Metal loads</cell></row><row><cell>a collection of mcode subroutines called mroutines, which</cell></row><row><cell>extend the architecture's instruction set. Metal assigns each</cell></row><row><cell>mroutine with a unique entry number, which serves as entry</cell></row><row><cell>points into Metal mode.</cell></row><row><cell>Critically, Metal stores mroutines in a RAM collocated</cell></row><row><cell>with the processor's instruction fetch unit to offer microcode</cell></row><row><cell>level overhead. The low overhead enables the development</cell></row><row><cell>of latency sensitive extensions that are otherwise only pos-</cell></row><row><cell>sible with microcode. The RAM partitions code and data</cell></row><row><cell>into separate segments, which hold mroutines and mroutine</cell></row><row><cell>private data. Accesses to the RAM do not alter processor</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell>lists the new Metal instructions. Applications exe-</cell></row><row><cell>cuting in normal mode call menter with an mroutine entry</cell></row><row><cell>number to enter Metal mode. Once in Metal mode, the pro-</cell></row><row><cell>cessor stores the caller's return address into Metal register</cell></row><row><cell>m31 and executes the corresponding mroutine.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>to Physical Memory. Modern processors manage memory through paging. The memory management unit (MMU) translates virtual pages to physical pages via page Hardware resources for adding Metal to our 5-Stage pipelined processor. The table provides an upper bound as modern processors are more complex.tables. However, there is no mechanism to access unmapped physical memory. Our implementation allows mroutines to bypass paging and access physical memory in Metal mode. This enables developers to implement custom page tables.Page Keys and Address Space IDs. Page keys provide an extra level of indirection for page permissions to accelerate batch permission changes. Address space IDs allow TLBs to cache multiple address spaces. Our processor exposes TLB modification instructions, and it supports page keys and address space IDs. This allows Metal to create arbitrary execution contexts and change page permissions rapidly.</figDesc><table><row><cell></cell><cell>Baseline</cell><cell cols="2">Metal %Change</cell></row><row><cell cols="3">Number of Wires 170,264 197,705</cell><cell>16.1%</cell></row><row><cell>Number of Cells</cell><cell cols="2">180,546 206,384</cell><cell>14.3%</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We thank <rs type="person">Emil Tsalapatis</rs> for the valuable discussion towards the development of Metal. We thank <rs type="person">Fatemeh Hassani</rs> for her master's thesis work on prototyping Metal in Verilog. We also thank the committee for their valuable feedback.</p></div>
			</div>			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/secure-coding/xucode-implementing-complex-instruction-flows.html" />
		<title level="m">XuCode: An Innovative Technology for Implementing Complex Instruction Flows</title>
		<imprint>
			<date type="published" when="2021-05">May 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">P4 Open Networking Foundation</orgName>
		</author>
		<ptr target="https://opennetworking.org/p4/" />
		<imprint>
			<date type="published" when="2022-04">Apr 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="https://www.dpdk.org/" />
		<title level="m">Data Plane Development Kit</title>
		<imprint>
			<date type="published" when="2023-02">Feb 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="https://ebpf.io/" />
		<title level="m">eBPF -Introduction, tutorials and community resources</title>
		<imprint>
			<date type="published" when="2023-02">Feb 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="https://spdk.io/" />
		<title level="m">Storage Performance Development Kit</title>
		<imprint>
			<date type="published" when="2023-01">Jan 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="https://www.synopsys.com/dw/ipdir.php?ds=dwc_standard_cell" />
		<title level="m">Synopsys Standard Cell Libraries</title>
		<imprint>
			<date type="published" when="2023-02">Feb 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="https://yosyshq.net/yosys/about.html" />
		<title level="m">Yosys Open SYnthesis Suite</title>
		<imprint>
			<date type="published" when="2023-02">Feb 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Control-Flow Integrity</title>
		<author>
			<persName><forename type="first">Mart?n</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihai</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">?lfar</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jay</forename><surname>Ligatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM Conference on Computer and Communications Security, CCS &apos;05</title>
		<meeting>the 12th ACM Conference on Computer and Communications Security, CCS &apos;05<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="340" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Secure Virtual Machine Architecture Reference Manual</title>
		<imprint>
			<date type="published" when="2005-12">December 2005</date>
			<publisher>Advanced Micro Devices, Inc</publisher>
			<biblScope unit="volume">33047</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<author>
			<persName><forename type="first">Thaynara</forename><surname>Alves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Don</forename><surname>Felton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Trustzone: Integrated Hardware and Software Security</title>
		<imprint>
			<date type="published" when="2004-01">January 2004</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="18" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Arm Architecture Reference Manual for A-profile architecture</title>
		<author>
			<persName><forename type="first">Arm</forename><surname>Limited</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2023">042523. April 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hardware Is the New Software</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Baumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Workshop on Hot Topics in Operating Systems</title>
		<meeting>the 16th Workshop on Hot Topics in Operating Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="132" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Intel SGX explained</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Costan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Sanctum: Minimal Hardware Extensions for Strong Software Isolation</title>
		<author>
			<persName><forename type="first">Ilia</forename><surname>Victor Costan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivas</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th USENIX Security Symposium (USENIX Security 16)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016-08">August 2016</date>
			<biblScope unit="page" from="857" to="874" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The Origin of the VM/370 Time-Sharing System</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Creasy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. Res. Dev</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="483" to="490" />
			<date type="published" when="1981-09">sep 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">Josh</forename><surname>Dersch</surname></persName>
		</author>
		<ptr target="https://engblg.livingcomputers.org/index.php/2017/06/23/the-xerox-alto-part-2-microcode/" />
		<title level="m">The Xerox Alto Part 2: Microcode</title>
		<imprint>
			<date type="published" when="2017-06">June 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Transactional Locking II</title>
		<author>
			<persName><forename type="first">Dave</forename><surname>Dice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ori</forename><surname>Shalev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nir</forename><surname>Shavit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Distributed Computing, DISC&apos;06</title>
		<meeting>the 20th International Conference on Distributed Computing, DISC&apos;06<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="194" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">PALcode for Alpha Microprocessors: System Design Guide</title>
		<imprint>
			<date type="published" when="1996-05">May 1996</date>
		</imprint>
		<respStmt>
			<orgName>Digital Equipment Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity</title>
		<author>
			<persName><forename type="first">Isaac</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fan</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulziibayar</forename><surname>Otgonbaatar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Shrobe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hamed</forename><surname>Okhravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stelios</forename><surname>Sidiroglou-Douskos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15</title>
		<meeting>the 22nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="901" to="913" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Implementation of Prolog via VAX 8600 Microcode</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Melvin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Annual Workshop on Microprogramming</title>
		<meeting>the 19th Annual Workshop on Microprogramming<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="68" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">In a first, researchers extract secret key used to encrypt Intel CPU code</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Goodin</surname></persName>
		</author>
		<ptr target="https://arstechnica.com/gadgets/2020/10/in-a-first-researchers-extract-secret-key-used-to-encrypt-intel-cpu-code/" />
		<imprint>
			<date type="published" when="2020-10">Oct 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Virtualizing the VAX Architecture</title>
		<author>
			<persName><forename type="first">Judith</forename><forename type="middle">S</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">T</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th Annual International Symposium on Computer Architecture, ISCA &apos;91</title>
		<meeting>the 18th Annual International Symposium on Computer Architecture, ISCA &apos;91<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="380" to="389" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Millicode in an IBM zSeries processor</title>
		<author>
			<persName><forename type="first">Lisa</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farrell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="425" to="434" />
			<date type="published" when="2004-06">06 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">IBM System/38 Support for Capability-Based Addressing</title>
		<author>
			<persName><forename type="first">Merle</forename><forename type="middle">E</forename><surname>Houdek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><forename type="middle">G</forename><surname>Soltis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roy</forename><forename type="middle">L</forename><surname>Hoffman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Annual Symposium on Computer Architecture, ISCA &apos;81</title>
		<meeting>the 8th Annual Symposium on Computer Architecture, ISCA &apos;81<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="341" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">PowerISA Version 3.0 B</title>
		<imprint>
			<date type="published" when="2017-03">March 2017</date>
		</imprint>
		<respStmt>
			<orgName>IBM Systems and Technology Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Intel 64 and IA-32 Architectures Software Developer&apos;s Manual</title>
	</analytic>
	<monogr>
		<title level="m">Instruction Set Reference, A-Z(325383-079US)</title>
		<meeting><address><addrLine>2A, 2B, 2C, &amp; 2D)</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2023-03">March 2023</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
		<respStmt>
			<orgName>Intel Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Intel Trust Domain Extensions</title>
		<imprint>
			<date type="published" when="2023-02">February 2023</date>
		</imprint>
		<respStmt>
			<orgName>Intel Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">AMD Memory Encryption</title>
		<author>
			<persName><forename type="first">David</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Powell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Woller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>White paper</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Performance and Security Lessons Learned from Virtualizing the Alpha Processor</title>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">A</forename><surname>Karger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07</title>
		<meeting>the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="392" to="401" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Spectre Attacks: Exploiting Speculative Execution</title>
		<author>
			<persName><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="93" to="101" />
			<date type="published" when="2020-06">jun 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An Exploratory Analysis of Microcode as a Building Block for System Defenses</title>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Kollenda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Koppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Fyrbiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Kison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christof</forename><surname>Paar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;18</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1649" to="1666" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Reverse Engineering x86 Processor Microcode</title>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Koppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Kollenda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Fyrbiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Kison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christof</forename><surname>Paar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th USENIX Security Symposium (USENIX Security 17)</title>
		<meeting><address><addrLine>Vancouver, BC</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017-08">August 2017</date>
			<biblScope unit="page" from="1163" to="1180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Sanctorum: A lightweight security monitor for secure enclaves</title>
		<author>
			<persName><forename type="first">Ilia</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyle</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jules</forename><surname>Drean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dayeol</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanovi?</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1142" to="1147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Capability-based Computer Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><surname>Levy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Digital Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<ptr target="https://www.realworldtech.com/forum/?threadid=200812&amp;curpostid=200822" />
		<title level="m">Linus Torvalds. x86 -why unite when you can fragment?</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Meltdown: Reading Kernel Memory from User Space</title>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Hamburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium (USENIX Security 18)</title>
		<meeting><address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018-08">August 2018</date>
			<biblScope unit="page" from="973" to="990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">CCFI: Cryptographically Enforced Control Flow Integrity</title>
		<author>
			<persName><forename type="first">Ali</forename><surname>Jose Mashtizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Bittau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mazi?res</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15</title>
		<meeting>the 22nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="941" to="951" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">MIPS64 Architecture for Programmers. Volume IV-I: Virtualization Module of the MIPS64 Architecture</title>
		<author>
			<persName><surname>Mips Tech</surname></persName>
		</author>
		<author>
			<persName><surname>Llc</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-12">December 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Practical, Transparent Operating System Support for Superpages</title>
		<author>
			<persName><forename type="first">Juan</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sitaram</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Cox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Symposium on Operating Systems Design and Implementation (Copyright Restrictions Prevent ACM from Being Able to Make the PDFs for This Conference Available for Downloading), OSDI &apos;02</title>
		<meeting>the 5th Symposium on Operating Systems Design and Implementation (Copyright Restrictions Prevent ACM from Being Able to Make the PDFs for This Conference Available for Downloading), OSDI &apos;02<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="89" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">SmashGuard: A Hardware Solution to Prevent Security Attacks on the Function Return Address</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Hilmi Ozdoganoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carla</forename><forename type="middle">E</forename><surname>Vijaykumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">A</forename><surname>Brodley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankit</forename><surname>Kuperman</surname></persName>
		</author>
		<author>
			<persName><surname>Jalote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1271" to="1285" />
			<date type="published" when="2006-10">oct 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title/>
		<author>
			<persName><surname>Privatecore</surname></persName>
		</author>
		<author>
			<persName><surname>Privatecore</surname></persName>
		</author>
		<ptr target="https://privatecore.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">The L4 Microkernel on Alpha, Design and Implementation</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Sch?nberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-09">September 1996</date>
		</imprint>
		<respStmt>
			<orgName>University of Dresden</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">SPARC JPS2: Common Specification</title>
		<imprint>
			<date type="published" when="2003-09">September 2003</date>
			<publisher>Sun Microsystems, Inc and Fujitsu Limited</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">ERIM: Secure, Efficient in-Process Isolation with Protection Keys (MPK)</title>
		<author>
			<persName><forename type="first">Anjo</forename><surname>Vahldiek-Oberwagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eslam</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Nuno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Duarte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Sammler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deepak</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Conference on Security Symposium, SEC&apos;19</title>
		<meeting>the 28th USENIX Conference on Security Symposium, SEC&apos;19<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1221" to="1238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The CHERI Capability Model: Revisiting RISC in an Age of Risk</title>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><forename type="middle">W</forename><surname>Chisnall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brooks</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">G</forename><surname>Laurie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Norton</surname></persName>
		</author>
		<author>
			<persName><surname>Roe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 41st Annual International Symposium on Computer Architecuture, ISCA &apos;14</title>
		<meeting>eeding of the 41st Annual International Symposium on Computer Architecuture, ISCA &apos;14</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="457" to="468" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
