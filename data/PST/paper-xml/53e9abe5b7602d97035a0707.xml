<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EROS: a fast capability system £</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jonathan</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jonathan</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Farber</surname></persName>
							<email>farber@dsl.cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">EROS: a fast capability system £</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">54BA859C458CEA706372E2DC57400149</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>EROS is a capability-based operating system for commodity processors which uses a single level storage model. The single level store's persistence is transparent to applications. The performance consequences of support for transparent persistence and capability-based architectures are generally believed to be negative. Surprisingly, the basic operations of EROS (such as IPC) are generally comparable in cost to similar operations in conventional systems. This is demonstrated with a set of microbenchmark measurements of semantically similar operations in Linux.</p><p>The EROS system achieves its performance by coupling well-chosen abstract objects with caching techniques for those objects. The objects (processes, nodes, and pages) are well-supported by conventional hardware, reducing the overhead of capabilities. Software-managed caching techniques for these objects reduce the cost of persistence. The resulting performance suggests that composing protected subsystems may be less costly than commonly believed.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>EROS is a capability-based microkernel with a single-level storage model. The single-level store's persistence is transparent to applications. Storage allocation, scheduling, and fault handling policies are exported from the kernel to allow multiple operating environments and application customized resource management. To simplify security assurance, all code having either direct access to the hardware or the ability to directly transform the system's security state is collected in the kernel. Bottom-half device drivers and the single-level store are therefore implemented within the kernel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">History of EROS</head><p>EROS is the third implementation of the GNOSIS (later renamed KeyKOS) architecture <ref type="bibr" target="#b14">[15]</ref> created by TymShare, Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage, and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SOSP-17 12/1999 Kiawah Island, SC c 1999 ACM 1-58113-140-2/99/0012. . . $5.00 Inc. First deployed in 1982, the goal of GNOSIS was to support secure time sharing and controlled collaboration among mutually adversarial users. The first GNOSIS kernel (later renamed KeyKOS/370) was implemented in 370 assembler language, with application code in PL/1. This system ran VISA transaction processing and networking applications. In the late 1980s the kernel and selected components were reimplemented in C for the Motorola 88000 family (KeyKOS/88k). Development ceased in 1991 when the company closed. The EROS project started shortly thereafter as a clean-room reimplementation of the GNOSIS architecture in C++, and has since made minor enhancements to the architecture. EROS for the x86 may be obtained from the EROS web site <ref type="bibr" target="#b40">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Components and capabilities</head><p>Large-scale software architectures are evolving (e.g., CORBA), in which applications can be viewed as capability connected components. This suggests that the study of capability systems is of increasing importance, since by design, capability systems provide support for protected subsystems, non-hierarchical protection domains, and typed objects <ref type="bibr" target="#b25">[26]</ref>.</p><p>Experience with systems such as the IBM AS/400 <ref type="bibr" target="#b46">[47]</ref> (a.k.a. <ref type="bibr">System 38)</ref>, the Plessey System 250 <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b28">29]</ref>, and KeyKOS <ref type="bibr" target="#b21">[22]</ref> suggests that reliability and security can be improved at both application and system levels if objects are separated into distinct protected subsystems to provide both fault isolation and discretionary access control. Languagebased approaches to enforcing protected subsystems have proven difficult to implement <ref type="bibr" target="#b52">[54]</ref>, and require expensive conversion of existing applications to the new language. An OS-based solution, possibly augmented by language level mechanisms, is therefore preferable.</p><p>However, the desirable features of transparent persistence and capability-based protection are widely believed to have prohibitive performance. This belief is largely justified by experience. The performance issues of the i432 have been examined by Colwell <ref type="bibr" target="#b6">[7]</ref>, and those of Mach by Ford <ref type="bibr" target="#b13">[14]</ref>. While the IBM AS/400 <ref type="bibr" target="#b46">[47]</ref> (a.k.a. <ref type="bibr">System 38)</ref> has been a large-scale commercial success, its performance depends on an augmented processor instruction set and a tagged memory system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">EROS and what we show in this paper</head><p>This paper presents the EROS architecture, and describes an efficient reduction to practice of this architecture for a commodity processor family: Intel's Pentium <ref type="bibr" target="#b22">[23]</ref>. We discuss the impact of persistence on the system's design in both structure and complexity. The EROS design and implementation applies the architectural ideas of microkernels to obtain performance in a system that is secure, capability-based, and transparently persistent.</p><p>We evaluate the performance of the resulting system using microbenchmarks. While the microbenchmarks currently available for EROS do not support general conclusions about application performance, they suggest that EROS will achieve reasonable performance on end user applications. The results suggest that capabilities are a reasonable substrate for a high-performance, high-security system on commodity hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Capabilities</head><p>A capability is an unforgeable pair made up of an object identifier and a set of authorized operations (an interface) on that object <ref type="bibr" target="#b8">[9]</ref>. UNIX file descriptors <ref type="bibr" target="#b50">[51]</ref>, for example, are capabilities.</p><p>In a capability system, each process holds capabilities, and can perform those operations authorized by its capabilities. Security is assured by three properties:</p><p>1. capabilities are unforgeable and tamper proof, 2. processes are able to obtain capabilities only by using authorized interfaces, and 3. capabilities are only given to processes that are authorized to hold them.</p><p>A protection domain is the set of capabilities accessible to a subsystem. An essential idea of capability-based system design is that both applications and operating system should be divided into cleanly separated components, each of which resides in its own protection domain.</p><p>Subject to constraint by an external reference monitor (Figure <ref type="figure">1</ref>), capabilities may be transferred from one protection domain to another and may be written to objects in the persistent store. Access rights, in addition to data, can therefore be saved for use across instantiations of one or more programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Implications for persistence</head><p>When persistent objects are permitted to contain capabilities, they take on certain characteristics of file metadata. In conventional file systems, correct stabilization of files depends on the order of data and metadata writes: data must be written before the metadata that references it <ref type="bibr" target="#b17">[18]</ref>. Similarly, objects in a capability system must be written before the capabilities that reference those objects. Unlike a file system, however, the update dependency graph in a capability system is unconstrained (and potentially circular).</p><p>Plausible mechanisms to ensure a consistent system image in the store include application-managed transactions or some form of periodic consistent snapshot of the machine state. For reasons of simplicity and correctness, EROS uses a periodic checkpoint similar to the KeyKOS mechanism described by Landau <ref type="bibr" target="#b27">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Design challenges</head><p>There are five key challenges in architecting a capability system.</p><p>First, transferring control across protection domain boundaries is expensive unless great care is taken in implementing protected control transfers. By default, no access should be shared across such a boundary. In a conventional architecture, this requires that the preceding context (the TLB and cache contents) be made unreachable by means of hardware tagging, cache flush, or other hardwareenforced means of isolation. Strategies for performing efficient context switch have been developed <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32]</ref>, and we have applied these ideas for protection domain crossings and presented the results in <ref type="bibr" target="#b43">[44]</ref>.</p><p>Second, we would like a uniform protection mechanism for all system resources. Choosing primitive protected objects and access rights that reduce directly to the hardware with minimal overhead is critical. If too large a unit of protection (e.g., memory regions) is selected, as in Mach <ref type="bibr" target="#b0">[1]</ref>, software is required to translate this abstraction into something that the hardware can implement. If too small a unit of protection (e.g. words) is used, the hardware protection mechanisms cannot be used directly and protection must be realized by software emulation.</p><p>Third, a collection of system services must be identified that compose these primitive objects into higher level abstractions efficiently and securely.</p><p>Fourth, the system must ensure that a correct initial arrangement of entities and access relationships is achieved when the system starts up. In particular, the correctness of this arrangement must be maintained at the stable storage boundary. Many capability systems use conventional file systems protected by access control lists. In doing so they give up the security advantages of capabilities.</p><p>Finally, capability systems have difficulty with traceability and selective revocation: determining who has what access and removing a particular user's access to an object. To solve this problem, hybrid designs using both capabilities and access control lists have been proposed in <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr" target="#b24">[25]</ref>. In a pure capability system like EROS, this issue must be addressed by the reference monitor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Mandatory access controls</head><p>EROS provides a primitive mechanism for revoking access to objects. Both objects and their capabilities have a version number. If the version numbers do not match, the capability is invalid and conveys no authority. Mandatory access control (MAC) policies require a finer mechanism: one that pro-vides selective revocation and access traceability. The EROS constructor (Section 5.3) enforces a discretionary policy <ref type="bibr" target="#b45">[46]</ref> similar to Lampson's confinement policy <ref type="bibr" target="#b26">[27]</ref>. This policy allows secure reference monitors to be built at user level, as has been done in KeySafe <ref type="bibr" target="#b37">[38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>User-level Reference Monitor</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compartment</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sandbox</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Process</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kernel</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1. Components within compartments</head><p>The KeySafe design divides a secure system into protected compartments (Figure <ref type="figure">1</ref>). Communication between these compartments is mediated by a reference monitor, which inserts transparent forwarding objects in front of all capabilities that cross compartment boundaries. To rescind the access rights of a compartment, the reference monitor rescinds the forwarding object.</p><p>A particularly attractive aspect of the KeySafe design is that it allows straightforward revision of mandatory access policies. Appropriate mandatory access control policies depend on the objects controlled, and are therefore application dependent. The KeySafe design facilitates modification of the mandatory access controls as the system evolves.</p><p>Evaluators spent several months in 1986 examining KeyKOS/KeySAFE, and encouraged its submission for B2 evaluation <ref type="bibr">[53]</ref>. The B2 security requirements specifically cover both traceability and revocation, and the NCSC team felt that the KeySafe design was sound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The EROS kernel</head><p>The EROS architecture is divided into a kernel that implements a small number of primitive capability types: numbers, nodes, data pages, capability pages, processes, entry and resume capabilities, and a few miscellaneous kernel services. These are described in this section. The architecture also includes a collection of system services that are implemented by non-privileged applications. These services provide higher-level abstractions such as files, directories, and memory objects.</p><p>The kernel presents a fairly direct virtualization of the underlying hardware via capability-protected abstractions. Both data and capabilities are stored in pages, whose size is dictated by the underlying hardware. Capabilities are also stored in nodes. Nodes hold 32 capabilities, and serve a function equivalent to metadata in conventional systems. All state visible to applications is stored in pages and nodes.</p><p>The kernel enforces a partition between data and capabilities by tagging. Data can be read/written only to data pages and capabilities to capability pages. A capability page is never mapped in such a way that access is permitted from user mode programs. Capability load and store instructions are emulated in supervisor software, and check the per-page type tag.</p><p>The kernel also implements LRU paging and the dispatch portion of a scheduler based on capacity reserves <ref type="bibr" target="#b34">[35]</ref>. As these ideas are not new, they are not discussed further in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Address translation</head><p>Like other recent microkernels, EROS views an address space as a set of mappings of the form:</p><formula xml:id="formula_0">ÚÔ ÔÔ ¢ Ö Û ¢ Ò Ð Ö</formula><p>where Ò Ð Ö is an entry capability to a process (Section 3.2). When an addressing exception occurs, the fault handler may either alter the structure of the address space and restart the process or pass the fault to the process fault handler for further handling.</p><p>The EROS kernel captures address space mappings in machine-independent fashion using nodes. <ref type="foot" target="#foot_0">1</ref> Address spaces are formed by building a tree of nodes whose leaves are data or capability pages. Each node contains 32 capabilities, which may point to either nodes or to pages (Figure <ref type="figure" target="#fig_0">2</ref>). Node capabilities encode the height of the tree that they name, enabling short-circuit traversal similar to that of the MC68851 <ref type="bibr" target="#b35">[36]</ref>, and avoiding the need for tall translation trees. Every EROS process includes a capability that names the root of its address space tree. The mapping described by this tree is translated on demand into the representation required by the underlying hardware. When a page fault occurs, the EROS kernel first attempts to traverse the address space tree to establish a valid mapping, performing any necessary object faults to load pages and nodes from the disk. If a valid mapping is found, this mapping is installed in the hardware mapping table and the operation is restarted. Otherwise, the fault is reflected using an upcall to a user-level fault handler specified by the address space (if present) or the process (otherwise).</p><p>Using a tree of nodes rather than page tables to describe address space mappings permits relatively fine-grain specification of fault handlers (Figure <ref type="figure" target="#fig_0">2</ref>). Information about fault handlers is stored in the node-based mapping tree, but is not directly captured by the hardware mapping tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Processes</head><p>EROS process state includes the user-mode registers of the underlying processor, including the user-accessible portion of the processor status word. In addition, each process has a capability register set implemented by the kernel. The capability registers contain those capabilities that the process can directly invoke.</p><p>The kernel exports the process abstraction to application code via two types of capabilities: process capabilities, which provide operations to manipulate the process itself, and entry capabilities, which allow the holder to invoke the services provided by a program within a particular process.</p><p>Because EROS is a persistent system, all process state must ultimately reside in structures that can be stored to disk. In EROS, these structures are pages and nodes. Process state is recorded using nodes (Figure <ref type="figure" target="#fig_1">3</ref>). Data register values are stored to the node using number capabilities, which name an unsigned value and implement read operations. 00 00 00 00 00 <ref type="bibr" target="#b10">11</ref>   EROS makes no distinction between processes and threads. All processes are single-threaded. Two processes may share an address space; each of these processes can hold distinct capabilities. Multithreaded services are implemented by having several processes that share a common address space. Most of these processes serve as worker threads. A distinguished process publishes the externally visible entry point to the service. This process accepts requests and forwards them to the worker processes. <ref type="foot" target="#foot_1">2</ref>In EROS, each process is a protection domain. Applications are designed as multiple cooperating processes. Application-transparent persistence ensures that consistency between processes is preserved across system restarts. Because the arrangement and consistency of these processes is not lost in the event of a system crash, the associated interprocess relationships need not be reconstructed every time the application is accessed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Capability invocation</head><p>All resource access in EROS is ultimately performed by capability invocation. <ref type="foot" target="#foot_2">3</ref> If authorized by the capability, each invocation causes the named object to perform some objectdefined operation specified by the invoker. Even memory accesses performed by load and store instructions may be modeled as an efficiently cached capability invocation. The semantics of memory reference is therefore covered by the capability semantics. Capabilities are used to invoke both kernel implemented services (pages, nodes, processes, numbers) and services or objects implemented by user processes. Process-implemented services are implemented using a "reply and wait" loop; if the service is not available at the time of the call, the caller blocks until the service becomes available.</p><p>Capability invocations transmit a small number of data registers (4), a contiguous data string, and a small number of capability registers (4). If desired, the sender can cause a distinguished entry capability called a resume capability to replace the last capability argument. The resume capability enables the recipient to reply to the sender.</p><p>All copies of a resume capability are efficiently consumed when any copy is invoked, ensuring an "at most once" reply. Manifesting the callers continuation as a capability instead of using an implicit stack allows non-hierarchical interprocess control flow, which is useful for thread dispatching. Distinguishing start and resume capabilities (and the associated process states) also allows applications to construct an implicit mutex around extended co-routine interactions by invoking an existing resume capability and generating a new resume capability with each interprocess control transfer. This mechanism is sometimes used to ensure that extended string transfers are not interrupted by other invocations.</p><p>Since entry capability invocations (including resume capabilities) are very common, EROS includes a fast interprocess communication (IPC) mechanism described in <ref type="bibr" target="#b42">[43]</ref> and <ref type="bibr" target="#b43">[44]</ref>. Although the implementation reported here has not been carefully optimized, earlier implementations have exactly matched the performance of L4's IPC primitive <ref type="bibr" target="#b43">[44]</ref>.</p><p>An unusual aspect of the architecture is that capability invocation is the only "system call" implemented by the kernel. Because there are no other system calls, all actions taken by a process are implicitly access checked. Objects imple-mented by the kernel are accessed by invoking their capabilities. All capabilities take the same arguments at the trap interface. In consequence, processes implementing either mediation or request logging can be transparently interposed in front of most objects. In particular, mandatory access control across confined subsystems can be enforced using either indirection using the kernel-implemented indirector object or simulation by a transparently interposed filter process, as in KeySafe <ref type="bibr" target="#b37">[38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Limiting access propagation</head><p>Capability systems permit capabilities to be transferred over authorized channels. As a result, security arguments must consider both the propagation of information and the propagation of access rights. Capability access rights can be surprisingly powerful; a read-only capability to a node permits a read-write capability residing in that node to be extracted, which in turn allows other data structures to be modified.</p><p>The EROS architecture uses two mechanisms to address this issue: the weak access right and access indirection.</p><p>Weak access is similar to read-only access, except that capabilities fetched via a weak capability are diminished in authority so as to be both read-only and weak. The net effect is that transitive read-only access is ensured. The default copy-on-write pager implementation described in Section 5, for example, remains in the "trusted computing base" for reasons of integrity, but is unable to leak information because it holds only a weak capability to the original memory object. The EROS weak access right is a generalization of the KeyKOS sense capability <ref type="bibr" target="#b21">[22]</ref>; sense capabilities are read-only, weak capabilities need not be. A write via a weak capability stores a diminished (i.e. read-only and weak) form of the stored capability.</p><p>Access indirection can be used to implement selective revocation. When sensitive capabilities are granted by a reference monitor, the monitor can either transparently forward requests on those capabilities or supply an indirection object in place of the real capability. Access can later be revoked by destroying the indirection object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Checkpointing and persistence</head><p>The correctness of the EROS operating system relies on the fact that all operations performed by the kernel result in a correct system state so long as the initial state was correct. The legality of an operation depends on the state of the system, which in turn depends on previous operations. This implies that causal order of operations must be maintained.</p><p>The challenge in causal ordering lies in ensuring that a correct system state is recovered when an unplanned shut down occurs (i.e., a crash). To achieve this, the kernel must periodically arrange for a consistent image to be saved without application support, and without unduly intruding on application performance. The difficulty lies in ensuring that the image written to the disk is correct; once committed, a bad checkpoint cannot be undone. The EROS implementation guarantees that a correct state exists on the disk by means of a transparent persistence mechanism evolved from KeyKOS <ref type="bibr" target="#b27">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1">Snapshot</head><p>As in KeyKOS, the EROS implementation takes a periodic snapshot of the entire machine. This state is written to the disk asynchronously. On restart the system proceeds from the previously saved system image. Because the checkpointed image is globally consistent, causal ordering is maintained. <ref type="foot" target="#foot_3">4</ref>The snapshot mechanism introduces minimal disruption of execution. While all processes are halted during the snapshot, this phase performs a consistency check and marks all objects copy-on-write (even to the kernel). Care is taken by the snapshot procedure to ensure that capabilities remain in their optimized form (Section 4.1). Memory mappings must be marked read-only to support the kernel copy-on-write implementation, but the mapping structures are not dismantled as a side effect of checkpointing.</p><p>An important difference between the snapshot mechanism of EROS (and KeyKOS) and those of L3 <ref type="bibr" target="#b30">[31]</ref> or Fluke <ref type="bibr" target="#b51">[52]</ref> is that the EROS snapshot mechanism performs a consistency check before the snapshot is taken. Critical kernel data structures are checked to ensure that their pointers point to objects of appropriate type, allegedly read-only objects in the object cache are checksummed to verify that they have not changed, every modified object must have an entry in the in-core checkpoint directory, and the types of capabilities in process slots are checked. If any of these checks fail, the system is rebooted without committing the current checkpoint.</p><p>Once committed, an inconsistent checkpoint lives forever. Aside from errors that have occurred while debugging the stabilization code itself, neither KeyKOS nor EROS has been observed to write an inconsistent checkpoint in seventeen calendar years of operation. The check procedure in EROS has caught innumerable bugs in the implementation, including several obscure boundary conditions and a number of stray pointer errors. This proved sufficiently useful that EROS now performs these checks continuously as a low-priority background task.</p><p>In the current implementation, the duration of the snapshot phase is a function of physical memory size. On systems with 256 megabytes of physical memory the snapshot takes less than 50 ms to perform. This time includes execution of the system sanity checker described above. A more incremental design would use copy-on-write techniques to implement the snapshot itself. This would make the snapshot phase solely a function of the process table size (Section 4.3), which should reduce the synchronous phase to roughly a millisecond.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2">Stabilization</head><p>Once a snapshot has been captured, the state is written to the disk asynchronously. To avoid checkpoint-induced delays, stabilization must complete before the next checkpoint, which is typically set at 5 minute intervals. To prevent overrun when applications perform unusually large numbers of object mutations, a checkpoint is also forced when 65% of the total checkpoint area has been allocated to the current checkpoint. Experience with the KeyKOS design <ref type="bibr" target="#b27">[28]</ref> suggests that this design can scale in memory capacity with the bandwidth of available I/O channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.3">Bootstrap and installation</head><p>The checkpoint mechanism is used both for startup and for installation. In EROS, an initial system disk image is compiled using a cross compilation environment. The image generation tools link processes by capabilities in much the way that a conventional link editor performs relocation as it builds a binary image. The resulting checkpoint area contains a list of running processes that should be (re)started when the system resumes.</p><p>While installation tools are not yet implemented, the built-in checkpoint and replication mechanisms make this straightforward. The program on the installation diskette formats new ranges on the hard disk corresponding to those on the floppy and mounts them. Because they match existing ranges (the ones on the floppy) but have old sequence numbers, the kernel recovers the "stale" range by sequentially marking all objects in the newly duplexed range "dirty" and allowing the replication logic to rewrite them to both replicates. <ref type="foot" target="#foot_4">5</ref> The installation tool simply waits for mirror recovery to complete and forces a checkpoint. The end result is that the image on the hard disk is now a valid bootable image. This mechanism is considerably simpler than the "big bang" used in KeyKOS installation <ref type="bibr" target="#b21">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.4">Supporting design rules</head><p>Checkpointing is facilitated by two kernel design rules: ¯All state resides in pages and nodes. ¯All kernel operations are atomic. <ref type="foot" target="#foot_5">6</ref>Much of the EROS design is predicated on the first restriction, which limits the number of disk object types that must be managed by the persistence subsystem. With the sole exception of the list of stalled processes, this objective is actually satisfied by the current implementation; the EROS kernel owns no state. Restricting the number of data types at this level also reduces the number of storage allocators that must be managed by the implementation.</p><p>The atomicity rule is a corollary of the pages and nodes requirement. When a kernel invocation must stall, as when waiting for page I/O, a small, in-kernel "thread" structure containing a capability to the stalled process is queued on the in-kernel stall queue. The invoker's program counter is adjusted to retry the invocation when awakened. This design is similar to that adopted in Fluke <ref type="bibr" target="#b11">[12]</ref> and MIT's ITS system <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3]</ref>, and simplifies checkpointing, as checkpointed kernel state requires special handling by the checkpoint mech-anism. In the current implementation, the only kernel state that must be checkpointed is the table of stall queue structures. The stall queue structures are also the only kernel resource that can be exhausted by action of applications.</p><p>While it is not presently implemented, such exhaustion can be managed by a trusted decongester application. When stall queue structures are oversubscribed, the kernel constructs fault capabilities (a specialized resume capability used by user-level fault handlers to restart a faulted process without changing its state) to the lowest priority processes and passes these fault capabilities to the decongester application for later resumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>This section describes how the abstractions of Section 3 are mapped to conventional hardware mechanisms.</p><p>The definitive representation for all EROS objects is the one that resides in pages and nodes on the disk. Pages and nodes are cached at two levels of abstraction by the EROS kernel (Figure <ref type="figure" target="#fig_2">4</ref>). The first level is for efficient access by the processor. The second level is simply an object cache, which is a fully associative, write-back cache of the on-disk objects. Address translation causes the contents of some nodes to be cached in hardware mapping tables. Process invocation causes other nodes to be cached in the process table. The process table is managed as a write-back cache that sits in front of the object cache. Hardware mapping structures are treated as read-only. Both are flushed when the capabilities they cache are invalidated.  Use of software caching at multiple levels of the system means that the representation of performance-critical data structures should be easily customizable to the processor architecture. Also, performance-critical portions of the implementation are free to use either the machine specific or the machine independent representation. In several cases, a hybrid approach has been used to improve performance. Fast paths use the machine-specific form, and are backed by a general path using the machine independent structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Object Cache</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Capabilities and object loading</head><p>An object capability logically contains a 64-bit unique object identifier for a node or page, a 32-bit version number, and a type field. In the Pentium implementation, each capability occupies 32 bytes. Every node and page has a version number; if the capability version and the object version do not match the capability is invalid. Nodes additionally carry a 32-bit "call count", giving a total node size of 528 bytes. Discussion of call counts has been omitted for lack of space, and may be found in <ref type="bibr" target="#b44">[45]</ref>.</p><p>As stored on the disk, an object capability actually contains the unique object identifier and version number. The first time a capability is used, it is prepared. The object it names is brought into memory and the capability is converted into optimized form (Figure <ref type="figure">5</ref>). All optimized capabilities point directly to the object that they name, and are placed on a linked list rooted at the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Node, Page, or Process</head><p>Object Ptr Type Aux-Info</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5. Prepared capability</head><p>Preparing a capability also causes the target object to be prepared for use. For node and page capabilities, preparation forces the named object into memory. For process related capabilities, preparing the capability brings in the associated nodes and loads the process into the process table (Section 4.3).</p><p>Preparing a capability is one of two operations that causes objects to be converted into hardware specific representations. The other is address translation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Address translation</head><p>An EROS address space is defined by a tree of nodes. Each node must be obtained from a storage manager. The space occupied by mapping structures is therefore fully accounted for.</p><p>The node-based address map must be converted into page table entries to be used by the hardware's MMU. As address exceptions occur, a lazy translation of the state in the node tree into page table entries is performed. The resulting hardware mapping entries are managed as a read-only cache of state that resides in the node trees.</p><p>A simple implementation would perform address translation by traversing the node tree, generating a mapping, and updating the page tables. To facilitate invalidation when the node slots are modified, it must record a mapping from capability addresses to the generated page table</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>entries (the depend table).</head><p>There are two issues with this implementation:</p><p>¯Full traversals are expensive. The node tree contains information stored in capabilities. A fair amount of data driven control flow is required to decode this information.</p><p>¯The naive design does not leverage shared mapping tables on architectures that support them.</p><p>The following sections describe how this implementation is optimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Reducing traversal cost</head><p>The Pentium family uses a two-level hierarchical translation table. EROS also uses a hierarchical mapping architecture; a correspondence can be established between the two mapping hierarchies (Figure <ref type="figure" target="#fig_3">6</ref>). Since nodes contain 32 entries, and Pentium mapping tables contain 1024 entries, two node levels are used to describe each of the Pentium mapping table levels. Wherever a valid mapping exists in the hardware page tables, this mapping agrees with the mapping in the node tree. The address translation algorithm exploits this correspondence. In Figure <ref type="figure" target="#fig_3">6</ref>, given a successful translation of page Ô¼, a subsequent translation fault on Ô½ or Ô¾ must also traverse nodes and . Because a valid hardware mapping entry exists in the page directory, the hardware mapping may be used instead provided that there exists some means to discover that node corresponds to the page table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Node</head><p>Every core page frame has an associated bookkeeping structure containing various information about the frame. For page frames that contain mapping tables, this information includes a pointer to the producer of that mapping table. The producer is that node in the mapping tree such that (a) its span in pages is less than or equal to that of the mapping table rounded up to the nearest power of 32 and (b) it has the largest span of the candidate nodes under rule (a). That is, we are looking for a node whose span is no larger than that of the corresponding mapping table. The rounding complication addresses the situation in which the hardware mapping table spans are not an integer power of the node spans. It is not relevant to the Pentium family.</p><p>In Figure <ref type="figure" target="#fig_3">6</ref>, node is the producer of the page directory, and node is the producer of the page The producer optimization means that the majority of page faults traverse only two layers of the node tree, which cuts the average translation cost in half. This is particularly important for fault handling, where at least part of the traversal must be done to identify the target fault handler. Producer tracking also means that page tables can be reclaimed by first locating their producer, then locating all valid in-memory capabilities to that producer by traversing the capability chain, and then invalidating all page tables associated with the addresses of the node slots (the array entries) containing those capabilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Shared mapping tables</head><p>Every producer has an associated list of products, which is the list of page tables constructed from that producer. A producer may have multiple products if a short-circuited tree has been constructed. If an address space is described by a single node, the node will be the producer of the page table, the read-only page directory, and the read-write page directory. A producer may also have multiple products if protection bits are not provided at some level of the translation tree. On the Pentium, the address space register does not implement a write protection, so both read-only and read-write versions of the page directory must be constructed following a checkpoint to ensure that copy-on-write occurs while stabilization is in progress.</p><p>The product chain is used to ensure that page tables are shared where possible (Figure <ref type="figure" target="#fig_4">7</ref>). If either process has successfully translated Ô¼, Ô½, or Ô¾, then a page table corresponding to nodes , , and has been created and placed on the product chain of node . When the other process first references any of these pages, the translation logic will find an invalid entry in its page directory. It will then locate the producer for the page directory (either or ), and traverse the upper portion of the node tree (either or ). In either case, it will discover that node is at a height corresponding to a page table, and check the product list of to see if a page table with appropriate permission constraints already exists. Finding the page table created by the previous successful translation, it will reuse this page table rather than create a new one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">No inverted page tables</head><p>Before a page or page table can be removed, all mapping structures referencing that object must be invalidated. Conventional implementations must maintain a mapping from pages to page table entries (an inverted page table) to accomplish this. In EROS, an inverted page table is rendered unnecessary by the capability link chains (Figure <ref type="figure">5</ref>). If the object to be removed is a page, its prepared capabilities must be traversed to convert them back to unoptimized (i.e., on-disk) form. As these capabilities are traversed for conversion, the previously recorded depend table entries are used to invalidate the page table entries that point to the page. If the hardware mapping architecture is hierarchical, the slots in each address space node correspond to a contiguous region in each of the produced page tables, so only one depend table entry is required per (node, page table) pair. Because of the capability link chain, a per-page entry is required only in the case of a single-page address space (i.e. one with no nodes).</p><p>If the object to be removed is a page table, matters are slightly more involved. Note that the producer of the page table spans all of the valid portion of the page table. It follows that the capabilities that name the producer dominate the page table entries that point to the page table. Before removing a page table, it suffices to traverse the capability chain of its producer and invalidate the associated depend table entries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Small spaces</head><p>Liedtke has shown that creative combinations of segmentation and virtual address translation can yield dramatic performance benefits on some classes of hardware <ref type="bibr" target="#b31">[32]</ref>. In such designs, the virtual address space is divided into a single "large space," a universally mapped kernel region, and some number of "small spaces." Boundaries between these spaces are enforced using segmentation rather than page protection.</p><p>In effect, this technique uses the segment registers to prepend tag bits to the virtual address. No TLB flush is necessary in control transfers between small spaces. Similarly, no TLB flush is needed when transferring to a large space if that large space is the "current" large space. A flush is required only when the current large space changes or a mapping entry is forcibly invalidated.</p><p>Small spaces have a disproportionate impact on the performance of an EROS system. The most critical operating system service applications fit comfortably in less than 128 KB, and these objects are accessed with high frequency.</p><p>In particular, all of the address space fault handlers currently included in the system run as small spaces, which halves the number of address space switches required to handle a page fault.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Processes</head><p>In EROS, the majority of capability invocations are IPC operations, whose performance depends critically on the lowlevel process representation. Software caching is used to convert the process structure of Figure <ref type="figure" target="#fig_1">3</ref> to and from a representation optimized for efficient register save and trap handling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">The process cache</head><p>The kernel maintains a boot-time allocated process table. Unlike conventional kernel architectures, this process table is a cache. As with other objects, the loading of process table entries is driven by capability preparation. When process first invokes a capability to process , the capability is prepared. As a side effect, a process table entry is allocated and the state of process is loaded into this entry. When a process blocks, a structure containing a process capability to that process is placed on some queue by the kernel. This queue structure is the only information about the process that must remain in memory while the process is stalled. Processes that are ready to execute are queued on the ready queue. When the stalled processes are awakened, this process capability is prepared, forcing the process back into the process table.</p><p>Process table writeback occurs either when an entry in the table is reallocated or when a checkpoint occurs. In either case, all capabilities to the unloaded process are deprepared, restoring them to their disk representation. As processes are restarted following the checkpoint, they are incrementally reloaded into the process table. This in turn causes the process' constituent nodes (Figure <ref type="figure" target="#fig_1">3</ref>) to be marked "dirty" in preparation for modification. When a checkpoint is in progress, copy on write is used to ensure that the snapshotted version of the state associated with active processes remains unmodified until it has been stabilized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">The save area</head><p>The Pentium architecture saves state to a kernel stack when a trap occurs. Rather than copy this state, the EROS kernel arranges for the kernel stack pointer to point directly into the per-process save area (Figure <ref type="figure" target="#fig_5">8</ref>). The hardware trap mechanism spills the trap state directly into the process table entry for the active process.</p><p>Control is assumed by the trap handler, which completes the register save, loads kernel segments, adjusts the stack pointer to point to the true kernel stack, and transfers control to the kernel. EROS is an "interrupt style" kernel. When a process is suspended in the kernel it is forced to restart at the trap instruction; there is no per-process kernel stack.  A Pentium implementation challenges register save design. The saved state has an irregular format (the error field is not consistently saved) and is not self describing (the trap number is not made easily available by the hardware). Thus, every hardware interrupt and exception has its own kernel entry point. This entry point appends the error value if necessary and inserts an identifying trap number onto the stack; it then branches to a common interrupt handler. Register save is further complicated by the fact that the processor may be in either "Virtual 8086" mode or protected mode when the interrupt occurs. EROS supports both modes. The state saved to the kernel stack differs according to mode. The kernel therefore keeps track of which mode the application is in and adjusts the kernel save area pointer accordingly before dispatching the process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Capability invocation</head><p>Capability invocations divide into two cases: fast path interprocess invocation and the general invocation mechanism.</p><p>The interprocess invocation fast path is based entirely on the machine specific process structure. It is implemented in assembly code, and handles the case in which the recipient process is prepared and all mappings for the necessary sender and recipient data pages are present in the page tables with valid permissions. If preparation is needed, or if mapping entries need to be constructed, the fast path is abandoned in favor of the general path.</p><p>The general invocation path uses the processor specific mapping structures to avoid traversing node trees unnecessarily, but falls back to node tree traversal when necessary. It handles certain cases omitted by the fast path -notably invocations that change the number of running processes (create or delete them). All cases are handled by the general implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Summary</head><p>EROS stores mapping and process state in a machine-independent data structure: the node. This common underlying representation simplifies both checkpointing and storage al-location, and means that system resources "run out" only when the available disk space is exhausted. This state is converted on demand to the representation required by the hardware for efficient use. Various representation and chaining techniques are used in lieu of conventional data structures to support invalidation and page out. The high-performance paths of the system operate against a machine-specific process structure similar to that of L4 and similar microkernels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">System services</head><p>Having described the kernel implementation, we can now sketch how these primitives are used to provide higher-level abstractions customarily implemented by supervisor code. To illustrate, we will describe the implementation of three basic services: the storage allocator, virtual copy memory objects and the process constructor. All of these services are implemented by application code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Storage allocation</head><p>Storage allocation is performed by the space bank, which owns all system storage. The space bank application implements a hierarchy of logical banks, each of which obtains its storage from its parent. The root of this hierarchy is the prime space bank. Every node and page used by an application is allocated from some particular space bank. The fact that all banks are implemented by the same process is not visible to client applications. The term "space bank" is therefore used to refer to a logical space bank.</p><p>A space bank performs four functions:</p><p>¯It allocates nodes and pages, optionally imposing an allocation limit.</p><p>¯It tracks the identities (the OIDs) of the pages and nodes that it has allocated.</p><p>¯It ensures that all capabilities to a node or page are rendered invalid when the object is deallocated.</p><p>¯It provides a degree of storage locality. Objects allocated from a given bank are allocated from contiguous extents on the underlying disk.</p><p>When a space bank is destroyed, objects allocated by that bank and all sub-banks are either deallocated or returned to the control of its parent bank. Space banks therefore provide a form of explicit storage reclamation. One way to ensure that a subsystem is completely dead is to destroy the space bank from which its storage was allocated.</p><p>Space banks manage extents dynamically; applications can ensure locality of storage for two objects by creating per-object sub-banks, creating the objects, and then destroying the bank without reclaiming the storage. Banks are cheap to create and occupy minimal storage (one node per bank). They are therefore well suited to region-based storage management <ref type="bibr" target="#b1">[2]</ref>. The unification of extent management and region management provided by this use of space banks extends the locality advantages of region management to permanent storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Virtual copy spaces</head><p>A virtual copy space is a copy-on-write version of some other space. Initially, the new space consists of a single node containing a capability to the original object and a capability to a copy-on-write manager. Writes to uncopied pages induce access violations that are directed to this manager. As each page in the new structure is modified, read-write copies are made of the target page and any necessary nodes (Figure <ref type="figure" target="#fig_6">9</ref>). Only the modified portion of the structure is copied. Each copied page and node is allocated from the space bank. The bank is provided by the client of the virtual copy object when the copy is first created; storage is accounted to the user. To create a lazy copy of an existing memory space, the manager for that space is asked to freeze the space. The manager returns a constructor (Section 5.3) which will produce copies of the original space. Demand zero objects are realized as virtual copies of the "primordial zero space," which is part of the hand-constructed initial system image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Space</head><p>We have previously noted that traversing the address space tree is expensive. The virtual copy handler reduces this cost by remembering the location of the last modified page and its containing node. If the next modified page falls within the same leaf node, no traversal is required. Empirically, this simple method matches common memory usage patterns well, and reduces the effective traversal overhead by a factor of 32. In the fast case, a copy-on-write page fault proceeds as follows:</p><p>1. Faulting process takes an address translation fault.</p><p>Kernel walks address space tree, locates no translation. 2. Kernel synthesizes an upcall to the virtual copy handler (context switch). 3. Virtual copy handler purchases a new page from the space bank, initializes it, and installs it at the appropriate offset (two context switches). 4. Virtual copy handler returns to the faulting process, restarting the instruction (context switch). 5. Faulting process takes another address translation fault. Kernel walks address space tree, locates a valid translation, and silently restarts the faulting instruction.</p><p>The performance of this implementation is discussed in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Process construction</head><p>As with virtual copies, process creation in EROS is performed by application code. Every application has an associated "constructor" that knows how to fabricate new instances of that application. Constructors are themselves applications, which come from the metaconstructor. The metaconstructor is part of the hand-constructed initial system image.</p><p>Constructors are trusted objects whose design purpose is to certify properties about the program instances they create. In particular, the constructor is able to tell the client whether the newly fabricated process has any ability to communicate with third parties at the time of its creation. The constructor is able to perform this certification based solely on inspection of the program's initial capabilities, without inspecting its code. This means that standard utility programs can be used on sensitive information without risk of information leakage. To build a new process (Figure <ref type="figure" target="#fig_7">10</ref>), the client invokes a constructor (step 1). The constructor invokes its process creator (2), which purchases nodes from a client-supplied space bank <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b3">4)</ref> and returns a new process (5) that initially executes from a constructor-supplied, read-only address space. When started <ref type="bibr" target="#b5">(6)</ref> this "construction space" creates a mutable copy of the new program's executable image (either by copying it or by creating a virtual copy), obtaining further space from the space bank as needed <ref type="bibr" target="#b6">(7,</ref><ref type="bibr" target="#b7">8)</ref>. It transfers control to the new process via a "swap address space and PC" operation. The new instance performs program specific initialization and returns (9) directly to the client process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Instance</head><p>Constructors are in practice used as the standard mechanism for packaging and instantiating programs in EROS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>The focus of this paper is a capability system design motivated by performance considerations. The best means of comparing its performance to that of other systems would be direct application benchmarks. EROS is new enough that applications have not yet been ported to it, which precludes this comparison at this stage. We have chosen microbenchmarks as our means of evaluation, inspired by those of lmbench <ref type="bibr" target="#b33">[34]</ref>. Each lmbench benchmark is motivated by a real performance bottleneck from some real application. We have examined the constituents of lmbench and produced semantically similar tests for EROS. As EROS does not export a raw disk interface and does not yet have a networking implementation we have omitted such benchmarks.</p><p>The categories of operations tested by the lmbench suite are relatively universal. In many cases, operations with corresponding semantics are used by native EROS applications. One way to place the performance of EROS in context is to compare these operations to their nearest Linux equivalents. We have constructed a set of EROS microbenchmarks to do so. The benchmarks are included in the EROS distribution <ref type="bibr" target="#b40">[41]</ref>.</p><p>Measurements were made on a uniprocessor 400 MHz Pentium II, with 192 megabytes of memory. The lmbench utilities report memory latencies of 7 ns, 69 ns, and 153 ns for the level one, level two, and main memories, respectively. Linux measurements, where given, are obtained from kernel version 2.2.5-22 on the same hardware using the standard lmbench distribution. The Linux kernel measured supports symmetric multiprocessing. Linux measurements reported here are made using a kernel with multiprocessing support compiled out.</p><p>The results are summarized in Figure <ref type="figure">11</ref>. The bars are normalized relative to the Linux timings. Except for the pipe bandwidth benchmark, a shorter bar represents a better result. Actual timings and percent loss/gain are also shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Kernel invocation baseline</head><p>The "trivial system call" benchmark is intended to examine the minimum cost of entering and exiting the kernel while performing minimal work. In POSIX this is customarily tested with the getppid() operation (0.7 s). The nearest EROS equivalent is the typeof operation on a number capability (1.6 s).</p><p>The difference reflects the difference in the two system architectures. EROS capability invocations must test to verify that the target object is prepared, and must allow for the possibility that control will be returned to some other process. Also, all capability invocations have the same argument structure (Section 3.3). The trivial EROS kernel invocation therefore involves a more complex argument specification and a greater amount of data manipulation. The common argument structure allows processes to transparently interpose on capability invocations, emulating the original object; in this case function was favored over performance in the design. object that is valid. That is, it measures the time to convert from the logical mapping structures maintained by the operating system to the hardware mapping representation. The benchmark constructs an object, unmaps it, remaps it, and then measures the time to sum the first word of each page. In Linux, this operation takes 687 s per page. The corresponding EROS operation takes 3.67 s per page in the general case, which reflects the basic cost of the node tree traversal. The EROS cost rises to 5.10 s if the fast traversal optimization of Section 4.2.1 is disabled. Linux performance on this benchmark has regressed in recent versions of the Linux kernel. The 2.0.34 version of the Linux kernel took 67 s on this operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Memory handling</head><p>If the mapped object falls at a page table boundary, the latency under EROS falls to 0.08 s. This is due to the page table sharing mechanisms described in Section 4.2.2. EROS preserves hardware mapping structures as long as it is feasible to do so. For EROS, this measures a real (and common) case. Page tables may be shared whenever a new instance of an existing application is created. The effect of sharing code space in such cases significantly reduces application startup latencies.</p><p>Experience with Mach and Chorus suggested that heap growth may inhibit system performance if it is slow <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21]</ref>. The POSIX design allows the operating system to grab any available swap page and zero it. We constructed a Linux benchmark using the lmbench timing framework, and determined that growing the heap by a page takes 31.74 s. In EROS, the fault must first be reflected to a user level fault handler which in turn must call a user level storage allocator as described in Section 5.2, which takes 20.42 s. The virtual copy handler fits within a small (address) space, allowing two of the context switches in the sequence to be done very cheaply (see below).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Process management</head><p>The EROS implementation's "performance core" is very similar in structure to that of L3 <ref type="bibr" target="#b29">[30]</ref>. An earlier implementation reported in <ref type="bibr" target="#b43">[44]</ref> matches the performance of L3 cycle for cycle. The current implementation is less highly tuned. A directed context switch under EROS takes 1.60 s in the large space case, and 1.19 s in the case of a control transfer between a large space and a small space. As measured by lmbench, a directed context switch under Linux takes 1.26 s. These latencies do not compose in obvious ways because of cache interference. A round trip large-large IPC operation takes 3.21 s, and a large-small round trip takes 2.38 s, but a nested sequence of calls such as that seen in the page allocation path (large to small to large and back) takes 6.31 s.</p><p>Where POSIX uses fork and exec to create new processes, EROS provides a direct method via the constructor. Constructors can guarantee sandboxing, and are the preferred means of starting new program instances. While it is therefore the appropriate mechanism to compare, it should be noted that the fork/exec implementation creates an address space that the EROS implementation does not require. Creating a copy of "hello world" under Linux takes 1.916 ms. Using a constructor to create a new copy of "hello world" takes 0.664 ms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Interprocess communication</head><p>Finally, we examine streaming data transfer using the pipe benchmark. Of the available IPC options, pipes are the most efficient mechanism provided in Linux (8.34 s latency, 260 MB/sec). The EROS equivalent implements pipes using a process (5.66 s, 281 MB/sec). The key point to note here is that for bulk data transfer the cost of context switches is much less important than minimizing cache misses. EROS pipe bandwidth is maximized using only 4 KB transfers. This suggests that IPC implementations which impose an upper bound on transfer payload do not impose an inherent inefficiency on data transfer rates. Bounding payloads simplifies the implementation and allows the IPC operation to be performed atomically. It also guarantees that any control transfer operation can make progress given a relatively small amount of real memory, eliminating a memory size dependency at the invocation API.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Other measurements</head><p>While EROS is not yet running applications, previous implementations of the architecture have been deployed with full application environments. An evaluation of the performance of KeyTXF, the KeyKOS transaction manager for the System 370 implementation, is described by Frantz and Landau <ref type="bibr" target="#b15">[16]</ref>. Performance on the TP1 benchmark ranged from 2.57 to 25.7 times faster than other protected database systems, and scaled linearly with CPU speed if the I/O system was also upgraded for increased capacity. IBM's TPF was 22% faster (22 transactions per second vs. 18 for KeyTXF), but TPF was an unprotected system; all TPF applications ran in supervisor mode, and were mutually trusted.</p><p>The Motorola implementation of KeyKOS included a full binary-compatible POSIX emulation. A limited performance evaluation was made against Omron's Mach 2.5 implementation (a monolithic kernel) for the same machine <ref type="bibr" target="#b4">[5]</ref>. Performance was mixed, ranging from 3.89 times slower than Mach performance on opening and closing files to 14 times faster on memory manipulation. The open/close result reflects a naive implementation, as noted in the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Performance summary</head><p>The benchmark results are summarized graphically in Figure <ref type="figure">11</ref>. As can be seen, EROS performs favorably on 6 out of 7 benchmarks. We believe that this provides good, although obviously not complete, evidence that composition of protected subsystems (several of which were used in the EROS benchmarks) need not inhibit system performance. In addition, it appears that capability systems can perform well without resorting to specialized hardware assists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>EROS's relation to TymShare's GNOSIS <ref type="bibr" target="#b21">[22]</ref> system was discussed in Section 1.1. Most of the GNOSIS architecture is preserved in EROS; the scheduler is a significant departure from the GNOSIS design. Many of the design documents and papers for the GNOSIS system (which was renamed KeyKOS) can be found at the KeyKOS web site <ref type="bibr" target="#b41">[42]</ref>. Mach and Chorus: Both Mach <ref type="bibr" target="#b19">[20]</ref> and Chorus <ref type="bibr" target="#b38">[39]</ref> use capabilities for interprocess communication. Mach also uses them to name memory objects. Both use external memory managers. Neither externalizes storage allocation or provides persistence, and in both cases the external memory manager has proven to be a source of performance difficulties <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b7">8]</ref>. Both systems are hybrid designs, in that other system calls are present in addition to capability invocation. While Mach originally started with a single mach msg system call, additional system calls were later added for performance.</p><p>The Mach send-once port bears a close resemblance to the EROS resume capability. Send-once ports can be forwarded, but cannot be copied. The absence of special semantics for resume capabilities removes a certain amount of complexity from the EROS IPC path, and slightly simplifies the implementation of debuggers and capability cache objects. Amoeba: Amoeba <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b49">50]</ref> is a distributed capability system. Unlike EROS, capabilities are protected by sparsity. Because capabilities are just data, language integration and IPC design are greatly simplified. The cost of this is that capability transfer cannot be detected by a reference monitor. Mandatory access control is therefore impossible to implement outside of the kernel, and metadata update order violations are not detectable by the kernel.</p><p>Amoeba does not use capabilities for fine grain system resource such as pages and memory mapping structures.</p><p>Storage for mapping structures is therefore a hidden overhead rather than clearly accounted for. L3 and L4: The EROS IPC implementation was heavily influenced by L3 <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32]</ref> and Mach 4 <ref type="bibr" target="#b13">[14]</ref>. The mechanism in EROS is closer to that of L3, but there are some significant differences.</p><p>L3 invocation is unauthenticated; in the absence of a chief any process ("task" in L3-speak) may invoke any other process. If required, access controls must be implemented by an intervening process known as a chief, doubling the cost of an authenticated IPC. The most recent iteration of Lava (the L4 successor) incorporates an IPC redirection mechanism that is very similar to capabilities <ref type="bibr" target="#b23">[24]</ref>. Even in the newest implementation, however, capabilities are not transferable. Transferring an authority from one process to another requires interaction with the indirection table manager.</p><p>L3 is also persistent <ref type="bibr" target="#b30">[31]</ref>, but lacks an equivalent to the EROS/KeyKOS consistency check. Its checkpoint mechanism is implemented outside the kernel by a memory manager that has direct access to kernel data structures. Data structures included in the checkpoint are allocated out of pageable memory. The kernel may page fault on these structures, and is designed to recover when it does so. Because the kernel directly uses process structure addresses (i.e. there is no indirection), any change in the size of the kernel process table or other checkpointed kernel tables renders previous checkpoints unusable. This is not a limitation of the current EROS mechanism. Fluke: Fluke <ref type="bibr" target="#b12">[13]</ref> is a capability kernel that also provides persistence. Its hierarchical resource management mechanisms are similar to those provided by the EROS space bank and the meter mechanism of KeyKOS. Like L3, Fluke's persistence is implemented by a user-level pager, but its performance is unreported. Also like L3, Fluke's persistence mechanism lacks a consistency check. Cache Kernel: The Cache Kernel <ref type="bibr" target="#b5">[6]</ref> uses a caching approach in some ways similar to EROS. Where EROS writes operating system objects (Processes) back to protected structures (Nodes), the Cache Kernel writes this state back to untrusted application kernels. Hydra and CAL/TSS: Hydra <ref type="bibr" target="#b54">[56]</ref> and CAL/TSS are early software capability systems. Neither was persistent. HY-DRA incorporates a port-based store and forward messaging system, which reduces its messaging performance. CAL's messaging is unbuffered and portless, and provides no multicast mechanism. CAL also provides an "event" mechanism, allowing a bounded number of one word messages to be sent asynchronously to the recipient. Of the early capability systems, the CAL design most closely resembles that of EROS. CAP: The Cambridge CAP computer <ref type="bibr" target="#b53">[55]</ref> is a hardware capability system in which capabilities name both protection domains and memory segments. The hardware assist provided by the capability cache provided adequate performance for large grain objects, but use of memory capabilities to describe language-grain objects (e.g., structures rather than pages) leads to higher-frequency dereferencing of capabilities than the hardware can effectively support. Also, the incorporation of nested memory capabilities in the architecture, while not leading to in-cache complexity, considerably complicates capability cache miss processing. Intel i432: The Intel i432 <ref type="bibr" target="#b36">[37]</ref> was originally designed as an ADA machine, and ultimately turned into an objectbased hardware system. A derivative segmentation architecture can be seen today in the i386. The i432 was designed as a high level language machine. Architecturally, it is a very complex machine, and its performance suffers dramatically as a result <ref type="bibr" target="#b6">[7]</ref>. ExOS: MIT's Exokernel <ref type="bibr" target="#b10">[11]</ref> provides an alternative approach to application-level resource management. Where the EROS kernel exports kernel-protected entities, the exokernel architecture reorganizes critical data structures to allow processes direct access, and pins these structures in memory. This approach eliminates the need for data copies in many cases, at the cost of exposing a more complex interface contract to the application. What maintainability implications this may have for long-term compatibility as interfaces evolve remain unclear. Greg Ganger, one of the Exokernel designers, has noted that the design of generally usable interfaces in exokernel remains a challenge <ref type="bibr" target="#b16">[17]</ref>.</p><p>The Exokernel uses hierarchically-named credentials called capabilities <ref type="bibr" target="#b32">[33]</ref>, but these are not capabilities in the traditional sense. They do not name target objects, nor directly authorize access, but rather contain encoded principals that the kernel checks against access-control lists. Exokernel capabilities are more akin to an extensible uid/gid abstraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>EROS' basic abstractions and implementation techniques can realize an efficient capability system on commodity hardware. Microbenchmark performance measurements in comparison with Linux are quite good. Results from other microkernels show that microbenchmark results do not always translate into strong application performance.</p><p>A full validation of our performance claim requires application-level benchmarks. The construction of a native EROS execution environment is expected to take several people another year, after which it will be possible to perform such measurements. The conclusion at this stage is that building such an environment is worth pursuing. Experience with KeyKOS <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b15">16]</ref> suggests that the microbenchmark results reported here approximately predict real system performance.</p><p>The design presented here incorporates both user-level fault handling, which is not uncommon in modern microkernels, and, uniquely as far as we know, user-level storage allocation. Performance does not appear to suffer from doing so. We believe this result stems from four aspects of the design:</p><p>1. The primitive abstractions implemented by the kernel map directly to the abstractions supported by the hardware. The "semantic gap" between the two is minimal. 2. EROS fault handlers -in particular memory handlersare less complex than those of similarly user-managed designs. The memory handler is responsible for address validation and storage provisioning, but does not make decisions about paging policy or resource arbitration among competing clients. This is in contrast to Mach <ref type="bibr" target="#b20">[21]</ref> and Lava, where all of these policies are implemented by a single piece of code. It is similar in this regard to Fluke <ref type="bibr" target="#b12">[13]</ref>. 3. While encapsulated, the kernel directly exports a machine-independent interface to address mapping structures. This allows portable memory managers to perform optimizations that are not possible when this metadata is opaque to the handler. In contrast, Exokernel's exported memory interface is machine-specific <ref type="bibr" target="#b10">[11]</ref>. 4. EROS's selection of basic abstractions enables a software caching design model, which in turn allows the implementation to use machine-dependent representations when performance is critical and machineindependent representations for low-likelihood cases or more portable code.</p><p>Roughly 22% of the current kernel code is Pentiumspecific. An additional 9% relates to hierarchical page table management or node tree traversal, and would be reused for similar translation architectures, such as the Motorola 68000 or 88000 or the Sun SPARC.</p><p>The EROS constructor mechanism provides a basic building block for EROS's user-level mandatory access control mechanism. Its correctness has been proven in <ref type="bibr" target="#b45">[46]</ref>.</p><p>The principal failing of capabilities is difficulty of administration. In the absence of a reference monitor, there is no direct way to say "Fred may not use this object." The KeySafe system <ref type="bibr" target="#b37">[38]</ref> provides one means to do so within a capability framework. Mechanisms appropriate for flexible mandatory access controls have been explored in DTOS <ref type="bibr" target="#b39">[40]</ref> and Flask <ref type="bibr" target="#b47">[48]</ref>. With EROS illustrating how to implement capability designs efficiently on commodity hardware, a logical next step is to pursue unifying the two mechanisms efficiently.</p><p>The EROS system currently runs on Pentium class hardware. The system is available for download from the EROS web site <ref type="bibr" target="#b40">[41]</ref>. The downloadable packages include the benchmarks presented here. A number of groups are currently proceeding with various enhancements of the system, including one that is developing a commercial product built on EROS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Acknowledgements</head><p>Several people offered comments and feedback that significantly improved this paper. We particularly wish to thank Leendert Van Doorn, Marc Auslander, and Bruce Lindsay of IBM, Norman Hardy of Agorics, Inc., Charlie Landau of Compaq Computer, and Bill Frantz of Electronic Communities, Inc. Maria Ebling of IBM did a thoughtful critique that significantly helped the clarity of the paper. Jay Lepreau of University of Utah was kind enough to shepherd this paper, and provided useful feedback. Mike Hibler, also of University of Utah, suggested several useful clarifications. We also</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. EROS memory tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Process structure</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Layered caching. Arrow labels indicate the operations that induce load and flush of each cache.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Memory translation for hierarchical MMU</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Sharing mapping tables</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Save area</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Virtual copy implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Process creation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>11 11 11 11 0 31 Registers Annex</head><label></label><figDesc></figDesc><table><row><cell>0 0 0 0 Process Root 1 1 1 1 (To Address Space) 0</cell><cell>31</cell><cell>Any Capability Number Capability Capability Registers Node Capability</cell></row><row><cell></cell><cell></cell><cell>(Always Zero)</cell></row><row><cell></cell><cell>0</cell><cell>31</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table Process</head><label>Process</label><figDesc></figDesc><table><row><cell>First</cell><cell></cell><cell></cell><cell>Paging</cell></row><row><cell>Level</cell><cell></cell><cell></cell><cell>Structures</cell></row><row><cell></cell><cell>Preparation</cell><cell>Aging</cell><cell>Page Faults</cell></row><row><cell>Second</cell><cell></cell><cell></cell></row><row><cell>Level</cell><cell></cell><cell></cell></row><row><cell cols="2">Checkpoint</cell><cell></cell></row><row><cell></cell><cell>Pageout</cell><cell cols="2">Migration</cell><cell>Object Faults</cell></row><row><cell>Permanent</cell><cell cols="2">Checkpoint</cell><cell>Permanent</cell></row><row><cell>Store</cell><cell>Log</cell><cell></cell><cell>Store</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>table. If Ô¼ has been successfully translated, a subsequent translation fault on Ô½ proceeds as follows. The high order bits of the virtual address are used to locate the page directory entry. This entry points to the physical address of the page table, which was constructed when Ô¼ was translated. Translation now attempts to use the low order bits of the virtual page address to traverse the page table. It locates the page table entry and finds that it is invalid. It then looks in the per-frame bookkeeping structure associated with the page table frame to find the producer of the page table, which is node . Traversal now proceeds through nodes and in the node tree, resulting in a valid page table entry.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Two benchmarks are used to examine memory performance: page fault and heap growth. The page fault benchmark measures the time to reconstruct page table entries for a memory Summary of benchmark results. For pipe bandwidth, larger is better. Linux lmbench results appear in dark gray. EROS results are normalized to the Linux numbers, and appear in lighter gray.</figDesc><table><row><cell>Benchmark</cell><cell cols="2">Linux-Normalized</cell><cell>Speedup</cell></row><row><cell>Pipe Latency</cell><cell cols="2">8.34 s 5.66 s</cell><cell>32.3%</cell></row><row><cell>Pipe Bandwidth</cell><cell cols="2">281 MB/s 260 MB/s</cell><cell>8.07%</cell></row><row><cell>Create Process</cell><cell>0.664 ms</cell><cell>1.92 ms</cell><cell>65.3%</cell></row><row><cell>Ctxt Switch</cell><cell cols="2">1.26 s 1.19 s</cell><cell>5.5%</cell></row><row><cell>Grow Heap</cell><cell cols="2">31.74 s 20.42 s</cell><cell>35.7%</cell></row><row><cell>Page Fault</cell><cell>3.67 s</cell><cell>687 s</cell><cell>99.5%</cell></row><row><cell>Trivial Syscall</cell><cell></cell><cell>1.6 s 0.7 s</cell><cell>-128%</cell></row><row><cell>Figure 11.</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>To those familiar with earlier capability systems, a node may be thought of as a fixed-size c-list<ref type="bibr" target="#b28">[29]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Orran Krieger has noted that this implementation has unfortunate processor locality implications on large SMP systems. A planned kernelimplemented dispatcher object will address</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>this.<ref type="bibr" target="#b2">3</ref> For emulation of other operating systems, the authority to explicitly invoke capabilities can be disabled by a per-process mode bit. If capability invocations are disabled, the invocation trap instruction is treated as a conventional exception and reflected via upcall to the per-process fault handler.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>A journaling mechanism (also described in<ref type="bibr" target="#b27">[28]</ref>) may be used by databases to ensure that committed state does not roll back. The journaling operation violates causal ordering, but is restricted to data objects. Because journaling does not violate the causal ordering of protection state, it does not violate the protection model.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Replication is currently implemented; mirror recovery is not.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>We exclude observability of data mutation from our definition of atomicity, which is necessary in multiprocessor implementations. The essential point is that access right updates be atomic.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>£ This research was supported by DARPA under Contracts #N66001-96-C-852, #MDA972-95-1-0013, and #DABT63-95-C-0073. Additional support was provided by the AT&amp;T Foundation, and the Hewlett-Packard, Tandem Computer and Intel Corporations. Ý Author now with the IBM T. J. Watson Research Center.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>wish to thank Roger Needham for discussions about CAP and the use of capability systems in active networking applications.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mach: A new kernel foundation for UNIX development</title>
		<author>
			<persName><forename type="first">M</forename><surname>Acceta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Baron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Rashid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tevanian</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1986 USENIX Summer Technical Conference</title>
		<meeting>1986 USENIX Summer Technical Conference</meeting>
		<imprint>
			<date type="published" when="1986-06">June 1986</date>
			<biblScope unit="page" from="93" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Memory management with explicit regions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Principles of Programming Languages</title>
		<meeting>Principles of Programming Languages<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page" from="313" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">PCLSRing: Keeping process state modular</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bawden</surname></persName>
		</author>
		<ptr target="ftp://ftp.ai.mit.edu/pub/alan/-pclsr.memo" />
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
	<note>Unpublished report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the inability of an unmodified capability machine to enforce the *-property</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Boebert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th DoD/NBS Computer Security Conference</title>
		<meeting>7th DoD/NBS Computer Security Conference<address><addrLine>Gaithersburg, MD, USA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="291" to="293" />
		</imprint>
	</monogr>
	<note>Sept. 1984. National Bureau of Standards</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The KeyKOS nanokernel architecture</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Bomberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Hardy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hardy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Landau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Workshop on Micro-Kernels and Other Kernel Architectures</title>
		<meeting>USENIX Workshop on Micro-Kernels and Other Kernel Architectures</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1992-04">Apr. 1992</date>
			<biblScope unit="page" from="95" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A caching model of operating system kernel functionality</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Duda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1994-11">Nov. 1994</date>
			<biblScope unit="page" from="179" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Performance effects of architectural complexity in the intel 432</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Colwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Gehringer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Jensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="296" to="339" />
			<date type="published" when="1988-08">Aug. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Data movement in kernelized systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Armand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Workshop on Micro-kernels and Other Kernel Architectures</title>
		<meeting>USENIX Workshop on Micro-kernels and Other Kernel Architectures<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-04">Apr. 1992</date>
			<biblScope unit="page" from="243" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Programming semantics for multiprogrammed computations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Dennis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">C</forename><surname>Van Horn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="143" to="154" />
			<date type="published" when="1966-03">Mar. 1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Its 1.5 reference manual</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eastlake</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Greenblatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Holloway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Memo</title>
		<imprint>
			<biblScope unit="volume">161</biblScope>
			<date type="published" when="1969-07">July 1969</date>
		</imprint>
		<respStmt>
			<orgName>MIT AI Lab</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exokernel: An operating system architecture for application-level resource management</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>O'toole</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Symposium on Operating Systems Principles</title>
		<meeting>15th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
			<biblScope unit="page" from="251" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Interface and execution models in the fluke kernel</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lepreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mcgrath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tullmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Symposium on Operating System Design and Implementation</title>
		<meeting>3rd Symposium on Operating System Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1999-02">Feb. 1999</date>
			<biblScope unit="page" from="101" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Microkernels meet recursive virtual machines</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lepreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tullmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Clawson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1996-10">Oct. 1996</date>
			<biblScope unit="page" from="137" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Evolving Mach 3.0 to a migrating threads model</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lepreau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Winter USENIX Conference</title>
		<meeting>Winter USENIX Conference</meeting>
		<imprint>
			<date type="published" when="1994-01">Jan. 1994</date>
			<biblScope unit="page" from="97" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Landau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Hardy</surname></persName>
		</author>
		<title level="m">Gnosis: A secure operating system for the &apos;90s. SHARE Proceedings</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Object oriented transaction processing in the KeyKOS microkernel</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Landau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Workshop on Micro-Kernels and Other Kernel Architectures</title>
		<meeting>USENIX Workshop on Micro-Kernels and Other Kernel Architectures</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1993-09">Sept. 1993</date>
			<biblScope unit="page" from="13" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Personal Communication</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-09">Sept. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Metadata update performance in file systems</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1994-11">Nov. 1994</date>
			<biblScope unit="page" from="49" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Capability Architectures and Small Objects</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Gehringer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>UMI Research Press</publisher>
			<pubPlace>Ann Arbor, Michigan, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">UNIX as an application program</title>
		<author>
			<persName><forename type="first">D</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Forin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rashid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Summer Conference</title>
		<meeting>USENIX Summer Conference</meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
			<biblScope unit="page" from="87" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Moving the default memory manager out of the Mach kernel</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Golub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Draves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of the Usenix Mach Symposium</title>
		<meeting>of the Usenix Mach Symposium</meeting>
		<imprint>
			<date type="published" when="1991-11">Nov. 1991</date>
			<biblScope unit="page" from="177" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Hardy</surname></persName>
		</author>
		<title level="m">The KeyKOS architecture. Operating Systems Review</title>
		<imprint>
			<date type="published" when="1985-10">Oct. 1985</date>
			<biblScope unit="page" from="8" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m">Pentium Processor Family User&apos;s Manual</title>
		<meeting><address><addrLine>Mt. Prospect, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>Intel Corporation ; Intel Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Flexible access control using IPC redirection</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liedtke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Panteleenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Workshop on Hot Topics in Operating Systems</title>
		<meeting>7th Workshop on Hot Topics in Operating Systems</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999-03">Mar. 1999</date>
			<biblScope unit="page" from="191" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Improving Security and Performance for Capability Systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Karger</surname></persName>
		</author>
		<idno>No. 149</idno>
		<imprint>
			<date type="published" when="1988-10">Oct. 1988</date>
		</imprint>
		<respStmt>
			<orgName>University of Cambridge</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An augmented capability architecture to support lattice security and traceability of access</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Herbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1984 IEEE Symposium on Security and Privacy</title>
		<meeting>of the 1984 IEEE Symposium on Security and Privacy<address><addrLine>Oakland, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1984-04">Apr. 1984</date>
			<biblScope unit="page" from="2" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A note on the confinement problem</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Lampson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="613" to="615" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The checkpoint mechanism in KeyKOS</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Landau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Second International Workshop on Object Orientation in Operating Systems</title>
		<meeting>Second International Workshop on Object Orientation in Operating Systems</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1992-09">Sept. 1992</date>
			<biblScope unit="page" from="86" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Capability-Based Computer Systems</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Digital Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Improving IPC by kernel design</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liedtke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th ACM Symposium on Operating System Principles</title>
		<meeting>14th ACM Symposium on Operating System Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A persistent system in real use -experiences of the first 13 years</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liedtke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd International Workshop on Object-Orientation in Operating Systems</title>
		<meeting>3rd International Workshop on Object-Orientation in Operating Systems<address><addrLine>Asheville, N.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Improved address-space switching on Pentium processors by transparently multiplexing user address spaces</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liedtke</surname></persName>
		</author>
		<idno>GMD TR 933</idno>
	</analytic>
	<monogr>
		<title level="j">GMD</title>
		<imprint>
			<date type="published" when="1995-11">Nov. 1995</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Secure applications need flexible operating systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Workshop on Hot Topics in Operating Systems</title>
		<meeting>6th Workshop on Hot Topics in Operating Systems</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997-05">May 1997</date>
			<biblScope unit="page" from="56" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">lmbench: Portable tools for performance analysis</title>
		<author>
			<persName><forename type="first">L</forename><surname>Mcvoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Staelin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX 1996 Technical Conference</title>
		<meeting><address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-01">Jan. 1996</date>
			<biblScope unit="page" from="279" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Processor capacity reserves: An abstraction for managing processor usage</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Mercer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tokuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Workshop on Workstation Operating Systems</title>
		<meeting>4th Workshop on Workstation Operating Systems</meeting>
		<imprint>
			<date type="published" when="1993-10">Oct. 1993</date>
			<biblScope unit="page" from="129" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">MC68851 Paged Memory Management Unit User&apos;s Manual</title>
		<author>
			<persName><forename type="first">Inc</forename><surname>Motorola</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<pubPlace>Englewood Cliffs, New Jersey, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">A Programmer&apos;s View of the Intel 432 System</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">I</forename><surname>Organick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<publisher>McGraw-Hill Book Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">The KeyKOS/KeySAFE system design</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Rajunas</surname></persName>
		</author>
		<idno>SEC009-01</idno>
		<ptr target="http://www.cis.upenn.edu/˜KeyKOS" />
		<imprint>
			<date type="published" when="1989-03">Mar. 1989</date>
			<publisher>Key Logic, Inc</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Overview of the Chorus distributed system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rozier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Abrossimov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Armand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Boule</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Guillemont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Langlois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Leonard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Neuhauser</surname></persName>
		</author>
		<idno>CS- TR-90-25</idno>
	</analytic>
	<monogr>
		<title level="m">Chorus Systemes, F-78182 St</title>
		<meeting><address><addrLine>Yvelines Cedex, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<idno>87-0902025A006</idno>
		<ptr target="http://www.securecomputing.com/randt/technical-docs.html" />
		<title level="m">DTOS lessons learned report</title>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
		<respStmt>
			<orgName>Secure Computing Corporation</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<ptr target="http://www.eros-os.org" />
		<title level="m">The EROS Web Site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<ptr target="http://www.cis.upenn.edu/˜KeyKOS" />
		<title level="m">The KeyKOS Web Site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">EROS: A Capability System</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">19104. 1999</date>
			<pubPlace>Philadelphia, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">The measured performance of a fast local IPC</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Farber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th International Workshop on Object Orientation in Operating Systems</title>
		<meeting>5th International Workshop on Object Orientation in Operating Systems<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996-11">Nov. 1996</date>
			<biblScope unit="page" from="89" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">State caching in the eros kernel -implementing efficient orthogonal persistence in a pure capability system</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Farber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th International Workshop on Persistent Object Systems</title>
		<meeting>7th International Workshop on Persistent Object Systems<address><addrLine>Cape May, NJ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="88" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Verifying operating system security</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weber</surname></persName>
		</author>
		<idno>MS-CIS-97-26</idno>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Philadelphia, PA, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Inside the AS/400</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">G</forename><surname>Soltis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Duke Press</publisher>
			<pubPlace>Loveland, Colorado</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">The Flask security architecture: System support for diverse security policies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Spencer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smalley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Losocco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hibler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lepreau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th USENIX Security Symposium</title>
		<meeting>8th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="1999-08">Aug. 1999</date>
			<biblScope unit="page" from="123" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Using sparse capabilities in a distributed operating system</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Tannenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Mullender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th International Symposium on Distributed Computing Systems</title>
		<meeting>9th International Symposium on Distributed Computing Systems</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="558" to="563" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Experiences with the Amoeba distributed operating system</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Tannenebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Van Staveren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Sharp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Mullender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Van Rossum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="46" to="63" />
			<date type="published" when="1990-12">Dec. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">UNIX implementation. The Bell System Technical</title>
		<author>
			<persName><forename type="first">K</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1931" to="1946" />
			<date type="published" when="1978-07">July 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Userlevel checkpointing through exportable kernel state</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tullmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lepreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hibler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Operating Systems</title>
		<imprint>
			<date type="published" when="1996-10">Oct. 1996</date>
			<biblScope unit="page" from="85" to="88" />
		</imprint>
	</monogr>
	<note>Proc. 5th IEEE</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Felten. Extensible security architectures for Java</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Balfanz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th ACM Symposium on Operating Systems Principles</title>
		<meeting>16th ACM Symposium on Operating Systems Principles<address><addrLine>Saint-Malo, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10">Oct. 1997</date>
			<biblScope unit="page" from="116" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">The Cambridge CAP Computer and its Operating System</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Wilkes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Elsevier North Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">HY-DRA/C.mmp: An Experimental Computer System</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">A</forename><surname>Wulf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Harbison</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Mc-Graw Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
