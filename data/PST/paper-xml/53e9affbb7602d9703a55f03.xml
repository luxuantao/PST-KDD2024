<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Robert</forename><surname>Geisberger</surname></persName>
							<email>robert.geisberger@ira.uka.de</email>
							<affiliation key="aff0">
								<orgName type="institution">Universität Karlsruhe (TH)</orgName>
								<address>
									<postCode>76128</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Sanders</surname></persName>
							<email>sanders@ira.uka.de</email>
							<affiliation key="aff0">
								<orgName type="institution">Universität Karlsruhe (TH)</orgName>
								<address>
									<postCode>76128</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dominik</forename><surname>Schultes</surname></persName>
							<email>schultes@ira.uka.de</email>
							<affiliation key="aff0">
								<orgName type="institution">Universität Karlsruhe (TH)</orgName>
								<address>
									<postCode>76128</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Delling</surname></persName>
							<email>delling@ira.uka.de</email>
							<affiliation key="aff0">
								<orgName type="institution">Universität Karlsruhe (TH)</orgName>
								<address>
									<postCode>76128</postCode>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">74FDC5573C6789ED0819FE4163AA6CD0</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a route planning technique solely based on the concept of node contraction. The nodes are first ordered by 'importance'. A hierarchy is then generated by iteratively contracting the least important node. Contracting a node v means replacing shortest paths going through v by shortcuts. We obtain a hierarchical query algorithm using bidirectional shortest-path search. The forward search uses only edges leading to more important nodes and the backward search uses only edges coming from more important nodes. For fastest routes in road networks, the graph remains very sparse throughout the contraction process using rather simple heuristics for ordering the nodes. We have five times lower query times than the best previous hierarchical Dijkstrabased speedup techniques and a negative space overhead, i.e., the data structure for distance computation needs less space than the input graph. CHs can be combined with many other route planning techniques, leading to improved performance for many-to-many routing, transit-node routing, goal-directed routing or mobile and dynamic scenarios.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Planning optimal routes in road networks has recently attracted considerable interest in algorithm engineering because it is an important application that admits a lot of interesting algorithmic approaches. Many of these techniques exploit the hierarchical nature of road networks in some way or another.</p><p>Here we present a very simple approach to hierarchical routing. Assume the nodes of a weighted directed graph G = (V, E) are numbered 1..n in order of ascending 'importance'. We now construct a hierarchy by contracting the nodes in this order. A node v is contracted by removing it from the network in such a way that shortest paths in the remaining overlay graph are preserved. This property is achieved by replacing paths of the form u, v, w by a shortcut edge u, w . Note that the shortcut u, w is only required if u, v, w is the only shortest path from u to w.</p><p>We shall view the contraction process as a way to add all discovered shortcuts to the edge set E. We obtain a contraction hierarchy (CH). Section 2 gives more details.</p><p>In Section 3 we explain how the nodes are ordered. Although 'optimal' node ordering seems a quite difficult problem, already very simple local heuristics turn out to work quite well. The basic idea is to keep the nodes in a priority queue sorted by some estimate of how attractive it is to contract a node. The main ingredient of this heuristic estimate is the edge difference: The number of shortcuts introduced when contracting v minus the number of edges incident to v. The intuition behind this is that the contracted graph should have as few edges as possible. Even using only edge difference, quite good CHs are computed. However, further refinements are useful. In particular, it is important to contract nodes 'uniformly'.</p><p>For routing, we split the CH (V, E) into an upward graph G ↑ := (V, E ↑ ) with E ↑ := {(u, v) ∈ E : u &lt; v} and a downward graph G ↓ := (V, E ↓ ) with E ↓ := {(u, v) ∈ E : u &gt; v}. For a shortest path query from s to t, we perform a modified bidirectional Dijkstra shortest path search, consisting of a forward search in G ↑ and a backward search in G ↓ . If, and only if, there exists a shortest s-tpath in the original graph, then both search scopes eventually meet at a node v that has the highest order of all nodes in a shortest s-t-path. More details of the query algorithm are given in Section 4. Applications and refinements like dynamic routing (i.e., edge weights are allowed to change), many-to-many routing, and combinations with other speedup techniques can be found in Section 5. Section 6 shows that in many cases, we get significant improvements over previous techniques for large real world inputs. Lessons learned and possible future improvements are summarized in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>Since there has recently been extensive work on speed-up techniques, we can only give a very abridged overview with emphasis on the directly related techniques beginning with the closest kin. For a more detailed overview we refer to <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>. CHs are an extreme case of the hierarchies in highway-node routing (HNR) <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref> -every node defines its own level of the hierarchy. CHs are nevertheless a new approach in the sense that the node ordering and hierarchy construction algorithms used in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref> are only efficient for a small number of geometrically shrinking levels. We also give a faster and more space efficient query algorithm using G ↑ and G ↓ .</p><p>The node ordering in highway-node routing uses levels computed by highway hierarchies (HHs) <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b1">2]</ref>. Our original motivation for CHs was to simplify HNR by obviating the need for another (more complicated) speedup technique (HHs) for node ordering. HHs are constructed by alternating between two subroutines: Edge reduction is a sophisticated and relatively costly routine that only keeps edges required 'in the middle' of 'long-distance' paths. Node reduction contracts nodes. In the original paper for undirected HHs <ref type="bibr" target="#b5">[5]</ref>, node reduction only contracted nodes of degrees one and two, i.e., it removed attached trees and multihop paths. We originally viewed node contraction as a mere helper for the main workhorse edge reduction. For directed graphs <ref type="bibr" target="#b5">[5]</ref>, we needed a more general criterion which nodes should be contracted away. It turned out that the edge difference is a good way to estimate the cost of contracting a node v. In <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b7">7]</ref> this method is further refined to use a priority queue and to avoid parallel edges. All previous approaches to contraction had in common that the average degree of the nodes in the overlay graph would eventually explode. So it looked like an additional technique such as edge reduction or reaches would be a necessary ingredient of any high-performance hierarchical routing method. Perhaps the most important result of CHs is that using only (a more sophisticated) node contraction, we get very good performance.</p><p>The fastest speedup technique so far, transit-node routing <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b1">2]</ref>, offers a factor up to 40 times better query times than CHs. However, it needs considerably higher preprocessing time and space, is less amenable to dynamization, and, most importantly it relies on another hierarchical speedup technique for its preprocessing. We have preliminary evidence that using CHs for this purpose leads to improved performance.</p><p>Finally, there is an entirely different family of speedup techniques based on goal-directed routing. Combination of CHs with goal-directed routing is the subject of another paper <ref type="bibr" target="#b9">[9]</ref> that systematically studies such combinations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Contraction</head><p>Recall from the introduction that when contracting node v, we are dealing with an overlay graph G = (V , E ) with V = v..n and an edge set E that preserves shortest path distances wrt the input graph. In G , we face the following many-to-many shortest-path problem: For each source node u ∈ v + 1..n with (u, v) ∈ E and each target node w ∈ v + 1..n with (v, w) ∈ E , we want to compare the shortest-path distance d(u, w) with the shortcut length c(u, v) + c(v, w) in order to decide whether the shortcut is really needed. A simple way to implement this is to perform a forward shortest-path search in the current overlay graph G from each source, ignoring node v, until all targets have been found. We can also stop the search from u when it has reached distance</p><formula xml:id="formula_0">d(u, v) + max {c(v, w) : (v, w) ∈ E }.</formula><p>Our actual implementation uses a simple, asymmetric form of bidirectional search inspired by <ref type="bibr" target="#b10">[10]</ref>: For each target node w we perform a single-hop backward search. For each edge (x, w) ∈ E we store a bucket entry (c(x, w), w) with node x. This way, forward search from u can be limited to distance</p><formula xml:id="formula_1">c(u, v) + max w:(v,w)∈E c(v, w) -min x:(x,w)∈E c(x, w) .</formula><p>When reaching a node x, we scan its bucket entries. For each entry (C, w), we can infer that there is a path from u to w of length d(u, x) + C.</p><p>Since exact shortest path search for contraction can be rather expensive, we have implemented two ways to limit the range of searches: We can limit the number of hops (edges) used in any path u, . . . , w , and we can limit the total search space size of a forward search. Note that this has no influence on the correctness of subsequent queries in the CH as long as we make sure to always insert a shortcut (u, w) when we have not found a path from u to w witnessing that the shortcut is unnecessary. Also note that for hop limit two, our bidirectional approach obviates a full fledged Dijkstra search. It suffices to scan the edges leaving a source node u.</p><p>Let us now focus the discussion on the hop limit. We get a tradeoff between fast contraction 'now' for small hop limits and a more sparse graph with better query time and possible easier contraction 'later' for a large hop limit. In our experiments it turned out, that it makes sense to start with a hop limit as small as one and to later increase it. We switch from one hop limit to the next when the average degree of the overlay graph G exceeds a specified bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Node Ordering</head><p>As already mentioned in the introduction, our basic approach uses a priority queue whose minimum element contains the node looking most attractive to be contracted next. The priority used is a linear combination of several terms. In addition to the single terms used, the linear coefficients of the different terms are important, some of them can be found in Section 6. In this section we focus on different possible terms. One difficulty with this approach is that when node v is contracted, this might affect the priorities of other nodes. We use several techniques to handle this problem:</p><p>-We use lazy update, i.e., before actually contracting v, we update its priority.</p><p>If it now exceeds the priority of the second largest element v , we reinsert v and continue with v . This process is repeated until a consistent minimum is found. Note that (at least wrt the result of node ordering) lazy update obviates immediate updates when a priority increases. -We recompute the priority of the neighbors of v.</p><p>-We periodically reevaluate all priorities and rebuild the priority queue.</p><p>Edge Difference. Arguably the most important term is the edge difference. For computing it, node ordering uses the same heuristics for limiting search spaces as are later used in the actual contraction. <ref type="foot" target="#foot_0">1</ref>Uniformity. Using only the edge difference, one can get quite slow routing. For example, if the the input graph is a path, contraction would produce a linear hierarchy where most queries would again follow paths of linear length. In contrast, if we iteratively contract maximal independent sets, we would get a hierarchy where any query is finished in logarithmic time.</p><p>More generally, it seems to be a good idea, to contract nodes everywhere in the graph in a uniform way, rather than keep contracting nodes in a small region. We have tried several heuristics for choosing nodes uniformly out of which we present the two most successful ones. For all measures used here, a large value means that the node is contracted late.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deleted Neighbors:</head><p>We count the number of neighbors that have already been contracted. This includes neighbors reached via shortcuts. Obviously, this quantity can be maintained correctly by either lazy update or by updating the neighbors of a contracted node. This heuristics is very simple and can be computed efficiently. Voronoi Regions: Define the Voronoi-Region R(v) of a node v in an overlay graph as the set of nodes in the input graph that are closer to v than to any other node in the overlay graph. We use the square root of the size of the Voronoi-region as a term in the priority function. By preferably contracting small Voronoi regions, we can hope that the nodes of the overlay graph are spread uniformly over the network. When v is contracted, its neighboring Voronoi regions will 'eat up' R(v). The necessary computations can be made using O(|R(v)|) steps of Dijkstra's algorithm <ref type="bibr" target="#b11">[11]</ref>. If we always contract Voronoi regions of size at most a constant times the average region size, we can easily show that the total number of Dijkstra-steps for maintaining the size of the Voronoi regions is O(n log n), i.e., computing Voronoi regions is reasonably efficient. Since Voronoi regions can only grow, lazy update ensures that the priority queue works correctly wrt this term of the priority function.</p><p>There are a number of further, optional parameters of the priority function that turn out to further improve the hierarchy at the cost of increased time for node ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cost of contraction.</head><p>A time consuming part of the contraction are the forward shortest-path searches to decide the necessity of shortcuts. So for example, we can use the sum of these search space sizes as a priority term. Note that this quantity can change beyond the direct neighborhood of the contracted node, i.e., our update rules are only heuristics.</p><p>Cost of queries. One can try to estimate how contracting nodes affects the size of query search spaces. We have implemented the following simple estimate Q(v) that can be shown to be an upper bound for the number of hops of a path s, . . . , v explored during a query: Initially,</p><formula xml:id="formula_2">Q(v) = 0. When v is contracted then for each neighbor u of v, Q(u):= max(Q(u), Q(v) + 1).</formula><p>Global measures. We can prefer contracting globally unimportant nodes based on some path based centrality measure such as (approximate) betweenness <ref type="bibr" target="#b12">[12]</ref> or reach <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b6">6]</ref>. Generally speaking, one can come up with many heuristic terms. But one gets an inflation of tuning parameters. Therefore, in the experiments we try to keep the number of actually used terms small, we use the same set of parameters for different inputs, and we make some sensitivity analysis to find out how robust the parameter choices are.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Query</head><p>In the introduction we have already outlined the basic approach which we shall now describe in more detail. An algorithm that already works quite well performs complete Dijkstra searches from s in G ↑ and from t in G ↓ . We have</p><formula xml:id="formula_3">Lemma 1. d(s, t) = min {d(s, v) + d(v, t) : v is settled in both searches}.</formula><p>Proof. We only give a proof outline for self-containedness since the CH-query is a special case of the HNR-query for which a detailed yet simple correctness proof is given in <ref type="bibr" target="#b1">[2]</ref>. In particular, here we only consider the case where shortest paths are unique.</p><p>Let v denote the largest<ref type="foot" target="#foot_1">2</ref> node on the shortest path P from s to t. We first claim that the sequence of prefix maxima<ref type="foot" target="#foot_2">3</ref> of P forms the shortest path from s to v in the upward graph G ↑ . If s = v there is nothing to prove. Otherwise, consider any pair (u, w) of subsequent prefix maxima in P and the overlay graph G = (u..n, E ) existing at some point during contraction. Since the shortest path from u to w uses only interior nodes smaller than u, and by definition of the properties of an overlay graph, (u, w) ∈ E and c(u, w) = d(u, w). Moreover, u &lt; w and hence (u, w) ∈ G ↑ . Analogously, the sequence of suffix maxima of P forms the shortest path from v to t in the downward graph.</p><p>There are two refinements to the complete search algorithm (that are also analogous to the HNR-query algorithm <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref>). The query alternates between forward and backward search. Whenever we settle a node in one direction that is already settled in the other direction, we get a new candidate for a shortest path. Search is aborted in one direction if the smallest element in the queue is at least as large as the best candidate path found so far. This does not affect correctness, since additional settled nodes in this direction cannot possibly contribute to better solutions.</p><p>We also prune the search space using the stall-on-demand technique: Before a node v is settled at distance d(v) in the forward search, it uses the information available in G ↓ to inspect downward edges (w, v) with w &gt; v. If d(w) + c(w, v) &lt; d(v), then the search can be stopped (stalled ) at v with stalling distance d(w) + c(w, v) since the computed distance to v is suboptimal so that a continuation of the search from v would be futile. Such stalled nodes are settled but their incident edges are not relaxed, leading to a considerably smaller search space. Moreover, stalling can propagate to further nodes x in the neighborhood of v, if the path over w in G to x is shorter than the currently found path to x in G ↑ . We perform a local BFS from v using the edges available in G ↑ or G ↓ . <ref type="foot" target="#foot_3">4</ref>The search stops at nodes that are not being stalled. To ensure correctness, we unstall a node x if a shorter path in G ↑ to x than the current one in G ↑ is found. Stall-on-demand is also applied to the backward search in the same way.</p><p>The graphs G ↑ and G ↓ can be stored in one data structure, using two direction flags for each edge to indicate whether it belongs to G ↑ or G ↓ . Irrespective of the direction flags, each edge (u, v) is stored only once, namely at the smaller node, which complies with the requirements of both forward and backward search (including the stall-on-demand technique). In particular, this also applies to undirected edges {u, v} with the same weight in both directions. In contrast, an efficient implementation of Dijkstra's (even unidirectional) algorithm needs to store such undirected edges {u, v} both at u and v. This is the reason why we may need less space than Dijkstra's algorithm for the original graph, even though we have to insert shortcuts.</p><p>Outputting Paths. As all routing techniques that use shortcuts, we need a way to unpack them in order to obtain a shortest path in the input graph. This is particularly simple for CHs since each shortcut (u, w) bypasses exactly one node v. We therefore obtain a simple recursive unpacking routine. In order to implement this efficiently, we need to store v together with the shortcut somewhere. Note that this information is not easily obtained just from G ↑ or G ↓ , i.e., our observation that we may need less space than the input graph only holds when path unpacking is not required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Applications</head><p>Changing all Edge Weights. In CHs we can distinguish between two main phases of preprocessing, node ordering and hierarchy construction. Similar to highwaynode routing, we do not have to redo node ordering when the edge weights change -for example when we switch from driving times for a fast car to a slow truck. Hierarchy construction ensures correctness for all node orderings. We will see that the resulting hierarchies are almost as good as hierarchies where node ordering has been repeated. The intuition behind this is that most important nodes remain important even if the actual edge weights change -both sports cars and trucks are fastest on the motorway.</p><p>Changing some Edge Weights. Since CHs are a special case of HNR <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref>, we can also adopt the successful approaches used there for routing in presence of some changed edges (e.g., due to traffic jams).</p><p>Many-to-Many Routing. In <ref type="bibr" target="#b10">[10]</ref> we developed an algorithm based on highway hierarchies that finds all shortest path distances between a set S of source nodes and a set T of target nodes. The idea is to perform only |T | backward searches, store the resulting search spaces appropriately and then to perform |S| forward searches that use the stored information on the backward searches to find the shortest path distances. As explained in <ref type="bibr" target="#b1">[2]</ref>, this works for a large family of nongoal-directed hierarchical routing techniques including highway-node routing and reach-based routing <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b6">6]</ref>. CHs are particularly well suited for many-to-many routing because they have very small search spaces and because for the backward search spaces we only need to store nodes that are not stalled.</p><p>Distance Oracles for Replacing Large Distance Tables. CH search-spaces are so small that we can drop the distance tables computed by many-to-many routing and instead store the search spaces from S and T as arrays of node-distance pairs sorted by node-id. Then an s-t query amounts to intersecting the search spaces for s and t and computing the minimum resulting distance. This intersection operation is similar to binary merging and thus runs very fast and cache efficiently.</p><p>Transit-Node Routing. Transit-node routing <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b1">2]</ref> is currently the fastest static routing technique available. Its main disadvantage compared to simpler techniques is that it needs considerably more preprocessing time. The preprocessing for transit-node routing is essentially a generalization of many-to-many routing. Hence, we can also do preprocessing using CHs and expect to obtain an improvement. We can use the nodes designated as most important by node ordering to define the sets of transit nodes. The edge difference criterion used by node ordering might help to identify transit-node sets that imply small sets of access nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Combination with Other Speedup Techniques.</head><p>There are interesting synergies between hierarchical speedup techniques and goal-directed methods such as landmark A * <ref type="bibr" target="#b6">[6]</ref> or arc flags <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b15">15]</ref>. Goal-directed techniques become cheaper in terms of preprocessing time and space if they are only applied to a core obtained after some contraction <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b7">7]</ref>. Since CHs are a fast, flexible, effective, and very fine-grained approach to this contraction, they seem best suited for this. The resulting overall query time is often better than any of the techniques alone. For example, an integration of CHs and arc-flags is so fast that it almost achieves the query times of transit-node routing using less space <ref type="bibr" target="#b9">[9]</ref>. Another interesting example is SHARC-routing <ref type="bibr" target="#b7">[7]</ref> which applies a sophisticated, multilevel variant of arc-flags to an network enriched with shortcuts. This has the advantage that it yields a unidirectional, very simple query algorithm that takes hierarchy into account indirectly via the arc flags.</p><p>Perhaps most importantly, not all graph families are as well behaved as road networks with travel time weights with respect to contraction. So it sometimes seems to be the best idea to stop contraction at some point and solely rely on goal-directed techniques for the core <ref type="bibr" target="#b9">[9]</ref>.</p><p>Node contraction started out as an ingredient of highway hierarchies (HHs). It would be interesting to see how good HHs would perform if we would reintegrate CHs into HHs. We could expect a more sparse network in the upper levels but also a more complicated, less focused query algorithm. Our guess would be that for road networks, we cannot expect an additional improvement but perhaps we should keep this approach in mind for network where contraction does not work so well.</p><p>Similarly, we could integrate CHs with reach-based routing <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b6">6]</ref>. CHs could contribute the shortcuts to be used, possibly simplifying the reach approximations during preprocessing. During the query, we could use reach values to prune the search additionally.</p><p>Implementation on Mobile Devices. Due to its small memory overhead and search space, CHs are a good starting point for route planning on mobile devices. This is the subject of a separate paper <ref type="bibr" target="#b18">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experiments</head><p>Environment. Experiments have been done on one core of a single AMD Opteron Processor 270 clocked at 2.0 GHz with 8 GB main memory and 2 × 1 MB L2 cache, running SuSE Linux 10.3 (kernel 2.6.22). The program was compiled by the GNU C++ compiler 4.2.1 using optimization level 3.</p><p>Test Instances. Our experiments in this section have been done on a road network of Western Europe<ref type="foot" target="#foot_4">5</ref> with 18 029 721 nodes and 42 199 587 directed edges, which has been made available for scientific use by the company PTV AG. For each edge, its length and one out of 13 road categories (e.g., motorway, national road, regional road, urban street) is provided so that an expected travel time can be derived, which we use as edge weight. Results for other test instances can be found in the full paper.</p><p>Different Variants. Although the basic idea of CHs is simple, we have many tuning parameters that should be set carefully and we should verify that these choices are robust in the sense that they work reasonably well for different instances. Therefore, we build up the system incrementally. Tab. 1 shows the most fundamental performance parameters for a number of increasingly sophisticated variants. For comparison, we add the times for the fastest variant of highwaynode routing (HNR) from [3] using the same system environment. Note that this version of HNR outperforms all previous speedup techniques with comparable preprocessing time so that focusing on HNR is meaningful.</p><p>Already using only the edge difference we obtain query times better than HNR. However, the preprocessing time and space is quite large. Just adding the uniformity parameter based on number of deleted neighbors (Line ED), we obtain more than four times better query time than HNR. The time for hierarchy construction becomes better than HNR once we take the search space size into account (letter S). This also improves node ordering if we limit the size of a local search (letter L).</p><p>To improve the preprocessing times, it helps to limit the number of hops in the searches during preprocessing and to take search space sizes for contraction into account. Figure <ref type="figure" target="#fig_0">1</ref> shows the development of the average degree during node contraction for different hop limits. We see that for hop limits below four, the average degree eventually explodes. We choose limits for the average degree that switch to a larger hop limit sufficiently before this explosion. 6 Interestingly, this also further improves query time. The algorithm in Line EDS1235 of Tab. 1 outperforms HNR in all respects and with a wide margin with respect to query time and hierarchy construction 7 time. As explained in Section 5, the latter time is particularly interesting when we want to exchange the edge weight function. We use this variant as our main economical 8 variant for further experiments. 6 1 → 2 hops @ degree 3.3, 2 → 3 @ 10, 3 → 5 @ 10. After switching to hop limit 3, we remove all edges e for which there is a witness with at most 3 edges that e is not a shortest path. This reduces the average degree and leaves some time before we have to switch to hop limit 5. 7 There is a version of HNR in <ref type="bibr" target="#b2">[3]</ref> with about two times faster hierarchy construction but with slower queries and more space consumption. 8 Coefficients for priority: E=190, D=120, S=1. By investing more preprocessing time, we can further improve the query performance. We abandon hop limitations and take the path-length estimate Q(v) into account. The resulting algorithm, Line EVSQL in Tab. 1, is used as our aggressive <ref type="foot" target="#foot_5">9</ref> variant for further experiments. Using betweenness<ref type="foot" target="#foot_6">10</ref> approximations (letter W) can improve the query time by additional 3%. <ref type="foot" target="#foot_7">11</ref> It is interesting to compare different indicators for query performance between aggressive CH and HNR. CHs are 5 times faster although the number of settled nodes is only 2.6 times smaller. This is in part due to a simpler data structure <ref type="foot" target="#foot_8">12</ref> and in part due to a far larger improvement (factor 6.4) wrt the number of relaxed edges. For many-to-many routing, we are mostly interested in the number of non-stalled nodes, which make the bucket-scan operations more expensive. In this respect, CHs are a factor 3 better.</p><p>Local Queries. Since random queries are unrealistic for large graphs, Fig. <ref type="figure">2</ref> shows the distributions of query times for various degrees of locality <ref type="bibr" target="#b3">[4]</ref>. We see a uniform improvement over HNR and small fluctuations in query time. This is further underlined in Fig. <ref type="figure">3</ref> where we give upper bounds for the search space size of all n × n possible queries (see <ref type="bibr" target="#b5">[5]</ref> for the algorithm). We see a superexponential decay of the probability to observe a certain search-space size and maximal search-space size bound less than 2.5 times the size of the average actual search-space sizes (see also Tab. 1).  <ref type="bibr" target="#b19">[19]</ref>: each box spreads from the lower to the upper quartile and contains the median, the whiskers extend to the minimum and maximum value omitting outliers, which are plotted individually. The queries generated for x-value r are random s-t-queries under the constraint that t is the r-th node visited by Dijkstra's algorithm (see also <ref type="bibr" target="#b3">[4]</ref>).</p><p>Unpacking Paths needs an average of 317 μs for the aggressive variant and 332 μs for the economical variant. The difference between the two variants is bigger for the space overhead which is 5.8 B/node and 10.8 respectively. Among the path unpacking times we have seen, this is only outperformed by the fastest variant for highway hierarchies in <ref type="bibr" target="#b5">[5]</ref> that explicitly stores completely unpacked representations of the most important shortcuts. Note that this optimization works for any shortcut-based speedup technique including CHs.</p><p>Many-to-Many Routing for a random 10000 × 10000 table using the aggressive variant needs 10.2 s. This is about six times faster than the highway-hierarchybased code from <ref type="bibr" target="#b10">[10]</ref> and more than twice as fast as the HNR-based implementation from <ref type="bibr" target="#b1">[2]</ref>. Our current implementation of many-to-many routing does not (yet) use the asymmetry between forward and backward search that has proved useful in <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b1">2]</ref>. Hence, we can expect further improvements.</p><p>Exchanging the Edge Weight Function. The table below shows the hierarchy construction time and query time using our economical variant for different speed profiles which come from the company PTV (see also <ref type="bibr" target="#b2">[3]</ref>). The times in brackets refer to the case when node ordering was done with the same speed profile and the main times are for the case that node ordering was done for our default speed profile. Transit-Node Routing. We used the node ordering with the aggressive variant of CHs to determine the transit-node sets for the implementation from <ref type="bibr" target="#b1">[2]</ref>. As we hoped for, this resulted in a reduced number of access nodes, which in turn results in better query time (4.3 → 3.4 μs) and lower space consumption (247 → 204 Byte/node), compared to <ref type="bibr" target="#b1">[2]</ref>. Preliminary experiments suggest that we get further improvements with an additional term for node ordering that takes into account the number of edges of the input graph that make up a shortcut. We have not yet implemented a CH-based preprocessing so that it is too early to judge the effect of CHs on preprocessing time. It is quite likely however, that we will also see an improvement in preprocessing time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>CHs are a simple and efficient basis for many hierarchical routing methods in road networks. The experiments in <ref type="bibr" target="#b9">[9]</ref> suggest that CHs also work well for other sparse networks with high locality such as transportation networks, or sparse unit-disk graphs. For more dense networks, CHs can be used for an initial contraction phase whereas a goal-directed technique is applied to the resulting core network. Several further improvements might be possible. The performance of node ordering is so far only slightly better than the HH based method used in <ref type="bibr" target="#b2">[3]</ref> for HNR. One reason is that we perform many similar searches that might be saved if we would reuse search spaces. The main problem with reuse is that storing search spaces would cost a lot of space. But perhaps we can partition large networks into smaller networks; perform the node ordering separately for each subnetwork; and only then merge the pieces into a global order. To a lesser extend such an optimization might also accelerate hierarchy construction. As a side effect we might also obtain a way to update the search space sizes of all nodes affected by a node contraction.</p><p>Although we have established that uniformity is important for good node ordering, it is not so clear whether the two uniformity measures we have introduced are the final word. In particular, the right measure might depend on the application. For example, our current code for transit-node routing uses a geometric locality filter and hence it might be good if the uniformity measure would take geometry into account.</p><p>We have already demonstrated that CHs yield improved preprocessing times when changing the entire cost function. We still have to try how well the dynamization techniques for changing few edge weights from <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref> translate.</p><p>Last but not least, we are now developing a method for fast routing in road networks with time-dependent edge weights. We hope that the simplicity and efficiency of CHs will give us a good starting point for this challenging task. The good performance of CHs for (unrolled) transportation networks observed in <ref type="bibr" target="#b9">[9]</ref> may be an indicator that this will work well.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Average degree development for different hop limits</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Performance of various node ordering heuristics. Terms of the priority function: E=edge difference, D=deleted neighbors, S=search space size, W=relative betweenness, V= √ Voronoi region size, L=limit search space on weight calculation, Q=upper bound on edges in search paths. Digits denote hop limits for testing shortcuts. Space overhead is wrt an adjacency array for bidirectional Dijkstra that stores each directed edge at both endpoints. The bottom line shows the performance for highway-node routing using the code from<ref type="bibr" target="#b2">[3]</ref>.</figDesc><table><row><cell>method</cell><cell>node</cell><cell cols="4">hierarchy query nodes non-stalled edges</cell><cell>space</cell></row><row><cell></cell><cell cols="3">ordering [s] construction [s] [μs] settled</cell><cell cols="3">nodes relaxed overhead</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>[B/node]</cell></row><row><cell>E</cell><cell>13010</cell><cell cols="2">1739 670 1791</cell><cell>1127</cell><cell>4999</cell><cell>-1.6</cell></row><row><cell>ED</cell><cell>7746</cell><cell>1062 183</cell><cell>403</cell><cell cols="2">236 1454</cell><cell>-2.3</cell></row><row><cell>ES</cell><cell>5355</cell><cell>123 245</cell><cell>614</cell><cell cols="2">366 1803</cell><cell>-3.5</cell></row><row><cell>ESL</cell><cell>1158</cell><cell>123 292</cell><cell>758</cell><cell cols="2">465 2169</cell><cell>-3.5</cell></row><row><cell>EDL</cell><cell>2071</cell><cell>576 187</cell><cell>418</cell><cell cols="2">243 1483</cell><cell>-2.3</cell></row><row><cell>EDSL</cell><cell>1414</cell><cell>165 175</cell><cell>399</cell><cell cols="2">228 1335</cell><cell>-2.6</cell></row><row><cell>ED5</cell><cell>634</cell><cell>98 224</cell><cell>470</cell><cell cols="2">250 1674</cell><cell>-1.6</cell></row><row><cell>EDS5</cell><cell>652</cell><cell>99 213</cell><cell>462</cell><cell cols="2">256 1651</cell><cell>-2.1</cell></row><row><cell>EDS1235</cell><cell>545</cell><cell>57 223</cell><cell>459</cell><cell cols="2">234 1638</cell><cell>0.6</cell></row><row><cell>EDSQ1235</cell><cell>591</cell><cell>64 211</cell><cell>440</cell><cell cols="2">236 1621</cell><cell>1.0</cell></row><row><cell>EDSQL</cell><cell>1648</cell><cell>199 173</cell><cell>385</cell><cell cols="2">220 1378</cell><cell>-2.1</cell></row><row><cell>EVSQL</cell><cell>1627</cell><cell>170 159</cell><cell>368</cell><cell cols="2">209 1181</cell><cell>-2.7</cell></row><row><cell>EDSQWL</cell><cell>1629</cell><cell>199 163</cell><cell>372</cell><cell cols="2">218 1293</cell><cell>-2.5</cell></row><row><cell>EVSQWL</cell><cell>1734</cell><cell>180 154</cell><cell>359</cell><cell cols="2">208 1159</cell><cell>-3.0</cell></row><row><cell>HNR</cell><cell>594</cell><cell>203 802</cell><cell>957</cell><cell cols="2">630 7561</cell><cell>9.5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>12 213 2 14 2 15 2 16 2 17 2 18 2 19 2 20 2 21 2 22 2 23 2 24 Local queries, box-and-whisker plot</figDesc><table><row><cell>query time [μs]</cell><cell>200 400 600 800 1000 1200</cell><cell>CH aggressive CH economical HNR</cell><cell>200 400 600 800 1000 1200</cell></row><row><cell></cell><cell>0</cell><cell></cell><cell>0</cell></row><row><cell></cell><cell></cell><cell>2 11 2 Dijkstra rank</cell><cell></cell></row><row><cell cols="2">Fig. 2.</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Updating neighbors of contracted nodes and lazy update 'almost' suffice to keep the priorities up to date wrt the edge difference. However, with some highly constructed example, not all priorities are updated in time when the search horizon is limited.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Recall that nodes are considered to be numbered during node ordering.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>i.e., the sequence of nodes ui on P = s = u1, u2, . . . , u k = t with the property that ui &gt; max {u1, u2, . . . , ui-1}.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We also have a version that additionally exploits the parent pointers of the shortest path tree. This slightly decreases search space but slightly increases query time.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Austria, Belgium, Denmark, France, Germany, Italy, Luxembourg, the Netherlands, Norway, Portugal, Spain, Sweden, Switzerland, and the UK.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_5"><p>Coefficients for priority: E=190, V=60, S=1, Q=145, L=1000.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_6"><p>The execution times for betweenness approximation<ref type="bibr" target="#b12">[12]</ref> are not included in Tab. 1.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_7"><p>Preliminary experiments with reach-approximations were not successful.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_8"><p>The HNR implementation from<ref type="bibr" target="#b2">[3]</ref> has to compare level information to find out which edges should be relaxed.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Partially supported by DFG grant SA 933/1-3, and by the Future and Emerging Technologies Unit of EC (IST priority -6th FP), under contract no. FP6-021235-2 (project ARRIVAL).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Engineering fast route planning algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WEA 2007</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Demetrescu</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4525</biblScope>
			<biblScope unit="page" from="23" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Route Planning in Road Networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dynamic highway-node routing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WEA 2007</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Demetrescu</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4525</biblScope>
			<biblScope unit="page" from="66" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Highway hierarchies hasten exact shortest path queries</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESA 2005</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Brodal</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Leonardi</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">3669</biblScope>
			<biblScope unit="page" from="568" to="579" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Engineering highway hierarchies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESA 2006</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Azar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Erlebach</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4168</biblScope>
			<biblScope unit="page" from="804" to="816" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Better landmarks within reach</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Werneck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WEA 2007</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Demetrescu</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4525</biblScope>
			<biblScope unit="page" from="38" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">SHARC: Fast and robust unidirectional routing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Delling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Workshop on Algorithm Engineering and Experiments</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>ALENEX</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast routing in road networks with transit nodes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bast</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Funke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">316</biblScope>
			<biblScope unit="issue">5824</biblScope>
			<biblScope unit="page">566</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Combining hierarchical and goal-directed speed-up techniques for Dijkstra&apos;s algorithm</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Delling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schieferdecker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WEA 2008</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5038</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Computing manyto-many shortest paths using highway hierarchies</title>
		<author>
			<persName><forename type="first">S</forename><surname>Knopp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Workshop on Algorithm Engineering and Experiments</title>
		<imprint>
			<biblScope unit="issue">ALENEX</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Goal directed shortest path queries using Precomputed Cluster Distances</title>
		<author>
			<persName><forename type="first">J</forename><surname>Maue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Matijevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WEA 2006</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Àlvarez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Serna</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4007</biblScope>
			<biblScope unit="page" from="316" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Better approximation of betweenness centrality</title>
		<author>
			<persName><forename type="first">R</forename><surname>Geisberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Algorithm Engineering and Experiments (ALENEX</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Reach-based routing: A new approach to shortest path algorithms optimized for road networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gutman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Algorithm Engineering and Experiments (ALENEX)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="100" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An extremely fast, exact algorithm for finding shortest paths in static networks with geographical background</title>
		<author>
			<persName><forename type="first">U</forename><surname>Lauther</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Geoinformation und Mobilität -von der Forschung zur praktischen Anwendung</title>
		<meeting><address><addrLine>Münster</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="219" to="230" />
		</imprint>
	</monogr>
	<note>IfGI prints</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Acceleration of shortest path and constrained shortest path computation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Köhler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Möhring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schilling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WEA 2005</title>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3503</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Highway hierarchies star</title>
		<author>
			<persName><forename type="first">D</forename><surname>Delling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>In: 9th DIMACS Implementation Challenge [20</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Better landmarks within reach</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Werneck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>In: 9th DIMACS Implementation Challenge [20</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Mobile Route Planning</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Schultes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Vetter</surname></persName>
		</author>
		<ptr target="http://algo2.iti.uka.de/schultes/hwy/" />
	</analytic>
	<monogr>
		<title level="m">preparation</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<ptr target="http://www.dis.uniroma1.it/∼challenge9/" />
		<title level="m">R Development Core Team: R: A Language and Environment for Statistical Computing</title>
		<imprint>
			<date type="published" when="2004">2004. 2006</date>
		</imprint>
	</monogr>
	<note>20. 9th DIMACS Implementation Challenge: Shortest Paths</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
