<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficiently Indexing Large Sparse Graphs for Similarity Search</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Guoren</forename><surname>Wang</surname></persName>
							<email>wanggr@mail.neu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">College of Information Science and Engineering</orgName>
								<orgName type="department" key="dep2">Heping District</orgName>
								<orgName type="institution">Northeastern University</orgName>
								<address>
									<addrLine>Wenhua Road 11-3</addrLine>
									<settlement>Shenyang, Liaoning</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bin</forename><surname>Wang</surname></persName>
							<email>wangbin@ise.neu.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">College of Information Science and Engineering</orgName>
								<orgName type="department" key="dep2">Heping District</orgName>
								<orgName type="institution">Northeastern University</orgName>
								<address>
									<addrLine>Wenhua Road 11-3</addrLine>
									<settlement>Shenyang, Liaoning</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE Computer Society</roleName><forename type="first">Xiaochun</forename><surname>Yang</surname></persName>
							<email>yangxiaochun@ise.neu.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">College of Information Science and Engineering</orgName>
								<orgName type="department" key="dep2">Heping District</orgName>
								<orgName type="institution">Northeastern University</orgName>
								<address>
									<addrLine>Wenhua Road 11-3</addrLine>
									<settlement>Shenyang, Liaoning</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Ge</forename><surname>Yu</surname></persName>
							<email>yuge@mail.neu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">College of Information Science and Engineering</orgName>
								<orgName type="department" key="dep2">Heping District</orgName>
								<orgName type="institution">Northeastern University</orgName>
								<address>
									<addrLine>Wenhua Road 11-3</addrLine>
									<settlement>Shenyang, Liaoning</settlement>
									<country key="CN">P.R. China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficiently Indexing Large Sparse Graphs for Similarity Search</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A7DCE01F123CDED8DED81E5632FD7332</idno>
					<idno type="DOI">10.1109/TKDE.2010.28</idno>
					<note type="submission">received 16 Apr. 2009; revised 6 Sept. 2009; accepted 7 Dec. 2009;</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph indexing</term>
					<term>similarity search</term>
					<term>-adjacent tree</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The graph structure is a very important means to model schemaless data with complicated structures, such as proteinprotein interaction networks, chemical compounds, knowledge query inferring systems, and road networks. This paper focuses on the index structure for similarity search on a set of large sparse graphs and proposes an efficient indexing mechanism by introducing the Q-Gram idea. By decomposing graphs to small grams (organized by -Adjacent Tree patterns) and pairing-up on those -Adjacent Tree patterns, the lower bound estimation of their edit distance can be calculated for candidate filtering. Furthermore, we have developed a series of techniques for inverted index construction and online query processing. By building the candidate set for the query graph before the exact edit distance calculation, the number of graphs need to proceed into exact matching can be greatly reduced. Extensive experiments on real and synthetic data sets have been conducted to show the effectiveness and efficiency of the proposed indexing mechanism.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ç</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>G RAPH similarity matching over a set of large graphs is a key issue in many graph-based applications. For example, the entities of a relational database can be considered as the vertices of a graph while the relation between those entities can be regarded as the edges across the corresponding vertices. Bioinformatical data such as proteinprotein interaction networks and chemical compounds, Web and XML documents, and road networks also have similar structures to graphs.</p><p>Conceptually, all data with a discrete structure can be represented in the form of graph, and the problem of designing and maintaining a graph index for similarity matching is quite prevalent in domains of many subjects.</p><p>There are various research problems related to graphs. For example, for a query graph, how to find out all the graphs in a graph set which are similar to the query graph. Whether two graphs are similar to each other can be judged by the size of their maximum common subgraph, but only theoretically, since the subgraph isomorphism test has been proved to be an NP-Complete problem <ref type="bibr" target="#b0">[1]</ref>. The sequential searching from a set of large graphs introduces a huge computational cost. Due to this low efficiency of a sequential search, a filter-andverification method is usually employed to speed up the search efficiency of graph similarity matching over a graph set and an index on the graph set can be used to filter the graph set to reduce candidates.</p><p>Similar to the Q-Gram <ref type="bibr" target="#b1">[2]</ref> index on strings, our indexing method focuses on how to break graphs into pieces, and evaluates the similarity of them through pairing-up corresponding pieces between the database and the query. However, indexing graphs is more challenging than indexing strings: the decomposition of strings is relatively simple, we only need to let a Q-length sliding window go from the beginning to the end, but decomposing graphs becomes more cumbersome. The first problem is how to define the "length" of the graph pieces. The second problem lies in the fact that we have to make sure the uniqueness of the decomposition: two isomorphic graphs should have the same decomposition. Furthermore, a minor number of modifications to a graph should only lead to a relatively small number of modified pieces, that is, the number of pairing-ups on the pieces should be correlated with the similarity of the graphs. Finally, the decomposition and pairing-up procedure should be efficient. For this purpose, an index should be designed to accelerate similarity.</p><p>Sparse graph can be used to model data in many applications such as road networks <ref type="bibr" target="#b2">[3]</ref>, natural language processing <ref type="bibr" target="#b3">[4]</ref>, and protein interaction networks <ref type="bibr" target="#b4">[5]</ref>. Beasley and Christofides <ref type="bibr" target="#b2">[3]</ref> use a sparse feasibility graph to model road networks to solve the problems of vehicle routing. Nallapati et al. <ref type="bibr" target="#b3">[4]</ref> propose sparse word graph to describe the correlations between words. Lin et al. <ref type="bibr" target="#b4">[5]</ref> propose a prediction algorithm of protein functions based on protein interaction data, which can be represented large sparse graphs. In these sparse graph applications, graph similarity search is an important issue. For example, a biology scientist might want to know the relationship between two protein interaction networks. Another example can be found in the field of chemistry, where one might want to find all compounds from a database with a certain substructure. Motivated by these applications, we propose -Adjacent Tree (-AT ) pattern for graph decomposition and indexing to solve the similarity search of sparse graphs. Given two graphs, we decompose them into -AT patterns (like Q-Gram decomposition of strings), then use the number of their common -AT patterns for edit distance estimation. Experimental results show that this indexing method for filtering sparse graphs is relatively fast and has a good accuracy when the querying edit distance threshold is not large.</p><p>The rest of this paper is organized as follows: Section 2 introduces the research works related to this paper. Section 3 presents the -adjacent tree index, including basic definitions, the edit operations adopted in this paper, problem statement, and the filtering principle based on the concept of -adjacent tree. Section 4 describes the implementation techniques of -adjacent tree index, including the construction and maintenance algorithms of -adjacent tree index. Section 5 gives the performance evaluation on the proposed index. Finally, Section 6 concludes the paper and highlights the future works.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Because subgraph isomorphism is an NP-complete problem <ref type="bibr" target="#b0">[1]</ref>, a filter-and-verification method is usually employed to speed up the search efficiency of graph similarity matching over a graph set. Since the filtering phase is the key issue to improve the search efficiency, a lot of indexing techniques have been proposed recently for speeding up filtering <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref>. Most of the existing research works on graph indexing can be grouped into two categories: frequent-subgraph-based indexing and graph-decomposition-based indexing.</p><p>Motivated by path-based indexing methods <ref type="bibr" target="#b18">[19]</ref> for managing semistructured data, Yan et al. <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref> introduce a novel indexing structure referred to as G-Index based on frequent subgraph patterns. It makes use of frequent subgraph structures as the basic indexing features. Shang et al. <ref type="bibr" target="#b7">[8]</ref> propose a novel indexing technique QuickSI to efficiently compute verification phase for testing subgraph isomorphism and a new feature-based indexing method is developed to accommodate QuickSI in the filtering phase. Yan et al. <ref type="bibr" target="#b8">[9]</ref> propose a structure filtering algorithm Grafil to filter out graphs without performing pairwise similarity computations. They point out that the filtering effectiveness and efficiency greatly depend on the quality of selected features. Cheng et al. <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref> propose a nested inverted-index called F G-index to avoid candidate verification by exploiting frequent subgraphs and edges as indexing features. However, when encountering infrequent queries, the method performs poorly, as infrequent subgraphs are not incorporated into the FG-Index. On the other hand, Chen et al. <ref type="bibr" target="#b11">[12]</ref> investigate an interesting graph containment search problem, and a contrast subgraph-based indexing model cIndex is proposed to solve this problem.</p><p>Frequent-subgraph-based indexing methods are also called feature-based indexing methods. They have two main shortcomings. One is that the effectiveness and efficiency of such kind of methods depend on the quality of selected features. The other is that it is difficult to construct and maintain the index because the frequent subgraph mining algorithm usually takes a very long time to compute <ref type="bibr" target="#b19">[20]</ref>.</p><p>To compensate for the latter shortcoming, the authors of <ref type="bibr" target="#b12">[13]</ref> and <ref type="bibr" target="#b13">[14]</ref> propose frequent-subtree-based indexing methods called T reeP i and Closure-T ree. The T reeP i approach indexes a graph set by using only subtree patterns to accelerate the filtering procedure, while the Closure-T ree approach uses the data structure called ClosureT ree to organize a B-tree-like index on the graph set. These new works also lead to discussions on the optimum pattern selection on graph indexing. Zhao et al. <ref type="bibr" target="#b14">[15]</ref> discuss the filtering ability among Path, Tree, and Graph, based on the study on many experiment results, and a conclusion of Tree þ Á ! Graph is drawn by the authors. Although subtree-based indexing methods alleviate the latter shortcoming, they still suffer from the former shortcoming like frequent-subgraph-based methods.</p><p>In graph-decomposition-based indexing methods, graph decomposition is applied directly to answering questions of isomorphism and subgraph isomorphism. Graph decomposition has been adopted before to the problems of isomorphism and subgraph isomorphism for planar graphs <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>. The method proposed in <ref type="bibr" target="#b15">[16]</ref> partitions a planar graph into pieces of small trees, and dynamic programming is applied within each piece. With the method, the subgraph isomorphism problem can be solved in linear time. Kukluk et al. <ref type="bibr" target="#b16">[17]</ref> have proposed an algorithm for isomorphism testing of planar graphs based on the decomposition of a graph into biconnected components. Williams et al. <ref type="bibr" target="#b17">[18]</ref> have developed three kinds of graph decomposition schemas, Clique Decomposition, Modular Decomposition, and Node Label Decomposition (NLD) <ref type="bibr" target="#b20">[21]</ref> to decompose a graph set, and Directed Acyclic Graphs (DAGs) are constructed to describe the results of a graph decomposition and a Graph Decomposition Index (GDI) is proposed to support graph similarity search. Tian and Patel <ref type="bibr" target="#b21">[22]</ref> have proposed an indexing method by incorporating graph structural information in a hybrid index structure called NH-index.</p><p>Graph decomposition indexing methods suffer from two main drawbacks. The first is that they have to enumerate all connected subgraphs, and therefore, complexity of graph decomposition is exponential to the graph size that is being decomposed. The other is that the frequency information existing in the graph decomposition results is not utilized for improving the efficiency of graph similarity search.</p><p>For either frequent subgraphs or decomposed subgraphs, they can be represented as sequences based on graph encoding techniques and graph similarity searching can be converted into subsequence matching. Jiang et al. <ref type="bibr" target="#b22">[23]</ref> have proposed a sequencing method called gString based on the chemical semantics in chemical compound databases. Zou et al. <ref type="bibr" target="#b23">[24]</ref> have proposed a spectral graph encoding method called GCoding, and a two-step filtering process is proposed based on the encoding schema to reduce the checking cost in the filtering phase.</p><p>In this paper, we propose a novel graph decomposition method called -Adjacent T ree (-AT ). The method is inspired by the idea of "Q-Gram" from string matching area. A graph is decomposed into a set of -Adjacent Trees and the decomposed results are indexed by a -AT index. A lower bound of the edit distance between graphs is derived and used for filtering graphs. The lower bound lemma guarantees the absence of false negatives. The proposed method incorporates both graph decomposition methods and frequent subgraph methods. Therefore, it can both control the results of decomposed subgraphs by tuning the value and make full use of the frequency information about decomposed subgraphs to improve the efficiency of the filtering phase.</p><p>In summary, we make the following contributions:</p><p>. A novel graph decomposition method called -Adjacent T ree (-AT ) is proposed to index graphs for graph similarity search. The method is inspired by the idea of "Q-Gram" from string matching area. . We get an inequality between the edit distance and the number of the common subgraphs of the two given graphs. With the inequality, we can filter a lot of graphs and improve the performance during graph similarity searching. . Extensive experiments have been conducted to validate the effectiveness and efficiency of the proposed method. Definition 2 (Subgraph Isomorphism). Let G and G 0 be two graphs. A subgraph isomorphism <ref type="bibr" target="#b5">[6]</ref> from G to G 0 is an injection f : V ðGÞ ! V ðG 0 Þ, iff it satisfies 1) 8u 2 V ðGÞ; fðuÞ 2 V ðG 0 Þ; W v ðuÞ ¼ W v ðfðuÞÞ and 2) 8"ðu; vÞ 2 EðGÞ; eðfðuÞ; fðvÞÞ 2 EðG 0 Þ, and W e ðeðu; vÞÞ ¼ W e ðeðfðuÞ; fðvÞÞÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Graph Isomorphism).</head><p>Let G and G 0 be two graphs. An isomorphism <ref type="bibr" target="#b5">[6]</ref> from </p><formula xml:id="formula_0">G to G 0 is a bijection f : V ðGÞ ! V ðG 0 Þ, iff it satisfies 1) 8u 2 V ðGÞ; fðuÞ 2 V ðG 0 Þ; W v ðuÞ ¼ W v<label>ðfðuÞÞ</label></formula><formula xml:id="formula_1">It is denoted by G &amp; G 0 . Graph G isomorphic to G 0 is denoted by G ffi G 0 if graph G is subgraph isomorphic to G 0 and it is denoted by G ffi G 0 if graph G is isomorphic to G 0 .</formula><p>If two graphs are isomorphic to each other, they can be considered to be equal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Problem Statement</head><p>We use graph edit distance to measure the similarity of two graphs. Intuitively, the edit distance of the two graphs is the minimum number of edit operations to convert one into another.</p><p>Definition 4 (Graph Edit Operation). A Graph Edit Operation (GEO) is an edit operation to transform one graph to another. The GEO can be one of the following six operations, as defined in <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b19">[20]</ref>:</p><p>1. Delete an edge from the graph.</p><p>2. Insert an edge between two disconnected vertices.</p><p>3. Delete an isolated vertex from the graph. 4. Insert an isolated vertex into the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>Change the label of a vertex. 6. Change the label of an edge.</p><p>It is obvious that we can convert any graph into another by a finite number of GEOs. To judge the similarity of two graphs, we define the Edit Distance between two graphs, which is the minimum number of GEOs needed to transform a graph to another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Graph Edit Distance). The Graph Edit Distance</head><formula xml:id="formula_2">Á G ðG 1 ; G 2 Þ between two graphs G 1 and G 2 is the minimum number of GEOs needed to transform G 1 to a graph isomorphic to G 2 .</formula><p>The definition of edit distance of two graphs gives us a measurement to quantify the difference of two graphs. Based on the definition above, we formally define the problem as follows:</p><p>Problem statement (Á G Query). Given a graph set D, a query graph Q, and a given threshold , find out all the graphs G in D satisfying the inequality Á G ðQ; GÞ . The returned graphs are the answer set of Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Filtering Principle</head><p>So far, we have introduced the measurement for quantifying the similarity between graphs and the problem definition of similarity search on graph sets. Next, we will discuss how to use -Adjacent Tree pattern decomposition for Á G lower bound estimation. To give readers a clear overview of our index method, we will use Q-Gram index as a comparison.</p><p>The main idea of Q-Gram is as follows: For each letter in a string, keep its small continuous gram (a short substring with this letter as its center). As such, an N-length string can have N grams in its Q-Gram set, each gram is of length Q. Q-Gram decomposition has overlapping, but it can make sure that 1) two same strings have identical Q-Gram sets and 2) any edit operation will only affect a limited number of grams. These two properties make it feasible to perform string edit distance query filtering, since the number of matched Q-Grams is correlated with the edit distance.</p><p>Instinctively, one can apply the reasoning behind the Q-Gram method to the problem of graph similarity matching. For each vertex of a graph, we can identify a small subgraph within the graph with this vertex as its center, and let all those subgraphs to be the "Grams" of the graph. This kind of "Gram" obviously satisfies the two properties stated above, so the pairing-up number of "Grams" between two graphs can be used to evaluate their graph edit distance. This is the basic idea of our index, but is technically not good enough, since the "Grams" are still graph patterns, and the pairing-up on those patterns can still be slow (depending on slow isomorphism test). To avoid the structural complexity of graph patterns, we use the Adjacent Tree patterns for index construction. An adjacent tree is a redundant subtree of a graph, which is able to preserve its structural information well. Furthermore, it is much faster to do matching on adjacent trees than on graph grams.  <ref type="figure" target="#fig_1">1b</ref>. With increases, the more and more adjacent vertices are included into the -AT , which indicates that the "Gram" becomes larger with larger . In Q-Gram index, either a too large or small Gram-length will weaken the strength of the index. This property also holds in -AT index, there is a trade-off in selection, as we will see it in the experimental part of this paper.</p><p>The concept of -AT is inspired on <ref type="bibr" target="#b13">[14]</ref>. He and Singh <ref type="bibr" target="#b13">[14]</ref> use pseudoisomorphism to do fast graph matching.</p><p>Here, we extend level-n adjacent subtrees by sorting the sibling nodes into an ordered sequence. Presorting the siblings can be convenient for unique sequentializing a -AT . In Section 4, we will see how this presorted structure benefits the -AT sequentializing.</p><p>It is simple to decompose a graph into -AT s. For each vertex, its -AT can be generated by a width-first searching on it. Fig. <ref type="figure" target="#fig_2">2</ref> gives an example of the -AT Ss of two graphs, the tables below graphs G 1 and G 2 record the different 1-AT s and corresponding numbers.</p><p>For a graph G, let -AT SðGÞ (-Adjacent Tree Set) of it be f-AT ðvÞj8v 2 Gg, -AT S serves as "Q-Gram set" for graph edit distance estimation. Intuitively, if the number of edit operations exerted on a graph is small, there must be considerable number of its -AT s remain unchanged. Next, we will see how to use the number of common -AT s of two graphs to estimate the lower bound of Á G of them.</p><p>The matching number of two graphs' -AT can be described as the intersection size of their -AT S. Lemma 1 gives the basic filtering principle of -AT index: Lemma 1. For two given graphs g 1 and g 2 , let ðg 1 Þ and ðg 2 Þ be the maximum degree of g 1 and g 2 , respectively. If the maximum degree of the two graphs g 1 and g 2 satisfies</p><formula xml:id="formula_3">ðg 1 Þ &gt; 1 and ðg 2 Þ &gt; 1, then j-AT Sðg 1 Þ \ -AT Sðg 2 Þj</formula><p>and Á G ðg 1 ; g 2 Þ satisfy the following inequality 1 :</p><formula xml:id="formula_4">j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj À Á G ðg 1 ; g 2 Þ Á 2ððg 1 Þ À 1Þ À1 :<label>ð1Þ</label></formula><p>Proof. Here, we use the technique of mathematical induction. First, we verify when</p><formula xml:id="formula_5">Á G ðg 1 ; g 2 Þ ¼ 0, j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj.</formula><p>If the two graphs g 1 and g 2 are isomorphic to each other, they must have the same properties in every respect, so the number of common -AT s in their -AT S will be the number of the vertices they have; thus,</p><formula xml:id="formula_6">j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj: Suppose when Á G ðg 1 ; g 2 Þ ¼ n, the lemma holds: j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj À n Á 2ððg 1 Þ À 1Þ À1 .</formula><p>Induction step: We need to prove that when Á G ðg 1 ; g 2 Þ ¼ n þ 1, the lemma still holds. Because there is one more GEO operation by changing the edit distance from n to n þ 1, we discuss the correctness of the induction in situations of the six different edit operations defined in Definition 4.  1. We can see from the proof for the lemma that 2ððg 1 Þ À 1Þ À1 is the upper bound number of the influenced -AT s of g 1 by an edit operation on g 1 .</p><p>. Delete an edge from the graph: Consider that the edit operation is that of deleting edge e from graph g 1 . Since there are k paths including e in g 1 , deleting an edge from g 1 will influence at most 2ððg 1 Þ À 1Þ À1 ÀAT s of g 1 . 2 So, we have</p><formula xml:id="formula_7">j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj À n Á 2ððg 1 Þ À 1Þ À1 À 2ððg 1 Þ À 1Þ À1 ¼ jV ðg 1 Þj À ðn þ 1Þ Á 2ððg 1 Þ À 1Þ À1 : That is, Lemma 1 holds when Á G ðg 1 ; g 2 Þ ¼ n þ 1.</formula><p>. Insert an edge between two vertices: Insertion of an edge is the reverse operation of deletion of an edge, so the proof is the same. . Delete an isolated vertex from the graph:</p><p>Deleting an isolated vertex from the graph will influence only 1 -AT S of g 1 , so we have</p><formula xml:id="formula_8">j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj À n Á 2ððg 1 Þ À 1Þ À1 À 1 ! jV ðg 1 Þj À ðn þ 1Þ Á 2ððg 1 Þ À 1Þ À1 :</formula><p>. Insert an isolated vertex into the graph: Insertion of an isolated vertex is the reverse operation of deletion of an isolated vertex, so the proof is the same. . Change the label of a vertex: Changing the label of vertex v in g 1 at most influences ððg 1 Þ À 1Þ À1 -AT s of g 1 , so we have</p><formula xml:id="formula_9">j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj À n Á 2ððg 1 Þ À 1Þ À1 À ððg 1 Þ À 1Þ À1 ¼ jV ðg 1 Þj À ðn þ 1Þ Á 2ððg 1 Þ À 1Þ À1 :</formula><p>. Change the label of an edge: Changing the label of edge e in g 1 at most influences 2ððg 1 Þ À 1Þ À1 -AT s of g 1 , so we have</p><formula xml:id="formula_10">j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj À n Á 2ððg 1 Þ À 1Þ À1 À ððg 1 Þ À 1Þ À1 ¼ jV ðg 1 Þj À ðn þ 1Þ Á 2ððg 1 Þ À 1Þ À1 :</formula><p>In a conclusion to the six situations of induction, we have discussed above. When</p><formula xml:id="formula_11">Á G ðg 1 ; g 2 Þ ¼ n þ 1, there will be j-AT Sðg 1 Þ \ -AT Sðg 2 Þj ! jV ðg 1 Þj À ðn þ 1ÞÁ2ððg 1 Þ À 1Þ À1 : u t</formula><p>Lemma 1 can be used to filter the candidate for Á G query. First, we pre-generate the set of k-ATs from all graphs in the graph set. For a query ðQ; Þ, we keep as the candidates of the query the graphs G for which the following condition holds: j-AT SðQÞ\ -AT SðGÞj ! jV ðQÞjÀÁ G ðQ; GÞ Á 2ððQÞÀ 1Þ À1 . Suppose that the query Q has the number of vertices 100 and the maximum degree 3, Á G threshold is 2, G is a graph in the set, and Q and G have 30 common 3-AT s. In this case, the upper bound becomes 30 &lt; 100 À 2 Â 2 Â ð3 À 1Þ ð3À1Þ , and G cannot be the answer of query Q based on Lemma 1. Using the filtering ability of Lemma 1, we can avoid many exact edit distance calculations.</p><p>Fig. <ref type="figure" target="#fig_3">3</ref> gives an example of how Lemma 1 works in candidate filtering. We mark the properties of the graphs such as jV ðG 1 Þj, <ref type="figure">,</ref> and<ref type="figure"></ref> verify Lemma 1 through a simple calculation of inequality (1).</p><formula xml:id="formula_12">ðG 1 Þ, Á G ðG 1 ; G 2 Þ in the figure</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Discussions</head><p>In this section, we give a brief analysis of how and graph density can influence the filtering ability of the index.</p><p>Let the</p><formula xml:id="formula_13">-AT Candidate Set of a Á G Query ðQ; Þ in graph set D is Cand ¼ fGjG 2 D; j-AT SðQÞ \ -AT SðGÞj ! jV ðGÞj À Á 2ððGÞ À 1Þ À1 g;</formula><p>the Candidate Set is the result set returned by -AT filtering on the graph set.</p><p>It is necessary to introduce the definition of sparse graph. A sparse graph is a graph G with jEðGÞj ( jV ðGÞj 2 , based on handshaking lemma, EðGÞ ¼ ðV ðGÞðGÞÞ=2, so we have ðGÞ ( jV ðGÞj. Nearly all biological and chemical compounds are sparse graphs, for the number of chemical 2. In the case of ¼ 1, deleting an edge eðv 1 ; v 2 Þ from g 1 influences 2 ¼ 2ð 1 ðg 1 Þ À 1Þ 1À1 1 À AT s of g 1 in which the roots are v 1 and v 2 , respectively. In the case of ¼ þ 1, the number of the influenced ð+1Þ-AT s is that of the influenced -AT s multiplied by ð À 1Þ. This is because ð þ 1Þ-AT s can be acquired by extending each node in -AT s with all its neighbors and at least one of these is already included in the -AT s.</p><p>bonds of each atom is constant, while the vertices number can be very large, so there is always ðGÞ ( jV ðGÞj.</p><p>The density of a graph can also be measured by the average degree of it. It is obvious that a sparse graph has a relatively low density.</p><p>There are two problems related to our lower bound estimation in Lemma 1. The first problem is that the estimation is too loose if the density of the graph is large. Can it be further tightened? Take a worst-case example, suppose the two graphs are both complete graphs, then even a single deletion on an edge will change all the vertices' -AT when &gt; 1. It is difficult to further tighten the lower bound estimation, but we can see that the filtering ability will be better on sparse graphs, the smaller the ðGÞ is, the smaller is the number of the k-ATs influenced by a single GEO.</p><p>The second problem is how to choose the proper to guarantee the filtering ability of the index for a specific graph set. Suppose that the graphs in the set are all sparse graphs, i.e., ðGÞ ( jV ðGÞj; 8G 2 D. From jCand j ¼ jfGjG 2 D; j-AT SðQÞ \ -AT SðGÞj ! jV ðGÞj À Á ðGÞ gj;</p><p>we can see that jV ðGÞj À Á ðGÞ should be greater than zero to guarantee the filtering ability of the index. Rearranging this expression leads to the following condition: log ðGÞ ðjV ðGÞj=Þ. But is a smaller necessarily better? The answer is negative because a matching on small adjacent tree sets may lead to mismatches on the whole graph. For example, two graphs can have all their 1-AT s matched with the other, but all in the wrong places. This can be analogized with the Q-Gram method on string matching, both too large and too small length Q-Grams can weaken the filtering ability of Q-Gram index. This is because too small grams cannot reflect the global structure of the string while too large grams may not be preserved under minor edit operations, this causes the trade-off in gram size selection. Due to the structural complexity of graph, it is difficult to give a theoretical evaluation on how to choose the optimum , and we will show some empirical results in the experiment section.</p><p>From the inequality 1 log ðGÞ ðjV ðGÞj=Þ, we can also see why the index is more effective for sparse graphs because only log ðGÞ ðjV ðGÞj=Þ ! 1 guarantees the existence of a proper . If we do not want to be too small, the condition ðGÞ ( V ðGÞ must hold, and thus, jEðGÞj ( jV ðGÞj 2 .</p><p>However, from Inequality (1), we can see when ¼ 1, the parameter ðg 1 Þ is eliminated. This leads to a solution for nonsparse graph. To index nonsparse graphs, we can choose 1-AT index, without worrying about that the large will weaken the filtering ability of the index. Although this is a feasible solution for nonsparse graphs, we still suggest to use this index only on sparse graphs because when is too small, the index sometimes can show unsatisfactory performance on candidate filtering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">-AT INDEX IMPLEMENTATION 4.1 -AT Index Construction</head><p>The discussion in Section 3 gives us a method to organize the index structure for Á G query. First, we generate all the -AT s of each graph in the graph set and store them in a table. For a query Q, we also generate its -AT s, and for each graph G in the graph set, we calculate the number of common -AT s of Q and G. Next, we use Inequality (1) to test if G belongs to the candidate set of the query.</p><p>This approach is faster than the naive searching method, but it is far from satisfying. First, -AT is a highly redundant structure. As increases, the space needed to store a -AT exponentially expands. Second, even though we have enough space to store -AT s, but the isomorphism test on large trees could also be slow enough to challenge our patience.</p><p>The bottleneck for the current -AT index as stated above forces us to improve the redundant structure of -AT index. It is noted that a -AT is made up by several ð À 1Þ-AT s, so actually we do not need to store every -AT of the graph set, but only 1-AT s; every larger -AT can be represented by smaller ones, and we can organize them in a -AT lattice.</p><p>For example, the 1; 2-AT s of G 2 in Fig. <ref type="figure" target="#fig_2">2</ref> are shown in Fig. <ref type="figure" target="#fig_4">4</ref>, and we can see that the -AT s have a tidy hierarchical structure, each -AT is made of several ð À 1Þ-AT s in the upper layer of the lattice.</p><p>To compact the index size, for each 1-AT shown in Fig. <ref type="figure" target="#fig_4">4</ref>, we give them a unique ID, then use the IDs of the 1-AT s to represent 2-AT s, and give each 2-AT a unique ID (Our "unique" means that the ID of the AT in the same layer of the lattice must be different) to represent 3-AT s, and so on. Each -AT can be represented in a hierarchical structure finally linked to 1-AT s (shown in Fig. <ref type="figure" target="#fig_5">5</ref>). We call this index structure "-AT lattice." Fig. <ref type="figure" target="#fig_5">5</ref> shows how to dispatch unique IDs for each -AT and how to use IDs of ð À 1Þ-AT s to represent -AT s based on the example 1; 2-AT s shown in Fig. <ref type="figure" target="#fig_4">4</ref>.</p><p>We can generate the -AT lattice in a relabeling procedure of each graph in the graph set. For a graph set, we first generate all its 1-AT s, and dispatch IDs for each unique 1-AT . After that, we store them in the first layer of the lattice, and then relabel each vertex in the graph set by the ID of their 1-AT . Next, we generate all 1-AT s of the new graph set and dispatch them unique IDs. These 1-AT s and their IDs are the element of the second layer of the lattice, this procedure continues until the layer number reaches the we set up.</p><p>Next, we introduce a technique to sequentialize a 1-AT . It is a difficult task to find out an adaptive sequentializing method for a general graph. Only very few methods can solve this problem using polynomial-time complexity. We can see, however, that a 1-AT can be organized in a star-like shape due to the special structure of the 1-AT . This gives rise to a method to transform a 1-AT into a sequence efficiently. For any 1-AT , suppose that its root vertex is v, child vertices are v 1 ; v 2 ; . . . ; v n , and the edges connecting the root vertex and child vertices are e 1 ; e 2 ; . . . ; e n . We then group each child vertex and the corresponding edge connecting it to the root vertex into a 2tuple; there will be n such tuples ðe 1 ; v 1 Þ; ðe 2 ; v 2 Þ; . . . ; ðe n ; v n Þ. Within these tuples, we define a partial ordering: if</p><formula xml:id="formula_14">W e ðe 1 Þ &lt; W e ðe 2 Þ or (W e ðe 1 Þ ¼ W e ðe 2 Þ and W ex ðv 1 Þ &lt; W ex ðv 2 Þ), then ðe 1 ; v 1 Þ 0 ðe 2 ; v 2 Þ, else ðe 1 ; v 1 Þ 1 ðe 2 ; v 2 Þ.</formula><p>In order to generate the sequence of a 1-AT and make sure that isomorphic 1-AT s should be mapped into the same sequence, we first sort the sequence of the tuples ðe 1 ; v 1 Þ; ðe 2 ; v 2 Þ; . . . ; ðe n ; v n Þ based on the partial order defined above, and then insert the root vertex into the head of the sequence. Finally, we get a sequence of the form ðvÞðe 1 ; v 1 Þ; ðe 2 ; v 2 Þ; . . . ; ðe n ; v n Þ.</p><p>We do not use the definition of level-n adjacent subtree in <ref type="bibr" target="#b24">[25]</ref> since we need to fix the order of a node's siblings for convenience of the sequentializing procedure of 1-AT . If the sibling nodes of a -AT are already sorted, the sequentialization of a -AT will become much easier.</p><p>Algorithm 1 describes the procedure of generating a -AT lattice of a graph set.</p><p>For a given graph, let the -AT table of the graph be a table recording all the -AT IDs and the frequency they appear in the graph. For example, Table <ref type="table" target="#tab_2">1</ref> shows the -AT table for the graph in Fig. <ref type="figure" target="#fig_1">1a</ref>.</p><p>We maintain the -AT table for each graph in the graph set for -AT set join. For each query Q, first generate its -AT table based on the existing -AT lattice, then for each graph G in the graph set, calculate -AT SðQÞ \ -AT SðGÞ by comparing the ð2 À 1; 2Þ columns of their -AT tables.</p><p>The usage of the -AT table allows us to store each graph's adjacent tree by their ID in the -AT lattice; this greatly reduces the space needed to store each graph's -AT s. In the query processing, the incoming query needs to be decomposed into -AT by a bottom-up search on the -AT lattice. The ID and number of its -AT can be collected during the search to generate the query's -AT table.</p><p>Algorithm 2 uses the -AT table for candidate filtering of Á G query (Q, ) on the graph set.</p><p>The set R returned by Algorithm 2 is the candidate answer set of the query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">-AT Index Maintenance</head><p>There are two steps in the maintenance of the index. The first step is the -AT lattice maintenance. Any nonpreviously existing -AT appearing in a new graph added to the set should be inserted into the lattice, and this can be done by decomposing the new graph and searching the -AT in the old lattice. If they do not exist, we insert them into the corresponding layer of the lattice. The other step is to generate the -AT table for the new graph. The -AT table can be attained by the searching and relabeling procedure.</p><p>The deletion procedure is similar to the insertion procedure. To do so, we generate all -AT s of the graph (these -AT s all have a 1-AT shape because we use the technique of searching and relabeling as defined before on the -AT lattice). Then for each -AT , we test if it is unique in the lattice, if so, we delete those -AT s from the -AT lattice, and delete the graph and its -AT table from the graph set.</p><p>It will cost a complete search on the graph set to test if a -AT is unique on the lattice; so for each -AT in the lattice, we maintain a "counter" that records the number of occurrences. If a new -AT is inserted into the lattice, we initialize its counter ¼ 1. Every subsequent insertion of this k-AT, the counter gets increased by 1. When a deletion is encountered, we subtract the counter by 1. When the counter equals 1, and another deletion operation is encountered,  then we will know that this -AT should be deleted from the lattice, and as such, the slow process of searching on the graph set can be avoided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Combining -AT Index with Inverted Index</head><p>Although searching on the -AT index will be much faster than doing the Á G calculation, it is still a sequential search. It inevitably has to access all the -AT tables in the graph set, and thus, this process has a higher computational cost. If we regard each graph in the graph set as a keyword set with their -AT s as their keywords, then we can organize the -AT index into an inverted index to avoid the slowly sequential search. Sarawagi and Kirpal <ref type="bibr" target="#b24">[25]</ref> give several approaches to use an inverted index for joining a set of keywords. After inverted index construction, we use the Probe-Count Algorithm <ref type="bibr" target="#b24">[25]</ref> to calculate j-AT Sðg 1 Þ \ -AT Sðg 2 Þj, 8g 2 2 D, and g 1 is the query. For each , we maintain an inverted table for all the -AT s (-inverted table). We use their IDs as the keywords and record their references in the graph set into the inverted list of this keyword. During a query processing, we first generate all the -AT s of the query and use the ID of the -AT as the keywords to pick up specific inverted lists in the -inverted table, then execute a join operation on those inverted lists using the Probe-Count Algorithm.</p><p>Algorithms 3 and 4 are used to construct an inverted index from a graph set and execute candidate filtering on the inverted index. The inverted index technique can greatly improve the time efficiency of the filtering algorithm. In Section 5, we will see that after applying the inverted index to the original -AT tables, the query processing time will remain constant with respect to the graph set size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PERFORMANCE EVALUATION</head><p>In this section, we evaluate the performance of -AT index by comparing with F G-index <ref type="bibr" target="#b9">[10]</ref> and DAG<ref type="foot" target="#foot_0">3</ref> index <ref type="bibr" target="#b17">[18]</ref>. F G-index is a kind of frequent-subgraph-based indexing technique while DAG index is a kind of graph-decomposition-based indexing technique. Note that is set to 0.1 for the F G-index method. Since our proposed method is a hybrid of graph-decomposition-based indexing method and frequent-subgraph-based indexing method, we choose these two indexing techniques to compare with our proposed method. In the query performance experiments, we randomly pick up one graph from the graph set to form a query for each query performance experiment, and it is running three times to get the average response time of the query. Similar ways are adopted in the literature <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Data Sets and Settings</head><p>We use three kinds of data sets in our experiments: two real data sets and a synthetic data set, described as follows:</p><p>1. NCI/NIH AIDS Antiviral Screen data set. AIDS is a widely used real chemical compounds data set <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>. This data set is available publicly on the Website of the Developmental Therapeutics Program (http://dtp.nci.nih. gov/). All data are stored in SDFile format. We generate from the AIDS data set more than 40,000 graphs, which have an average number of 20 vertices and 26 edges and a maximum number of 25 vertices and 35 edges. 2. Protein Interaction Data set DIP (short for Database of Interacting Proteins). DIP is a protein interaction network data set <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b21">[22]</ref>. This data set is available on the Website of the Database of Interacting Proteins (http://dip.doe-mbi.ucla.edu/). We download from the Website all the eight newly species protein interaction data sets, including D. melanogaster (fruit fly), S. cerevisiae (baker's yeast), E. coli, C. elegans, H. sapiens (Human), H. pylori, M. musculus (house mouse), and R. novegicus (Norway rat). From the eight protein interaction data sets, we generate more than 5,000 graphs that have an average number of 12 vertices and 36 edges and a maximal number of 17 vertices and 51 edges. Protein interaction networks are typical large sparse graphs <ref type="bibr" target="#b4">[5]</ref>. 3. Synthetic data set. The synthetic data are randomly generated by the algorithm used in the paper <ref type="bibr" target="#b25">[26]</ref>.</p><p>There are five parameters used in the generator: the database size jDj, the average graph size jT j, the number of seeds jLj, the size of seed graphs jIj, and the number of distinct edge and vertex labels N. The generated process is described as follows: a) Initialize the information for seed graphs, including the size and probability of each seed graph. The size of a seed graph is determined by a Poisson distribution with mean jIj and the probability of the seed graph is generated randomly. b) Select a seed graph using the probability information of the seeds. c) For the selected seed graph, a corresponding graph is generated, the size of which is determined by a Poisson distribution with mean jT j. In our experiments, the parameters used for the generator are set as: jDj ¼ 10kÀ100k, jT j ¼ 10, jLj ¼ 200, jIj ¼ 10, and N ¼ 5. The generated graphs have an average number of 10 vertices and 40 edges and a maximal number of 16 vertices and 48 edges when the parameter graphsize is fixed at 10. Table <ref type="table">2</ref> gives the settings of the four parameters used in our experiments, including ranges and default values. is a key parameter in our proposed indexing method. It can be used to control the index size and tune the index performance. Á is the edit distance threshold. Graphsize is the average number of nodes of the graphs in the graph database. DBSize is the number of graphs in the graph database. The default values of Graphsize and DBSize are set as 10 and 10,000 since the DAG indexing method takes a very long time to build the indexes with large graph sizes and large database size.</p><p>All the algorithms were implemented using C++. The experiments were run on a PC with an 3.0 GHz CPU and 3GB memory, running a Windows XP operating system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance of Index Construction</head><p>In this section, we compare the index construction performance of our proposed -AT method with DAG and F G-index on three data sets in terms of index size and index construction time.</p><p>Figs. <ref type="figure" target="#fig_0">6</ref> and<ref type="figure">7</ref> show the index size and construction time of three data sets. We can see in Fig. <ref type="figure" target="#fig_0">6</ref> that the DAG indexing method has the worst performance in index size. This is because DAG needs to index all the decomposed subgraphs. Moreover, DAG will take more space in the case of larger GraphSize since the number of the decomposed subgraphs is exponential to GraphSize. Our indexing method -AT incorporates graph-decomposition-based indexing techniques with frequent-subgraph-based indexing techniques; therefore, it has less space costs than DAG. Among the three indexing methods, F G-index has the best performance in index size, since the method only needs to index some frequent subgraphs. Fig. <ref type="figure">7</ref> shows that -AT is superior to the other two indexing methods in index construction time. In the procedure of constructing indexes, the main CPU cost is subgraph isomorphism test. DAG has to invoke the subgraph isomorphism test operation to clean the duplicates of subgraphs and F G-index has to invoke the subgraph isomorphism test operation to find frequent subgraphs, while -AT invokes the subtree isomorphism test to collect the frequency information of the decomposed subtrees. It is obvious that subtree isomorphism test is faster than subgraph isomorphism test. DAG is the slowest in index construction time since the number of the decomposed subgraphs is much more than that of the found  frequent subgraphs in F G-index and that of the decomposed subgraphs in -AT .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Performance of Query Processing and Filtering Ability</head><p>In this section, we compare the query processing and filtering performance of our proposed -AT method with DAG and F G-index on the three data sets. Fig. <ref type="figure">8</ref> shows the performance of query processing and filtering ability of the three indexing techniques on the AIDS data set. We can see in Fig. <ref type="figure">8a</ref> that DAG has the worst filtering performance, and -AT has almost the same filtering ability as F G-index but -AT is slightly better than F G-index. Fig. <ref type="figure">8b</ref> shows that -AT has better query processing performance than DAG but slower than F G-index. This is because there are a few frequent subgraph patterns in the AIDS data set and a few of subgraph isomorphism test operations are invoked in F G-index. It can be noted that all the three methods have good query processing performance since all the response times are no more than 3 ms. Fig. <ref type="figure">9</ref> shows the performance of query processing and filtering ability of three indexing techniques on the DIP data set. We can see in Fig. <ref type="figure">9a</ref> that DAG has the worst filtering performance and F G-index has the best filtering performance on the DIP data set. -AT becomes better than F G-index when DBSize is larger than 5,000. Fig. <ref type="figure">9b</ref> shows that in query processing performance, -AT and DAG are far superior to F G-index and -AT is slightly better than DAG. Since there are only a few protein interactions, only a few distinct labels of edges exist in the DIP data set. This leads to inefficient query processing on infrequent edges, and therefore, F G-index gets very bad query processing performance in the DIP data set. Fig. <ref type="figure" target="#fig_1">10</ref> shows the performance of query processing and filtering ability of three indexing techniques on the synthetic data set. We can see in Fig. <ref type="figure" target="#fig_1">10a</ref> that -AT has almost the same filtering performance as DAG. Fig. <ref type="figure" target="#fig_1">10b</ref> shows that the query processing performance of -AT is far superior to F G-index and DAG. This is because F G-index and DAG have to invoke a lot of subgraph isomorphism test operations in the synthetic data set while -AT invokes subtree isomorphism test operations. The cost of subtree isomorphism test is much faster than that of the subgraph isomorphism test as pointed out before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Performance of Scalability</head><p>In this section, we test the scalability performance of our proposed indexing methods -AT (with inverted) and -AT (without inverted) on the synthetic data set. The range of parameter DBSize is set as 10 k to 100 k. In the previous experiments, it is set as 1 to 10 k since the DAG method will take a very long time to build the index when the database is very large. Fig. <ref type="figure" target="#fig_1">11</ref> shows the scalability performances of -AT when varies. We can see in Fig. <ref type="figure" target="#fig_1">11a</ref> that -AT has a good filtering ability when is smaller than 4. This is why we set the default value of as 3. Fig. <ref type="figure" target="#fig_1">11b</ref> shows that the query processing response time increases linearly as increases. The optimized method with inverted index improves the performance by more than 40 percent. Fig. <ref type="figure" target="#fig_9">12</ref> shows the scalability performance of our proposed indexing method -AT when the edit distance threshold Á varies. In Fig. <ref type="figure" target="#fig_9">12a</ref>, we can see that the candidate size increases as Á increases, since the size of the results is also increasing as Á increases. Fig. <ref type="figure" target="#fig_9">12b</ref> shows that the query processing response time is constant as Á increases, since the query processing cost is not depending on Á. The optimized method with inverted index decreases the response time by about two times.</p><p>Fig. <ref type="figure" target="#fig_3">13</ref> shows the scalability performance of our proposed indexing method -AT as GraphSize varies (the range of variation 20 to 180). In the figures, we can see that both candidate size and response time increase linearly as GraphSize varies. Fig. <ref type="figure" target="#fig_3">13b</ref> shows that our proposed indexing  method -AT has a very good scalability performance versus graph size, and the optimized method with inverted index improves the response time about 30 percent.</p><p>Fig. <ref type="figure" target="#fig_11">14</ref> gives the scalability performance of -AT as database size varies. Fig. <ref type="figure" target="#fig_11">14a</ref> shows that the candidate size increases linearly as database size increases. This is because the number of answers increases as database size increases. Fig. <ref type="figure" target="#fig_11">14b</ref> shows that the optimized method with inverted index improves the response time about 20 percent and the improvement increases gradually as database size increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS AND FUTURE WORK</head><p>We have developed a graph set indexing method for similarity matching. By decomposing the graphs into small pieces (-AT s), and pairing-up these pieces, we evaluate the global similarity between them. In order to seek for a compromise between frequent-subgraph-based indexing methods and graph-decomposition-based indexing methods, we use the redundant subtree structure: -AT pattern for index construction. -AT records more structural information on each vertex than a normal graph-decomposition-based indexing method, and while maintaining the simple structure of tree. By calculating the number of common -AT s of two graphs, we can estimate the graph edit distance between them. This gives us a method for indexing and candidate filtering in a graph set for similarity matching. Experimental results evince that when applied to large sparse graph sets and when the Á G threshold is not too large, prefiltering on -AT index can be both fast and accurate.</p><p>There are still several opportunities for future improvements on the -AT index.</p><p>1. The lower bound estimation is loose on nonsparse graphs because we assume that the edit operation can happen on each V or E in a graph at a same probability. In fact, due to the unbalanced structure of a graph, the probability of different V or E, which will be covered by the edit operations, is also different; so we actually can apply probability model to our index to further tighten the lower bound estimation, under a different assumption of the distribution of edit operations. Also we can apply some machine learning methods to calculate the distribution from statistical information about large amounts of queries.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 6 (</head><label>6</label><figDesc>Adjacent Tree (AT )). The adjacent tree of a vertex v (AT ðvÞ) in GðV ; EÞ is a breadth-first search tree of vertex v, the children of each node of AT ðvÞ are sorted by their labels in the graph. Definition 6 indicates that AT ðvÞ is infinitely expanding, as shown in Fig. 1. To be of practical use, we only take the subtree of the top-level of the adjacent tree for index construction. Definition 7 (-Adjacent Tree (-AT )). The -adjacent tree of a vertex v (-AT ðvÞ) in graph G is the top -level subtree of AT ðvÞ. Fig. 1 shows a -AT example, some of the adjacent trees of the graph shown in Fig. 1a are shown in Fig.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of -adjacent tree.</figDesc><graphic coords="4,29.48,51.17,244.46,186.01" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Example of -adjacent tree set.</figDesc><graphic coords="4,300.53,51.17,228.47,332.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Example of Lemma 1.</figDesc><graphic coords="5,301.32,51.17,226.89,329.27" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The hierarchical structure of -AT .</figDesc><graphic coords="6,297.13,51.17,235.16,147.23" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. How to compact the -AT lattice by "relabeling."</figDesc><graphic coords="7,35.09,51.17,233.24,159.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .Fig. 7 .</head><label>67</label><figDesc>Fig. 6. Index size of three data sets. (a) Index size of AIDS. (b) Index size of DIP. (c) Index size of synthetic data set.</figDesc><graphic coords="9,34.47,591.28,497.54,128.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .Fig. 9 .</head><label>89</label><figDesc>Fig. 8. Query processing performance and filtering ability of AIDS. (a) Filtering ability. (b) Query processing response time.</figDesc><graphic coords="10,31.12,51.17,241.17,98.42" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .Fig. 11 .</head><label>1011</label><figDesc>Fig. 10. Query processing performance and filtering ability of the synthetic data set. (a) Filtering ability. (b) Query processing response time.</figDesc><graphic coords="10,294.97,51.17,239.53,96.83" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>2 .</head><label>2</label><figDesc>The -AT model still suffers from more false positives than the graph pattern model in the filtering phase because tree patterns are still "weak" compared with graph patterns. For this reason, other methods should be investigated, which can combine them together to further optimize the performance of the index such as the method proposed in<ref type="bibr" target="#b14">[15]</ref>. 3. Paralleling to the edit distance threshold query, some different kinds of querying forms, such as k-NN query and top-k query, can be discussed under our filtering principle and indexing model. This opens up many interesting topics in the similarity matching on graph sets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 12 .Fig. 13 .</head><label>1213</label><figDesc>Fig. 12. Scalability versus edit distance threshold. (a) Candidate size. (b) Query response time.</figDesc><graphic coords="11,31.98,51.17,239.53,98.53" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Scalability versus database size. (a) Candidate size. (b) Query response time.</figDesc><graphic coords="11,295.20,51.17,239.02,98.31" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>AE V ; AE E Þ is a graph, where each vertex and edge are labeled with words from the alphabets AE V and AE E , respectively. W v : V ! AE V is a surjection from V ðGÞ to AE V and W e : E ! AE E is a surjection from EðGÞ to AE E . AE V and AE E are the label alphabets for vertices and edges, respectively.</figDesc><table><row><cell>3 PRINCIPLE OF -ADJACENT TREE INDEX</cell></row><row><cell>3.1 Preliminaries</cell></row><row><cell>First, we introduce the basic definitions in graph theory for</cell></row><row><cell>graph representation and comparison. Whether two graphs</cell></row><row><cell>are equal to each other is judged by a (sub)graph isomorph-</cell></row><row><cell>ism test; it will be necessary to introduce the concept of</cell></row><row><cell>(sub)graph isomorphism in the following.</cell></row><row><cell>A graph GðV ; EÞ is a tuple containing two sets, the set of</cell></row><row><cell>vertices V and the set of edges E, and each edge e is</cell></row><row><cell>associated with two vertices in the set of vertices, denoted</cell></row><row><cell>by eðu; vÞ; u; v 2 V .</cell></row><row><cell>Definition 1 (Attributed Graph). A labeled graph GðV ; E;</cell></row><row><cell>W v ; W e ;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE 1 Example</head><label>1</label><figDesc></figDesc><table /><note><p>of -AT Table</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 2 Parameter Settings</head><label>2Settings</label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>The index proposed in<ref type="bibr" target="#b17">[18]</ref> is called GDI, we would like to name it DAG since the paper uses Directed Acyclic Graph to represent decomposed subgraphs.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors thank a lot to Mr. Zinan Xu and Mr. Miaoqiang Su for their hard work on the experiments. This research was partially supported by the National Natural Science Foundation of China under Grant Nos. 60873011, 60933001, 60828004, and 60973018; the National Basic Research Program of China under Grant No. 2006CB303103; and the 863 Program under Grant Nos. 2007AA01Z192 and 2009AA01Z131.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Guoren Wang received the PhD degree from Northeastern University, China, in 1996. He is currently a professor and the director of the Computer System Institute of the College of Information Science and Engineering at Northeastern University. His research interests include XML data management, query processing and optimization, bioinformatics, high-dimensional indexing, parallel database systems, and P2P data management. He has published more than 100 research papers in international conferences and journals. He is a senior member of the CCF. . For more information on this or any other computing topic, please visit our Digital Library at www.computer.org/publications/dlib.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<editor>W. Yu</editor>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>China Machine Press</publisher>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="620" to="630" />
		</imprint>
	</monogr>
	<note>Np Completeness. second ed.</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On Using q-Gram Locations in Approximate String Matching</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sutinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tarhio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Ann. European Symp. Algorithms</title>
		<meeting>Third Ann. European Symp. Algorithms</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="327" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Theory and Methodology: Vehicle Routing with a Sparse Feasibility Graph</title>
		<author>
			<persName><forename type="first">J</forename><surname>Beasley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Christofides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European J. Operational Research</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="499" to="511" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Sparse Word Graphs: A Scalable Algorithm for Capturing Word Correlations in Topic Models</title>
		<author>
			<persName><forename type="first">R</forename><surname>Nallapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Seventh IEEE Int&apos;l Conf. Data Mining Workshops (ICDMW &apos;07)</title>
		<meeting>Seventh IEEE Int&apos;l Conf. Data Mining Workshops (ICDMW &apos;07)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="343" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Prediction of Protein Function Using Common-Neighbors in Protein-Protein Interaction Networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Sixth IEEE Int&apos;l Symp. BioInformatics and BioEng</title>
		<imprint>
			<biblScope unit="page" from="251" to="260" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Graph Indexing: A Frequent Structure-Based Approach</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="335" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Graph Indexing Based on Discriminative Frequent Structure Analysis</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Xifeng Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="960" to="993" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Taming Verification Hardness: An Efficient Algorithm for Testing Subgraph Isomorphism</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 34th Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>34th Int&apos;l Conf. Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="364" to="375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Substructure Similarity Search in Graph Databases</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="766" to="777" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fg-Index: Towards Verification-Free Query Processing on Graph Databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="857" to="872" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient Query Processing on Graph Databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="44" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Towards Graph Containment Search and Indexing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 33rd Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>33rd Int&apos;l Conf. Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="926" to="937" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Treepi: A Novel Graph Indexing Method</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 23rd Int&apos;l Conf. Data Eng</title>
		<meeting>IEEE 23rd Int&apos;l Conf. Data Eng</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="966" to="975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Closure-Tree: An Index Structure for Graph Queries</title>
		<author>
			<persName><forename type="first">H</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd Int&apos;l Conf. Data Eng</title>
		<meeting>22nd Int&apos;l Conf. Data Eng</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">38</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graph Indexing: Tree + Delta ! Graph</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 33rd Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>33rd Int&apos;l Conf. Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="938" to="949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Subgraph Isomorphism in Planar Graphs and Related Problems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Algorithm and Experiments in Testing Planar Graphs for Isomorphism</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Kukluk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">B</forename><surname>Holder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="313" to="356" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Graph Database Indexing Using Structured Graph Decomposition</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Huan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd Int&apos;l Conf. Data Eng</title>
		<meeting>23rd Int&apos;l Conf. Data Eng</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="976" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Algorithmics and Applications of Tree and Graph Searching</title>
		<author>
			<persName><forename type="first">D</forename><surname>Shasha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giugno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st ACM SIGACT-SIGMOD-SIGART Symp. Principles of Database Systems</title>
		<meeting>21st ACM SIGACT-SIGMOD-SIGART Symp. Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="39" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Binary Linear Programming Formulation of the Graph Edit Distance</title>
		<author>
			<persName><forename type="first">D</forename><surname>Justice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1200" to="1214" />
			<date type="published" when="2006-08">Aug. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Graph Decomposition Using Node Labels</title>
		<author>
			<persName><forename type="first">O</forename><surname>Johansson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Royal Inst. of Technology</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note type="report_type">doctoral dissertation</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Tale: A Tool for Approximate Large Graph Matching</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Int&apos;l Conf. Data Eng</title>
		<meeting>24th Int&apos;l Conf. Data Eng</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="963" to="972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Gstring: A Novel Approach for Efficient Search in Graph Databases</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd Int&apos;l Conf. Data Eng</title>
		<meeting>23rd Int&apos;l Conf. Data Eng</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="566" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A Novel Spectral Coding in a Large Graph Database</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int&apos;l Conf. Extending Database Technology</title>
		<meeting>11th Int&apos;l Conf. Extending Database Technology</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient Set Joins on Similarity Predicates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sarawagi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kirpal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD</title>
		<meeting>ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="743" to="754" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Frequent Subgraph Discovery</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kuramochi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2001 IEEE Int&apos;l Conf. Data Mining</title>
		<meeting>2001 IEEE Int&apos;l Conf. Data Mining</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="313" to="320" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
