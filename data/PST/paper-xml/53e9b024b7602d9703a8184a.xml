<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DSD: A Schema Language for XML</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nils</forename><surname>Klarlund</surname></persName>
							<email>klarlund@research.att.com</email>
						</author>
						<author>
							<persName><forename type="first">Anders</forename><surname>MÃ¸ller</surname></persName>
							<email>amoeller@brics.dk</email>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">BRICS</orgName>
								<orgName type="institution" key="instit2">University of Aarhus</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">BRICS</orgName>
								<orgName type="institution" key="instit2">University of Aarhus</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">DSD: A Schema Language for XML</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4FC84E672A7E12BB234AFCF49710BB8F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>XML (eXtensible Markup Language) is a linear syntax for trees, which has gathered a remarkable amount of interest in industry. The acceptance of XML opens new venues for the application of formal methods such as specification of abstract syntax tree sets and tree transformations.</p><p>A notation for defining a set of XML trees is called a schema language. Such trees correspond to a specific user domain, such as XHTML, the class of XML documents that make sense as HTML.</p><p>A useful schema notation must: identify most of the syntactic requirements that the documents in the user domain follow; allow efficient parsing; be readable to the user; allow limited tree transformations corresponding to the insertion of defaults; be modular and extensible to support evolving classes of XML documents.</p><p>In the present paper, we introduce the DSD (Document Structure Description) notation as our bid on how to meet the requirements above.</p><p>The expressiveness of DSDs goes far beyond the DTD concept that is already build into XML and SGML. In particular, we advocate the use of nonterminals in a top-down manner, coupled with boolean logic and regular expressions to describe how constraints on tree nodes depend on their context. We also support a general, declarative mechanism for inserting default elements and attributes that is reminiscent of Cascading Style Sheets (CSS), a way of manipulating formatting instructions in HTML that is built into all modern browsers. Finally, we include a simple technique for evolving DSD documents through selective redefinitions.</p><p>The DSD language is completely self-describable, meaning that the syntax of legal DSD documents together with all static requirements are captured in a special DSD document, the meta-DSD of less than 500 lines.</p><p>We relate DSDs to other recent XML schema languages and to languages for abstract syntax description.</p><p>The DSD language is fully implemented and is available in an open source distribution.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>XML (eXtensible Markup Language) <ref type="bibr" target="#b5">[5]</ref> is a syntax derived from SGML for markup of text. XML is particularly interesting to computer scientists because the markup notation is really nothing but a way of specifying labeled trees. The tree view and the convenient SGML syntax of HTML have been important to the development of the World Wide Web. Recently, the general XML syntax has gathered a remarkable amount of interest in industry as a way of exchanging data such as documents, databases, or computed information.</p><p>We argue in this document that the acceptance of XML opens new ways of introducing formal computer science techniques into practice. Specifically, we study: the formal specification of XML languages, that is sets of abstract syntax trees, and tree-based default insertion mechanisms, that is, tree transformations. Both aspects are part of the DSD (Document Structure Description) notation, which we introduce informally in this article. Before we explain DSDs, let us mention some fundamental XML efforts that are already standardized (in the sense of being a W3C recommendation) or under development:</p><p>CSS (Cascading Style Sheet) allows XML documents to be rendered visually (CSS2 <ref type="bibr" target="#b1">[1]</ref> is the latest official recommendation); transformation language defines rather general transformations between XML languages (XSLT <ref type="bibr" target="#b6">[6]</ref>, which is also called a style sheet language, became an official recommendation recently); linking defines generalized links between XML resources (X Link <ref type="bibr" target="#b11">[11]</ref> and XPointer <ref type="bibr" target="#b10">[10]</ref> are almost completed, whereas XPath <ref type="bibr" target="#b7">[7]</ref>, a simple expression language underlying several of the XML efforts, has just been turned into an official recommendation); schema language is a current effort similar to ours for describing the formal syntax of XML applications (XML has already inherited the DTD concept from SGML, but this notation is considered inadequate by many); and query language, which will generalize database queries to semi-structured data represented by XML documents.</p><p>In the area of schema languages, several proposals, such as DDML <ref type="bibr" target="#b2">[2]</ref>, DCD <ref type="bibr" target="#b3">[3]</ref>, SOX <ref type="bibr">[9]</ref>, Schematron <ref type="bibr" target="#b14">[14]</ref>, and RELAX <ref type="bibr" target="#b19">[19]</ref> have already emerged. Recently, W3C has issued an official draft proposal for XML Schema, which has been met with intense debate.</p><p>Our DSD proposal is more ambitious than other proposals with the exception of Schematron, which is based on a pattern matching paradigm instead of a parsing view, and RELAX, which is more expressible in some regards. A DSD defines a grammar for a class of XML documents, documentation for that class, and additionally a CSS-like notation for specifying default parts of documents. A DSD is itself an XML document.</p><p>We recall that an XML document consists of elements that have attributes and content; the latter is a sequence of text interspersed with subelements. For an example, take the HTML markup &lt;body class='mystuff'&gt; Hello &lt;em&gt;there&lt;/em&gt; &lt;/body&gt; This is an element representing a node labeled "body". The node has an attribute named "class" and two children corresponding to its content (the stuff between the start tag &lt;body..&gt; and the end tag &lt;/body&gt;: a text node with value "Hello" and an element node labeled "em"; the "em" node in turn has one child node, which is a text node.</p><p>We have six major goals for the descriptive power of DSDs. They should: allow context dependent descriptions of content and attributes, since the context of a node, such as ancestors and attribute values, often govern what is legal syntax; generalize CSS <ref type="bibr" target="#b1">[1]</ref> (Cascading Style Sheets) so that readable, CSS-like rules for default attribute values and default content can be defined for arbitrary XML domains, not only predefined user formatting models; complement XSLT <ref type="bibr" target="#b6">[6]</ref> in the sense that the expressive power of DSDs should be close to that of XSLT, so that assumptions made by XSLT style sheets can be made explicit in a DSD; permit the description of semi-structured data, that is, the description of what references may point to; enable the redefinitions of syntactic classes, so that evolving XML languages can be expressed in terms of existing DSDs; and be self-describable.</p><p>It is also important to us that a DSD yields a linear time algorithm for checking conformance of XML documents and that DSDs are based on simple concepts familiar to computer scientists. To honor these ambitions, our design combines several elementary ideas: a uniform notion of constraint that captures the legality of attributes, attribute values, and content; conditional constraints guarded by boolean expressions that capture dependencies between attributes, attribute values, element contexts, and content; nonterminals in the form of element IDs that allow several different versions of an element to coexist; the concept of projected content that allows succinct descriptions of both ordered and unordered content; regular expressions to describe both attribute values and content sequences; automatic insertion of default attributes and elements guided by boolean expressions; several ID types to allow easy redefinitions; and points-to requirements that constrain the targets of references.</p><p>Despite its expressive power, the DSD language is simple enough that it can be rigorously defined in an 15 page English specification (excluding examples and introduction). This present paper describes the main ideas of the language and relates it to other XML schema language proposals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work</head><p>There are currently two major W3C initiatives aiming at describing classes of XML documents.</p><p>The first initiative is called RDF (Resource Description Framework) Schema Specification. RDF is a generic notation for describing metadata, such as content ratings, user references, or content relationships. It is based on well-known concepts: named properties and entity-relationship diagrams. Thus an RDF description is a graph expressed in a generic notation. RDF schemas, in turn, declare properties and allowed relationships that constrain the shape of an RDF description. An RDF schema defines a number of domains, mappings among them, and classes, which may be related by subclass constraints. Thus, RDF schemas aim at describing data models, not XML syntax as such.</p><p>The second initiative is named XML Schemas. The requirements that a schema language should address are summarized in the document <ref type="bibr" target="#b17">[17]</ref>. The DSD language, we believe, satisfies the principles and requirements outlined, except that we have paid less attention to a precise coordination with other W3C standards (some of which are under development). In particular, we have not addressed the relatively modest issue of integrating primitive datatypes with our structural descriptions. Neither have we addressed the issue of namespaces <ref type="bibr" target="#b4">[4]</ref>.</p><p>The XML Schema proposal <ref type="bibr" target="#b22">[22]</ref> contains many features that may directly be compared to the DSD language. Other features, such as those that deal with name spaces and import mechanisms, are outside the scope of the current DSD proposal.</p><p>The XML Schema proposal introduces several mechanisms, inspired by object-oriented programming, for restraining how schemas are constructed such as final, abstract, and equivalence notions. They contribute to the complexity of the language, while impeding self-describability. The current DSD proposal does not rely on object-orientation, since we found that many application domains, such as HTML, do not lend themselves to 00.</p><p>In XML Schema, a number of constraint-like concepts are introduced: complex types, attribute group definition, and content type concepts. We propose to unify these, and our additional notion of a boolean constraint, into one concept.</p><p>The XML Schema proposal introduces three different kinds of content models element content model, element-only content, and named model group. We introduce only one kind of content model, which may be anonymous or identified by an ID.</p><p>Apparently, the current XML Schema proposal does not satisfy two of the requirements in <ref type="bibr" target="#b17">[17]</ref>: it is not self-describing, since many syntactic constraints on schemas are not describable by a schema; and it does not address schema evolution, that is, how existing schemas may be combined or amended to reflect new features or restrictions.</p><p>We address the first requirement by making the DSD language strong enough to cover boolean conditions, including context descriptions and the description of where ID references point to. Our meta-DSD, which describes the class of valid DSDs, covers all syntactic constraints.</p><p>We address the second requirement by our use of definitions and redefinitions of nonterminals as a simple solution to the problem of extending grammatical categories in schemas as they evolve.</p><p>There are other significant differences between DSDs and XML Schema. First, our notion that attributes must be declared gradually avoids semantic ambiguities in how CSS is used for inserting default attribute values for XML languages like SMIL <ref type="bibr" target="#b13">[13]</ref>. Second, our schema language captures that content and attribute declarations often depend on ancestors and other attributes; XML Schema does not allow attributes value dependencies, which are common to XML languages (including XML Schema itself). Finally, the key notions of XML Schema of how to specify the recursive structure of a document are, in our opinion, too weak and at the same time much too complicated as far as we gather from the current draft <ref type="bibr" target="#b22">[22]</ref>.</p><p>There have been several other schema language proposals. DDML <ref type="bibr" target="#b2">[2]</ref> was the result of a collaborative effort on the XML-DEV mailing list. It is a relatively straightforward generalization of DTD concepts. A similar notion called DCD was proposed in <ref type="bibr" target="#b3">[3]</ref>. A different approach was suggested by SOX <ref type="bibr">[9]</ref>, which is based on an object-oriented paradigm. These languages do not appear to offer a unifying notion of constraint, or context-dependent declarations.</p><p>A interesting approach <ref type="bibr" target="#b21">[21]</ref>, called assertion grammars, achieves some of our goals since it is based implicitly on nonterminals. Recast in our terminology, assertions are redefinitions of nonterminals that conditionally extend their meaning. The condition reflects the context where the addition is valid. We believe it would be possible to explain assertion grammars fully in terms of DSD concepts; conceivably, assertion grammar concepts could be integrated with DSDs, where they would stand for abbreviations of DSD constructs. Assertion grammars allow only a restricted class of extensions, and they do not allow as flexible context dependencies as DSDs.</p><p>Another approach closely related to ours is that of RELAX <ref type="bibr" target="#b19">[19]</ref>, which is based on the automata-theoretic characterization of regular tree languages formulated in <ref type="bibr" target="#b18">[18]</ref>. In RELAX, a specification expresses a nondeterministic tree automaton. In order to decide whether a given document is accepted by the automaton, an efficient algorithm must work bottom-up in order to carry out a subset construction on the fly. We depart fundamentally from RELAX on this point: we chose to make DSDs similar to deterministic, topdown automata-otherwise, it would not be obvious how DSDs could become a foundation for CSS extended to arbitrary XML. With our semantics, defaults are inserted deterministically as a part of the parsing process; had we chosen a more general automaton model, default insertion would become very complex-seemingly amounting to the solution of a kind of system of equations. Indeed, RELAX is suggested as a notation that is explicitly designed not to support default insertions. We disagree: declarative default mechanisms are so important that they must be supported by the semantics of the schema notation.</p><p>Our notion of constraint assignment is superficially similar to the way automata states are assigned by RELAX to nodes of the XML tree; also, we use the idea of <ref type="bibr" target="#b18">[18]</ref> to express the transition relation by regular expressions over automata states. However, our current semantics is that of a parsing process, not that of automata theory. (We may in the future decide on a purer semantics, although we are committed to a top-down approach.)</p><p>We know of no other work that have suggested a generalization of CSS based on a schema notation; the Simple Tree Transformation Language outlined in <ref type="bibr" target="#b12">[12]</ref> seems similar in ambition but is based on a more operational, and explicit, semantics.</p><p>The DSD notation is similar in some respects to the XSLT transformation language: both employ a top-down traversal of a tree based on testing properties, such as attribute values, of a current node and its ancestors. They differ in that the XSLT expression language is more powerful (so that more properties can be tested), the output may look very different from the input (whereas DSDs only insert element and attribute default), and that there are no unique named constraints assigned to nodes during parsing. DSD with its more restricted formal apparatus allow features such as CSS-like defaults, linear parsing, and redefinitions, which are hard to achieve with XSLT.</p><p>Similarly, the Schematron <ref type="bibr" target="#b14">[14]</ref> proposal is not based on grammatical structures, but uses patterns expressed in XPath/XSLT to impose collections of individual requirements that could possibly be used in conjunction with grammar-based schema notations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">XML CONCEPTS</head><p>The reader is assumed familiar with standard XML concepts, such as those defined in <ref type="bibr" target="#b5">[5]</ref>. The following provides a brief description of the XML object model used in DSDs.</p><p>A well-formed XML document is represented as a tree. The leaf nodes correspond to empty elements, chardata, processing instructions, and comments. The internal nodes correspond to non-empty elements. DTD information is not represented. Each element is label-led with a name and a set of attributes, each consisting of a name and a value. Names, values, and chardata are strings.</p><p>Child nodes are ordered. The content of an element is the sequence of its child nodes. The context of a node is the path of nodes from the root of the tree to the node itself. Element nodes are ordered: An element v is before an element w if the start tag of v occurs before the start tag of w in the usual textual representation of the XML tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE DSD LANGUAGE</head><p>A DSD defines the syntax of a family of conforming XML documents. An application document is an XML document intended to conform to a given DSD. It is the job of a DSD processor to determine whether an application document is conforming or not.</p><p>A DSD is itself an XML document. This section describes the main aspects of the DSD language and its meaning. For a complete definition, we refer to <ref type="bibr" target="#b16">[16]</ref>.</p><p>A DSD is associated to an application document by placing a special processing instruction in the document prolog. This processing instruction has the form &lt;?dsd URI="URI"?&gt;</p><p>where URI is the location of the DSD. A DSD processor basically performs one top-down traversal of the application document in order to check conformance. During this traversal, nodes are assigned constraints by the DSD. A constraint specifies a requirement of a node relative to its context and content that must be fulfilled in order for the document to conform. Initially, a constraint is assigned to the root node. During the checking of a node, its child nodes are assigned new constraints, which are checked later in the traversal. Also, checking a constraint may cause default attributes and child nodes to be inserted. The term the current element is used in the following to refer to the node in the application document that is being processed at a given moment during the traversal.</p><p>If no constraints have been violated upon termination, then the original document conforms to the DSD and the resulting document with defaults inserted is output.</p><p>A DSD consists of a number of definitions, each associated with an ID allowing reference for reuse and redefinition. In the following, the various kinds of definitions are described. We use a number of small examples, some inspired by the XHTML language <ref type="bibr" target="#b20">[20]</ref> and some that are fragments of the book example described in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Element constraints</head><p>The central kind of definition is the element definition. An element definition defines a pair consisting of an element name and a constraint. During the application document processing, the elements in the application documents are assigned IDs of such element definitions. An element can only be assigned the ID of an element definition of the same name.</p><p>The IDs of element definitions are reminiscent of nonterminals in context-free grammars. Each ID determines the requirements imposed on the content, attributes, and context of the element to which it is assigned. We allow several different element definitions with the same name; thus, element names are not used as nonterminals. This distinction allows several versions of an element to coexist.</p><p>As an example, consider a DSD describing a simple database containing information about books, such as, their titles, authors, ISBN numbers, and so on. Imagine that both the whole database and each book entry should contain a title element, but with different structure. Book entry titles may only contain chardata without markup; also, defaults may be specified for book entry titles. Database titles may contain arbitrary content and no attributes. These two kinds of title elements can be defined as follows:</p><p>&lt;ElementDef ID="book-title" Name="title" Defaultable="yes"&gt; &lt;Content&gt;&lt;StringType/&gt;&lt;/Content&gt; &lt;/ElementDef&gt; &lt;ElementDef ID="database-title" Name="title"&gt; &lt;ZeroOrMore&gt; &lt;Union&gt; &lt;StringType/&gt;&lt;AnyElement/&gt; &lt;/Union&gt; &lt;/ZeroOrMore&gt; &lt;/ElementDef&gt; A constraint is defined by a constraint expression, which can contain declarations of attributes, declarations of element content, boolean expressions about attributes and context, and conditional subconstraints guarded by boolean expressions. These aspects are described in the following sections.</p><p>The example below expresses something that is impossible or cumbersome to formalize in other schema proposals. The requirement is that anchor elements in XHTML are not nested:</p><p>&lt;ElementDef ID="a"&gt; &lt;Constraint&gt; &lt;Not&gt; &lt;Context&gt; &lt;Element Name="a"/&gt;&lt;SomeElements/&gt; &lt;/Context&gt; &lt;/Not&gt; &lt;/Constraint&gt; : : : &lt;ElementDef&gt;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Attribute declarations</head><p>During evaluation of a constraint, attributes are declared gradually. Only attributes that have been declared are allowed in an element. Since constraints can be conditional and attributes are declared inside constraints, this evaluation scheme allows hierarchical structures of attributes to be defined. Such structures cannot be described by other schema proposals although they are common; for instance, in a XHTML input element, the length attribute may only be present if the type attribute is present and has value text or password.</p><p>An attribute declaration consists of a name and a string type. The name specifies the name of the attribute, and the string type specifies the set of its allowed values. It is an error if an attribute being declared is not present in the current element, unless it is declared as optional.</p><p>The presence and values of declared attributes can be tested in boolean expressions and context patterns. For instance: &lt;Attribute name="action"&gt; &lt;StringType IDRef="URI"/&gt; &lt;/Attribute&gt; evaluates to true if an attribute named action has been declared, is present in the current element, and its value matches the string type URI.</p><p>Our notion of gradual attribute declaration is essential to the use of CSS-like mechanisms in generic XML settings. For example, the proposed use of CSS in SMIL <ref type="bibr" target="#b13">[13]</ref> is not entirely well-defined: with a CSS-like mechanism both setting and testing attributes in no pre-defined order the result of default insertion is ambiguous. (This ambiguity does not appear when CSS is used to set formating properties that live in a different universe from attributes.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">String types</head><p>A string type is a set of strings defined by a regular expression. String types are used for two purposes: to define valid attribute values and to define valid chardata.</p><p>Regular expressions provide a simple, well-known, and expressive formalism for specification of sets of strings. All reasonable sets can be defined, and by the correspondence with finite-state automata, an efficient implementation is possible. A rich set of operators is provided, such as Sequence, ZeroOrMore, Union, Optional, Intersection, Complement.</p><p>The use of regular expressions is more flexible than using a predefined collection of data types. Furthermore, the relations-ship to finite-state automata guarantees an efficient implementation. Special automata representations, such as MONA <ref type="bibr" target="#b15">[15]</ref>, promises that this approach extends to Unicode <ref type="bibr" target="#b8">[8]</ref>.</p><p>All well-known data types, such as URIs, e-mail addresses, and ZIP codes, can be described by regular expressions. The following example shows the definition of ISBN numbers:</p><p>&lt;StringTypeDef ID="isbn"&gt; &lt;Sequence&gt; &lt;Repeat Value="9"&gt; &lt;Sequence&gt; &lt;CharSet Value="0123456789"/&gt; &lt;Optional&gt; &lt;CharSet Value=" -"/&gt; &lt;/Optional&gt; &lt;/Sequence&gt; &lt;/Repeat&gt; &lt;CharSet Value="0123456789X"/&gt; &lt;/Sequence&gt; &lt;/StringTypeDef&gt;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Content expressions</head><p>The content of an element, its child nodes, can be viewed as a sequence of element nodes and chardata nodes. We ignore other kinds of nodes and assume that there are no adjacent chardata nodes. (Adjacent ones may be joined by concatenation.)</p><p>As a part of an element constraint, a set of valid content sequences can be specified using a formalism which resembles regular expressions, but is modified to take default insertion into account.</p><p>Content expressions are built of atomic expressions and content expression operators. An atomic expression is either an element description or a string type. Element descriptions are used to assign constraints to the child elements, and string types specify chardata child nodes. There is no backtracking across constraint assignments to child elements: once a sequence of children has been matched, the assignment of constraints to them is fixed, and parsing continues in a top-down manner.</p><p>The operators consist of Sequence, ZeroOrMore, AnyElement, Union, If, and a few others.</p><p>As an example, the valid content of a XHTML table element (see <ref type="bibr" target="#b20">[20]</ref> Modulo the syntactic overhead of the XML notation, this example could just as easily be expressed in DTD. But, as explained in the following, DSDs also allow more complex content requirements to be specified.</p><p>A constraint may contain a collection of content expressions. Each of them must match some of the content of the current element, just like each attribute declaration must match an attribute. More precisely, each content expression is matched against a subsequence of the content that consists of elements mentioned in the content expression itself. Thus, the actual content is projected onto the elements that the content expression is about. If, for instance, the content expression mentions elements A and B, and the content is a sequence of elements A, B, C, a chardata node, and an element A, then this expression is matched against the projected content A, B, A (and the match fails). This method makes it easy to specify requirements of both ordered and unordered content. Additionally, unordered content is declared just like attributes.</p><p>In the XHTML specification, the content of the head element is described as "head.misc, combined with a single title and an optional base element in any order". In a DTD, this requirement can be formalized only by listing all the possible combinations in a single regular expression. The XML schema proposal introduces a separate operator to express interleavings. In a DSD, three content expressions in a constraint does the job: &lt;Content IDRef="head.misc"/&gt; &lt;Element IDRef="title"/&gt; &lt;Optional&gt;&lt;Element IDRef="base"/&gt;&lt;/Optional&gt; When checking a set of content expressions, each of them are thus checked in turn on their own subsequence of the content. As an final requirement, each content node must be matched by exactly one content expression. Thus, generally speaking, content expressions in a constraint must not overlap, just as it is an error to declare an attribute more than once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Context patterns</head><p>A context pattern can be used to make defaults, constraints and content descriptions context dependent.</p><p>Context patterns are defined in essence like CSS selectors <ref type="bibr" target="#b1">[1]</ref>. A context pattern is a sequence of context terms; a context term is either an element pattern or a SomeElements element. The context of the current element is a sequence of nodes, starting at the root of the XML tree, and ending in the current element. The context of the current element matches a context pattern if the context can be decomposed into consecutive fragments, such that the sequence of context terms match the sequence of fragments. An element pattern specifies an element name and a set of attributes, and is matched by a single element node if the name and attributes match. A SomeElements is matched by any context fragment. Implicitly, all context patterns begin with a SomeElements element.</p><p>The following example is a context pattern that matches those li elements that are immediately within ul elements inside form elements whose method attribute has value post: &lt;Context&gt; &lt;Element Name="form"&gt; &lt;Attribute Name="method" Value="post"/&gt; &lt;/Element&gt; &lt;SomeElements/&gt; &lt;Element Name="ul"/&gt; &lt;Element Name="li"/&gt; &lt;/Context&gt;</p><p>To see how useful context-dependent definitions are, let us consider a common situation: an XML grammar that represents not one but several related XML notations. For example, a DSD may specify both draft and final markup notations for books. This is the scenario mentioned in the XML 1.0 specification, where conditional sections of DTDs may be used to describe variations:</p><formula xml:id="formula_0">&lt;!ENTITY % draft 'INCLUDE' &gt; &lt;!ENTITY % final 'IGNORE' &gt; &lt;![%draft;[ &lt;!ELEMENT book (comments*, title, body, supplements?)&gt; ]]&gt; &lt;![%final;[ &lt;!ELEMENT book (title, body, supplements?)&gt; ]]&gt;</formula><p>Here, two flags (macros or parameter entities), called draft and final are used to control the expansion of the two conditional definitions of book. Typically, these flags would be declared in the document type declaration of the application document, whereas the conditional sections would be declared in an external DTD. The declarations in the application document are processed before the external DTD.</p><p>As stated, the first conditional definition is expanded since the first item of the conditional definition expands to INCLUDE. Similarly, the second definition is not expanded since the first item expands to IGNORE. In our opinion, this mechanism is cumbersome and unsafe. A document writer must set two flags at the same time, and they must not both be INCLUDE or IGNORE.</p><p>With DSDs, the parameterization of the XML grammar can be explained in terms of the application document itself. For example, if the root element is called DOC, then an attribute draft of this element would govern the definition of a book: Here the logic of the different versions is clearly spelled out at the XML level of the application document itself. We believe that this simple mechanism is not possible with any other of the XML schema proposals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Default insertion</head><p>Default attributes and content are defined by an association to a boolean expression. Such attributes or content is applicable for insertion at a given place in the application document if the boolean expression evaluates to true at that place.</p><p>The following example defines that the length of input fields of type text is by default 20: &lt;Default&gt; &lt;Context&gt; &lt;Element Name="input"&gt; &lt;Attribute Name="type" Value="text"/&gt; &lt;/Element&gt; &lt;/Context&gt; &lt;DefaultAttribute Name="length" Value="20"/&gt; &lt;/Default&gt; Defaults are inserted "upon request" by constraints:</p><p>When an attribute declaration is encountered and the declared attribute is not present in the current element, an applicable default is inserted, if a such exists.</p><p>During evaluation of a content expression, if an element description or a string type is encountered and the next content node does not match the description, then an applicable default is inserted, if a such exists. Default elements can only be inserted if declared as defaultable by the description.</p><p>A notion of specificity of defaults, based on CSS <ref type="bibr" target="#b1">[1]</ref>, is used to determine a default when more than one is applicable. Intuitively, the default with the most complex boolean expression is chosen; if two are equally complex, the one latest defined is chosen.</p><p>For convenience, defaults can also be defined in the application document. Every application document element may contain default definitions, which in a sense extend the DSD. Such default definitions are recognized using the DSD namespace. They are not considered part of the application document by the DSD processor. Their scope are not the whole application document; they are considered as applicable default definitions only in the subtree rooted by the element in which they occur.</p><p>The following example shows how the length default previously defined may be overridden for certain text type input elements, namely those inside form elements that have an action attribute whose value is a string starting with http://www.brics.dk/: &lt;DSD:Default&gt; &lt;Context&gt; &lt;Element Name="form"&gt; &lt;Attribute Name="action"/&gt; &lt;Sequence&gt; &lt;String Value="http://www.brics.dk/"/&gt; &lt;ZeroOrMore&gt;&lt;AnyChar/&gt;&lt;/ZeroOrMore&gt; &lt;/Sequence&gt; &lt;/Attribute&gt; &lt;/Element&gt; &lt;SomeElements/&gt; &lt;Element Name="input"&gt; &lt;Attribute Name="type" Value="text"/&gt; &lt;/Element&gt; &lt;/Context&gt; &lt;DefaultAttribute Name="length" Value="30"/&gt; &lt;/DSD:Default&gt; Defaults defined in the application document are always considered more specific than defaults defined in the DSD document. Furthermore, when two application document defaults are applicable and they are not siblings, the one with the smallest scope, that is, the inner-most, will always be considered more specific than the other.</p><p>Our notion of default mechanism goes much beyond other schema proposals. We do believe that CSS is so useful and well-established that a generic version should be adopted along with a schema language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">ID attributes and points-to requirements</head><p>In attribute declarations, a DSD may declare that application document attributes are of type ID or IDRef, as is also possible with DTDs. An attribute of type ID is considered a definition of the value of the attribute. Such a definition must be unique. Similarly, an IDRef attribute is a reference to the element containing the attribute defining the given value, and such an element must exist.</p><p>Additionally, a DSD may impose a points-to requirement on the element denoted by a reference. Such a requirement is defined by a boolean expression, which may probe attribute values and context as we have seen. This mechanism allows description of semistructured data.</p><p>In the following example, a book-reference attribute is declared. It must refer to an element with an attribute of type ID occurring in a book element: &lt;AttributeDecl ID="book-reference"</p><p>IDType="IDRef"&gt; &lt;PointsTo&gt; &lt;Context&gt;&lt;Element Name="book"/&gt;&lt;/Context&gt; &lt;/PointsTo&gt; &lt;/AttributeDecl&gt; Points-to requirements are checked in a separate phase after the main traversal of the XML tree.</p><p>As explained in Section 4, the DSD language is self-describable. The meta-DSD relies on the ID mechanism to enforce proper use of definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Redefinitions and evolving DSDs</head><p>It is often the case that a whole class of related XML schemas is to be defined. Also, often one wants to create an XML schema from an existing schema by making modifications and extensions. DSDs support these software practices by providing two simple mechanisms: document inclusion and redefinition.</p><p>Both DSD documents and application documents can be created as extensions of other documents using a special include processing instruction of the form &lt;?include URI="URI"?&gt;</p><p>where URI denotes the document to be included, that is, inserted in place of the processing instruction. A document can only be included once into a given document; subsequent attempts are ignored.</p><p>In DSDs, all definitions can be renewed. One can include a document containing a definition of a concept and then later redefine the concept. Since the DSD language is designed to be selfdescribable, the meta-DSD must be able to express this notion of redefinition.</p><p>In order to allow modification and extension of existing application document definitions, two new attribute types, RenewID and Cur-rIDRef, are introduced beside ID and IDRef. All definitions can be redefined using RenewID; an IDRef attribute refers to the last occurring definition or redefinition in the document. An attribute of type CurrIDRef refers to the current definition, which is the last definition or redefinition occurring before which does not contain the element with the CurrIDRef attribute. Assume that in some existing DSD, a book element has been defined as follows:</p><p>&lt;ElementDef ID="book"&gt; &lt;Constraint IDRef="book-constraints"/&gt; &lt;/ElementDef&gt; &lt;ConstraintDef ID="book-constraints"&gt; : : :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&lt;/ConstraintDef&gt;</head><p>Consider a situation where we want to reuse this DSD but would like to extend the book constraints with a new attribute declaration. This can be done using RenewID to redefine book-constraint and CurrIDRef to refer to the original definition:</p><p>&lt;ConstraintDef RenewID="book-constraints"&gt; &lt;Constraint CurrIDRef="book-constraints"/&gt; &lt;AttributeDecl Name="new-attribute"/&gt; &lt;/ConstraintDef&gt; 3.9 Self-documentation Documentation may be associated to most constructs in a DSD. This is treated as meta-information, which does not affect the processing. It allows a DSD to be virtually self-documenting towards application authors. Also, a DSD processor may use this information when errors are detected to provide the author with useful help.</p><p>The DSD language allows three kinds of documentation: Label, which can be used to attach a label to the construct; Doc, which is intended for full documentation of the construct; and BriefDoc, intended for a brief description, which could be translated in a title attribute of HTML (the effect is that a box with the brief documentation pops up when the mouse is over the construct). Documentation may consist of arbitrary XML, but a XHTML-like subset is recommended.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE META-DSD</head><p>The DSD language is self-describable: there is a DSD that completely captures the requirements for an XML document to be a valid DSD. We provide such a DSD of less than 500 lines, called the meta-DSD. It can be used both as a human readable description of DSD to clarify unclear issues, and by DSD processors to check whether a given XML document is a valid DSD. The meta-DSD resides at http://www.brics.dk/DSD/dsd.dsd; thus, all DSD documents should contain the processing instruction: &lt;?dsd URI="http://www.brics.dk/DSD/dsd.dsd"?&gt; stating that they are intended to conform to the meta-DSD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THE BOOK EXAMPLE</head><p>We now present a small example of a complete DSD. It describes an XML syntax for databases of books. Such a description could be arbitrarily detailed; we have settled for title, ISBN number, authors (with homepages), publisher (with homepage), publication year, and reviews. The main structure of the DSD is as follows:</p><p>&lt;?dsd URI="http://www.brics.dk/DSD/dsd.dsd"?&gt; &lt;DSD IDRef="database" DSDVersion="1.0"&gt; &lt;ElementDef ID="database"&gt; &lt;ZeroOrMore&gt; &lt;Element IDRef="book"/&gt; &lt;/ZeroOrMore&gt; &lt;Element IDRef="database-title"/&gt; &lt;/ElementDef&gt; ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&lt;/DSD&gt;</head><p>In the database element we use projected content to allow the title to appear anywhere. The remaining definitions are presented below, excluding the title element and the isbn string type that are shown in Section 3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">THE XPML EXAMPLE</head><p>At AT&amp;T Labs, we have used DSDs to describe XPML, an HTMLlike experimental language that has been developed for programming IVR (Interactive Voice Response) systems. The XPML notation has evolved from being a simple version of HTML, dubbed PML, to becoming a rich programming environment for telephone services that rely on text-to-speech, touchtone input, speech recognition, and call control.</p><p>Often, XPML documents resemble conventional marked-up documents; but sometimes they are heavily customized with many default time and prompt settings, making them more like notations in a programming language. DSDs play an important role, since they can describe almost all syntactic constraints of the language. (Indeed, the needs of PML originally motivated the development of the DSD language.)</p><p>The XPML core: big picture XPML has a simple core, similar to HTML; for example, state ments comprise select, a and menu elements and inline content, where inline is text or audio or span elements. This part of the syntax is describable by DTDs as well. The DSD reflects the fact that the syntax really is more complicated: form statements may occur only when not nested inside another form statement, and input statements may occur only inside a form statement. These context dependencies are easily expressed using a combination of boolean logic and regular expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The XPML core: attribute dependencies</head><p>The type attribute of the input statement determine what other attributes are possible and what the allowed content is. For example, when the type attribute is text, a size attribute is allowed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Platform specific markup</head><p>Variations in hardware or device choices influence language constructs, such as attributes and their value ranges. These constraints are modeled in separate DSDs that amend the description of the core XPML language. For example, the xpml-att DSD describes metric attributes for controlling how information about user sessions are reported back to the server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Additional abstractions</head><p>At the other end of the abstraction spectrum is the need for numerous variations on basic constructs, such as the select element. Each variation is a generic interaction style characterized by how the user is prompted and how error situations are handled. Each interaction style is itself further parameterized by various messages, timeout parameters, and so on. These variations would be hard describe using other formal techniques such as object-oriented types; they are simply too heterogeneous. Nevertheless, they look rather much alike on the surface. As an example, the menu element is already described in the core DSD as containing elements according a regular expression &lt;ElementDef ID="menu"&gt; &lt;OneOrMore&gt; &lt;Sequence&gt; &lt;Element IDRef="menu-option"/&gt; &lt;Optional&gt; &lt;Element IDRef="menu-do"/&gt; &lt;/Optional&gt; &lt;/Sequence&gt; &lt;/OneOrMore&gt; &lt;Constraint IDRef="menu-constraint"/&gt; &lt;Constraint IDRef="menu-dtmf-constraint"/&gt; &lt;/ElementDef&gt;</p><p>The content expression denotes any non-empty sequence of option elements, where each option element allows an optional do element immediately following it. Also, a constraint menu-constraint is introduced to be a place holder for attributes common to both speech and touchtone (DTMF) input as the DSD evolves; similarly, menu-dtmf-constraint is introduced as a place holder for touchtone specific constraints.</p><p>In a separate DSD that describe the interaction style abstraction, the interaction attribute that selects an interaction style, either basic or optional, is introduced, along with the extra elements counttimeout and pause that are allowed: &lt;ConstraintDef RenewID="menu-constraint"&gt; &lt;Constraint CurrIDRef="menu-constraint"/&gt; &lt;AttributeDecl Name="interaction" Optional="yes"&gt; &lt;StringType IDRef="Menu-interaction-name"/&gt; &lt;/AttributeDecl&gt; &lt;If&gt; &lt;Or&gt; &lt;Attribute Name="interaction" Value="basic"/&gt; &lt;Attribute Name="interaction"</p><p>Value="optional"/&gt; &lt;/Or&gt; &lt;Then&gt; &lt;Element Name="counttimeout" Defaultable="yes"&gt; &lt;Constraint IDRef= "message-attributes"/&gt; &lt;Content IDRef= "menu-message-content"/&gt; &lt;/Element&gt; &lt;Element Name="pause" Defaultable="yes"&gt; &lt;Constraint IDRef= "message-attributes"/&gt; &lt;Content IDRef="menu-message-content"/&gt; &lt;/Element&gt; &lt;/Then&gt; &lt;/If&gt; &lt;/ConstraintDef&gt;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Platform dependent defaults</head><p>The number of defaults for XPML is very large; there are many patterns in the assignments, and the CSS-like default mechanism is particularly suited for capturing the defaults in as systematic a way as possible. For example, we can express that both select and menu elements share certain default values for some of their attributes: &lt;Default&gt; &lt;Or&gt; &lt;Context&gt;&lt;Element Name="select"/&gt;&lt;/Context&gt; &lt;Context&gt;&lt;Element Name="menu"/&gt;&lt;/Context&gt; &lt;Context&gt;&lt;Element Name="input"/&gt;&lt;/Context&gt; &lt;/Or&gt; &lt;DefaultAttribute Name="maxtterrs"</p><p>Value="3"/&gt; &lt;DefaultAttribute Name="maxmisselected"</p><p>Value="3"/&gt; &lt;DefaultAttribute Name="maxtimeout"</p><p>Value="2"/&gt; &lt;DefaultAttribute Name="endchars"</p><p>Value="#"/&gt; &lt;DefaultAttribute Name="interdigittimeout"</p><p>Value="4000ms"/&gt; &lt;DefaultAttribute Name="finaltimeout"</p><p>Value="5000ms"/&gt; &lt;DefaultAttribute Name="timeout"</p><p>Value="0ms"/&gt; &lt;/Default&gt;</p><p>We have made a preliminary description of the full XPML language. Our experiments show that almost all of the syntax and static semantics of XPML can be captured as DSDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">THE DSD 1.0 TOOL</head><p>A prototype DSD processor has been implemented and is freely available. This prototype shows that it is possible to implement a complete DSD processor in less than 5000 lines of simple C code. The processor tests conformance of application documents and inserts defaults.</p><p>By using a DSD processor as a front-end for other XML tools, these often become much simpler to construct. The DSD processor itself relies on this technique. Using the meta-DSD it can be checked that a given DSD document is indeed a valid DSD. Then, when using this DSD to check the actual application documents, the processor simply assumes that the DSD is valid. This bootstrapping technique has reduced the size of the implementation and made it more readable.</p><p>The DSD language is designed such that a linear-time processing is possible. The prototype fulfills this property; execution time is proportional to the size of the application document (where DSD defaults are viewed as belonging to an extended DSD). The constant of proportionality depends on the complexity of the given DSD. As an example, a self-application of the meta-DSD takes less than half a second.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functionality</head><p>If an error occurs, that is, if a document is not conforming to its DSD, then a suitable error message is inserted in the document which is then output. If the processing succeeds without errors, then the defaults are added to the application document. As an extra feature, the tool can be instructed to add special attributes that detail the element ID assigned to a node. Such parsing information can be useful in subsequent processing by other XML tools.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>, App. A.1) can be described by the following content expression:</figDesc><table><row><cell>&lt;Sequence&gt;</cell></row><row><cell>&lt;Optional&gt;</cell></row><row><cell>&lt;Element IDRef="caption"/&gt;</cell></row><row><cell>&lt;/Optional&gt;</cell></row><row><cell>&lt;Union&gt;</cell></row><row><cell>&lt;ZeroOrMore&gt;</cell></row><row><cell>&lt;Element IDRef="thead"/&gt;</cell></row><row><cell>&lt;/ZeroOrMore&gt;</cell></row><row><cell>&lt;ZeroOrMore&gt;</cell></row><row><cell>&lt;Element IDRef="tfoot"/&gt;</cell></row><row><cell>&lt;/ZeroOrMore&gt;</cell></row><row><cell>&lt;/Union&gt;</cell></row><row><cell>&lt;Optional&gt;</cell></row><row><cell>&lt;Element IDRef="thead"/&gt;</cell></row><row><cell>&lt;/Optional&gt;</cell></row><row><cell>&lt;Optional&gt;</cell></row><row><cell>&lt;Element IDRef="tfoot"/&gt;</cell></row><row><cell>&lt;/Optional&gt;</cell></row><row><cell>&lt;Union&gt;</cell></row><row><cell>&lt;OneOrMore&gt;</cell></row><row><cell>&lt;Element IDRef="tbody"/&gt;</cell></row><row><cell>&lt;/OneOrMore&gt;</cell></row><row><cell>&lt;OneOrMore&gt;</cell></row><row><cell>&lt;Element IDRef="tr"/&gt;</cell></row><row><cell>&lt;/OneOrMore&gt;</cell></row><row><cell>&lt;/Union&gt;</cell></row><row><cell>&lt;/Sequence&gt;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The isbn attribute is optional; if it is not present in a book, then a title is mandatory. naive definition of url is chosen here. It could be replaced with the full 200 line official definition, which is indeed a regular language.</figDesc><table><row><cell></cell><cell>&lt;review&gt;</cell></row><row><cell>&lt;StringTypeDef ID="url"&gt;</cell><cell>http://www.amazon.com/exec/obidos/ASIN/</cell></row><row><cell>&lt;ZeroOrMore&gt;&lt;AnyChar/&gt;&lt;/ZeroOrMore&gt;</cell><cell>0201485419</cell></row><row><cell>&lt;/StringTypeDef&gt;</cell><cell>&lt;/review&gt; &lt;ElementDef ID="book"&gt; &lt;/book&gt; &lt;AttributeDecl Name="isbn" Optional="yes"&gt; &lt;StringType IDRef="isbn"/&gt; &lt;/database&gt;</cell></row><row><cell></cell><cell>&lt;/AttributeDecl&gt;</cell></row><row><cell></cell><cell>&lt;Sequence&gt;</cell></row><row><cell></cell><cell>&lt;If&gt;&lt;Attribute Name="isbn"/&gt;</cell></row><row><cell></cell><cell>&lt;Then&gt;</cell></row><row><cell></cell><cell>&lt;Optional&gt;</cell></row><row><cell>&lt;StringTypeDef ID="simple"&gt;</cell><cell>&lt;Element IDRef="book-title"/&gt;</cell></row><row><cell>&lt;OneOrMore&gt;</cell><cell>&lt;/Optional&gt;</cell></row><row><cell>&lt;Union&gt;</cell><cell>&lt;/Then&gt;</cell></row><row><cell>&lt;CharRange Start="a" End="z"/&gt;</cell><cell>&lt;Else&gt;</cell></row><row><cell>&lt;CharRange Start="A" End="Z"/&gt;</cell><cell>&lt;Element IDRef="book-title"/&gt;</cell></row><row><cell>&lt;CharSet Value=". -&amp;amp;"/&gt;</cell><cell>&lt;/Else&gt;</cell></row><row><cell>&lt;/Union&gt;</cell><cell>&lt;/If&gt;</cell></row><row><cell>&lt;/OneOrMore&gt;</cell><cell>&lt;OneOrMore&gt;</cell></row><row><cell>&lt;/StringTypeDef&gt;</cell><cell>&lt;Element IDRef="author"/&gt;</cell></row><row><cell></cell><cell>&lt;/OneOrMore&gt;</cell></row><row><cell>&lt;StringTypeDef ID="digits"&gt;</cell><cell>&lt;Element IDRef="publisher"/&gt;</cell></row><row><cell>&lt;ZeroOrMore&gt;</cell><cell>&lt;Element Name="year"&gt;</cell></row><row><cell>&lt;CharRange Start="0" End="9"/&gt;</cell><cell>&lt;StringType IDRef="digits"/&gt;</cell></row><row><cell>&lt;/ZeroOrMore&gt;</cell><cell>&lt;/Element&gt;</cell></row><row><cell>&lt;/StringTypeDef&gt;</cell><cell>&lt;Optional&gt;</cell></row><row><cell></cell><cell>&lt;Element Name="review"&gt;</cell></row><row><cell></cell><cell>&lt;StringType IDRef="url"/&gt;</cell></row><row><cell>Such string types should be part of a standard library.</cell><cell>&lt;/Element&gt; &lt;/Optional&gt;</cell></row><row><cell></cell><cell>&lt;/Sequence&gt;</cell></row><row><cell></cell><cell>&lt;/ElementDef&gt;</cell></row><row><cell>&lt;Default&gt;</cell><cell></cell></row><row><cell>&lt;Context&gt;</cell><cell></cell></row><row><cell>&lt;Element Name="book"/&gt;</cell><cell></cell></row><row><cell>&lt;/Context&gt;</cell><cell></cell></row><row><cell>&lt;DefaultContent&gt;</cell><cell></cell></row><row><cell>&lt;title&gt;Untitled&lt;/title&gt;</cell><cell></cell></row><row><cell>&lt;/DefaultContent&gt; &lt;/Default&gt;</cell><cell>&lt;ElementDef ID="author"&gt; &lt;Sequence&gt;</cell></row><row><cell></cell><cell>&lt;Element Name="first"&gt;</cell></row><row><cell></cell><cell>&lt;StringType IDRef="simple"/&gt;</cell></row><row><cell>This definition allows untitled books to receive the default title</cell><cell>&lt;/Element&gt;</cell></row><row><cell>Untitled. An example of a conforming application document</cell><cell>&lt;Optional&gt;</cell></row><row><cell>looks as follows:</cell><cell>&lt;Element Name="initial"&gt;</cell></row><row><cell></cell><cell>&lt;StringType IDRef="simple"/&gt;</cell></row><row><cell></cell><cell>&lt;/Element&gt;</cell></row><row><cell>&lt;?dsd URI="http://www.brics.dk/DSD/book.dsd"?&gt;</cell><cell>&lt;/Optional&gt;</cell></row><row><cell></cell><cell>&lt;Element Name="last"&gt;</cell></row><row><cell>&lt;database&gt;</cell><cell>&lt;StringType IDRef="simple"/&gt;</cell></row><row><cell>&lt;title&gt;</cell><cell>&lt;/Element&gt;</cell></row><row><cell>&lt;b&gt;Classic Computer Science Books&lt;/b&gt;</cell><cell>&lt;/Sequence&gt;</cell></row><row><cell>&lt;/title&gt;</cell><cell>&lt;Optional&gt;</cell></row><row><cell>&lt;book isbn="0201485419"&gt;</cell><cell>&lt;Element IDRef="homepage"/&gt;</cell></row><row><cell>&lt;title&gt;</cell><cell>&lt;/Optional&gt;</cell></row><row><cell>The Art of Computer Programming</cell><cell>&lt;/ElementDef&gt;</cell></row><row><cell>&lt;/title&gt;</cell><cell></cell></row><row><cell>&lt;author&gt;</cell><cell>&lt;ElementDef ID="publisher"&gt;</cell></row><row><cell>&lt;first&gt;Donald&lt;/first&gt;</cell><cell>&lt;StringType IDRef="simple"/&gt;</cell></row><row><cell>&lt;initial&gt;E&lt;/initial&gt;</cell><cell>&lt;Optional&gt;</cell></row><row><cell>&lt;last&gt;Knuth&lt;/last&gt;</cell><cell>&lt;Element IDRef="homepage"/&gt;</cell></row><row><cell>&lt;homepage&gt;</cell><cell>&lt;/Optional&gt;</cell></row><row><cell>http://www-cs-faculty.stanford.edu/</cell><cell>&lt;/ElementDef&gt;</cell></row><row><cell>Ëknuth/</cell><cell></cell></row><row><cell>&lt;/homepage&gt;</cell><cell></cell></row><row><cell>&lt;/author&gt; &lt;publisher&gt; Addison-Wesley &lt;homepage&gt;http://www.aw.com&lt;/homepage&gt;</cell><cell>An order is imposed on first, initial, and last, but pro-jected content allows the optional homepage element to appear anywhere.</cell></row><row><cell>&lt;/publisher&gt;</cell><cell></cell></row><row><cell>&lt;year&gt;1998&lt;/year&gt;</cell><cell>&lt;ElementDef ID="homepage"&gt;</cell></row><row><cell></cell><cell>&lt;StringType IDRef="url"/&gt;</cell></row><row><cell></cell><cell>&lt;/ElementDef&gt;</cell></row></table><note><p>A</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Processing instructions with target dsd or include, as well as elements and attributes with namespace http://www.brics.dk/ DSD, contain information relevant to the DSD processing. All other processing instructions and also chardata consisting of white-space only and comments are ignored.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>The DSD tool is given the URI of an application document containing a DSD-reference processing instruction. It performs the traversal of the application document as described in Section 3, and if it succeeds, it then performs the points-to check described in Section 3.7.Before the application document is processed, the DSD document (including all application document defaults) is checked to see whether it conforms to the meta-DSD. This check can be omitted by a commandline option if the user is certain that the DSD is in fact valid.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>The DSD language provides a simple but very expressive alternative to other XML schema proposals. It embodies a formal approach to the specification, validation, and default completion of XML syntax. It addresses issues such as context dependencies, CSS-like defaults, schema evolution, semi-structured data, complex data types, and efficient implementation. It has an expressive power similar to XSLT in the sense that XSLT recursion (even with modes) and testing based on boolean expressions probing element and attribute content is expressible as DSDs. Moreover, the DSD language has been implemented and tested in practice (and the implementation is freely available).</p></div>
			</div>


			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Availability</head><p>The DSD processor is available in an open source distribution. Please visit the DSD project home page at: http://www.brics. dk/DSD/ for more information. This home page also contains other DSD resources, such as the official specification of the DSD 1.0 language, example DSDs and application documents, an XSL style-sheet <ref type="bibr" target="#b6">[6]</ref> allowing a pleasing visual rendering of DSD documents, and more.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Bert</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">HÃ¥kon</forename><surname>Wium Lie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Lilley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Jacobs</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/REC-CSS2/" />
		<title level="m">Cascading Style Sheets, level 2, CSS2 Specification. W3C</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Bourret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ingo</forename><surname>Macherius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>St</surname></persName>
		</author>
		<author>
			<persName><surname>Laurent</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/NOTE-ddml" />
		<title level="m">Document Definition Markup Language (DDML) Specification, Version 1.0. W3C</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">Tim</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Frankston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashok</forename><surname>Malhotra</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/NOTE-dcd" />
		<title level="m">Document Content Description for XML. W3C</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">Tim</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Hollander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Layman</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/REC-xml-names" />
		<title level="m">Namespaces in XML. W3C</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Tim</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Paoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Sperberg-Mcqueen</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/REC-xml" />
		<title level="m">Extensible Markup Language (XML) 1.0. W3C</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">James</forename><surname>Clark</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/WD-xslt" />
		<title level="m">XSL Transformations (XSLT) Specification. 1999</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">James</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Derose</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/xpath" />
		<title level="m">XML Path Language. W3C</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://www.unicode.org/" />
		<title level="m">The Unicode Consortium. The Unicode Standard, Version 2.0. Addison Wesley</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Schema for Object-Oriented XML 2.0. W3C</title>
		<author>
			<persName><forename type="first">A</forename><surname>Davidson</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/NOTE-SOX/" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://www.w3.org/TR/xptr" />
		<title level="m">XML Pointer Language. W3C</title>
		<editor>
			<persName><forename type="first">Steve</forename><surname>Derose</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ron</forename><surname>Daniel</surname><genName>Jr</genName></persName>
		</editor>
		<editor>
			<persName><forename type="first">Eve</forename><surname>Maler</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<ptr target="http://www.w3.org/TR/xlink" />
		<title level="m">XML Linking Language. W3C, 2000</title>
		<editor>
			<persName><forename type="first">Steve</forename><surname>Derose</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Eve</forename><surname>Maler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Orchard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ben</forename><surname>Trafford</surname></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Simple tree transformation sheets 3</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Glazman</surname></persName>
		</author>
		<idno>NOTE-STTS3-19981111</idno>
		<ptr target="http://www.w3.org/TR/NOTE-STTS3" />
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>W3C</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Synchronized Multimedia Integration Language (SMIL) 1.0 Specification. W3C</title>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Hoschka</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/REC-smil" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://www.ascc.net/xml/resourceschematron/schematron.html" />
		<title level="m">The Schematron: An XML Structure Validation Language using Patterns in Trees</title>
		<editor>
			<persName><forename type="first">Jeff</forename><surname>Jelliffe</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">MONA Version 1.3 User Manual. BRICS</title>
		<author>
			<persName><forename type="first">Nils</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anders</forename><surname>MÃ¸ller</surname></persName>
		</author>
		<ptr target="http://www.brics.dk/mona" />
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Document Structure Description 1.0. AT&amp;T &amp; BRICS</title>
		<author>
			<persName><forename type="first">Nils</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anders</forename><surname>MÃ¸ller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Schwartzbach</surname></persName>
		</author>
		<ptr target="http://www.brics.dk/DSD/specification.html" />
		<imprint>
			<date type="published" when="1999-10">October 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">Ashok</forename><surname>Malhotra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Murray</forename><surname>Maloney</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/NOTE-xml-schema-req" />
		<title level="m">XML Schema Requirements. W3C</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Hedge automata: a formal model for xml schemata</title>
		<author>
			<persName><forename type="first">Makoto</forename><surname>Murata</surname></persName>
		</author>
		<ptr target="http://www.xml.gr.jp/relax/hedgenice.html" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">How to relax</title>
		<author>
			<persName><forename type="first">Makoto</forename><surname>Murata</surname></persName>
		</author>
		<ptr target="http://www.xml.gr.jp/relax/" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">Steven</forename><surname>Pemberton</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/WD-html-in-xml" />
		<title level="m">XHTML 1.0: The Extensible HyperText Markup Language. W3C</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Dave</forename><surname>Raggett</surname></persName>
		</author>
		<ptr target="http://www.w3.org/People/Raggett/dtdgen/Docs/" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>Assertion grammars. Draft</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName><surname>Thompson</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/xmlschema-1/" />
		<title level="m">XML Schema Part 1: Structures</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
