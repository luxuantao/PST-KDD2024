<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Combining effects: Sum and tensor ଁ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Martin</forename><surname>Hyland</surname></persName>
							<email>m.hyland@dpmms.cam.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics</orgName>
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<postCode>CB3 0WB</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gordon</forename><surname>Plotkin</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="laboratory">Laboratory for the Foundations of Computer Science</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
								<address>
									<addrLine>King&apos;s Buildings</addrLine>
									<postCode>EH9 3JZ</postCode>
									<settlement>Edinburgh</settlement>
									<country key="GB">Scotland, UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Power</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="laboratory">Laboratory for the Foundations of Computer Science</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
								<address>
									<addrLine>King&apos;s Buildings</addrLine>
									<postCode>EH9 3JZ</postCode>
									<settlement>Edinburgh</settlement>
									<country key="GB">Scotland, UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Combining effects: Sum and tensor ଁ</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D43C9C3A205CCA40BC2F222408D5CE64</idno>
					<idno type="DOI">10.1016/j.tcs.2006.03.013</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Computational effect</term>
					<term>Lawvere theory</term>
					<term>Modularity</term>
					<term>Monad</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We seek a unified account of modularity for computational effects. We begin by reformulating Moggi's monadic paradigm for modelling computational effects using the notion of enriched Lawvere theory, together with its relationship with strong monads; this emphasises the importance of the operations that produce the effects. Effects qua theories are then combined by appropriate bifunctors on the category of theories. We give a theory for the sum of computational effects, which in particular yields Moggi's exceptions monad transformer and an interactive input/output monad transformer. We further give a theory of the commutative combination of effects, their tensor, which yields Moggi's side-effects monad transformer. Finally, we give a theory of operation transformers, for redefining operations when adding new effects; we derive explicit forms for the operation transformers associated to the above monad transformers.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>We seek a unified account of modularity for computational effects. More precisely, we seek a mathematical theory that supports the combining of computational effects such as exceptions, side-effects, interactive I/O (i.e., input/output), probabilistic nondeterminism, and nondeterminism. Ideally, we should like to develop natural mathematical operations for the combination of effects, together with associated relevant theory. There is more than one such operation: for example, as we shall see, the combination of side-effects and nondeterminism is of a different nature to the combination of I/O and nondeterminism and, again, one is sometimes interested in different ways to combine even the same pair of effects, for example, side-effects and exceptions. This paper is devoted to two such ways of combining effects: their sum, which, as we shall see, may be employed for combining both exceptions and interactive I/O with other effects; and their commutative combination, their tensor, which, as we shall see, may be employed for combining side-effects with other effects.</p><p>In order to give such operations, we first need a unified way to model the various computational effects individually. In this we start by following Moggi, who, in <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b40">41]</ref>, gave a unified category-theoretic account of computational effects, which he called notions of computation. He modelled each effect by means of a strong monad T on a base category C with finite products. In the case C = Set, the monads corresponding to the effects listed above are: T E = -+ E, T S = (S × -) S , T I/O , where T I/O (X) = Y. (Y I + (O × X) + X) <ref type="bibr" target="#b38">[39]</ref><ref type="bibr" target="#b39">[40]</ref><ref type="bibr" target="#b40">[41]</ref>, the distributions with countable support monad D , and the nonempty finite powerset monad F + . Here E is a countable set of exceptions, S is a set of states, typically analysed as V L where V is a countable set of values and L is a finite set of locations, I is a countable set of inputs, and O is a countable set of outputs. Corresponding monads exist for a general category C, provided it has appropriate additional structure. Moggi's unified approach has proved useful, particularly in functional programming <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>.</p><p>Strong monads in hand, we seek certain binary operations on them. We seek an operation • on strong monads such that</p><formula xml:id="formula_0">T E • T = T T E = T (-+ E),</formula><p>the computationally natural combination of exceptions with I/O and both forms of nondeterminism, and the usual computationally natural combination with side-effects. We also seek an operation ⊗ on strong monads such that</p><formula xml:id="formula_1">T S ⊗ T = T (S × -) S ,</formula><p>the computationally natural combination of side-effects with I/O and both forms of nondeterminism; it is also a possible, if less natural, combination with exceptions which we discuss further below. Finally, we seek an operation * on strong monads such that</p><formula xml:id="formula_2">(T I/O * T )X Y.T (Y I + (O × Y ) + X),</formula><p>the computationally natural combination of interactive I/O with the above effects other than state.</p><p>So we ask: can we give a mathematical theory yielding such binary operations on strong monads? Modulo a few side conditions, the answer is positive and, in order to do so, we make fundamental use of the correspondence between monads and Lawvere theories, which are invariant forms of equational theories <ref type="bibr" target="#b33">[34]</ref>. The base category used in denotational semantics is not Set but, rather, an order-theoretic one, such as -Cpo; the objects of this latter category are the -cpos, i.e., partial orders with least upper bounds of increasing -chains, and the morphisms are the continuous functions, i.e., maps of partial orders that preserve the least upper bounds. So we work with enriched Lawvere theories, supported by the correspondence between them and strong monads in <ref type="bibr" target="#b49">[50]</ref> (and see the expository <ref type="bibr" target="#b52">[53]</ref>).</p><p>Here, we are following an algebraic programme that shifts focus away from monads to the study of natural programming operations that yield the required effects, with the monads given by free algebras for natural theories for the operations <ref type="bibr" target="#b45">[46]</ref> (and see too <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b44">45]</ref>). For instance, rather than emphasise the side-effects monad (S × -) S , we emphasise the operations lookup and update associated with side-effects, and the equations relating them. In the case where S = V L , the operation lookup can be considered as an L-indexed family of V -ary operations, and update can be considered as an L × V -indexed family; the idea is that lookup l (x) proceeds with x v if the contents of l is v and update l,v (y) proceeds with y, having updated l with v. The equations describe the interactions between the lookup and update operations on the same or different locations. Again, rather than emphasise the powerdomain for nondeterminism, we emphasise the operation of nondeterministic choice ∨ with its equations for associativity, symmetry, and idempotence <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b42">43]</ref>. This change in emphasis is computationally natural for all the examples of computational effects listed above. Not all computationally natural operations arise in this way though, only the algebraic ones, defined below; an important example of a nonalgebraic operation is the handle operation, for dealing with raised exceptions. Algebraic operations are in bijective correspondence with generic effects, also defined below; sometimes one, sometimes the other, is the more natural in programming languages. In <ref type="bibr" target="#b39">[40]</ref>, Moggi defined a wider class of operations than ours, including both our algebraic operations and our generic effects, but imposing a weaker naturality condition than we do. However, it is by virtue of restricting to the smaller class of algebraic operations that we are able to find a mathematical theory.</p><p>Having reformulated our account of computational effects in terms of enriched Lawvere theories, we can reformulate our questions in terms of corresponding operations on theories. We may ask if there is a mathematical theory yielding an operation L •L on enriched Lawvere theories L and L such that, for example, in the case of Set, if L is the Lawvere theory L E associated with exceptions, then L • L corresponds to T (-+ E), where L corresponds to T , and similarly for our other two anticipated operations L ⊗ L and L * L. The answers to these reformulated questions are remarkably natural and, in various guises, have existed since the discovery of the notion of Lawvere theory in the 1960s <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b53">54]</ref>.</p><p>In the first and third cases, the required operation on Lawvere theories is just their sum, so L • L = L * L = L + L.</p><p>Here one has the operations for each of the two theories, subject to the equations for each of the two theories, but with no equations relating them. And in the second case, the required operation L ⊗ L is the tensor or Kronecker product of theories, which amounts to taking the operations of both theories and demanding that they commute with each other, while retaining the equations of both. For instance, combining side-effects with nondeterminism, and assuming there are three values, one would have the commutation equation lookup l (x 1 ∨ y 1 , x 2 ∨ y 2 , x 3 ∨ y 3 ) = lookup l (x 1 , x 2 , x 3 ) ∨ lookup l (y 1 , y 2 , y 3 ).</p><p>In a functional language with references and nondeterminism this would induce the program equivalence: let x be !y in (M or N) ≡ (let x be !y in M) or(let x be !y in <ref type="bibr">N)</ref>, where !M is the dereferencing operator and M or N is nondeterministic choice; the semantics of !M is given by the generic effect corresponding to lookup. There is a similar commutation equation for update and ∨, with a corresponding induced program equivalence. References for mathematical theory that supports the tensor product are <ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref>, for which this is a leading example.</p><p>The published work most closely related to ours is that of Moggi and Cenciarelli on monad transformers. They defined a monad transformer to be a function F :|Mon(C)| → |Mon(C)| from the set of strong monads on a category C with finite products to itself <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b6">7]</ref>. For example, their monad transformer for side-effects takes a monad T to the monad T (S × -) S , assuming C is cartesian closed, and S is an object of C. Our view of monad transformers is as specialisations of our binary operations for combining effects. Moggi and Cenciarelli's monad transformers agree with ours, as they must; the difference is that we have an associated mathematical theory, including a computationally natural explanation in terms of the equations governing the interaction between the two effects.</p><p>The question we pose could equally be posed by asking how one might derive the side-effects monad transformer from the side-effects monad qua monad, but the work on monad transformers to date has not answered that. Moreover, our work involves no asymmetry: there seems no a priori reason why the combination of side-effects with nondeterminism should be achieved by applying a side-effects monad transformer to the nondeterminism monad rather than vice versa. And, as is well known, in the case of exceptions the side-effects monad transformer does not give the required result for the usual interpretation of the combination. Rather than the standard (S × (-+ E)) S it gives ((S × -) + E) S .</p><p>Possible uses of the latter combination are for nonrecoverable errors and, more speculatively, for language features for undoing partially completed transactions, e.g., rollback in database languages. In regard to the latter it is worth noting that the combination supports a nonstandard exception-handling mechanism, that, when an exception is raised, restores the state to what it was when the handler was defined, and then executes the handler. This combination of state and exceptions has been termed 'transitional' in <ref type="bibr" target="#b10">[11]</ref>, and 'snapback' in <ref type="bibr" target="#b3">[4]</ref>. In practice, monads for various kinds of exceptions, and even states, would be combined; some sample calculations are given in Section 7.</p><p>There is also relevant previous unpublished work by Paul Levy. He observed that the sum of any monad T with that for exceptions -+ E is given by T (-+ E). He also defined a universal notion of commutative combination of monads and showed that T (S × -) S is the commutative combination of T and (S × -) S with that definition. When the monads have rank, this definition agrees with ours, but the universal construction seems unlikely to exist for all pairs of monads.</p><p>As is well known <ref type="bibr" target="#b4">[5]</ref> the composition of monads is also a monad if there is a distributive law between them. This idea has been used to explain several of the monad transformers that arise in computation, such as the exceptions monad transformer <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b23">24]</ref>. However, there are several not so explicable, such as the state and resumptions monad transformers. The work on dyads <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b51">52]</ref> yields a generalisation of distributive laws that covers the state monad transformer but not the resumptions one.</p><p>As discussed in <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b8">9]</ref>, for a theory of modularity, having shown how to combine effects one needs to know how to redefine operations, lifting them from the old effects to the combinations with the new ones. Such redefinitions are commonly given on a case-by-case basis, see <ref type="bibr" target="#b6">[7]</ref> for a systematic treatment of redefinitions in this way. Here, by restricting to algebraic operations we present a theory prescribing the needed liftings. We define a notion of operation transformer which, by standard universal algebra, is equivalent to that of a monad map. Since we have such maps canonically associated with the + and ⊗ constructions, we can derive operation transformers for them and so also for their associated monad transformers. We note that in <ref type="bibr" target="#b39">[40]</ref> Moggi shows how to redefine members of a certain class of (his) operations; these include our generic effects but not our algebraic operations.</p><p>The paper is organised as follows. We generally first investigate the unenriched case, which largely amounts to the situation where computational effects are modelled in Set. We then explain the more general enriched situation that includes base categories such as -Cpo. This allows us to deal with nontermination, i.e., partiality. In Section 2, we describe the relationship between monads and Lawvere theories, and explain how the latter appear in our leading examples. In Section 3, we develop a theory for the sum of Lawvere theories and explain how this gives rise to the exceptions and interactive I/O monad transformers. In fact they are both examples of a more general sum, of a monad with a free monad; the corresponding monad transformer appears in a slightly different form in <ref type="bibr" target="#b8">[9]</ref>, under the name of the generalised resumptions monad transformer. In Section 4, we explore the tensor product of Lawvere theories and in Section 5, we show that the commutative combination of side-effects with any other Lawvere theory yields the side-effects monad transformer; we also consider some other examples, including the 'complexity' monad transformer from <ref type="bibr" target="#b8">[9]</ref> and the analysis of parallel computation in <ref type="bibr" target="#b17">[18]</ref>. In Section 6 we consider operation transformers and, so far as we can, give explicit definitions of them for the various monad transformers previously considered. In Section 7, we propose a canonical formula for combining the main computational effects we treat in the paper, and discuss several other issues concerning the combination of effects by sum and tensor. Finally, in Appendix A, we outline the fundamental 2-categorical theory that underlies our main results.</p><p>A word on explicit definitions is appropriate here. Where possible we give explicit definitions of monad and operation transformers. We do not claim that these formulae are particularly new, though they may sometimes be more general than have appeared previously. The point is rather that they arise canonically from our general understanding of monad transformers as specialisations of natural binary constructions on Lawvere theories, namely sum and tensor, and from operation transformers via their relation to monad maps. On a slightly different note, we use standard mathematical notation for these explicit definitions; this can be contrasted with Moggi who prefers to use a suitable type theory to aid comprehensibility; again functional programmers prefer to give corresponding definitions in a functional programming language, typically Haskell.</p><p>A clear omission from this paper is the study of distributivity: this seems to be how various forms of nondeterminism combine. For example, the distributivity of probabilistic choice over ordinary choice when combining probabilistic nondeterminism with nondeterminism is discussed in <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b57">58]</ref>, and the distributivity of each of internal and external nondeterminism over each other is discussed in <ref type="bibr" target="#b16">[17]</ref>. Another important question concerns the combination of effects with local state <ref type="bibr" target="#b45">[46]</ref>: this paper only concerns global state. In <ref type="bibr" target="#b45">[46]</ref> local state is specified using an additional operation block together with additional equations, and is modelled using a presheaf category, thereby avoiding any need for models with infinitely many locations. But it is unclear yet how best to integrate this work with enriched Lawvere theories, let alone consider combinations with other effects. Finally, we have not considered the relationship of all these effects with that of continuations; this will be substantially different as, unlike all the other cases, the continuations monad does not have a rank. One can still treat the continuations monad algebraically but that means introducing operations of unbounded rank, which does not make computational sense to us. We therefore believe continuations should be treated separately. In this connection it is worth noting that, were it not for the desire to include continuations in the treatment of monad transformers, Moggi and Cenciarelli might have taken them to be functors F : Mon(C) → Mon(C) equipped with a natural transformation I → F , rather than mere functions; the natural transformation would be used to extend (algebraic) operations, as explained in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Monads and Lawvere theories</head><p>For simplicity of exposition, we start by restricting our attention to the base category Set. All our monads on Set are of countable rank, which means that, in a precise sense, they are of bounded size <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b2">3]</ref>. The category of monads with countable rank is equivalent to the category of countable Lawvere theories, which we now define. All our mathematics generalises to arbitrary rank, but, as all our examples are of countable rank, which includes finite rank, we restrict our exposition to that case.</p><p>Let ℵ 1 denote a skeleton of the category of countable sets and all functions between them. So ℵ 1 has an object for each natural number n and an object for ℵ 0 . Up to equivalence, ℵ 1 is the free category with countable coproducts on 1. So, in referring to ℵ 1 , we implicitly make a choice of the structure of its countable coproducts. Definition 1. A countable Lawvere theory consists of a small category L with countable products and a strict countableproduct preserving identity-on-objects functor I : ℵ op 1 -→ L. A map of countable Lawvere theories from L to L is a strict countable-product preserving functor from L to L that commutes with I and I .</p><p>We sometimes refer to morphisms of a Lawvere theory as operations.</p><p>Definition 2. A model of a countable Lawvere theory L in any category C with countable products is a countableproduct preserving functor M : L -→ C.</p><p>Note that, following Lawvere <ref type="bibr" target="#b32">[33]</ref>, and see <ref type="bibr" target="#b4">[5]</ref>, we ask here for ordinary preservation of countable products. Every such model is equivalent to one in which powers of 1 are strictly preserved. However, the conventional nonstrict version is more convenient in practice: for example, for any model M : L -→ C of L and countable-product preserving functor U : C -→ D, the composite UM is then also a model of L; it also fits well with a 2-categorical treatment <ref type="bibr" target="#b47">[48]</ref>.</p><p>For any countable Lawvere theory L and any category with countable products C, we thus have the category Mod(L, C) of models of L in C; the maps are given by all natural transformations: the naturality condition implies that they respect countable-product structure. There is a canonical forgetful functor U L : Mod(L, C) -→ C. If it has a left adjoint F L , this forgetful functor exhibits Mod(L, C) as coherently equivalent to the category T L -Alg for the monad T L = U L F L thereby induced by L on C. If C is locally countably presentable <ref type="bibr" target="#b2">[3]</ref>, then: the required left adjoint F L exists; U L , and so also T L , have countable rank; and Mod(L, C) is locally countably presentable.</p><p>For a converse in the case that C = Set, given a monad T with countable rank on Set, the category Kl(T )</p><formula xml:id="formula_3">op ℵ 1</formula><p>determined by restricting Kl(T ), the Kleisli category of T to the objects of ℵ 1 is a countable Lawvere theory L T , and the functor from T -Alg to Mod(L T , Set) induced by the restriction is an equivalence of categories. An enriched, thereby more general, version of the following result appears in <ref type="bibr" target="#b49">[50]</ref>.</p><p>Theorem 1. The construction sending a countable Lawvere theory L to T L together with that sending a monad T with countable rank to L T induce an equivalence of categories between the category of countable Lawvere theories and the category of monads with countable rank on Set. Moreover, the comparison functor exhibits an equivalence between the categories Mod(L, Set) and T L -Alg.</p><p>The usual way in which to obtain Lawvere theories is by means of sketches, with the Lawvere theory given freely on the sketch: Barr and Wells' book <ref type="bibr" target="#b5">[6]</ref> treats sketches in loving detail. To give a sketch amounts to giving operations and equations; for countable Lawvere theories one allows the operations to be of countable arity.</p><p>We now consider our main examples from the point of view of countable Lawvere theories. Given a category C with a terminal object and a set X, we write X for the X-fold copower of 1, i.e., X 1.</p><p>Example 1 (Exceptions). The countable Lawvere theory L E for exceptions is the free countable Lawvere theory generated by an operation raise : 0 -→ E, where E is a countable set of exceptions. In terms of operations and equations this corresponds to an E-indexed family of nullary operations with no equations. In terms of models M of L E one has</p><formula xml:id="formula_4">M(raise) : 1 = M(1) 0 -→ M(1) E ,</formula><p>which corresponds to an evident map E -→ M(1), again showing how codomains of operations correspond to parameterisation.</p><p>Note our use here of the countable set E for the codomain of the operation of the Lawvere theory; strictly speaking we should instead have used the corresponding object of ℵ 1 . It is, however, conceptually convenient to allow ourselves such minor liberties.</p><p>The monad induced by L E is T E = -+ E, the exceptions monad mentioned above. More generally, if C is any category with countable sums and a terminal object then the monad induced by L E on C is -+ E.</p><p>Given a category C and a set X, we write (X × -) for the X-fold copower X -, and (-) X for the X-fold power X -.</p><p>Example 2 (Side-effects). The countable Lawvere theory L S for side-effects, where S = V L , with V countable and L finite, is the free countable Lawvere theory generated by the operations lookup : V -→ L and update : 1 -→ L × V subject to the seven natural equations listed in <ref type="bibr" target="#b45">[46]</ref>, four of them specifying interaction equations for lookup and update and three of them specifying commutation equations. Note, as in the case of exceptions, the use of codomains, here L and L × V , to handle indexing at the Lawvere theory level. It is shown in <ref type="bibr" target="#b45">[46]</ref> that this Lawvere theory induces the side-effects monad mentioned above. More generally, if C is any category with countable powers and copowers then, slightly generalising the result in <ref type="bibr" target="#b45">[46]</ref>, the monad induced by L S on C again has the form (S × -) S .</p><p>For the next example, we first need some discussion of free and initial algebras and free monads. Given any endofunctor on a category C, we write ( y. y, ) for the initial -algebra if it exists. If C has binary sums, the free -algebra on an object x can be identified with ( y. ( y + x), ( -+x) ), and the one exists if and only the other does. These free algebras exist if, for example, C is locally countably presentable and has countable rank.</p><p>Next, if the forgetful functor from -alg to C has a left adjoint, we say that the resulting monad is the free monad on and write it as * . If * exists, the category * -Alg for * qua monad is isomorphic to the category -alg for the endofunctor .</p><p>We see from the above that, if C has binary sums, then * can be identified with y. ( y + -) and the one exists if and only if the other does. We further see that if C is locally countably presentable and has countable rank, then * exists and has countable rank <ref type="bibr" target="#b24">[25]</ref>. </p><formula xml:id="formula_5">(Y ) = ∈ O × Y I .</formula><p>Then the monad corresponding to L is * , the free monad on and, as we see from the above, it can be given explicitly by</p><formula xml:id="formula_6">T (X) = Y. ∈ O × Y I + X .</formula><p>The signature functor for exceptions is, evidently, E (Y ) = E and we have already given that for interactive I/O. As before, these are also the forms of and T in the more general situation where the monad is that induced by L on a locally countably presentable category C. We remark that polynomial functors of the above kind appear in the context of categorical models of dependent type theory, where the existence of * corresponds to the existence of W-types <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>Example 4 (Nondeterminism). The countable Lawvere theory L N for (binary) nondeterminism is the countable Lawvere theory freely generated by a binary operation ∨ : 2 -→ 1 subject to equations for associativity, commutativity and idempotence, i.e., the countable Lawvere theory for a semilattice; the corresponding monad on Set is the finite nonempty subset monad, F + .</p><p>Example 5 (Probabilistic nondeterminism). The countable Lawvere theory L P f for finite probabilistic nondeterminism is that freely generated by [0, 1]-many binary operations + p : 2 -→ 1, for p ∈ [0, 1], subject to the equations for associativity, commutativity and idempotence given in <ref type="bibr" target="#b15">[16]</ref>. The induced monad on Set is the distributions with finite support monad, D f .</p><p>There is also a countable Lawvere theory L P for countable probabilistic nondeterminism. This is the theory of superconvex spaces <ref type="bibr" target="#b31">[32]</ref>; it has operations p of countably infinite arity, indexed by sequences p ∈ [0, 1] whose sum is 1, and subject to the two elegant equations: 1.</p><formula xml:id="formula_7">n 0 m n x n = x m , 2.</formula><p>n 0 p n m 0 q nm x m = m 0 ( n 0 p n q nm )x m using an evident notation, and where m n is the Kronecker delta function. The induced monad on Set is the distributions with countable support monad, D .</p><p>Superconvex spaces have, admittedly, a rather profligate collection of operations. However one can economise: they can all be defined in terms of one such operation, for example that where p n = 2 -(n+1) ; it seems not to be known whether there is an elegant equational axiomatisation in terms of this operation alone: an elegant nonequational axiomatisation has been given in <ref type="bibr" target="#b9">[10]</ref>. There is an evident variation of convex spaces which uses instead finite sequences of reals in [0, 1], subject to the analogous axioms; this yields an alternative and elegant presentation of the theory for finite probabilistic nondeterminism.</p><p>Of course Set is not the category of primary interest in denotational semantics. One is more interested in -Cpo, and variants, in order to model recursion. As we now outline, the relationship between countable Lawvere theories and monads with countable rank generalises without fuss to one between countable enriched Lawvere theories and strong monads with countable rank on such categories. We enrich with respect to a category V that is locally countably presentable as a cartesian closed category: -Cpo is one such. It is worth observing that the category of directed complete partial orders (dcpos), a standard alternative to -Cpo in the literature, is not locally presentable.</p><p>The least obvious point to note when enriching Lawvere theories is that the notion of countable product of a single generator does not generalise most naturally to a notion of countable product but rather to a notion of countable cotensor <ref type="bibr" target="#b25">[26]</ref>. The notion of cotensor is the most natural enrichment of the notion of a power-object. Given an object x of a category C and given a set A, the A-fold power x A satisfies the defining condition that there is a bijection of sets:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C(y, x A )C(y, x) A</head><p>natural in y. Enriching this, given an object x of a V-category C and given an object a of V, the cotensor x a satisfies the defining condition that there is an isomorphism in V :</p><formula xml:id="formula_8">C(y, x a )C(y, x) a V-natural in y. When C = V, x a</formula><p>is the exponential. We say that the cotensor x a is countable if a is countably presentable. When V is Set, the countably presentable objects are exactly the countable sets. These objects are harder to characterise in the case of -Cpo, but it can be shown that they include all the -continuous -cpos.</p><p>These cotensors are used to enable enriched Lawvere theories to have as arities objects of V other than discrete ones, meaning those of the form X. As an example, taking V to be Poset, this allows us not only to consider objects such as x 2 (= x 2 = x × x) in a locally ordered category, but also to consider objects such as x , where is Sierpinski space, the two-point partial order ⊥ . This possibility allows us, in describing Poset-theories, to incorporate inequations. For, suppose one wishes to say that f g for two morphisms f, g : x → y; this is accomplished by introducing a third morphism h : x → y and asserting the equations f = y ⊥ o h and g = y o h, where ⊥ and are the two evident maps from 1 to .</p><p>There is an evident dual notion of tensor a ⊗ x generalising the notion of copower. It satisfies the defining condition that there is an isomorphism in V :</p><formula xml:id="formula_9">C(a ⊗ x, y)C(x, y) a V-natural in y; this will prove useful below. When V = Set, A ⊗ x is the A-fold copower of x, i.e., A × x. When C = V, a ⊗ x is the product of a and x.</formula><p>If C is a locally countably presentable as a V-category <ref type="bibr" target="#b26">[27]</ref> (e.g., when C = V ) then it has both tensors and cotensors, the V-functor a ⊗has countable rank, since it is a colimit, and so does (-) a if a is countably presentable.</p><p>We can now proceed to the definition of countable Lawvere V-theories. Define V ℵ 1 to be a skeleton of the full sub-V-category of V determined by the countably presentable objects of V. It is equivalent to the free V-category with countable tensors on 1 <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b49">50]</ref>, so as before we assume a choice of this structure. Definition 3. A countable Lawvere V-theory is a small V-category L with countable cotensors together with a strict countable-cotensor preserving identity-on-objects V-functor I :</p><formula xml:id="formula_10">V op ℵ 1 -→ L. A map of countable Lawvere V-theories from L to L is a strict countable-cotensor preserving V-functor from L to L that commutes with I and I . A model of L in a V-category C with countable cotensors is a countable-cotensor preserving V-functor M : L -→ C.</formula><p>Routinely generalising the unenriched case, for any countable Lawvere V-theory L and any V-category with countable cotensors C, we have a V-category of models of L in C, Mod(L, C); the homobjects are given by homobjects of all V-natural transformations <ref type="bibr" target="#b25">[26]</ref>, and the V-naturality condition implies they respect countable cotensors. There is a canonical forgetful V-functor U L from Mod(L, C) to C. If it has a left V-adjoint F L , this forgetful V-functor exhibits Mod(L, C) as coherently equivalent to the V-category T L -Alg for the V-monad T L = U L F L thereby induced by L on C. If C is locally countably presentable as a V-category, then: the required left V-adjoint F L exists; U L , and so also T L , have countable rank, and Mod(L, C) is locally countably presentable as a V-category.</p><p>For a converse in the case that C = V, given a V-monad T with countable rank on V, the V-category Kl(T )</p><formula xml:id="formula_11">op ℵ 1</formula><p>determined by restricting Kl(T ) to the objects of V ℵ 1 is a countable Lawvere V-theory L T , and the V-functor from T -Alg to Mod(L T , Set) induced by the restriction is an equivalence of V-categories.</p><p>To give a V-enriched V-monad is equivalent to giving a strong monad on V <ref type="bibr" target="#b30">[31]</ref>. So, in order to make the comparison with Moggi's definition a little more direct, we express the main abstract result of <ref type="bibr" target="#b49">[50]</ref> in terms of strong monads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. If V is locally countably presentable as a cartesian closed category, the constructions of T L from L and of L T from T induce an equivalence of categories between the category of countable</head><p>Lawvere V-theories on V and the category of strong monads on V with countable rank. Moreover, the comparison V-functor exhibits an equivalence between the V-categories Mod(L, V ) and T L -Alg.</p><p>A common and important way to generate countable Lawvere V-theories is by taking the free countable Lawvere V-theory on an unenriched countable Lawvere theory. Given an unenriched countable Lawvere theory L, the free countable Lawvere V-theory on L is generated by the operations and equations of L. Note that it will typically have more objects as there may be countably presentable objects other than the discrete ones; these additional objects may, in turn, generate additional maps.</p><p>Write L V for the free V-theory on L. Then the category Mod(L, V ) is isomorphic to the underlying ordinary category of the V-category Mod(L V , V ). And the ordinary monad T 0 generated by the forgetful functor from Mod(L, V ) to V is the underlying ordinary monad of the V-monad generated by the forgetful V-functor from Mod(L V , V ) to V .</p><p>So the passage from L to L V is simple, and we typically overload notation a little by dropping the subscript on L V , thus using the notation L for both an ordinary Lawvere theory and the free V-theory on it. It can additionally happen, as in the case V = -Cpo, that a functor has at most one enrichment to a V-functor, making V-enrichment a property rather than extra structure. In that case one can also gloss over the difference between the enriched and the ordinary monads.</p><p>Before passing to examples with V = -Cpo we first present some remarks on initial and free objects and monads in an enriched context. Given any V-endofunctor on a V-category C, let ( y. y, ) denote the initial -algebra if it exists. If C has V-cotensors, the initial -algebra is the same as the initial algebra of 0 , the underlying ordinary functor of , with one existing if and only if the other does; more generally, the underlying category -alg 0 of the V-category -alg is isomorphic to 0 -alg and the forgetful V-functor from -alg to C has a left V-adjoint if and only if the forgetful functor from 0 -alg to C 0 has an ordinary left adjoint, and these adjoints necessarily agree with each other.</p><p>Next, if C has binary sums, the free -algebra on an object x can be given in terms of initial algebras as ( y. ( y + x), ( -+x) ), with one existing if and only the other does. These free algebras exist if, for example, C is locally countably presentable as a V-category, e.g., when C = V and has countable rank.</p><p>If the forgetful functor from -alg to C has a left V-adjoint, we say that the resulting V-monad is the free V-monad on and write it as * . If * exists, then its underlying monad is the free monad on 0 , and the V-category * -Alg for * qua V-monad is isomorphic to the V-category -alg for .</p><p>We see from the above that when C has binary sums, * is y. ( y + -) with one existing if and only if the other does. We also then see that the monad * exists when C is locally countably presentable as a V-category, e.g., when C = V and has countable rank.</p><p>We conclude this section by looking at some computationally relevant examples of enriched theories in the case V = -Cpo. The first example of a countable Lawvere -Cpo-theory does not arise freely from an unenriched countable Lawvere theory.</p><p>Example 6 (Nontermination). The countable Lawvere -Cpo-theory L for nontermination is the theory freely generated by a nullary operation : 0 -→ 1 subject to the condition that there is an inequality where the unlabelled map is the unique map determined because 0 is the initial object of V ℵ 1 and therefore the terminal object of V op ℵ 1 . The models of L in -Cpo are the -cpos with a least element. The corresponding strong monad T is the lifting construction (-) ⊥ which adds a new least element. It is worth noting that there is at most one morphism from L to any other countable -Cpo-theory L; this reflects the fact that a least element is unique, if it exists.</p><p>Adding a nontermination effect allows us to model recursion in the context of -Cpo; if we then also want to model other effects we have to combine them with nontermination: simply adapting to -Cpo by switching to L -Cpo from L does not suffice. (See <ref type="bibr" target="#b43">[44]</ref> for sufficient conditions for the use of -Cpo-enriched categories and monads to model a call-by-value language with effects and recursion.) We will therefore study the combination of our example effects with nontermination. This is accomplished by combining the relevant L -Cpo with L , either by sum or by tensor, but one must be careful in the case of probabilistic nondeterminism: see the discussion below.</p><p>There is, perhaps, something rather ad hoc about the present treatment of recursion: one simply plucks -Cpo 'out of the air' and then adds a nontermination effect. One wonders if recursion itself can in some sense be thought of as an effect; if not, a more satisfactory treatment of the combination of effects with recursion could perhaps be obtained in the context of axiomatic or synthetic domain theory <ref type="bibr" target="#b11">[12]</ref>.</p><p>We now look again at the examples considered above in the case of Set. For exceptions, interactive I/O and side-effects this is matter of generalising from countable sets to countably presented -cpos.</p><p>Example 7 (Absolutely free theories). Consider the free countable Lawvere -Cpo-theory L on operations op : I → O for ∈ where the I and the O are countably presentable -cpos. The signature functor : -Cpo → -Cpo is defined similarly to before, by</p><formula xml:id="formula_12">(Q) = ∈ O × Q I ,</formula><p>where we mean the usual products and powers in -Cpo. The monad induced by L is again * , the free -Cpo-monad on ; it can be given explicitly, again similarly to before, by</p><formula xml:id="formula_13">T (P ) = Q. ∈ O × Q I + P .</formula><p>As before too, all this generalises to a locally countably presentable -Cpo-category C, where and T have the same form as above, but replacing products and powers by tensors and cotensors, and where T is now the monad on C induced by L. The exceptions and interactive I/O signature functors, E and I/O , and monads, T E and T I/O , are again special cases.</p><p>Example 8 (Side-effects). We can generalise the set V of values, but not the finite set L of locations, to be any countably presentable -cpo. Then we take the countable Lawvere -Cpo-theory L S to be freely given by the diagrams in <ref type="bibr" target="#b45">[46]</ref>, but allowing this more general kind of state. Further generalising the result given there, we obtain that, if C is any -Cpo-category with tensors and cotensors of countably presentable -cpos, then the -Cpo-monad induced on C by L S is (S ⊗ -) S .</p><p>In the cases where the countably presentable -cpos are discrete, the Lawvere -Cpo-theories are the free countable Lawvere -Cpo-theories on the corresponding countable Lawvere theories.</p><p>Example 9 (Nondeterminism). The countable Lawvere -Cpo-theory L N for binary nondeterminism is again that of a semilattice, and so it is the -Cpo-theory freely generated by the corresponding countable Lawvere theory. The induced strong monad T N is the (convex) powerdomain monad <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b17">18]</ref>, taking that on -Cpo to be synonymous with the free -Cpo-semilattice monad.</p><p>There are two more powerdomains: the upper or Smyth one and the lower or Hoare one. As essentially mentioned in <ref type="bibr" target="#b17">[18]</ref> these can also be described by -Cpo-theories. The upper one is given by adding the inequation x ∨ y y and the lower one by the opposite inequation x ∨ y y.</p><p>One can give explicit descriptions of these powerdomains, if necessary making further restrictions on the class of partial orders under consideration; see <ref type="bibr" target="#b14">[15]</ref> for a recent treatment in the context of the category of dcpos.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 10 (Probabilistic nondeterminism).</head><p>A computationally natural presentation of a countable Lawvere -Cpotheory for probabilistic nondeterminism combined with nontermination <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b45">46]</ref> can be obtained by taking the axioms for L P f and L together with an infinitary axiom relating the least element with probabilistic choice. This axiom says that any element x is equal to the limit of the increasing sequence</p><formula xml:id="formula_14">, x + 1/2 , x + 1/2 (x + 1/2 ), . . . .</formula><p>It can be stated within the framework of Lawvere -Cpo-theories by making use of the countably presentable -cpo:</p><formula xml:id="formula_15">0 1 • • • n • • •</formula><p>which can be thought of as the 'standard -chain'.</p><p>This interaction between probabilistic choice and nontermination is unpleasant. Fortunately, however, there is a natural and elegant alternative presentation of the theory, consisting of the axioms of L P together with that of L . There is then no need for any additional axiom on the interaction of probabilistic choice and nontermination.</p><p>We should comment that the standard theory of probabilistic powerdomains was not developed in the category of -cpos, but rather in that of dcpos. The initial definition was in terms of valuations and was shown to be equivalent to an algebraic one on the subclass of the continuous dcpos. Given that background, it seems reasonable to transplant the algebraic treatment of probabilistic nondeterminism to -Cpo to the present context.</p><p>Finally we remark that although our examples mainly concern Set and -Cpo, everything can be done more generally. For everything other than partiality one can replace Set by any category V that is locally countably presentable as a cartesian closed category, interpreting the theories of the various effects in our examples as countable Lawvere Vtheories. To include partiality and to have the least upper bounds needed for recursion one can take V to be locally countably presentable as a cartesian closed -Cpo-category <ref type="bibr" target="#b26">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The sum of effects</head><p>Our leading examples of the sum of effects are given by the combination of exceptions with all the other computational effects we consider: side-effects, interactive I/O and nondeterminism, and by the combination of interactive I/O with all other effects we consider except for side-effects. A succession of results support the construction of the sum of theories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3. The category of countable Lawvere theories is cocomplete.</head><p>This may be proved using the equivalence between countable Lawvere theories and monads on Set of countable rank, together with the analysis of <ref type="bibr" target="#b27">[28]</ref>. The construction of the sum is complicated, especially when attempted in terms of monads: a general construction involves a transfinite induction, with inductive steps being given by a complicated coequaliser <ref type="bibr" target="#b24">[25]</ref>. But all our examples of Lawvere theories are given freely on equational theories. And in those terms, the sum is easy to describe: one takes the operation symbols of both equational theories, renamed, if necessary, to avoid confusion, and takes the axioms of both. The complication arises in passing from the induced equational theory to the Lawvere theory freely generated by it, as, in doing so, one may apply the operations of one theory to the operations of the other, hence the generally transfinite induction.</p><p>Even in terms of equational theories, care is required. For instance, given Lawvere theories L and L , there are always maps of Lawvere theories given by coprojections L -→ L + L and L -→ L + L . But these coprojection functors need not be faithful. For instance, L might be the trivially collapsing theory, i.e., its equations may force L to be equivalent to 1. In that case, L + L is also equivalent to 1, so the coprojection from L is trivial.</p><p>From Theorem 3 we know the sum exists and, when starting with equational theories, we know how to describe it. But for the purposes of calculation, it is still convenient to have a more explicit construction of the sum qua monad. And, under a condition that includes the examples of exceptions and interactive I/O, we can provide that. The key point is that, in both of these cases, the monads are generated by operations subject to no equations. So they may be described as the free monads on endofunctors with countable rank, namely the signature functors E and I/O . We will give characterisations of the sum of a general monad and a free one. It turns out that we can work much more generally than on Set. For simplicity of exposition, we shall start with a category C and assert conditions on it as convenient.</p><p>It is worth remarking that using these ideas one already has an explicit characterisation of sum in the case where both monads are free. It is straightforward to show, e.g., by considering the categories of algebras, that the sum of 1 * and 2 * is ( 1 + 2 ) * , where we now mean the pointwise sum of functors; this is subject to the proviso that C has binary sums and that ( 1 + 2 ) * exists, which it does when C is locally countably presentable and the i have countable rank. As an example, the sum of the exceptions and I/O monads is Y.</p><formula xml:id="formula_16">(E + Y I + O × Y + -).</formula><p>We now turn to our more general case, the explicit characterisation of the sum of a monad and a free monad. Given an endofunctor H : C → C and a monad T : C → C, a distributive law of H over T is a natural transformation : H T → T H subject to commutativity of the evident two diagrams expressing coherence of with respect to the monad structure of T ; this is a slight variation on the usual notion of a distributive law of a monad over a monad as in <ref type="bibr" target="#b4">[5]</ref>.</p><p>Proposition 1. For any endofunctor and monad (T , , ) over a category C, the natural transformation is a distributive law of T over T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 1. The monad T lifts to a monad T on T -alg given by</head><formula xml:id="formula_17">T ((x, )) = T x, T T x x -→ T T x T -→ T x .</formula><p>We denote by ( + T )-Alg the category for which an object consists of an object x of C together with two structures on it: a T -structure : T x → x, for T as a monad, and a -structure : x → x, for as a functor, and with maps being those maps in C that preserve the two structures. The reason for this notation is that ( + T )-Alg is the category of algebras for the monad * + T if that sum exists. There is a canonical functor : T -Alg -→ ( + T )-Alg that sends ((x, :</p><formula xml:id="formula_18">T x → x), : T x → x) to (x, • x : x → x, : T x → x). Lemma 1. The functor : T -Alg -→ ( + T )-Alg is an isomorphism of categories.</formula><p>Proof. The inverse of sends the object (x, : T x → x, : x → x) to the object ((x, • : T x → x), ). Funtoriality and the proof that this is an inverse are mundane. Theorem 4. Given an endofunctor : C -→ C and a monad T : C -→ C, if the free monads * and ( T ) * exist then the sum of monads * + T exists in the category of monads over C and is given by a canonical monad structure on the composite T ( T ) * .</p><p>Proof. If ( T ) * exists, the category T -alg for the endofunctor T is isomorphic to the category ( T ) * -Alg for ( T ) * qua monad. So T is a lifting of T to the category of algebras for the monad ( T ) * . So we have a distributive law of ( T ) * over T , yielding a monad structure on T ( T ) * , with T ( T ) * -Alg isomorphic to T -Alg <ref type="bibr" target="#b4">[5]</ref>. If * also exists, ( + T )-Alg is, by construction, isomorphic to ( * + T )-Alg, yielding the result.</p><p>Note that this result is general and does not refer to local countable presentability. However if C is locally countably presentable and both and T have countable rank then T ( T ) * has countable rank and so it is also the sum in the category of monads over C of countable rank.</p><p>We remark that one can work much more generally still: the characterisation of the sum in Theorem 4 can be made within an arbitrary 2-category with a few limits. In that sense, Theorem 4 is inherently a category-theoretic result, not relying on any substantial fact about Cat. The proof at the 2-categorical level is a straightforward application of Street's formal theory of monads <ref type="bibr" target="#b55">[56]</ref>.</p><p>In <ref type="bibr" target="#b8">[9]</ref>, Cenciarelli and Moggi introduce a generalised resumptions monad transformer, sending T to z.T ( z + x). Their resumptions monad is the special case where is the identity. This amounts to adding the theory L d of a unary operator d : 1 → 1 with no equations to L T ; one can think of the operation d as 'suspending' or 'delaying' computation. It is straightforward to show, using Proposition 5.3 of <ref type="bibr" target="#b54">[55]</ref>, that z.T ( z + x) exists if and only if ( T ) * x does, and that T ( T ) * x and z.T ( z+x) are then isomorphic. So our T ( T ) * is simply another form of the generalised resumptions monad transformer; the point here, as elsewhere, is that we have derived it as part of a general theory of combinations of monads. We can summarise this discussion with the following corollary of Theorem 4: Corollary 2. Given an endofunctor : C -→ C and a monad T : C -→ C, if * and z.T ( z + x) exist, then the sum of monads * + T exists in the category of monads on C and is given by a canonical monad structure on z.T ( z + -).</p><p>In giving this result, we have used a distributive law of T over T . But if we restrict our attention to a monad T and a free monad on an endofunctor where, for definiteness, T and have countable rank on a locally countably presentable category, we can provide a more direct proof of this result, not referring to a distributive law. The category of monads with countable rank on a locally countably presentable category C is monadic over the category of endofunctors with countable rank on C (see <ref type="bibr" target="#b27">[28]</ref>). The construction z.T ( z + x) extends to an endofunctor on the category of monads with rank that lifts an endofunctor on the category of endofunctors with rank. That fact, together with a Bekič-style result and use of Beck's monadicity theorem <ref type="bibr" target="#b4">[5]</ref>, yields a direct proof that the construction z.T ( z + x) agrees with * + T . Theorem 4 yields a characterisation of the monads generated by the sum of the exceptions Lawvere theory with any other Lawvere theory, and also by the sum of the interactive I/O Lawvere theory with any other Lawvere theory. In the case of exceptions, one can give a simpler proof, essentially by observing that the endofunctor is the constant at E and by routinely using that fact to simplify the above argument. In direct terms, the argument is as follows:</p><p>Corollary 3. Given a category C with binary sums, an object E of C, and a monad T on C, the sum of the monads (-+ E) and T exists and is given by the monad T (-+ E).</p><p>Proof (Direct proof). The category T (-+ E)-Alg is isomorphic to T -Alg, where T is the monad on (-+ E)-Alg determined by lifting T , using the canonical distributive law of -+ E over T . By direct calculation, the latter category is in turn isomorphic to ((-+ E) + T )-Alg: a T -algebra consists of an object x together with a morphism E → x and a T -structure on x, that is, a ((-+ E) + T )-algebra.</p><p>This result explains how the exceptions monad transformer, sending a monad T L to the composite T L (-+ E), arises: one takes the disjoint union of the two sets of operations and retains the equations for T L . And this explanation brings with it the theory of coproducts, such as their associativity and commutativity, and their interaction with other operations.</p><p>For interactive I/O, the above argument seems as simple as is likely to be found. It duly induces an interactive I/O monad transformer that sends a monad T on a locally countably presentable category C to the monad T + T I/O given as T ( y. ((T y) I + (O × T y) + -)); the other form of this monad discussed above is z.T (z I + (O × z) + -).</p><p>While we have shown that there is a canonical monad structure on T ( T ) * , we have not given it explicitly. However explicit formulae can be extracted from the proof, and we now give them. First we need some notation. Suppose we are given an endofunctor F : C -→ C, and that the forgetful functor from F -alg to C has a left adjoint, so that the free monad F * on F exists. Then we write F for the unit of the adjunction, F x for the free algebra map, F x : F F * x → F * x, and, for any F -algebra a = (y, ) and f : x → y, we write I F,x,a (f ) : (F * x, F x) → a for the unique morphism of F -algebras such that f = I F,x,a (f ) o F x. Sometimes, as here, it is convenient to use applicative rather than subscript notation with natural transformations.</p><p>Proceeding to the calculation, it will be convenient to write H for T . The unit is</p><formula xml:id="formula_19">I H ------→ H * H * ----→ T H * ,</formula><p>where is the unit of T . For the multiplication, we first give the distributive law * :</p><formula xml:id="formula_20">H * T → T H * whose existence is shown in the proof of Theorem 4. It is * x = I H,T x,a (f ),</formula><p>where f = T ( H x), a = (T H * , ) and :</p><formula xml:id="formula_21">H (T H * )x → T H * x is the composition H (T H * )x H * x ----→ T H H * x T ( H x) ------→ T H * x,</formula><p>where is the multiplication of T . With this, the multiplication of T H * is</p><formula xml:id="formula_22">T H * T H * T * H * ------→ T T H * H * H ----→ T H * ,</formula><p>where H is the multiplication of H * . The extension of a morphism x → T H * y along the unit of T H * can, as usual, be defined from the monad structure. It can also be defined more directly via an intermediate morphism H * x → T H * y defined much like * was, using the properties of the free H -algebra on x.</p><p>To complete our analysis of the sum of Lawvere theories, we give a closedness result. At present, we do not have a substantial relevant application of this result, but it does bear comparison with a result in <ref type="bibr" target="#b19">[20]</ref> that has proved to be of some value, so we mention it: A simple proof follows directly from the fact that a (T +T )-algebra consists of a set x together with both a T -structure and a T -structure on it.</p><p>The formal work in this section enriches without fuss. In particular, the sum is again the correct operation in the enriched setting. And our notation, calculations and formulae lift routinely. The only point that does not enrich routinely is the informal discussion about equational theories: as best we know, there is currently no enriched notion of equational theory corresponding to enriched Lawvere theories. However, that part of the above discussion could be phrased in terms of sketches, for which an enriched account does exist or at least can readily be gleaned from the literature <ref type="bibr" target="#b29">[30]</ref>.</p><p>Spelling out the situation, we have, first, that it is straightforward to calculate sums of free V-monads. They are given by the formula *</p><formula xml:id="formula_23">1 + * 2 = ( 1 + 2 ) * .</formula><p>Next, we have the following series of results: Theorem 6. The category of countable Lawvere V-theories is cocomplete.</p><p>Theorem 7. Given a V-endofunctor : C -→ C and a V-monad T : C -→ C, if the free V-monads * and ( T ) * exist then the sum of V-monads * + T exists in the category of V-monads over C and is given by a canonical V-monad structure on the composite T ( T ) * .</p><p>The above explicit calculation of the canonical monad structure applies verbatim to the enriched situation, using the usual conventions of enriched category theory <ref type="bibr" target="#b25">[26]</ref>.</p><p>Corollary 4. Given a V-endofunctor : C -→ C and a V-monad T : C -→ C, if * and z.T ( z + -) exist, then the sum of V-monads * + T exists in the category of V-monads on C and is given by a canonical V-monad structure on z.T ( z + -).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 5. Given a V-category C with binary sums, an object E of C, and a V-monad T on C, the sum of the V-monads (-+ E) and T exists and is given by the V-monad T (-+ E).</head><p>We now specialise to the case where C = V = -Cpo. There are no interactions between nontermination and raising an exception, or inputting or outputting a value, so they can all be combined by sum. All these possibilities, and more, are covered by the general form of absolutely free -Cpo-theories discussed above. So with</p><formula xml:id="formula_24">(Q) = ∈ O × Q I .</formula><p>Theorem 7 tells us that the sum of * and T can be given in the form</p><formula xml:id="formula_25">Q. ∈ O × Q I ⊥ + - ⊥ ,</formula><p>and Corollary 4 tells us that it can alternatively be given in the form</p><formula xml:id="formula_26">Q. ∈ O × Q I + - ⊥ .</formula><p>So, for example, the combination of all three of exceptions, interactive I/O and nontermination can be written as</p><formula xml:id="formula_27">( Q. E + Q I ⊥ + (O × Q ⊥ ) + -) ⊥ or, alternatively, as Q. (E + Q I + (O × Q) + -) ⊥ .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The commutative combination of effects</head><p>In this section, we consider the tensor product L ⊗ L of countable Lawvere theories L and L <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b53">54]</ref>. We move immediately to the central definition of the section, for base category Set.</p><p>The category ℵ 1 not only has countable coproducts, but also has finite products, which we denote by a × a . The object a × a may also be seen as the coproduct of a copies of a , so, given an arbitrary map f : a -→ b in a countable Lawvere theory, it is immediately clear what we mean by the morphism a × f : a × a -→ a × b . We define f × a by conjugation and, in the following, we suppress the canonical isomorphisms. Definition 5. Given countable Lawvere theories L and L , the countable Lawvere theory L ⊗ L , called the tensor product of L and L , is defined by the universal property of having maps of countable Lawvere theories from L and L to L ⊗ L , with commutativity of all operations of L with respect to all operations of L , i.e., given f : a -→ b in L and f : a -→ b in L , we demand commutativity of the diagram The tensor product always exists because it is defined by operations and equations, or equivalently by a sketch <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. Its existence also follows by appeal to Appendix A. In terms of equational theories, the tensor product is also easy to describe: one takes the operation symbols and equations of each of the two theories, again renaming the operation symbols if necessary to avoid confusion, and adds equations expressing that each operation of one theory commutes with each operation of the other. For example if f is a binary operation symbol of one theory and g is a ternary one of the other, one adds the equation</p><formula xml:id="formula_28">f (g(x 11 , x 12 , x 13 ), g(x 21 , x 22 , x 23 )) = g(f (x 11 , x 21 ), f (x 12 , x 22 ), f (x 13 , x 23 )).</formula><p>The equational form of the commutative combination can be useful as a basis for the calculation of specific examples.</p><p>As usual, we first develop the abstract theory in the unenriched case following <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b53">54]</ref>, giving the enriched version afterwards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 2. There is a canonical extension of the tensor product ⊗ to a symmetric monoidal structure on the category of countable Lawvere theories.</head><p>A proof for this proposition is elementary. The unit for the tensor product is the initial Lawvere theory, i.e., the theory generated by no operations and no equations. This is the initial object of the category of Lawvere theories, so is also the unit for the sum. It induces the identity monad.</p><p>The result gives some indication of the definiteness of the tensor product, but not much: there are typically many symmetric monoidal structures on categories, such as finite product or finite coproduct, and usually many others satisfying no particular universal property. But what is much less common, and is central to the proof of our main theorem about the combination of side-effects with other effects, and indeed is central to the understanding of what commutativity means, is a characterisation of L⊗L in terms of the categories of models of L and L . Relevant, delicate 2-categorical analysis supporting this is in Appendix A; here, we simply state the characterisation in its own terms, the result following from Theorem 16.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 8. For any category C with countable products, there is a coherent equivalence of categories between Mod(L ⊗ L , C) and Mod(L, Mod(L , C)).</head><p>The analysis of this section extends readily to the enriched setting. The V-category V ℵ 1 not only has countable tensors but also has finite products, just as the ordinary category ℵ 1 not only has countable coproducts but also has finite products. Our analysis of a × f in the unenriched setting extends routinely to the enriched setting, except here, of course, we must express the analysis in terms of the object L(a , b ) of V rather than in terms of an arrow f : a -→ b . The key fact is that the cotensor (a x ) y is canonically isomorphic to the cotensors a (x×y) and (a y ) x . Consistently with this, we must express the commutativity condition of the theorem in terms of homobjects of V rather than in terms of arrows like f . Definition 6. Given countable Lawvere V-theories L and L , the countable Lawvere V-theory L ⊗ L , which we call the tensor product of L and L , is defined by the universal property of having maps of countable Lawvere V-theories from L and L to L ⊗ L , subject, suppressing canonical isomorphisms, to commutativity of Once again, the tensor product exists because it is determined by the free theory on an enriched sketch <ref type="bibr" target="#b29">[30]</ref>. But it may equally, indeed more elegantly, be proved to exist by appeal to an enriched version of Appendix A, from which the following result also follows: Theorem 9. The construction L⊗L is symmetric monoidal on the category of countable Lawvere V-theories. Further, for any V-category C with countable cotensors, there is a coherent equivalence of V-categories between Mod(L⊗L , C) and Mod(L, Mod(L , C)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Calculating the tensor product, in particular of side-effects with other effects</head><p>Here, we calculate certain tensor products in more detail, particularly that for side-effects with other computational effects. Our central result shows that, under appropriate hypotheses, our theory of the tensor product of computational effects agrees with Moggi's definition of the side-effects monad transformer. It is as follows: Theorem 10. Let L S be the countable Lawvere theory for side-effects, let L be any countable Lawvere theory, and let C be a locally countably presentable category. Then the induced V-monad T L S ⊗L on C is isomorphic to T L (S ⊗ -) S .</p><p>Proof. By Theorem 9, the category Mod(L S ⊗ L, C) is coherently equivalent to the category Mod(L S , Mod(L, C)). Since C is locally countably presentable, there is an adjunction F L ٜ U L : Mod(L, C) → C with T L = U L F L and, further, the category Mod(L, C) is complete and cocomplete, and so has countable products and coproducts. Therefore, by <ref type="bibr" target="#b45">[46]</ref>, the monad induced by L S on Mod(L, C) is (S × -) S .</p><p>Right adjoints preserve products and left adjoints preserve coproducts. So T L S ⊗L , which is the monad given by the composite forgetful functor from the category Mod(L S , Mod(L, C)) to C, must be given by</p><formula xml:id="formula_29">T L S ⊗L = U L (S × F L -) S (U L F L (S × -)) S T L (S × -) S as required.</formula><p>We do not require rank, in particular countability, for the result. We could define a notion of theory that does not involve a rank, retain a correspondence with strong monads, and make the commutative combination of the theorem, but the general theory becomes more complicated because, as remarked in the introduction, tensor products of such theories seem not always to exist. Corollary 6. The side-effects theory for S = V L is the L-fold tensor product of the side-effects theory for S = V (i.e., the case where L = 1).</p><p>Proof. By the theorem, the tensor product of two side-effects theories, one for S and the other for S , is the side-effects theory for S × S . Now use induction and the finiteness of L.</p><p>Explicit formulae follow for the monad structure of T L (S × -) S . Let and be the unit and multiplication of T L . Then the unit of T L (S × -) S at x is Curry( (S×x) ), where Curry is the transpose function, and the monad multiplication at x is</p><formula xml:id="formula_30">T L (S × (T L (S × x) S )) S T L (eval ) S -------→(TLTL(S × x)) S S S×x ----→ T L (S × x) S ,</formula><p>where eval is the evaluation function, and is the symmetry of product.</p><p>The theorem generalises readily to the enriched setting. Generalising Example 8 from -Cpo-enrichment to Venrichment, we allow the -cpo of values to be instead any countably presentable object of V, but again retain the finite set of locations. The countable Lawvere V-theory L S is again freely given by the diagrams in <ref type="bibr" target="#b45">[46]</ref>, but allowing the more general kind of state. And, once more generalising <ref type="bibr" target="#b45">[46]</ref>, we obtain that, if C is any V-category with tensors and cotensors of countably presentable objects, then the V-monad induced on C by L S is (S ⊗ -) S . Theorem 11. Let L S be the countable Lawvere V-theory for side-effects, let L be any countable Lawvere V-theory, and let C be locally countably presentable as a V-category. Then the induced V-monad T L S ⊗L on C is isomorphic to</p><formula xml:id="formula_31">T L (S ⊗ -) S .</formula><p>Proof. The proof agrees verbatim with that of Theorem 10, subject to systematic reference to enrichment.</p><p>The analogous formulae for the monad structure hold in the enriched case; note too that the explicit description of the V-monad for the tensor agrees with that in the unenriched case.</p><p>As an immediate application of the theorem, we see that the -Cpo-monad induced by the commutative combination of the -Cpo-theories for side-effects and nontermination is ((S ⊗-) ⊥ ) S . The conditions for the tensor product amount here to saying that the operations for state commute with , that is, they are strict. For example, we have the equation update l,v ( ) = which reflects the computational idea that we do not wish to distinguish between nontermination and an updating operation immediately followed by nontermination. This contrasts with, for example, the combination of interactive I/O and nontermination where one does not wish to impose strictness.</p><p>By analysis of the structure of our argument for the commutative combination of side-effects with other effects, we can generalise a little. It follows from Theorem 9 that, if C is locally countably as a V-category, then the V-category Mod(L ⊗ L, C) is coherently equivalent to the V-category Mod(L , Mod(L, C)). And we know that the V-monad T L ⊗L is given by the left adjoint to the forgetful V-functor from Mod(L ⊗ L, C) to C. But Mod(L, C) is locally countably presentable as a V-category since C is. So the forgetful V-functor</p><formula xml:id="formula_32">U L : Mod(L , Mod(L, C)) -→ Mod(L, C)</formula><p>has a left V-adjoint F L . Combining these observations, it follows that T L ⊗L is given by the composite U L T L F L , where T L = U L F L is the V-monad on Mod(L, C) induced by L . The proof of our characterisation of the commutative combination of side-effects with other effects simply amounted to describing T L , then using the preservation properties of left and right adjoints in order to calculate the V-monad U L T L F L .</p><p>Using this technique, we now analyse the combination of nondeterminism and nontermination. Here V = -Cpo, L = L N and L = L .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3. (1)</head><p>The unit map T N is strict at -cpos with a least element.</p><p>(2) The monad T N cuts down to a functor on Mod(L , -Cpo), taken as the category of -cpos with a least element and strict -continuous maps.</p><p>Proof. <ref type="bibr" target="#b0">(1)</ref> For the first claim, let P be an -cpo with a least element. We know that for any -continuous map f : P → T N (P ) there is a unique -continuous homomorphism f : T N (P ) → T N (P ) that makes the following diagram commute :</p><p>(we are omitting object subscripts on unit maps for the sake of notational clarity). Moreover, this assignment of homomorphisms to continuous functions is itself continuous. Now consider the constant map k : P → T N (P ) sending every element of P to N (⊥); one easily sees that k is the constant map sending every element of T N (P ) to N (⊥). But then, since N is monotonic one has that k N , and so k N = id T N (P , which proves that N (⊥) =⊥, as required. (2) For the second claim, we first let P be an -cpo with a least element, to show that T N (P ) is in Mod(L N , Mod(L , -Cpo)). We know from the first part that T N (P ) has a least element; we also have to show that the semilattice operation ∪ is a morphism in Mod(L , -Cpo)) which, since it is certainly continuous, amounts to showing that ⊥ ∪ ⊥=⊥, which follows from idempotence. Next, we have to show that T N preserves morphisms. So let Q be another -cpo with a least element, and consider a strict -continuous map f : P → Q. Then as T N (f ) = N f and the unit map is strict, so is T N (f ), concluding the proof.</p><p>It follows directly from this proposition that T N cuts down to the monad T C considered more generally above, inheriting its monadic structure from T N . We therefore calculate that the commutative combination of T N and T is U T C F = T N U F = T N T , with the first equality arising from the fact that T C lifts T N from -Cpo to Mod(L , -Cpo). It is worth recollecting that such liftings correspond to distributive laws, here one of T over T N , with the resulting monad being again T N T .</p><p>The case of the combination of nondeterminism and nontermination is odd. The extra conditions imposed by the tensor product amount to saying that the two operations commute, i.e., that the following equation holds:</p><formula xml:id="formula_33">∨ = .</formula><p>However this is an instance of idempotency and so the sum and tensor product coincide in this case. There is an argument for regarding the combination as a tensor product since we use the theory of tensors to give an explicit form for the combination.</p><p>The combination of probabilistic nondeterminism and nontermination is entirely analogous to that of nondeterminism and nontermination, provided one uses the theory of countable probabilistic nondeterminism. So the analogue of Proposition 3 holds, with the analogous proof, and one can view the combination as a tensor product of the two theories, with the induced monad being given by the composition of that for probabilistic nondeterminism with that for nontermination.</p><p>Finally, we should mention here an argument for treating the combination of nondeterminism and nontermination as a sum rather than a tensor. It is natural to give the semantics of deadlock as the empty set, as in, e.g., <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2]</ref>, and so to consider a variant L Z of L N which is the theory of a commutative semilattice with a zero. But then one would not consider the tensor product of this with L as that would identify (the constants for) nontermination and deadlock. So one must take the combination to be the sum. However one then finds that the induced monad is not isomorphic to either composition of T and T Z , the monad on -Cpo induced by L Z . This leaves the analogy with L N somewhat imperfect, and so we choose not to prefer either of the two ways of regarding the combination of L N and L .</p><p>Having considered the combination of exceptions and interactive I/O with nontermination in Section 3, we have now considered all combinations of the individual effects under discussion in this paper with nontermination. It is then interesting to consider combinations of pairs of effects with nontermination, since that is what we require when combining nontermination effects under the additional requirement of being able to model recursion.</p><p>For exceptions, we can combine the above results on the combination of a single effect with nontermination by application of Corollary 5. For example, combining exceptions with side-effects and nontermination, we wish the operations associated with side-effects and nontermination to commute, but no others. We therefore want the -Cpomonad induced by the -Cpo-theory L E + (L S ⊗ L ), and that is ((S ⊗ (-+ E)) ⊥ ) S .</p><p>For side-effects, we can instead combine the above results on the combination of a single effect with nontermination by application of Theorem 11. For example, combining side-effects with interactive I/O and nontermination one wants the -Cpo-monad induced by L S ⊗ (L I/O + L ). We already know that the -Cpo-monad induced by</p><formula xml:id="formula_34">L I/O + L is R. (R I + (O ⊗ R) + -) ⊥ ; so the -Cpo-monad we seek is ( R.(R I + (O ⊗ R) + (S × -)) ⊥ ) S .</formula><p>For interactive I/O, we can combine the above results on the combination of a single effect with nontermination by application of Theorem 7 or Corollary 4. For example, for the combination of interactive I/O with nondeterminism and nontermination we want the monad on -Cpo induced by</p><formula xml:id="formula_35">L I/O + (L N ⊗ L ). By Corollary 4 this is Q. T N ((Q I + (O × Q) + -) ⊥ ).</formula><p>If we take the value of this monad at the initial (empty) -cpo, we get a solution to the following recursive domain equation:</p><formula xml:id="formula_36">P T N ((P I + (O × P )) ⊥ ).</formula><p>This is a variation on the various domains of processes used in the denotational semantics of Milner's CCS and its variants, see again <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2]</ref>. The difference lies in the exact nature of the interactive I/O monad chosen (see Section 7 for a general such monad) and the use of the theory of semilattices with a zero to model deadlock.</p><p>Finally, we present two more examples of the commutative combination of effects. First we consider the treatment of resumptions as used for the semantics of parallel imperative programming languages. As mentioned above, Cenciarelli and Moggi's resumptions monad is z.T (z + x) in a category C with binary sums. Using Corollary 4 this gives the usual notion of resumptions in -Cpo taking T to be T N T (S × -) S and x = 1. In terms of -Cpo-theories this is the monad induced by L d + (L S ⊗ (L N ⊗ L )) where we recall that L d is the theory of a unary operator with no equations, regarded as the operation of suspending computation. Note that in this theory d does not commute with nondeterminism. If we wanted d to commute with nondeterminism, but not with state or nontermination, we would naturally be led to consider the theory L H P = (L d + (L S ⊗ L )) ⊗ L N instead. We now show that the work of Hennessy and Plotkin <ref type="bibr" target="#b17">[18]</ref> can be considered in terms of the latter theory.</p><p>They work with an algebra of resumptions in the category ND ⊥ of -Cpo-semilattices with a least element, which is Mod(L N L , -Cpo); the algebra is given by</p><formula xml:id="formula_37">R = B. (S ⊗ (B ⊥ + I )) S ,</formula><p>where I is the tensor unit of ND ⊥ , and (-) ⊥ is the comonad of the adjunction</p><formula xml:id="formula_38">F ٜ U : ND ⊥ → ND,</formula><p>where ND is the category of -Cpo-semilattices. This is not in the form we want; we instead switch to the category ND and consider the algebra</p><formula xml:id="formula_39">R = A. ((S ⊗ (A + I )) ⊥ ) S ,</formula><p>where now (-) ⊥ is the monad UF and I is the tensor unit of ND. One can show that RUR and for the semantic analysis of <ref type="bibr" target="#b17">[18]</ref> one can switch to R. This is now in the required form and the corresponding resumptions monad on ND is A.T (A + -) where T = ((S ⊗-) ⊥ ) S . By Theorem 11, the latter is the -Cpo-monad on ND induced by L S ⊗L and, further, by the discussion on absolutely free -Cpo-theories, the -Cpo-monad induced by L d is the free -Cpo-monad on the identity signature -Cpo-functor. So by Corollary 4, the -Cpo-monad on ND induced by the theory L d + (L S ⊗ L ) is the resumptions monad A.T (A + -) just described.</p><p>It then follows that, by the above analysis of the tensor product of theories, the monad T H P on -Cpo induced by L H P is given by U N ( A.T (A + -))F N . We could thus view <ref type="bibr" target="#b17">[18]</ref> as indeed implicitly working with the theory L H P as, qua -cpo:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R = U N ( A.T (A + I ))U N ( A.T (A + F N (1)))T H P (1).</head><p>Another, perhaps more natural, possibility, would be to recast <ref type="bibr" target="#b17">[18]</ref> in terms of an ND-theory of the form L d + (L S ⊗ L ). However ND is locally countably presentable as a symmetric monoidal category rather than as a cartesian closed one, and cartesian closure is the prevailing assumption of this paper. All the theory of this paper generalises to such symmetric monoidal closed categories except, perhaps, that associated with the state monad. That, prima facie, explicitly depends on cartesian closure as the axioms in <ref type="bibr" target="#b45">[46]</ref> make explicit use of diagonals on arities. We nonetheless expect a suitable generalisation to be found, but, for the moment, the situation remains unclear.</p><p>For our last example of the commutative combination of effects, let M be a monoid in V and consider the combination of any computational effect, given by L or equivalently T L , with the complexity monad M ⊗ -. We have assumed throughout the paper that V is cartesian closed, so M ⊗is just M × -, but our argument here is more general, so we indicate that by our notation. There is a canonical distributive law of the monad M ⊗over T L , obtained using the strength t : M ⊗ T L --→ T L (M ⊗ -) of T L . So T L (M ⊗ -) acquires a canonical monad structure.</p><p>Theorem 12. Let L be any countable Lawvere V-theory, let M be a monoid in V, and let L M be the Lawvere V-theory induced by the monad M ⊗ -. <ref type="formula">1</ref>), such that the corresponding map ¯ : m(1) -→ m(1) M is a map of models. This in turn is equivalent to giving a T L -algebra (x, ) and an M-action : M ⊗ x -→ x on x such that ¯ : x -→ x M is a map of T L -algebras. But that in turn is equivalent to giving a T L (M ⊗ -)-algebra by generalities about distributive laws of monads <ref type="bibr" target="#b4">[5]</ref>. These equivalences are all functorial, yielding an isomorphism from T L M ⊗L -Alg to T L (M ⊗ -)-Alg and hence an isomorphism of monads between T L M ⊗L and T L (M ⊗ -). This result does not make substantial use of size conditions on either V or L and can be generalised readily to an arbitrary strong monad.</p><formula xml:id="formula_40">Then T L (M ⊗ -) is the V-monad induced by L M ⊗ L. Proof. To give a model of L in (M ⊗ -)-Alg is equivalent to giving a model m : L -→ V of L in V, together with an M-action : M ⊗ m(1) -→ m(1) on m(</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 7. The tensor product of</head><formula xml:id="formula_41">M ⊗ -and M ⊗ -is (M ⊗ M ) ⊗ -.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Operation transformers</head><p>We now consider a theory of operation transformers, specifically algebraic operation transformers. Algebraic operations were studied in <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b46">47]</ref> in an enriched setting, with V complete, cocomplete and symmetric monoidal closed; here we restrict our attention to the case where V is locally countably presentable as a cartesian closed category. Let T be a strong monad on V . Then an operation of sort (a, b) on T is a transformation of the form</p><formula xml:id="formula_42">x : (T x) a -→ (T x) b ,</formula><p>where a and b are objects of V ; it is algebraic if it is a V-natural transformation with respect to x as an object of Kl(T ). For example, the nonempty finite power-set monad F + supports the binary choice algebraic operation</p><formula xml:id="formula_43">∨ X : (F + X) 2 -→ F + X,</formula><p>where ∨ X (u, v) = u ∪ v. Other Set-based examples of algebraic operations detailed in <ref type="bibr" target="#b46">[47]</ref> are a binary probabilistic choice operation + r for every real number r in the interval [0, 1] on the monad of finite distributions, a raise operation of sort (0, E) on the monad for exceptions, read and write operations of sorts (I, 1) and (1, O), respectively on the monad T I/O for interactive I/O, and lookup and update operations of sorts (V , L) and (1, L × V ), respectively, on the monad for side-effects. As mentioned in the Introduction, the operation handle, for handling exceptions, is not an algebraic operation. It can be considered as an operation of sort (1 + E, 1), being defined as the composition</p><formula xml:id="formula_44">(T X) 1+E -→ (X × (T X) E ) + (E × (T X) E ) [ T 0 ,eval] -→ T X.</formula><p>However it is only natural with respect to Set, not Kl(-+ E).</p><p>The main result of <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b46">47]</ref> asserted that the enriched Yoneda embedding induces a bijection between maps b -→ a in Kl(T ), i.e., maps b -→ T a in V , and algebraic operations x : (T x) a -→ (T x) b . The correspondence is as follows:</p><p>given a map f : b -→ a in Kl(T ), the corresponding algebraic operation is</p><formula xml:id="formula_45">(T x) a (a ⇒ x) f ⇒x ------→(b ⇒ x)(T x) b ,</formula><p>where x ⇒ y is the Kleisli exponential; and given an algebraic operation x , the corresponding map in Kl(T ) is The map in Kl(T ) is called the generic effect corresponding to and, in the case of infinitary operations such as lookup and update, the generic effect typically appears more directly in a programming language than does the corresponding algebraic operation <ref type="bibr" target="#b46">[47]</ref>.</p><p>In all our examples, the objects a and b lie in the full sub-V-category of V given by V ℵ 1 . Recall that the Lawvere V-theory L T induced by a strong monad T is precisely the restriction of Kl(T ) op to the objects of V ℵ 1 . So we can reformulate a mild restriction of the main result of <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b46">47]</ref> to read: Theorem 13. Given a strong monad T with countable rank on V, the enriched Yoneda embedding induces a bijection between maps a -→ b in L T and algebraic operations:</p><formula xml:id="formula_46">x : (T x) a -→ (T x) b .</formula><p>This result yields the liftings we seek: given countable Lawvere V-theories L and L , we have coprojections inl : L -→ L + L and inr : L -→ L + L . So, by two applications of the theorem and one application of the coprojection, each algebraic operation on T L is sent to an algebraic operation on T L+L ; ditto for L . There are also canonical maps L -→ L ⊗ L and L -→ L ⊗ L , yielding liftings of algebraic operations on T L and T L to algebraic operations on T L⊗L in just the same way.</p><p>To give the coprojection inl : L -→ L+L is equivalent to giving a corresponding coprojection inl : T L -→ T L +T L , and applying the functor inl to an arrow a -→ b in L is equivalent to composing the corresponding monad map inl with a -→ b seen as a generic effect b -→ T L a. Ditto for inr and for replacing + by ⊗.</p><p>Motivated by these remarks, we make a definition of operation transformer that has the spirit of the idea of monad transformer but for algebraic operations rather than monads. Given a strong monad T on V, define the V-category Op(T ) to have the same objects as V, with Op(T )(a, b) defined, using the bijection of <ref type="bibr" target="#b46">[47]</ref>, to make an arrow of Op(T ) an algebraic operation:</p><formula xml:id="formula_47">x : (T x) a -→ (T x) b .</formula><p>So, Op(T ) is isomorphic to Kl(T ) op <ref type="bibr" target="#b46">[47]</ref>, and so there is a canonical V-functor J T : V op -→ Op(T ). Moreover, when T has countable rank, the restriction of Op(T ) to the objects of V ℵ 1 is, by the theorem, isomorphic to L T : size issues do not play a major role here. Definition 7. Given strong monads T and T , an operation transformer from Op(T ) to Op(T ) is a V-functor op : Op(T ) -→ Op(T ) commuting with the canonical V-functors J T and J T .</p><p>It follows from the definitions that, for every strong monad T , the V-category Op(T ) has V-cotensors and every operation transformer preserves them. Proposition 4. To give an operation transformer from Op(T ) to Op(T ) is equivalent to giving a map of strong monads from T to T . If T and T have countable rank, to give an operation transformer is further equivalent to giving a map of Lawvere V-theories from L T to L T .</p><p>Suppose that we have an operation transformer from Op(T ) to Op(T ), with corresponding map of monads : T → T , that is an algebraic operation of sort (a, b), and that is the result of applying the operation transformer to .</p><p>Then is a lifting of in the sense that the following diagram commutes for all objects x:</p><p>To see this, suppose corresponds to the generic effect ¯ : b -→ T a. Then is given by the composite</p><formula xml:id="formula_48">b × (T x) a ¯ ×(T x) a -------→ T a × (T x) a ----→ T x</formula><p>and is given by the composite</p><formula xml:id="formula_49">b × (T x) a ¯ ×(T x) a ------→ T a × (T x) a a ×(T x) a ------→ T a × (T x) a ----→ T x.</formula><p>The dinaturality of evaluation then yields the commutativity of the diagram.</p><p>For explicit constructions of operation transformers, first consider sum. Let C be locally countably presentable as a V-category. Then, given a V-endofunctor and a V-monad (T , , ) on C, and assuming * and ( T ) * exist, we have shown that * + T exists and is given by a canonical V-monad structure on T ( T ) * . It is routine to verify that the coprojections * -→ * + T and T -→ * + T are given by the V-monad maps:</p><formula xml:id="formula_50">* ( T ) * ------→ H * T H * ------→ T H * and T H * : T -→ T H * ,</formula><p>where, as before, we now find it convenient to write H for T . So, the liftings of generic effects b -→ * a and b -→ T a are given by composition with these V-monad maps. The transformer Op(T ) -→ Op(T H * ) can be described directly as follows: the lifting of an algebraic operation</p><formula xml:id="formula_51">x : (T x) a -→ (T x) b is H * x : (T H * x) a -→ (T H * x) b .</formula><p>And a partial description of the transformer Op( * ) -→ Op(T H * ) is given as follows. By the enriched Yoneda lemma, to give a map b -→ a is equivalent to giving a V-natural transformation:</p><p>x : x a -→ ( x) b natural in x as an object of V . But a map b -→ a gives rise, by composition with the unit a -→ * a, to a generic effect b -→ * a and hence to an algebraic operation * x : ( * x) a -→ ( * x) b on * . So every V-natural transformation as above gives rise to an algebraic operation * , to which one may apply the operation transformer. It follows by routine calculation that the lifting of * is</p><formula xml:id="formula_52">(T H * x) a T H * x ------→(H H * x) b ( H x) b ------→(H * x) b ( T H * x) b ------→(T H * x) b .</formula><p>We now consider various examples for C = Set; corresponding examples with nontermination for C = -Cpo are readily available.</p><p>Example 11 (Exceptions). For modelling exceptions, is the constant at E, and so * = ( T ) * = -+ E, and the canonical -+ E → T (-+ E) is (-+ E). The operation raise, of sort (0, E), is inr at X; it arises from the identity map E → 0 and its lifting is X+E inr at X. The operation handle is not an algebraic operation, so our theory does not include it. where read = ( T ) * ( T I )inr I and write = ( T ) * ( T 1)inl(id, 1 t). In turn, read and write themselves are liftings of generic effects read and write for the input monad and the output monad, respectively.</p><p>We do not know any more direct expression of the corresponding algebraic operations than using the formula given above for obtaining them from the generic effects. The generic effects appear more typically in programming languages <ref type="bibr" target="#b46">[47]</ref>, although one does see them in process languages such as Milner's CCS <ref type="bibr" target="#b35">[36]</ref>.</p><p>Example 13 (Side-effects). For the tensor product of L S with any countable Lawvere theory L, the theory maps L -→ L ⊗ L S and L -→ L ⊗ L S correspond to the evident monad maps:</p><formula xml:id="formula_53">T L -→ T L (S × -) S and L (S × -) S : (S × -) S -→ T L (S × -) S .</formula><p>As it is the generic effects for side-effects rather than the corresponding algebraic operations that typically appear directly in programming languages <ref type="bibr" target="#b46">[47]</ref>, we just consider them. The generic effect corresponding to the algebraic operation lookup is</p><formula xml:id="formula_54">deref : L -→ (S × V ) S defined on Set by deref (l)(s) = (s, s(l)).</formula><p>Its lifting by composition with the L (S × -) S is the generic effect</p><formula xml:id="formula_55">deref : L -→ T (S × V ) S defined by deref (l)(s) = T (s, s(l)).</formula><p>The situation for the generic effect assign : L × V -→ (S × 1) S corresponding to the algebraic operation update is similar.</p><p>Liftings of operations on T L are simply characterised. Suppose that is such an operation, say of sort (A, B). Then its lifting to an operation on T L (S × -) S is (T L (S × X) S ) A (T L (S × X) A ) S ( S×X ) S ------→(TL(S × X) S ) B (T L (S × X) B ) S .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Discussion</head><p>In this paper we have shown how to combine different effects in terms of natural operations on Lawvere theories rather than on the corresponding monads. That has allowed us to give an account of two standard ways to combine effects: taking their sum, and taking their commutative combination, or tensor product. We then derived explicit forms for some corresponding combinations of monads. Sum and tensor account for most of the examples in which effects are combined in practice; we have yet to consider distributive combinations, local state and continuations. We have also given canonical ways to lift algebraic operations when adding effects; we have yet to consider other operations such as handle.</p><p>Of course, one may combine more than two effects, so the operations we define may be used several times. This leads us to propose a formula for combining exceptions, side-effects, interactive I/O and (binary) nondeterminism:</p><formula xml:id="formula_56">L E + (L S ⊗ (L I/O + L N )),</formula><p>where we have used the standard combinations, as described above, of exceptions, state, and side-effects with other effects. In terms of monads this is</p><formula xml:id="formula_57">T X = ( Y. F(Y I + (O × Y ) + (S × (X + E)))) S .</formula><p>We also propose similar formulae replacing L N by L P , or other forms of nondeterminism, and also for combinations of just some of these effects; the latter amounts to replacing the Lawvere theories for the effects not combined by the trivial (initial) Lawvere theory. These formulae yield exactly those interactions between operations given when considering binary combinations above, and so: 1. The equations for each effect are retained in the theory for the combination, and no more are added. 2. The equations for the binary interactions we have considered above are retained in the combination, and no more are added. 3. There are no ternary, or higher, interactions. We do not have any independent justification of these formulae; perhaps a theory of observation of computational effects would help. The formulae proposed do however coincide with all the cases we are aware of in the literature.</p><p>Observe that the formula is, in a sense, linear, having the form</p><formula xml:id="formula_58">F E (F S (F I/O (L N ))),</formula><p>where each F is derived from + or ⊗ applied to a particular Lawvere theory. This explains why monad transformers have appeared in functional programming <ref type="bibr" target="#b6">[7]</ref>: one has a monad transformer for each effect and method of its combination and, modulo our correspondence with Lawvere theories, those monad transformers are precisely the F 's. This paper yields the additional point that they arise from general binary operations on Lawvere theories; indeed for state there are two relevant operations and two possible monad transformers. It is less clear whether nondeterminism is as simple because of the symmetry involved in the combination of internal and external nondeterminism <ref type="bibr" target="#b16">[17]</ref>. The above discussion does not, of course, take recursion and nontermination into account. Here one would start with nontermination, and then add the other effects:</p><formula xml:id="formula_59">L E + (L S ⊗ (L I/O + (L N ⊗ L ))),</formula><p>where we are now working in -Cpo.</p><p>The linearity of these formulae is all the more remarkable if one considers the whole range of possibilities for combining several theories by sum and tensor. We can illustrate these best by an example. Consider four theories arranged in a square We can combine these into one theory, with the operations of one L i commuting with those of another if and only if they are adjacent in the square. The resulting theory is the colimit of the diagram This idea is general, applying to any irreflexive graph of theories; let us call such combinations of theories 'graphical combinations'. One can show that any 'polynomial combination' of theories, built up out of + and ⊗, is equivalent to such a graphical combination; the present example is a case in point: the corresponding polynomial combination is (L 1 + L 4 ) ⊗ (L 2 + L 3 ). One may then ask whether the converse is true: are all graphical combinations polynomial?</p><p>To answer such questions, we consider formal polynomials and graphs. Formal polynomials are built out of variables using + and ⊗, obtaining, for example, x ⊗ (y + z) and (x ⊗ y) + (x ⊗ z). Given such a polynomial and a list of variables x 1 , . . . , x n including all those occurring in the polynomial, we obtain a functor Set n → Set in an evident way. One can then also ask when two such formal polynomials are equivalent, meaning that the corresponding functors are naturally isomorphic; this does not depend on the choice of the list of variables, and we will generally suppress mention of the choice.</p><p>The two example polynomials just given are not so equivalent; to see this note that the initial theory is an identity (up to isomorphism) for both + and ⊗, and so, taking y and z to be the initial theory, if the two were equivalent so would be x and x + x. On the other hand, there are some evident equivalences based on the commutativity and associativity natural isomorphisms for + and ⊗; let us call these 'simple' equivalences.</p><p>Formal graphs are finite undirected irreflexive graphs whose nodes are labelled by variables. They denote functors of theories in a way that will be evident from the above discussion of graphical colimits of theories (we again understand a given list of variables here). Formalising remarks made above, one can associate a formal graph with every formal polynomial in such a way that the two denote naturally isomorphic functors:</p><p>• to every variable one associates the graph with one node, labelled by that variable, • to every polynomial of the form p + q one associates the disjoint sum of the graphs associated to p and q, • to every polynomial of the form p⊗q one associates the graph obtained from the disjoint sum of the graphs associated to p and q by adding edges between every node in the first graph and every node in the second one. Note that the graph so associated to a polynomial, other than a variable, is either disconnected or else has a disconnected complement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 5. Two polynomials are simply equivalent if and only if their associated graphs are isomorphic.</head><p>Proof (Sketch). Necessity is obvious; sufficiency follows from the fact that a graph and its complement cannot both be disconnected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 14. The functors associated to two formal graphs are naturally isomorphic if and only if the two graphs are isomorphic.</head><p>Proof. We again just give a sketch of the proof. The implication from right to left is clear. In the other direction, let x i be the variables occurring in the two graphs, for i = 1, n. Consider the two theories L and L obtained from the formal graphs by taking x i to be L i where, as an equational theory, L i is given by two unary function symbols f and g subject to the equation f p i (x) = g p i (x), where p i is the ith prime number. Then, as L and L are isomorphic, so are the two semigroups L(1, 1) and L (1, 1). Note that these semigroups are both generated by copies of f and g, there being one copy for each node of the graph in question.</p><p>As the equations are length-preserving, the semigroup isomorphism must map generators to generators; furthermore, the prime numbers associated to corresponding generators via the above equations must be the same. Thus the isomorphism determines a bijection between the nodes of the two graphs that respects the variables labelling them. This bijection also respects the graph structure, as that yields commutations in the two theories, and hence the two semigroups and such commutations are also preserved by the semigroup isomorphism.</p><p>Note that the proof only makes use of the object part of the two functors. So we also have that two formal graphs are isomorphic if and only if the object parts of their associated functors are isomorphic.</p><p>We are now in a position to answer the two questions formulated above. First, not all graphical combinations are equivalent to polynomial ones: for a counterexample one may take any nontrivial graph such that neither it nor its complement is disconnected; the simplest example is the four-node graph Second, we can characterise polynomial equivalence: Corollary 8. Two polynomials are equivalent if and only if they are simply equivalent.</p><p>The graphical method is convenient for calculating combinations of theories, and we now present two examples concerning state and exceptions. First, suppose we wish to combine the usual exceptions theory L E with the state theory L S and a theory L E u for nonrecoverable errors. One would wish only the last two to commute, giving the graph Following the above translation of polynomials into graphs 'backward', one notes that this is a disjoint combination of the subgraph with the theory L E and the subgraph with the theories L S and L E u , which latter are connected. The corresponding polynomial combination of theories is therefore</p><formula xml:id="formula_60">L E + (L S ⊗ L E u ).</formula><p>Passing to monads, and making use of monad transformers, the corresponding monad can be written as</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F E (F S (T E u )).</head><p>Using previous results, one can then calculate an explicit form for this monad:</p><formula xml:id="formula_61">((S × (-+ E)) + E u ) S .</formula><p>Suppose now we wish instead to have a theory L E for standard exceptions, a theory L E r for exceptions for rollback, as discussed in Section 1, and two theories for state: L S for ordinary state, not subject to rollback, and L S r for state subject to rollback. One would then naturally have the two state theories commute and also the rollback state and exception theories commute. This gives the graph which yields the polynomial combination</p><formula xml:id="formula_62">L E + (L S r ⊗ (L E r + L S )).</formula><p>corresponding monad is F E (F S r (F E r (T S ))), with the explicit form (S × ((S r × (-+ E)) + E r )) S×S r .</p><p>The reader may enjoy the exercise of adding in unrecoverable errors.</p><p>The advantage of the graphical method is that one has only to consider the pairwise relationships; everything else then follows, including which monad transformers are to be applied, if any. We hasten to add that this last example is hardly realistic; for example, for database languages one needs to model databases, which would involve a less naive form of state, and one further needs to bring in additional structure to enable the modelling of parallelism.</p><p>All the binary combinations of effects we have considered in this paper have already appeared in the literature. In principle there could be other computationally interesting combinations, even just using the sum and the commutative combination of theories. However, as far as we can tell, there is not much of interest to be found in this way, although it is certainly good to try. For example, let us consider the four theories, L E , L S , L I/O and L N , working in Set. Taking symmetry into account, there are 20 such combinations of these, of which so far we have only considered seven, namely the six given in the above formula and the transactional combination L E ⊗ L S . However, apart from a known generalisation of the interactive I/O theory, and a possible noninteractive form of input/output, none of the other 13 possibilities seems to yield anything new of computational interest.</p><p>Let us look first at the situation 'along the diagonal', beginning with the sum of theories. For exceptions we have that L E + L E is isomorphic to L E+E , so we obtain nothing new there. For state, we have not studied the sum L S + L S , but neither are we aware of any natural computational interpretation of this theory: what could it mean to have two disjoint sets of states where assignment (or update) in one did not commute with assignment (or update) in the other? We also do not know an explicit form for the induced monad.</p><p>For interactive I/O we obtain a known generalisation of what we have been considering. Take L I , the 'input' theory, to be the absolutely free theory of an operator read : I → 1 and take L O , the 'output' theory, to be the absolutely free theory of an operator write : 1 → O; evidently L I/O is the same as L I + L O . Then a general form of theory, closed under sums, is given by i=1,m</p><formula xml:id="formula_63">L I i + j =1,n L O j .</formula><p>This is the absolutely free theory on operators read : I i → 1 and write j : 1 → O, and it can be used to model m input channels and n output channels. The induced monad is given explicitly by</p><formula xml:id="formula_64">T (X) = Y. i=1,m Y I i + j =1,n (O j × Y ) + X .</formula><p>Everything we said above concerning the simpler case of L I/O and its combinations generalises naturally to this more general theory. However, nothing essentially new is thereby learnt, although, certainly, the applications are wider; it was therefore convenient for us to phrase our discussions above in terms of the special case.</p><p>Finally, turning to nondeterminism, while we have not previously considered the sum L N + L N , neither do we know a computational interpretation; the closest we are aware of is the combination of internal and external nondeterminism, as considered in, e.g., <ref type="bibr" target="#b16">[17]</ref>; but there one naturally imposes additional distributivity equations, as mentioned above.</p><p>Let us now consider the commutative combination of theories along the diagonal. For exceptions we have that L E ⊗ L E is the theory of a single constant with no equations, other than in the trivial case where one of E or E is empty. For state we have that L S ⊗ L S is L S×S which again yields nothing new. For I/O while we have not previously considered L I/O ⊗ L I /O neither can we think of a natural computational interpretation of it, nor of an explicit form for the induced monad. There could be some interest in combinations like L I ⊗ L O in which input and output commute; they may be of use in modelling some kind of noninteractive I/O or stream-based computation. One can at any rate obtain an explicit form for the induced monad: the monad induced by L O is O * ×where O * is the free monoid on O; so, by Theorem 12, that induced by L I ⊗ L O is T I (O * × -). Finally, one can show that L N ⊗ L N is L N , obtaining nothing new.</p><p>Of the remaining five 'off-diagonal' combinations, all are new but none seems to have any computational interest, except perhaps for L I/O ⊗ L N in which nondeterminism commutes with interactive I/O. This suggests some sort of trace model of communicating processes, analogous to the model of <ref type="bibr" target="#b17">[18]</ref> for parallel imperative programs. However, if one tried, for example, to model concurrency in the style of Milner <ref type="bibr" target="#b35">[36]</ref> one would fail as his parallel operator is sensitive to the order of communication and choice. It seems reasonable to judge this last case as unclear.</p><p>As we have seen, in every case of extending effects considered in this paper we obtained a morphism of theories (equivalently of monads); it is these morphisms which yield the natural transformations associated to the monad transformers. Further, according to Proposition 4, operation transformers are equivalent to such morphisms. However, taking the case of Set for simplicity, it follows that the equations holding for an effect are included in those holding for the extension (modulo the theory morphism). But this is odd as, if anything, one would expect a decrease in the equations holding as there is an increase in the available contexts for discriminating computations: the extension will have more operations available for constructing such contexts. It would be interesting to have an independent justification of the conservation of equations; perhaps this could be accomplished through a theory of the observation of effects.</p><p>The heart of this result it applies to us is that the construction that sends a pair of small categories C and D with countable products to the category CP (C, D) of countable-product preserving functors from C to D is a wellbehaved construction. Moreover, for any small categories C and C with countable products, there is a small category C ⊗ C with countable products together with a well-behaved equivalence of categories between CP (C, CP (C, D)) and CP (C ⊗ C , D) natural in D. The theorem only determines the construction C ⊗ C up to coherent equivalence of categories, but, when restricted to countable Lawvere theories, it agrees up to equivalence with the construction we gave in the paper. Thus we may conclude the following: Theorem 16. The construction L ⊗ L on countable Lawvere theories extends to a coherent pseudo-monoidal pseudoclosed structure on the 2-category of small categories with countable products and, for any small category C with countable products, there is a coherent equivalence of categories between Mod(L ⊗ L , C) and Mod(L, Mod(L , C)).</p><p>Upon inspection of the proof one can see that the smallness assumption on the category C is not needed.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3 (</head><label>3</label><figDesc>Interactive I/O). The countable Lawvere theory L I/O for interactive I/O is the free countable Lawvere theory generated by the operations read : I -→ 1 and write : 1 -→ O, where I is a countable set of inputs and O of outputs. In terms of operations and equations this corresponds to an operation of arity I together with an O-indexed family of unary operations, with no equations. The monad T I/O for interactive I/O corresponding to this Lawvere theory is the free monad on I/O where I/O (Y ) = Y I + (O × Y ) is the signature functor determined by the two operations. By the above remarks, we have T I/O (X) = Y. (Y I + (O × Y ) + X). These are also the forms of I/O and T I/O in the more general situation where the monad is that induced by L I/O on a locally countably presentable category C. Exceptions and interactive I/O exemplify a general pattern of 'absolutely free' theories. Consider the free countable Lawvere theory L on the operations op : I → O , for ∈ , where the I and the O are countable sets. Define the corresponding signature functor to be the 'polynomial' functor</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 4 .Theorem 5 .</head><label>45</label><figDesc>Given a countable Lawvere theory L and a category C with countable products, denote by Mod * (L, C) the identity-on-objects/fully faithful factorisation of the forgetful functor U L : Mod(L, C) -→ C. So the objects of Mod * (L, C) are the models of L in C and the maps are just maps in C. We have the following theorem: There is a coherent natural equivalence between Mod * (L + L , C) and Mod * (L, Mod * (L , C)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 a-</head><label>1</label><figDesc>-----→(T a) a a ----→(T a) b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 12 (</head><label>12</label><figDesc>Interactive I/O). The monad for interactive I/O is given by T I/O X = Y. (Y I + (O × Y ) + X) which is * , where = I/O . The generic effects for interactive input and output, read : 1 -→ T I/O (I ) and write : O -→ T I/O (1), then arise from the maps inr id : 1 → I and inl(id, t) : O → 1, respectively; they are ( I )inr id and ( 1)inl(id, t). The liftings of these generic effects are read : 1 -→ T ( Y. ((T Y ) I + (O × T Y ) + I )) and write : O -→ T ( Y. ((T Y ) I + (O × T Y ) + 1)),</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We should like to acknowledge useful conversations with Paul Levy and helpful comments from the referees.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Pseudo-commutativity and pseudo-closedness</head><p>The simplest way we know to explain the extent to which we have a natural closed structure on the category of small categories with countable products is in terms of 2-monads on Cat as developed in <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b20">21]</ref>, cf., also <ref type="bibr" target="#b19">[20]</ref>. The 2-monad of interest to us is the 2-monad T cp for which the 2-category of algebras, pseudo-maps, and 2-cells is the 2-category of small categories with countable products, functors that preserve countable products in the usual sense, and natural transformations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8. A symmetric pseudo-commutativity for a 2-monad T on Cat consists of a family of invertible natural transformations:</head><p>natural in A and B and subject to coherence with respect to the symmetry of Cat and one coherence axiom with respect to each of the strength, unit, and multiplication of T .</p><p>The monad T cp has a unique symmetric pseudo-commutativity. The first main definition of <ref type="bibr" target="#b20">[21]</ref> gives a notion of pseudo-closed structure for a 2-category: it is almost as strong as closed structure, but one needs to relax the definition of closed structure just a little in order to account for the distinctions between preservation and strict preservation of structure such as countable-product structure: the reason, in our setting, that we do not quite have a closed structure is that, given a category C with countable products, the category Mod(ℵ op 1 , C) is equivalent but not isomorphic to C. We do not spell out the detailed definition of pseudo-closed 2-category here. The main result of <ref type="bibr" target="#b20">[21]</ref> (see <ref type="bibr" target="#b18">[19]</ref> for a formulation directed more towards a computer science audience) is as follows: Theorem 15. If T is a symmetric pseudo-commutative accessible 2-monad on Cat, the 2-category of T -algebras and pseudo-maps of T -algebras has a pseudo-monoidal pseudo-closed structure induced by the pseudo-commutative structure of T , coherently with respect to the closed structure of Cat. Corollary 9. The 2-category of small categories with countable products, countable-product preserving functors, and natural transformations is pseudo-monoidal pseudo-closed, coherently with respect to the closed structure of Cat.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Experiments, powerdomains and fully abstract models for applicative multiprogramming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the FCT</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Karpinski</surname></persName>
		</editor>
		<meeting>of the FCT</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="volume">158</biblScope>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A domain equation for bisimulation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="161" to="218" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Adámek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rosický</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Locally Presentable and Accessible Categories</title>
		<title level="s">London Mathematical Society Lecture Note Series</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">189</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">A functional correspondence between monadic evaluators and abstract machines for languages with computational effects</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Danvy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Midtgaard</surname></persName>
		</author>
		<idno>RS-03-35</idno>
		<ptr target="http://www.brics.dk/RS/03/Abs/BRICS-RS-03-Abs/BRICS-RS-03-Abs.html" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Aarhus University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">BRICS Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wells</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Toposes</forename></persName>
		</author>
		<title level="m">Triples and Theories</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wells</surname></persName>
		</author>
		<title level="m">Category Theory for Computing Science</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Benton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APPSEM &apos;00 Summer School</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Dybjer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Pinto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Saraiva</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000. 2000</date>
			<biblScope unit="volume">2395</biblScope>
			<biblScope unit="page" from="42" to="122" />
		</imprint>
	</monogr>
	<note>Monads and effects</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Introduction to Functional Programming Using Haskell</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bird</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A syntactic approach to modularity in denotational semantics</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cenciarelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fifth. Biennial Meeting on Category Theory and Computer Science, CWI Technical Report</title>
		<meeting>Fifth. Biennial Meeting on Category Theory and Computer Science, CWI Technical Report</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A universal characterization of the closed euclidean interval (extended abstract)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Escardó</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Simpson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the LICS &apos;01</title>
		<meeting>of the LICS &apos;01<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="115" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Representing layered monads</title>
		<author>
			<persName><forename type="first">A</forename><surname>Filinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 26th POPL</title>
		<meeting>of the 26th POPL<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Domains and denotational semantics: history, accomplishments and open problems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>O'hearn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Riecke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosolini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. EATCS</title>
		<imprint>
			<biblScope unit="issue">59</biblScope>
			<biblScope unit="page" from="227" to="256" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Algebra-valued functors in general and tensor products in particular</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Freyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Colloq. Math. Wroclaw</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="89" to="106" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Wellfounded trees and dependent polynomial functors</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gambino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hyland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the TYPES 2003</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Berardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Coppo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Damiani</surname></persName>
		</editor>
		<meeting>of the TYPES 2003<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3085</biblScope>
			<biblScope unit="page" from="210" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Gierz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Lawson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mislove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
		<title level="m">Continuous Lattices and Domains, Encyclopedia of Mathematics</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">93</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Probabilistic domains</title>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the CAAP &apos;94</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of the CAAP &apos;94<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">136</biblScope>
			<biblScope unit="page" from="21" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Algebraic Theory of Processes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C B</forename><surname>Hennessy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Full abstraction for a simple parallel programming language</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C B</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the MFCS &apos;79</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Bečvář</surname></persName>
		</editor>
		<meeting>of the MFCS &apos;79<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="page" from="108" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Pseudo-commutative monads</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M E</forename><surname>Hyland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the MFPS</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<meeting>of the MFPS<address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">XVII</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Two-dimensional linear algebra</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M E</forename><surname>Hyland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the CMCS</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<meeting>of the CMCS<address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">47</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Pseudo-commutative monads and pseudo-closed 2-categories</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M E</forename><surname>Hyland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Pure Appl. Algebra</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="141" to="185" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Jones</surname></persName>
		</author>
		<idno>ECS-LFCS-90-105</idno>
		<title level="m">Probabilistic non-determinism</title>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A probabilistic powerdomain of evaluations</title>
		<author>
			<persName><forename type="first">C</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the LICS &apos;89</title>
		<meeting>of the LICS &apos;89<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="186" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Composing monads</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Duponcheel</surname></persName>
		</author>
		<idno>YALEU/DCS/RR-1004</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Yale University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A unified treatment of transfinite constructions for free algebras, Free monoids, colimits, associated sheaves, and so on</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kelly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. Austral. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1" to="83" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Basic Concepts of Enriched Category Theory</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kelly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Structures defined by finite limits in the enriched context I</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kelly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cahiers de Topologie et Géom. Différentielle</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="42" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">whose counits are coequalizers, and presentations of finitary enriched monads</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Pure Appl. Algebra</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page" from="163" to="179" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Combining monads</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1992 Glasgow Workshop on Functional Programming, Workshops in Computing</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Launchbury</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Samson</surname></persName>
		</editor>
		<meeting>1992 Glasgow Workshop on Functional Programming, Workshops in Computing<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="134" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Y</forename><surname>Kinoshita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Takeyama</surname></persName>
		</author>
		<author>
			<persName><surname>Sketches</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Pure Appl. Algebra</title>
		<imprint>
			<biblScope unit="volume">143</biblScope>
			<biblScope unit="page" from="275" to="291" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Monads on symmetric monoidal closed categories</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Arch. Math</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Theory and applications of superconvex spaces</title>
		<author>
			<persName><forename type="first">H</forename><surname>König</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Aspects of Positivity in Functional Analysis, North-Holland Mathematics Studies</title>
		<meeting><address><addrLine>North-Holland, Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">122</biblScope>
			<biblScope unit="page" from="79" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Functorial semantics of algebraic theories and some algebraic problems in the context of functorial semantics of algebraic theories</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Lawvere</surname></persName>
		</author>
		<ptr target="http://www.tac.mta.ca/tac/reprints/articles/5/tr5abs.html" />
	</analytic>
	<monogr>
		<title level="m">Reports of the Midwest Category Seminar II</title>
		<imprint>
			<date type="published" when="1963">1963. 1968. 2004</date>
			<biblScope unit="page" from="1" to="121" />
		</imprint>
		<respStmt>
			<orgName>Columbia University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Algebraic Theories</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Manes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Graduate Texts in Mathematics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<date type="published" when="1976">1976</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Concurrent processes and their syntax</title>
		<author>
			<persName><forename type="first">G</forename><surname>Milne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Mach</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="302" to="321" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and Concurrency</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Nondeterminism and probabilistic choice: obeying the laws</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Mislove</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the CONCUR 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Palamidessi</surname></persName>
		</editor>
		<meeting>of the CONCUR 2000<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1877</biblScope>
			<biblScope unit="page" from="350" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Wellfounded trees in categories</title>
		<author>
			<persName><forename type="first">I</forename><surname>Moerdijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Palmgren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Pure Appl. Logic</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="189" to="218" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Computational lambda-calculus and monads</title>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the LICS &apos;89</title>
		<meeting>of the LICS &apos;89<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">An abstract view of programming languages</title>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
		<idno>ECS-LFCS-90-113</idno>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Notions of computation and monads</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="55" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A powerdomain construction</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="452" to="487" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><surname>Domains</surname></persName>
		</author>
		<ptr target="http://homepages.inf.ed.ac.uk/gdp/publications" />
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Adequacy for algebraic effects</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the FOSSACS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Honsell</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Miculan</surname></persName>
		</editor>
		<meeting>of the FOSSACS<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2030</biblScope>
			<biblScope unit="page" from="1" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Semantics for algebraic operations (extended abstract</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the MFPS</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Brookes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Mislove</surname></persName>
		</editor>
		<meeting>of the MFPS<address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">XVII</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Notions of computation determine monads</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the FOSSACS &apos;02</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Nielsen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Engberg</surname></persName>
		</editor>
		<meeting>of the FOSSACS &apos;02<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2303</biblScope>
			<biblScope unit="page" from="342" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Algebraic operations and generic effects</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Categorical Structures</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="69" to="94" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Why tricategories?</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">120</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="251" to="262" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Modularity in denotational semantics</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the MFPS XIII</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Brookes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Mislove</surname></persName>
		</editor>
		<meeting>of the MFPS XIII<address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Enriched Lawvere theories</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Appl. Categories</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="83" to="93" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modularity and dyads</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Brookes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Jung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Mislove</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Scedrov</surname></persName>
		</editor>
		<meeting><address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">20</biblScope>
		</imprint>
	</monogr>
	<note>Proc. of the MFPS XV</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A modular approach to denotational semantics</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosolini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ICALP 98</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of the ICALP 98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1443</biblScope>
			<biblScope unit="page" from="351" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Variations on algebra: monadicity and generalisations of equational theories</title>
		<author>
			<persName><forename type="first">E</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Festschrift for Professor Rod Burstall</title>
		<imprint>
			<date type="published" when="2002">Nos. 3, 4 and 5, 2002</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="308" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName><surname>Categories</surname></persName>
		</author>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972">1972</date>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Complete axioms for categorical fixed-point operators</title>
		<author>
			<persName><forename type="first">A</forename><surname>Simpson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th. Symp. on Logic in Computer Science</title>
		<meeting>15th. Symp. on Logic in Computer Science<address><addrLine>Silver Sping, MD</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="30" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">The formal theory of monads</title>
		<author>
			<persName><forename type="first">R</forename><surname>Street</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Pure Appl. Algebra</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="149" to="168" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Tix</surname></persName>
		</author>
		<title level="m">Continuous D-cones: convexity and powerdomain constructions</title>
		<meeting><address><addrLine>Aachen</addrLine></address></meeting>
		<imprint>
			<publisher>Shaker Verlag</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universitat Darmstadt</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Semantic Domains for Combining Probability and Non-Determinism</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">129</biblScope>
			<biblScope unit="page" from="1" to="104" />
			<date type="published" when="2005">2005</date>
			<publisher>Elsevier</publisher>
			<pubPlace>Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
