<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sensor networks and distributed CSP: communication, computation and complexity ✩</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ramón</forename><surname>Béjar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Departament d&apos;Informàtica i Enginyeria Industrial</orgName>
								<orgName type="institution">Universitat de Lleida, Jaume II</orgName>
								<address>
									<addrLine>69</addrLine>
									<postCode>E-25001</postCode>
									<settlement>Lleida</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Carmel</forename><surname>Domshlak</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Cornell University</orgName>
								<address>
									<postCode>14853</postCode>
									<settlement>Ithaca</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Cèsar</forename><surname>Fernández</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Departament d&apos;Informàtica i Enginyeria Industrial</orgName>
								<orgName type="institution">Universitat de Lleida, Jaume II</orgName>
								<address>
									<addrLine>69</addrLine>
									<postCode>E-25001</postCode>
									<settlement>Lleida</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Carla</forename><surname>Gomes</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Cornell University</orgName>
								<address>
									<postCode>14853</postCode>
									<settlement>Ithaca</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bhaskar</forename><surname>Krishnamachari</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Electrical Engineering-Systems</orgName>
								<orgName type="institution">University of Southern California</orgName>
								<address>
									<postCode>90089</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bart</forename><surname>Selman</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Cornell University</orgName>
								<address>
									<postCode>14853</postCode>
									<settlement>Ithaca</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Magda</forename><surname>Valls</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Departament de Matemàtica</orgName>
								<orgName type="institution">Universitat de Lleida, Jaume II</orgName>
								<address>
									<addrLine>69</addrLine>
									<postCode>E-25001</postCode>
									<settlement>Lleida</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sensor networks and distributed CSP: communication, computation and complexity ✩</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8DAC6845991AF5C3E969C04AB54E3201</idno>
					<idno type="DOI">10.1016/j.artint.2004.09.002</idno>
					<note type="submission">Received 3 April 2004; accepted 13 September 2004</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Distributed CSP benchmark</term>
					<term>Phase transitions</term>
					<term>Randomized combinatorial search</term>
					<term>Communication network delays</term>
					<term>NP-completeness</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce SensorDCSP, a naturally distributed benchmark based on a real-world application that arises in the context of networked distributed systems. In order to study the performance of Distributed CSP (DisCSP) algorithms in a truly distributed setting, we use a discrete-event network simulator, which allows us to model the impact of different network traffic conditions on the performance of the algorithms. We consider two complete DisCSP algorithms: asynchronous backtracking (ABT) and asynchronous weak commitment search (AWC), and perform performance comparison for these algorithms on both satisfiable and unsatisfiable instances of SensorDCSP. We found that random delays (due to network traffic or in some cases actively introduced by the agents) combined with a dynamic decentralized restart strategy can improve the performance of DisCSP algorithms.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>0004-3702/$ -see front matter  2004 Elsevier B.V. All rights reserved. doi:10.1016/j.artint.2004.09.002</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In recent years we have seen an increasing interest in Distributed Constraint Satisfaction Problem (DisCSP) formulations to model combinatorial problems arising in distributed, multi-agent environments. In the world of networked systems, there is a rich set of distributed applications for which the DisCSP paradigm is particularly useful. In such distributed applications, constraints among agents, such as communication bandwidth and privacy issues, preclude the adoption of a centralized approach. During the last decade, many interesting results have been presented on algorithmic <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b33">[34]</ref><ref type="bibr" target="#b34">[35]</ref><ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b37">38]</ref> and applicative <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b24">25]</ref> issues of dealing with DisCSPs (and this list is far from being exhaustive).</p><p>Study of alternative algorithms for a certain class of computational problems requires a comprehensive set of benchmark domains. These domains should provide us with problem instances inducing various forms of structure and various levels of complexity. Several success stories in the recent research in AI and other related areas show us that a wide palette of benchmark domains, accomplished with extensive analysis of their structure and complexity, helps to develop new algorithmic techniques. Examples of this can be found in the areas of AI planning <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>, SAT solvers <ref type="bibr" target="#b29">[30]</ref>, etc.</p><p>To the best of our knowledge, so far DisCSP algorithms have been mostly studied on benchmarks from classical CSP (such as N-Queens, Graph Coloring, etc.), formulated in a distributed fashion. In this paper we introduce and study SensorDCSP, a naturally distributed benchmark inspired by several distributed applications arising in networked systems <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b18">19]</ref>. SensorDCSP involves a network of distributed sensors simultaneously tracking multiple mobile objects, and the problem underlying SensorDCSP is NP-complete. We show that the SensorDCSP domain undergoes a phase transition in satisfiability with respect to two control parameters: the level of sensor compatibility and the level of the sensor visibility. Standard DisCSP algorithms on problem instances of SensorDCSP exhibit the easy-hard-easy profile in complexity, peaking at the phase transition, which is similar to the pattern observed in centralized CSP algorithms. More interestingly, the relative strength of standard DisCSP algorithms on SensorDCSP is highly dependent on the satisfiability of the instances. This aspect has been overlooked in the literature on account of the fact that, so far, the performance of DisCSP algorithms has been evaluated primarily on satisfiable instances <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref>. We study the performance of two well-known DisCSP algorithms-Asynchronous Backtracking (ABT) <ref type="bibr" target="#b35">[36]</ref>, and Asynchronous Weak-Commitment search (AWC) <ref type="bibr" target="#b34">[35]</ref>-on SensorDCSP. Both ABT and AWC use agent priority ordering during the search process. While these priorities are static in ABT, AWC allows for dynamic changes in the ordering and was originally proposed as an improvement over ABT. One of our findings is that although AWC does indeed perform better than ABT on satisfiable instances, just the opposite is true on unsatisfiable instances.</p><p>Our SensorDCSP benchmark also allows us to study other interesting properties that are specific to DisCSPs and dependent on the physical characteristics of the distributed environment. For example, while the underlying infrastructure or hardware is not critical in studying CSPs, we argue that this is not the case for DisCSPs in communication networks. This is because the traffic patterns and packet-level behavior of networks affect the order in which messages from different agents are delivered to one another, and thus can significantly impact the distributed search process. To investigate these kinds of effects, we implemented our DisCSP algorithms using a fully distributed discrete-event network simulation environment with a complete set of communication oriented classes. The network simulator allows us to realistically model the message delivery mechanisms of varied distributed communication environments ranging from wide-area computer networks to wireless sensor networks.</p><p>We study the impact of communication delays on the performance of DisCSP algorithms. We consider different link-delay distributions. Our results show that the presence of a random element due to the delays can improve the performance of AWC. Moreover, though link delay causes the performance of the standard ABT algorithm to deteriorate, a decentralized restart strategy that we have developed for ABT improves its solution time dramatically while also increasing the robustness of solutions with respect to the variance of the network link-delay distribution. These results are consistent with results on successful randomization techniques that were developed for the purpose of improving the performance of CSP algorithms <ref type="bibr" target="#b8">[9]</ref>. Another novel aspect of our work is the introduction of a mechanism for actively delaying messages. The active delay of messages decreases the communication load of the system and, somewhat counter-intuitively, can also decrease the overall solution time.</p><p>While SensorDCSP provides a general abstraction for many real-life resource allocation problems, in tracking systems (that SensorDCSP was inspired by) the problems typically induce some clear spatial structure, leading to a relatively high decomposability of the problem. Addressing these systems, we introduce GSensorDCSP, a variant of SensorDCSP in which constrainedness of compatibility and visibility is conditioned by the locations of the sensors and objects on the plane. For this benchmark we perform both analytical and empirical complexity analysis. We show that, inspite of its inherently decomposable nature, GSensorDCSP is NP-complete, except for some special tractable cases. Identification of these tractable cases allows us to study performance of the DisCSP algorithms on a provably polynomial distributed problems. On the other hand, we show that DisCSP algorithms scale nicely on a wide subclass of GSensorDCSP, and this scalability makes using DisCSP algorithms feasible in many real-life applications. In particular, we analyze the AWC algorithm on a sequence of GSensorDCSP problems that represent a system of sensors tracking a set of moving objects. We discuss some properties of such a dynamic GSensorDCSP, and show how these properties could be exploited in the dynamic tracking systems.</p><p>The remainder of the paper is organized as follows: In Section 2 we describe SensorD-CSP and model it as a DisCSP. In Section 3 we describe two standard DisCSP algorithms and the modifications we have incorporated into the algorithms. In Section 4 we present an empirical complexity analysis for SensorDCSP, and study active introduction of randomization by the agents. In Section 5 we present results on delays caused by different traffic conditions in the communication network. In Section 6 we introduce GSensorDCSP, and describe its modeling as a DisCSP. In Section 7 we present formal complexity results for GSensorDCSP, evaluate the performance of the DisCSP algorithms on various subclasses of this problem, and discuss solution repairing as a technique for dynamic CSPs. Finally, we present our conclusions in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">SensorDCSP-a benchmark for DisCSP algorithms</head><p>In a distributed CSP, variables and constraints are distributed among the different autonomous agents that have to solve the problem. A DisCSP is defined as follows:</p><p>(1) A finite set {A 1 , A 2 , . . . , A n } of agents; (2) A set {P 1 , P 2 , . . . , P n } of local (private) CSPs, where CSP P i pertains to agent A i (and A i is the only agent that can modify the values assigned to the variables of P i ); (3) A global CSP, each of whose variables is also a variable of one of the local CSPs.</p><p>In analysis of DisCSP algorithms, each agent is traditionally assumed to control only one problem variable. However, in our DisCSP modeling of SensorDCSP every agent needs to control not one, but three local variables. We extend the single-variable approach by modeling each agent as a set of multiple virtual agents, one for each agent's local variable. In order to distinguish between communication and computation costs, in our discrete-event simulator we use different delay distributions to distinguish between messages exchanged between virtual agents of a single real agent (intra-agent messages) and those between virtual agents of different real agents (inter-agent messages). This modeling technique seems to be useful in general, since in many realistic problems an agent might control more than one variable. In that case, the time spent by an agent trying to find an assignment for its own local variables (consistent with its intra-agent and inter-agent constraints) would be only affected by the computation cost of the agent hardware.</p><p>The availability of a realistic benchmark of satisfiable and unsatisfiable instances, with tunable complexity, is critical for the study and development of new search algorithms. Unfortunately, in the DisCSP literature one cannot find such a benchmark. SensorDCSP, the sensor-mobile problem, is inspired by a real distributed resource allocation problem <ref type="bibr" target="#b0">[1]</ref> and offers such desirable characteristics.</p><p>In SensorDCSP we have multiple sensors S = {s 1 , . . . , s m } and multiple mobiles T = {t 1 , . . . , t n } which are to be tracked by the sensors. The goal is to allocate three sensors to track each mobile node, such that all these triplets of sensors are pair-wise disjoint and consistent with two sets of constraints: visibility constraints and compatibility constraints. Fig. <ref type="figure" target="#fig_1">1</ref> shows an example with six sensors and two mobiles. Each mobile has a set of sensors that can possibly detect it, as depicted by the bipartite visibility graph in Fig. <ref type="figure" target="#fig_16">1(a)</ref>. In addition, it is required that each mobile be assigned three sensors that satisfy a compatibility relation with each other; this compatibility relation is depicted by the graph in Fig. <ref type="figure" target="#fig_1">1</ref>  Finally, it is required that each sensor only track at most one mobile. A possible solution is depicted in Fig. <ref type="figure" target="#fig_16">1(c)</ref>, where the set of three sensors assigned to each mobile is indicated by the lighter edges.</p><p>SensorDCSP is NP-complete, since the problem of partitioning a graph into cliques of size three can be reduced to it <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b16">17]</ref>. This is not true, however, of the limiting case in which every pair of sensors is compatible. That case is polynomially solvable, because as each such problem can be reduced to a feasible flow problem in a bipartite graph <ref type="bibr" target="#b17">[18]</ref>.</p><p>For our experiments, we define a random distribution of instances of SensorDCSP. An instance of the problem is generated from two different random graphs, the visibility graph and the compatibility graph. Apart from the number of mobiles and number of sensors, we also specify parameters controlling edge density of the visibility graph (P v ) and edge density of compatibility graph (P c ). Each of these parameters specifies the independent probability of including a particular edge in the corresponding graph. As these two graphs model the resources available to solve the problem, P v and P c control the number of constraints in the generated instances.</p><p>We have developed an instance generator for these random distributions that generates DisCSP-encoded instances of SensorDCSP. We believe that SensorDCSP is a good benchmark problem because it abstracts many real-life resource allocation problems, and because, as we shall show, one can easily generate easy/hard, unsatisfiable/satisfiable instances by tuning the parameters P v and P c appropriately. Our DisCSP encoding of Sen-sorDCSP is as follows: Each mobile is associated with a different agent. There are three different variables per agent, one for each sensor that we need to allocate to the corresponding mobile. The value domain of each variable is the set of sensors that can detect the corresponding mobile. The intra-agent constraints between the variables of one agent are that the three sensors assigned to the mobile must be distinct and pair-wise compatible. The inter-agent constraints between the variables of different agents are that a given sensor can be selected by at most one agent. In our implementation of the DisCSP algorithms, this encoding is translated to an equivalent formulation where we have three virtual agents for every real agent, each virtual agent handling a single variable.</p><p>We should also address the question of where the agents actually reside. The original problem <ref type="bibr" target="#b0">[1]</ref> that inspired SensorDCSP assumes passive/non-collaborative mobile nodes, in which case it must be assumed that there exists a mechanism whereby one of the sensor nodes within range of each mobile node contains the agent corresponding to that mobile (the description of such a mechanism is beyond the scope of this study, but it could be implemented using distributed leader election algorithms, for example). Alternatively, in other tracking scenarios the mobile nodes may be collaborative and have the computational ability to execute their own agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DisCSP algorithms</head><p>In this work we consider two specific DisCSP algorithms, Asynchronous Backtracking Algorithm (ABT), and Asynchronous Weak-Commitment Search Algorithm (AWC). We provide a brief overview of these algorithms but refer the reader to <ref type="bibr" target="#b37">[38]</ref> for a more comprehensive description. We also describe the modifications that we introduced into these algorithms. As mentioned earlier, we assume that each agent can only handle one variable. In what follows, the neighbors of a given agent are the agents with whom it shares constraints.</p><p>The Asynchronous Backtracking Algorithm (ABT) is a distributed asynchronous version of a classical backtracking algorithm. This algorithm needs a static agent ordering that determines an ordering of the variables of the problem. Agents use two kinds of messages for solving the problem-ok messages and nogood messages. Agents initiate the search by assigning an initial value to their variables. An agent changes its value when it detects that it is not consistent with the assignments of higher priority neighbors, and so it maintains an agent view, which consists of the variable assignments of its higher priority neighbors.</p><p>Each time an agent assigns a value to its variable, it issues the ok message to inform its lower-priority neighbors of this new assignment. If an agent is unable to find an assignment that is consistent with the assignments of all of its higher-priority neighbors, it sends a nogood message, which consists of a subset of that agent's view that makes it impossible for the agent to find a consistent assignment for itself; the nogood message is sent to the lowest-priority agent among all the (higher-priority) agents in that particular subset of that agent's view. Receipt of a nogood message causes the receiver agent to record the content of that message as a new constraint and then try to find an assignment that is consistent with its higher-priority neighbors and with all of its recorded constraints. If the top-priority agent is forced to backtrack (which implies that its assignment is inconsistent with at least one of its recorded constraints, since there is no higher-priority neighbor with which its assignment could possibly clash), this means that the problem has no solution. If, on the other hand, the system reaches a state where all agents are happy with their current assignments (no nogood messages are generated), this means that the agents have found a solution.</p><p>The Asynchronous Weak-Commitment Search Algorithm (AWC) can be seen as a modification of the ABT algorithm. The primary differences are as follows: A priority value is determined for each variable, and the priority value is communicated using the ok message. If an agent's current assignment is inconsistent with that agent's view, the agent selects a new consistent assignment that minimizes the number of constraint violations with lower-priority neighbors. When an agent cannot find a consistent value and generates a new nogood, it sends the nogood message to all its neighbors and raises its priority by one unit above the maximal priority of its neighbors. Then it finds an assignment that is consistent with the assignments of its higher-priority neighbors and informs its neighbors by sending them ok messages. If no new nogood can be generated, the agent waits for the next message.</p><p>Considering both ABT and AWC, in recent years it has been recognized that randomization is a useful technique for enhancing the performance of complete backtracking-based CSP solvers <ref type="bibr" target="#b8">[9]</ref>. We therefore wish to explore randomization strategies in our context. The most obvious way of introducing randomization in DisCSP algorithms is by randomizing the value selection strategy used by the agents. In the ABT algorithm this is done by performing a uniform random value selection, among the set of values consistent with the agent view and the nogood list, every time the agent is forced to select a new value. In the AWC algorithm, we randomize the selection of the value among the values that are not only consistent with the agent view and the nogood list but also minimize the number of violated constraints. This form of randomization is analogous to the randomization techniques used in backtrack search algorithms.</p><p>A novel way of randomizing the search in the context of DisCSP algorithms is to introduce forced delays in the delivery of messages. Delays introduce randomization in that the order in which messages from different agents reach their destination agents determines the order in which the search space is traversed. More concretely, every time an agent has to send a message, it follows the following procedure: Transmitting message m with delay d means that the agent requires its communication interface to add d seconds to the delivery time currently scheduled for m and all the successors of m in the message queue. The latter preserves the order of transmission and reception for the messages sent from one agent to another agent. The parameter r is the fraction of the communication delay (D) added by the agent. Section 4.2 details more accurately this active introduction of delays. In our implementation of the algorithms, this strategy is performed by using the services of the discrete event simulator that allow specific delays to be applied selectively in the delivery message queue of each agent.</p><p>We have also developed the following decentralized restarting strategy suitable for the ABT algorithm: the highest-priority agent uses a timeout mechanism to decide when a restart should be performed. It performs the restart by changing its value at random from the set of values consistent with the nogoods learned so far. Then, it sends ok messages to its neighbors, thus producing a restart of the search process, but without forgetting the nogoods learned. This restart strategy is different from the restart strategy used in centralized procedures, such as Satz-rand <ref type="bibr" target="#b8">[9]</ref>. Here, the search is not restarted from scratch, but rather benefits from prior mistakes since all agents retain the nogoods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Complexity profiles of DisCSP algorithms on SensorDCSP</head><p>As mentioned earlier, when studying distributed algorithms several factors may determine their performance. Some of those factors are inherent to the search procedure, such as agent ordering. In this work, we always assume an arbitrary lexicographic ordering of the agents, focusing our attention on other factors, specifically these related to the physical characteristics of the distributed environment. For example, the traffic patterns and packet-level behavior of networks can affect the order in which messages from different agents are delivered to each other, significantly impacting the distributed search process. To investigate these kinds of effects, we have developed an implementation of the algorithms ABT and AWC using the Communication Networks Class Library (CNCL) <ref type="bibr" target="#b15">[16]</ref>. This library provides a discrete-event network simulation environment with a complete set of communication-oriented classes. The network simulator allows us to realistically model the message-delivery mechanisms of various distributed communication environments ranging from wide-area computer networks to wireless sensor networks. Finally, in our implementations of ABT and AWC we have not limited the number of nogoods learned by the agents. Although in the worst case this can require exponential space, in our experiments we have not noticed any exponential blow-up in the number of nogoods learned by any agent. Two reasons for this could be as follows. First, for the typical instances of the random distribution, the particular characteristics of the SensorDCSP constraints could be bounding the number of variables that a given variable can have constraints with. Second, it is possible that the size of the instances tested so far is insufficient to discover such an exponential blow-up in space complexity.</p><p>The results shown in this section have been obtained according to the following scenario: The communication links used for communication between virtual agents of different real agents (inter-agent communication) are modeled as random-delay links, with a negative-exponential distribution and a mean delay of 1 time unit. The communication links used by the virtual agents of the same real agent (intra-agent communication) are modeled as fixed delay links, with a delay of 10 -3 time units. Here we use fixed-delay links because we assume that a set of virtual agents work inside a private computation node and this allows virtual agents to communicate with each other using dedicated communication links. This scenario could correspond to a heavy-loaded network situation where inter-agent delay fluctuations obey to the queuing-time process on intermediate systems. The difference between the two delays by a factor of 1000 reflects that intra-agent computation is usually less expensive that inter-agent communication. In Section 5 we will see how different delay-distribution models over the inter-agent communication links can impact the performance of the algorithms.</p><p>In our experiments with SensorDCSP we considered different sets of instances with 3 mobiles and 15 sensors. Every set contained 19 instances and was generated with a different pair of values for the parameters P c and P v (ranging from 0.1 to 0.9), providing us with 81 data points. Each instance has been executed 9 times, each time with a different random seed. The results reported in this section were obtained using a sequential value selection function for the different algorithms. By sequential we mean that values are chosen according to a lexicographic order. Fig. <ref type="figure" target="#fig_3">2</ref> shows the percentage of satisfiable instances as a function of P c and P v . When both probabilities are low, most of the generated instances are unsatisfiable. For high probabilities, however, most of the instances are satisfiable. The transition between the satisfiable and unsatisfiable regions occurs within a relatively narrow range of these control parameters, analogous to the phase transition in CSP problems, e.g., in SAT <ref type="bibr" target="#b25">[26]</ref>. Also consistent  with other CSP problems is our observation that the hardest instances for these backtracking algorithms generally occur in the region where the phase transition occurs. Fig. <ref type="figure" target="#fig_4">3</ref> shows the mean solution time with respect to the parameters P c and P v . As can be seen there, the hardest instances lie on the diagonal that defines the phase-transition zone, with a peak for instances with a low P c value. The dark and light solid lines overlaid on the mesh depict the location of the iso-lines for P sat = 0.2 and P sat = 0.8, respectively, as per the phasetransition surface of Fig. <ref type="figure" target="#fig_3">2</ref>. As mentioned earlier, the SensorDCSP problem is NP-complete only when not all sensors are pairwise compatible (i.e., when P c &lt; 1) <ref type="bibr" target="#b17">[18]</ref>. Therefore, the parameter P c could separate regions of different mean computational complexity, as in other mixed P/NP-complete problems like 2 + p-SAT <ref type="bibr" target="#b25">[26]</ref> and 2 + p-COL <ref type="bibr" target="#b32">[33]</ref>. This is particularly noticeable in the mean-time distribution for AWC shown in Fig. <ref type="figure" target="#fig_4">3</ref>.</p><p>We observe that the mean times to solve an instance with AWC appear to exceed those with ABT by an order of magnitude. At first glance, this is a surprising result, considering that the AWC algorithm is a refinement of ABT and that results reported for satisfiable instances in the literature <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref> point to better performance for AWC. One plausible explanation for the discrepancy is the fact that our results deal with both satisfiable and unsatisfiable instances. On further investigation, we found that while AWC does indeed outperform ABT on satisfiable instances, it is much slower on unsatisfiable instances. This result seems consistent with the fact that the agent hierarchy on ABT is static, while for AWC the hierarchy changes during problem solving; consequently, AWC might be expected to take more time to inspect all the search space when unsatisfiable instances are considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Randomization and restart strategies</head><p>In this subsection we present the benefits of using randomized value selection and restart strategies for distributed CSP algorithms. The introduction of a randomized value selection function was directly assumed in <ref type="bibr" target="#b36">[37]</ref>. In extensive experiments we performed with our test instances, we found that the randomized selection function is indeed better than a sequential value selection. Randomization can result in greater variability in performance, however, so ABT should be equipped with a restart strategy. We have not defined a restart strategy for AWC, because, as will be seen in Section 5, the dynamic priority strategy of AWC can be viewed as a kind of built-in partial restart strategy. In the results reported in the rest of the paper, both ABT and AWC use randomized value selection functions.</p><p>To study the benefits of the proposed restart strategy for ABT, we have used restarts in solving hard satisfiable instances with ABT. Fig. <ref type="figure" target="#fig_5">4</ref> shows the mean time needed to solve a hard satisfiable instance, together with the corresponding 95% confidence intervals, for a number of cutoff times. We observe that there is clearly an optimal restart cutoff time that gives the best performance. As will be discussed in Section 5, use of restart strategies is essential when dealing with the delays that occur in real communication networks, given the high variance in the solution time due to randomness of link delays in the communication network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Active delaying of messages</head><p>One rather novel way of randomizing a DisCSP algorithm is to introduce delays in the delivery of the agents' outgoing messages, as we described in Section 3. In this subsection we present the results of our experiments with the AWC and ABT algorithms. The amount of delay added by the agents is a fraction r (from 0 to 1) of the delay in the inter-agent communication links. Here, we consider the case where all the inter-agent communication links have fixed delays of 1 time unit, because we want to isolate the effect of the delay added by the agents. This is in contrast to the experiments described elsewhere in this section, where we report the effects of allowing variable inter-agent delays.</p><p>Fig. <ref type="figure">5</ref> shows the results of using AWC to solve a hard satisfiable instance from our Sen-sorDCSP domain (namely, the one that corresponds to point A in Fig. <ref type="figure" target="#fig_4">3</ref>). The solution time and the number of messages are plotted for various values of p, the probability of adding a delay, and r, the fraction of delay added with respect to the delay of the link. The horizontal plane cutting the surface shows the median time needed by the algorithm when we consider no added random delays (p = 0, r = 0). We see that agents can indeed improve the performance of AWC by actively introducing additional, random delays when exchanging messages. The need to send messages during the search process is almost always reduced when agents add random delays; in the best case the number of messages delivered can be as much as a factor of 3 smaller than in the worst case. Perhaps more surprisingly, the solution time can also improve if the increase in delay (r) is not too high.</p><p>Fig. <ref type="figure">6</ref> shows the results with AWC (left) and ABT (right) for a hard satisfiable instance (namely, the one that corresponds to point B in Fig. <ref type="figure" target="#fig_4">3</ref>). We observe that the performance of AWC is improved in a greater number of cases than that of ABT. Moreover, in the best case the solution time is smaller than that in the worst case by a factor of 2.25 for AWC and 1.63 for ABT. It appears that AWC benefits to a greater extent overall than ABT when it comes to the incorporation of delays added by agents. The reason for this could be the ability of AWC to exploit randomization via its inherently restarting search strategy. Fig. <ref type="figure">5</ref>. Median time and number of messages needed to solve a hard satisfiable instance (point A in Fig. <ref type="figure" target="#fig_4">3</ref>) with AWC when agents add random delays in outgoing messages. The horizontal plane represents the median time (or the median number of messages) for the case where no delay is added (p = 0). Fig. <ref type="figure">6</ref>. Median time for AWC and ABT to solve a hard satisfiable (point B in Fig. <ref type="figure" target="#fig_4">3</ref>) instance when agents add random delays in outgoing messages. The horizontal plane represents the median time for the case where no delay is added (p = 0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The effect of the communication network data load</head><p>As described in the previous section, when working on a communication network with fixed delays, the performance of AWC can be improved, depending on the amount of random delay addition that the agents introduce into the message delivery system. In real networks, however, the conditions of data load present in the communication links used by the agents cannot always be modeled with fixed-delay links. It would thus seem worthwhile to determine how differences in communication network environments can affect the performance of the algorithms. In Section 4.2 we considered inter-agent communication links with random, exponentially distributed delays. In this section we study the effect produced in the performance of DisCSP algorithms by considering delay distributions corresponding to different traffic conditions.</p><p>We examine various link-delay distributions that can be used to model communication network traffic. Because of their attractive theoretical properties, negative-exponential distributions of arrival times have traditionally been used to model data traffic. In the past decade, however, it has been shown that although these models are able to capture singleuser-session properties, they are not suitable for modeling aggregate data links in local-or wide-area network scenarios <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b27">28]</ref>. In view of this, we have simulated network delays according to three different models for the inter-arrival time distribution: the aforementioned negative-exponential distribution, the log-normal distribution, and the Fractional Gaussian Noise (FGN) <ref type="bibr" target="#b28">[29]</ref> distribution.</p><p>The log-normal distribution can be used to obtain distributions with any desired variance, whereas FGN processes are able to capture crucial characteristics of the Internet traffic, such as long-range dependence and self-similarity that do not lend themselves to other models. We synthesize FGN from α-stable distributions with typical parameter values of H = 0.75 and d = 0.4. Fig. <ref type="figure">7</ref> shows the cumulative density functions (CDF) of the time required for three algorithms (AWC, ABT, and ABT with restarts) to solve hard instances when all the inter-agent communication links have delays modeled as fixed, negative exponential, and log-normal. The means were nearly identical, but the variances were quite different. Table <ref type="table">1</ref> presents the estimated mean and variance of the number of messages exchanged when using each of the three aforementioned algorithms, together with several different inter-agent link-delay distributions, to solve the same hard instance. The estimated mean and variance of the solution time for the same scenarios show an analogous behavior to the one observed with the number of messages. The results in Fig. <ref type="figure">7</ref> and Table <ref type="table">1</ref> show that the delay distributions have an algorithm-specific impact on the performance of both AWC and basic ABT.</p><p>For the basic ABT, the solution time on hard instances becomes worse when channel delays are modeled by random distributions as opposed to the fixed delay case. The greater the variance of the link delay, the worse ABT performs. However, introducing the restart strategy has the desirable effect of improving the performance of ABT. Furthermore, ABT with restarts is fairly robust and insensitive to the variance in the link delays. AWC behaves differently from the basic ABT. On hard instances, having randomization in the link delays improves the solution time compared to the fixed delay channel. Likewise, the mean solution time for AWC is extremely robust to the variance in communication link delays, although the variance of solution time is slightly affected by this. Note that our experiments with FGN delay models show no significant differences in performance for the three algorithms in relation to other traffic models with the same variance.</p><p>In general, we found that on satisfiable instances, AWC always performs significantly better than both basic and restarts-enhanced ABTs. Therefore, AWC appears to be a better candidate in situations where most instances are likely to be satisfiable, and where we cannot avoid random delays in the links.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Grid-based SensorDCSP</head><p>The above analysis of SensorDCSP problems provides us with the first results on behavior of distributed CSP algorithms in close-to-real-world distributed applications. Observe that the very concrete specification of the SensorDCSP problem helps us both to analyze its computational complexity, and to establish coherent experiments for empirical analysis. However, getting closer to the real-world tracking systems, one may have to further specify the properties of the domain. The main information that we believe should be captured in analysis of various tracking systems is the spatial properties of both communication between the sensors and visibility of the mobiles. Two reasons make capturing this information essential:</p><p>(1) Given spatial limitations for both communication between the sensors and visibility of the mobiles, the complexity analysis for general SensorDCSP provides only upper bounds on the complexity of any spatially-limited SensorDCSP. In addition, deriving conclusions on various sub-classes of spatially-limited SensorDCSP from the empirical results on general SensorDCSP is not straightforward whatsoever. In particular, this makes hard to analyze scalability of the DisCSP algorithms with respect to reallife tracking systems. (2) The overall goal of any tracking system is to track a set of moving objects, and this set is not necessarily constant over time (e.g., some tracked objects run out of the region covered by the sensors, while some new objects are getting into this region).</p><p>Performance analysis of such a dynamic system is impossible without some realistic assumptions about the dynamics of the moving objects, which in turn can be specified only with respect to some concrete spatial model of SensorDCSP.</p><p>In addition, spatial nature of the problem instances is likely to lead to inherently decomposable problems, making adopting the DisCSP approach even more attractive. Influenced by the above motivation and the properties of a recently studied challenge problem for distributed tracking systems <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref>, we introduce a grid-based SensorDCSP benchmark, and perform both analytical analysis of this problem and empirical study of DisCSP algorithms on both static and dynamic settings of this problem.</p><p>The Grid-based SensorDCSP (or GSensorDCSP, for short) is a specific variant of the general SensorDCSP: as before, we have multiple sensors S = {s 1 , . . . , s m }, multiple objects T = {t 1 , . . . , t n } which are to be tracked by the sensors subject to visibility and compatibility constraints, and the goal is to allocate three sensors to track each object, while keeping these triplets of sensors pair-wise disjoint. However, in GSensorDCSP the sensors are located on the nodes of a uniform grid of m nodes, and the mobile objects are located within the surface enclosed by the grid (i.e., the grid specifies the generally trackable region). <ref type="foot" target="#foot_0">1</ref> Furthermore, the visibility and compatibility constraints in GSensorDCSP relate to the physical limitations of the sensors and the properties of the terrain on which the sensors are located. In this section we provide a formal classification of the GSensorD-CSP problem instances, together with an abstract model for specifying such instances with requested properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Locality of communication and visibility</head><p>The physical limitations of the sensors are modeled by the notions of k-compatibility and k-visibility. The k-compatibility window for sensor s i , denoted as C k (s i ), corresponds to the set of all sensors that are at most k general (rectilinear and/or diagonal) hops from s i . For example, the black sensors in Fig. <ref type="figure" target="#fig_7">8</ref>(a) correspond to 1-compatibility windows for the gray sensor. Similarly, the k-visibility window for a mobile t j , denoted as V k (t j ), corresponds to the set of all sensors that are at most k general hops around t j . For example, the black sensors in Fig. <ref type="figure" target="#fig_7">8</ref>(b) correspond to 2-visibility windows for the rectangular mobile. Note that, we have |C k (s i )| (2k + 1) 2 -1 (where the strict equality holds for all sensors located at least k hops from the boundaries of the grid), and |V k (t j )| 4k 2 .</p><p>Given a GSensorDCSP problem instance Π , denote by C(s i ) the set of sensors that the sensor s i can communicate with, and by V(t j ) the set of sensors that can track the mobile t j . The compatibility graph of Π is called k-restricted if and only if, for every sensor s i we have C(s i ) ⊆ C k (s i ), and there exists a sensor s i such that C(s i ) ⊆ C k-1 (s i ). In turn, the compatibility graph of Π is called k-enhanced if and only if, for every sensor s i we have C k (s i ) ⊆ C(s i ), and there exists a sensor s i such that C k+1 (s i ) ⊆ C(s i ). The corresponding notions of k-restrictness and k-enhanceness for the visibility graph of Π are defined similarly. It is easy to see that higher values of k for both compatibility and visibility correspond to more powerful sensors. For example, thinking of the gray sensor in Fig. <ref type="figure" target="#fig_7">8(c</ref>) as of the only sensor, the compatibility graph corresponding to Fig. <ref type="figure" target="#fig_7">8(c</ref>) is 2-restricted and 1-enhanced. Similarly, thinking of the rectangular mobile in Fig. <ref type="figure" target="#fig_7">8(d</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Connecting locality and constrainedness</head><p>While physical limitations of the sensors in GSensorDCSP problems are modeled via the locality windows, terrain limitations are modeled via incompleteness of compatibility and visibility within the windows. This part of modeling is done in a way very similar to this for the general SensorDCSP: Within a particular problem class (k c , k v ) representing problems with k c -restricted compatibility graph and k v -restricted visibility graphs, the problems can be ordered according to the local constrainedness, i.e., the average number of sensors that a sensor can communicate with and the average number of sensors that can track a mobile object. For the experiments, a random distribution of GSensorDCSP instances for a particular pair of locality parameters (k c , k v ) is defined as follows. Similarly to the general SensorDCSP, an instance of GSensorDCSP is generated from two different random graphs, the visibility graph and the compatibility graph. Apart of the parameters number of mobiles and number of sensors, we also specify the parameters P v , P c ∈ (0, 1] that control the edge density of visibility and communication graphs, respectively. These parameters specify the independent probability of including a particular edge in the corresponding graph. However, not as for the general SensorDCSP, these parameters have only a local effect: For every pair of sensors s i and s j , the probability Pr(s i , s j ) for the edge (s i , s j ) to be a part of the communication graph is given by: Pr(s i , s j ) = 0, s j / ∈ C k c (s i ), P c , s j ∈ C k c (s i ).</p><p>(</p><p>Similarly, for the visibility graph, we have:</p><formula xml:id="formula_1">Pr(t i , s j ) = 0, s j / ∈ V k v (t i ), P v , s j ∈ V k v (t i ).</formula><p>(</p><formula xml:id="formula_2">)<label>2</label></formula><p>Clearly, higher values for P c and P v correspond to less problematic terrain conditions for communication and tracking, respectively. To conclude, each problem instance of GSen-sorDCSP can be characterized by six parameters:</p><p>• Order of the problem, characterized by both the number of sensors and the number of mobiles (n and m, respectively), • Level of decomposition, modeled via locality of compatibility and visibility, using the corresponding notions of window restrictness (k c and k v ), and • Level of constrainedness, modeled via the expected fraction of sensors that can communicate with a sensor and the expected fraction of sensors that can track a mobile object, out of the maximally possible such numbers specified by the level of decomposition. These aspects of the problem instances are modeled using the uniform probability distributions P c and P v with their corresponding means.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Computational analysis of GSensorDCSP</head><p>In this section we present a complexity analysis for GSensorDCSP. Despite the a priori problematic multi-parametric nature of this problem, its concrete definition allows us to perform both analytical and empirical complexity analysis. Our analytical analysis characterizes both tractable and hard subclasses of GSensorDCSP. This classification both guides our empirical evaluation, and describes the connection between various problem parameters and the expected hardness of the problem. In turn, our experimental analysis shed light on both the phase transition in satisfiability of GSensorDCSP and the scalability expected from DisCSP algorithms on spatial SensorDCSP problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Complexity results for GSensorDCSP</head><p>In this section we perform an extensive formal complexity analysis of GSensorDCSP, identifying both tractable and hard subclasses of the GSensorDCSP problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1. GSensorDCSP is NP-complete.</head><p>Proof. GSensorDCSP is a special case of SensorDCSP, thus it is clearly in NP. The proof of hardness is by a straightforward reduction from SensorDCSP. Given a general Sensor-DCSP problem Π with sensors S = {s 1 , . . . , s m } and mobile objects T = {t 1 , . . . , t n }, the corresponding GSensorDCSP problem Π is defined as follows: Let k be the smallest number such that k m and k = l × l , where l, l ∈ N. The sensor set of Π is S = {s 1 , . . . , s k }, where, for 1 i m, we have s i = s i , and all these k sensors are located on the nodes of a uniform l × l grid. The set of mobile objects of Π is this of Π , and these objects are arbitrarily located within the grid. Finally, the compatibility and visibility graphs of Π are identical to these of Π . Obviously, there exist a solution for the problem Π if and only if there exist a solution for the problem Π . 2</p><p>Note that the notions of locality in the GSensorDCSP problems constructed from the general SensorDCSP problems as in the proof of Lemma 1 are redundant: In general, if l l , we can only say that the compatibility and visibility graphs of the generated problems Π are (l -1)-restricted. However, later we discuss GSensorDCSP with constantly bounded compatibility and visibility windows.</p><p>Recall that SensorDCSP is polynomial for complete compatibility graphs <ref type="bibr" target="#b17">[18]</ref>. The corresponding notion in GSensorDCSP is this of locally complete compatibility graphs, as it is summarized by Lemma 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. Given an GSensorDCSP problem instance Π with an i-enhanced compatibility graph, and j -restricted visibility graph, if</head><formula xml:id="formula_3">i 2j -1, then Π is solvable in polynomial time.</formula><p>Proof. Without loss of generality, assume that, for every sensor s, we have C(s) = C i (s). In this case, if i 2j -1, then, for every mobile t, we have that every pair of sensors in V(t) can communicate one with the other. Therefore, this problem can be presented as a feasible integral flow problem in a bipartite graph, similarly to the way it is done for SensorDCSP problems with complete compatibility. 2</p><p>Observe that, while Lemma 1 shows the general hardness of GSensorDCSP, the practical relevance of this result is extremely limited. Recall that the central motivation for specifying a spatial model for SensorDCSP was that, in real world, both the communication and tracking abilities of the sensors are spatially limited. Therefore, the complexity analysis of GSensorDCSP would be helpful only if it will be parametrized by the problem's level of decomposition. Below we perform such an analytical analysis, parametrized by the restrictness of visibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3. Any GSensorDCSP problem instance with 1-restricted visibility graph V is solvable in polynomial time.</head><p>The proof of Theorem 3 by reduction to the problem of feasible integer flow appears in Appendix A. In turn, Theorem 4 shows that extending restrictness of visibility to V 2 makes the GSensorDCSP problem hard, and this result is independent of the restrictness of compatibility between the sensors. Theorem 4. GSensorDCSP with 2-restricted visibility is NP-complete.</p><p>The proof of Theorem 4 by reduction from 3-SAT appears in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Complexity profiles of the AWC algorithm on GSensorDCSP</head><p>For the first experiment with the AWC algorithm, we consider different sets of instances with 25 sensors (grid 5 × 5) and 5 mobiles, with every set generated with different values for the parameters P c and P v with respect to Eqs. ( <ref type="formula" target="#formula_0">1</ref>) and ( <ref type="formula" target="#formula_2">2</ref>). The parameters P c and P v are ranging from 0.1 to 1 with an increment of 0.1, giving a total number of 100 data sets, where every set contains 50 instances. Recall that by k v and k c we refer to the parameters controlling the restrictness of the visibility graph and compatibility graph, respectively. It is worth to mention that in contrast to the time model assumed in Section 4, the forthcoming experiments in the GSensorDCSP domain (but in the dynamic case) assume a random negative exponential distributed delay, with a mean of 1 time unit for both inter-agent and intra-agent communication. The reason for such an assumption is that we are no longer interested in time performance but in complexity analysis of the problem. Obviously, such scenario changes if dynamics of the mobiles is considered, shifting back to the time model adopted in Section 4. Given the results provided by Theorems 3 and 4, we consider three hard subclasses of GSensorDCSP, corresponding to k v = 2 and k c ∈ {1, 2, 3}. Fig. <ref type="figure" target="#fig_8">9</ref>(a) shows<ref type="foot" target="#foot_1">2</ref> the percentage of satisfiable instances as a function of P c and P v for k v = 2 with k c = 1 and k c = 2. As in the case of general SensorDCSP (see Fig. <ref type="figure" target="#fig_3">2</ref>), when both probabilities are low, the instances generated are mostly unsatisfiable, while for high probabilities most of the instances are satisfiable. Both for k c = 1 and k c = 2, the transition between the satisfiable and unsatisfiable regions occurs within a narrow range of the density parameters. Observe that, for k c = 1 this range corresponds to significantly higher values of P c and P v , comparatively to these for k c = 2 and k c = 2. However, the form of the transition for various values of k c is very similar (see Fig. Consistently with the general SensorDCSP, we observe that the phase transition coincides with the region where the hardest instances occur. For instance, Fig. <ref type="figure" target="#fig_16">10</ref> shows the mean solution time with respect to the density parameters P v and P c for the problem instances with 25 sensors, 5 mobiles, k c = 1, and k v = 2. Somewhat less expected result is depicted in Fig. <ref type="figure" target="#fig_16">11</ref> for the case of k v = 1 (and k c = 1), which is shown in Theorem 3 to be polynomial by a reduction to the problem of feasible integral flow in bipartite graphs. Despite the fact that AWC has no explicit connection with the algorithms for the latter problem, Fig. <ref type="figure" target="#fig_16">11(b)</ref> shows that these instances are practically easy for AWC as well.</p><p>For the second experiment with the AWC algorithm, we consider different sets of instances for several orders of the problem (size of the grid), and several levels of decomposition (visibility and compatibility restrictness). In particular, we consider grids of 25, 36, 49, 64, 81, and 100 sensors (N = 5, 6, 7, 8, 9, 10), tracking 5, 7, 9, 12, 15 and 18 mobiles, respectively, giving us an approximately constant ratio between the number of mobiles and the number of sensors for each case. Note that N = 10 was the largest problem size we were able to deal with using the CNCL simulator. The restrictness of visibility and compatibility graphs is kept equal (k c = k v = k), and different sets correspond to k equal 2, 3, 4, and 5. Each set of problem instances corresponding to a particular pair of values (N, k) contains 30 instances. The important point is that all the problem instances, in all the sets (N, k), have been selected from the corresponding phase transition regions with respect to the density parameters P c and P v , representing the regions of the hardest problem instances (as it was shown in Figs. 9(a) and 10).  The mean solution time for satisfiable instances in this experiment is plotted in Fig. <ref type="figure" target="#fig_12">12</ref> as a function of N , where Figs. 12(a), (b) and (c) depict this graphs in logarithmic scale for the problem instances with k = 2, 3, k = 3, 4, and k = 4, 5, respectively, while Fig. <ref type="figure" target="#fig_18">12(d)</ref> presents the whole picture in the linear scale. We observe that the problem scalability with N degrades dramatically as k increases, but it can be considered as reasonable for k = 2 and k = 3. In order to capture the exponential behavior of AWC on these problems, Figs. <ref type="figure" target="#fig_18">12(a)-(c</ref>) depicts the obtained measures, showing 95% confidence interval of the samples in logarithmic scale, as well as their corresponding linear regression plots. These plots have been represented in three different interrelated pictures in order to facilitate a pair-wise comparison. Two conclusions can be drawn from Fig. <ref type="figure" target="#fig_12">12</ref>. First, it is easy to see that the slopes of the regression lines increase with k. For our set of results, the obtained slopes are 0.03, 0.202, 0.213 and 0.293 for k = {2, 3, 4, 5}, respectively. Second, the exponential dependence of the mean solution time on N seems to fit well according to the experiments. In particular, the obtained mean square error of the regressions is 0.039, 0.04, 0.002 and 0.11 for k equal to 2, 3, 4 and 5, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Exploiting solution repairing in dynamic GSensorDCSP</head><p>Considering the scalability of the DCSP algorithms on GSensorDCSP, our main concern was about feasibility of striving to optimality in problems with real-life sensor/mobiles settings, where time deadlines play a crucial role, and the objects being tracked are moving.</p><p>More formally, the task of a tracking system can be specified as a dynamic GSensorD-CSP problem Π, which consists of an ordered sequence Π 1 , . . . , Π N of regular (static) GSensorDCSP problems, that are:</p><p>(1) Defined over the same set of sensors S i = {s 1 , . . . , s m }, and having the same compatibility graph, (2) Possibly differ in their sets of mobile objects and/or visibility graphs, where T i = {t i 1 , . . . , t i n i } is the set of mobiles associated with the problem Π i , and (3) Each problem instance should be solved within a certain time window.</p><p>Attempting to address this problem, we conducted an experiment with 100 sensors that suppose to track over time a continuously changing set of moving mobiles. The parameters used in this experiment have been chosen to represent a network of radars controlling some part of the airspace. As written, we considered a 10 × 10 uniform grid of sensors, with the distance of 10 miles between any two adjacent sensors, and the tracking area covered by these sensors is defined by the square of 8100 square miles enclosed by the grid. The compatibility graph of Π is 4-restricted, and the visibility graphs of all the sub-problems of Π (see below) are 4-restricted as well (k c = k v = 4).</p><p>The mobiles are assumed to move according to some independently chosen linear trajectories, where the velocity of all the mobiles is 2 Mach (1500 miles/hour). Our intention was to keep a controlled, relatively tight ratio between the number of mobiles and the number of sensors, thus we strived to keep the (now expected) number of 18 mobiles inside the grid. On the other hand, we want to model both the mobiles leaving the grid, and the mobiles entering the grid, while keeping the movement of the mobiles independent one of another. To achieve it, we extended the number of mobiles to 36, setting this mobiles to move in (randomly initialized) linear trajectories inside an area larger than our sensor grid. The area is modeled by a square of 16200 square miles (twice as big as the square defined by the grid), and the center of this extended area is exactly the center of the grid. For the first sub-problem Π 1 , each mobile is located at a randomly chosen point inside this extended area, and is annotated with a randomly chosen linear trajectory, that will determine the position of this mobile in Π 2 and so on. If, at some point, a mobile reaches the border of the extended area, it reflects from the border at a randomly chosen angle, which determines a new linear trajectory for this mobile. Such modeling of the mobile dynamics provides us with a continuously changing set of mobiles inside the grid, while the expected size of this set is known (and is 18 mobiles in our experiment). The time window available to solve each sub-problem Π i is set to 1.2 seconds, i.e., the minimum time spent by a mobile inside a cell given a speed of 2 Mach, providing us at least 20 snapshots of a mobile during its presence in a particular cell. Fig. <ref type="figure" target="#fig_13">13</ref> depicts the results for two dynamic GSensorDCSP problems Π 1 and Π 2 , each consists of 100 static GSensorDCSP sub-problems, where the subproblems for Π 1 (Figs. <ref type="figure" target="#fig_20">13(a)-(b)</ref>) and Π 2 (Figs. <ref type="figure" target="#fig_20">13(c)-(d)</ref>) were selected from the regions of P sat ≈ 0.7(P c = P v = 0.47) and P sat ≈ 0.5(P c = P v = 0.45), respectively. Recall that P sat ≈ 0.5 corresponds to the region of the hardest instances. The dashed lines in Figs. <ref type="figure" target="#fig_20">13(a),</ref><ref type="figure">(c</ref>) depict the cumulative probability distributions of solving Π i within a time window of t seconds. In Π 1 , all the solvable sub-problems were solved in less than 0.9 seconds, while in Π 2 all except to one sub-problems were solved within the time limit of 1.2 seconds.</p><p>Observe that, if no assumptions can be made about the connection between the mobiles in T i and T i+1 , there is no particular reason to treat Π differently than just solving its static sub-problems Π 1 , . . . , Π N one by one independently, using one of the DCSP algorithms. In what follows, we refer to this approach as to naive solving of dynamic CS problems, and the results depicted by the dashed lines in Figs. <ref type="figure" target="#fig_20">13(a),</ref><ref type="figure">(c</ref>) correspond to this straightforward approach. However, mobile dynamics are typically far from being chaotic (linear trajectories in our experiment), i.e., the changes between the subsequent sub-problems are governed by some clear model of mobile dynamics. For instance, consider a network of radars controlling some airspace region. In such an application, it is reasonable to assume that if an aircraft becomes trackable by a sensor, then this aircraft is likely to remain trackable by this sensor in some near future.</p><p>One of our hypotheses was that continuity of mobiles movement can be exploited in improving the performance of the tracking systems. An approach that a priori seems to be promising for dealing with such a problem Π = {Π 1 , . . . , Π N } is to initialize the search for Π i , 1 &lt; i N , by the solution already achieved for Π i-1 (comparatively to starting from an random assignment in AWC used in the naive approach). In what follows, we refer to this approach as to solution repairing. Note that in this approach, nogoods are not kept and are removed once a solution is obtained, so no additional synchronization is required between agents.</p><p>The central question is whether the contribution of solution repairing (versus the naive approach) is expected to be significant in real-life settings of both the mobiles dynamics, and the time available to solve each one of the static sub-problems. One experiment provides a positive evidence to this question: The solid lines in Figs. <ref type="figure" target="#fig_20">13(a)-(c</ref>) depict the cumulative probability distributions of solving Π i within a time window of t seconds using the solution repairing approach. It is easy to see that solution repairing clearly outperforms the naive approach, and Figs. <ref type="figure" target="#fig_20">13(b)-(d</ref>) illustrate this even better: For each sub-problem Π i , these graphs plot the difference between the times required to solve Π i using AWC from scratch and starting from the solution for P i-1 , if this exists ( t). More interestingly, the results of our experiment show that the relative attractiveness of solution repairing is higher in the region of harder instances. For instance, using solution repairing, all the sub-problems of Π 2 were solved in less than 0.75 second. The reason could be that small changes in the problem setting (as the changes between Π i and Π i+1 are expected to be) usually will not change significantly the placement of the solutions in the search tree. If so, then adopting solution repairing is likely to initialize the search at a node that is close to a solution node in the search tree. Likewise, the contribution of this property is likely to be more significant for sequences of harder problems, i.e., problems that a priori have less alternative solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions</head><p>We introduced SensorDCSP, a benchmark that captures some of the characteristics of real-world distributed applications that arise in the context of distributed networked systems. The two control parameters of our SensorDCSP generator, sensor compatibility (P c ) and sensor visibility (P v ), result in a zero-one phase transition in satisfiability. We tested two complete DisCSP algorithms, synchronous backtracking (ABT) and asynchronous weak commitment search (AWC). We show that the phase transition region of Sensor-DCSP induces an easy-hard-easy profile in the solution time, both for ABT and AWC, which is consistent with CSPs. We found that AWC performs much better than ABT on satisfiable instances, but worse on unsatisfiable instances. This differential in performance is most likely due to the fact that on unsatisfiable instances, the dynamic priority ordering of AWC slows the completion of the search process.</p><p>In order to study the impact of different network traffic conditions on the performance of the algorithms, we used a discrete-event network simulator. We found that random delays can improve the performance and robustness of AWC. On hard satisfiable instances, however, the performance of the basic ABT deteriorates dramatically when subject to random link delays. However, we developed a decentralized dynamic restart strategy for ABT, which results in an improvement and shows robustness with respect to the variance in link delays. Most interestingly, our results also show that the active introduction of message delays by agents can improve performance and robustness while reducing the overall network load. These results validate our thesis that when considering networking applications of DisCSP, one cannot afford to neglect the characteristics of the underlying network conditions. The network-level behavior can have an important, algorithm-specific, impact on solution time.</p><p>In a more focused attempt to study practical applicability of the DisCSP algorithms for various distributed tracking systems, we introduced and analyzed GSensorDCSP, a variant of SensorDCSP that induces a spatial structure on the problem constraints. We performed both analytical analysis of GSensorDCSP and an empirical study of DisCSP algorithms on various instances of this problem. First, we analyzed the performance of AWC on the tractable subclasses of GSensorDCSP, showing that AWC scales perfectly on such instances. Next we have tested scalability of AWC on various hard subclasses of GSen-sorDCSP. While in general GSensorDCSP induces phase-transition in satisfiability with respect to the density parameters of the problem, we showed that AWC scales nicely on a wide (a priori hard) subclass of GSensorDCSP. Finally, we analyzed the AWC algorithm on a sequence of GSensorDCSP problems that represent a system of sensors tracking a set of moving objects. We discussed some properties of such a dynamic GSensorDCSP, and showed how these properties could be exploited in the dynamic tracking systems.</p><p>We believe that our study makes it clear that DisCSP algorithms are best tested and validated on benchmarks based on real-world problems, using network simulators. We hope our benchmark domains will be of use for the further analysis and development of DisCSP methods. the objects in the first stage. First, we construct a directed graph G = (S ∪ T , E), such that there is an edge from a sensor s ∈ S to an object t ∈ T if and only if s ∈ V 1 (t). Likewise, we add a super-source node s, and for each sensor s ∈ S we put an edge from s to s. Similarly, we add a super-sink node t, and for each object t ∈ T we add an edge from t to t. Now we construct a feasible integer flow problem based on this graph. For each edge (s, s) and for each edge (s, t) we place a lower bound flow of 0 and an upper bound flow of 1. For each edge (t, t), if t ∈ T , then we place a lower bound flow of 3 and an upper bound flow of 3. Otherwise, if t ∈ T , we place a lower bound flow of 1 and an upper bound flow of 1. It is easy to see that our GSensorDCSP problem Π has a solution if and only if this directed graph has a feasible flow of 3 • |T | + |T |. As feasible-flow problems are known to be polynomial-time solvable <ref type="bibr" target="#b5">[6]</ref>, so is this special case of GSensorDCSP. 2 Theorem 4. GSensorDCSP with 2-restricted visibility is NP-complete.</p><p>Proof. The membership in NP is straightforward, since the general SensorDCSP is in NP. The proof of hardness is by reduction from 3-SAT. Let F be a 3-cnf formula specified by the clauses {c 1 , . . . , c m } over the variables {x 1 , . . . , x n }. An equivalent GSensorDCSP problem Π F with 2-restricted visibility and 1-restricted compatibility can be constructed as follows.</p><p>The grid of Π F is an (4n + 2) × (9m + 3) grid of sensors; in what follows, by the rows and columns of the grid we refer to the rows and columns of the grid cells, in terms of which we have an (4n + 1) × (9m + 2) grid of cells. Except for the first row, the rows of the grid can be considered in ordered quadruples, where the ith quadruple of rows corresponds to the variable x i in F . For simplicity of presentation, we denote the rows of the grid as 0 0 , 1 0 , 1 1 , 1 2 , 1 3 , 2 0 , 2 1 , 2 2 , 2 3 , . . . , n 0 , n 1 , n 2 , n 3 . where the j th nine-tuple of columns corresponds to the clause c j in F .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For an illustration, see</head><p>Since we construct Π F with 1-restricted compatibility between the sensors, every triplet of mutually compatible sensors in Π F has to lie on the vertexes of a certain grid cell. It is easy to see that such a triplet of sensors will form a cell-embedded triangle of one of the four forms:</p><p>To illustrate the notation we are using, the cell formed by the row i 3 and the column j 5 is denoted by (i 3 , l 5 ), and i 3 , l 5 , B denotes the fact that the three sensors forming the triangle of type B in cell (i 3 , l 5 ) are mutually compatible.</p><p>First, for each variable x i ∈ F , the compatibility of the sensors in rows i 0 , . . . , i 3 is defined by the following template (for an illustration see  • In rows i 0 and i 2 we have no compatible triplets of sensors.</p><p>• In row i 1 , for all 1 l m, we have i 1 , 0 0 , A , i 1 , l 0 , B , i 1 , l 2 , A , i 1 , l 3 , B , i 1 , l 5 , A , i 1 , l 6 , B , i 1 , l 8 , A , and i 1 , (m + 1) 0 , B . • In row i 3 , for all 1 l m, we have i 3 , 0 0 , D , i 3 , l 0 , B , i 3 , l 2 , A , i 3 , l 3 , B , i 3 , l 5 , A , i 3 , l 6 , B , i 3 , l 8 , A , and i 3 , (m + 1) 0 , C .</p><p>For each variable x i ∈ F , we have 6m + 2 mobiles, located and visible by the sensors according to the following template (see Fig.</p><p>A.1, where dashed lines connect between the mobiles and the compatible triplets of sensors that can track these mobiles):</p><p>• The first 3m mobiles are located in row i 1 , in cells (i 1 , l 1 ), (i 1 , l 4 ), (i 1 , l 7 ), 1 l m, where the mobile in cell (i 1 , l k ), k ∈ {1, 4, 7}, can be tracked only by the two sensor triplets i 1 , l k-1 , B and i 1 , l k+1 , A . • The next 3m mobiles are located similarly in row i 3 , in the cells (i 3 , l 1 ), (i 3 , l 4 ), (i 3 , l 7 ), 1 l m, where again the mobile in cell (i 3 , l k ), k ∈ {1, 4, 7}, can be tracked only by the two sensor triplets i 3 , l k-1 , B and i 3 , l k+1 , A . • The last two mobiles are located in row i 2 , in cells (i 2 , 0 0 ) and (i 2 , (m + 1) 0 ). The mobile in (i 2 , 0 0 ) can be tracked only by the two sensor triplets i 1 , 0 0 , A and i 3 , 0 0 , D , and the mobile in (i 2 , (m + 1) 0 ) can be tracked only by the two sensor triplets i 1 , (m + 1) 0 , B and i 3 , (m + 1) 0 , C .</p><p>Observe that the mobiles corresponding to a particular variable x i are "circularly" constrained: if all these mobiles are tracked, then either they are all tracked by the white sensor triangles, or they are all tracked by the shadowed sensor triangles. Intuitively, this construction will ensure that x i takes the same value with respect to all the clauses in F . Now we extend both the set of the mobiles, and the compatibility between the sensors with respect to the clauses of F . For each clause c l = (u i , u j , u k ), i &lt; j &lt; k, where each u t ∈ {x t , x t }, the construction is as follows (see Fig. • In the special row 0 0 , we have 0 0 , l 3 , C and 0 0 , l 5 , D .</p><p>• For each literal u t ∈ c l , let h be 1, 4, or 7, when u t is the first, second and third literal of c l , respectively. Now, for each literal u t ∈ c l :</p><p>• For 1 s t -1, we have s 1 , l h , C , s 1 , l h , D , s 3 , l h , C , and s 3 , l h , D .</p><p>• If u t = x t , then we have t 1 , l h , D . Otherwise, if u t = x t , we have t 1 , l h , C .</p><p>• For 1 s t -1, we have two mobiles located in the cells (s 2 , l h ) and ((s + 1) 0 , l h ). Each one of these two mobiles can be tracked only by all (one or two) compatible The construction is clearly polynomial-time since the number of sensors on the grid is (4n + 2) × (9m + 3), and the number of mobiles is (n(6m + 2) + 3m(2n -1)). </p><formula xml:id="formula_4">= (x 1 ∨ x 2 ∨ x 3 ) ∧ (x 1 ∨ x 2 ∨ x 3 ).</formula><p>Our claim is that a 3-cnf formula F is satisfiable if and only if there exist a solution to the corresponding GSensorDCSP Π F .</p><p>(⇒) First we show that if F is satisfiable, then there is a solution for Π F . Let φ be an assignment to {x 1 , . . . , x n } satisfying F . First, for each variable x i , we assign the 6m + 2 mobiles associated with x i (see the first stage of the construction) to be tracked consistently with φ(x i ): These mobiles are tracked by the white (shadowed) compatible triplets of sensors if φ(x i ) = true (φ(x i ) = false), respectively.</p><p>Since φ is a satisfying assignment, let u l i ∈ φ be a literal satisfying the clause c l . Consider the vertical sequence of mobiles associated with the literal u l i in the column l h (plus one sensor in the row 1 0 ), and, in particular, consider the lowest such mobile. By the construction, this mobile can be tracked by the compatible triplet of sensors in cell ((l i ) 1 , l h ), since no sensor in this triplet has been assigned to track mobiles associated with x l i . By the same inductive argument, every sensor in this vertical sequence can be tracked by a compatible triplet of sensors located immediately below it. Therefore, the remaining two mobiles associated with c l in row 1 0 can be tracked by the sensor triplets 0 0 , l 3 , C and 0 0 , l 5 , D . Hence, all the mobiles are assigned to be tracked by pair-wise disjoint, compatible triplets of sensors, and thus Π F is solved.</p><p>(⇐) Now we show that if Π F is solvable, then F is satisfiable. It is easy to see that, if there exist a solution for Π F , then, for each clause c l ∈ F , there exist at least one literal u l i ∈ c l , such that the corresponding mobile in the row 1 0 is tracked by a triplet of compatible sensors located immediately below it in the column l h . In turn, this entails that all the mobiles in the corresponding vertical sequence corresponding to the associated with the literal u l i will have to be tracked by the sensor triplets located immediately below them.</p><p>Given the set of m literals {u 1 i , . . . , u m i } as above, we claim that the assignment φ = m j =1 u j i satisfies F . Since each literal u l i satisfies the corresponding clause c l , the only thing remains to be shown in order to prove the claim is that if u l i ∈ φ, then u l i / ∈ φ. However, this is apparent from the construction of Π F , and the choice of u l i for c l : Suppose that u l i corresponds to x l i = true. In this case, u l i will eliminate a shadowed triangle of sensors in the row (l i ) 1 , and u l i will eliminate a white triangle from the same row. It is easy to see that in this case some of the mobiles in the rows (l i ) 1 , (l i ) 2 , and (l i ) 3 will remain untracked, which contradicts our assumption that there is a solution for Π F . 2</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A SensorDCSP problem instance: (a) Visibility graph; (b) Compatibility graph; (c) Feasible sensors/mobiles assignment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 .</head><label>1</label><figDesc>with probability p: d := D • (1 + r); else (with probability (1p)) d := D; 2. deliver the message with delay d.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Percentage of satisfiable instances depending on the density parameter for the visibility graph (P v ) and the density parameter for the compatibility graph (P c ).</figDesc><graphic coords="9,173.76,98.08,199.68,88.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Mean solution time with respect to P v and P c for ABT and AWC algorithms. Points A and B show the locations of the two hard instances analyzed in Section 4.2.</figDesc><graphic coords="9,155.64,235.12,235.80,243.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Mean time to solve a hard satisfiable instance by ABT using restarts, plotted with different cutoff times.</figDesc><graphic coords="10,154.68,455.31,238.09,161.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Table 1 Fig. 7 .</head><label>17</label><figDesc>Fig. 7. Cumulative density functions (CDF) of the time needed to solve hard instances for their respective algorithms, AWC, ABT and ABT with restarts under different link delay models.</figDesc><graphic coords="13,157.92,391.42,231.36,146.46" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. k-compatibility and k-visibility windows. Locality of communication and visibility.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Percentage of satisfiable instances depending on density parameters for the visibility graph (P v ) and the compatibility graph (P c ). (a) Plot for different values of P v and P c . (b) Plot when P v and P c are equal.</figDesc><graphic coords="19,100.32,106.95,173.04,97.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>9(b)), showing a similar phase transition behavior for various subclasses of the GSensorDCSP problem with k v = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10 .Fig. 11 .</head><label>1011</label><figDesc>Fig. 10. Mean solution time with respect to P v and P c for the AWC algorithm on instances with 25 sensors, 5 mobiles, k c = 1 and k v = 2.</figDesc><graphic coords="20,136.20,98.08,274.92,150.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>3</head><label>3</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Mean solution time with respect to the order of the problem (size of the grid) for AWC algorithm on problem instances from the phase transition regions for k c = k v = 2, 3, 4, 5.</figDesc><graphic coords="21,100.32,230.96,166.92,106.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Dynamics of one problem, located at 70% of satisfiability ratio; (a) show the cumulative probability distributions for the solution repairing and the naive solving approach; (b) plot time differences to solve between the two approaches.</figDesc><graphic coords="23,289.32,223.05,167.40,99.90" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Fig. A.3. Similarly, the columns of the grid (except for the first and the last ones), can be considered in ordered nine-tuples 0 0 , 1 0 , . . . , 1 8 , 2 0 , . . . , 2 8 , . . . , m 0 , . . . , m 8 , (m + 1) 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>Fig. A.1, where triangles depict the compatible triplets of sensors):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. A. 1 .</head><label>1</label><figDesc>Fig. A.1. Mobiles, sensors, compatibility and visibility for a variable x i ∈ F .</figDesc><graphic coords="27,165.24,98.09,216.72,55.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>A.2):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. A. 2 .</head><label>2</label><figDesc>Fig. A.2. Mobiles, compatible triplets of sensors, and visibility constraints in the construction corresponding to a clause c l ∈ F . In this case, u k = x k .</figDesc><graphic coords="28,205.56,98.08,136.20,210.42" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>Fig. A.3 illustrates the construction on a small example of F</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Fig. A. 3 .</head><label>3</label><figDesc>Fig. A.3. Construction of Π F for F = (x 1 ∨ x 2 ∨ x 3 ) ∧ (x 1 ∨ x 2 ∨ x 3 ).</figDesc><graphic coords="29,143.40,98.08,260.64,178.44" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We adopt a general position assumption that the objects are not located on the edges of the grid, but in the cells formed by the grid.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The case of k v = 2 and k c =</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>is not depicted in Fig.9(a) as it is very close to this for k v = 2 and k c = 2 (see Fig. 9(b)).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>The phase transition regions for every pair (N, k) have been determined in advance.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>✩ This work was supported in part by AFOSR (F49620-01-1-0076, Intelligent Information Systems Institute and MURI F49620-01-1-0361), CICYT (TIC2001-1577-C03-03 and TIC2003-00950), DARPA (F30602-00-2-0530), an NSF CAREER award (IIS-9734128), and an Alfred P. Sloan Research Fellowship. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the US Government.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Appendix A. Proofs Theorem 3. Any GSensorDCSP problem instance with 1-restricted visibility graph V is solvable in polynomial time.</p><p>Proof. Consider such a problem instance Π , where S and T stand for the sets of sensors and mobiles in Π , respectively. Let cell(t i ) denote the cell of the grid in which object t i is located. First, given that, for every object t i ∈ T , we have V(t i ) ⊆ V 1 (t i ), we determine the following disjoint partition of T into T = T ∪ T :</p><p>(i) t i ∈ T if and only if can be potentially tracked by any possible (out of four) triplet of sensors from V 1 (t i ), and (ii) t i ∈ T if and only if there exists a pair of sensors in cell(t i ) (= V 1 (t i )) that have to be a part of any solution for t i in Π .</p><p>To show feasibility of such a partition, consider a mobile t i ∈ T . If the compatibility graph restricted to the four sensors in V 1 (t i ) is complete (i.e., all four sensors of cell(t i ) can communicate one with each other), then we have t i ∈ T , and this corresponds to locally complete compatibility of sensors relevant to t i . Alternatively, if the communication between the sensors in V 1 (t i ) is not complete, then there exist at least one pair of mutually incompatible sensors s, s ∈ V 1 (t i ). Clearly, these two sensors cannot be simultaneously a part of a solution for t i . Therefore, two other sensors V 1 (t i ) \ {s, s } have to be a part of any solution for t i in Π , if one exists, and thus we have t i ∈ T . Clearly, this partition of T can be performed in linear time.</p><p>Observe that, for each object t i ∈ T , the pair of sensors V 1 (t i ) \ {s, s } can be preassigned to t i . Now, let S ⊆ {s 1 , . . . , s m } be the set of sensors that were not preassigned to</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><surname>Afrl/Iftb</surname></persName>
		</author>
		<ptr target="http://www.rl.af.mil/div/IFT/IFTB/ants/ants.html" />
		<title level="m">Autonomous Negotiating Teams (ANTs) Program</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Distributed constraint satisfaction in a wireless sensor tracking system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Béjar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IJCAI-01 Workshop on Distributed Constraint Reasoning</title>
		<meeting>the IJCAI-01 Workshop on Distributed Constraint Reasoning<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Distributed dynamic backtracking</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bessière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maestre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Meseguer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IJCAI-01 Workshop on Distributed Constraint Reasoning</title>
		<meeting>the IJCAI-01 Workshop on Distributed Constraint Reasoning<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Distributed constrained agents for allocating service demands in multi-provider networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Calisti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Faltings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Special Issue on Constraint-Based Problem Solving</title>
		<imprint>
			<biblScope unit="volume">XXIX</biblScope>
			<biblScope unit="issue">91</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>J. Italian Oper. Res. Soc.</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multistage negotiation for distributed constraint satisfaction</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Conry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Lesser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems Man Cybernet. (Special Section on DAI)</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1462" to="1477" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<title level="m">Introduction to Algorithms</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Self-similarity in world wide web traffic: evidence and possible causes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Crovella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bestavros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Networking</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="835" to="846" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Communication and computation in distributed CSP algorithms</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Béjar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Gomes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming</title>
		<meeting>the 8th International Conference on Principles and Practice of Constraint Programming</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="664" to="679" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Boosting combinatorial search through randomization</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Selman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Kautz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the National Conference on Artificial Intelligence (AAAI-98)</title>
		<meeting>the National Conference on Artificial Intelligence (AAAI-98)<address><addrLine>Madison, WI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="431" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Backtracking in distributed constraint networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hamadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bessièere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Quinqueton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th European Conference on Artificial Intelligence (ECAI-98</title>
		<meeting>the 13th European Conference on Artificial Intelligence (ECAI-98</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="219" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A formalization of autonomous dynamic reconfiguration in distributed constraint satisfaction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hannebauer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1-4</biblScope>
			<biblScope unit="page" from="129" to="151" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Complexity results for standard benchmark domains in planning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Helmert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">143</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="219" to="262" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Local search topology in planning benchmarks: an empirical analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hoffmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI-01)</title>
		<meeting>the 17th International Joint Conference on Artificial Intelligence (IJCAI-01)<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="453" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Local search topology in planning benchmarks: a theoretical analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hoffmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Artificial Intelligence Planning and Scheduling (AIPS-02)</title>
		<meeting>the 6th International Conference on Artificial Intelligence Planning and Scheduling (AIPS-02)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="379" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Distributed sensor network for real time tracking</title>
		<author>
			<persName><forename type="first">B</forename><surname>Horling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mailler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rawlins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lesser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Conference on Autonomous Agents</title>
		<meeting>the Fifth International Conference on Autonomous Agents</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="417" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">CNCL-Communication Networks Class Library</title>
		<author>
			<persName><forename type="first">M</forename><surname>Junius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Büter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pesch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Aachen University of Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the complexity of general graph factor problems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="601" to="608" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Phase transitions, structure, and complexity in wireless networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamachari</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Ithaca, NY</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Electrical Engineering, Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Distributed problem solving and the boundaries of selfconfiguration in multi-hop wireless networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Béjar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Wicker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hawaii International Conference on System Sciences (HICSS-35)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On the self-similar nature of ethernet traffic (Extended version)</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Leland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Taqqu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Willinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Wilson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Networking</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Open constraint satisfaction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Macho-Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Faltings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAMAS-02 Workshop on Distributed Constraint Satisfaction</title>
		<meeting>the AAMAS-02 Workshop on Distributed Constraint Satisfaction</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A distributed cooperating constraints solving system</title>
		<author>
			<persName><forename type="first">P</forename><surname>Marti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rueher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internat. J. Artificial Intelligence Tools</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="93" to="113" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scheduling agents-distributed timetabling problems (DisTTP)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Meisels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kaplansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on the Practice and Theory of Automated Timetabling (PATAT-02)</title>
		<meeting>the International Conference on the Practice and Theory of Automated Timetabling (PATAT-02)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="182" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Comparing performance of distributed constraints processing algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Meisels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Razgon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAMAS-2002 Workshop on Distributed Constraint Reasoning</title>
		<meeting>the AAMAS-2002 Workshop on Distributed Constraint Reasoning</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="86" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A dynamic distributed constraint satisfaction approach to resource allocation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Modi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tambe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kulkarni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Principles and Practices of Constraint Programming</title>
		<meeting>International Conference on Principles and Practices of Constraint Programming</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="685" to="700" />
		</imprint>
	</monogr>
	<note>CP-2001</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Determining computational complexity from characteristic phase transitions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Monasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zecchina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Selman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Troyansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">400</biblScope>
			<biblScope unit="page" from="133" to="137" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A distributed arc-consistency algorithm</title>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Deville</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Programming</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="227" to="250" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Wide area traffic: the failure of Poisson modeling</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Networking</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="226" to="244" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Samorodnitsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Taqqu</surname></persName>
		</author>
		<title level="m">Stable Non-Gaussian Random Processes</title>
		<imprint>
			<publisher>Chapman &amp; Hall</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<ptr target="http://www.satlib.org/index-ubc.html" />
		<title level="m">SATLIB-The Satisfability Library</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Hoos</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Stützle</surname></persName>
		</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Maintaining hierarchical distributed consistency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Silaghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sam-Haroud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Faltings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the CP-00 Workshop on Distributed Constraint Satisfaction</title>
		<meeting>the CP-00 Workshop on Distributed Constraint Satisfaction</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Distributed constrained heuristic search</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sycara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Systems Man Cybernet</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1446" to="1461" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</author>
		<title level="m">Proceedings of the Eighteenth National Conference on Artificial Intelligence (AAAI-02)</title>
		<meeting>the Eighteenth National Conference on Artificial Intelligence (AAAI-02)<address><addrLine>Edmonton, AB</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="695" to="700" />
		</imprint>
	</monogr>
	<note>From P to NP: COL, XOR, NAE, 1-in-k, and Horn SAT</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Weak-commitment search for solving constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th National Conference on Artificial Intelligence (AAAI-94)</title>
		<meeting>the 12th National Conference on Artificial Intelligence (AAAI-94)<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="313" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Asynchronous weak-commitment search for solving distributed constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Conference on Principles and Practice of Constraint Programming (CP-95)</title>
		<meeting>the First International Conference on Principles and Practice of Constraint Programming (CP-95)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="88" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Distributed constraint satisfaction for formalizing distributed problem solving</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Durfee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth IEEE International Conference on Distributed Computing Systems</title>
		<meeting>the Twelfth IEEE International Conference on Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="614" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The distributed constraint satisfaction problem: formalization and algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Durfee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kuwabara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowledge Data Engrg</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="673" to="685" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Algorithms for distributed constraint satisfaction: a review</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hirayama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Autonomous Agents Multi-Agent Syst</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="198" to="212" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
