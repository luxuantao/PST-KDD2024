<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FRAUDAR: Bounding Graph Fraud in the Face of Camouflage</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bryan</forename><surname>Hooi</surname></persName>
							<email>bhooi@andrew.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>5000 Forbes Avenue</addrLine>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hyun</forename><forename type="middle">Ah</forename><surname>Song</surname></persName>
							<email>hyunahs@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>5000 Forbes Avenue</addrLine>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alex</forename><surname>Beutel</surname></persName>
							<email>abeutel@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>5000 Forbes Avenue</addrLine>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Neil</forename><surname>Shah</surname></persName>
							<email>neilshah@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>5000 Forbes Avenue</addrLine>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kijung</forename><surname>Shin</surname></persName>
							<email>kijungs@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>5000 Forbes Avenue</addrLine>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
							<email>christos@cs.cmu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>5000 Forbes Avenue</addrLine>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">FRAUDAR: Bounding Graph Fraud in the Face of Camouflage</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">12078F8FBC463294BA96316A2D70D525</idno>
					<idno type="DOI">10.1145/2939672.2939747</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Given a bipartite graph of users and the products that they review, or followers and followees, how can we detect fake reviews or follows? Existing fraud detection methods (spectral, etc.) try to identify dense subgraphs of nodes that are sparsely connected to the remaining graph. Fraudsters can evade these methods using camouflage, by adding reviews or follows with honest targets so that they look "normal". Even worse, some fraudsters use hijacked accounts from honest users, and then the camouflage is indeed organic.</p><p>Our focus is to spot fraudsters in the presence of camouflage or hijacked accounts. We propose FRAUDAR, an algorithm that (a) is camouflage-resistant, (b) provides upper bounds on the effectiveness of fraudsters, and (c) is effective in real-world data. Experimental results under various attacks show that FRAUDAR outperforms the top competitor in accuracy of detecting both camouflaged and non-camouflaged fraud. Additionally, in real-world experiments with a Twitter follower-followee graph of 1.47 billion edges, FRAUDAR successfully detected a subgraph of more than 4000 detected accounts, of which a majority had tweets showing that they used follower-buying services.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>How can we detect if a politician has purchased fake followers on Twitter, or if a product's reviews on Amazon are genuine? More challengingly, how can we provably prevent fraudsters who sell fake followers and reviews for various web services from evading our detection systems? In this paper we focus on precisely this problem -specifically, how can we design a fraud detection system with strong, provable guarantees of robustness?</p><p>Given the rise in popularity of social networks and other web services in recent years, fraudsters have strong incentives to manipulate these services. On several shady websites, anyone can buy fake Facebook page-likes or Twitter followers by the thousands. Yelp, Amazon and TripAdvisor fake reviews are also available for sale, misleading consumers about restaurants, hotels, and other services and products. Detecting and neutralizing these actions is important for companies and consumers alike.</p><p>The tell-tale sign of such fraudulent actions is that fraudsters Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. must add many edges, creating unusually large and dense regions in the adjacency matrix of the graph (see Figure <ref type="figure" target="#fig_1">2</ref>). Smart fraudsters will also try to 'look normal', by adding links to popular items/idols (like famous singers/actors, or well-liked products) -this behavior is called "camouflage" in the recent literature. State-of-the-art algorithms, such as SPOKEN <ref type="bibr" target="#b23">[23]</ref> and NETPROBE <ref type="bibr" target="#b21">[21]</ref> exploit exactly the density signal, but do not account for "camouflage."</p><p>We propose FRAUDAR, a novel approach for successfully detecting fraudsters under camouflage, and we give provable limits on undetectable fraud. We provide data-dependent limits on the maximum number of edges a group of fraudulent adversaries can have without being detected, on a wide variety of real world graphs. As shown in Figure <ref type="figure" target="#fig_0">1</ref>(a), FRAUDAR provides limits on undetectable fraud, and additionally provides novel optimizations that strengthen this bound.</p><p>Moreover, our method outperforms competitors and finds real world fraud on Twitter. In Figure <ref type="figure" target="#fig_0">1</ref>(b) we find that FRAUDAR detects injected fraud with high accuracy, even in the case of camouflage, where prior methods struggle to detect fraudulent attacks. Additionally, when tested on a Twitter graph from 2009, FRAU-DAR finds a 4031 by 4313 subgraph that is 68% dense. As shown in Figure <ref type="figure" target="#fig_0">1(c-d</ref>), we find that a majority of the detected accounts had tweets showing that they used follower-buying services, and had gone undetected by Twitter for the 7 years since the data was collected. Finally, our method is scalable, with near linear runtime in the data size.</p><p>Thus, our main contributions are as follows:</p><p>• Metric: we propose a novel family of metrics which satisfies intuitive "axioms" and has several advantages as a suspiciousness metric. • Theoretical Guarantees: we provide a provable bound on how much fraud an adversary can have in the graph without being caught, even in the face of camouflage. Additionally, we improve the theoretical bound through novel optimizations that better distinguish fraud and normal behavior in real-world data.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND AND RELATED WORK</head><p>Fraud detection has received significant focus in recent years. Many existing methods aim to detect fraud through review text <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b20">20]</ref>. However, these approaches are typically not adversarially robust: spammers can carefully select their review texts to avoid detection. Even without knowledge of the detection system, they may mimic normal user reviews as closely as possible. Graph-based approaches detect groups of spammers, often by identifying unexpectedly dense regions of the graph of users and products. Such methods are potentially harder to evade, as creating fake reviews unavoidably generates edges in the graph. Graph-based methods may be classified into global and local methods. Global methods: Building on singular value decomposition (SVD), latent factor models, and belief propagation (BP), these model the entire graph to find fraud. SPOKEN <ref type="bibr" target="#b23">[23]</ref> considered the "eigenspokes" pattern produced by pairs of eigenvectors of graphs, and was later generalized for fraud detection <ref type="bibr" target="#b12">[12]</ref>. FBOX <ref type="bibr" target="#b25">[25]</ref> builds on SVD but focuses on detecting attacks missed by spectral techniques. Several methods have used HITS <ref type="bibr" target="#b15">[15]</ref>-like ideas to detect fraud in graphs <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b6">6,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b30">30]</ref>. BP has been used for fraud classification on eBay <ref type="bibr" target="#b21">[21]</ref>, and fraud detection <ref type="bibr" target="#b1">[1]</ref>. All of these methods have been successful in finding fraud but they offer no guarantees of robustness. <ref type="bibr" target="#b25">[25]</ref> performs adversarial analysis for spectral algorithms, showing that attacks of small enough scale will necessarily evade detection methods which rely on the top k SVD components. Local clustering methods: A different direction for fraud detection focuses on local subgraphs, by analyzing the properties of egonets to detect fraud <ref type="bibr" target="#b5">[5,</ref><ref type="bibr" target="#b22">22]</ref>. COPYCATCH <ref type="bibr" target="#b2">[2]</ref> and GETTHESCOOP <ref type="bibr" target="#b12">[12]</ref> use local search heuristics to find relevant dense bipartite subgraphs. However, without guarantees on the search algorithm, the algorithms may not be robust to intelligent adversaries. Dense subgraph mining: Finding dense subgraphs has been an important focus of graph theory communities and has been studied from a wide array of perspectives <ref type="bibr">[7,</ref><ref type="bibr" target="#b14">14]</ref>. Most closely related  to ours is Charikar's work on finding subgraphs with large average degree <ref type="bibr" target="#b4">[4]</ref>, which shows that subgraph average degree can be optimized with approximation guarantees. Variants have been proposed to efficiently find large, dense subgraphs <ref type="bibr" target="#b27">[27]</ref>, with approximation guarantees. To our knowledge, however, this is the first work which adapts this theoretical perspective to the challenges of fraud detection and camouflage resistance, and achieves meaningful bounds for our application. Moreover, our work differs from these in its setting of bipartite graphs, and in the use of edge reweighting to further increase accuracy. Social network-based Sybil defense: Multiple identity or 'Sybil' attacks pose problems of malicious behavior in distributed systems. SybilGuard <ref type="bibr" target="#b32">[32]</ref> and SybilLimit <ref type="bibr" target="#b31">[31]</ref> use a decentralized random walk approach to limit the number of Sybil attackers. SumUp <ref type="bibr" target="#b26">[26]</ref> and Iolaus <ref type="bibr" target="#b19">[19]</ref> adapt this to content rating settings. However, these systems rely on a separate trust network between users; our setting is fundamentally different as our approach works directly with the user-product bipartite graph. Handling camouflage: <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b28">28]</ref> consider fraud detection methods that are robust to camouflage attacks. However, both methods focus on the time-series domain, observing changes in the behavior of fraudsters from system access logs rather than graph data.</p><p>A comparison between FRAUDAR and other fraud detection algorithms is summarized in Table <ref type="table" target="#tab_2">1</ref>. Our proposed method FRAU-DAR is the only one that matches all specifications.  (U ∪ W, E). We can consider the objects to be followees on Twitter or products on Amazon. Table <ref type="table" target="#tab_3">2</ref> gives a complete list of the symbols we use throughout the paper. We now describe our attack model and then our problem definition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PROBLEM DEFINITION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attack model.</head><p>We assume that fraudsters are hired to use users they control to add edges pointing to a subset of nodes in W. For example, a business may pay for followers on Twitter or positive reviews on Yelp. In general, fraudsters add a large number of edges, inducing a dense subgraph between the fraudster accounts and customers, as shown in the bottom right corner of each subplot of Figure <ref type="figure" target="#fig_1">2</ref>. This general characteristic of fraud was found to be true in our experiments on real datasets, as well as in many other papers which use dense blocks to detect fraud <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b23">23]</ref>.</p><p>To mask the fraud, fraudster accounts can add arbitrary "camouflage", i.e. edges pointing from their user accounts to any of the nodes in W that are not customers. We assume that fraudsters have complete knowledge of the graph and fraud detection mechanisms, enabling worst-case camouflage for any fraud detection system we create. Examples of the possible types of camouflage are given in Figure <ref type="figure" target="#fig_1">2</ref>: (a) adding camouflage edges to random honest users, (b) camouflage biased toward high degree nodes, (c) using hijacked ac-counts, whereby fraudster accounts have realistic patterns of camouflage essentially similar to that of honest users.</p><p>While it is trivial for fraud accounts to add edges to any other node, it is more difficult for customer accounts to get honest edges. In particular, we assume that a customer would try to increase their number of incoming edges by a significant portion, and as a result a fraction, λ ∈ [0, 1], of their incoming edges will be from fraudsters. This assumption would manifest itself as customers wanting to boost their follower count to seem noticeably more popular or a restaurant wanting a significant number of positive ratings to shift its average "number of stars" on Yelp. We will demonstrate how using this real world pattern significantly improves fraud detection both theoretically and in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Desired properties of detection approach.</head><p>Our goal is to detect dense subgraphs in G, typically indicative of fraudulent groups of users and objects, like in the bottom-right of Figure <ref type="figure" target="#fig_1">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INFORMAL PROBLEM 1.</head><p>Given a bipartite graph, detect attacks so as to minimize the number of edges that fraudsters can add pointing to customers without being detected.</p><p>Given that we want our detection algorithm to be able to handle camouflage, we define the requirements for a camouflage-resistant algorithm: DEFINITION 1. Let (A, B) be a block consisting of fraudulent users and objects. A density metric g is camouflage-resistant if when any amount of camouflage is added by the adversary, g(A ∪ B) does not decrease.</p><p>That is, fraudsters cannot make themselves less suspicious by adding camouflage. Our goal is to find a fraud detection approach satisfying the following criteria:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROBLEM DEFINITION 1 (DENSE SUBGRAPH DETECTION).</head><p>Design a class of density metrics for bipartite graphs, which can be optimized (1) in near-linear time, (2) within a constant factor of the optimum, and (3) is minimally affected by camouflage edges added by adversaries.</p><p>Obtaining theoretical guarantees on the near-optimality of the returned subgraph is important because, as we will later show, it allows us to offer guarantees against worst-case fraudsters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PROPOSED METHOD</head><p>Given this problem definition and attack model, we now offer FRAUDAR and our theoretical analysis of FRAUDAR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Metric</head><p>In this section, we propose a class of metrics g that have particularly desirable properties when used as suspiciousness metrics. Namely, we will show that if g takes the form in ( <ref type="formula" target="#formula_0">1</ref>) and ( <ref type="formula" target="#formula_1">2</ref>), then it can be optimized in a way that is (a) scalable; (b) offers theoretical guarantees, and (c) is robust to camouflage.</p><p>Let A ⊆ U be a subset of users and B ⊆ W be a subset of objects. Let S = A ∪ B, and V = U ∪ W. For the rest of this paper, we use g to denote the density metric that the algorithm will optimize, i.e. the algorithm will find S to (approximately) maximize g(S). Note that g has a single argument, which is the union of the users and objects whose suspiciousness we are evaluating.</p><p>We propose using density metrics g of the following form:</p><formula xml:id="formula_0">g(S) = f (S) |S|<label>(1)</label></formula><p>where total suspiciousness f is:</p><formula xml:id="formula_1">f (S) = fV (S) + fE (S) = i∈S ai + i,j∈S∧(i,j)∈E cij,<label>(2)</label></formula><p>for some constants ai ≥ 0 and constants cij &gt; 0.</p><p>Intuitively, the node suspiciousness fV (S) is a sum of constants ai corresponding to the users and objects in S, which can be thought of as how individually suspicious that particular user or object is. The edge suspiciousness fE (S) is a sum of constants cij corresponding to the edges in between S, which can be thought of as how suspicious that particular edge is (e.g. the suspiciousness of the text of a review by user i for object j).</p><p>There are many advantages to metrics of this form. Firstly, metrics of this form can be optimized in a way that is (a) scalable; (b) offers theoretical guarantees, and (c) is robust to camouflage, as we demonstrate in the rest of this paper. All 3 of these properties hold due to the particular chosen form in ( <ref type="formula" target="#formula_0">1</ref>) and <ref type="bibr" target="#b2">(2)</ref>.</p><p>Secondly, metrics of this form obey a number of basic properties (or "axioms") that we would intuitively expect a reasonable suspiciousness metric should meet, as we next show. These basic properties are adapted from the "axioms for suspiciousness metrics," proposed in <ref type="bibr" target="#b10">[10]</ref>, to our setting where node and edge weights exist.</p><p>AXIOM 1 (NODE SUSPICIOUSNESS). A subset consisting of higher suspiciousness nodes is more suspicious than one consisting of lower suspiciousness nodes, if the other conditions are fixed. Formally,</p><formula xml:id="formula_2">|S| = |S | ∧ fE (S) = fE (S ) ∧ fV (S) &gt; fV (S ) ⇒ g(S) &gt; g(S )</formula><p>AXIOM 2 (EDGE SUSPICIOUSNESS). Adding edges within a subset increases the suspiciousness of the subset if the other conditions are fixed. Formally,</p><formula xml:id="formula_3">e / ∈ E ⇒ g(S(V, E ∪ {e})) &gt; g(S(V, E))</formula><p>where S(V, E) is the subgraph induced by S in the graph (V, E).</p><p>The edge density ρ(S) of an induced subgraph is its number of edges divided by its maximum possible number of edges. AXIOM 3 (SIZE). Assuming node and edge weights are all equal, larger subsets are more suspicious than smaller subsets with the same edge density. Formally, given ai = a ∀ i, and cij = b ∀ (i, j) ∈ E:</p><formula xml:id="formula_4">|S| &gt; |S | ∧ S ⊃ S ∧ ρ(S) = ρ(S ) ⇒ g(S) &gt; g(S )</formula><p>AXIOM 4 (CONCENTRATION). A subset with smaller size is more suspicious than one with the same total suspiciousness but larger size. Formally,</p><formula xml:id="formula_5">|S| &lt; |S | ∧ f (S) = f (S ) ⇒ g(S) &gt; g(S )</formula><p>Density metrics g of the form defined in Equation (1) satisfy these properties: THEOREM 1. The density metric defined in (1) satisfies axioms 1 to 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. See appendix A.</head><p>Note some simple metrics that violate these axioms: the edge density ρ(S) itself, as a metric, does not increase with the size of S and hence violates axiom 3. On the opposite end, the total edge weight function i,j∈S∧(i,j)∈E cij as a metric violates axiom 4 as it does not consider how concentrated the edge weight is. In contrast, g scales in a reasonable manner as its size or concentration changes.</p><p>A simple example of a metric g as defined in ( <ref type="formula" target="#formula_0">1</ref>) and ( <ref type="formula" target="#formula_1">2</ref>) is the bipartite graph average degree: EXAMPLE 1. (Bipartite Graph Average Degree) Let ai = 0, and let cij = 1 if (i, j) ∈ E and 0 otherwise. In the expression (2) for f (S), we add one term cij for each edge (i, j) for which i, j are both in the subset S. Thus, f (S) is equal to the number of edges in the subgraph spanned by S, or half the total degree in the subgraph spanned by S. As a result, g(S) = f (S)</p><p>|S| is half the average degree of the subgraph spanned by S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Algorithm</head><p>Let f and g be as given in ( <ref type="formula" target="#formula_0">1</ref>) and <ref type="bibr" target="#b2">(2)</ref>. In this section, we give an algorithm for optimizing the density metric g in near-linear time.</p><p>Algorithm 0 describes our proposed FRAUDAR algorithm, a greedy approach inspired by that of <ref type="bibr" target="#b4">[4]</ref> but which covers our broader objective class. We start with the entire set of nodes U ∪ W, then repeatedly remove the node which results in the highest value of g evaluated on the remaining set of nodes. Formally, denote by X the current set we are optimizing over; initially we set X = U ∪ W. Let ∆i = f (X \{i})-f (X ) be the change in f when we remove i from the current set. At each step, we will select i to maximize ∆i, i.e. to leave behind the set with highest value of f . We then remove i from X . We then repeat this process: we recompute the values of ∆j, then choose the next node to delete, and so on. This leads to a shrinking series of sets X over time, denoted X0, . . . , Xm+n of sizes m + n, . . . , 0. At the end, we return the one of these that maximizes the density metric g.</p><p>The key fact that allows the algorithm to be efficient is the forms for f and g in ( <ref type="formula" target="#formula_0">1</ref>) and (2). When i is removed, the only values of ∆j which need to be updated are those where j is a neighbor of i. This is because for all other j, the expressions (1) and (2) ensure that ∆j does not change. Hence, the updates are fast: for each (i, j) ∈ E, over the lifetime of the algorithm we will perform at most one such update over this edge, for a total of O(|E|) updates. Using appropriate data structures, as we next describe, each update can be performed in O(log |V|) time, totalling O(|E| log |V|) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Priority Tree.</head><p>Each element i ∈ X has a priority that will change as the algorithm progresses: the priority of element i at the tth iteration is ∆i = f (Xt \ {i}) -f (Xt). This ensures that in Line 5, the element i * = arg maxi∈X t g(Xt \ {i}) we wish to find is exactly the element of highest priority, allowing us to retrieve it quickly (in O(log |V|) time, as we explain below). Note that it does not matter if we use f or g in the arg max since the denominator of g in (1), |Xt \ {i}|, is the same for all possible deletions i.</p><p>These priorities are stored in the priority tree T constructed in line 2 of Algorithm 0. This data structure is a binary tree with all |V| elements as leaves, all at the bottom level of the tree. Each internal node keeps track of the maximum priority of its two children.</p><p>The priority tree supports fast retrieval of the maximum priority element (used in Line 5 of Algorithm 0); it does this by starting at the root and repeatedly moving to the child with higher priority. It also supports quickly updating priorities: since all the leaves can be stored in fixed locations, we can easily retrieve the leaf at any index to update its priority. Then, after updating that node's priority, we travel up the tree to update each parent up to the root (used in <ref type="bibr">Line 6)</ref>. Each of these operations on T takes O(log |V|) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scalability.</head><p>The bottleneck is the loop in Lines 5 to 7 which runs m + n times. Lines 5 and 6 take O(log |V|) as discussed, while Line 7 is constant time. Finally, we need |E| updates to node priorities, one for each edge. Thus the algorithm takes O(|E| log |V|) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Theoretical Bounds</head><p>So far, we have shown that g can be optimized in near-linear time. In this section, we will show that when f and g are of the form (1) and ( <ref type="formula" target="#formula_1">2</ref>), FRAUDAR is guaranteed to return a solution of at least half of the optimum value. THEOREM 2. Let A, B be the set of users and objects returned by FRAUDAR. Then:</p><formula xml:id="formula_6">g(A ∪ B) ≥ 1 2 gOPT</formula><p>where gOPT is the maximum value of g, i.e.</p><formula xml:id="formula_7">gOPT = max A ,B g(A ∪ B )</formula><p>PROOF. Let the elements of V be labeled v1, v2, . . . , vm+n. We define 'weight assigned to node vi in S' as</p><formula xml:id="formula_8">wi(S) = ai + (v j ∈S)∧((v i ,v j )∈E) cij + (v j ∈S)∧((v j ,v i )∈E) cji</formula><p>where ai(≥ 0) indicates the weight of node vi and cij(&gt; 0) indicates that of edge (vi, vj) as in <ref type="bibr" target="#b2">(2)</ref>. Note that when node vi is removed from the current set S at some point in the algorithm, wi(S) is the decrease in the value of f , since it is the sum of all terms excluded in (2) when node vi is removed. Now consider the optimal set S * . For each node vi ∈ S * , we claim that wi(S * ) ≥ g(S * ). Otherwise, removing a node with wi(S * ) &lt; g(S * ) results in</p><formula xml:id="formula_9">g = f (S * ) -wi(S * ) |S * | -1 &gt; f (S * ) -g(S * ) |S * | -1 = f (S * ) -f (S * )/|S * | |S * | -1 = g(S * ),</formula><p>which is a contradiction. Let vi be the node that FRAUDAR removes first among those in S * , and let S be the set before FRAUDAR removes vi. Then, since S ⊃ S * , wi(S ) ≥ wi(S * ). Moreover, since FRAUDAR chooses to remove node vi, for each of the other remaining nodes vj ∈ S , wj(S ) ≥ wi(S ). Since each term in f (S ) can be assigned to at most two nodes, summing over j gives f (S ) ≥</p><formula xml:id="formula_10">|S |w i (S ) 2</formula><p>. Also note that g(A ∪ B) ≥ g(S ) since FRAUDAR returns the best solution that it encounters. We conclude that</p><formula xml:id="formula_11">g(A ∪ B) ≥ g(S ) = f (S ) |S | ≥ wi(S ) 2 ≥ wi(S * ) 2 ≥ g(S * ) 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Edge Weights and Camouflage Resistance</head><p>So far, we have seen that metrics of the form: g(S) = f (S) |S| , where f (S) = i∈S ai + i,j∈S∧(i,j)∈E cij can be optimized efficiently and with approximation guarantees. In this section, we show how we can select metrics within this class that are resistant to camouflage, i.e. they do not allow fraudulent users to make themselves less suspicious by adding camouflage edges, i.e. edges toward honest objects.</p><p>Recall that ai and cij are the weights of node i and edge ij, while f (S) is the total node and edge weight in S. A key idea of Algorithm 1 FRAUDAR, which greedily removes nodes to maximize a metric g. Line 5 and 6 run in O(log |V|) time, using a data structure described in Section 4.2. Require: Bipartite G = (U ∪ W, E); density metric g of the form in <ref type="bibr" target="#b1">(1)</ref> 1: procedure FRAUDAR (G, g) 2:</p><p>Construct priority tree T from U ∪ W see Section 4.2 3:</p><p>X0 ← U ∪ W suspicious set is initially the entire set of nodes U ∪ W 4:</p><p>for t = 1, . . . , (m + n) do 5:</p><p>i * ← arg maxi∈X i g(Xi \ {i}) exonerate least suspicious node 6:</p><p>Update priorities in T for all neighbors of i * 7:</p><p>Xt ← Xt-1 \ {i * } 8:</p><p>end for 9:</p><p>return arg max X i ∈{X 0 ,...,X m+n } g(Xi) return most suspicious set Xi 10: end procedure our approach is that instead of treating every edge equally, we assign a lower weight cij when the target object j has high degree. This is because objects of very high degree are not necessarily suspicious (since highly popular objects commonly exist). Thus, this weighting allows us to put greater emphasis on objects within unexpectedly dense subgraphs, rather than just high degree objects.</p><p>If we consider the adjacency matrix with rows representing users and columns representing objects, we would like to downweight columns with high column sum (column-weighting). A simple result we show in this section is that column-weightings are camouflage resistant. Recall that a density metric g is camouflageresistant if g(A ∪ B) does not decrease when any amount of camouflage is added by an adversary with fraudulent users A and customers B. Let di be the the ith column sum, i.e. the degree of object i.</p><p>Formally, define a column-weighting as a choice of weighting in which each cij is a function of the respective column sum, i.e. cij = h(dj) for some function h. THEOREM 3. Let cij be a column-weighting. Then g (as defined in (1) and (2)) is camouflage resistant.</p><p>PROOF. Adding camouflage only adds edges in the region between A (fraudulent users) and B C (honest objects). It does not add or remove edges within the fraudulent block; moreover, the weights of these edges do not change either as their weights only depend on the column degrees of B, which do not change when camouflage is added. Thus the value of g does not change.</p><p>A natural follow-up question is whether camouflage-resistance also holds for row-weightings (i.e. selecting cij to be a function of the corresponding row sum). It turns out that row-weightings are in general not camouflage resistant. This is because a fraudulent user account can add a large number of camouflage edges, thereby increasing their row sum, decreasing the weight of each of their edges. Thus g(A ∪ B) decreases, meaning that g is not camouflage resistant.</p><p>Hence we may choose any column-weighting while ensuring camouflage resistance. The remaining question is what function to choose for the column-weighting, i.e. the function h where cij = h(dj). It should be decreasing (so as to downweight columns with high sum). It should shrink more slowly than h(x) = 1/x, since h(x) = 1/x allows a single edge to contribute as much as the total contribution of a column with any number of edges, causing us to catch columns with single ones rather than dense blocks.</p><p>Within the remaining space of choices, we note that a very similar problem of downweighting based on column frequency appears in deciding the form of the 'inverse document frequency' term of the popular heuristic tf-idf weighting scheme <ref type="bibr" target="#b24">[24]</ref>, in which loga-rithmic weighting of frequency has been empirically found to perform well. We also show empirical results (in Section 5.1) that logarithmic weighting leads to strong theoretical bounds. For these reasons, we recommend using h(x) = 1/ log(x + c), where c is a small constant (set to 5 in our experiments) to prevent the denominator from becoming zero, or excessive variability for small values of x. We use the resulting density metric (denoted g log ) in our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Implications: Bounding Fraud</head><p>Figure <ref type="figure" target="#fig_0">1(a)</ref> shows curves representing our theoretical bounds on the maximum amount of fraud that can be present for each possible size of the fraudulent block, based on Theorem 2. We now explain how such bounds can be computed from Theorem 2. Assume that the fraudulent block contains m0 user accounts and n0 customers.</p><p>In this section, we assume that no side information is present, so we set the ai, the prior suspiciousness of each node, to 0. Thus here g log (S) = 1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>|S|</head><p>i,j∈S 1 log(d j +c) , where dj is the degree of the jth object. Consider a fraudulent subgraph with m0 user nodes and n0 object nodes. Assume that each fraudulent customer has at least a certain fraction 0 &lt; λ &lt; 1 of fraudulent edges: each fraudulent customer should be receiving at least a comparable fraction of fraudulent reviews to its actual honest reviews, otherwise it would not be profiting appreciably from the fraud. THEOREM 4. Let ( Â, B) be the block detected by FRAUDAR. Then the number of edges that a fraudulent block of size (m0, n0) can have without being detected is at most 2(m0 + n0)g log ( Â ∪ B) log(m0/λ + c). In other words, our algorithm will detect a fraudulent block without fail if it contains more edges than this threshold.</p><p>PROOF. By Theorem 2, 2g log ( Â ∪ B) is an upper bound on the value of g log on any subgraph of users and objects. Since the fraudulent block has m0+n0 nodes in total, thus 2(m0+n0)g log ( Â∪ B) is an upper bound on the value of total suspiciousness f log .</p><p>Moreover, each fraudulent customer has at most m0 fraudulent edges joined to it, and since at least λ fraction of its edges must be fraudulent, it can have at most m0/λ degree in total. Hence the weight of each fraudulent edge is at least 1 log(m 0 /λ+c) . But since the total weighted degree is at most 2(m0 + n0)g log ( Â ∪ B), it follows that the number of fraudulent edges is at most 2(m0 + n0)g log ( Â ∪ B) log(m0/λ + c).</p><p>We apply this bound to real data in Section 5.1. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTS</head><p>We design experiments to answer the following questions: Q1. Illustration of our theorem: How strong are the bounds that FRAUDAR provides in terms of bounding undetectable fraud in the graph? Does column weighting improve those bounds? Q2. Evaluation on synthetic data: How accurately does FRAU-DAR detect injected fraud under different types of camouflage attacks? Does FRAUDAR outperform state-of-the-art competitors? Q3. Effectiveness in real-world data: Does FRAUDAR detect true fraud in real-world graphs? Have the fraudulent accounts already been detected by previous methods? Q4. Scalability: Is FRAUDAR scalable with regard to the data size?</p><p>We implemented FRAUDAR in Python; all experiments were carried out on a 2.4 GHz Intel Core i5 Macbook Pro, 16 GB RAM, running OS X 10.9.5. The code is available for download at www. andrew.cmu.edu/user/bhooi/camo.zip. We test FRAUDAR on a variety of real world datasets. Table <ref type="table">3</ref> offers details on the datasets we used.</p><p>To test the accuracy of our method, we use synthetic attacks injected into our Amazon dataset. We structure our "attacks" as shown in Figure <ref type="figure" target="#fig_1">2</ref>. We injected a fraudulent block of users and customers with varying densities. We assume λ = 0.5 for our theoretical bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Q1. Illustration of our Theorem</head><p>In Figure <ref type="figure" target="#fig_0">1</ref> (a), we showed our theoretical bounds (Theorem 4) applied to compute the maximum number of edges an adversary with m0 = 50 user nodes can have for various values of n0. These are computed by running FRAUDAR under two weighting schemes. First, we use our g log scheme exactly as in Theorem 4 to get an upper bound 2(m0 + n0)g log ( Â ∪ B) log(m0/λ + c) on the number of fraudulent edges; plotting this against n0 gives the green region ('improved') in Figure <ref type="figure" target="#fig_0">1 (a)</ref>. The blue region ('original') comes from using the analogous procedure without the logweighting, i.e. where g(S) is half the average degree, as in Example 1.</p><p>In this case, we see that the log-weighted scheme provides stronger bounds, since the bound is lower, i.e. an adversary should have fewer edges in order not to be detected. Intuitively, this happens because down-weighting high degree columns decreases the weight of many of the honest high degree objects in the dataset, so groups of adversaries stand out more, resulting in stronger bounds on how many edges an adversary can have.</p><p>Next, we apply our FRAUDAR in the same way over various real-world graphs to analyze the theoretical upper bounds computed by FRAUDAR on the density that fraudulent blocks can Figure <ref type="figure" target="#fig_3">3</ref>: FRAUDAR's bounds on fraud are stringent, on real graphs: E.g., on TripAdvisor, the bound says that a fraudulent block containing 50 user accounts and anywhere between 100 and 1000 products must have density of &lt; 2% to avoid detection.</p><p>have. We run FRAUDAR on four real-world graphs: Amazon <ref type="bibr" target="#b18">[18]</ref>, Trip Advisor <ref type="bibr" target="#b29">[29]</ref>, Epinions <ref type="bibr" target="#b17">[17]</ref>, and Wiki-vote <ref type="bibr" target="#b17">[17]</ref>. The detailed description of each graph is in Table <ref type="table">3</ref>. For all datasets, Figure <ref type="figure" target="#fig_3">3</ref> shows the maximum number of fraudulent edges that an adversary can have without being detected, assuming 50 fraudulent users and varying the number of fraudulent customers. We see that we can detect fraud most easily in Trip Advisor, followed by Epinion, Wiki-vote, Amazon; even a fairly sparse block of density around 0.05 would stand out strongly in the Trip Advisor graph. While density is important in determining how easy it is to detect fraud in each graph (fraudulent blocks stand out more strongly in a sparse graph), it is not the only factor. Indeed, Wiki-vote is actually denser than Amazon. In fact, the difficulty of detecting fraud in each graph is mainly determined by its densest blocks, since an adversarial block that is significantly less dense than the densest normal blocks in the graph is unlikely to be detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Q2. Evaluation on Synthetic Data</head><p>In Figure <ref type="figure" target="#fig_0">1</ref> (b), we demonstrated that FRAUDAR can effectively detect fraud under four types of camouflage attacks: 1) Injection of fraud with no camouflage, 2) random camouflage, 3) biased camouflage and 4) hijacked accounts, more accurately than competitors.</p><p>We conduct experiments based on the settings at the beginning of this section, averaged over 5 trials. For the camouflage scenarios 2) and 3), the amount of camouflage added per fraudulent user account was (on average) equal to the amount of actual fraudulent edges for that user. For the 'Random Camo' case, for each fake user node, camouflage edges were chosen at random, with on average the same number of camouflage edges as fraudulent edges, as shown in Figure <ref type="figure" target="#fig_1">2 (a)</ref>. For the 'Biased Camo' case, for each fake user node, camouflage edges were directed toward each object with probability proportional to the degree of the object as shown in Figure <ref type="figure" target="#fig_1">2 (b)</ref>. For the 'Hijacked' case, we used a random subset of existing users to form the fraudulent block.</p><p>In each case, we injected 200 fraudulent users and 200 fraudulent products with various edge densities to the subsetted Amazon review graph of 2000 users and 2000 products, with a density of 0.0006. We compare FRAUDAR to SPOKEN in their F measure (= 2×precision×recall precision+recall ) in detecting the fake users. In the first set of experiments, we assume that no honest user added an edge to the fraudulent target (i.e. object) nodes.</p><p>As seen in Figure <ref type="figure" target="#fig_0">1</ref>(b), the results demonstrate that FRAUDAR works robustly and efficiently against all four attacks, achieving F- measures of over 0.95 on all four scenarios for densities of at least 0.04. On the other hand, SPOKEN was able to reach its maximum performance of 0.9 only when fraud blocks had densities of higher than 0.06 and under the 'no camouflage' scenario.</p><p>The experimental results in Figure <ref type="figure" target="#fig_0">1</ref>(b) were based on the assumption that no honest user added an edge to the fraudulent target nodes. However, in a real-world environment, some honest users may add edges to the fraudulent target nodes (which we refer to as "reverse camouflage"). To incorporate this, we conducted another experiment using an attack model where we add edges between honest users and the fraudulent target nodes, but with sparser density compared to the fraud blocks. We added random edges to this region, with half the density of the fraud blocks. All other experimental settings were unchanged. The experimental results are shown in Figure <ref type="figure" target="#fig_4">4</ref> (a). For FRAUDAR, the results are generally similar. In contrast, SPOKEN shows slightly worse performance under this additional camouflage.</p><p>To show that FRAUDAR is effective both at catching fraudulent users accounts as well as fraudulent objects, we next separately evaluate the fraud detection of both fake users and fake targets using F measure. The basic experimental setup is same as before, with the density of the fraudulent blocks now fixed to 0.03. In Figure <ref type="figure" target="#fig_4">4</ref> (b), the bar plots are shown for the comparison. 'Userwise' (red) denotes the F measure of the detecting fake users, and 'target-wise' denotes the F measure of detecting fake target nodes. We see that in general, accuracy is high and fairly similar, but the performance in detecting fake users is slightly higher than that of detecting products.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Q3. Effectiveness on Real Data</head><p>In this section, we verify that FRAUDAR accurately detects a large block of fraudulent accounts in the Twitter follower-followee graph, as verified by hand labelling and by clear signs of fraud exhibited by a majority of the detected users. Indeed, a majority of the detected accounts had tweets advertising follower-buying services, and the tweets had not been removed or the accounts suspended for the 7 years since the data was collected. Figure <ref type="figure" target="#fig_0">1(d)</ref> shows a sample fraudster caught by FRAUDAR.</p><p>The Twitter graph we use contains 41.7 million users and 1.47 billion follows; it was extracted in July 2009 and first used in <ref type="bibr" target="#b16">[16]</ref>. On this graph, FRAUDAR detected a dense subgraph of size 4031 followers by 4313 followees. This subgraph is extremely dense, with 68% density, which is highly suspicious in itself.</p><p>To further investigate this block, we randomly sampled 125 followers and 125 followees in the block detected by FRAUDAR for hand labeling to determine how many of them appear fraudulent. To do this, we labeled which users were fraudulent based on the following characteristics of their profile data, chosen based on established criteria in the literature <ref type="bibr" target="#b25">[25]</ref> summarized below.</p><p>• links on profile associated with malware or scams • clear bot-like behavior (e.g. replying to large numbers of tweets with identical messages) • account deleted • account suspended For comparison, we also construct two control groups of size 100 containing users that were not detected by the algorithm. The first control group contains randomly selected non-detected users. For the second (degree-matched) control group, we constructed it to match the follower count of users in the detected group; we do this by repeatedly selecting a random detected user, then finding another non-detected user who has at most 10% bigger or smaller follower count. During the labelling process, we shuffled the detected users with the control groups randomly and hid group memberships from labellers, labeling users in a "blind" manner.</p><p>Additionally, we also check and report how many of these users have Tweets containing the URLs of two known follower-buying services, TweepMe and TweeterGetter, showing that they had advertised these follower-buying services through tweets.</p><p>Note that this entire labelling process used only profile and tweet data and not follower-followee data, whereas our algorithm uses only follower-followee data, so the labelling is a fair estimate of the algorithm's accuracy. We present two pieces of evidence which strongly indicates fraud in the detected group. Firstly, the percentage of users with tweets advertising TweepMe or Tweetergetter is much higher among the detected users than among both control groups (Figure <ref type="figure" target="#fig_5">5</ref>): 41% of the detected followers, and 26% for the detected followees. These rise to 62% and 42% respectively as shown in Figure <ref type="figure" target="#fig_0">1</ref>(c) if we ignore deleted, protected and suspended accounts (for which profile information was unavailable). In the control groups, there were no mentions of TweepMe and very few mentions of TweeterGetter, as shown in Figure <ref type="figure" target="#fig_5">5</ref>. Figure <ref type="figure" target="#fig_5">5</ref> shows the breakdown of our groups in terms of deleted and suspended users. Given the sparsity of TweepMe and TweeterGetter in the control groups, we see that the detected users are likely charac-  terized by a large block of users using these and possibly other follower-buying services, resulting in a dense block.</p><p>Secondly, we used our hand-labelling using the above criteria to determine how many of each group appear fraudulent. 57% of the detected followers and 40% of the followees were labelled as fraudulent, deleted or suspended accounts, but much fewer in the control groups, with 25% for the degree-matched control group, and 12% for control group with no condition. Thus both these results support the effectiveness of FRAUDAR in detecting fraudulent users in the real-world graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Q4. Scalability</head><p>Figure <ref type="figure" target="#fig_7">7</ref> shows the near-linear scaling of FRAUDAR's running time in the number of edges. Here we used the Trip Advisor dataset, and subsampled user nodes in proportions of 0.7 0 , . . . , 0.7 12 . Slopes parallel to the main diagonal indicate linear growth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>In this paper, we propose FRAUDAR, a fraud detection algorithm which provably bounds the amount of fraud adversaries can have, even in face of camouflage. Our main contributions are as follows.</p><p>• Metric: we propose a novel family of metrics which satis- fies intuitive "axioms" and has several advantages as a suspiciousness metric. • Theoretical Guarantees: we provide theorems (See Theorem 2 in Section 4.3 and Theorem 4 in Section 4.5) on how FRAUDAR gives a provable upper bound on undetectable fraud. We also prove that our proposed metric is camouflageresistant. • Effectiveness: FRAUDAR was successfully applied on realworld graphs on fraud attacks with various types of camouflage, and outperformed the competitor. It also detected a large block of fraudulent activity in the Twitter followerfollowee graph. • Scalability: FRAUDAR runs near-linearly in the input size.</p><p>(See Figure <ref type="figure" target="#fig_7">7</ref>). </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (a) Our theoretical thresholds: fraudsters in the detection region will be caught by our approach. Our novel optimizations improve the (data-dependent) bounds by lowering it to the green region. (b) Fraudar outperforms competitors. (c) A large fraction of accounts flagged by our algorithm are confirmed fraudsters: both among detected followees (left red bar) and followers (right red bar) compared to almost none among non-flagged accounts (2 control groups). Confirmation was done by inspecting Tweets that advertise TweepMe or TweeterGetter. (d) Real-life results -a sample fraudster caught.</figDesc><graphic coords="2,335.59,235.08,150.64,201.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Three examples of possible attacks.</figDesc><graphic coords="3,76.66,53.79,150.63,136.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Consider a set of m users U = {u1, . . . , um} and n objects W = {w1, . . . , wn} connected according to a bipartite graph G = Symbol Interpretation U = {u1, . . . , um} Users W = {w1, . . . , wn} Objects V Nodes of bipartite graph: U ∪ W G Bipartite graph G = (V, E) A Subset of users B Subset of objects S Subset of nodes, S = A ∪ B g(S) Density metric f (S) 'Total suspiciousness' metric (2) X Current set of nodes in the greedy algorithm ∆i f (X \ {i}) -f (X ) Â, B Users (resp. objects) returned by FRAUDAR m0, n0 No. of users (resp. objects) in fraud block di ith column sum of adjacency matrix λ Min. fraction of fraud edges per customer g log Logarithmic weighted metric</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>3 :</head><label>3</label><figDesc>Bipartite graph datasets used in our experiments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: (a) FRAUDAR outperforms competitors in multiple settings. Accuracy of fraud detection on Amazon data in the experiment with "reverse camouflage" (edges from honest users to fraudulent products). (b) FRAUDAR has similar and high accuracy both in detecting fraudulent users and fraudulent customers. Comparison of accuracy on fake users and targets under four different camouflage attacks.</figDesc><graphic coords="8,305.98,57.37,191.28,138.04" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: FRAUDAR detects a large, clearly fraudulent block in Twitter. A majority of the detected accounts were either deleted, suspended, or contained known follower-buying services, TweepMe and TweeterGetter. In comparison, the control groups had much less detected fraud.</figDesc><graphic coords="9,72.93,53.79,200.84,164.25" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Follower-buying services: a large fraction of detected accounts use TweepMe (bottom) or TweeterGetter (middle, top).</figDesc><graphic coords="9,98.03,293.43,150.64,120.87" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: FRAUDAR runs in near-linear time: the curve (blue) shows the running time of FRAUDAR, compared to a linear function (black).</figDesc><graphic coords="9,370.61,53.80,131.50,99.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>APPENDIX A. PROOF OF THEOREM 1 PROOF. Axiom 1 (</head><label>11</label><figDesc>Node Suspiciousness) g(S) = fV (S) + fE (S) |S| &gt; fV (S ) + fE (S ) |S| = fV (S ) + fE (S ) |S | = g(S ). Axiom 2 (Edge Suspiciousness) Let e = (u, v). g(S(V, E ∪ {e})) = fV (S) + fE (S) + cuv |S| &gt; fV (S) + fE (S) |S| = g(S(V, E)). Axiom 3 (Size) Let S = A ∪ B, and ρ be the edge density. g(S) = fV (S) + fE (S) in both |A| and |B|. Axiom 4 (Concentration) g(S) = f (S) |S| &gt; f (S) |S | = f (S ) |S | = g(S ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Comparison between FRAUDAR and other fraud detection algorithms.</figDesc><table><row><cell>COPYCATCH</cell><cell>CatchSync</cell><cell>BP-based methods</cell><cell>SPOKEN</cell><cell>FBOX</cell><cell>GETTHESCOOP</cell><cell>FRAUDAR</cell></row><row><cell>Detects dense blocks</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Camouflage-resistant</cell><cell>?</cell><cell></cell><cell></cell><cell>?</cell><cell></cell><cell></cell></row><row><cell>Theoretical guarantees</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Symbols and Definitions</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This material is based upon work supported by the National Science Foundation under Grant No. CNS-1314632, DGE-1252522, and IIS-1408924.</p><p>Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation, or other funding parties.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Opinion fraud detection in online reviews by network effects</title>
		<author>
			<persName><forename type="first">L</forename><surname>Akoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICWSM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Copycatch: stopping group attacks by spotting lockstep behavior in social networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Beutel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Guruswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Palow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd WWW</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="119" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Aiding the detection of fake accounts in large scale social online services</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sirivianos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pregueiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Greedy approximation algorithms for finding dense components in a graph</title>
		<author>
			<persName><forename type="first">M</forename><surname>Charikar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Approximation Algorithms for Combinatorial Optimization</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="84" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Cortes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pregibon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Volinsky</surname></persName>
		</author>
		<title level="m">Communities of interest</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Understanding and combating link farming in the twitter social network</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Viswanath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kooti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Korlam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Benevenuto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ganguly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Gummadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st WWW</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="61" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Evaluating cooperation in communities with the k-core structure</title>
		<author>
			<persName><forename type="first">C</forename><surname>Giatsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Thilikos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vazirgiannis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Social Networks Analysis and Mining (ASONAM), 2011 International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="87" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Leaps: Detecting camouflaged attacks with statistical learning guided by program analysis</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Combating web spam with trustrank</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Gyöngyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB Endowment</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="576" to="587" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A general suspiciousness metric for dense blocks in multimodal data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Beutel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Mining (ICDM), 2015 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="781" to="786" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Catchsync: catching synchronized behavior in large directed graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Beutel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">20th KDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="941" to="950" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Inferring strange behavior from connectivity pattern in social networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Beutel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Knowledge Discovery and Data Mining</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="126" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Opinion spam and analysis</title>
		<author>
			<persName><forename type="first">N</forename><surname>Jindal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM 2008</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="219" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">METIS: Unstructured graph partitioning and sparse matrix ordering system</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The University of Minnesota</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Authoritative sources in a hyperlinked environment</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="604" to="632" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">What is twitter, a social network or a news media? In 19th WWW</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="591" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Signed networks in social media</title>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Huttenlocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kleinberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</title>
		<meeting>the SIGCHI Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1361" to="1370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Hidden factors and hidden topics: understanding rating dimensions with review text</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mcauley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM conference on Recommender systems</title>
		<meeting>the 7th ACM conference on Recommender systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="165" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Iolaus: Securing online content rating systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Molavi Kakhki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kliman-Silver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mislove</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd WWW</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="919" to="930" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Finding deceptive opinion spam by any stretch of the imagination</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cardie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Hancock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="309" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Netprobe: a fast and scalable system for fraud detection in online auction networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Pandit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Chau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th WWW</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="201" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Focused clustering and outlier detection in large attributed graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Perozzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Akoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Iglesias</forename><surname>Sánchez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">20th KDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1346" to="1355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Eigenspokes: Surprising patterns and community structure in large graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sridharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Machiraju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PAKDD</title>
		<imprint>
			<date type="published" when="2010">2010a, 84, 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Mining of massive datasets</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Cambridge University Press</publisher>
			<biblScope unit="volume">1</biblScope>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Beutel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gallagher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1410.3915</idno>
		<title level="m">Spotting suspicious link behavior with fbox: An adversarial perspective</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Sybil-resilient online content voting</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="15" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The k-clique densest subgraph problem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Tsourakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th WWW</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1122" to="1132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Camouflaged fraud detection in domains with complex relationships</title>
		<author>
			<persName><forename type="first">S</forename><surname>Virdhagriswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dakin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th KDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="941" to="947" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Latent aspect rating analysis without aspect keyword supervision</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th KDD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="618" to="626" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Propagating trust and distrust to demote web spam</title>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Davison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MTW</title>
		<imprint>
			<biblScope unit="volume">190</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Sybillimit: A near-optimal social network defense against sybil attacks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SP 2008. IEEE Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="3" to="17" />
		</imprint>
	</monogr>
	<note>Security and Privacy</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Sybilguard: defending against sybil attacks via social networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Flaxman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="267" to="278" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
