<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Annotations in Data Streams</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2009-04-29">April 29, 2009</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Amit</forename><surname>Chakrabarti</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dartmouth College</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Graham</forename><surname>Cormode</surname></persName>
							<email>graham@research.att.com</email>
							<affiliation key="aff1">
								<orgName type="laboratory">AT&amp;T Labs-Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrew</forename><surname>Mcgregor</surname></persName>
							<email>mcgregor@cs.umass.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Annotations in Data Streams</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2009-04-29">April 29, 2009</date>
						</imprint>
					</monogr>
					<idno type="MD5">D5E26C0C834F94A9BDC43C4FE5F9CFCD</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The central goal of data stream algorithms is to process massive streams of data using sublinear storage space. Motivated by work in the database community on outsourcing database and data stream processing, we ask whether the space usage of such algorithms be further reduced by enlisting a more powerful "helper" who can annotate the stream as it is read. We do not wish to blindly trust the helper, so we require that the algorithm be convinced of having computed a correct answer. We show upper bounds that achieve a non-trivial tradeoff between the amount of annotation used and the space required to verify it. We also prove lower bounds on such tradeoffs, often nearly matching the upper bounds, via notions related to Merlin-Arthur communication complexity. Our results cover the classic data stream problems of selection, frequency moments, and fundamental graph problems such as triangle-freeness and connectivity. Our work is also part of a growing trend -including recent studies of multi-pass streaming, read/write streams and randomly ordered streams -of asking more complexity-theoretic questions about data stream processing. It is a recognition that, in addition to practical relevance, the data stream model raises many interesting theoretical questions in its own right.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The data stream model has become a popular abstraction when designing algorithms that process network traffic and massive data sets <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b20">21]</ref>. The computational restrictions that define this model are severe: algorithms must use a relatively small amount of working memory and process input in whatever order it arrives. This captures constraints in high-throughput data processing settings. For example, network monitoring often requires (near) real-time response to anomalies and hence traffic must be processed as it arrives, rather than being stored and processed offline. For massive data sets stored in external memory, being able to process the data in any order avoids the I/O bottlenecks that arise with algorithms that assume random access. Unfortunately, while some problems admit efficient streaming algorithms, many others provably require a lot of working memory or multiple passes over the data, which is typically not feasible.</p><p>This paper considers the potential for off-loading stream computation to a more powerful "helper" so that single pass, small-space stream computation is possible even for such "hard" functions. The additional power of the helper can arise in a variety of situations, e.g., multiple processing units, special purpose hardware, or a third party who provide a commercial stream processing service. This last case has recently garnered attention in the context of outsourcing database processing <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b33">34]</ref>. A key issue is that we do not want to blindly trust the helper: hardware faults or outright deception by a third-party would lead to incorrect results. So our protocols must have sufficient information contained in the help to allow the "verifier" to be convinced that they have obtained the correct answer. We think of this help as annotations augmenting the original stream. Our goal is to design protocols so that the verifier finds the correct answer with an honest helper, and is likely not fooled by a dishonest helper. The primary metrics are the amount of annotations provided by the helper and the amount of working space used by the verifier.</p><p>Our approach is naturally related to Interactive Proofs and Merlin-Arthur communication protocols <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b24">25]</ref> but differs in two important regards. Firstly, the verifier must process both the original data and the advice provided by the helper under the usual restrictions of the data stream model. Secondly, we focus on annotations that can be provided online. Note that in Merlin-Arthur communication, it is assumed that the helper is omniscient and that the advice he provides can take into account data held by any of the players. In the stream model, this would correspond to prescience where the annotation in the stream at position t may depend on data that is yet to arrive. In contrast we are primarily interested in designing algorithms with online annotation, i.e., annotation that only depends on data that has arrived before the annotation is written. This corresponds to a helper who sees the data concurrently with the verifier.</p><p>Our Contributions: We first formally define the relevant models: traditional and online Merlin-Arthur communication, and streaming models with either prescient or online annotations. We then investigate the complexity of a range of problems in these models, including selection, frequency moments, and graph problems such as triangle-counting and connectivity. Estimating frequency moments in particular has become a canonical problem when exploring variants of the data stream model such as random order streams <ref type="bibr" target="#b9">[10]</ref> and read/write streams <ref type="bibr" target="#b6">[7]</ref>. Our results include:</p><p>• Selection. The problem of finding the median of m values in the range [n] highlights the difference between prescient and online annotation. For any h, v such that hv ≥ m we present an O(v log m)space algorithm that uses O(h log m log n) bits of online annotation. Furthermore, we show that this trade-off is optimal up to polylogarithmic factors. In contrast, a trivial O(log mn) space algorithm can verify O(log n) bits of prescient annotation.</p><p>• Frequency Moments and Frequent Items. We next consider properties of { f i } i∈ <ref type="bibr">[n]</ref> where f i is the frequency of the token "i". For any h, v such that hv ≥ n, we present an O(h log m)-space algorithm that uses (φ -1 v log m) bits of online annotation and returns exactly the tokens whose frequency exceeds φ m. We also show an O(log m) space algorithm that uses O(ε -1 log 2 m) bits of online annotation and returns a set of tokens containing {i : f i ≥ φ m} and no elements from {i : f i ≤ (φε)m}. This algorithm relies on a powerful way that annotation can be used in conjunction with sketch-based algorithms. For any h, v such that hv ≥ n, we present an O(kv log m)-space algorithm that uses O(k 2 h log m) bits of online annotation and computes</p><formula xml:id="formula_0">F k = ∑ i f k i exactly (k ∈ Z + ).</formula><p>The trade-off is optimal up to polylogarithmic factors even if the algorithm is allowed to use prescient annotation. To prove this we present the first Merlin-Arthur communication bounds for multi-party set-disjointness.</p><p>• Graph Problems. For graphs defined by streams of m edges on n nodes, we show that only O(log n) space is needed by the verifier to determine whether a graph is connected, contains a perfect matching, or is triangle-free, with annotation proportional to the input size. We show that our algorithms are optimal in many cases. For any h, v such that hv ≥ n 3 , we also present an Õ(v) space algorithm for counting triangles that uses Õ(h) bits of annotation where Õ hides poly-logarithmic factors.</p><p>Related Work: When multiple passes over the input are allowed, it is natural to consider annotations that can be written to the "input tape" and are available to the stream algorithm in subsequent passes <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>The read/write stream model, which provides both multiple passes and multiple working tapes, can be viewed as a natural extension of the multi-pass annotation model <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b19">20]</ref>. However, such annotations are of no use if only a single pass over the input is allowed. Few examples of prior work have explicitly considered annotations that are provided by an (untrusted) third party. Gertner et al. <ref type="bibr" target="#b18">[19]</ref> showed that the set of languages recognized by a verifier with logarithmic space given annotation polynomial in the input size is exactly NP. In contrast, our focus is on the case where the annotation is (sub)linear in the input size and can be provided online; the distinction between prescient and online annotation was not relevant in their results because with polynomial annotation, the entire input could be repeated. Feigenbaum et al. <ref type="bibr" target="#b16">[17]</ref> observe that a logarithmic space verifier can check a linear space annotation for the disjointness problem. In communication complexity, the role of non-deterministic advice has been studied more extensively, see e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b25">26]</ref>. Recent works of Aaronson and Widgerson <ref type="bibr" target="#b0">[1]</ref> and Klauck <ref type="bibr" target="#b24">[25]</ref> are particularly relevant. They resolve the MA complexity of two-party set disjointness -we extend some of their techniques to our streaming model.</p><p>There has also been more applied work which implicitly defines annotation protocols. The notion of stream punctuations are, in our terminology, simple prescient annotations, indicating facts such as that there are no more tuples relevant to timestamp t in the remainder of the stream <ref type="bibr" target="#b32">[33]</ref>. Work on stream outsourcing studies the problem of verifying that a claimed "grouping" corresponds to the input data <ref type="bibr" target="#b33">[34]</ref>. They solve exact and approximate versions of the problem by using a linear amount of annotation. Lastly, work on proof infused streams answers various selection and aggregation queries over sliding windows <ref type="bibr" target="#b26">[27]</ref> with logarithmic space and linear annotation. However, a critical difference is that this work requires that the helper and verifier agree on a one-way hash function, for which it is assumed the helper cannot find collisions. Our results are in a stronger model without this assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Models and Definitions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Communication Models</head><p>Let f : X 1 × • • • × X t → {0, 1} be a function, where each X i is a finite set. This naturally gives a t-player number-in-hand communication problem, where Player i holds an input x i ∈ X i and the players wish to output f (x 1 , . . . , x t ) correctly, with high probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MA Communication:</head><p>We first consider a variant of this communication model. A Merlin-Arthur protocol (henceforth, "MA protocol") for f is one that involves the usual t players, plus a "super-player," called Merlin, who knows the entire input x = (x 1 , . . . , x t ). The protocol works as follows: first Merlin deterministically writes a help message h on the blackboard, and then Players 1 through t run a randomized protocol P, using a public random string R, eventually outputting a bit out(P; x, R, h). To clarify, R is not known to Merlin at the time he writes h. An MA protocol is δ -error if there exists a function h : X 1 × . . . × X t → {0, 1} * , such that:</p><formula xml:id="formula_1">1. If f (x) = 1 then Pr R [out(P; x, R, h(x)) = 0] ≤ δ . 2. If f (x) = 0 then ∀ h Pr R [out(P; x, R, h ) = 1] ≤ δ .</formula><p>We define err(P) to be the minimum δ such that the above conditions are satisfied. We also define the help cost hcost(P) to be the maximum length of h, over all x, and the verification cost vcost(P) to be the maximum number of bits communicated by Players 1 through t over all x and R. Finally, we define the cost of P to be cost(P) = hcost(P) + vcost(P). We then define the δ -error MA-complexity of f as MA δ ( f ) = min{cost(P) : P is an MA protocol for f with err(P) ≤ δ } . Further, we define MA( f ) = MA 1/3 ( f ).</p><p>Online-MA Communication: We also consider a variant of the above model, specific to one-way protocols (i.e., protocols where the players speak once each, in increasing order), where Merlin constructs t help messages h 1 , . . . , h t so that the ith message is only a function of the first i inputs. To make this precise we need to amend the definition of δ -error: An online-MA protocol is δ -error if there exists a family of functions h i : X 1 × . . . × X i → {0, 1} * , such that:</p><formula xml:id="formula_2">1. If f (x) = 1 then Pr R [out(P; x, R, h 1 (x 1 ), h 2 (x 1 , x 2 ), . . . , h t (x 1 , . . . , x t )) = 0] ≤ δ . 2. If f (x) = 0 then ∀ h = (h 1 , h 2 , . . . , h t ) Pr R [out(P; x, R, h ) = 1] ≤ δ .</formula><p>The message h i is revealed privately to the ith player. We define the help cost, hcost(P), to be the maximum length of ∑ i∈[t] |h i |. We define err(P), vcost(P), and cost(P) as for MA. Define MA → δ ( f ) = min{cost(P) : P is an online MA protocol for f with err(P) ≤ δ } and write MA → ( f</p><formula xml:id="formula_3">) = MA → 1/3 ( f ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data Stream Models</head><p>The annotated data-stream models are most conveniently defined relative to the above communication models. Again we consider the computation of a function f on a t-tuple x ∈ U t for some universe U , e.g., {0, 1} or [n]. The main difference from the communication model is that we further insist that the message sent by player i must be computed with limited memory and only sequential access to x i and h i . Without advice, this is equivalent to the usual definition of the single-pass data stream model. We will also consider non-Boolean functions f and a notion of approximation: we say f is computed correctly if the answer returned is in some pre-defined set C( f (x)), e.g., {a</p><formula xml:id="formula_4">: |a -f (x)| ≤ ε f (x)}.</formula><p>Stream Model with Prescient Annotations: In the context of the stream model we consider the help h provided by Merlin to be decomposed into t (deterministic) functions that map the input to binary help strings:</p><formula xml:id="formula_5">h 1 : U t → {0, 1} * , . . . , h t : U t → {0, 1} * . Let h(x) := (h 1 (x), . . . , h t (x)).</formula><p>We then consider a randomized protocol, A , with oracle access to a random string R, where Player i computes a message of size at most w given only w bits of working memory and only sequential access to the bit stream x i , h i (x) . The output of this protocol is allowed to include the special symbol ⊥ if the verifier is not convinced of the validity of the annotation. Such a protocol is said be δ</p><formula xml:id="formula_6">-error if Pr R [out(A ; x, R, h) ∈ C( f (x))] ≤ δ and Pr R [out(A ; x, R, h ) = ⊥] ≤ δ for any h = (h 1 , h 2 , . . . , h t ) = h(x).</formula><p>We define err(A ) to be the minimum δ such that the above conditions are satisfied. We define the help cost hcost(A ) to be the maximum length of ∑ i |h i |, over all x, and the verification cost vcost(A ) = w. We say that A and h forms an</p><formula xml:id="formula_7">(h, v) prescient scheme if hcost(A ) = O(h + 1), vcost(A ) = O(v + 1) and err(A ) &lt; 1/3.</formula><p>Stream Model with Online Annotations: For online annotations we insist that the ith help function is only a function of (x 1 , . . . , x i ). The other definitions are as above. We say that A and h form an (h, v) online scheme as above if hcost(A ) = O(h + 1), vcost(A ) = O(v + 1) and err(A ) &lt; 1/3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Preliminary Lemmas</head><p>In multiple places we make use of basic fingerprinting techniques which enable a verifier to test whether two large streams represent the same object using small space. Let Z + denote the set of non-negative integers, and let F q denote the finite field with q elements (whenever it exists). Let A = a 1 , . . . , a m denote a data stream, with each</p><formula xml:id="formula_8">a i ∈ [n]. Then A implicitly defines a frequency distribution f(A) := ( f 1 , . . . , f n ), where f j = |{i ∈ [m] : a i = j}|.</formula><p>Fingerprints are formed by computations over F q , as BF q (r, f) := ∏ n j=1 (rj) f j . To make fingerprints, we choose q based on an a priori bound m on f 1 .</p><p>Lemma 2.1. Let q ≥ m be a prime, and choose r uniformly at random from F q . Given an input stream A of length m, the fingerprint BF q (r, f(A)) can be computed using O(log q) storage. Suppose f ∈ Z n + is a vector with f = f(A) and f 1 ≤ m. Then the "collision probability"</p><formula xml:id="formula_9">Pr r∈ R F q [BF q (r, f ) = BF q (r, f(A))] ≤ m/q.</formula><p>Proof. To compute the fingerprint in streaming fashion, express BF q (r,</p><formula xml:id="formula_10">f(A)) = ∏ m i=1 (r -a i ).</formula><p>The bound on the collision probability follows from the fact that for any f ∈ Z n + , the polynomial BF q (X, f) ∈ F q [X] has degree at most f 1 .</p><p>This fingerprint implies a prescient protocol for a multi-set inclusion problem: Lemma 2.2. Let A ⊂ U be a set of size n and let B ⊂ U be multi-set of size t. Let B be the set formed by removing all duplicate elements from B. Then, given a stream which begins with the elements of A followed by the elements of B, there is a (t logt, logt) prescient scheme that establishes whether B = A.</p><p>Proof. Note that we may assume that t ≥ n otherwise A = B and this is easy to certify. The helper annotates each a ∈ A with the multiplicity, f a , of a in B. This allows the verifier to incrementally construct a fingerprint of the set {(a, i) : a ∈ A, i ∈ [ f a ]}. The prover annotates the jth occurrence of b ∈ B with j, which allows the verifier to incrementally construct a fingerprint of the set {(a, i) : a ∈ B , i ∈ [ f a ]}. The verifier accepts if the two fingerprints match.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Warm-Up: Index and Selection</head><p>In this section, we present an online scheme for the SELECTION problem: Given desired rank ρ ∈ [m], output an item a k from the stream A = a 1 , . . . , a m ∈ [n] m , such that |{i : a i &lt; a k }| &lt; ρ and |{i : a i &gt; a k }| ≤ mρ. We assume m = Θ(n) to simplify the statement of bounds. An easy (log m, log m) prescient scheme is for the helper to give an answer s as annotation at the start of the stream. The verifier need only count how many items in the stream are (a) smaller than s and (b) greater than s. The verifier returns s if the rank of s satisfies the necessary conditions. Next, we present (almost) matching upper and lower bounds when only online annotation is allowed.</p><p>To do this, we first consider the online MA complexity of the communication problem of INDEX: Alice holds a string x ∈ {0, 1} N , Bob holds an integer i ∈ [N], and the goal is for Bob to output INDEX(x, i) := x i . The lower bound for SELECTION will follow from the lower bound for INDEX and a key idea for the SELECTION upper bound follows from the communication protocol for INDEX. </p><formula xml:id="formula_11">INDEX must have hcost(Q) vcost(Q) = Ω(N). So, in particular, MA → (INDEX) = Θ( √ N).</formula><p>Proof. For the lower bound, we use the given online MA protocol Q to build a randomized one-way INDEX protocol Q . Let h = hcost(Q). Let B(n, p) denote the binomial distribution with parameters n and p, and let k be the smallest integer such that</p><formula xml:id="formula_12">X ∼ B(k, 1/3) ⇒ Pr[X &gt; k/2] ≤ 2 -h /3. A standard tail estimate gives k = Θ(h).</formula><p>Let a(x, R) denote the message that Alice sends in Q when her random string is R, and let b(a, i, h) be the bit Bob outputs upon receiving message a from Alice and h from Merlin. In the protocol Q , Alice chooses k independent random strings R 1 , . . . , R k and sends Bob a(x, R 1 ), . . . , a(x, R k ). Bob then outputs 1 iff there exists a h-bit string h such that MAJORITY (b(a</p><formula xml:id="formula_13">(x, R 1 ), i, h), . . . , b(a(x, R k ), i, h)) = 1. Clearly, cost(Q ) ≤ k •vcost(Q) = O(hcost(Q) vcost(Q)).</formula><p>We claim that Q is a 1 3 -error protocol for INDEX whence, by a standard lower bound (see, e.g., Ablayev <ref type="bibr" target="#b1">[2]</ref>), cost(Q ) = Ω(N).</p><p>To prove the claim, consider the case when x i = 1. By the correctness of Q there exists a suitable help message h from Merlin that causes Pr[b(a(x, R), i, h) = 0] ≤ 1/3. Thus, by construction and our choice of k, the probability that Bob outputs 0 in Q is at most 2 -h /3. Now suppose x i = 0. Then, every possible message h from Merlin satisfies Pr[b(a(x, R), i, h) = 1] ≤ 1/3. Arguing as before, and using a union bound over all 2 h possible messages h, we see that Bob outputs 1 with probability at most 2 h • 2 -h /3 = 1 3 . The upper bound follows as a special case of the two-party set-disjointness protocol in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">Theorem. 7.4]</ref> since the protocol there is actually online. We give a more direct protocol which establishes intuition for our SELECTION result. Write Alice's input string x as x = y (1) • • • y (v) , where each y ( j) is a string of at most h bits, and fix a prime q with 3h &lt; q &lt; 6h. Let y (k) be the substring that contains the desired bit x i . Merlin sends Bob a string z of length at most h, claiming that it equals y (k) . Alice picks a random r ∈ F q and sends Bob r and the strings BF q (r, y (1) ), . . . , BF q (r, y (v) ), thus communicating O(v log q) = O(v log h) bits. Bob checks if BF q (r, z) = BF q (r, y (k) ), outputting 0 if not. If the check passes, Bob assumes that z = y (k) , and outputs x i from z under this assumption. By Lemma 2.1, the error probability is at most h/q &lt; 1/3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark.</head><p>The above lower bound argument in fact shows that an online MA protocol P for an arbitrary two-party communication problem f satisfies hcost(P) vcost(P) = Ω(R → ( f )). Thus, MA → ( f ) = Ω( R → ( f )) where R → ( f ) is the one-way, randomized communication complexity of f . Theorem 3.2. For any h, v s.t. hv ≥ m there is a (h log m, v log m) online scheme for SELECTION and any (h, v) online scheme for SELECTION must have hv = Ω(m).</p><p>Proof. Conceptually, the verifier builds a vector r = (r 1 , . . . , r n ) ∈ Z n + where r k = |{ j ∈ [m] : a j &lt; k}|. This is done by inducing a new stream A from the input stream A: each token a j in A causes virtual tokens a j + 1, a j + 2, . . . , n to be inserted into A . Then r = f(A ); note that r 1 = O(m 2 ). As in the INDEX protocol, the vector r is arranged into v subvectors of dimension h, and the verifier retains only fingerprints -based on a prime q = O(m 2 ) -on each subvector. After the stream is seen, the helper claims that the answer is s, by providing the values of r i for all i in the subvector containing s. The verifier fingerprints the provided block, and outputs s if it agrees with their stored fingerprint, otherwise it returns ⊥.</p><p>For the lower bound, we use a standard reduction from the INDEX problem: Given string x, we form the stream over [2n] by placing a j = 2 jx j in the stream for each j. Further, given the integer index i, we place i copies of 2n and mi copies of 1. Consequently, the median of this length 2m stream is 2ix i , from which the value of x i can be recovered. To complete the proof, observe that any streaming scheme to solve this problem would imply a communication protocol with the same cost; and that all players can perform this reduction online without extra space or annotation.</p><p>Notice that in the above scheme the information computed by the verifier is independent of ρ, the rank of the desired element. Therefore these algorithms work even when ρ is revealed at the end of the stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Frequency Moments and Frequent Items</head><p>In this section we consider properties of f = { f i : i ∈ [n]} where f i is the frequency of the token "i" in the stream. In particular, the kth frequency moment is defined as F k = ∑ i∈[n] f k i and the frequent items are defined as the set {i : f i &gt; T }, for some threshold T . Both problems have a long history in the data streams literature. It is well known that in the traditional data stream model, exact computation of F k (k = 1) requires Ω(n) space. Even constant factor approximation requires Ω(n 1-2/k ) space <ref type="bibr" target="#b10">[11]</ref>.</p><p>Frequent Items. We prove results on finding exact and approximate frequent items.</p><p>A prescient helper can list the set of claimed frequent items, along with their frequencies, for the verifier to check against the stream. But we must also ensure that the helper is not able to omit any items that exceed the threshold. Our result shows a compact witness set for the exact case, which leads to online schemes for the exact and approximate versions of the problem. Theorem 4.1. There exists a (φ -1 log 2 m, φ -1 log 2 m) prescient scheme and a (φ -1 n α log m, n 1-α log m) online scheme (α ∈ [0, 1]) for finding {i : f i &gt; T := φ m}. Any (h, v) online scheme for this must have hv = Ω(n).</p><p>Proof. For the upper bound consider a binary tree whose leaves are the elements of the universe [n]. Associate each node v with the set of elements at the leaves of the the subtree rooted at v. Call this set S(v) where S(u) = {i} if u is the ith leaf. Let g(v) = ∑ i∈S(v) f i . Note that if u is a node and v is any ancestor of u, then g(u) ≤ g(v). Now observe that there is a witness set of size O(φ -1 log n) to identify all leaves i with f i &gt; T : this consists of the set W of all such is in addition to pairs of nodes (u, v) such that u is the child of v, and g(u) ≤ T but g(v) &gt; T . Here, each pair (u, v) ∈ W is witness to the fact that no leaves i ∈ S(u) can have f i &gt; T . The sets S(u) for such u together with {i : f i &gt; T } form a partition of [n]. Further, there can be at most φ -1 such nodes v at any level of the binary tree, as the sum of g(v) is at most m. This bounds the size of this witness set to |W | = O(φ -1 log n). This leads to two schemes for the problem. In the first,prescient scheme, the helper lists the members of W and their corresponding frequencies. The verifier remembers this information, and ensures that it agrees with the frequencies in the stream. Assuming m = Ω(n) gives hcost = vcost = φ -1 log 2 m. In the second, online scheme, the 2n -1 nodes in the tree are divided into v groups of h such that hv ≥ 2n. The verifier keeps a fingerprint of the frequency vector of each group. After the stream is seen, the helper provides the witness set W , sorted by the natural order on nodes, plus the frequency vector of all groups containing items named in W . This totals min{O(|W |h), n} items, yielding a (min{n log m, hφ -1 log m}, v log m) online scheme. A subtlety here is that the output size can exceed the verifier's memory, so the verifier may output a partial result before returning ⊥.</p><p>The lower bound follows from the hardness of INDEX: a string x of length n (assume n is odd) induces a stream A, by placing a j = 2 jx j in the stream for each j. Then, given index i, we place n -1 copies of 2i in the stream. Observe that if x i = 0 then f 2i &gt; m/2, else f 2i &lt; m/2. Thus, determining the frequent items for T = 1 2 m solves INDEX, proving the bound.</p><p>In many cases, it suffices to find a set of approximate frequent items: these include all items with f i &gt; φ m and no items with f i &lt; (φε)m for parameters ε, φ . Solutions to this problem in the traditional streaming model are often based on "sketch" algorithms. We define an integer linear sketch broadly as any summary v which can be computed as v = Sf(A) for a "sketch matrix" S with integral entries. Such sketches include instantiations of the Johnson-Lindenstrauss transform <ref type="bibr" target="#b21">[22]</ref>, Count-Sketch <ref type="bibr" target="#b11">[12]</ref>, and Count-Min <ref type="bibr" target="#b12">[13]</ref>. Each stream token i increments v by Se i , where e i is the vector that is 1 in location i and 0 elsewhere. The sketch can be fingerprinted: each update multiplies the fingerprint by BF q (r, Se i ). This observation means that the helper can annotate (parts of) v at the end of the stream, for verification. However, to define an efficient scheme, we also need to show: (1) the verifier can compute Se i in small space, so S must have a compact representation; and (2) the verifier must be able to extract the result from v in a streaming fashion, in space sublinear in the size of the sketch.</p><p>We use ideas from verifying exact frequent items to build a scheme for verifying approximate frequent items via sketching. Count-Sketch <ref type="bibr" target="#b11">[12]</ref> defines a "basic" sketch of length w via two pairwise independent hash functions b : [n] → [w], and c : [n] → {-1, +1}. The sketch vector v is defined by v , j = ∑ i:b (i)= j f i c (i), and the basic estimate of the frequency of i is fi, = c (i)v ,b (i) . This satisfies | fi,f i | = O((F 2 /w) 1/2 ) with constant probability; to reduce the error probability, the median of the basic estimates from d basic sketches with different hash functions is taken, fi = median 1≤ ≤d fi, . Count-Min is essentially Count-Sketch with c (i) := 1 for all . It promises | fi, -</p><formula xml:id="formula_14">f i | = O(F 1 /w) [13].</formula><p>Theorem 4.2. There exists an (s log n log m, log m) online scheme to verify the approximate frequent items found by Count-Sketch or Count-Min sketches of size s.</p><p>Proof. Given a threshold T , the set of approximate frequent items are {i : fi &gt; T }. To ensure that no items are omitted, we use the witness-tree approach from Theorem 4.1, and consider an expanded set of items that include the set of tree nodes v and their corresponding frequencies f (v): the annotator and verifier now keep a sketch v k for each level k of the tree. Although the analysis in Theorem 4.1 is stated in terms of exact frequencies the same argument goes through when we have fi = f i ± εm. In particular, when using sketches with d = O(log n), this holds for each i with probability at least 1 -1/16n, and so it holds over all 2n frequencies with probability at least 7/8. So with this large constant probability and ε &lt; 1/2, there is a valid witness set W of O(log n/φ ) tree nodes.</p><p>The verifier can validate this witness set W using the method in Theorem 4.1 over the full set of nodes and their estimated frequencies. By presenting the set of nodes v in W in order of min S(v), the verifier can ensure that the nodes identified do form a partition of [n] as required (and hence that no high frequency items are omitted). If the helper provides for each node v ∈ W the information (v, fv , fv,1 , . . . fv,d ) the verifier can check that fv is above or below T as appropriate. The verifier ensures that fv is derived correctly from the d values of fv, (using O(d) working space). The verifier also incrementally builds a fingerprint of the set B = {(v, , fv, )}. At the end of the annotation, the helper lists the entries of each sketch v k , j in order and tags each entry with the set of v's for which it has been used to make an estimate. The verifier builds a fingerprint of the tuples</p><formula xml:id="formula_15">(v, , c (v)v k ,b (v) )</formula><p>, and checks that it matches the fingerprint of B (this is essentially an instance of the multiset equality protocol in Lemma 2.2). The verifier fingerprints also the (untagged) sketch to check it matches the verifier's fingerprinted sketch built from the input stream.</p><p>The total amount of annotation is O(s log n) sketch entries, from the log n sketches of size s. The verifier needs to remember d estimated frequencies (to verify their median) and O(log n) fingerprinted sketches (one for each level). We mention that if φ ε, then the verifier only needs to inspect a small fraction of the sketch entries to verify the frequent items. In this case, one can obtain a tradeoff: write the sketch as an array of h × v entries, so that hv ≥ s. The verifier can create v fingerprints each summarizing h entries of the sketch. To verify, the helper modifies the above algorithm to only present those blocks of h entries which include a value that needs to be seen by the verifier. In total, to verify O(|W |) approximate frequencies requires verifying O(φ -1 d log n) entries, giving an (φ -1 h log m log 2 n, v log m) online scheme.</p><p>Other algorithms find all items i such that fi ≥ φ F 1/2 2 .These can also be adapted to our setting using similar ideas, and verified in logarithmic space with annotation proportional to the sketch size.</p><p>Frequency Moments. We now show a family of algorithms that exhibit an optimal verification/annotation trade-off for the exact computation of F k . Our algorithm is inspired by the "algebrization" results of Aaronson and Wigderson <ref type="bibr" target="#b0">[1]</ref> but the key idea can be traced back to classic interactive proof protocols of Lund et al. <ref type="bibr" target="#b27">[28]</ref> and Shamir <ref type="bibr" target="#b30">[31]</ref>.</p><p>Theorem 4.3. Suppose h and v are positive integers with hv ≥ n. Then, for integers k ≥ 1, there exists a (k 2 h log m, kv log m) online scheme for computing F k exactly.</p><p>Proof. Let A be the input stream. We map the length n vector f(A) into an h × v matrix ( f (x, y)) x∈[h],y∈[v] , using any canonical bijection between [n] and [h] × [v]. Pick a prime q ≥ max{m k , 3kh}; since m ≥ n, this can be done while ensuring that log q = O(k log m). We shall work in the field F q , which is safe because q exceeds the maximum possible value of</p><formula xml:id="formula_16">F k (A). Let f (X,Y ) ∈ F q [X,Y ] be the unique polynomial satisfying deg X ( f ) = h -1, deg Y ( f ) = v -1 and f (x, y) = f (x, y) for all (x, y) ∈ [h] × [v].</formula><p>The verifier picks a random r ∈ F q . As the stream is read, the verifier maintains a sketch consisting of the v quantities f (r, 1), . . . , f (r, v). Clearly, this sketch fits in O(v log q) bits of storage.</p><p>At the end of the stream, the annotator provides a polynomial s (X) ∈ F q [X] that is claimed to be equal to s(X) := ∑ y∈[v] f (X, y) k , which has degree at most k(h -1), thus using O(kh log q) bits of annotation. The verifier evaluates s (r) from the supplied annotation and computes s(r) = ∑ y∈[v] f (r, y) k from his sketch, checks that s (r) = s(r) and outputs ⊥ if not. If the check passes, the verifier outputs ∑ x∈[h] s (x) as the final answer. Clearly, this answer is correct if the annotation was honest. Further, the verifier is fooled only if s = s, but s (r) = s(r); the probability of this is at most k(h -1)/q ≤<ref type="foot" target="#foot_0">1</ref> 3 , by choice of q. It remains to show that the sketch can be computed incrementally in O(v log q) space. To maintain each f (r, y) for y ∈ Numerous problems such as computing Hamming distance and Inner Product, and approximating F 2 and F ∞ , can be solved using F k as a primitive or using related techniques.</p><formula xml:id="formula_17">[v], note that upon reading a new token i ∈ [n] that maps to (a, b) ∈ [h] × [v], the necessary up- date is of the form f (r, y) ← f (r, y) + p a,b (r, y) , where p a,b (X,Y ) = ∏ i∈[h]\{a} (X -i)(a -i) -1 • ∏ j∈[v]\{b} (Y - j)(b -j) -1 . Since</formula><p>1. F 2 can be approximated with factor 1 + ε from an integer linear sketch of size O(1/ε 2 ). In particular, if CS w (A) denotes a length-w Count-Sketch vector of the stream A, then F 2 (CS w (A)) estimates F 2 (A) with relative error ε = w -1/2 with constant probability <ref type="bibr" target="#b31">[32]</ref>. Thus, if we allow shared randomness between the verifier and the helper 1 so that they can agree on the sketch hash functions, the above F 2 scheme yields a (ε -2α log m, ε 2α-2 log m) online scheme for any α ∈ [0, 1].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Recall that</head><formula xml:id="formula_18">F ∞ = max i f i and note that F t ∞ ≤ F t ≤ nF t ∞ . Hence, if t = log n/ log(1 + ε), then (F t ) 1/t is at most a factor 1 + ε from F ∞ . This yields a (( 1 ε log n) 2 h log m, ( 1 ε log n)v log m</formula><p>) online scheme for approximating F ∞ for any h, v such that hv ≥ n. We next present lower bounds on the trade-off possible for computation of F k .</p><p>Theorem 4.4. Any (h, v) scheme that exactly computes F k requires hv = Ω(n) and any (h, v) scheme that approximates F k up to a constant factor requires hv = Ω(n 1-5/k ).</p><p>These bounds are based on bounds we prove on the MA complexity of DISJ n,t : {0, 1} nt → {0, 1}, the tparty communication problem defined as follows. The input is a t × n Boolean matrix, with Player i holding the ith row, for i ∈ [t]. The desired output is ∧ t i=1 ∨ n j=1 ¬x i j , i.e., 1 iff the subsets of [n] represented by the rows are disjoint. We call an input x = (x i j ) i∈[t], j∈ <ref type="bibr">[n]</ref> valid if every column of x has weight either 0 or 1 or t, and at most one column has weight t. Note that DISJ n,t is naturally related to frequency moments: for any valid input x, F k (S) ≥ t k if DISJ n,t (x) = 0 and F k (S) ≤ n if DISJ n,t (x) = 1 where S is the multi-set { j : x i j = 1}. The next theorem, a generalization of a result by Klauck <ref type="bibr" target="#b24">[25]</ref>, and reductions from DISJ n,2 or DISJ n,O(n 1/k ) establish the first and second parts of Theorem 4.4 respectively in a straightforward manner. The next theorem also resolves a question of Feigenbaum et al. <ref type="bibr" target="#b16">[17]</ref>.</p><p>Theorem 4.5. Let P be an ε-error MA protocol for DISJ n,t , where ε ≤ 1/3. Then hcost(P) • vcost(P) = Ω(n/t 4 ). In particular, MA(DISJ n,t ) = Ω(</p><formula xml:id="formula_19">√ n/t 2 ).</formula><p>Proof. A rectangle is defined as a subset of inputs of the form X 1 × • • • × X t , where each X i ⊆ {0, 1} n is a subset of all possible inputs for Player i. In deterministic communication protocols, the inverse image of any transcript of such a protocol must be a rectangle. Let A = DISJ -1 n,t (1) and B = DISJ -1 n,t (0). Lemma 4.6 (Alon-Matias-Szegedy <ref type="bibr" target="#b3">[4]</ref>, generalizing Razborov <ref type="bibr" target="#b29">[30]</ref>). There exists distribution µ over valid inputs with 1) µ(A) = µ(B) = 1/2 and 2) µ(T ∩ B) = (2e) -1 µ(T ∩ A) -t2 -n/2t 4 for each rectangle T .</p><p>Assume t = ω(n 1/4 ) since otherwise the bound is trivial. Put h = hcost(P) and v = vcost(P). An input x ∈ A is said to be covered by a message h from Merlin if Pr R [out(P; x, R, h) = 0] ≤ ε. By correctness, every such input must be covered, so there exists a help message h * that covers every input in a set G ⊆ A, with µ(G) ≥ 2 -h µ(A) = 2 -h-1 . Fix Merlin's message in P to h * and amplify the correctness of the resulting randomized Merlin-free protocol by repeating it O(h) times and taking the majority of the outputs. This gives us a randomized protocol P for DISJ n,t with communication cost c = O(hv) whose error, on every input in G ∪ B, is at most 2 -2h . Let µ denote the distribution µ conditioned on G ∪ B. Note that, by condition (1) of Lemma 4.6,</p><formula xml:id="formula_20">∀ x ∈ {0, 1} nt : either µ (x) = 0 or µ(x) ≤ µ (x) ≤ 2µ(x) .<label>(1)</label></formula><p>By fixing the random coins of P we can obtain a deterministic protocol Q, for DISJ n,t , such that err µ (Q) ≤ 2 -2h and cost(Q) = c. By the rectangle property, there exist disjoint rectangles T 1 , T 2 , . . . , T 2 c such that out(Q</p><formula xml:id="formula_21">; x) = 1 iff x ∈ 2 c i=1 T i . Therefore 2 c ∑ i=1 µ (T i ∩ B) ≤ 2 -2h<label>(2)</label></formula><p>and</p><formula xml:id="formula_22">µ A \ 2 c i=1 T i ≤ 2 -2h<label>(3)</label></formula><formula xml:id="formula_23">By (1), µ (A) = µ (G) ≥ µ(G) ≥ 2 -h-1 . Using (1)</formula><p>, and a rearrangement of (3):</p><formula xml:id="formula_24">2 c ∑ i=1 µ(T i ∩ A) ≥ 1 2 2 c ∑ i=1 µ (T i ∩ A) ≥ 1 2 µ (A) -2 -2h ≥ 2 -h-3 .</formula><p>Suppose c ≤ n/5t 4 and n is large enough. Applying condition (2) of Lemma 4.6 we get ∑ 2 c i=1 µ(T i ∩ B) ≥ 2 -h-3 /(2e) -2 c t2 -n/2t 4 ≥ 2 -h-6 . However, by ( <ref type="formula" target="#formula_20">1</ref>) and (2), we have ∑ 2 c i=1 µ(T i ∩ B) ≤ 2 -2h , a contradiction. Hence hv = Ω(c) = Ω(n/t 4 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Graph Problems</head><p>In this section we consider computing properties of graphs on n nodes, determined by a stream of m edges <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b20">21]</ref>. We present tight results for testing connectivity of sparse graphs, determining if a bipartite graph has a perfect matching, and counting triangles.</p><p>Triangles via Matrix Multiplication. Estimating the number of triangles in a graph has received significant attention because of its relevance to database query planning (knowing the degree of transitivity of a relation is useful when evaluating relational queries) and investigating structure properties of the webgraph <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b22">23]</ref>. In the absence of annotation, any single pass algorithm to determine if there is a non-zero number of triangles requires Ω(n 2 ) bits space <ref type="bibr" target="#b5">[6]</ref>. We show that the answer can be verified with O(n 2 ) annotation in logarithmic space. The following theorem, proved using ideas from <ref type="bibr" target="#b5">[6]</ref> coupled with Theorem 4.5, shows that this is best possible. Theorem 5.1. Any (h, v) scheme for counting triangles must have hv = Ω(n 2 ).</p><p>Proof. We show a reduction from an instance DISJ (n 2 /9),2 . We represent the instance as n/3 × n/3 matrices X,Y in the natural way. We proceed to construct a graph that has a triangle iff X i, j = Y i, j = 1 for some i, j ∈ [n/3]. The nodes are partitioned into sets U,V,W so that</p><formula xml:id="formula_25">|U| = |V | = |W | = n/3. Insert edges {(u i , w i ) : i ∈ [n/3]} ∪ {(u i , v j ) : X i, j = 1} ∪ {(w i , v j ) : Y i, j = 1}. There is a triangle (u i , v j , w i ) iff X i, j = Y i, j = 1,</formula><p>and there is no other way to form a triangle. The result follows from Theorem 4.5.</p><p>We now outline an online scheme with vcost = O(log n) and hcost = O(n 2 ). A major subroutine of our algorithm is the verification of matrix multiplication in our model. That is, given n × n matrices A, B and C, verify that AB = C. Our technique extends the classic result of Frievalds <ref type="bibr" target="#b17">[18]</ref> by showing that if the helper presents the results in an appropriate order, the verifier needs only O(log n) bits to check the claim. Note that this much annotation is necessary if the helper is to provide C in his stream.</p><p>Theorem 5.2. There exists a (n 2 , log n) online scheme for matrix multiplication.</p><p>Proof. By the result of Kimbrel and Sinha <ref type="bibr" target="#b23">[24]</ref>, the verifier can check AB = C by picking r uniformly from F q and checking that A(Br T ) = Cr T for vector r = (r 1 , . . . , r n ). This fails to distinguish different matrices with probability at most n/q. Rather than computing A(Br T ) and Cr T explicitly, the verifier will compare fingerprints of Cr T and ABr T . These are computed as sCr T and sABr T , for a vector s = (s 1 , . . . , s n ) where s is picked uniformly from F q . This also fails with probability at most n/q. We observe that (1) sCr T = ∑ i, j s i r j C i, j can be computed easily whatever order the entries of C are presented in. (2) sABr T = (sA)(Br T ) is the inner product of two n-dimensional vectors, and that (sA) i = ∑ j s j A i, j and (Br T ) i = ∑ j r j B j,i . Therefore, if the helper presents the ith column of A followed by the ith row of B for each i in turn, the verifier can easily compute sABr T , in O(log q) space. Picking q ≥ 6n ensures that the verifier is fooled with probability at most 1/3, and the total space used by the verifier to store r, s and intermediate values is O(log n).</p><p>With this primitive, arbitrary matrix products A , A -1 . . . A 2 A 1 are verified with O( n 2 ) annotation by verifying A 2,1 := A 2 A 1 , then A 3,2,1 := A 3 A 2,1 , etc. Matrix powers A are verified with O(n 2 log ) annotation.</p><p>Proof of Theorem 5.6. If the graph is connected then there exists a spanning tree T directed towards the root and an injective labeling of the nodes f : V → [|V |] such that each non-root node with label j is linked to exactly one node with label &gt; j. The helper outputs such a function f , and the verifier ensures that it is an injection. Then each (directed) edge (u, v) in T and its labels f (u) &gt; f (v) is presented in decreasing order of f (u). The verifier checks this order, and ensures that it is consistent with f via fingerprinting. The helper must also list all edges, so that the verifier can ensure that all T edges are from the input.</p><p>If the graph is not connected the annotation presents a bipartition of the graph. Each node is presented along with its label, and each is presented along with the corresponding node labels. The verifier uses fingerprinting to ensure no edge is omitted, and the multiset protocol of Lemma 2.2 to ensure that the node labels are consistent.</p><p>For the lower bound, we reduce an instance of DISJ n,2 to connectivity of a graph with O(n) edges over nodes v 0,0 . . . v 3,n : create edges (v j,0 , v j,i ) for j ∈ {0, 2, 3} and i ∈ [n]. Then if x i = 1, add edge (v 0,i , v 1,i ), else add edge (v 1,i , v 2,i ); and if y i = 1, add edge (v 1,i , v 3,i ) else add edge (v 2,i , v 3,i ). The resulting graph is connected only if x and y are not disjoint. The result follows from Theorem 4.5.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 3 . 1 (</head><label>31</label><figDesc>Online MA complexity of INDEX). Let h and v be integers such that hv ≥ N. There is a online MA protocol P for INDEX, with hcost(P) ≤ h and vcost(P) = O(v log h); and any online MA protocol Q for</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>p a,b (r, y) = 0 for any y ∈ [v] \ {b}, the verifier need only update the single value f (r, b), by adding p a,b (r, b), upon reading this token. Note that using a table of O(v) appropriate precomputed values, this update can be computed efficiently. For h = v = √ n, this takes a constant number of arithmetic operations per update.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>3 .</head><label>3</label><figDesc>Consider a stream consisting of length N binary string x followed by length N binary string y. Exact computation of F 2 implies online schemes for certain functions of x and y. For example, the innerproduct x • y is (F 2 (x + y) -F 2 (x) -F 2 (y))/2 and the Hamming distance is |{i : x i = 1}| + |{i : y i = 1}|-2x•y. Hence we get (N α log N, N 1-α log N) online schemes for both functions, for any α ∈ [0, 1].</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Or we could let the verifier send a random string to the helper before any input is read.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements: We thank Yael Gertner, Sampath Kannan, and Mahesh Viswanathan for sharing <ref type="bibr" target="#b18">[19]</ref>. We also thank Sudipto Guha and T. S. Jayram for helpful discussions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Theorem 5.3. There is a (n 2 , log n) online scheme for counting triangles.</p><p>Proof. Denote the graph adjacency matrix by A, with A i,i := 0. The helper lists A v,w and A 2 v,w for all pairs (v, w) in some canonical order. The verifier computes ∑ v,w A v,w A 2 v,w as the number of triangles. The verifier uses fingerprints to check that A matches the original set of edges, and the protocol in Theorem 5.2 to ensure that A 2 is as claimed.</p><p>We also show that it is possible to trade-off the computation with the helper in a "smooth" manner. The approach is based on an observation of Bar-Yossef et al. <ref type="bibr" target="#b5">[6]</ref>: The frequency moments of a derived stream can be expressed in terms of the number of triples of nodes with exactly {0, 1, 2, 3} edges between them. In small space we can induce a length m(n -2) stream by replacing each edge (u, v) by the set of triples {(u, v, w) : w = u, v}. It follows that the number of triangles can be expressed in terms of the frequency moments of this derived stream, as (F 3 -2F 2 + F 1 )/12. By using the protocol of Theorem 4.3, we obtain the following theorem.</p><p>Theorem 5.4. There is a (n 3α , n 3-3α ) online scheme for counting triangles (α ∈ [0, 1]).</p><p>Bipartite Perfect Matchings. We now present an online scheme for testing whether a bipartite graph has a perfect matching. Graph matchings have been considered in the stream model <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b34">35]</ref> and it can be shown that any single pass algorithm for determining the exact size of the maximum matching requires Ω(n 2 ) space. We show that we can off-load this computation to the helper such that, with only O(n 2 ) annotation, the answer can be verified in O(log n) space. This is shown to be best possible by combining a reduction from <ref type="bibr" target="#b15">[16]</ref> coupled with Theorem 3.1.</p><p>Theorem 5.5. There exists a (m, log n) online scheme for bipartite perfect matching and any (h, v) online scheme for bipartite perfect matching requires hv = Ω(n 2 ).</p><p>Proof. We consider the general case, where there may be nodes in [n] with no incident edges, which are to be ignored for the matching. If there is a perfect matching M, the annotation lists all edges in M, and the degree of all nodes in [n]. Let x be the characteristic vector that has 1 in the vth coordinate iff the degree of v is non-zero, y be the vector of node frequencies in M. The verifier can use fingerprints to ensure that the claimed degree sequence is correct, and that x matches y.</p><p>If the graph does not have a perfect matching, Hall's theorem provides a witness. Let L ∪ R be a bipartition of the graph, then there exists L ⊂ L such that |L | &gt; |Γ(L )|, the neighbors of L . The helper lists for each node: its degree; whether it is in L or R; and whether it is in L , Γ(L ), or neither. Then the helper presents each edge (u, v), along with the same information on each node. Using Lemma 2.2, the verifier can ensure that the sets are consistent with a constant number of fingerprints. It remains to check that each edge is allowable and</p><p>Connectivity. The problem of determining if a graph is connected was considered in the standard stream model <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b20">21]</ref> and the multi-pass W-stream model <ref type="bibr" target="#b14">[15]</ref>. In both models, it can be shown that any constant pass algorithm without annotations needs Ω(n) bits of space. In our model, the helper can convince a verifier with O(log n) space whether a graph is connected with only O(m) annotation. This is the best possible for sparse graphs where m = O(n) by combining a reduction from <ref type="bibr" target="#b15">[16]</ref> with Theorem 3.1.</p><p>Theorem 5.6. There exists a (m, log n) online scheme for connectivity and any (h, v) online scheme for connectivity requires hv = Ω(n) even when m = O(n).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Algebrization: a new barrier in complexity theory</title>
		<author>
			<persName><forename type="first">S</forename><surname>Aaronson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Theory of Computing</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="731" to="740" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Lower bounds for one-way probabilistic communication complexity and their application to space complexity</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ablayev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="139" to="159" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the streaming model augmented with a sorting primitive</title>
		<author>
			<persName><forename type="first">G</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Datar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajagopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ruhl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="540" to="549" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The space complexity of approximating the frequency moments</title>
		<author>
			<persName><forename type="first">N</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Matias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="137" to="147" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Complexity classes in communication complexity theory (preliminary version)</title>
		<author>
			<persName><forename type="first">L</forename><surname>Babai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Frankl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="337" to="347" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reductions in streaming algorithms, with an application to counting triangles in graphs</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Bar-Yossef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sivakumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM-SIAM Symposium on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="623" to="632" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the value of multiple read/write streams for approximating frequency moments</title>
		<author>
			<persName><forename type="first">P</forename><surname>Beame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D.-T</forename><surname>Huynh-Ngoc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Lower bounds for randomized read/write stream algorithms</title>
		<author>
			<persName><forename type="first">P</forename><surname>Beame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Jayram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rudra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Theory of Computing</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="689" to="698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Counting triangles in data streams</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Buriol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Frahling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Leonardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marchetti-Spaccamela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Principles of Database Systems</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="253" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Robust lower bounds for communication and stream computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mcgregor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Theory of Computing</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="641" to="650" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Near-optimal lower bounds on the multi-party communication complexity of set disjointness</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Computational Complexity</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="107" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Finding frequent items in data streams</title>
		<author>
			<persName><forename type="first">M</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farach-Colton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">312</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="15" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An improved data stream summary: the count-min sketch and its applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="58" to="75" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Adapting parallel algorithms to the w-stream model, with applications to graph problems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Demetrescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Escoffier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Moruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ribichini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MFCS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="194" to="205" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Trading off space for passes in graph streaming problems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Demetrescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Finocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ribichini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM-SIAM Symposium on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="714" to="723" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On graph problems in a semi-streaming model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mcgregor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">348</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="207" to="216" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Annotation and computational geometry in the streaming model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<idno>YALEU/DCS/TR-1249</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>Yale University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fast probabilistic algorithms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Freivalds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MFCS</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="57" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">NP and streaming verifiers</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gertner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Randomized computations on large data sets: tight lower bounds</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hernich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Schweikardt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Principles of Database Systems</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Computing on data streams. External memory algorithms</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rajagopalan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="107" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Extensions of Lipshitz mapping into Hilbert space</title>
		<author>
			<persName><forename type="first">W</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lindenstrauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Contemporary Mathematics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="189" to="206" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">New streaming algorithms for counting triangles in graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jowhari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ghodsi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computing and Combinatorics</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="710" to="716" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A probabilistic algorithm for verifying matrix products using o(n 2 ) time and log 2 n + o(1) random bits</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kimbrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Sinha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="107" to="110" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Rectangle size bounds and threshold covers in communication complexity</title>
		<author>
			<persName><forename type="first">H</forename><surname>Klauck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Computational Complexity</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="118" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nisan</surname></persName>
		</author>
		<title level="m">Communication Complexity</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Proof-infused streams: Enabling authentication of sliding window queries on streams</title>
		<author>
			<persName><forename type="first">F</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hadjieleftheriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kollios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="147" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Algebraic methods for interactive proof systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fortnow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Karloff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="859" to="868" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Cads: Continuous authentication on data streams</title>
		<author>
			<persName><forename type="first">S</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On the distributional complexity of disjontness</title>
		<author>
			<persName><forename type="first">A</forename><surname>Razborov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Colloquium on Automata, Languages and Programming</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="249" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">IP = PSPACE</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="869" to="877" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Tabulation based 4-universal hashing with applications to second moment estimation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Thorup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM-SIAM Symposium on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Tucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M L</forename><surname>Delcambre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sheard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Jones</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Punctuated data streams</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Randomized synopses for query assurance on data streams</title>
		<author>
			<persName><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hadjieleftheriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kollios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Data Engineering</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Weighted matching in the semi-streaming model</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zelke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="669" to="680" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
