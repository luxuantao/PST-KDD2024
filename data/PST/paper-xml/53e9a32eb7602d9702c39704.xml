<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A New CRT-RSA Algorithm Secure Against Bellcore Attacks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Johannes</forename><surname>Bl</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Martin</forename><surname>Otto</surname></persName>
							<email>martinmo@upb.de</email>
						</author>
						<author>
							<persName><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
							<email>jean-pierre.seifert@infineon.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Paderborn University</orgName>
								<address>
									<postCode>D-33095</postCode>
									<settlement>Paderborn</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Paderborn University PaSCo Graduate School</orgName>
								<address>
									<postCode>D-33095</postCode>
									<settlement>Paderborn</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Infineon Technologies Secure Mobile Solutions</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">SMS IC</orgName>
								<address>
									<postCode>D-81609</postCode>
									<settlement>Munich</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A New CRT-RSA Algorithm Secure Against Bellcore Attacks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">614B401E0734BB2A199331BDCDA6916A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>B.8.1 [Reliability, Testing, and Fault-Tolerance]: fault attacks</term>
					<term>C.3 [Special-Purpose and Application-based Systems]: smartcards</term>
					<term>D.4.6 [Security and Protection]: Cryptographic controls Algorithms, Security RSA, cryptanalysis, faults attacks, Bellcore attack, smartcards, Chinese Remainder Theorem</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we describe a new algorithm to prevent fault attacks on RSA signature algorithms using the Chinese Remainder Theorem (CRT-RSA). This variant of the RSA signature algorithm is widely used on smartcards. Smartcards on the other hand are particularly susceptible to fault attacks like the one described in [7]. Recent results have shown that fault attacks are practical and easy to accomplish ([21],</p><p>[17]). Therefore, they establish a practical need for fault attack protected CRT-RSA schemes. Starting from a careful derivation and classification of fault models, we describe a new variant of the CRT-RSA algorithm. For the most realistic fault model described, we rigorously analyze the success probability of an adversary against our new CRT-RSA algorithm. Thereby, we prove that our new algorithm is secure against the Bellcore attack.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Smartcards play an important role in modern cryptography. Smartcards are used to compute digital signatures, most notably digital signatures based on RSA. Since speed is still an issue with modern smartcards, enhancements have been adopted to the plain RSA signature algorithm. The most common enhancement is the computation of an RSA signature using the Chinese Remainder Theorem (CRT). We will refer to this variant of RSA as CRT-RSA. With CRT-RSA one can expect a speed-up by a factor of 4 compared to plain RSA. However, smartcards are not as tamper-resistant as one may wish. Hence side-channel attacks like fault, power, and timing attacks, on smartcards have attracted a lot of attention. Among side-channel attacks, fault attacks seem to be easiest to realize <ref type="bibr" target="#b2">[2]</ref>. In particular, CRT-RSA proved to be susceptible to fault attacks. In <ref type="bibr">[7]</ref> an extremely simple attack on CRT-RSA is described. Named the Bellcore attack, this attack reveals the secret factorization of the RSA modulus N by introducing a single fault resulting in a signature that is correct modulo one of the secret prime factors of N , but faulty modulo the other prime factor. This attack is particularly devastating because the type of fault induced is irrelevant.</p><p>Several types of countermeasures against fault attacks have been described, e.g. to compute a signature twice and compare the two results or to verify the result with the public key before output. However, these two countermeasures are too costly to be of practical interest. A more sophisticated software countermeasure has been proposed by Shamir (see <ref type="bibr" target="#b20">[20]</ref>). He suggested to check intermediate results modulo a small integer. This approach will be described later in more detail. Of course, general (usually randomized) schemes that enhance the security of RSA can also prevent fault attacks or at least make them harder to realize. The most prominent of these randomization schemes is OAEP <ref type="bibr" target="#b4">[4]</ref>. Most smartcard certification authorities, however, require that a smartcard implements a pure RSA signature algorithm that is secure without using OAEP or similar schemes.</p><p>Although several software countermeasures against fault attacks have been proposed (see <ref type="bibr">[7]</ref>, <ref type="bibr" target="#b24">[24]</ref>), none of these proposals was based on an explicitly formulated and justified fault model. Accordingly, no proper security analysis of the various schemes could be given. Hence, in this paper starting from a careful derivation and classification of fault models, we describe a new variant of the CRT-RSA algorithm. For the most realistic fault model described, we analyze whether a Bellcore-type attack on the algorithm can be successful. In <ref type="bibr" target="#b2">[2]</ref> it was shown that a fault attack can basically change the value of any variable used in a smartcard algorithm. Hence, for any variable used in our scheme we analyze whether a Bellcore-type attack can be mounted by changing the value of that particular variable. We prove that for all variables the success probability of a Bellcore-type fault attack is negligible. Only once do our proofs rely on a plausible but unproven number theoretic assumption.</p><p>Our scheme borrows ideas from Shamir's countermeasure against fault attacks as well as the idea of infective computations from <ref type="bibr" target="#b24">[24]</ref>. Shamir suggests choosing a small prime t of about 32 bits to compute Sp = m d mod pt and Sq = m d mod qt and check whether Sp ≡ Sq mod t before combining them with the CRT. As is easily seen, Shamir's scheme only protects the signature computations modulo the two secret prime factors of the RSA modulus N . It leaves unprotected the CRT-combination step to obtain the final signature modulo N . Furthermore, as observed in <ref type="bibr" target="#b24">[24]</ref>, Shamir's algorithm has a single point of failure when it checks if Sp ≡ Sq mod t. Usually, such a comparison relies on the zero flag only. A single point of failure means that once this point is successfully attacked, a smartcard may output a defective signature that can be used to recover secrets.</p><p>Infective computation, as introduced in <ref type="bibr" target="#b24">[24]</ref>, means that any error introduced by a fault attack propagates through the computation. In particular, in CRT-RSA a faulty signature will always be faulty modulo both prime factors, thereby preventing a Bellcore attack. Unfortunately, for realistic parameters the infective computation proposed in <ref type="bibr" target="#b24">[24]</ref> can be broken. In particular, the method proposed in <ref type="bibr" target="#b24">[24]</ref> restricts the pairs of public/secret exponents in RSA to pairs, that basically can be broken by Wiener's small secret exponent attacks ( <ref type="bibr" target="#b5">[5]</ref>).</p><p>The scheme proposed in this paper extends Shamir's idea to protect every single computation step of the signature algorithm, including the CRT combination. We achieve this by using two small integers t1 and t2 to compute Sp = m d mod pt1 and Sq = m d mod qt2. These values are combined to S mod Nt1t2 via the CRT. This combination with a larger modulus allows to use infective computation steps afterwards. These infective steps ensure that an error will cause the final signature to be false modulo both primes p and q. Infective computations not only avoid single points of failures. They also allow a card to continue its computation, even if a fault is detected. Hence, our scheme renders mechanism like security resets or error messages pointless. This is an important feature of our scheme, since error messages or security resets may leak important and useful information to an adversary (see for example <ref type="bibr" target="#b14">[14]</ref>, <ref type="bibr" target="#b6">[6]</ref> for more details).</p><p>Finally, unlike the scheme proposed in <ref type="bibr" target="#b24">[24]</ref>, our algorithm works with any RSA key, no restriction on the key space applies. To prove security, we present a rigorous analysis of our scheme.</p><p>To describe and classify fault models, we start from the most powerful adversary imaginable, i.e. an adversary that can change any specific bit at any specific time of the algorithm execution. However, we make use of several hardware features employed on realistic smartcards to argue that the effects of such a precise intrusion are not completely predictable for an adversary. The hardware mechanisms we are referring to include randomized clocks, memory encryption / decryption schemes, and randomized address scrambling (see <ref type="bibr" target="#b18">[18]</ref>, <ref type="bibr" target="#b9">[9]</ref>). Like randomized schemes, these hardware features try to make fault attacks harder by randomizing the effects of a fault attack in a manner that can not be controlled or predicted by an adversary.</p><p>Based on the effects of randomized clocks, memory encryption/decryption, and randomized address scrambling we argue that even a very powerful adversary can not hope to reset a bit value at a specific location and time. Instead all he can hope is that with a certain probability he will change the value of a particular variable used by the algorithm. Furthermore, we argue that an adversary can only hope to change the value of a targeted variable to some random value. We also describe some intermediate fault models, in which the adversary is able to attack specific byte or bit values. We extend the analysis of our CRT-RSA scheme to these models as well. We show that in these models the new CRT-RSA scheme sometimes offers an even better security, i.e. knowing the effect of an attack exactly helps defending against this attack. In our analysis, we only look at fault attacks. Combinations with other side channel attacks like timing or power attacks are not regarded.</p><p>The paper is organized as follows: After stating the preliminaries in Section 2, we formulate a careful classification of fault models in Section 3. We propose a new algorithm in Section 4 that will be proven to be secure against the Bellcore attack in Section 5. Section 6 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES</head><p>Throughout the paper, we will use the following notation. We assume that an RSA key scheme consists of two primes p and q that form the RSA modulus N = p • q. We will denote the public RSA key as e and the private RSA key as d, satisfying e • d ≡ 1 mod ϕ(N ). Here, ϕ(N ) denotes Euler's totient function. The function l(n) will be used to denote the binary length of an integer n. We will use a | b to denote that an integer a divides b, and a | b to denote the converse.</p><p>Usually, smartcards compute RSA signatures S(m) := m d mod N using the CRT-RSA scheme. Here, the two signature parts Sp := m d mod (p-1) mod p and Sq := m d mod (q-1) mod q are computed first. They are combined using the Chinese Remainder Theorem (CRT) as S(m) := CRT(Sp, Sq) mod N . On average, this scheme is four times faster than the direct computation via a single exponentiation, cf. <ref type="bibr" target="#b12">[12]</ref>.</p><p>The major exploit of fault attacks on smartcards performing CRT-RSA signatures is an attack first presented in <ref type="bibr">[7]</ref> (and named the "Bellcore attack"). Here it is assumed that an adversary induces an error that causes Sp to be defective while Sq is computed correctly (or vice versa of course). If the defective CRT-combination S = CRT(Sp, Sq) mod N is disclosed, the scheme is completely broken as gcd(S em, N ) = q.</p><p>As we investigate errors on various variables, we use the following convention: For random errors on a specific variable x, we write f (x) = x + e(x), where e(x) is the error dependent on x. For random errors, e(x) ∈ [-x, 2 l(x) -1x]. In some scenarios, e(x) can be specified in greater detail, e.g. for random byte errors, e(x) = b • 2 k with |b| ∈ 2 8 a random byte and 0 ≤ k &lt; l(x) -7. For single bit errors, |b| = 1 and 0 ≤ k &lt; l(x). We always assume a uniform distribution on the errors.</p><p>All parts of our analysis can be rigorously proven. Only the analysis for one variable relies on the following heuristically justified assumption.</p><p>Assumption 1. For an RSA modulus N = p•q, d a secret key, m ∈ N a given message, t p a prime, e(•) a random error as defined above, the value α := m d div (pt + e(pt)) mod t can be seen as a random variable uniformly distributed in t .</p><p>Clearly, α only has a chance to fulfill the assumption correctly if 2 l(pt) is a multiple of t. However, the assumption is justified for other cases as well, because the distance to the uniform distribution is negligibly small as t 2 l(pt) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DEVELOPMENT OF PRACTICALLY APPROVED FAULT MODELS</head><p>There has been a large number of different fault attacks in the literature. They differ in the power to locate and time an attack, in the number of bits affected, in the effect of an attack (the fault type), in the probability of the implied effect of an attack, and in prior work that has to be applied to the card in order to mount the attack, cf. among others <ref type="bibr">[7]</ref>, <ref type="bibr" target="#b16">[16]</ref>, <ref type="bibr" target="#b22">[22]</ref>, <ref type="bibr" target="#b14">[14]</ref>, <ref type="bibr" target="#b15">[15]</ref>, <ref type="bibr" target="#b1">[1]</ref>, <ref type="bibr" target="#b3">[3]</ref>, <ref type="bibr" target="#b8">[8]</ref>, <ref type="bibr" target="#b23">[23]</ref>, <ref type="bibr" target="#b2">[2]</ref>, <ref type="bibr" target="#b21">[21]</ref>. However, the characterization of the used fault models has been simple and insufficient to derive usable frameworks for a satisfactory analysis. Therefore, we present a characterization of the different parameters needed to fully describe all known types of fault attacks. This leads to a proper mathematical formulation of errors induced by such attacks. The derived fault models are motivated by smartcards as they are used today.</p><p>• For control on the fault location we define the three classes "no control", "loose control" (a selected variable can be targeted) and "complete control" (selected bits can be attacked).</p><p>• For control on the timing we also define the three classes "no control", "loose control" (an error is induced in a block of a few operations) and "precise control" (the exact time can be met).</p><p>• For the number of bits attacked, we differentiate between a "single faulty bit", "few faulty bits" (e.g. a byte) or a "random number of faulty bits" (bounded by the length of the attacked variable).</p><p>• The fault type describes the character of the fault as it manifests itself in the chip. This parameter has appeared in the literature as the "fault model". We will break with this tradition as a reasonable description of a fault model must contain more than just the type of the fault. Fault types include the classic fault types, namely the stuck at fault (saf), where bits permanently keep their value from the point of a successful attack, the bit flip fault (bf), where bits are flipped to their complementary value and the random fault (rf), where bits are changed to a random value, possibly the one they already had. In addition to these classic fault types, we also have the fault type derived from recent work in <ref type="bibr" target="#b21">[21]</ref>. Their approach enables them to set a single specific (targeted) bit to 1 or reset that bit to 0. This is the bit set or reset fault (bsr).</p><p>• Attacks mounted also have a certain probability associated with them. Usually an attack is not certain to be successful, it is only so most of the time. Therefore, any effect as well as the control on location and timing might require a probability or even a distribution to be completely described. For example, some physical attacks might have a greater probability of resetting a bit than of setting that bit (see <ref type="bibr" target="#b8">[8]</ref>, <ref type="bibr" target="#b6">[6]</ref>). No control on the location implies that a specific location is expected to be hit with a certain probability 1/(number of locations).</p><p>To derive reasonable fault models, we combine parameter settings known from actual attacks with hardware countermeasures in effect on the card. As we are guided by practical considerations, we always assume the most powerful adversary, i.e. the adversary presented in <ref type="bibr" target="#b21">[21]</ref> and <ref type="bibr" target="#b17">[17]</ref> able to use (bsr) faults. This adversary can select any specific area on the card at a precise time (on his clock) and set the stored bit to any specific value. We also consider smartcards, that may have several hardware countermeasures (see <ref type="bibr" target="#b18">[18]</ref>). The architecture of a modern smartcard is sketched in Figure <ref type="figure" target="#fig_0">1</ref>. In these realistic scenarios, the effective power of the adversary is reduced significantly, e.g. knowledge about the location of the induced fault need not imply knowledge about the position of the bit within an algorithm. Similarly, precise timing need not imply knowledge of the actual step performed at that time. The following five fault models gradually improve the strength of the card's countermeasures.  Parameter setting. For this strong fault model, we assume that the adversary has precise control on both timing and location. This means that the adversary knows the attacked bit as well as the attacked operation. Note that an attack usually happens before the variable is used in a line of an algorithm. We assume that only a single bit is affected. This resembles the (bsr) fault type that is achieved by attacks described in <ref type="bibr" target="#b21">[21]</ref> or <ref type="bibr" target="#b17">[17]</ref> on RAM or EEPROM of an unprotected smartcard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RSA accelerator</head><p>Mathematical model. This attack can be modeled as an addition or subtraction of a single bit, i.e. a variable X is changed to</p><formula xml:id="formula_0">X = X ± 2 k for 0 ≤ k ≤ l(X) -1.</formula><p>Motivation from the real world. Although high-end smartcards implement sophisticated hardware countermeasures, many smartcards currently used are either too old or too cheap to do so. Hence, this fault model is a realistic one. It assumes the strongest adversary and the weakest card. Since algorithms secure in this fault model are secure in the weaker models as well, it is a particularly interesting model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fault Model #2: Precise Byte Errors.</head><p>Parameter setting. In this scenario, we assume that the timing is precise. Hence, a specific operation can be targeted. However, control on location is loose, i.e. the number of bits affected can only be bounded by a block of few bits (we assume a byte). We allow any fault type in this model.</p><p>Mathematical model. The attack can be modeled as an addition or subtraction of an unknown error byte at a known position, i.e. a variable X is changed to</p><formula xml:id="formula_1">X = X ± b • 2 k for a known 0 ≤ k ≤ l(X) -8 and an unknown b ∈ 2 8.</formula><p>Motivation from the real world. This model is motivated by the fact that the strong adversary's power is reduced on smartcards if encryption of the data is used. Usually, all data stored in EEPROM and RAM is encrypted <ref type="bibr" target="#b18">[18]</ref>. Hence, if an error is induced into memory, the CPU will see a random block of data. The same model is derived if the bus lines are attacked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fault Model #3: Unknown Byte Errors.</head><p>Parameter setting. In this scenario, we assume loose control on both timing and location. The loose control on location means that a certain variable can be targeted but the number of bits affected can only be bounded by a block of few bits (usually a byte). In addition, loose control on timing means that the attacker can only affect the variable within a specific time frame that usually contains several instructions. The exact instruction affected by the attack is unknown. Hence, the attacker does not know for sure which byte of the variable is currently used by the algorithm. We allow any fault type in this model.</p><p>Mathematical model. This attack can be modeled as an addition or subtraction of an error byte, i.e. a variable</p><formula xml:id="formula_2">X is changed to X = X ± b • 2 k for an unknown 0 ≤ k ≤ l(X) -8 and an unknown b ∈ 2 8.</formula><p>Motivation from the real world. This model is motivated by the fact that attacks on EEPROM and RAM with address scrambling (cf. <ref type="bibr" target="#b18">[18]</ref>) will not allow to specify when the attacked block is requested by the CPU. Encryption of the memory ensures that a faulty bit affects a whole block of data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fault Model #3': Unknown Byte Errors in Unknown Variables.</head><p>Parameter setting. This model assumes loose control on location, once again a whole byte is affected, and no control on timing. Due to the latter it is unknown at which exact time within the program the attack is mounted. It is even unknown, which variable is faulty.</p><p>Mathematical model. We model this type of fault as a variable dependent error, i.e. a variable X is changed to X = X ± b • 2 k for an unknown 0 ≤ k ≤ l(X) -8 and an unknown b ∈ 2 8. Note that due to the unprecise timing, the attacked variable X is also unknown (to some degree). Motivation from the real world. The strong adversary's power is effectively reduced to this model if the smardcard uses memory encryption in RAM and EEPROM. This causes any bit fault to affect a whole block of data. In addition, some smartcards use a randomized clock (cf. <ref type="bibr" target="#b9">[9]</ref>). In this case, the attacker knows that a successful attack will change a block of data. But he does not know the exact time of the change within the algorithm. Therefore the attacker does not know the position of the block as it is used in the CPU.</p><p>Fault Model #4: Random Errors. Parameter setting. In this fault model, we assume that the adversary has no control on the location of a fault and only a loose timing, i.e. he can target an interval of some operations. This interval may have been derived from other sources of information, for example from the power profile of the card (see <ref type="bibr" target="#b2">[2]</ref>). The number of affected bits is unknown.</p><p>Mathematical model. We model this uncertainty on the number of affected bits by a random fault. We assume that for a given variable X, the uniformly distributed random value f (X) ∈ [0, 2 l(X) -1] is used by the algorithm. In this model, any fault may result in any faulty value.</p><p>Motivation from the real world. This scenario is motivated by strong high-end smartcards completely armed with countermeasures. Memory encryption, address scrambling and a randomized clock imply that any error induced into memory or the CPU at a vague point will leave the attacker at most with the information that a certain variable is faulty. It therefore enforces a very weak adversary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reaction Of The Smartcard</head><p>A smartcard may react in various ways to an attack: Unprotected cards will fail to notice the attack and output a faulty result, leaving them vulnerable to the Bellcore attack. More sophisticated smartcards may have countermeasures that alter the result to some random value or use detection mechanisms that report an error to the user. The error output may either depend on the kind of error or be unspecific.</p><p>Modern high-end smartcards may have additional hardware countermeasures (see <ref type="bibr" target="#b6">[6]</ref>), that might successfully fight some of these attacks and react with a complete security reset. This reaction of the card may already be set off before an attack successfully induced an error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implications For Our Analysis</head><p>So far, no software countermeasures against fault model #1 are known (see <ref type="bibr">Section 6)</ref>. Lukily, the models #1 and #2 are unlikely in the real world, as all trustworthy smartcards are fully armed with a variety of countermeasures. This causes a precise location of an affected bit or byte to be unrealistic.</p><p>We will therefore concentrate to analyze security against fault models #3 and #4. The two models #3 and #3' are equivalent, as model #3' usually only means that the faulty variable X is from a small set of possible variables. If the attack hits every variable within this set with a sufficiently high probability, a specific variable is expected to be hit after a relatively low number of attacks. Hence, both scenarios can be modeled in the same way (see <ref type="bibr" target="#b6">[6]</ref>).</p><p>The analysis of our method will show that only a negligible number of faults result in an output that potentially leaks valuable information to an adversary. Hence, the smartcard needs no other means of reaction to errors such as error messages or security resets. We will therefore not consider any such reaction mechanisms in the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">THE NEW APPROACH</head><p>The drawbacks of Shamir's small prime verification countermeasure explained in the introduction show that better methods are needed. As Shamir's basic idea is very promising, we extend this countermeasure to the whole CRT-RSA computation. We also use infective computations as introduced by <ref type="bibr" target="#b24">[24]</ref> to eliminate the single point of failure of a checking step.</p><p>Algorithm 2 (infective CRT-RSA).</p><formula xml:id="formula_3">Input. A message m ∈ N Output. Sig := m d mod N In Memory. p • t1, q • t2, N , N • t1 • t2, dp, dq, t1, t2, et 1 and et 2 1 Let Sp := m dp mod p • t1 2 Let Sq := m dq mod q • t2 3 Let S := CRT(Sp, Sq) mod N • t1 • t2 4 Let c1 := (m -S et 1 + 1) mod t1 5 Let c2 := (m -S et 2 + 1) mod t2 6 Let Sig := S c 1 •c 2 mod N 7 output Sig</formula><p>The basic algorithm for CRT-RSA consists of three steps, the computation of the two parts Sp and Sq and their combination to the signature S using the CRT. We modify the computation of all three values implementing a variant of Shamir's idea. Then we introduce a detection mechanism that is not required to be error free in order to prevent a fault attack on the whole smartcard. If an error was induced at any step of the algorithm, this countermeasure will change the final result in a way unpredictable to an adversary. The resulting algorithm, Algorithm 2, looks extremely simple, but it proves to be very effective in the most practical attack model assuming the strongest adversary.</p><p>As a precomputation step that can be done for any smartcard at production time, generate a valid RSA key with (N, e), N = p • q, as the public key and d as the corresponding private key satisfying e • d ≡ 1 mod ϕ(N ).</p><p>Additionally, select two integers t1 and t2 of sufficiently large bitlength to withstand exhaustive search (see Section 5.7 for concrete suggestions) which must satisfy several conditions in order to allow a secure scheme:</p><p>1. t1 and t2 must be coprime 2. gcd(d, ϕ(t1)) = 1 and gcd(d, ϕ(t2)) = 1 3. t1 and t2 are squarefree 4. ti ≡ 3 mod 4 for i ∈ {1, 2} 5. t2 |X = pt1 • ((pt1) -1 mod qt2) Note that the use of two small moduli instead of a single one has already been described by Shamir in <ref type="bibr" target="#b20">[20]</ref>, but for a different use. Let dp := d mod ϕ(p•t1), dq := d mod ϕ(q •t2). Afterwards, compute two corresponding public keys et 1 and Let us briefly comment on the five conditions for the small primes ti: Condition 1 is needed to ensure that the CRT combination of Sp and Sq works, because it requires the two moduli to be coprime. Condition 2 is required to ensure that the small keys et i (i = 1, 2) can be generated. Condition 3 must hold, because otherwise the equation m d•et i ≡ m mod ti may not hold. This condition can be further relaxed. However, we suggest choosing primes for both ti. Condition 4 ensures a good resistance against attacks on the exponents dp and dq. The security analysis will further explain this condition. Finally, Condition 5 provides security against attacks on the CRT combination (see the analysis of attacks on line 3 below). Section 4.1 will show that choosing both ti as strong primes is a useful recommendation.</p><formula xml:id="formula_4">et 2 such that d • et i = 1 mod ϕ(ti). Store p • t1, q • t2, N , N • t1 • t2,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Efficiency Of The New Algorithm</head><p>Now we will show that the new algorithm is indeed an efficient algorithm to compute RSA signatures. The efficiency depends on the keys ti. The additional costs compared to the plain CRT-RSA method are mainly an increased number of operations in lines 1 and 2 due to the larger moduli. This increases the size of the exponent and of the intermediate results. These have to be computed in a larger group now. The additional costs of the CRT (due to a larger modulus) and the costs of the two modular exponentiations modulo t1 and t2 (in lines 4 and 5) do not contribute to the overall costs significantly. If quadratic time complexity is assumed for the modular exponentiations in pt 1 and qt 2 , the savings compared to the plain CRT-RSA scheme is lowered to 1/3 instead of 1/4 (for l(ti) ∈ {60, 80}) of the cost of the plain CRT-RSA exponentiation. This is still an acceptable speedup.</p><p>For the key generation process, which is usually performed on the card at production time, we can efficiently find suitable candidates for t1 and t2. First, a valid RSA key pair ((e, N ), d) is chosen, with N = p • q. Then the two small moduli t1 and t2 are generated. We would like to emphasize the fact that neither the algorithm nor the small moduli impose any restrictions on the choice of the main RSA key, no special structure or generation process is required. Hence, any valid RSA key pair can be used for ((e, N ), d).</p><p>We suggest choosing t1 and t2 as different strong primes, i.e. (ti -1)/2 are also primes. As ti p, q this obviously satisfies Conditions 1, 3, and 4. Condition 2 is not satisfied for a fixed ti in a fraction of about 1/ti cases. Therefore given l(ti) large enough, this probability is negligible. For randomly chosen ti, the values pt1 and qt2 are independent, therefore (pt1) -1 mod qt2 is uniformly distributed in qt 2 . As t2 |pt1, this means that the probability that a chosen t2 does not satisfy Condition 5 is at most 1/t2. Hence, we expect very few strong prime choices. Since the density of strong primes is conjectured to be asymptotically D • x/ log 2 (x) ( <ref type="bibr" target="#b13">[13]</ref>), the task of finding suitable ti is easy. Here D ≈ 0.6601618 is the twin prime constant.</p><p>Note that it is also possible to use a modified CRT combination that can handle the case t1 = t2. Hence, it suffices to choose a single t. We choose two in order to use the standard CRT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">SECURITY ANALYSIS OF THE PROPOSED COUNTERMEASURE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Undetectable Errors</head><p>For the security analysis, we need to investigate the probability of any induced error to circumvent our countermeasure and result in an undetectable error. Note that we are only concerned with errors that cause the final signature to be correct modulo p but false modulo q (or vice versa), in which case the classic Bellcore attack can be applied. Otherwise, no exploits of specific errors in a faulty CRT-RSA signature are known yet. Also, in our analysis, we do not look at combinations with other side channel attacks like timing or power attacks.</p><p>The checking mechanism in lines 4 and 5 is done via a small modulus, hence, undetectable errors are introduced into the system. However, we will show that the number of these errors is negligibly small. Therefore, they pose no threat to the security of the system.</p><p>An error will slip by lines 4 and 5 undetected if it is eliminated by the modular reduction. If S is a faulty value for S, then if S = S + k • t1 • t2, k ∈ , both modular reductions in lines 4 and 5 will fail to detect this error and set c1 = c2 = 1. For other values of S , it is S = S mod ti for i = 1 or i = 2. Hence S et i = m mod ti, which in turn forces m -S et i &gt; 0 mod ti. Therefore, it is ci = 1. Note that this observation is independent of the type of error.</p><p>However, in order to analyze the scheme, we need to define our fault model. For our analysis, we assume again the strongest adversary attacking the best protected card. We will only analyze in detail the most interesting/practical scenario, the random error fault model #4, and show its security against the Bellcore attack. Results for the byte error fault models #2, #3 yield even better results. See the appendix for details on attacks using the other fault models. The random error fault model #4 assumes that an attacked value x is replaced by a random bit string f (x) = x+e(x) as defined in Section 2. For simplicity, we only assume a single fault. However, as long as multiple errors are uncorrelated, the results are the same. Note that it is virtually impossible to correlate attacks on smartcards that use hardware countermeasures.</p><p>The two special inputs m = 0 and m = 1 will prove dangerous to the algorithm in the presence of some faults. Later, we will describe several enhancements to our scheme such that also these two messages cannot be exploited in a fault attack.</p><p>In the following analysis of attacks on each variable, the term success probability always refers to the success probability for a random fault induced into the attacked variable to result in an undetectable error such that the Bellcore attack can be applied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Attacks On Lines 1 And 2 • Attack on the variable Ô</head><p>The success probability for an attack on dp is at most 3/t1 for messages m ≡ ±1 mod t1. This probability is taken over the errors. A fraction of at most 3/t1 of all messages satisfies m ≡ ±1 mod t1. The message m = 1 is secure. For other messages m ≡ ±1 mod t1, m = 1, the success probability is at least 1/2.</p><p>Comment. Although this analysis seems to prove the algorithm insecure, this is not the case. Any adversary capable of constructing malicious instances of messages, i.e. an m ≡ ±1 mod t1, needs to know t1. But this parameter is secret. Hence, the adversary has no information on how to construct m. Therefore, the best he can do is to randomize the inputs. And since the number of malicious messages is less than 3/t1, this is a secure situation.</p><p>Proof. Let m ≡ ±1 mod t1. Given m, an error e(dp) leads to an undetectable error if m e(dp) ≡ 1 mod t1.</p><p>(</p><formula xml:id="formula_5">)<label>1</label></formula><p>We need to analyze how many e(dp) exist at most with <ref type="bibr" target="#b1">(1)</ref>. Consider gcd(e(dp), t1 -1). Since t1 is a strong prime, we get gcd(e(dp), t1 -1) ∈ {1, 2, (t1 -1)/2, t1 -1}.</p><p>Any e(dp) with gcd(e(dp), t1 -1) ∈ {1, 2} can be written as e(dp) = 2 l • b, b odd and gcd(b, t1 -1) = 1. For these e(dp), (1) implies m 2 l ≡ 1 mod t1. Next, since t1 is a strong prime, the equation x 2 l ≡ 1 mod t1 has only the solutions x ≡ ±1 mod t1. We conclude that for m ≡ ±1 mod t1 and gcd(e(dp), t1 -1) ∈ {1, 2}, no error will be undetectable.</p><p>Hence it remains to bound the number of e(dp) with gcd(e(dp), t1 -1) ∈ {(t1 -1)/2, t1 -1} and m e(dp) ≡ 1 mod t1. The worst case for m is if m (t 1 -1)/2 ≡ 1 mod t1, in which case any e(dp) with the property that e(dp) is a multiple of (t1-1)/2 leads to an undetectable fault. Since e(dp) ∈ [-dp, 2 l(dp)+1 -1], the number of e(dp) with gcd(e(dp), t1 -1) ∈ {(t1 -1)/2, t1 -1} is a fraction of at most 2/(t1 -1) &lt; 3/t1 of all possible e(dp).</p><p>Let us now determine the number of messages m ≡ ±1 mod t1. As the messages are in N, there are at most 2 • N/t1 + 2 messages satisfying the condition m ≡ ±1 mod t1. This is a fraction of less than 3/t1 of all possible messages. Now let m ≡ 1 mod t1. If m = 1, then m e(dp) = 1 and Sp = 1. Hence, the error has no effect. Otherwise, every fault will cause an undetectable error, because m e(dp) ≡ 1 mod t1 independent of the error e(dp).</p><p>Let m ≡ -1 mod t1. The probability that a random fault causes an undetectable error is at least 1/2, since every even e(dp) yields m e(dp) ≡ 1 mod t1. In addition, if e(dp) is invertible modulo (t1 -1), the same considerations as above apply. This increases the success probability further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Attack on the variable ÔØ1</head><p>The success probability for an attack on pt1 is at most 2/t1. This result is based on Assumption 1. The probability is taken over random choices of the error.</p><p>Proof. If the modulus is randomly changed to f (pt1) = pt1 + e(pt1), write m d = α0 • (pt1 + e(pt1)) + α1 with α1 &lt; pt1 + e(pt1). The correct result Sp is now Sp = α0 • e(pt1) + α1 mod pt1, while the faulty result S p is α1. An undetectable error happens, if Sp ≡ Sq mod t1, hence if α0 •e(pt1)+α1 ≡ α1 mod t1. This is equivalent to α0 • e(pt1) ≡ 0 mod t1.</p><p>As t1 is a prime, t1 has to divide at least one of the two factors. Hence, we need to compute the probability of 0 ≡ e(pt1) mod t1 and of 0 ≡ α0 = m d div (pt1 + e(pt1)) mod t1. As e(pt1) is an uniformly distributed integer in a contiguous interval and α0 is uniformly distributed by Assumption 1, the success probability is at most 1/t1 for each factor, and altogether at most 2/t1. This probability is taken over random choices of the error.</p><p>• Attack on Ñ or the exponentiation's interme-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>diate variable</head><p>The success probability for an attack during the exponentiation is at most 2/t1 for messages m ≡ 0 mod t1. This probability is taken over the errors. For messages m ≡ 0 mod t1, all faults yield an undetectable error. A fraction of at most 1/t1 of all messages m satisfies m ≡ 0 mod t1.</p><p>Comment. There are many possible ways to compute m dp mod pt1. Algorithm 3 presents a timing and simple power attack secure version of the well-known square-and-multiply algorithm (cf. <ref type="bibr" target="#b10">[10]</ref>, <ref type="bibr" target="#b11">[11]</ref>). The result holds for other exponentiation algorithms as well.</p><p>Again, some messages are malicious, but similar to the reasoning before, the adversary can gain no advantage from this fact as he cannot choose m accordingly. Attacks on y0 and y1 resemble the same situation if they get incorporated into the computation at all. If the modulus pt1 is attacked during the exponentiation, the resulting scenario is equivalent to that analyzed for a global attack on pt1 above. </p><formula xml:id="formula_6">S p = (y + e(y)) 2 l-1 • m w for w = È l-1 i=1 di • 2 i .</formula><p>Hence messages m ≡ 0 mod t1 lead to S p ≡ Sp mod t1 and to an undetectable error in line 4 of Algorithm 2. There are at most 1/t1 of all possible messages satisfying this condition.</p><p>For messages m ≡ 0 mod t1, we analyze the probability of (y + e(y)) 2 l-1 ≡ (y) 2 l-1 mod t1. First consider the case (y + e(y)) ≡ 0 mod t1. This implies (y) l-1 ≡ 0 mod t1 as well. Since y is of the form m x for some x, this in turn implies m ≡ 0 mod t1, which is impossible.</p><p>From now on we assume y + e(y) ≡ 0 mod t1. Then (y + e(y)) 2 l-1 ≡ (y) 2 l-1 mod t1 implies 1 = (y/(y + e(y))) 2 l-1 mod t1. Since t1 ≡ 3 mod 4, this is equivalent to 1 = (y/(y + e(y))) 2 , which in turn implies ±1 = (y/(y + e(y))). For any fixed y, there are exactly two choices of e(y) that satisfy this equality. Hence, in case m ≡ 0 mod t1 we can bound the success probability by 2/t1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Attack on the result ËÔ</head><p>The success probability for an attack on Sp is at most 1/t2 for messages m = 0, 1. Again, the probability is taken over the error. This case will be analyzed while considering attacks on the CRT combination in line 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Attacks On Line 3</head><p>Line 3, the CRT combination, may also be successfully attacked. We assume that</p><formula xml:id="formula_7">S = Sp + X • (Sq -Sp) mod N • t1 • t2 with X = pt1 • ((pt1) -1 mod qt2).</formula><p>Here X is a precomputed value stored on the smartcard.</p><p>• Attack on the result Ë, or on the two addends ËÔ and ¡ (ËÕ ËÔ)</p><p>The success probability for an attack on S, Sp or X • (Sq -Sp) is at most 1/(t1 • t2). The probability is taken over random errors only, it is independent from the chosen message.</p><p>Proof. If S is attacked directly, then S = S+e(S). This would circumvent the countermeasure iff e(S) ≡ 0 mod ti for both i. Because both ti are different primes, this means that e(S) ≡ 0 mod t1 •t2 must hold. As the error e(S) comes from a contiguous interval, this probability is at most 1/(t1 • t2). The same result holds for attacks on the two summands Sp and X • (Sq -Sp).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Attack on</head><p>The success probability for an attack on X is at most 1/(t1 • t2) for all but a fraction of 2/ min(t1, t2) messages. This probability is taken over random choices for the error.</p><p>Comment. An attack on X will result in S = S+e(X)• (Sq -Sp), which may be an undetectable error if t1 • t2|e(X)•(Sq -Sp). The probability for this requirement is at most 1/ min(t1, t2). A detailed analysis of this case can be found in Appendix A. Moreover, the error e(X) also needs to be a multiple of either p or q in order to apply the Bellcore attack.</p><p>As with attacks on dp, the adversary has no information on how to construct a message that yields Sq -Sp to be a multiple of t1, t2 or both. His best choice is to choose random messages, which only gives him a negligible success probability. Hence, this attack is not promising to an adversary.</p><p>• Attack on ËÔ or ËÕ or (ËÕ ËÔ)</p><p>The success probability for an attack on Sp or Sq is less than 1/t2. This probability is taken over random choices of the error only.</p><p>Proof. If an adversary attacks either Sp or Sq in the second summand, the output of the CRT recombination is S = S + e(Sp) • X (or e(Sq) respectively).</p><p>This causes an undetectable error if t1 • t2|e(Sp) • X. As t1 and t2 are primes, this means that both ti have to divide at least one factor. As t1 always divides X = pt1 • ((pt1) -1 mod qt2) and t2 never divides X by Condition 5, this may only happen if t2|e(Sp). Because e(Sp) is uniformly distributed over an interval of consecutive numbers, the success probability is at most 1/t2. The same reasoning holds for (Sq -Sp).</p><p>Comment. If t2 is not chosen carefully to prevent t2|X, the success probability is increased with the probability to meet t2|X. This is independent from the error, therefore any error e(Sp) = 0 would be harmful. This explains Condition 5 of the condition list for selecting t1 and t2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Attacks On Lines 4 -6</head><p>We also need to investigate the possibilities to attack the detection mechanism, lines 4 -6. But attacks on the computation of ci are in vain unless another successful attack has been carried out already. If a random error into a correct ci is induced, it is ci = 1 and the final signature will look like a random value. The same consideration applies to line 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Excluding the two messages Ñ = 0 and Ñ = 1</head><p>The analysis shows that choosing m ∈ {0, 1} leads to a malicious message as m ≡ 0, 1 mod ti in these cases as well. The choice m = 0 or m = 1 is useful for an adversary in attacks on m, on the values Sp and Sq, and on the intermediate results of the exponentiation. Therefore, these two messages must be treated separately. For all other cases, the adversay's ability to create malicious messages implies knowledge about ti. As we assume these parameters to be secret, the adversary has no better choice than to choose m at random. This leaves him with a success probability of at most 1/ti. Hence, ti is a security parameter and can be chosen large enough to effectively prevent efficient attacks. Now let us explain several methods dealing with the case m ∈ {0, 1}. The first method is to use padding schemes. In fact, almost any padding scheme, deterministic or randomized, will ensure that m = 0 and m = 1 will either not be signed at all or will only be signed with negligible probability. However, as explained in the introduction, most smartcard certification authorities require that a smartcard implements a pure RSA signature algorithm that is secure without using OAEP or similar padding schemes.</p><p>To avoid padding schemes, one can modify the message used in lines 1 and 2 in the following way: In line 1 one uses the message mp := m + r1 • p and in line 2 the message mq := m+r2•q. Here, 1 &lt; ri &lt; ti, i = 1, 2 are fixed numbers. Obviously, it should hold that r1 • p mod t1 ∈ [-2, . . . 2], and for line 2 equivalently. In this way, the algorithm actually computes m d mod N . This blinding technique is also useful against other side channel attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Summarizing the results</head><p>Table <ref type="table" target="#tab_2">1</ref> shows the most successful attack scenarios on each line of Algorithm 2. Summarizing the results of this section, the probability to induce an error that can fool our countermeasure and still break the system by the Bellcore attack is negligibly small if the bitlength of t1 and t2 is large enough. Additionally, in the real world various randomization strategies are applied on the card to counteract other side-channel attacks. These measures show that malicious messages, which have been shown to exist for some attacks, are virtually impossible to create. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Further Security Considerations</head><p>Note that disclosure of most intermediate variables can be used to break the system. E.g., if our countermeasure prevents a Bellcore attack on a faulty Sp using c1 = 1, c2 = 1 and c1 is revealed, then gcd(m e -Sig c 1 , N) = p. This also implies that the bitlength of the parameters ti must be large enough to defend against a brute force search on ci from lines 4 and 5 of Algorithm 2.</p><p>The length of the two parameters ti should be as small as possible to ease the cost of computation, but it must be large enough to guarantee security. Section 5.1 shows that the most promising attacks succeed with a probability of at most 3/ min(t1, t2). Hence, both t1 and t2 must be large enough to ensure that attacking the scheme succeeds only with negligible probability. The definition of "small" and "negligible" will have to be adapted to the actual implementation of a system using our algorithm. If we assume a very high level of security, we will demand a security of 2 80 , i.e. l(ti) &gt; 80. Less conservative security considerations may allow to reduce this bound. Practical applications may only need to guarantee the security of the signature key for a small time like 2 years -today's credit cards incorporate the same security feature. In cases like these, l(ti) = 60 seems to be secure (the SETI@home project as one of the largest open attacks achieved about 2 61 operations <ref type="bibr" target="#b19">[19]</ref>). If less powerful attacks are assumed, this level might be lowered even further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>The fault models described in Section 3 show that the adversaries known in the literature can be described with few parameters. This description leads to a common model with proper mathematical formulations. The models always assume quite natural the most powerful adversary known. However, the power of the adversary is gradually reduced due to countermeasures in effect on the attacked smartcard.</p><p>The proposed algorithm develops known ideas into a form that can be proven to be secure within the presented framework with respect to the Bellcore attack. The only problem still unsolved by software mechanisms poses the fault model #1 (precise bit error attacks on an unprotected smartcard). If the power of the adversary is not reduced by hardware or software means, the adversary may perform a successful oracle attack circumventing the proposed countermeasure: as attacks like those described in <ref type="bibr" target="#b21">[21]</ref> or <ref type="bibr" target="#b17">[17]</ref> allow to set any specific bit to any specific value, we just need l(x) steps to determine the bit pattern, and hence the value, of any parameter x. We guess a bit value, set that bit and verify whether the final result and therefore the guess is correct or not. This reveals any attacked parameter and only uses the knowledge whether a fault occurred or not. No specific value is needed. No efficient software countermeasure protecting against such a fault can withhold that information from the adversary. Therefore, we insist that all currently proposed CRT-RSA implementations are broken by this attack. To prevent this fault model #1, smartcards must fight the cause of error rather than the effect on computation to reduce the power of the adversary significantly. Luckily, various but not all hardware manufacturers of cryptographic devices such as smartcard ICs have been aware of the importance of protecting their chips against intrusion. To do so they use carefully developed logic families, sensors, filters, regulators, etc. We are also investigating possible software countermeasures that use random bits to alter the parameters. As oracle attacks need to test several identical runs of an algorithm, this will effectively reduce the power of the adversary. We will elaborate this idea and present an enhanced algorithm in a different paper shortly.</p><p>speedup with residue number system immune against hardware fault cryptanalysis. In K. <ref type="bibr">Kim</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IS HARMLESS</head><p>Assume that an adversary attacks the CRT combination S = Sp+X •(Sq -Sp) mod Nt1t2 with X = pt1•((pt1) -1 mod qt2). X is assumed to be precomputed and stored on the card. A random error induced into X will result in a faulty value S instead of S:</p><formula xml:id="formula_8">S = Sp + X • (Sq -Sp) + e(X) • (Sq -Sp) mod Nt1t2 = S + e(X) • (Sq -Sp) mod Nt1t2, with e(X) ∈ [-X, 2 l(X) -1 -X].</formula><p>The additional term is the induced error. The countermeasure of Algorithm 2 will fail to detect this fault iff the addend is a multiple of both t1 and t2, i.e. if t1 • t2|e(X) • (Sq -Sp) mod Nt1t2 because both t1 and t2 are different primes. The latter property also implies that at least one of the factors must be a multiple of t1 and one (possibly the same) a multiple of t2.</p><p>As we consider the security independent from the adversary's choices for m, we first assume that neither t1 nor t2 divides (Sq -Sp). As e(X) is an equally distributed value from a consecutive interval, and t1 and t2 may be seen as independent values, the probability for t1|e(X) and t2|e(X) is at most 1/(t1 • t2).</p><p>For the message dependent question whether any of the primes ti divides (Sq -Sp), let Sq := c be fixed first (with 0 ≤ c &lt; qt2). In this case, there are pt1 integers in [c -pt1 + 1, c]. Of these numbers, only multiples of t1 are counted. Hence, there are at most (pt1)/t1 = p many such integers. Therefore, the probability of getting such an integer is ≤ p • 1/(pt1) = 1/t1. If we now count the overall number of possible integers for all choices of c, we determine</p><formula xml:id="formula_9">Pr[(Sq -Sp) = k • t1] = qt 2 -1 c=0 Pr[(Sq -Sp) = k • t1|Sq = c] • Pr[Sq = c] = qt 2 -1 c=0 Pr[(c -Sp) = k • t1 for some k] • 1 qt2 ≤ 1 qt2 • qt2 • 1 t1 = 1 t1 .</formula><p>As the same consideration holds for t2, we have a maximum of 2/ min(t1, t2) messages where the probability that a random error is not detected is significantly higher than 1/(t1 • t2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. UNDETECTABLE BYTE ERRORS</head><p>Similar to the analysis in Section 5.1, results for induced byte faults according to the byte error fault models #2 and #3 can be stated. This models an attack on a variable x as f (x) = x + b • 2 k with |b| ∈ 2 8, 0 ≤ k &lt; l(x) -7. All probabilities stated in the following will be over random choices of errors e(x) = b • 2 k with random b and k. Here, b will always denote a random byte value, that can be either positive or negative. The analysis of a byte error attack is completely analogous to the analysis for random errors presented in Section 5. The results of the analysis of byte errors are shown in Table <ref type="table" target="#tab_5">2</ref>. The displayed results are better than the results for random errors as analyzed in Section 5. This is not surprising, since the special structure of the induced error, i.e. b &lt; 2 8 , eliminates some possible attacks, i.e. attacks which require that the greatest common divisor of b and ti-1 is large, which is impossible for byte errors. On the other hand, the following two cases yield worse results, because they cannot be based on Assumption 1:</p><p>• attack on the stored variable ÔØ1</p><p>If a random byte fault is induced into pt1, such that pt1 is changed to pt1 + b • 2 k , an undetectable error requires that m d div (pt1 + b • 2 k ) ≡ 0 mod t1.</p><p>• attack on Ñ or the exponentiation's intermediate variable Any random byte fault induced during the exponentiation that causes an intermediate value y of Algorithm 3 to be changed into y + b • 2 k must fulfill the equation b • 2 k ≡ -2y mod t1 in order to induce an undetectable error. For messages m ≡ 0 mod t1, all faults yield an undetectable error. Comment. Both cases described above require the adversary to be able to construct malicious messages in order to be practical. However, the adversary has no information about t1, which is needed to construct a malicious message. Therefore, his best choice is to choose random m for input. In this case, his success probability is negligible.</p><p>The two special messages m = 0 and m = 1 need to be excluded from the set of possible inputs. Here, the same considerations as in Section 5 apply. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. UNDETECTABLE BIT ERRORS</head><p>The analysis of bit errors is completely analogous to the analysis in Section 5. Here, the precise bit error fault model #1 is considered, where a variable x is changed to f (x) = x ± 2 k with 0 ≤ k &lt; l(x). The results are exactly the same as in Table <ref type="table" target="#tab_5">2</ref>. Note that similar to the results in Appendix B, attacks on pt1 require that m d div (pt1 ± 2 k ) ≡ 0 mod t1 and attacks on m or the exponentiation's intermediate variable require that ±2 k ≡ -2y mod t1 in order to induce undetectable errors. An adversary cannot construct such messages unless he knows ti. As these values are secret, his chance of successfully choosing a random m that satisfies any of these conditions is negligible. Note that the results in this section only consider Bellcore attacks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1 .</head><label>1</label><figDesc>INTRODUCTION * Supported by the PaSCo Graduate School, Paderborn University.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :Fault Model # 1 :</head><label>11</label><figDesc>Figure 1: architectural sketch of a modern high-end smartcard</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 3 (</head><label>3</label><figDesc>modular exponentiation). Input. A message m ∈ N, a key d ≥ 3, a modulus pt1 Output. m d mod pt1 1 Let y := m 2 mod pt1 2 For i from l(d) -2 downto 1 do 3 L e ty0 := y 4 L e ty1 := y • m mod pt1 5 L e ty := y 2 d i mod pt1 6 Let y0 := y 7 Let y1 := y • m mod pt1 8 Let y := y d 0 mod pt1 9 output y Proof. If Algorithm 3 is attacked at the time when i = l, and the intermediate value y is altered, we have</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>dp, dq, t1, t2, et 1 and et 2 on the smartcard. With these parameter settings, it is easy to see that Algorithm 2 computes the correct signature if no error occurs.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Summarizing the success probabilities of a fault attack adversary</figDesc><table><row><cell>fault attack on</cell><cell>probability of the attack</cell></row><row><cell>line 1</cell><cell>3/ min(t 1 , t 2 )</cell></row><row><cell>line 2</cell><cell>3/ min(t 1 , t 2 )</cell></row><row><cell>line 3</cell><cell>2/ min(t 1 , t 2 )</cell></row><row><cell>line 4</cell><cell>0 in our fault model</cell></row><row><cell>line 5</cell><cell>0 in our fault model</cell></row><row><cell>line 6</cell><cell>0 in our fault model</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>, editor, Information Security and Cryptology -ICISC 2001, volume 2288 of LNCS, page 397 ff., 4th International Conference Seoul, Korea, December 6-7, 2001. 2001. Springer-Verlag. (journal version in IEEE Trans. on Comp., April 2003).</figDesc><table><row><cell>APPENDIX</cell></row><row><cell>A. PROVING THAT Ë ¼ = Ë + ( ) ¡ (ËÉ ËÈ )</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>fault attack on probability of the attack line</head><label></label><figDesc></figDesc><table><row><cell>1</cell><cell>3/t 1</cell></row><row><cell>line 2</cell><cell>3/t 2</cell></row><row><cell>line 3</cell><cell>1/(t 1 • t 2 )</cell></row><row><cell>lines 4 -6</cell><cell>0 in our fault model</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 .</head><label>2</label><figDesc>Summarizing the success probabilities of a fault attack adversary for byte faults</figDesc><table /></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Tamper resistance -a cautionary note</title>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second USENIX Workshop on Electronic Commerce</title>
		<meeting>the Second USENIX Workshop on Electronic Commerce<address><addrLine>Oakland, California</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1996">November 18-21 1996</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fault attacks on RSA with CRT: Concrete results and practical countermeasures</title>
		<author>
			<persName><forename type="first">C</forename><surname>Aumüller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hofreiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Cryptographic Hardware and Embedded Systems 2002 (CHES 2002), Hotel Sofitel</title>
		<meeting><address><addrLine>San Francisco Bay (Redwood City; USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">August 13-15 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Breaking public key cryptosystems on tamper resistant devices in the presence of transient faults</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Y</forename><surname>Jeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Narasimhalu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ngair</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security Protocols</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Christianson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Crispo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Lomas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Roe</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1362</biblScope>
			<biblScope unit="page" from="115" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Optimal asymmetric encryption</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in cryptology -EUROCRYPT &apos;94 (Perugia)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="92" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Blömer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>May</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>personal communication</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fault based cryptanalysis of the Advanced Encryption Standard (AES)</title>
		<author>
			<persName><forename type="first">J</forename><surname>Blömer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seventh International Financial Cryptography Conference</title>
		<meeting><address><addrLine>Guadeloupe, FWI</addrLine></address></meeting>
		<imprint>
			<publisher>Gosier</publisher>
			<date type="published" when="2003-01-27">2003. January 27-30), 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the importance of checking cryptographic protocols for faults</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Demillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT&apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Fumy</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="37" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the importance of eliminating errors in cryptographic computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Demillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="101" to="119" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Differential power analysis in the presence of hardware countermeasures</title>
		<author>
			<persName><forename type="first">C</forename><surname>Clavier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dabbous</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems -Proceedings of CHES 2000</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Worcester, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1965</biblScope>
			<biblScope unit="page" from="252" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Resistance against differential power analysis for elliptic curve cryptosystems</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Cryptographic Hardware and Embedded Systems (CHES&apos;99)</title>
		<title level="s">Lecture Notes in Computer Science, page 292 ff</title>
		<meeting>Cryptographic Hardware and Embedded Systems (CHES&apos;99)</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1717</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Statistics and secret leakage</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Naccache</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Financial Cryptography</title>
		<title level="s">Lecture Notes in Computer Science, page 157 ff</title>
		<meeting>Financial Cryptography</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1962</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast decipherment algorithm for RSA public-key cryptosystem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Couvreur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Quisquater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Letters</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">21</biblScope>
			<biblScope unit="page" from="905" to="907" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Some problems of &apos;Partitio Numerorum&apos; III: On the expression of a number as a sum of primes</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hardy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Littlewood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acta Mathematica</title>
		<imprint>
			<date type="published" when="1922">1922</date>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="1" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Observability analysis: Detecting when improved cryptosystems fail</title>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-M</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology -CT-RSA 2002</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<meeting><address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002-02-22">February 18-22, 2002. February 2002</date>
			<biblScope unit="volume">2271</biblScope>
			<biblScope unit="page" from="17" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Comments on some new attacks on cryptographic devices</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kaliski</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<date type="published" when="1997-07">July 1997</date>
		</imprint>
		<respStmt>
			<orgName>RSA Laboratories</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Chinks in digital armor -exploiting faults to break smart-card cryptosystems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science News</title>
		<imprint>
			<biblScope unit="volume">151</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="78" to="79" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Eddy current for magnetic analysis with active sensor</title>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Samyde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Esmart 2002 3rd edition</title>
		<meeting>Esmart 2002 3rd edition<address><addrLine>Nice, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-09">September 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Rankl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Effing</surname></persName>
		</author>
		<title level="m">Smart Card Handbook</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">SETI@home project. Current total statistics</title>
		<author>
			<persName><forename type="first">T</forename></persName>
		</author>
		<ptr target="http://setiathome.ssl.berkeley.edu/totals.html" />
		<imprint>
			<date type="published" when="2002-06-28">June 28th 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Method and apparatus for protecting public key schemes from timing and fault attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-11-23">1999. Nov. 23, 1999</date>
			<publisher>US Patent No</publisher>
			<biblScope unit="volume">991</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Optical fault induction attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Skorobogatov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Cryptographic Hardware and Embedded Systems 2002 (CHES 2002), Hotel Sofitel</title>
		<meeting><address><addrLine>San Francisco Bay (Redwood City), USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">August 13 -15, 2002, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Checking before output may not be enough against fault-based cryptanalysis</title>
		<author>
			<persName><forename type="first">S.-M</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="967" to="970" />
			<date type="published" when="2000-09">September 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A countermeasure against one physical cryptanalysis may benefit another attack</title>
		<author>
			<persName><forename type="first">S.-M</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">volume 2288 of LNCS, page 414 ff., 4th International Conference Seoul</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</editor>
		<meeting><address><addrLine>Korea</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001-12-06">2001. December 6-7, 2001. 2001</date>
		</imprint>
	</monogr>
	<note>Information Security and Cryptology -ICISC</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">S.-M</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><surname>Rsa</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
