<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Notion of Variability in Software Product Lines</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jilles</forename><surname>Van Gurp</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computing Science</orgName>
								<orgName type="institution">University of Groningen</orgName>
								<address>
									<addrLine>9700 AV The Netherlands</addrLine>
									<postBox>PO Box 800</postBox>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Bosch</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computing Science</orgName>
								<orgName type="institution">University of Groningen</orgName>
								<address>
									<addrLine>9700 AV The Netherlands</addrLine>
									<postBox>PO Box 800</postBox>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mikael</forename><surname>Svahnberg</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Software Engineering &amp; Computer Science</orgName>
								<orgName type="institution">Blekinge Technical University</orgName>
								<address>
									<postCode>372 25</postCode>
									<settlement>Ronneby</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Notion of Variability in Software Product Lines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9596CEF04D2DC2A90BC02CD7799E2818</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we discuss the notion of variability. We have experienced that this concept has so far been underdefined. Although, we have observed that variability techniques become increasingly important. A clear indication of this trend is the recent emergence of software product lines. Software product lines are large, industrial software systems intended to specialize into specific software products. Our contribution in this paper is that we provide the reader with a framework of terminology and concepts regarding variability. In addition, we present three recurring patterns of variability. Finally, we suggest a method for managing variability in software product lines.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over time, variability in software assets has become increasingly important in software engineering. Whereas software systems originally were relatively static and it was accepted that any required change would demand potentially extensive editing of the existing source code, this is no longer acceptable for contemporary software systems. Instead, although covering a wide variety in suggested solutions, newer approaches to software design share as a common denominator that the point at which design decisions concerning the supported functionality and quality requirements are made is delayed to later stages.</p><p>A typical example of such delayed design decisions is provided by software product lines. Rather than deciding on what product to build beforehand, in software product lines, a software architecture and set of components is defined and implemented that can be configured to match the requirements of a family of software products. A second example is the emergence of software systems that can dynamically adapt their behavior at run-time, either by selecting alternatives embedded in the software system or by accepting new code modules during operation, e.g. plug-and-play functionality. These systems are required to contain so-called 'dynamic software architectures' <ref type="bibr" target="#b19">[20]</ref>.</p><p>The consequence of the developments described above is that whereas earlier decisions concerning the actual functionality provided by the software system were made during requirement specification and had no effect on the software system itself, new software systems are required to employ various variability mechanisms that allow the software architects and engineers to delay the decisions concerning the variants to the point in the development cycle that optimizes overall business goals. For example, in some cases, this leads to the situation where the decision concerning some variation points is delayed until runtime, resulting in customer-or user-performed configuration of the software system. In other cases, variability can be handled before compilation, thus removing complexity of the final product.</p><p>Figure <ref type="figure">1</ref> illustrates how the variability of a software system is constrained during development. The space between the arrows of the funnel denotes the amount of variability in the system. When the development starts, there are no constraints on the system (i.e. any system can be built). This is visualized in Figure <ref type="figure">1</ref> by having inifinite space between the arrows. During development, the number of potential systems decreases (so there is increasingly less variability) until finally at run-time there is exactly one system (i.e. the running and configured system). At each step in the development, design decisions are made. Each decision constrains the number of possible systems (this is also argued in <ref type="bibr" target="#b12">[13]</ref>). When software product lines are considered, it is beneficial to delay some decisions so that products implemented using the shared product line assets can be varied. We refer to these delayed design decisions as variation points.</p><p>Figure <ref type="figure">1</ref> displays two stereotypical variability funnels. One represents a situation where a lot of variability is removed from the system early on (left), the other one rep-resents a situation where a lot of effort has been made to preserve variability until very late in the development process. Arguably, the left funnel system is easier to develop, however the right funnel system provides greater reusability and flexibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Software Product Lines</head><p>The goal of a software product line is to minimize the cost of developing and evolving software products that are part of a product family. A software product line captures commonalities between software products for the product family. By using a software product line, product developers are able to focus on product specific issues rather than issues that are common to all products.</p><p>The process of creating a specific software product using a software product line is referred to as product instantiation. Typically there are multiple relatively independent development cycles in companies that use software product lines: one for the software product line itself (often referred to as domain engineering); and one for each product instantiation.</p><p>Instantiating a software product line typically means taking a snapshot of the current software product line and using that as a starting point for developing a product. Basically, there are two steps in the instantiation: • Selection. In this phase the architecture is stripped from all unneeded functionality. Where possible preimplemented variants are selected for the variation points in the software product line.</p><p>• Extension. In this phase additional variants are created for the remaining variation points. From this we can see that there are two conflicting goals for a product line. On one hand a product line has to be flexible in order to allow for diverse product line instantiations. On the other hand a product line has to provide functionality that can be used out of the box to create products with a minimal effort. The conflict is that the process of customizing the product line is costly and consequently it is simpler to develop conrete products that fall within the scope of the product line if the product line offers just enough variabiliy. The scope of the product line widens if more variability is added to the product line. However this also increases the cost of product derivation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Problem statement</head><p>The increased use of variability mechanisms is a trend that has been present in software engineering for a long time, but typically ad-hoc solutions have been proposed and used. To the best of our knowledge, few attempts have been made to organize the existing approaches and mechanisms in a framework or taxonomy, nor suggested design principles for selecting appropriate techniques for achieving variability. The aim and contribution of this paper is to address this problem by providing a set of concepts and terminology as well as a process for managing variability. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.">Related work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Possible systems 8</head><p>by earlier work in our research group. One of the authors published a book about designing and using software product lines <ref type="bibr" target="#b4">[5]</ref>. This book was largely based on case studies and experience reports such as <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24]</ref>. From these reports we learned that evolution in software product lines is more complicated than in stand alone products because of the dependencies between the various products and because of the fact that there may be conflicting requirements between the different products. Empirical research such as <ref type="bibr" target="#b21">[22]</ref>, suggests that a software product line approach stimulates reuse in organizations. In addition, a follow up paper by <ref type="bibr" target="#b20">[21]</ref> provides empirical evidence for the hypothesis that organizations get most reuse benefits during the early phases of development. Because of this we believe it is worthwhile for software product line developing companies to invest time and money in performing methods such as in Section 4. Variability Patterns. We were not the first to look for variability patterns. In <ref type="bibr" target="#b15">[16]</ref>, patterns are used to model variability in product families. Unlike us, they limit themselves to the detailed design phase. Instead we try to cover the entire development process, thus gaining the advantage of discovering variation points earlier (as pointed out above).</p><p>Also in <ref type="bibr" target="#b12">[13]</ref>, a number of variability mechanisms are discussed. This book also discusses how subsequent design decicions remove variability from an architecture. However it fails to put these mechanisms in the context of a variation management method like we do. Also, variability is not linked to features. This is an important characteristic of our approach as it is an important means for early identification (i.e. before architecture design) of variability needs in the future system. Requirements. Our argument for introducing the external feature in Section 2 is based on <ref type="bibr" target="#b24">[25]</ref>. They argue that a requirement specification should contain nothing but information about the environment. The rationale behind this is that a requirement specification should not be biased by implementation. Since features are an interpretation of the requirements, there is a need to map implementation independent requirements to implementation aware features. Feature Modeling. Our extended feature graph is based on the work presented in <ref type="bibr" target="#b8">[9]</ref>. The main difference, aside from graphical differences, between our notation and theirs is the external feature and the addition of binding time. In <ref type="bibr" target="#b9">[10]</ref> the feature graph notation is used as an important asset in a method for implementing software product lines. Combined with our management method, the feature graph notation may be an important contribution to building software product lines.</p><p>Also related is the FODA method discussed in <ref type="bibr" target="#b13">[14]</ref>. In this domain analysis method, feature graphs play an important role. The FORM method presented in <ref type="bibr" target="#b14">[15]</ref> can be seen as an elaboration of this method. In this work feature graphs are recognized as a tool for identifying commonality between products. We take the point of view that it is more important to identify the variability between architectures than to identify the commonalities since the goal of developing a software product line is to be able to change the resulting system. In order to do that, the system has to be flexible enough to support the changes. The FORM method uses four layers to classify features (capability, operating environment, domain technology and implementation technique). We use a more fine-grained layering by using the different representations (architectural design, detailed design, source code, compiled code, linked code and running system) as abstractions. The advantage of this is that we can the relate variation points to different moments in the development. We consider this to be one of the contributions of our paper.</p><p>Our hierarchical feature graph bears some resemblance to the integral hierarchical and diversity model presented in <ref type="bibr" target="#b10">[11]</ref>. Unlike their model, we use variation points to model variability. The notion of variation points was first introduced in <ref type="bibr" target="#b11">[12]</ref>. Their model uses a similar layering as can be found in <ref type="bibr" target="#b0">[1]</ref>. In this paper, three distinct granularities of reuse are identified (component, class and algorithm) that correspond to our architecture design, detailed design and implementation levels. Feature interaction. Feature interaction can be modeled in a feature graph as dependencies between different features <ref type="bibr" target="#b9">[10]</ref>. Since features can be seen as incremental units of development <ref type="bibr" target="#b7">[8]</ref>, dependencies make it impossible to link all features to a single component or class. As a consequence, source code of large systems such as software product lines tends to be tangled. Features that are associated with several other features are called crosscutting features. Variability in such features is very hard to implement and often requires that a system is designed using for example design patterns <ref type="bibr" target="#b9">[10]</ref>. Methodology. Our method for managing variability bears some resemblance to the architecture development method outlined in <ref type="bibr" target="#b16">[17]</ref>. The first steps in this method are to select a few cases to find major abstractions. Our method of creating a feature graph based on a number of cases in order to find variation points can be seen as a refinement of these steps.</p><p>Another method that is related to ours is the FAST (Family-Oriented Abstraction, Specification and Translation) method that is discussed in <ref type="bibr" target="#b6">[7]</ref>. This empirically tested method uses the SCV (Scope, Commonality and Variability) analysis method to identify and document commonality and variability in a system. The result of this analysis is a textual document. A notation modeling variability in terms of features, such as provided in this paper, is not used in their work. An important lesson learned in our paper is that variation points should be bound early in order to save on development cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Remainder of the paper</head><p>In the remainder of this paper we will in discuss features as a useful abstraction for describing variability (Section 2). After that we will introduce our framework of terminology (Section 3). In Section 4 we provide a method for managing variability. In Section 5 we illustrate our terminology with a few examples of variability techniques in the Mozilla browser architecture and we conclude our paper in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Features: increments of evolution</head><p>One of the issues that need to be addressed is how to express variability. In this section we suggest that features are a useful abstraction for doing so. In <ref type="bibr" target="#b4">[5]</ref>, we define features as follows: "a logical unit of behavior that is specified by a set of functional and quality requirements". The point of view taken in this book is that a feature is a construct used to group related requirements ("there should at least be an order of magnitude difference between the number of features and the number of requirements for a product line member").</p><p>In other words, features are an abstraction from requirements. In our view, constructing a feature set is the first step of interpreting and ordering the requirements. In the process of constructing a feature set, the first design decisions about the future system are already taken. In <ref type="bibr" target="#b7">[8]</ref>, features are identified as units of incrementation as systems evolve. It is important to realize that there is an n to m relation between features and requirements. This means that a particular requirement (e.g. a performance requirement) may apply to several features and that a particular feature typically meets more than one requirement (e.g. a functional requirement and a couple of quality requirements).</p><p>A software product line provides a central architecture that can be evolved and specialized into concrete products. The differences between those products can be discussed in terms of features. Consequently, a software product line must support variability for those features that tend to differ from product to product.</p><p>In <ref type="bibr" target="#b8">[9]</ref> the following categorization of features is suggested: • Mandatory Features. These are the features that identify a product. E.g. the ability type in a message and send it to the mail server is essential for an email client application.</p><p>• Optional Features. These are features that, when enabled, add some value to the core features of a product. A good example of an optional feature for an email client is the ability to add a signature to each message. It is in no way an essential feature and not all users will use it but it is nice to have it in the product. • Variant Features. A variant feature is an abstraction for a set of related features (optional or mandatory). An example of a variant feature for the email client might be the editor used for typing in messages. Some email clients offer the feature of having a user configurable editor.</p><p>We have added a fourth category: • External Features. These are features offered by the target platform of the system. While not directly part of the system, they are important because the system uses them and depends on them. E.g. in an email client, the ability to make TCP connections to another computer is essential but not part of the client. Instead the functionality for TCP connections is typically part of the OS on which the client runs.</p><p>Our choice of introducing external features is further motivated by <ref type="bibr" target="#b24">[25]</ref>. In this work it is argued that requirements should not reflect on implementation details (such as platform specific features). Since features are abstractions from requirements, we need external features to link requirements to features. Using this categorization we have adapted the notation suggested by <ref type="bibr" target="#b8">[9]</ref> to support external features. In addition we have integrated the notion of binding time which we will discuss in detail in Section 3. An example of our enhanced notation can be found in Figure <ref type="figure" target="#fig_0">2</ref>. In this feature graph, the features of an email client are illustrated. The notation uses various constructs to indicate optional features; variant features in that exclude each other (xor) and variant features that may be used both (or).</p><p>The example in Figure <ref type="figure" target="#fig_0">2</ref> demonstrates how these different constructs can be used to indicate where variability is needed. The receive message feature, for instance, is a mandatory variant feature that has pop3 and imap as its variants. The choice as to which is used is delayed until runtime, meaning that users of the email client can configure to use either variant. Making this sort of details clear early on helps identify the spots in the system where variability is needed early on. The receive message feature might be implemented using an abstract receive message class that has two subclasses, one for each variant.</p><p>Our feature decomposition may give readers the impression that a conversion to a component design is straightforward. Unfortunately, due to a phenomenon called feature interaction, this is not true. Feature interaction is a well-known problem in specifying systems. It is virtually impossible to give a complete specification of a system using features because the features cannot be considered independently. Adding or removing a feature to a system has an impact on other features. In <ref type="bibr" target="#b7">[8]</ref>, feature interaction is defined as a characteristic of "a system whose complete behavior does not satisfy the separate specifications of all its features". In <ref type="bibr" target="#b9">[10]</ref>, the feature interaction problem is characterized as follows: "The problem is that individual features do not typically trace directly to an individual component or cluster of components -this means, as a product is defined by selecting a group of features, a carefully coordinated and complicated mixture of parts of different components are involved.". This applies in particular to so-called crosscutting features (i.e. features that are applicable to classes and components throughout the entire system).</p><p>However, constructing feature diagrams may help developers identify which parts of their system need to support variability. Since the only prerequisite for building a feature diagram is the requirement specification, this can be done very early in the development process. Because of this, we argue that feature diagrams are an important tool for the management of variability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Variability</head><p>Variability is the ability to change or customize a system. Improving variability in a system implies making it easier to do certain kinds of changes. It is possible to anticipate some types of variability and construct a system in such a way that it facilitates this type of variability. Reusability and flexibility have been the driving forces behind the development of such techniques as object orientation, object oriented frameworks and software product lines. Consequently these techniques allow us to delay certain design decisions to a later point in the development.</p><p>Now that we are able to identify variability using the feature graph notation, we can examine the notion of variability more closely. We have found that when discussing a concrete variation point in a system, certain characteristics reappear. In this section we will introduce these characteristics and introduce suitable terminology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Abstraction levels</head><p>During software development, a software system goes through a number of development phases. Each development phase has its own representations. One could say that development consists of transformations of these representations. E.g. a requirement specification is transformed in to a feature graph. After that, the feature graph forms the basis for the architecture design, which in turn forms the basis of the detailed design. After detailed design, source code is created. This source code is compiled, linked and finally run.</p><p>These different representations can be regarded as different abstraction levels of the system. Initially developers work with high-level models describing the requirements and features of the future system. Based on these highlevel representations, the first design decisions are taken and an architecture design is created, etc. Consequently development can be characterized as going from abstract representations of a system to more concrete detailed descriptions. During each transformation design decisions are taken. But more importantly, some design decisions are delayed and left open for variability deliberately. These open design decisions are referred to as variation points.</p><p>In Figure <ref type="figure" target="#fig_1">3</ref>, we have listed a number of representations Linux win32 compiletime a system goes through and the associated processes that transform these representations. Note that transformation processes are not equal to development phases. Although, these transformation processes recurr in most development methods (for example iterative methods such as for instance Extreme Programming <ref type="bibr" target="#b1">[2]</ref> but also waterfall model based methods) there are considerable differences between methods as to how much time and effort is spent on the various processes and when they are executed.</p><p>Especially for the later transformation processes it is very much technology dependent when these processes are executed. If we compare the use of an interpreted language like Python and a compiled language like C, we see that a C program is compiled and linked before product delivery whereas with Python compiling and linking are done while the system is executed. Yet, the variability techniques involved are very much the same. This also shows the advantage of an interpreted language: the user has more variability techniques at hand, simply because there are more transformations (i.e. compilation, linking) at run-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Variation point properties</head><p>Now that we have established that variability can be associated with different abstraction levels, we can introduce some additional properties of variability. A variation point can be in three, mutually exclusive states:</p><p>• Implicit. In Figure <ref type="figure">1</ref>, we illustrated how during development a system is constrained. In the early phases of development there are many open design decisions, and consequently a there is a lot of variability. However, these decisions have not been deliberately left open so there is not a single point in the system that we can denote as a variation point. We refer to this type of variation points as implicit. • Designed. As soon as the design decision is left open deliberately we say that the variation point is designed. • Bound. The intention of designing a variation point in a system is to be able to insert a variant at a later stage. As soon as this happens, the variation point is bound to a variant. Usually, when a variation point is designed there is also some idea about how and when variants are to be added to the system. In order to support this notion, we make a distinction between: • Open variation points. Each variation point is associated with a set of variants that can be bound to it. In an open variation point, new variants may be added to this set.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Transformation Process Representation</head><p>(UA) User Actions after linking takes place the variation point is closed since it is impossible to add new subclasses to the system without at least re-linking the system. It should be noted that in modern programming languages, linking may be done dynamically in which case the variability point remains open. The consequence of this is that sub classes may be added after product delivery.</p><p>Using the properties defined in this section, we can accurately describe variability in a system. We can also compare and evaluate different techniques of implementing variability. In Section 5, we will do this for a number of techniques used in the Mozilla architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Recurring patterns of variability</head><p>We have observed that when representation and development phase are abstracted from, variability follows certain patterns. To the best of our knowledge, variability always follows one of the following three patterns: Single variant. With this pattern of variability, there is a set of variants. At binding time a single variant is picked from this set of available variants. Single variants can be identified in feature diagrams by looking for the xor specialization construct. Optional variant. Optional variant is a special case of single variant since here the set of available variants only contains one variant and using it is optional. Optional variants are indicated in feature diagrams with an open circel on the relation end. Multiple parallel variants. When multiple parallel variants are used, the variation point is not permanently bound to a variant but rather, the variant selection and binding process is executed every time the variation point is accessed. This type of variation point can be recognized by the use of the or specialization construct in feature diagrams.</p><p>Note that combinations of these patterns are possible, (e.g. an optional single variant). Using these patterns of variability and the properties of variation points, we can make a classification of different variability realization techniques. Unfortunately, doing so is beyond the scope of this paper. However, we are currently working on a paper discussing a taxonomy of variability mechanisms based on the patterns described above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Variability management</head><p>Based on the previous sections, we suggest the following method for managing variability during the development that consists of the following steps:</p><formula xml:id="formula_0">• Identification • Constraining • Implementation</formula><p>• Managing the variants Identification of variability. The first step in the process is to identify where variability is needed. We suggest that the feature diagram notation we introduced in this paper is a good approach for doing so. From such a diagram, the important variation points can be identified. Constraining variability. Once a variation point has been identified, it needs to be constrained. After all the purpose is not to provide limitless flexibility but to provide just enough flexibility to suit the current and future needs of the system in a cost effective way. For constraining a variation point, the following activities need to take place: • Choose a binding time for each variation point. Should the user be able to choose the variant or can developers do this before product delivery? • Decide when and how variants are to be added to the system. • Pick a variability pattern for each point. If the feature diagram notation was used, this information can be obtained from the diagram. • Pick representation for realization of the variation point. Relevant for this decision is the way new variants are to be added. Implementing variability. Based on the previous a suitable realization technique needs to be selected. In Section 5 we provided the reader with a few examples of such techniques. However, there are many more techniques. We intend to provide a taxonomy of mechanisms and techniques in future work. Providing such a taxonomy here would be beyond the scope of this paper. Managing the variants. Depending on whether a variation point is open or not, some sort of variant management is needed. In some cases variants may be added manually. But it is also common for modern systems to download and install new variants over the internet. An example of a management in software is the XPInstall component in the Mozilla architecture (see Section 5). This component automates the downloading and installation of component variants. Especially when the multiple parallel variant pattern is used, a software management system will be needed to manage the variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Case study: Mozilla</head><p>As an example of variability in practice we analyzed the architecture of the Mozilla browser. The Mozilla browser has been developed as a so-called open source project. Consequently, information is readily available about its design. In addition, many variability techniques are applied in the Mozilla architecture, which makes it an interesting subject in the context of this paper.</p><p>The Mozilla project <ref type="bibr" target="#b17">[18]</ref> was started in 1998 when</p><p>Netscape <ref type="bibr" target="#b18">[19]</ref> decided to make the source code of Netscape 4 available under an open source license. About half a year later, it was decided to redevelop the browser from scratch since the original source code was tangled beyond repair. At the moment of writing, the first commercial product based on the Mozilla source code (i.e. Netscape 6) has been released. The main goal for the Mozilla project was not to provide a browser but rather a product line for building web applications. In the remainder of this section we will list a number of Mozilla features and analyze them, using the terminology and concepts introduced in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Mozilla features</head><p>Themes. An important feature of Mozilla is its support for user interface themes. Figure <ref type="figure">4</ref> illustrates this feature with a feature diagram. Mozilla implements the model view controller architectural pattern. Consequently the theme support variation point was designed during architectural design. As indicated by the feature diagram, this variation point is bound at run-time. By default two themes are bundled with Mozilla. However, users can download third party themes as well (i.e. the variation point is open at runtime). Since there has to be at least one theme (otherwise the application wouldn't have look and feel), the variation point follows the single variant pattern. Security. Security in Mozilla is handled through a component called Personal Security Manager (PSM). This is an optional. component that can be added to the system by users (see Figure <ref type="figure">5</ref>). The PSM provides such services as managing certificates for components, encryption/decryption of email messages etc. Variability for this feature was deliberately built into the architecture to allow third par-ties to add their own proprietary security components. Consequently, the security variation point was designed during architectural design. The variation point is bound at link-time. Although currently the PSM is the only available variant, the variation point is open at run-time (mozilla uses dynamic linking) so users can install a different security component should such an alternative become available. Network. A variation point that follows the multiple parallel variant pattern can be found in the way mozilla retrieves its files. Files are retrieved using the so-called Necko component (see Figure <ref type="figure">6</ref>). This component uses URIs (uniform resource identifier) and protocol handlers to retrieve information from websites, ftp sites, the local filesystem, a jar file or any other supported protocol. The Necko variation point is designed during architecture design, it is open during detailed design and since it is an instance of the multiple parallel variant pattern, it is bound at run-time on a per call basis (i.e. each time something needs to be retrieved, a suitable protocol handler is bound to the variation point). Java Support. Mozilla can optionally support Java. In Figure <ref type="figure" target="#fig_2">7</ref>, we illustrate this feature with a feature diagram. From this figure we learn that there is a variation point in the Mozilla architecture for Java Support. Also, the variation point combines both the single variant pattern and the optional variant pattern. The binding of this variation point is optional and the variants are external to the architecture and binding typically happens at linking time. In the feature graph we list three common Java implementations In the implementation of Mozilla, all interaction with the JVM (java virtual machine) is done through the OJI (open java interface) interface. Since this interface was introduced during architecture design, the Java support variation point became designed during architecture design. Furthermore, since users can install OJI compliant java implementations, the variation point is open at runtime. The system is capable of downloading and linking the necessary binary components without requiring a restart of the application. The XPCOM architecture is an instance of the broker pattern described in <ref type="bibr" target="#b5">[6]</ref>. This pattern provides a variability mechanism following the 'single variant pattern' we describe in this paper. Rather than hard coding references between components, components have to request the broker (i.e. XPCOM) for a reference of a suitable component. This allows developers to replace the called component without having to change the calling component. It also allows them to provide more than one component for a given interface. The OJI interface discussed above is an example of an application of this technique. The browser accesses the JVM through this interface. Consequently, any OJI compliant JVM can be plugged into the XPCOM architecture. Blackbox components. The main advantage of using the XPCOM architecture is that it forces developers to use XPCOM components in a blackbox fashion. The component bus constrains the use of a component to what has been specified in the IDL interfaces. This prevents that code of different components gets tangled too much. It also allows for delaying binding until linking rather than compilation. Since there are no source code dependencies between components, all dependency related variability is bound after compilation. Dynamic binding. Another important technique is dynamic binding. Without dynamic binding, the system would not be able to use new components at run-time. The system would have to be shut down, patched recompiled and restarted each time a new component is registered with the XPCOM bus. Dynamic linking gives users the flexibility to use all variability techniques that are associ-ated with linking. Traditionally, in statically linked systems these techniques had to be applied before product delivery, whereas with dynamic linking they can be applied after product delivery. Scripting. A technique that goes beyond the use of dynamic binding is the use of interpreted languages. The advantage of interpreted languages over compiled languages in the context of variability is that scripts can be changed at run-time. Domain specific languages. One prominent feature of the Mozilla architecture is the use of XML. Mozilla uses XML as a format for storing and exchanging structured data. Rather than specifying things like a user interface as C code or even javascript code, an XML representation called XUL is used. XUL is an example of a domain specific language (the domain in this case is user interfaces).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The underlying techniques</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Summary</head><p>In this section we explained some of the variability techniques applied in the Mozilla architecture. The variation points we selected in the Mozilla architecture illustrate the three patterns we identified. A fourth example (i.e. java support) shows that the patterns can be combined in various ways. Using our terminology in combination with the feature diagram, we are able to discuss these techniques on a high level and without discussing any implementation details.</p><p>One of the observations we can make about variability in the Mozilla architecture is that most of the variation points are bound at run-time. Because of this, Mozilla is highly customizable. A second observation is that most variation points are kept open until after product delivery. Both observations fit in with the trend of delaying design decisions we illustrated in Figure <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>The motivation for writing this paper was that we observed an increase in the application of various variability techniques. Furthermore we observed that these techniques are often applied in an adhoc fashion. This paper makes a number of contributions to address these issues: • The main contribution of this paper is that it provides a framework of terminology and concepts regarding variabilitiy. Our framework of terminology provides the reader with the tools to describe variability in a software system in terms of variation points and variants. In addition we associate binding times with variation points. To the best of our knowledge this paper is the first that generalizes the notion of variability in such a way.</p><p>• A second contribution of our paper is the introduction of recurring patterns of variability. • A third contribution is the variability management method described in Section 4. An integral part of our method is our adapted version of the feature graph notation first discussed in <ref type="bibr" target="#b8">[9]</ref>. Our adaptations consist of adding binding time information to the feature graph constructs and the addition of the external feature construct. Using our terminology, patterns and variability management method, software developers can recognize where variability is needed in their system early on and design their systems accordingly. Furthermore they can communicate their intentions with other developers and motivate design choices without going into detail about the implementation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2</head><label>2</label><figDesc>Figure 2 Example feature graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3</head><label>3</label><figDesc>Figure 3 Representation &amp; transformation processes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 7</head><label>7</label><figDesc>Figure 4 Theme support in Mozilla</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Of course the techniques used in Mozilla are not unique for Mozilla. Most of the mechanisms employed in Mozilla are based on common techniques. In this section we give a brief overview and indicate what their advantages are with respect to variability. The broker pattern. Mozilla has its own component architecture XPCOM which closely resembles COM (the component infrastructure included with MS Windows).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Figure 1 The Variability Funnel with early and delayed variability</head><label></label><figDesc></figDesc><table><row><cell>Possible systems 8</cell><cell>User expectations, technologies</cell></row><row><cell></cell><cell>Requirement Specification</cell></row><row><cell></cell><cell>Architecture Description</cell></row><row><cell></cell><cell>Design Documentation</cell></row><row><cell></cell><cell>Source code</cell></row><row><cell></cell><cell>Compiled code</cell></row><row><cell></cell><cell>Linked code</cell></row><row><cell></cell><cell>Running code</cell></row><row><cell>1</cell><cell></cell></row><row><cell></cell><cell>Software Product Lines. Our work was largely inspired</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>•</head><label></label><figDesc>Closed variation points. In a closed variation point, no new variants can be added. Usually, a variation point is only open in specific representations. An example of a variation point is an abstract class. This variation point is designed during detailed design. During detailed design it is also open since new subclasses can still be added during that phase. However,</figDesc><table><row><cell>User input, technology, expectations</cell></row><row><cell>(RC) Requirement Collection</cell></row><row><cell>Requirement Specification</cell></row><row><cell>(AD) Architecture Design</cell></row><row><cell>Architecture Description</cell></row><row><cell>(DD) Detailed Design</cell></row><row><cell>Design Documentation</cell></row><row><cell>(I) Implementation</cell></row><row><cell>Source Code</cell></row><row><cell>(C) Compilation</cell></row><row><cell>Compiled Code</cell></row><row><cell>(L) Linking</cell></row><row><cell>Linked Code</cell></row><row><cell>(E) Execution</cell></row><row><cell>Running Code</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Design and implementation of Hierarchical Software Systems with Reusable Components</title>
		<author>
			<persName><forename type="first">D</forename><surname>Batory</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>O'malley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="355" to="398" />
			<date type="published" when="1992-10">October 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Extreme Programming Explained</title>
		<author>
			<persName><forename type="first">K</forename><surname>Beck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Product-Line Architectures in Industry: A Case Study</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Software Engineering</title>
		<meeting>the 21st International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="1998-11">November 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Evolution and Composition of Reusable Assets in Product-Line Architectures: A Case Study</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Working IFIP Conference on Software Architecture</title>
		<meeting>the First Working IFIP Conference on Software Architecture</meeting>
		<imprint>
			<date type="published" when="1999-02">February 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Design &amp; Use of Software Architectures -Adopting and Evolving a Product Line Approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Pattern-Oriented Software Architecture -A System of Patterns</title>
		<author>
			<persName><forename type="first">F</forename><surname>Buschmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jäkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Meunier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Rohnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stahl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Commonality and variability in software engineering</title>
		<author>
			<persName><forename type="first">J</forename><surname>Coplien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="page" from="37" to="45" />
			<date type="published" when="1999-12">November/December 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Feature Requirements Models: Understanding Interactions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Gibson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Feature Interactions In Telecommunications IV</title>
		<meeting><address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Integrating feature modeling with the RSEB</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Griss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Favaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. Fifth International Conference on Software Reuse</title>
		<meeting>Fifth International Conference on Software Reuse<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Comput. Soc</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="388" to="376" />
		</imprint>
	</monogr>
	<note type="report_type">Cat. No.98TB100203</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Implementing Product line Features with Component Reuse</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Griss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 6th International Conference on Software Reuse, Vienna, Austria</title>
		<meeting>6th International Conference on Software Reuse, Vienna, Austria</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
		</imprint>
	</monogr>
	<note>to appear in</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">N Integral Hierarchy and Diversity Model for Describing Product Family architecture</title>
		<author>
			<persName><forename type="first">P</forename><surname>Van De Hamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Van Der Linden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saunders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sligte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ARES Workshop: Development and evolution of Software Architectures for Product Families</title>
		<meeting>the 2nd ARES Workshop: Development and evolution of Software Architectures for Product Families<address><addrLine>Berlin Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Software Reuse: Architecture, Process and Organization for Business success</title>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Griss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Software Architecture For Product Families: Putting Research into Practice</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jazayeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Der Linden</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000-05">May 2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Feature Oriented Domain Analysis (FODA) Feasibility Study</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Novak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Peterson</surname></persName>
		</author>
		<idno>CMU/SEI- 90-TR-21</idno>
		<imprint>
			<pubPlace>Pittsburgh, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Software Engineering Institute, Carnegy Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">FORM: a feature-oriented reuse method withdomain-specific architectures</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Software Engineering</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="354" to="355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Using Patterns to Model Variability in Product Families</title>
		<author>
			<persName><forename type="first">B</forename><surname>Keepence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mannion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Software</title>
		<imprint>
			<date type="published" when="1999-08">July/ August 1999</date>
			<biblScope unit="page" from="102" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The 4+1 View Model of Architecture</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Kruchten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Software</title>
		<imprint>
			<date type="published" when="1995-11">November 1995</date>
			<biblScope unit="page" from="42" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="http://www.mozilla.org/" />
		<title level="m">Mozilla website</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://www.netscape.com/" />
		<title level="m">Netscape website</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Self-Adaptive Software: An Architecturebased Approach</title>
		<author>
			<persName><forename type="first">P</forename><surname>Oreizy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Gorlick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Heimbigner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Medvidovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Quilici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Intelligent Systems</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An empirical study of a software reuse reference model</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Rine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information and Software Technology</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="47" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Investments in reusable software. A study of software reuse investment success factors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Rine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Sonnemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The journal of systems and software</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="17" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Evolution in Software Product Lines: Two Cases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Svahnberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Software Maintenance -Research and Practice</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="391" to="422" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Characterizing Evolution in Product Line Architectures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Svahnberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd annual IASTED International Conference on Software Engineering and Applications</title>
		<meeting>the 3rd annual IASTED International Conference on Software Engineering and Applications<address><addrLine>Anaheim, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IASTED/Acta Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="92" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Four Dark Corners of Requirements Engineering</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
