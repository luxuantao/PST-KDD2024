<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Program Synthesis from Polymorphic Refinement Types</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nadia</forename><surname>Polikarpova</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">MIT CSAIL</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Ivan</forename><surname>Kuraj</surname></persName>
							<email>ivanko@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">MIT CSAIL</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">MIT CSAIL</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Program Synthesis from Polymorphic Refinement Types</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1A5F1891B5615CF595321A94F186EF70</idno>
					<idno type="DOI">10.1145/2908080.2908093</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs; I.2.2 [Automatic Programming]: Program Synthesis General Terms Languages</term>
					<term>Verification Program Synthesis</term>
					<term>Functional Programming</term>
					<term>Refinement Types</term>
					<term>Predicate Abstraction</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a method for synthesizing recursive functions that provably satisfy a given specification in the form of a polymorphic refinement type. We observe that such specifications are particularly suitable for program synthesis for two reasons. First, they offer a unique combination of expressive power and decidability, which enables automatic verification-and hence synthesis-of nontrivial programs. Second, a type-based specification for a program can often be effectively decomposed into independent specifications for its components, causing the synthesizer to consider fewer component combinations and leading to a combinatorial reduction in the size of the search space. At the core of our synthesis procedure is a new algorithm for refinement type checking, which supports specification decomposition.</p><p>We have evaluated our prototype implementation on a large set of synthesis problems and found that it exceeds the state of the art in terms of both scalability and usability. The tool was able to synthesize more complex programs than those reported in prior work (several sorting algorithms and operations on balanced search trees), as well as most of the benchmarks tackled by existing synthesizers, often starting from a more concise and intuitive user input.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The key to scalable program synthesis is modular verification. Modularity enables the synthesizer to prune candidates for different subprograms independently, whereby combinatorially reducing the size of the search space it has to consider. This explains the recent success of type-directed approaches to synthesis of functional programs <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b26">27]</ref>: not only do ill-typed programs vastly outnumber well-typed ones, but more importantly, a type error can be detected long before the whole program is put together.</p><p>Simple, coarse-grained types alone are, however, rarely sufficient to precisely describe a synthesis goal. Therefore, existing approaches supplement type information with other kinds of specifications, such as input-output examples <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b26">27]</ref>, or pre-and post-conditions <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>. Alas, the corresponding verification procedures rarely enjoy the same level of modularity as type checking, thus fundamentally limiting the scalability of these techniques.</p><p>In this work we present a novel system that pushes the idea of type-directed synthesis one step further by taking advantage of refinement types <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b32">33]</ref>: types decorated with predicates from a decidable logic. For example, imagine that a user intends to synthesize the function replicate, which, given a natural number n and a value x, produces a list that contains n copies of x. In our system, the user can express this intent by providing the following signature:</p><formula xml:id="formula_0">replicate :: n : Nat → x : α → {ν : List α | len ν = n}</formula><p>Here, the return type is refined with the predicate len ν = n, which restricts the length of the output list to be equal to the argument n; Nat is a shortcut for {ν : Int | ν ≥ 0}, the type of integers that are greater or equal to zero <ref type="foot" target="#foot_0">1</ref> . Given this signature, together with the definition of List and a standard set of integer components (which include zero, decrement function, and inequalities), our system produces a provably correct implementation of replicate, shown in Fig. <ref type="figure" target="#fig_0">1</ref>, within fractions of a second.</p><p>We argue that refinement types offer the user a convenient interface to a program synthesizer: the signature above is only marginally more complex than a conventional ML or Haskell type. Contrast that with example-based synthesis, which would require a conventional type together with multiple input-output pairs, and in return provide much weaker correctness guarantees.</p><p>The replicate example is a perfect illustration of the power of parametric polymorphism for specifying program behavior. Even though the signature in Fig. <ref type="figure" target="#fig_0">1</ref> never says explicitly that each element of the output list must equal x, it nevertheless captures the semantics of replicate completely: since the function knows nothing about the type parameter α, it has no way of constructing any values of this type other than x. This surprising expressiveness of polymorphic types had been long known <ref type="bibr" target="#b39">[40]</ref>, but combined with refinements, it enables full-fledged higherorder reasoning within the type system: a caller of replicate can instantiate α with any refinement type, obtaining the fact that whenever x has a certain property, every element of the output list shares that same property.</p><p>Perhaps surprisingly, prior work on liquid types <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b36">37]</ref> has shown that this type of higher-order reasoning can be fully automated for a large class of programs and properties. The liquid type inference algorithm <ref type="bibr" target="#b32">[33]</ref> uses a combination of Hindley-Milner unification and least-fixpoint Horn clause solver based on predicate abstraction to discover refined instantiations for polymorphic types and ultimately reduce verification to proving quantifier-free formulas over simple refinement predicates, efficiently decidable by SMT solvers. The unique combination of expressive power and decidability offered by polymorphic refinement types makes them ideal for program synthesis.</p><p>Technical Challenges. Unfortunately, liquid type inference cannot be applied out of the box to the context of synthesis. Designed for the setting where, given a program, the goal is to construct its type, the inference algorithm starts from the leaves of the program, whose types are known, and propagates type information bottom-up, constructing types of terms from the types of their subterms. In program synthesis, however, the setting is different: here the top-level type is given, and the goal is to construct the program. One way to do so is to exhaustively explore program candidates, performing liquid type inference on each one, and then checking if the inferred type matches the given specification. While this approach does rule out many ill-typed partial programs, it fails to take advantage of the specification for guiding the search. A more promising approach would propagate type information top-down from the specification, using it to filter out irrelevant partial solutions. Some program terms naturally support decomposing a specification into independent requirements for their subterms. For example, given a goal type T and assuming that the top-level construct of the program is a conditional with a known guard, we can pass T on to the two branches of the conditional, together with the appropriate path conditions derived from the guard, and proceed to check (or synthesize) them completely independently. Unfortunately, for other program terms there might be infinitely many ways to precisely decompose a specification. Take a function application, f x: the specification f x :: Nat can be satisfied by requiring that f subtract one and x be positive, or that f add one, and x be greater than negative one, and so on. The challenge in this case is to find an over-approximate decomposition: that is, construct requirements on f and x that are necessary but generally not sufficient for the correctness of f x, yet are strong enough to filter out many incorrect subterms.</p><p>To address this challenge, we propose a new type checking mechanism for refinement types, which we dub local liquid type checking. At the heart of the new mechanism is a type system inspired by bidirectional type checking <ref type="bibr" target="#b29">[30]</ref>. Bidirectional systems interleave top-down and bottom-up propagation of type information depending on the syntactic structure of the program; in this work we extend the bottom-up phase of bidirectional checking with top-down propagation of over-approximate type information, resulting in a round-trip type checking mechanism, which promotes modular checking of function applications. Additionally, we equip the type system with a novel liquid abduction rule, which enables modular checking of branching terms.</p><p>Refinement type checking involves solving subtyping constraints over unknown refinement types. The modularity requirement precludes our system from using the two techniques employed to this end by liquid type inference-Hindley-Milner unification and the least-fixpoint Horn solver-since both techniques are designed to work on complete programs and propagate type information bottom-up. Instead, local liquid type checking incorporates an algorithm for solving subtyping constraints incrementally, as it analyzes different parts of the program. Most notably, top-down propagation requires finding the greatest fixpoint solution to unknown refinements instead of the least, which is known to be fundamentally more expensive; we propose a practical implementation for this fixpoint computation, which we call MUSFIX, inspired by an existing algorithm for enumerating minimal unsatisfiable subsets (MUSes) <ref type="bibr" target="#b21">[22]</ref>.</p><p>Results. We have combined local liquid type checking and exhaustive enumeration of program terms in a prototype program synthesizer called SYNQUID (for "SYNthesis with liQUID types"), which we evaluated on 64 synthesis problems from a variety of sources. The implementation, the benchmarks, and a web interface for SYNQUID are available from the tool repository <ref type="bibr" target="#b30">[31]</ref>.</p><p>Our evaluation indicates that the techniques described above work well for synthesizing programs that manipulate lists and trees, as well as data structures with complex invariants and custom user-defined data structures. SYNQUID was able to synthesize programs that are more complex than those previously reported in the literature, including five different sorting algorithms, and manipulations of binary search trees, AVL trees, and Red-Black trees. The evaluation also shows that the modularity features of local liquid type checking and the MUSFIX solver are crucial for the performance of the system. We compare our system with the existing synthesizers based on input-output examples <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b26">27]</ref>, and Hoare-style verification <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>, and demonstrate that SYNQUID can handle the majority of its competitors' most challenging benchmarks, taking a similar or shorter amount of time. In addition, compared with the example-based tools, SYNQUID's specifications are usually more concise and the generated solutions are provably correct; compared with the tools based on Hoare-style reasoning, SYNQUID can verify (and thus synthesize) more complex programs thanks to automatic refinement inference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview</head><p>SYNQUID operates within a core ML-like language featuring conditionals, algebraic datatypes, pattern matching, parametric polymorphism, and fixpoints. We equip the language with general decidable refinement types, closely following the liquid types framework <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b35">36]</ref>. The type system includes refined base types of the form {B | ψ}, where ψ is a refinement predicate over the program variables and a special value variable ν, which does not appear in the program. Base types can be combined into dependent function types of the form x : T x → T 2 , where x may appear in the refinement predicates of T 2 . Our framework is agnostic to the exact logic of refinement predicates as long as validity of their boolean combinations is decidable; our prototype implementation uses the quantifier-free logic of arrays 2 , uninterpreted functions, and linear integer arithmetic, which is sufficient for all the examples and benchmarks in this paper.</p><p>A synthesis problem is defined by (1) a goal refinement type T (2) a typing environment Γ and (3) a set of logical qualifiers Q. A solution to the synthesis problem is a program term t that has the type T in the environment Γ. The environment contains type signatures of components available to the synthesizer (which may include datatype constructors, "library" functions, and local variables) as well as any path conditions that can be assumed when synthesizing t. Qualifiers are predicates from the refinement logic used as building blocks for unknown refinements and branch guards. Our system extracts an initial set of such predicates automatically from the goal type and the types of components; for all our experiments, the automatically extracted qualifiers were sufficient to synthesize all the necessary refinements, but in general the user might have to provide additional predicates.</p><p>Given a synthesis problem, SYNQUID constructs a candidate solution, by either by either picking a component in Γ or decomposing the problem into simpler subproblems and recursively obtaining a solution t i to each one. Since the decomposition is generally incomplete, a candidate obtained by combining t i 's is not guaranteed to have the desired type T ; to check if the candidate is indeed a solution, the system generates a subtyping constraint. If the constraint cannot be satisfied, the system backtracks to pick a different combination of solutions 2 Arrays are used to model sets.</p><p>to subproblems (or a different decomposition altogether); the stronger the sub-goals produced during decomposition, the less SYNQUID has to backtrack. The rest of the section illustrates the details of this procedure and showcases various features of the specification language on a number of examples.</p><p>Example 1: Recursive Programs and Condition Abduction. We first revisit the replicate example from the introduction. We assume that the set of available components includes functions 0, inc and dec on integers, as well as a list datatype whose constructors are refined with length information, expressed by means of an uninterpreted function (or measure) len.</p><formula xml:id="formula_1">0 :: {Int | ν = 0} inc :: x: Int → {Int | ν = x + 1} dec :: x: Int → {Int | ν = x -1} termination measure len :: List β → Nat data List β where Nil :: {List β | len ν = 0} Cons :: β → xs: List β → {List β | len ν = len xs + 1}</formula><p>Measure len also serves as the termination metric on lists (denoted with the termination keyword above): it maps lists to a type that has a predefined well-founded order in our language and thus enables termination checks for recursion on lists.</p><p>For the rest of the section, let us fix the set of logical qualifiers Q to { ≤ , = }, where is a placeholder that can be instantiated with any program variable or ν.</p><p>Given the specification n : Nat → x : α → {List α | len ν = n} SYNQUID picks λ-abstraction as the top-level construct, and creates a synthesis subproblem for its body with a simpler goal type {List α | len ν = n}. The system need not consider other choices of the top-level construct, since every terminating program has an equivalent β-normal η-long form, where all functions are fully applied and the head of each application is a variable; moreover, the above decomposition is precise, since any solution to the subproblem will satisfy the top-level goal.</p><p>As part of the decomposition, the arguments n : Nat and x : α are added to the environment, together with the function replicate itself, to account for the possibility that it may be recursive. In order to ensure termination of recursive calls, the system weakens the type of replicate in the environment to n : {Int | 0 ≤ ν &lt; n} → x : α → {List α | len ν = n } demanding that the first argument be strictly decreasing. SYN-QUID picks n as the termination metric in this case, since it is the only argument whose type has an associated well-founded order.</p><p>In the body of the function, the top-level construct might be a branching term. Rather than exploring this possibility explicitly, SYNQUID adds a fresh predicate unknown P 0 as a path condition to the environment, and then searches for a branch-free program term that satisfies the specification assuming P 0 . Each candidate branch-free term t is validated by solving a subtyping constraint; as part of this process, SYNQUID discovers the weakest P 0 that makes t satisfy the specification. In case t is valid unconditionally, the weakest such P 0 is True, and no branch is generated.</p><p>Suppose the first branch-free term that SYNQUID considers is Nil; this choice results in a subtyping constraint n : Nat;x : α;P 0 {List β | len ν = 0} &lt;: {List α | len ν = n} where β is a free type variable. The constraint imposes two requirements: (i) the shapes of the two types (i.e. their underlying unrefined types) must have a unifier <ref type="bibr" target="#b28">[29]</ref> and (ii) the refinements of the subtype must subsume those of the supertype under the assumptions encoded in the environment. The constraint above gives rise to a unifier [β → {α | P 1 }] (where P 1 is a fresh predicate unknown) and two Horn constraints: P 0 ∧ P 1 ⇒ and 0 ≤ n ∧ P 0 ∧ len ν = 0 ⇒ len ν = n. SYNQUID uses the MUSFIX Horn solver (Sec. 3.6) to find the weakest assignment of liquid formulas to P 0 and P 1 that satisfies both Horn constraints. A liquid formula is a conjunction of atomic formulas, obtained by replacing -placeholders in each qualifier in Q with appropriate variables. If for some P i no valid assignment exists, or the weakest valid assignment is a contradiction, the candidate program is discarded.</p><p>In our example, MUSFIX discovers the weakest assignment L = [P 0 → n ≤ 0,P 1 → ], effectively abducing the necessary branching condition. Since the condition is not trivially true, the system proceeds to synthesize the remaining branch under the path condition ¬(n ≤ 0). A similar strategy for generating branching programs has been successfully employed in several existing synthesis tools <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref> and is commonly referred to as condition abduction. Each condition abduction technique faces the challenge of searching a large space of potential conditions efficiently; our approach, which we dub liquid abduction, addressed this challenge by restricting conditions to liquid formulas and using MUSFIX to explore the space of liquid formulas efficiently.</p><p>The remaining branch has to deal with the harder case of n &gt; 0. When enumerating candidates for this branch, SYNQUID eventually decides to apply the replicate component (that is, make a recursive call), and searches for the parameters via recursive application of the synthesis procedure. At this point, the strong precondition on the argument m, 0 ≤ ν &lt; n, which arises from the termination requirement, enables filtering candidate arguments locally, before synthesizing the rest of the branch. In particular, the system will discard the candidates n and inc n right away, since they fail to produce a value strictly less than n.</p><p>Example else Node y (insert x l) r Pattern matching in this example is synthesized using a special case of liquid abduction: type-checking the term Node x Empty Empty against the goal type {BST α | keys ν = keys t + [x]}, causes the system to abduce the condition keys t = [], which implies a match on t.</p><p>The challenging aspect of this example is reasoning about sortedness. For example, for the term Node y l (insert x r) to be type-correct, the recursive call must return the type BST {α | y &lt; ν}. This type does not appear explicitly in the userprovided signature for insert; in fact, verifying this program requires discovering a nontrivial inductive invariant of insert (that adding a key greater than some value z into a tree with keys greater than z again produces a tree with keys greater than z), which puts this and similar examples beyond reach of existing synthesizers based on Hoare-style reasoning <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>In our framework, this property is easily inferred by the Horn constraint solver in combination with polymorphic recursion. When insert is added to the environment, its type is generalized to ∀β.x : β → u : {BST β | size u &lt; size t} → {BST β | keys ν = keys t + {x}}. At the site of the recursive call, the precondition of Node y l imposes a constraint that simplifies to BST β &lt;: BST {α | y &lt; ν}, which leads to instantiating</p><formula xml:id="formula_2">[β → {α | P 0 }] and [P 0 → y &lt; ν].</formula><p>Importantly, due to round-trip type checking (Sec. 3.2), this assignment is discovered before the two arguments to insert are synthesized, which has the effect of propagating the requirement imposed by Node top-down through the application of insert onto its arguments. In particular, using the goal type {α | y &lt; ν} for the first argument of insert, the system can immediately discard the candidate y, while trying x succeeds and leads to the abduction of the branch condition y ≤ x. As our evaluation shows, disabling this type of early filtering increases the synthesis time for this example from less than two seconds to over two minutes.</p><p>Example 3: Abstract Refinements. Using refinement types as an interface to synthesis raises the question of their expressiveness. Restricting refinements to decidable logics fundamentally limits the class of programs they can fully specify, and for other programs writing a refinement type might be possible but cumbersome compared to providing a set of input-output examples or a specification in a richer language. The previous examples suggest that refinement types are effective for specifying programs that manipulate data structures with nontrivial universal and inductive invariants. In this example we demonstrate how extending the type system with abstract refinements allows us to express a wider class of properties, for example, talk about the order of list elements.</p><p>Abstract refinements, proposed in <ref type="bibr" target="#b35">[36]</ref>, enable explicit quantification over refinements of datatypes and function types. For example, a list datatype can be parameterized by a binary relation r that must hold between any in-order pair of elements in the list:</p><formula xml:id="formula_3">data RList α &lt;r ::α → α → Bool&gt; where Nil :: RList α &lt;r&gt; Cons :: x: α → RList {α | r x ν} &lt;r&gt; → RList α &lt;r&gt;</formula><p>On the one hand this enables concise definitions of lists with various inductive properties as instantiations of RList:</p><formula xml:id="formula_4">IList α = RList α &lt; λ x λ y . x ≤ y&gt; --Increasing list UList α = RList α &lt; λ x λ y . x = y&gt; --Unique list List α = RList α &lt; λ x λ y . True&gt; --Unrestricted list</formula><p>On the other hand, making list-manipulating functions polymorphic in this relation, provides an elegant way to specify orderrelated properties. Consider the following type for list reversal:</p><formula xml:id="formula_5">reverse :: &lt;r ::α → α → Bool&gt; . xs: RList α &lt;r&gt; → {RList α &lt; λ x λ y . r y x&gt; | len ν = len xs}</formula><p>It says that whatever relation holds between every in-order pair of elements of the input list, also has to hold between every outof-order pair of elements of the output list. This type does not restrict the applicability of reverse, since at the call site r can always be instantiated with True; the implementation of reverse, however, has to be correct to any value of r, which leaves the synthesizer no choice but reverse the order of list elements. Given the above specification and a component that appends an element to the end of the list (specified in a similar fashion), SYNQUID synthesizes the standard implementation of list reversal.</p><p>Example 4: Higher-Order Combinators and Auxiliary Function Discovery. Complex programs might require recursive auxiliary functions. Discovering specifications for such functions automatically is a difficult task, akin to lemma discovery in theorem proving <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b24">25]</ref>, which largely remains an open problem. SYNQUID expects users to provide the high-level insight about a complex algorithm in the form of auxiliary function signatures. For example, if the goal is to synthesize a list sorting function with the following signature sort ::</p><formula xml:id="formula_6">xs: List α → {IList α | elems ν = elems xs}</formula><p>(where elems denotes the set of list elements), the user can express the insight behind different sorting algorithms by providing different auxiliary functions: insertion into a sorted list for insertion sort, splitting and merging for merge sort, or partitioning and concatenation for quick sort. Naturally, the implementation of the auxiliary functions can in turn be synthesized, but coming up with their specification is the creative step that generally requires user interaction, and can be considered a major hurdle on the path to fully automatic synthesis.</p><p>It turns out, however, that replacing general recursion with higher-order combinators such as map and fold-a style widely used and highly encouraged in functional programming-makes it possible to infer requirements on the auxiliary function from the specification of the main program. This is one of the main insights behind the synthesizer λ 2 <ref type="bibr" target="#b11">[12]</ref>, which relies on hardcoded rules for propagating input-output examples top-down through common combinators. SYNQUID supports this topdown propagation of specifications out of the box thanks to the combination of refinement types and polymorphism.</p><p>Consider the following type for function foldr, which folds a binary operation f over a list ys from right to left:</p><formula xml:id="formula_7">foldr ::&lt;p :: List β → γ → Bool&gt; . f: (t: List β → h: β → acc: {γ | p t ν} → {γ | p (Cons h t) ν}) → seed: {γ | p Nil ν} → ys: List β → {γ | p ys ν}</formula><p>The shape of this type is slightly different from the usual signature of foldr: the operation f takes an extra ghost argument t, which denotes the part of the list that has already been folded <ref type="foot" target="#foot_1">3</ref> . The type of is parametrized by a binary relation p that foldr establishes between the input list ys and the output; it requires that the relationship hold between the empty list and the seed, and that applying f to a head element h and the result of folding a tail list t yield a result that satisfies the relationship with Cons h t (in other words, p plays the role of a loop invariant). Note that folding a list left-to-right (foldl) requires a more complex specification that cannot currently be expressed within the SYNQUID type system.</p><p>What happens if we ask SYNQUID to synthesize sort, while providing foldr as the only component? When trying out an application of foldr, round-trip type checking handles its higher-order argument, f, in a special way, since in our type system, as in <ref type="bibr" target="#b32">[33]</ref>, f cannot appear in the result type of foldr. Consequently, the exact value of f is not required to determine the type of the application, which gives SYNQUID the freedom to synthesize it independently from the rest of the program.</p><p>The tool quickly figures out that foldr ?? Nil xs has the required type {IList α | elems ν = elems xs}, given the following assignment to foldr's type and predicate variables: [β → α,γ → IList α,p → λas.λbs.elems bs = elems as]. Now that SYNQUID comes back to the task of filling in the first argument of foldr, its required type has been determined entirely as The next section gives a formal account of the SYNQUID language and type system, and details its modular type checking mechanism, which enables scalable synthesis.</p><formula xml:id="formula_8">t: List α → h: α → acc: {IList α | elems ν = elems t} → {IList α | elems ν = elems (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The SYNQUID Language</head><p>The central goal of this section is to develop a type checking algorithm for a core programming language with refinement types that is geared towards candidate validation in the context of synthesis. This context imposes two important requirements on the type checking mechanism which are necessary for the synthesis procedure to be automatic and scalable. The first one has to do with the amount of type inference: the mechanism can expect top-level type annotations-this is how users specify synthesis goals-but cannot rely on any annotations beyond that; in particular, the types of all polymorphic instantiations and arguments of anonymous functions must be inferred. The second requirement is to detect type errors locally: intuitively, if a subterm of a program causes a type error independently of its context, the algorithm should be able to report that error without analyzing the context.</p><p>We build our type checking mechanism as an extension to the the liquid types framework <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b32">33]</ref>, which uses a combination of Hidley-Milner unification and a Horn solver to infer refinement types. The original liquid type inference algorithm is not designed for synthesis, and thus makes different trade-offs: in particular it does not satisfy the locality requirement. Our type checking mechanism achieves locality based on three key ideas. First, we apply bidirectional type checking <ref type="bibr" target="#b29">[30]</ref> to refinement types and reinforce it with additional top-down propagation of type information, arriving at round-trip type checking (Sec. 3.2); we then further improve locality of rules for for function applications and branching statements (Sec. 3.4). Second, we develop a new algorithm for converting subtyping constraints into horn clauses, which is able to do so incrementally as the constraints are issued before analyzing the whole program (Sec. 3.5). Finally, we propose a new, efficient implementation for a greatestfixpoint Horn solver (Sec. 3.6). In the interest of space we omit abstract refinements (see Sec. 2) from the formalization; <ref type="bibr" target="#b35">[36]</ref>   shown that integrating this mechanism into the type system that already supports parametric polymorphism is straightforward. In Sec. 3.7 we derive synthesis rules from the modular type checking rules; in doing so we follow previous work on typedirected synthesis <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b26">27]</ref>, which has shown how to turn type checking rules for a language into synthesis rules for the same language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Syntax and Types</head><p>Fig. <ref type="figure" target="#fig_2">2</ref> shows the syntax of the SYNQUID language.</p><p>Terms. Unlike previous work, we differentiate between the languages of refinements and programs. The former consists of refinement terms ψ, which have sorts ∆; the exact set of interpreted symbols and sorts depends on the chosen refinement logic. We refer to refinement terms of the Boolean sort B as formulas.</p><p>The language of programs consists of program terms t, which we split, following <ref type="bibr" target="#b26">[27]</ref> into elimination and introduction terms (E-terms and I-terms for short). Intuitively, E-terms-variables and applications-propagate type information bottom-up, composing a complex property from properties of their components; I-terms propagate type information top-down, decomposing a complex requirement into simpler requirements for their components. Note that conditional guards, match scrutinees, and left-hand sides of applications are restricted to E-terms. We</p><formula xml:id="formula_9">Well-Formed Types Γ T WF-SC Γ;ν : B ψ Γ {B | ψ} WF-CTX Γ;C T Γ let C in T WF-FO Γ {B | ψ} Γ;x : {B | ψ} T Γ x : {B | ψ} → T WF-HO Tx non-scalar Γ Tx Γ T Γ Tx → T Subtyping Γ T &lt;: T &lt;:-SC Γ B &lt;: B Valid( Γ ψ⇒ψ ∧ψ ⇒ ψ ) Γ {B | ψ} &lt;: {B | ψ } &lt;:-FUN Γ Ty &lt;: Tx Γ;y : Ty [y/x]T &lt;: T Γ x : Tx → T &lt;: y : Ty → T &lt;:-DT Γ Ti &lt;: T i Γ D Ti &lt;: D T i &lt;:-REFL Γ B &lt;: B Figure 3.</formula><p>Well-formedness and subtyping.</p><p>further separate I-terms into branching terms-conditionals and matches-and function terms-abstractions and fixpoints-and disallow branching terms on the right-hand side of application. This normal form is required to enable precise and efficient local type checking, as explained below. It does not fundamentally restrict the expressiveness of the language: every terminating program in lambda calculus can be translated to SYNQUID by first applying a standard β-normal η-long form <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b26">27]</ref> and then pushing branching terms outside of applications, guards, and scrutinees. Types and Schemas. A SYNQUID type is either a scalarbase type refined with a formula-or a dependent function type. Base types include primitives, type variables, and user-defined datatypes with zero or more type parameters. Datatype constructors are represented simply as functions that must have the type ∀α 1 ...α m .T 1 → ... → T k → D α 1 ...α m . A contextual type is a pair of a sequence of variable bindings and a type that can mention those variables; contextual types are useful for precise type checking of applications, as explained in Sec. 3.2.</p><p>SYNQUID features ML-style polymorphism, where type variables are universally quantified at the outermost level to yield type schemas. Unlike ML, we restrict type variables to range only over scalars, which gives us the ability to determine whether a type is a scalar, even if it contains free type variables. We found this restriction not to be too limiting in practice.</p><p>Environments, Well-Formedness, and Subtyping. A typing environment Γ is a sequence of variable bindings x : T and path conditions ψ; we denote conjunction of all path conditions in an environment as P(Γ). A formula ψ is well-formed in the environment Γ, written Γ ψ, if it is of a Boolean sort and each of its free variables is bound in Γ to a type that is consistent with its sort in ψ. Well-formedness extends to types as shown in Fig. <ref type="figure">3</ref>. Note the two different rules for first-order and higher-order function types: in a function type x : T 1 → T 2 , T 2 may reference the formal argument x only if T 1 is a scalar type (that is, only first-order function types are dependent).</p><p>The subtyping relation Γ T &lt;: T is relatively standard (Fig. <ref type="figure">3</ref>). For simplicity, we consider all datatypes covariant in their type parameters (rule &lt;:-DT); if need be, variance can be selected per type parameter depending on whether it appears positively or negatively in the constructors. The crucial part is the rule &lt;:-SC, which reduces subtyping between scalar types to implication between their refinements, under the assumptions extracted from the environment. Since the refinements are drawn from a decidable logic, this implication is decidable. The function that extracts assumptions from the environment is parametrized by a formula ψ and returns a conjunction of all path conditions and refinements of all variables mentioned in ψ or the path conditions:</p><formula xml:id="formula_10">Γ ψ = P(Γ)∧B FV(P(Γ))∪FV(ψ) (Γ) where B v (Γ;x : {B | ψ}) = [x/ν]ψ∧B v\{x}∪FV(ψ) (Γ) (x ∈ v) B v (Γ) (otherwise) B v (Γ;x : T ) = B v (Γ) (T non-scalar) B v (•) =</formula><p>This definition limits the effect of an environment variable with an inconsistent refinement to only those subtyping judgments that (transitively) mention that variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Round-Trip Type Checking</head><p>This section describes the core of SYNQUID's type system. It is inspired by bidirectional type checking <ref type="bibr" target="#b29">[30]</ref>, which interleaves top-down and bottom-up propagation of type information depending on the syntactic structure of the program, with the goal of making type checks more local. Bidirectional typing rules use two kinds of typing judgments: an inference judgment, written Γ e ↑ T , states that the term t generates type T in the environment Γ; a checking judgment, Γ t ↓ T , states that the term t checks against a known type T in the environment Γ. Accordingly, all typing rules can be split into inference and checking rules, depending on the judgment they derive. Bidirectional type checking rules for SYNQUID can be found in the technical report <ref type="bibr" target="#b31">[32]</ref>.</p><p>In a bidirectional system, analyzing a program starts with propagating its top-level type annotation top-down using checking rules, until the system encounters a term t to which no checking rule applies. At this point the system switches to bottom-up mode, infers the type T of t, and checks if T is a subtype of the goal type; if the check fails, t is rejected. Bidirectional type propagation is "all-or-nothing": once a checking problem for a term cannot be decomposed perfectly into checking problems for its subterms, the system abandons all information about the goal type and switches to purely bottom-up inference. Our insight is that some information from the goal type can be retained in the bottom-up phase, leading to more local error detection. To this end, we modify the bidirectional inference judgment into a strengthening judgment Γ t ↓ T ↑ T , which reads as follows: in the environment Γ, term t checks against a known type T and generates a stronger type T . We call the resulting type system round-trip, since it propagates types top-down and then back up.</p><formula xml:id="formula_11">Type Strengthening Γ Q e ↓ T ↑ T VARSC Γ(x) = {B | ψ} Γ {B | ψ} &lt;: T Γ Q x ↓ T ↑ {B | ν = x} VAR∀ Γ(x) = ∀αi.T Γ Q Ti Γ [Ti/α]T &lt;: T Γ Q x ↓ T ↑ [Ti/α]T APPFO Γ Q e1 ↓ {B | ⊥} → T ↑ let C1 in (x : {B | ψ} → T ) Γ;C1 Q e2 ↓ {B | ψ} ↑ let C2 in Tx Γ;C1;C2;x : Tx T &lt;: T Γ Q e1 e2 ↓ T ↑ let C1;C2;x : Tx in T APPHO Γ Q e ↓ bot → T ↑ let C in (T x → T ) Γ;C Q f ↓ T x Γ Q e f ↓ T ↑ let C in T Type Checking Γ Q t ↓ S IE Γ Q e ↓ T ↑ T Γ Q e ↓ T ABS Γ;y : Tx Q t ↓ [y/x]T Γ Q λy.t ↓ (x : Tx → T ) IF Γ Q e ↓ Bool ↑ let C in {Bool | ψ} Γ;C;[ /ν]ψ Q t1 ↓ T Γ;C;[⊥/ν]ψ Q t2 ↓ T Γ Q if e then t1 else t2 ↓ T MATCH Γ Q e ↓ top ↑ let C in {D T k | ψ} Ci = T j i → {D T k | ψ i } Γi = {x j i : T j i };[x /ν]ψ i Γ;C;[x /ν]ψ;Γi Q ti ↓ T Γ Q match e with |i Ci x j i → ti ↓ T TABS Γ Q t ↓ T αi not free in Γ Γ Q t ↓ ∀αi.T FIX Γ;x : S ≺ Q t ↓ S Γ Q fix x.t ↓ S</formula><p>Derivation rules for round-trip type checking are presented in Fig. <ref type="figure" target="#fig_3">4</ref>. All judgments are parametrized by the set of qualifiers Q, used to construct unknown refinements as explained below. Checking rules encode the way a checking judgment for an I-term t is decomposed into simpler checking judgments for its components. Strengthening rules encode the way a goal type for an E-term e is decomposed into over-approximate goal types for its subterms, which are necessary but in general not sufficient for correctness, while the precise type of e is constructed from the inferred types of its subterms. A round-trip type checker starts with a top-down phase, just as a bidirectional one would; when it encounters an E-term, it applies the corresponding strengthening rule and discards the inferred type (see rule IE). Thus, instead of detecting type errors at the boundary between I-and E-terms, the round-trip system performs local checks for each variable and function application.</p><p>In order to support goals types with an underspecified shape (as required for match scrutinees and higher-order applications), we augment SYNQUID with top and bot types, which are, respectively, a supertype and a subtype of every type. Note that these types are ignored when computing the logical representation of the environment Γ ψ , since they are not considered scalar. Also note that the precision of round-trip type checking crucially relies on the fact that only E-terms appear in strengthening judgments; this is why SYNQUID bans branching terms from function arguments, conditional guards, and match scrutinees.</p><p>Polymorphic instantiations. The rule VAR∀, which handles polymorphic instantiations, replaces type variables α i with types T i chosen nondeterministically to satisfy all subtyping checks <ref type="foot" target="#foot_2">4</ref> . In order to tame this nondeterminism, following <ref type="bibr" target="#b32">[33]</ref>, we restrict T i s to liquid types. A formula ψ is liquid in Γ with qualifiers Q, written Γ Q ψ, if it is a conjunction of well-formed formulas, each of which is obtained from a qualifier in Q by substitutingplaceholders with variables. This notion extends to types, Γ Q T , in a way analogous to well-formedness (Fig. <ref type="figure">3</ref>). Note that the set of all liquid formulas in a given environment is finite, and so is the set of all liquid types with a fixed shape. Sec. 3.5 and Sec. 3.6 present a deterministic algorithm for finding the types T i .</p><p>Applications. The application rules APPFO and AppHO are the core of the round-trip type system: they are responsible for propagating partial type information down to the left-hand side of an application. The type system distinguishes between first-order and higher-order applications, since in a function type x : T 1 → T 2 , T 2 cannot mention x if T 1 is a function type (see Fig. <ref type="figure">3</ref>). As a result, a higher-order application always yields the type T 2 independently of the argument. If instead T 1 is a scalar type, we have to replace x inside T 2 with the actual argument of the application. Unfortunately, we cannot assign the application e 1 e 2 the type [e 2 /x]T 2 , since e 2 is a program term, which does not necessarily have a corresponding refinement precisely capturing its semantics. We address this problem by assigning e 1 e 2 a contextual type let C in T 2 , where the context C binds the variable x to the precise type of e 2 .</p><p>Example. We demonstrate the local error detection enabled by rule APPFO on the following type-checking problem:</p><formula xml:id="formula_12">Γ Q append xs xs ↓ {List Pos | len ν = 5}</formula><p>where Pos is an abbreviation for {Int | ν &gt; 0} and Γ contains the following bindings:</p><formula xml:id="formula_13">xs : {List Nat | len ν = 2}; append : ∀α.l : {List α | len ν ≥ 0} → r : {List α | len ν ≥ 0}</formula><p>→ {List α | len ν = len l+len r} Intuitively, the constraint on the length of the output list is hard to verify without analyzing the whole expression, while the mismatch in the type of the list elements can be easily found without considering the second argument of append. Refinement types provide precise means to distinguish those cases: the length-related refinement of append is dependent on the arguments l and r, whereas the type of the list elements cannot possibly mention l or r, since it has to be well-formed in a scope where these variables are not defined.</p><p>Applying the APPFO rule twice to the judgment above yields</p><formula xml:id="formula_14">Γ Q append ↓ {B 0 | ⊥} → {B 1 | ⊥} → {List Pos | len ν = 2},</formula><p>where the base types B 0 and B 1 are yet to be inferred. Applying VAR∀, and decomposing the resulting subtyping check with &lt;:-FUN, we get</p><formula xml:id="formula_15">Γ;l : {B 0 | ⊥};r : {B 1 | ⊥} {List T 0 | len ν = len l+len r} &lt;: {List Pos | len ν = 2}</formula><p>Using &lt;:-SC, this judgment can be decomposed into an implication on refinements-vacuous thanks to the types of l and r-and subtyping on base types, List T 0 &lt;: List Pos, which is not vacuous since here l and r are out of scope. The first argument of append is checked against the type List T 0 (in the second premise of APPFO), which imposes a subtyping check Γ List Nat &lt;: List T 0 . Since no type T 0 satisfies both subtyping relations, the type checker rejects the term append xs.</p><p>Recursion. Another rule in Fig. <ref type="figure" target="#fig_3">4</ref> that deserves some discussion is FIX, which comes with a termination check. In the context of synthesis, termination concerns are impossible to ignore, since non-terminating recursive programs are always simpler than terminating ones, and thus would be synthesized first if considered correct. The FIX rule gives the "recursive call" a termination-weakened type S ≺ , which intuitively denotes "S with strictly smaller arguments". The exact definition of termination-weakening is a parameter to our system. Our implementation provides a predefined well-founded order on primitive base types, and allows the user to define one on datatypes by mapping them to primitive types using termination metrics; then S ≺ is defined as a lexicographic order on the tuple of all arguments of S that have an associated well-founded order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Soundness and Completeness</head><p>We show soundness and completeness of round-trip type checking relative to purely bottom-up liquid type inference <ref type="bibr" target="#b32">[33]</ref>. Detailed proofs are available in the technical report <ref type="bibr" target="#b31">[32]</ref>.</p><p>Round-trip type checking is sound in the sense that whenever a SYNQUID term t type-checks against a schema S, Γ Q t ↓ S, there exist a set of qualifiers Q and a schema S , such that the bottom-up system infers S for t, Γ Q t :: S, and Γ S &lt;: S. Note that bottom-up inference might require strictly more qualifiers than type checking: in the bottom-up system, generating types for branching statements and abstractions imposes the requirement that these types be liquid; the round-trip system obtains the types of those terms by decomposing the goal type, thus the liquid restriction does not apply. In practice the difference is irrelevant, since the type inference algorithm can extract the missing qualifiers from the top-level goal type and the preconditions of component functions. Thus, if Q contains a sufficient set of qualifiers such that the goals schema is liquid (Γ Q S) and the preconditions of component function are liquid, which we denote as Q Γ, then we can take Q = Q. Theorem 1 (Soundness of round-trip type checking). If Q Γ, Γ Q S, and Γ Q t ↓ S, then Γ Q t :: S and Γ Q S &lt;: S.</p><p>Unlike liquid type inference, the round-trip system requires a proof of termination for all fixpoints; thus if Γ Q t :: S, but t's termination cannot be shown using the chosen definition of termination weakening, the round-trip type system will reject t. Thus we show completeness for a weakened round-trip system, obtained from Fig. <ref type="figure" target="#fig_3">4</ref> by replacing S ≺ in the premise of the FIX rule by S. We denote the checking judgment of the modified system as</p><formula xml:id="formula_16">Γ * Q t ↓ S. Theorem 2 (Completeness of round-trip type checking). If Γ Q t :: S, then Γ * Q t ↓ S.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Type System Extensions</head><p>In this section we further improve the locality of type checking for function applications and branching terms.</p><p>Type Consistency. Recall the type checking problem Γ Q append xs xs ↓ {List Pos | len ν = 5} from Sec. 3.2, and let us change the type of xs to {List Pos | len ν = 6}. In this case, xs has the right element type, Pos, but intuitively the partial application append xs can still be safely rejected, since no second argument with a non-negative length can fulfill the goal type.</p><p>To formalize this intuition we introduce the notion of type consistency, defined in Fig. <ref type="figure" target="#fig_4">5</ref>. Two scalar types are consistent if they have a common inhabitant for some valid valuation of environment variables. For function types, the relation is not symmetric: a type x : T x → T is consistent with a goal type if their return types are consistent for some value of x of type T x .</p><p>We add a premise Γ T ∧ : T to every rule in Fig. <ref type="figure" target="#fig_3">4</ref> that already has the premise of the form Γ T &lt;: T . The additional premise has no effect on full applications, since for scalar types consistency is subsumed by subtyping. The consistency check can, however, reject a partial application e allowed by subtyping, due to goals generated by the rule APPFO, which have a vacuous argument type {B | ⊥}. It is easy to show that in the absence of consistency checks, any application of such e would always be rejected by the subtyping check in APPFO; thus introducing consistency checks does not affect completeness of type checking. With consistency checks in place, the term append xs in the example above is rejected since the formula len xs = 6∧len r ≥ 0∧len ν = len xs+len r∧len ν = 5 is unsatisfiable.</p><p>Liquid Abduction. Consider the IF rule in Fig. <ref type="figure" target="#fig_3">4</ref>: the type checker can analyze the two branches of the conditional independently of each other, but can only proceed with either branch once the precise type of the guard has been inferred. In the context of synthesis this amount to blindly enumerating type-correct boolean expressions as guards and then checking if any of them enables synthesis of a correct branch. The goal of this section is to improve the locality of the IF rule in order to avoid such blind enumeration.</p><p>The idea comes from condition abduction <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref>: instead of starting with the guard, for which no information can be extracted from the goal type, start by analyzing one of the branches and use logical abduction to infer the weakest assumption under which the branch fulfills the goal type. If such a condition does not exist or is a contradiction, the branch candidate is deemed ill-typed; otherwise the abduced condition can be used as a specification for the guard.</p><p>This strategy relies on the availability of a sufficiently fast mechanism to perform logical abduction, which is generally challenging. In SYNQUID, we treat unknown path conditions the same way as unknown refinements in polymorphic instantiations: we restrict their valuations to liquid formulas over environment variables, and use the greatest-fixpoint Horn solver (described in Sec. 3.6) to discover the weakest such valuation. We refer to the modified rule for conditionals as the liquid abduction rule:</p><formula xml:id="formula_17">IFAB Γ Q ψ Sat( Γ ψ ∧ψ) Γ Q e ↓ {Bool | ν = ψ} Γ;ψ Q t 1 ↓ T Γ;¬ψ Q t 2 ↓ T Γ Q if e then t 1 else t 2 ↓ T</formula><p>This rule limits completeness of round-trip type checking by restricting valid guard types to the form above. Most notably, it excludes guards that contain function composition, and thus users have to provide wrapper components to encapsulate complex guard predicates; in all our experiments, the set of required guard components was quite intuitive, thus we conclude that the trade-off between expressiveness and efficiency offered by liquid abduction is reasonable in the context synthesis.</p><p>Match Abduction. A similar technique can be used to propose pattern matching, assuming the types of potential scrutinees are restricted to liquid types. In this case, however, the liquid restriction imposes more substantial limitations on the structure of the program: abduction only works if the scrutinee is a variable and its datatype has at least one scalar constructor (such as Nil in List). Thus, SYNQUID employs a combined approach: it first tries an abduction-based rule, but if that fails, the system reverts to the original MATCH rule of Fig. <ref type="figure" target="#fig_3">4</ref>. As a result, type checking (and synthesis) enjoys the efficiency benefits of abduction without compromising completeness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">The Local Liquid Type Checking Algorithm</head><p>Starting from the round-trip typing rules presented above, this section develops local liquid type checking: a deterministic algorithm that takes as input a SYNQUID program t, an environment Γ, a goal schema S, and a set of qualifiers Q, and either produces a derivation of Γ Q t ↓ S or rejects the program.</p><p>The main challenge is to find suitable instantiations for polymorphic components, as required by the rule VAR∀; to this end, the algorithm replaces the type variables α i in the component schema with fresh free type variables α i<ref type="foot" target="#foot_3">5</ref> , extracts subtyping constraints on α i from the subtyping premises of the derivation, and then solves the subtyping constraints to either discover a valid type assignment mapping free type variables to liquid types, or conclude that such an assignment does not exist.</p><p>For the purpose of constraint solving, we extend the syntax of refinement terms with predicate unknowns P i . Local liquid type checking maintains a set of subtyping constraints</p><formula xml:id="formula_18">C = {Γ i T i &lt;: T i }, a set of Horn constraints H = {ψ i }, a type assignment T = [α i → T i ],</formula><p>and a liquid assignment L = [P i → {ψ} i ]. We denote with ψ L the formula ψ with all predicate unknowns substituted with conjunctions of their valuations in L. The type checking process alternates between the following two steps: it either extends the type derivation by applying one of the rules of Fig. <ref type="figure" target="#fig_3">4</ref>, adding any of its subtyping premises to C, or it picks a constraint c from C and solves it; constraint solving is formalized in the procedure Solve in Fig. <ref type="figure" target="#fig_5">6</ref>.</p><p>Solve does one of the following, depending on the operands of a subtyping constraint: it either substitutes a type variable for which an assignment already exists (Eq. 1, Eq. 2), unifies a type variable with a type (Eq. 4, Eq. 5), decomposes subtyping over compound types (Eq. 6, Eq. 7), or translates subtyping over scalar types into a Horn constraint and uses the procedure Horn, described in the next section, to find an L that satisfies all Horn constraints (Eq. 8). Local liquid type checking terminates when the entire type derivation has been built, and all constraints in C are between free type variables (only Eq. 3 applies).</p><p>During unification of α and T , procedure Fresh inserts fresh predicate unknowns in place of all refinements in T ; note that due to the incremental nature of our algorithm, T might itself contain free type variables, which are simply replaced with fresh free type variables to be unified later as more subtyping constraints arise. This novel feature of local liquid type checking, which we call incremental unification, is crucial for early error detection. Existing refinement type checkers <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b32">33]</ref> cannot interleave shape and refinement discovery, since they rely on the global Hindley-Milner inference algorithm to fully reconstruct the shapes of all types in the program before discovering their refinements.</p><p>Example. Starting from empty T and L, Solve( α &lt;: List β | len ν &gt; 0) instantiates α by Eq. 4 leading to T = [α → {List γ | P 0 }], L = [P 0 → ∅] and recycles the subtyping constraint; next by Eq. 1 and Eq. 7, the constraint is decomposed into {List | P 0 } &lt;: {List | len ν &gt; 0} and γ &lt;: β . The former produces a Horn constraint P 0 ⇒ len ν &gt; 0, which leads to strengthening L[P 0 ], while the latter is retained in C. If further type checking produces a subtyping constraint on β , say Nat &lt;: β , T will be extended with an assignment [β → {Int | P 1 }], which in turn will lead to transforming the constraint on γ into</p><formula xml:id="formula_19">Solve(Γ c) = match c with | {α | ψ} &lt;: T,α ∈ dom(T ) -→ C ← C ∪{Γ Refine(T (α ),ψ) &lt;: T } (1) | T &lt;: {α | ψ},α ∈ dom(T ) -→ (symmetrical) (2) | {α | ψ1} &lt;: {β | ψ2} -→ C ← C ∪{α | ψ1} &lt;: {β | ψ2}<label>(3)</label></formula><formula xml:id="formula_20">| {α | ψ} &lt;: T,α / ∈ T -→ T ← T [α → Fresh(T )]; C := C ∪{Γ {α | ψ} &lt;: T } (4) | T &lt;: {α | ψ} -→ (symmetrical)<label>(5)</label></formula><p>| (x : Tx → T1) &lt;: (y : Ty → T2) -→ C ← C ∪{Γ Ty &lt;: Tx,Γ;y : Ty [y/x]T1 &lt;: T2}</p><formula xml:id="formula_21">| {D T i 1 | ψ1} &lt;: {D T i 2 | ψ2} -→ C ← C ∪{Γ {D | ψ1} &lt;: {D | ψ2},Γ T i 1 &lt;: T i 2 } (7) | {B | ψ1} &lt;: {B | ψ2} -→ H ← H∪{ Γ ψ 1 ⇒ψ 2 ∧ψ1 ⇒ ψ2};<label>(6)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L ← Horn(L,H)</head><p>| otherwise -→ fail ( <ref type="formula">9</ref>) </p><formula xml:id="formula_23">Refine({B | ψ},ψ ) = {B | ψ∧ψ } Fresh(T ) = match T with | {α | ψ} -→ β | {D T i | ψ} -→ {D Fresh(T i ) | P }, L ← L[P → ∅] | {B | ψ} -→ {B | P }, L ← L[P → ∅] Horn(L,H) = if ∀h ∈ H.Valid( h L) then L else let h ← {H | ¬Valid( h L)} in let L ← Strengthen(L,h) in Horn(L ,H)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Solving Horn Clauses</head><p>The set of Horn constraints H produced by Solve in Fig. <ref type="figure" target="#fig_5">6</ref> consists of implications of the form ψ ⇒ ψ , where each side is a conjunction of a known formula and zero or more predicate unknowns P . The goal of the procedure Horn is to find a liquid assignment to P that validates all constraints in H or determine that H is unsatisfiable. The space of possible valuations of each P is 2 Q P , where Q P is a set of atomic formulas obtained by instantiating qualifiers Q in the environment where P was created.</p><p>Local liquid type checking invokes Horn after every new Horn constraint is issued, and expects to detect an unsatisfiable set of constraints-and thus a type error-as early as possible. Round-trip typing rules-in particular, APPFO and IF-ABDproduce constraints in a specific order, such that for each un-known P , implications where P appears negatively (on the left) are issued before the ones where it appears positively (on the right). To enable early error detection in this setting, procedure Horn looks for the weakest valuation of each P that validates all Horn constraints issued so far, and deems H unsatisfiable if for some P such a valuation does not exist or is inconsistent (an inconsistent valuation can be safely discarded since it is guaranteed to violate some future constraint where P appears positively).</p><p>As an optimization, Horn always starts form the current assignment L and possibly makes it stronger, since all weaker assignments are known to be too weak to satisfy the previously issued constraints (for a fresh P , L[P ] is initialized with ∅). Horn uses an iterative greatest-fixpoint computation, outlined in Fig. <ref type="figure" target="#fig_5">6</ref>; in every iteration, Strengthen(L,ψ ⇒ ψ ) produces the weakest consistent assignment L strictly stronger than L, such that ψ L ⇒ ψ L is valid (or fails if this is not possible). In general, L is not unique; in this case our algorithm simply explores all alternatives independently, which happens rarely enough in the context of refinement type checking and synthesis.</p><p>Implementing Strengthen efficiently is challenging: for every unknown P in ψ, the algorithm has to find the smallest subset of atomic predicates from Q P \L[P ] that validates the implication. Existing greatest-fixpoint Horn solvers <ref type="bibr" target="#b33">[34]</ref> use breadth-first search, which is exponential in the cumulative size of Q P and does not scale sufficiently well to practical cases of condition abduction (see Sec. 4). Instead, we observe that this task is similar to the problem of finding minimal unsatisfiable subsets (MUSs) of a a set of formulas; based on this observation, we build a practical algorithm for Strengthen which we dub MUSFIX.</p><p>The task of Strengthen amounts to finding all MUSs of the set κ∈ψ (Q κ \ L[κ]) ∪ {¬ ψ L } under the assumption ψ L . MUSFIX borrows the main insight of the MARCO algorithm <ref type="bibr" target="#b21">[22]</ref> for MUS enumeration, which relies on the ability of the SMT solver to produce unsatisfiable cores from proofs. We modify MARCO to only produce MUSs that contain the negated right-hand side of the Horn constraint, ¬ ψ L , since Horn should only produce consistent solutions. For each resulting MUS (stripped of ¬ ψ L ), MUSFIX finds all possible partitions into valuations of individual predicate unknowns. Since MUSes are normally much smaller than the original set of formulas, a straightforward partitioning algorithm works well and rarely yield more than one valid partition. As an important optimization, when MUS enumeration returns multiple syntactically minimal subsets, MUSFIX prunes out semantically redundant subsets, i.e. it removes a subset m i if m i ⇒ m j for some j = i.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Synthesis from Refinement Types</head><p>From the rules of round-trip type checking we can obtain synthesis rules, following the approach of <ref type="bibr" target="#b26">[27]</ref> and reinterpreting the checking and strengthening judgments in such a way that the term t is considered unknown. This interpretation yields a synthesis procedure, which, given a goal schema S, picks a rule where the goal schema in the conclusion matches S, and constructs the term t from subterms obtained from the rule's premises. More concretely, starting from the top-level goal schema S, the algorithm always starts by applying rule FIX (if S ≺ is defined) followed by TABS (if the schema is polymorphic), and finally ABS (if the goal type is a function type). Given a scalar goal, the procedure performs exhaustive enumeration of well-typed E-terms up to a given bound on their depth, solving subtyping constraints at every node and simultaneously abducing a path condition as per the IF-ABD rule. If the resulting condition ψ is trivially true, the algorithm has found a solution; if ψ is inconsistent, the E-term is discarded; otherwise, the algorithm generates a conditional and proceeds to synthesize its remaining branch under the fixed assumption ¬ψ, as well a term of type {Bool | ν = ψ} to be used as the branch guard. Once all possible E-terms are exhausted, the algorithm attempts to synthesize a pattern match using an arbitrary E-term as a scrutinee, unless the maximal nesting depth of matches has been reached.</p><p>Soundness and Completeness. Soundness of synthesis follows straightforwardly from soundness of round-trip type checking, since each program candidate is constructed together with a typing derivation in the round-trip system. Completeness is less obvious: due to condition abduction, the synthesis procedure only explores programs where the left branch of each conditional is an E-term. We can show that every SYNQUID program can be rewritten to have this form (by flattening nested conditionals and pushing conditionals inside matches). Thus the synthesis procedure is complete in the following sense: for each schema S, if there exists a term t, such that the depth of applications and pattern matches in t are within the given bounds, the procedure is guarantees to find some term t that also type-checks against S; if such a term t does not exist, the procedure will terminate with a failure. Note that the algorithm imposes no a-priori bound on the nesting depth of conditionals (which is crucial for completeness as stated above); this does not preclude termination, since in any given environment, liquid formulas partition the input space into finitely many parts, and every condition abduction is guaranteed to cover a nonempty subset of these parts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Evaluation</head><p>We performed an extensive experimental evaluation of SYN-QUID with the goal of assessing usability and scalability of the proposed synthesis technique compared to existing alternatives. This goal materializes into the following research questions:</p><p>(1) Are refinement types supported by SYNQUID expressive enough to specify interesting programs, including benchmarks proposed in prior work?</p><p>(2) How concise are SYNQUID's input specifications compared both to the synthesized solutions and to inputs required by existing techniques?</p><p>(3) Are SYNQUID's inputs intuitive: in particular, is the algorithm applicable to specifications not tailored for synthesis?</p><p>(4) How scalable is SYNQUID: can it handle benchmarks tackled by existing synthesizers? Can it scale to more complex programs than those previously reported in the literature?</p><p>(5) How is synthesis performance impacted by various features of SYNQUID and its type system?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Benchmarks</head><p>In order to answer the research questions stated above, we arranged a benchmark suite that consists of 64 synthesis challenges from various sources, representing a range of problem domains. In the interest of direct comparison with existing synthesis tools, our suite includes benchmarks that had been used in the evaluation of those tools <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>From each of these papers, we picked top three most complex challenges (judging by the reported synthesis times) that were expressible in SYNQUID's refinement logic, plus several easier problems that were common or particularly interesting.</p><p>Our second source of benchmarks are verification case studies from the LiquidHaskell tutorial <ref type="bibr" target="#b17">[18]</ref>. The purpose of this second category is two-fold: first, these problems are larger and more complex than existing synthesis benchmarks, and thus can show whether SYNQUID goes beyond the state of the art in synthesis; second, the specifications for these problems have been written by independent researchers and for a different purpose, and thus can serve as evidence that input accepted by SYNQUID is sufficiently general and intuitive. Out of the total of 14 case studies, we picked 5 that came with sufficiently strong functional specifications (list sorting, binary-search trees, content-aware lists, unique lists, and AVL trees), erased all implementations, and made relatively straightforward syntactic changes in order to obtain valid SYNQUID input.</p><p>Tab. 1 lists the 64 benchmarks together with some metrics of our type-based specifications: the number of synthesis goals including auxiliary functions, the set of components provided, the number of measures used, and the cumulative size of refinements. Note that the reported specification size only includes refinements in the signatures of the synthesis goals; refinements in component functions are excluded since every such function (except trivial arithmetic operations and helper functions) serves as a synthesis goal in another benchmark; refinements in datatype definitions are also excluded, since those definitions are reusable between all benchmarks in the same problem domain. Full specifications are available from the SYNQUID repository <ref type="bibr" target="#b30">[31]</ref>.</p><p>The benchmarks are drawn from a variety of problem domains with the goal of exercising different features in SYNQUID. List and tree benchmarks demonstrate pattern matching, structural recursion, the ability to generate and use polymorphic and higher-order functions (such as map and fold), as well as reasoning about nontrivial properties of data structures, both universal (e.g. all elements are non-negative) and recursive (e.g. size and set of elements). Our most advanced benchmarks include sorting and operations over data structures with complex representation invariants, such as binary search trees, heaps, and balanced trees. These benchmarks showcase expressiveness of refinement types, exercise SYNQUID's ability to perform nontrivial reasoning through refinement discovery, and represent a scalability challenge beyond the current state of the art in synthesis. Finally, we included several benchmarks operating on "custom" datatypes (including the "address book" case study from <ref type="bibr" target="#b19">[20]</ref>) in order to demonstrate that SYNQUID's applicability is not limited to standard textbook examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Results</head><p>Evaluation results are summarized in Tab. 1. SYNQUID was able to synthesize (and fully verify) solutions for all 64 benchmarks; the table lists sizes of these solutions in AST nodes (Code) as well as synthesis times in seconds (T-all).</p><p>The results demonstrate that SYNQUID is efficient in synthesizing a variety of programs: all but 7 benchmarks are synthesized within 5 seconds; it also scales to programs of nontrivial size, including complex recursive (red-black tree insertion of size 69) and non-recursive functions (3-value binary heap constructor of size 246). Even though specification sizes for some benchmarks are comparable with the size of the synthesized code, for many complex problems the benefits of describing computations as refinement types are significant: for example, the type-based specifications of the three main operations on binary-search trees are over six times more concise than their implementations.</p><p>The synthesis times discussed above were obtained for optimal exploration bounds, which could differ across benchmarks. Tab. 1 also reports synthesis times T-def for a setting where all benchmarks in the same category share the same exploration bounds. Although this inevitably slows down synthesis, on most of the benchmarks the performance penalties were not drastic: only three benchmarks failed to terminate within the two-minute timeout.</p><p>In order to assess the impact on performance of various aspects of our algorithm and implementation, Tab. 1 reports synthesis times using three variants of SYNQUID, where certain features were disabled: the column T-nrt corresponds to replacing round-trip type checking with bidirectional type checking (that is, disabling subtyping checks for partial applications); T-ncc corresponds to disabling type consistency checks; T-nmus corresponds to replacing MUSFIX with naive breadth-first search. The results demonstrate that the most significant contribution comes from using MUSFIX: without this feature 37 out of 64 benchmarks time out, since breadth-first search cannot handle condition abduction even with a moderate number of logical qualifiers. The second most significant feature is round-trip type checking, with 33 benchmarks timing out when disabled, while consistency checks only bring significant speedups for the most complex examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Comparative Evaluation</head><p>We compared SYNQUID with state-of-the-art synthesis tools that target recursive functional programs and offer a comparable level of automation. The results are summarized in Tab. 2. For each tool, we list the three most complex benchmarks reported in the respective paper that were expressible in SYNQUID's refinement logic; for each of the three benchmarks we report the specification size (if available) and the synthesis time; for ease of comparison, we repeat the same two metrics for SYNQUID (copied over from Tab. 1). Note that the synthesis times are not directly comparable, since the results for other tools are taken from respective papers and were obtained on different hardware; however, the differences of an order of magnitude or more are still significant, since they can hardly be explained by improvements in single-core hardware performance. We split the tools into two categories according to the specification and verification mechanism they rely on.</p><p>Formal Specifications with Deductive Verification. The first category includes LEON <ref type="bibr" target="#b19">[20]</ref> and JENNISYS <ref type="bibr" target="#b20">[21]</ref>; both tools use pre-and post-conditions (and data structure invariants) to describe computations, and rely on unbounded, SMT-based verification to validate candidate programs (and thus provide the same correctness guarantees as SYNQUID). Unlike LEON and SYNQUID, JENNISYS targets imperative, heap-based programs; the evaluation in <ref type="bibr" target="#b20">[21]</ref>, however, focuses on side-effect free benchmarks. Both tools use variants of condition abduction, which makes their exploration strategies similar to SYNQUID's.</p><p>For both tools, translating their three most complex benchmarks into SYNQUID proved to be straightforward. This suggests that our decidable refinement logic is not too limiting in practice, compared to other formal specification languages used for synthesis. Our specifications are on average slightly more concise than LEON's and significantly more concise than those in JENNISYS; the latter is largely due to the heap-based language, but the results still indicate that embedding predicates into types can help curb the verboseness of traditional Hoare-style specifications. SYNQUID was able to synthesize solutions to all problems tackled by the other two tools in this category. The converse is not true: automatic verification of some of SYNQUID's benchmarks (such as the binary-search tree example in Sec. 2) requires invariant discovery, which is not supported by the other two tools. This suggests that SYNQUID qualitatively differs from other state-of-the-art synthesizers in terms of the class of programs for which a verified solution can be synthesized. On the benchmarks where the other tools are applicable, SYNQUID demonstrates considerably smaller running times, which suggests that fast verification and early pruning enabled by type-based specifications indeed improve the scalability of synthesis.</p><p>Input/Output Examples. Our second category of tools includes MYTH <ref type="bibr" target="#b26">[27]</ref>, λ 2 <ref type="bibr" target="#b11">[12]</ref> and ESCHER <ref type="bibr" target="#b0">[1]</ref>, which synthesize programs from concrete input-output examples, as well as MYTH2 <ref type="bibr" target="#b13">[14]</ref>, which uses generalized input-output examples. Using refinement types, we were able to express 3 out of 3, 10, 5, and 7 of their most complex benchmarks, receptively. The functions we failed to specify either manipulate nested structures in a representation-specific way (such as "insert a tree under each leaf of another tree"), or perform filtering ("list of nodes in a tree that match a predicate").</p><p>At the same time, we found cases where refinement types are concise and intuitive, while providing input-output examples is extremely tedious. One of those cases is insertion into a binary search tree: MYTH requires 20 examples, each of which contains two bulky tree instances and has to define the precise position where the new element is to be inserted; the type-based specification for this problem, given in Sec. 2, is straightforward and only defines the abstract effect of the operation relevant to the user. This suggests that in general, logic-based specification techniques, including refinement types in SYNQUID, are a better fit for describing operations that maintain a complex representation invariant but have a simple abstract effect, while example-based approaches fare better when describing operations that inherently expose the complex representation of a data structure.</p><p>Experiments with example-based tools only report the number of examples required for synthesis and not their sizes; however, we can safely assume that each example contains multiple AST nodes, and thus conclude that type-based specifications for the benchmarks in Tab. 2 are more concise. By imposing more constraints on the set of examples (such as trace completeness <ref type="bibr" target="#b26">[27]</ref>) and increasing its size, example-based synthesizers can trade off user effort for synthesis time. On the benchmarks under comparison, MYTH appears to favor performance, while λ 2 prefers smaller example sets. SYNQUID tries to offer the best of both world and achieves good performance with concise specifications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Evaluation on Non-recursive Benchmarks</head><p>In order to asses the scalability of MUSFIX on larger search spaces, we evaluated SYNQUID on two parametrized benchmarks from the linear integer arithmetic track of the SyGuS'14 competition <ref type="bibr" target="#b2">[3]</ref>: max n (find maximum of n integer arguments) and array _ search n (find the position of a value in a sorted array with n elements). Both benchmarks target non-recursive programs that consist of a series of nested conditionals; moreover, the search space for the branch guards grows exponentially with n. This makes the two problems ideal benchmarks for condition abduction techniques. Fig. <ref type="figure" target="#fig_6">7</ref> shows SYNQUID synthesis times on the two benchmarks for n = 2,3,...,6. For reference, we also plot the results for the enumerative solver (the fastest of the SyGuS baseline solvers), as well as the higher-order solver ALLOY* <ref type="bibr" target="#b23">[24]</ref>, and PUFFIN <ref type="bibr" target="#b3">[4]</ref>, a specialized synthesizer for conditional integerarithmetic expressions <ref type="foot" target="#foot_4">6</ref> . The results show that SYNQUID's condition abduction scales relatively well compared to general synthesizers, but loses to PUFFIN's theory-specific abduction engine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related Work</head><p>Our work is the first to leverage general decidable refinement types for synthesis, but it builds on a number of ideas from prior work as has been highlighted already throughout the paper. Specifically, our work combines ideas from two areas: synthesis of recursive functional programs and refinement type inference.</p><p>Synthesis of Recursive Functional Programs. A number of recent systems target recursive functional programs and use type information in some form to restrict the search space. The most closely related to our work are MYTH <ref type="bibr" target="#b26">[27]</ref>, MYTH2 <ref type="bibr" target="#b13">[14]</ref>, and LEON <ref type="bibr" target="#b19">[20]</ref>.</p><p>MYTH pioneered the idea of leveraging bidirectional type checking for synthesis. However, MYTH does not support polymorphism or refinement types. Instead, the system relies on examples in order to specify the desired functionality. For certain functions, providing examples is easy whereas writing a refinement type is cumbersome or, due to the limitations of decidable refinement logic, even impossible. That said, examples in general do not fully specify a program; thus programming by example always involves a manual verification step. Moreover, for some less intuitive problems, such as insertion into a balanced tree or AST transformations, providing input-output examples requires familiarity with all details and corner cases of the algorithm, whereas refinement types enable a more abstract specification. Additionally, MYTH expects the set of examples to be trace complete, which means that for any example the user provides, there should also be examples corresponding to any recursive calls made on that input. Other systems that use a combination of types and input-output examples, and thus have similar advantages and disadvantages relative to our system, include λ 2 <ref type="bibr" target="#b11">[12]</ref> and ESCHER <ref type="bibr" target="#b0">[1]</ref>.</p><p>MYTH2 generalizes example-based synthesis: it treats examples as singleton types, and extends the input language with intersection and union types, as well as parametric polymorphism. This addresses some of the shortcomings of concrete input-output examples (in particular, their verboseness), however, in the absence of dependent function types most interesting programs still cannot be fully speficied. Combining SYNQUID's dependent types with singletons, intersection, and unions found in MYTH2 is an interesting direction for future work.</p><p>In LEON, synthesis problems are defined by first-order specifications with recursive predicates, and verification is based on a semi-decision procedure <ref type="bibr" target="#b34">[35]</ref>, implemented on top of an SMT solver. LEON's verification engine does not support invariant inference, which prevents it from generating provably correct implementations for problems such as insertion into a sorted list or a binary search tree. The general synthesis strategy is similar to ours: first decompose the specification and then switch to generate-and-check mode, enhanced with condition abduction. Unlike our system, LEON does not perform systematic specification decomposition in the generate-and-check mode, and lacks support for polymorphism and high-order functions.</p><p>The use of type information has also proved extremely useful for code completion <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b27">28]</ref>, although none of these systems rely on a type system as expressive as ours, and they are designed for a very different set of tradeoffs compared to SYNQUID. For example, because the problem is highly under-constrained, these systems place significant emphasis on the ranking of solutions.</p><p>Another important body of related work related is hole driven development, as embodied in systems like Agda <ref type="bibr" target="#b25">[26]</ref> and Idris <ref type="bibr" target="#b5">[6]</ref>, which leverage a rich type system to aid development, but are meant to be used interactively rather than to perform complete synthesis. Djinn <ref type="bibr" target="#b4">[5]</ref> serves a similar purpose but uses the less expressive Haskell type system.</p><p>Refinement Type Checking. Our type checking algorithm is based on liquid type inference <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref>, which pioneered combining Hindley-Miler unification with predicate abstraction. We integrate their ideas with bidirectional type checking <ref type="bibr" target="#b29">[30]</ref>, which has been used before both for other flavors of refinement types <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b40">41]</ref> and for unrestricted dependent types <ref type="bibr" target="#b7">[8]</ref>, but not for general decidable refinement types. Another difference with liquid types is that we use greatest-fixpoint predicate abstraction procedure inspired by <ref type="bibr" target="#b33">[34]</ref>, and improved using an algorithm for efficient MUS enumeration <ref type="bibr" target="#b21">[22]</ref>.</p><p>Logical Abduction. The concept of abduction in logical reasoning has found numerous applications in programming languages, including specification inference <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10]</ref> and program synthesis <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b20">21]</ref>. Abduction techniques based on quantifier elimination <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">10]</ref> and theory-specific unification operators <ref type="bibr" target="#b3">[4]</ref>, are precise and efficient, but only applicable to restricted domains. SYNQUID performs abduction using predicate abstraction and MUS enumeration, which can be applied to a wider range of specification logics, but its precision is limited to the given set of logical qualifiers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Refinement type signature of replicate and the code synthesized from this signature.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>has</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Terms and types.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Rules of round-trip type checking.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Type consistency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Solving subtyping constraints.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Evaluation on non-recursive benchmarks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>termination measure size</head><label></label><figDesc>:: BST α → Int measure keys :: BST α → Set α data BST α where Empty ::{BST α | keys ν = []} Node :: x: α → l: BST{α | ν &lt; x} → r: BST{α | x &lt; ν} → {BST α | keys ν = keys l + keys r + [x]}According to this definition, one can obtain a BST either by taking an empty tree, or by composing a node with key x and two BSTs, l and r, in which all keys are, respectively, strictly less and strictly greater than x. The type is additionally refined by the measure keys, which denotes the set of all keys in the tree, and a termination measure size (size-related refinements are omitted in the interest of space).</figDesc><table><row><cell>The following type specifies insertion into a BST:</cell></row><row><cell>insert :: x: α → t: BST α →</cell></row><row><cell>{BST α | keys ν = keys t + [x]}</cell></row><row><cell>From this specification, SYNQUID generates the following</cell></row><row><cell>implementation within two seconds:</cell></row><row><cell>insert = λ x . λ t . match t with</cell></row><row><cell>| Empty → Node x Empty Empty</cell></row><row><cell>| Node y l r → if x ≤ y ∧ y ≤ x</cell></row><row><cell>then t</cell></row><row><cell>else if y ≤ x</cell></row><row><cell>then Node y l (insert x r)</cell></row><row><cell>2: Complex Data Structures and Invariant In-</cell></row><row><cell>ference. Assuming comparison operators in our logic are</cell></row><row><cell>generic, we can define the type of binary search trees as follows:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>(where elems (Cons h t) is expanded into [h] + elems t using the definition of the elems measure in the type of Cons); in other words, the auxiliary function must insert h into a sorted list acc. Treating this inferred signature as an independent synthesis goal, SYNQUID easily synthesizes a recursive program for insertion into a sorted list, and thus completes the following implementation of insertion sort without requiring any hints from the user, apart from a general recursion scheme:</figDesc><table /><note><p>Cons h t)} sort = λ xs . foldr f Nil xs where f = λ t . λ h . λ acc . match acc with Nil → Cons h Nil Cons z zs → if h ≤ z then Cons h (Cons z zs) else Cons z (f zs h zs)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Benchmarks and SYNQUID results. For each benchmark, we report the number of synthesis goals #G; the set of provided Components; the number of defined measures #M; cumulative size of Specification and synthesized Code (in AST nodes) for all goals; as well as SYNQUID running times (in seconds) with minimal bounds (T-all), with default bounds (T-def ), without round-trip checking (T-nrt), without type consistency checking (T-ncc), and without MUSFIX (T-nmus). "-" denotes timeout of 2 minutes or out of memory.</figDesc><table><row><cell>Group</cell><cell>Description</cell><cell>#G</cell><cell>Components</cell><cell>#M</cell><cell>Spec</cell><cell>Code</cell><cell>T-all</cell><cell>T-def</cell><cell>T-nrt</cell><cell>T-ncc</cell><cell>T-nmus</cell></row><row><cell></cell><cell>is empty</cell><cell>1</cell><cell>true, false</cell><cell>1</cell><cell>6</cell><cell>6</cell><cell>0.02</cell><cell>0.02</cell><cell>0.02</cell><cell>0.02</cell><cell>0.01</cell></row><row><cell></cell><cell>is member</cell><cell>1</cell><cell>true, false, =, =</cell><cell>2</cell><cell>6</cell><cell>18</cell><cell>0.11</cell><cell>0.11</cell><cell>0.13</cell><cell>0.10</cell><cell>-</cell></row><row><cell></cell><cell>duplicate each element</cell><cell>1</cell><cell></cell><cell>1</cell><cell>7</cell><cell>16</cell><cell>0.05</cell><cell>0.05</cell><cell>-</cell><cell>0.08</cell><cell>0.04</cell></row><row><cell></cell><cell>replicate</cell><cell>1</cell><cell>0, inc, dec, ≤, =</cell><cell>1</cell><cell>4</cell><cell>21</cell><cell>0.05</cell><cell>0.05</cell><cell>9.63</cell><cell>0.05</cell><cell>-</cell></row><row><cell></cell><cell>append two lists</cell><cell>1</cell><cell></cell><cell>1</cell><cell>8</cell><cell>15</cell><cell>0.15</cell><cell>0.09</cell><cell>-</cell><cell>0.13</cell><cell>0.10</cell></row><row><cell></cell><cell>concatenate list of lists</cell><cell>1</cell><cell>append</cell><cell>3</cell><cell>5</cell><cell>12</cell><cell>0.05</cell><cell>0.05</cell><cell>0.22</cell><cell>0.04</cell><cell>0.04</cell></row><row><cell></cell><cell>take first n elements</cell><cell>1</cell><cell>0, inc, dec, ≤, =</cell><cell>1</cell><cell>8</cell><cell>27</cell><cell>0.12</cell><cell>0.12</cell><cell>55.82</cell><cell>0.12</cell><cell>-</cell></row><row><cell></cell><cell>drop first n elements</cell><cell>1</cell><cell>0, inc, dec, ≤, =</cell><cell>1</cell><cell>11</cell><cell>20</cell><cell>0.10</cell><cell>0.10</cell><cell>7.87</cell><cell>0.09</cell><cell>-</cell></row><row><cell></cell><cell>delete value</cell><cell>1</cell><cell>=, =</cell><cell>2</cell><cell>8</cell><cell>26</cell><cell>0.10</cell><cell>0.10</cell><cell>0.17</cell><cell>0.12</cell><cell>-</cell></row><row><cell>List</cell><cell>map zip</cell><cell>1 1</cell><cell></cell><cell>1 1</cell><cell>5 10</cell><cell>22 22</cell><cell>0.03 0.08</cell><cell>0.03 0.08</cell><cell>0.06 -</cell><cell>0.03 0.10</cell><cell>0.02 0.07</cell></row><row><cell></cell><cell>zip with function</cell><cell>1</cell><cell></cell><cell>1</cell><cell>10</cell><cell>33</cell><cell>0.07</cell><cell>0.07</cell><cell>-</cell><cell>0.17</cell><cell>0.06</cell></row><row><cell></cell><cell>cartesian product</cell><cell>1</cell><cell>append, map</cell><cell>3</cell><cell>8</cell><cell>26</cell><cell>0.30</cell><cell>0.29</cell><cell>5.83</cell><cell>0.25</cell><cell>0.23</cell></row><row><cell></cell><cell>i-th element</cell><cell>1</cell><cell>0, inc, dec, ≤, =</cell><cell>1</cell><cell>12</cell><cell>20</cell><cell>0.05</cell><cell>0.05</cell><cell>0.38</cell><cell>0.05</cell><cell>-</cell></row><row><cell></cell><cell>index of element</cell><cell>1</cell><cell>0, inc, dec, =, =</cell><cell>2</cell><cell>8</cell><cell>20</cell><cell>0.08</cell><cell>0.08</cell><cell>0.14</cell><cell>0.07</cell><cell>-</cell></row><row><cell></cell><cell>insert at end</cell><cell>1</cell><cell></cell><cell>2</cell><cell>21</cell><cell>19</cell><cell>0.10</cell><cell>0.10</cell><cell>0.24</cell><cell>0.11</cell><cell>0.12</cell></row><row><cell></cell><cell>reverse</cell><cell>1</cell><cell>insert at end</cell><cell>2</cell><cell>15</cell><cell>12</cell><cell>0.09</cell><cell>0.10</cell><cell>0.29</cell><cell>0.12</cell><cell>0.09</cell></row><row><cell></cell><cell>foldr</cell><cell>1</cell><cell></cell><cell>2</cell><cell>14</cell><cell>32</cell><cell>0.10</cell><cell>0.10</cell><cell>-</cell><cell>0.10</cell><cell>0.44</cell></row><row><cell></cell><cell>length using fold</cell><cell>1</cell><cell>0, inc, dec</cell><cell>2</cell><cell>4</cell><cell>17</cell><cell>0.03</cell><cell>0.07</cell><cell>0.03</cell><cell>0.03</cell><cell>0.02</cell></row><row><cell></cell><cell>append using fold</cell><cell>1</cell><cell></cell><cell>2</cell><cell>8</cell><cell>20</cell><cell>0.04</cell><cell>2.19</cell><cell>0.05</cell><cell>0.04</cell><cell>0.03</cell></row><row><cell></cell><cell>insert</cell><cell>1</cell><cell>=, =</cell><cell>2</cell><cell>8</cell><cell>26</cell><cell>0.27</cell><cell>0.22</cell><cell>0.85</cell><cell>0.20</cell><cell>-</cell></row><row><cell>Unique list</cell><cell>delete remove duplicates remove adjacent dupl.</cell><cell>1 2 1</cell><cell>=, = is member =, =</cell><cell>2 2 3</cell><cell>8 13 5</cell><cell>22 47 32</cell><cell>0.18 0.36 1.33</cell><cell>0.19 0.87 1.32</cell><cell>1.07 0.72 -</cell><cell>0.26 0.33 1.31</cell><cell>---</cell></row><row><cell></cell><cell>integer range</cell><cell>1</cell><cell>0, inc, dec, ≤, =</cell><cell>2</cell><cell>13</cell><cell>23</cell><cell>2.36</cell><cell>2.33</cell><cell>22.27</cell><cell>2.33</cell><cell>-</cell></row><row><cell>Strictly sorted list</cell><cell>insert delete intersect</cell><cell>1 1 1</cell><cell>&lt; &lt; &lt;</cell><cell>2 2 2</cell><cell>8 8 8</cell><cell>41 29 40</cell><cell>0.18 0.10 0.33</cell><cell>0.17 0.09 0.32</cell><cell>0.43 0.21 0.68</cell><cell>0.16 0.10 0.34</cell><cell>---</cell></row><row><cell></cell><cell>insert (sorted)</cell><cell>1</cell><cell>≤, =</cell><cell>2</cell><cell>8</cell><cell>34</cell><cell>0.25</cell><cell>0.24</cell><cell>0.68</cell><cell>0.23</cell><cell>-</cell></row><row><cell></cell><cell>insertion sort</cell><cell>1</cell><cell>insert (sorted)</cell><cell>4</cell><cell>5</cell><cell>12</cell><cell>0.06</cell><cell>0.06</cell><cell>0.20</cell><cell>0.06</cell><cell>0.05</cell></row><row><cell></cell><cell>sort by folding</cell><cell>1</cell><cell>foldr, ≤, =</cell><cell>2</cell><cell>11</cell><cell>47</cell><cell>2.14</cell><cell>-</cell><cell>-</cell><cell>2.21</cell><cell>-</cell></row><row><cell></cell><cell>extract minimum</cell><cell>1</cell><cell>≤, =</cell><cell>4</cell><cell>23</cell><cell>40</cell><cell>4.28</cell><cell>4.35</cell><cell>-</cell><cell>7.58</cell><cell>-</cell></row><row><cell></cell><cell>selection sort</cell><cell>1</cell><cell>extract minimum</cell><cell>6</cell><cell>5</cell><cell>16</cell><cell>0.49</cell><cell>0.44</cell><cell>-</cell><cell>0.42</cell><cell>0.38</cell></row><row><cell>Sorting</cell><cell>balanced split</cell><cell>1</cell><cell></cell><cell>4</cell><cell>31</cell><cell>33</cell><cell>0.96</cell><cell>0.51</cell><cell>-</cell><cell>1.40</cell><cell>0.80</cell></row><row><cell></cell><cell>merge</cell><cell>1</cell><cell>≤, =</cell><cell>2</cell><cell>17</cell><cell>41</cell><cell>2.19</cell><cell>14.61</cell><cell>-</cell><cell>6.85</cell><cell>-</cell></row><row><cell></cell><cell>merge sort</cell><cell>1</cell><cell>split, merge</cell><cell>6</cell><cell>11</cell><cell>25</cell><cell>2.10</cell><cell>2.10</cell><cell>-</cell><cell>2.52</cell><cell>1.69</cell></row><row><cell></cell><cell>partition</cell><cell>1</cell><cell>≤</cell><cell>4</cell><cell>27</cell><cell>40</cell><cell>2.84</cell><cell>7.89</cell><cell>-</cell><cell>3.42</cell><cell>-</cell></row><row><cell></cell><cell>append with pivot</cell><cell>1</cell><cell></cell><cell>2</cell><cell>28</cell><cell>22</cell><cell>0.22</cell><cell>0.15</cell><cell>0.58</cell><cell>0.22</cell><cell>0.19</cell></row><row><cell></cell><cell>quick sort</cell><cell>1</cell><cell>partition, append w/pivot</cell><cell>6</cell><cell>11</cell><cell>22</cell><cell>2.71</cell><cell>18.45</cell><cell>-</cell><cell>2.49</cell><cell>4.94</cell></row><row><cell></cell><cell>is member</cell><cell>1</cell><cell>false, not, or, =</cell><cell>2</cell><cell>6</cell><cell>28</cell><cell>0.29</cell><cell>0.29</cell><cell>7.90</cell><cell>0.28</cell><cell>-</cell></row><row><cell>Tree</cell><cell>node count preorder</cell><cell>1 1</cell><cell>0, 1, + append</cell><cell>1 2</cell><cell>4 5</cell><cell>18 18</cell><cell>0.20 0.21</cell><cell>0.20 0.20</cell><cell>--</cell><cell>0.91 0.91</cell><cell>0.14 0.15</cell></row><row><cell></cell><cell>create balanced</cell><cell>1</cell><cell>0, inc, dec, ≤, =</cell><cell>2</cell><cell>7</cell><cell>29</cell><cell>0.14</cell><cell>0.15</cell><cell>-</cell><cell>0.21</cell><cell>-</cell></row><row><cell></cell><cell>is member</cell><cell>1</cell><cell>true, false, ≤, =</cell><cell>2</cell><cell>6</cell><cell>37</cell><cell>0.09</cell><cell>0.08</cell><cell>0.10</cell><cell>0.08</cell><cell>-</cell></row><row><cell>BST</cell><cell>insert delete</cell><cell>1 1</cell><cell>≤, = ≤, =</cell><cell>2 2</cell><cell>8 8</cell><cell>55 68</cell><cell>0.91 5.68</cell><cell>0.88 5.62</cell><cell>--</cell><cell>0.82 10.74</cell><cell>--</cell></row><row><cell></cell><cell>BST sort</cell><cell>5</cell><cell>≤, =</cell><cell>6</cell><cell>51</cell><cell>115</cell><cell>1.38</cell><cell>1.35</cell><cell>-</cell><cell>1.25</cell><cell>-</cell></row><row><cell></cell><cell>is member</cell><cell>1</cell><cell>false, not, or, ≤, =</cell><cell>2</cell><cell>6</cell><cell>43</cell><cell>0.38</cell><cell>0.38</cell><cell>9.63</cell><cell>0.35</cell><cell>-</cell></row><row><cell>Binary Heap</cell><cell>insert 1-element constructor 2-element constructor</cell><cell>1 1 1</cell><cell>≤, = ≤, = ≤, =</cell><cell>2 2 2</cell><cell>8 5 6</cell><cell>55 8 55</cell><cell>0.51 0.02 0.08</cell><cell>0.50 0.02 0.08</cell><cell>8.83 0.02 0.25</cell><cell>0.48 0.02 0.07</cell><cell>-0.02 -</cell></row><row><cell></cell><cell>3-element constructor</cell><cell>1</cell><cell>≤, =</cell><cell>2</cell><cell>7</cell><cell>246</cell><cell>2.10</cell><cell>2.12</cell><cell>-</cell><cell>1.98</cell><cell>-</cell></row><row><cell></cell><cell>rotate left</cell><cell>3</cell><cell>inc</cell><cell>3</cell><cell>104</cell><cell>91</cell><cell>11.08</cell><cell>12.43</cell><cell>-</cell><cell>17.06</cell><cell>10.08</cell></row><row><cell></cell><cell>rotate right</cell><cell>3</cell><cell>inc</cell><cell>3</cell><cell>107</cell><cell>91</cell><cell>19.23</cell><cell>18.34</cell><cell>-</cell><cell>36.35</cell><cell>17.87</cell></row><row><cell>AVL</cell><cell>balance insert</cell><cell>1 1</cell><cell>rotate, nodeHeight, isSkewed, isLHeavy, isRHeavy balance, &lt;</cell><cell>4 3</cell><cell>31 22</cell><cell>119 47</cell><cell>1.56 1.84</cell><cell>-1.81</cell><cell>--</cell><cell>1.76 1.64</cell><cell>--</cell></row><row><cell></cell><cell>extract minimum</cell><cell>1</cell><cell>&lt;</cell><cell>5</cell><cell>11</cell><cell>25</cell><cell>1.92</cell><cell>1.87</cell><cell>-</cell><cell>1.72</cell><cell>-</cell></row><row><cell></cell><cell>delete</cell><cell>2</cell><cell>extract minimum, balance, &lt;</cell><cell>5</cell><cell>37</cell><cell>63</cell><cell>15.67</cell><cell>-</cell><cell>-</cell><cell>13.79</cell><cell>-</cell></row><row><cell></cell><cell>balance left</cell><cell>2</cell><cell></cell><cell>9</cell><cell>143</cell><cell>137</cell><cell>5.62</cell><cell>5.53</cell><cell>-</cell><cell>48.47</cell><cell>-</cell></row><row><cell>RBT</cell><cell>balance right</cell><cell>2</cell><cell></cell><cell>9</cell><cell>144</cell><cell>137</cell><cell>7.63</cell><cell>7.72</cell><cell>-</cell><cell>45.32</cell><cell>-</cell></row><row><cell></cell><cell>insert</cell><cell>3</cell><cell>balance left, right, ≤, =</cell><cell>9</cell><cell>49</cell><cell>112</cell><cell>8.95</cell><cell>8.53</cell><cell>-</cell><cell>7.93</cell><cell>-</cell></row><row><cell></cell><cell>desugar AST</cell><cell>1</cell><cell>0, 1, 2</cell><cell>4</cell><cell>5</cell><cell>46</cell><cell>1.17</cell><cell>1.10</cell><cell>-</cell><cell>1.23</cell><cell>0.78</cell></row><row><cell>User</cell><cell>make address book</cell><cell>1</cell><cell>is private</cell><cell>3</cell><cell>5</cell><cell>35</cell><cell>0.62</cell><cell>3.67</cell><cell>-</cell><cell>0.94</cell><cell>0.55</cell></row><row><cell></cell><cell>merge address books</cell><cell>1</cell><cell>append</cell><cell>3</cell><cell>8</cell><cell>19</cell><cell>0.35</cell><cell>5.85</cell><cell>-</cell><cell>0.31</cell><cell>0.24</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>Comparison to other synthesizers. For each benchmark</figDesc><table><row><cell></cell><cell>Benchmark</cell><cell cols="4">Spec SpecS Time TimeS</cell></row><row><cell>LEON</cell><cell>strict sorted list delete strict sorted list insert merge sort</cell><cell>14 14 9</cell><cell>8 8 11</cell><cell>15.1 14.1 14.3</cell><cell>0.10 0.18 2.1</cell></row><row><cell>JEN</cell><cell>BST find bin. heap 1-element</cell><cell>51 80</cell><cell>6 5</cell><cell>64.8 61.6</cell><cell>0.09 0.02</cell></row><row><cell></cell><cell>bin. heap find</cell><cell>76</cell><cell>6</cell><cell>51.9</cell><cell>0.38</cell></row><row><cell>MYTH</cell><cell>sorted list insert list rm adjacent dupl. BST insert</cell><cell>12 13 20</cell><cell>8 5 8</cell><cell>0.12 0.07 0.37</cell><cell>0.25 1.33 0.91</cell></row><row><cell></cell><cell>list remove duplicates</cell><cell>7</cell><cell>13</cell><cell>231</cell><cell>0.36</cell></row><row><cell>λ 2</cell><cell>list drop</cell><cell>6</cell><cell>11</cell><cell>316.4</cell><cell>0.1</cell></row><row><cell></cell><cell>tree find</cell><cell>12</cell><cell>6</cell><cell>4.7</cell><cell>0.29</cell></row><row><cell>ESC</cell><cell>list rm adjacent dupl. tree create balanced</cell><cell>n/a n/a</cell><cell>5 7</cell><cell>1 0.24</cell><cell>1.33 0.14</cell></row><row><cell></cell><cell>list duplicate each</cell><cell>n/a</cell><cell>7</cell><cell>0.16</cell><cell>0.05</cell></row><row><cell>MYTH2</cell><cell>BST insert sorted list insert tree count nodes</cell><cell>n/a n/a n/a</cell><cell>8 8 4</cell><cell>1.81 1.02 0.45</cell><cell>0.91 0.25 0.20</cell></row></table><note><p>we report: Spec, specification size (or the number of input-output examples) for respective tool; SpecS, specification size for SYNQUID (from Tab. 1); Time, reported running time for respective tool; TimeS, running time for SYNQUID (from Tab. 1).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Hereafter the bound variable of the refinement is always called ν and the binding is omitted.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Extending SYNQUID with bounded refinement types<ref type="bibr" target="#b38">[39]</ref> would enable a more natural specification without the ghost argument.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>The same rule handles monomorphic non-scalar variables, assuming zero type variables.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>We prime the names of free type variables to differentiate them from the bound type variables of the top-level goal schema.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>The results for these tools are taken from their respective papers; only differences in the order of magnitude are significant.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Aleksandar Milicevic, Shachar Itzhaky, Ranjit Jhala, and the anonymous reviewers for their valuable input. This work was funded by DARPA Grant FA8750-14-2-0242 (MUSE) and NSF Grants CCF-1139056 and CCF-1438969.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Recursive program synthesis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Kincaid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Maximal specification synthesis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gurfinkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Syntax-guided synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Juniwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raghothaman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Torlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Udupa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMCAD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Synthesis through unification</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Černý</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Radhakrishna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Augustsson</surname></persName>
		</author>
		<ptr target="http://hackage.haskell.org/package/djinn" />
		<title level="m">djinn, the official Haskell package webpage</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Idris, a general-purpose dependently typed programming language: Design and implementation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brady</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Funct. Program</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="552" to="593" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Hipspec: Automating inductive proofs of program properties</title>
		<author>
			<persName><forename type="first">K</forename><surname>Claessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rosén</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Smallbone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ATx/WInG</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An algorithm for type-checking dependent types</title>
		<author>
			<persName><forename type="first">T</forename><surname>Coquand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="167" to="177" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Intersection types and computational effects</title>
		<author>
			<persName><forename type="first">R</forename><surname>Davies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Inductive invariant generation via abductive inference</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Mcmillan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Tridirectional typechecking</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dunfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Synthesizing data structure transformations from input-output examples</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Feser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hybrid type checking</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Exampledirected synthesis: a type-theoretic interpretation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Frankle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Osera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Complete completion using types and weights</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gvero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kuraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Piskac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Proof-pattern recognition and lemma discovery in ACL2</title>
		<author>
			<persName><forename type="first">J</forename><surname>Heras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Komendantskaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Maclean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LPAR</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Type assisted synthesis of recursive transformers on algebraic data types</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Inala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<idno>CoRR, abs/1507.05527</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Programming with refinement types (an introduction to liquidhaskell</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vazou</surname></persName>
		</author>
		<ptr target="https://ucsd-progsys.github.io/liquidhaskell-tutorial" />
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Type-based data structure verification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kawaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Synthesis modulo recursive functions</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kneuss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kuraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Suter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Program extrapolation with Jennisys</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Milicevic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Liffiton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Previti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</author>
		<title level="m">Fast, flexible mus enumeration. Constraints</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Jungloid mining: Helping to navigate the api jungle</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mandelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kimelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Alloy*: A general-purpose higher-order relational constraint solver</title>
		<author>
			<persName><forename type="first">A</forename><surname>Milicevic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Near</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Scheme-based theorem discovery and concept invention</title>
		<author>
			<persName><forename type="first">O</forename><surname>Montano-Rivas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Mccasland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Dixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bundy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert Syst. Appl</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1637" to="1646" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dependently typed programming in agda</title>
		<author>
			<persName><forename type="first">U</forename><surname>Norell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AFP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Type-and-example-directed program synthesis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Osera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Type-directed completion of partial expressions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Perelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Types and Programming Languages</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Local type inference</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">N</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="44" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Polikarpova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kuraj</surname></persName>
		</author>
		<ptr target="https://bitbucket.org/nadiapolikarpova/synquid/" />
		<title level="m">Synquid code repository</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Program synthesis from polymorphic refinement types</title>
		<author>
			<persName><forename type="first">N</forename><surname>Polikarpova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kuraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<idno>CoRR, abs/1510.08419</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Liquid types</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kawaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Program verification using templates over predicate abstraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Satisfiability modulo recursive programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Suter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Köksal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Abstract refinement types</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vazou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Liquidhaskell: experience with refinement types in the real world</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vazou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<editor>Haskell</editor>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Refinement types for haskell</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vazou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vytiniotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L P</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Bounded refinement types</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vazou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bakst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICFP</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Theorems for free! In FPCA</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wadler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Dependent types in practical programming</title>
		<author>
			<persName><forename type="first">H</forename><surname>Xi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pfenning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
