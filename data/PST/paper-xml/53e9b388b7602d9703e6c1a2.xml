<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Design and Implementation of the Ariel Active Database Rule System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><roleName>Member, /€€E</roleName><forename type="first">Eric</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
							<email>hanson@cis.ufl.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department $Computer and Information Sciences</orgName>
								<orgName type="institution">University of Florida</orgName>
								<address>
									<postCode>32611</postCode>
									<settlement>Gainesville</settlement>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Design and Implementation of the Ariel Active Database Rule System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9FE79A9AA430B0FECF2905C13E6A1E9A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Active database systems</term>
					<term>database management systems</term>
					<term>database rule systems</term>
					<term>discrimination networks</term>
					<term>production rule systems</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes the design and implementation of the Ariel DBMS and its tightly-coupled forward-chaining rule system. The query language of Ariel is a subset of POSTQUEL, extended with a new production-rule sublanguage. Ariel supports traditional relational database query and update operations efficiently, using a System R-like query processing strategy. In addition, the Ariel rule system is tightly coupled with query and update processing. Ariel rules can have conditions based on a mix of selections, joins, events, and transitions. For testing rule conditions, Ariel makes use of a discrimination network composed of a special data structure for testing single-relation selection conditions efficiently, and a modified version of the TREAT algorithm, called A-TREAT, for testing join conditions. The key modification to TREAT (which could also be used in the Rete algorithm) is the use of virtual &amp;memory nodes which save storage since they contain only the predicate associated with the memory node instead of copies of data matching the predicate. In addition, the notions of tokens and &amp;memory nodes are generalized to support event and transition conditions.The rule-action executor in Ariel binds the data matching a rule's condition to the action of the rule at rule fire time, and executes the rule action using the query processor.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>HE Ariel system is an implementation of a relational 7: DBMS with a built-in rule system. The Ariel rule system (ARS) is based on the production system model [13]. The approach taken in the design of Ariel has been to adopt as much as possible from previous work on main-memory production systems such as OPS5 1121, but make changes where necessary to improve the functionality and performance of a production system in a database environment. These changes include a rule language extension to POSTQUEL [41] with a query-language-like syntax, a discrimination network for rule condition testing tailored to the database environment, and measures to integrate rule processing with set-oriented database update commands and transactions. A distinguishing feature of Ariel is that it is a complete implementation of a relational DBMS with a rule system that is tightly coupled with the query processor.</p><p>Ariel's rule condition testing mechanism, called A-TREAT, is a variation of the TREAT algorithm [26] enhanced with features to speed up testing of selection predicates in rule conditions, reduce the amount of state information kept in the network, and handle event, transition, and patternbased conditions in a uniform way <ref type="bibr" target="#b14">[19]</ref>, <ref type="bibr">[16]</ref>.</p><p>A project closely related to Ariel is DATEX 1271, [4]. Ariel and DATEX both use discrimination networks for testing rules with conditions containing joins, unlike other current active database systems. DATEX has shown good performance for real OPS5 programs running on moderately sized databases. Some other database rule systems have been developed but have not been implemented in a tightly coupled fashion with the database query processor. These include DIPS 1361, <ref type="bibr">[30]</ref> and RPL <ref type="bibr">[lo]</ref>, <ref type="bibr">[ll]</ref>. <ref type="bibr">Another,</ref><ref type="bibr">HiPAC [9]</ref>, [7], <ref type="bibr" target="#b19">[24]</ref>, has been implemented, but only as a main-memory prototype. The POST-GRES rule system (PRS) <ref type="bibr">[38]</ref>, <ref type="bibr">[41]</ref>, I401 and the Starburst rule system (SE) <ref type="bibr">[43]</ref>, <ref type="bibr">[15]</ref> have been implemented in a tightlycoupled fashion with their respective database systems. However, neither the PE, SRS, DIPS, RPL, nor HiPAC have a rule condition testing network comparable to the one in Ariel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE ARIEL QUERY AND RULE LANGUAGES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Query Language</head><p>Ariel is based on the relational data model and provides a subset of the POSTQUEL query language of POSTGRES for specifying data definition commands, queries, and updates <ref type="bibr">[41]</ref>. POSTQUEL commands retrieve, append, delete, and replace are supported, along with other commands for creating and destroying relations and indexes, and performing utility functions such as loading relations, gathering statistics on data in relations, and so forth. The syntax of POSTQUEL data manipulation commands is shown below. Square brackets indicate optional clauses. In POSTQUEL, the target-list is used to specify fields to be retrieved or updated, thefrom-list is used to specify tuple variable bindings, and the qualification is used to specify a predicate that the data affected by the command must match. In addition, a relation name can be used as a tuple variable name by default, avoiding the need to use a from clause in most cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Rule Language</head><p>ARL is a production rule language with enhancements for defining rules with conditions that can contain relational selections and joins, as well as specifications of events and transitions. The ARL syntax is based on the syntax of the query language. Hence, the syntax of a rule condition is nearly identical to that of the where clause of a query The general form of an ARL rule is the following: A unique rule-name is required for each rule so the rule can be referred to later by the user. The user can optionally specify a ruleset-name to place the rule in a ruleset. Rulesets are merely a convenient way of grouping rules so they can be activated and deactivated simultaneously, displayed together, etc. If no ruleset name is specified when a rule is defined, the rule is placed in the system-defined ruleset default-rules. <ref type="bibr">'</ref> The optional priority clause allows specification of a numeric priority to control the order of rule execution.* The priority can be a floating-point number in the range -1,000 to 1,000. If the priority clause is not present, priority defaults to 0. Priorities are used to help the system order the execution of rules when multiple rules are eligible to m.</p><p>The on clause allows specification of an event that will trigger the rule. The following types of events can be specified after an on clause: Event specifications are provided since in a database environment, it may be important to trigger a rule based on operations performed, not just data values in a new or updated tuple. For example, when a new employee is appended to an employee table, it may be desirable to have rules trigger to initialize information about the employee and take any special actions necessary when an employee is hired. Here, the triggering condition is the append event.</p><p>The condition after the if clause has the following form:</p><formula xml:id="formula_0">qualification [from from-list]</formula><p>The qualzfication part of a rule's if condition has the same form as the qualification of a where clause in a query with some exceptions. A rule's qualification clause can contain only selection and join conditions. Aggregates and the relational projection operation are not allowed. This design was chosen to simplify rule condition testing. The from clause is for specifying bindings of tuple variables to relations. Relation names can be used as default tuple variables.</p><p>Transition conditions are important in a database rule language because application developers often wish to specify transition integrity constraints and alerting conditions. For example, it may be that in a particular application it is important that no one ever be given more than a ten percent raise. To allow transition conditions to be specified in Ariel, a special keyword previous lets a condition refer to the previous value of an attribute. The value that a tuple attribute had at the beginning of a transition can be accessed using the following notation:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>previous tuple-variable.attribute</head><p>There will be cases where a rule must be triggered when any tuple value exists in a relation. To allow any tuple in a relation to be matched, the following conditional expression is provided:</p><p>Any can be thought of as a way to specify a rule condition element (tuple variable) with no selection condition and no joins to any other condition element.</p><p>The then part of the rule contains the action to be performed when the rule fires. The action can be a single data manipulation command, or a compound command which is a do ... end block surrounding a list of commands.</p><p>The binding between the condition and the action of a d e is specified by using the same tuple variable(s) in both. This means a tuple variable appearing in both the rule condition and action ranges in the action only over the data that has matched the rule condition since the last execution of the d e .</p><p>ARL rule conditions are similar to OPS5 conditions in expressive power. The main differences are that unlike OPS5, ARL supports event and transition conditions. However, OPS5 supports negated conditions and ARL does not. Negated conditions are important for the expressive power of a production rule language, and would be a worthwhile feature in an extended version of ARL. ARL also does not include some relational operations, including negation, union, projection and containment. These were intentionally Ieft out to allow a streamlined implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">. 3 Semantics of Rule Execution</head><p>The Ariel rule system uses a production system model. Execution of rules is governed by a recognize-act cycle similar to that used in OPS5 [13]. Ariel rule instantiations are setoriented, which means that when a rule fires, all combinations of tokens that have matched the rule condition since the last time the rule fired are processed at once. any (tuple-variable)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">I Transifions</head><p>Ariel rules are processed after each database transition. A transition in Ariel is defined to be the changes in the database induced by either a single command, or a do ... the commands in the transaction so the entire transaction is a single transition. Each command in a transaction will be considered a transition by itself unless it is enclosed in a block. Blocks are provided to allow programmers to safely update the database with multiple commands when data integrity or consistency might be temporarily violated during the update. Programmers are encouraged to only put a block around groups of commands which might violate integrity or consistency, since use of blocks does incur some performance overhead.</p><p>There are a number of different possible semantics for transition rules. Three possible designs were considered. These will be called level 1, 2 ,and 3 semantics. Level 1 semantics requires that a transition rule wake up immediately after the command that causes a transition that satisfies the rule condition. This means rules must be given a chance to run after every command. An unfortunate consequence is that a programmer cannot specify that a block of commands in a transaction be run with no intervening rules. Also, every rule action must have only one command. Furthermore, it is unclear what to do if two or more transition rules match an updated tuple, and the first rule to execute modifies the tuple. For which new/old tuple value pair should the second rule run?</p><p>The transition rule semantics actually implemented in Ariel is level 2 as described below. Ariel treats transitions as a set of logical events (insertions, modifications and deletions). These logical events are derived by composing the physical events as they occur. Consider the following sequence of changes to the database, where S, is a database state, E, is the net effect of a transition TI, and To is a user-issued transition. In addition, FI is the ith firing of a rule action. TJFJ is the transition induced by rule action firing F,. EO</p><formula xml:id="formula_1">E l E2 E n -1 so 4 s1 -+ s2 -+ s3 ... * Sn TO Tl[Fl] T2[F2] Tn -1[Fn -11</formula><p>The net effect of the transition from state S, to state S, is the composition of E, through</p><p>The net effects of the changes to the database are logically updated after each user-issued command or do ... end block, and the changes continue to accumulate until rules terminate. After rules terminate, the changes are discarded.</p><p>The old value of each old/new tuple pair accumulated is always the value that the tuple had at the beginning of the transition (state So).</p><p>Intuitively, it would be pleasing if the condition of a transition rule referred to the following change in a tuple t:</p><p>the change in t between the beginning of a transition and the current state, or, if the rule has run for t since the beginning of the transition, the change in t between the state the last time the rule executed and the current state. Such a semantics (called level 3) was considered for use in Ariel but the implementation complexity and performance overhead were felt to be prohibitive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Physical Events</head><p>In Ariel, triggering of event-based rules is based on logical events rather than physical events. A logical event is the net effect of one or more physical events. Logical events are defined as follows. The match step finds the set of rules that are eligible to run. The conflict resolution step selects a single rule for exe-cution from the set of eligible rules. Finally, the act step executes the statements in the rule action. The cycle repeats until no rules are eligible to run.</p><p>The conflict resolution strategy for Ariel is motivated by the LEX strategy used in OPS5 <ref type="bibr">[5]</ref>. The idea is to let the rule whose condition was most recently matched go first. However, Ariel's conflict resolution scheme is not the same as LEX because Ariel uses set-01-iented instantiations and OPS5 uses instance-oriented ones. Ariel picks a rule to execute during the conflict resolution phase using the following criteria (after each of the steps, shown below, if there is only one rule still being considered, that rule is scheduled for execution, otherwise the set of rules still under consideration is passed to the next step):</p><p>* Select the rule(s) with the highest priority. * Select the rule(s) most recently awakened. If two or more different rules with the highest priority had their conditions satisfied by the same database transition, then those rules would be tied at this point. If two or more different rules with the highest priority had their conditions satisfied by different transitions, then only the ones that had their conditions satisfied by the latest transition would still be considered after this point.</p><p>* Select the rule(s) whose condition is the most selective. The selectivity is estimated by the query optimizer at the time the rule is compiled. This is possible because the rule condition has the same form as the where clause of a query 0 If more than one rule remains, select one arbitrarily.</p><p>Because Ariel uses set-oriented instantiations, there are situations where a rule that has been on the agenda for a long time and has a lot of data bound to its condition can be "promoted" to the head of the agenda by a small update that causes one new data item to match its condition. This is because how recently a rule was awakened is determined by the last time any data matched the rule's condition. This sort of behavior is inherent in the use of set-oriented instantiations. Some examples are presented below using these relations: The above rule deletes people named "Fritz" from the emp relation if they earn more than $30,000 a year. It does not delete everyone earning more then $30,000 a year if there is someone named "Fritz." The rule will be triggered if an updated emp tuple has name field "Fritz," Use of the "arty" operator: A rule that will fire if there is any tuple in RI and there is a tuple in R2 with attribute "a" greater than 7 can be created as follows: The first creates a new emp tuple with the empty string as name field and the second one sets the name to "Bob." If events are interpreted as physical operations, then this sequence of commands will not trigger rule NoBobs. However, NoBobs will be triggered if the block is treated as the following single logical event: I append emp(name="Bob", age=27, sal=55000, dno=l2) 1 I Ln general, interpretation of events as logical rather than I physical is expected to be more intuitive and easy to use for 1 rule programmers, since they will only have to be con-1 I cerned with eflects of database operations, not the expression 1 of them. Since many different sequences of commands can , have the same effect, considering only the logical effects of 1 updates should simplify design of event-based rules.</p><p>It can be difficult to specify event-based rules to achieve I a desired goal. Hence, it is recommended that rules without event conditions be used whenever possible, since they will be triggered whenever any data matches the if condition, regardless of the event that created or modified the data. An alternative to the NoBobs rule that is not event-based is the following: This rule deletes all emp records with name "Bob" whether they are created by an append or a replace command. The effect of this rule is to place the name and new/old salary pair of every employee that received a raise o f ' I I greater than ten percent in a relation salaryError. Other rules could be defined to trigger on appends to salaryError to take an appropriate action, such as reversing the update, 1 or notifying a person to verify the correctness of the update. I Referring to Fig. <ref type="figure" target="#fig_4">2</ref>, the following is an example illustrat-1 ing Ariel's level 2 transition semantics. Suppose that the following emp tuple is modified by the commands and ~ rules shown below: The above sequence of user commands and rule firings takes the data base from state So to S, as shown in Fig. <ref type="figure" target="#fig_4">2</ref>. The complete definitions of the rules corresponding to firings F, and F2 are not shown since they are not relevant to this example. At each state So through S,, the net effect of all transitions from the start state So is shown in Fig. <ref type="figure" target="#fig_4">2</ref>. Rules get an opportunity to run at states S,, S,, and S , . When an existing tuple is modified, a token is created which contains an old/new-value pair for the tuple, and this token is used to test conditions of rules. A rule with a transition condition on the emp table which is triggered for the employee "Herman" at state S, would be bound to the token shown attached to St in Fig. <ref type="figure" target="#fig_4">2</ref>. See Section 5.3 for details on implementation of transition conditions.</p><p>A drawback of level 2 semantics is that an anomaly can occur, in which a transition rule wakes up, modifies the tuple bound to it, and inadvertently retriggers itself since the net effect of the transition from the old to the new value of the tuple still matches the rule condition. For example, consider the following rule:</p><formula xml:id="formula_2">define rule extraRaise if emp.sa1 &gt; 1.1 * previous emp.sa1 then replace emp(sa1 = emp.sa1 + 500)</formula><p>For values of salary greater than zero, this rule triggers itself infinitely in Ariel. Level 3 semantics can avoid this but carry higher implementation and execution costs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Combining condition types:</head><p>As an example of how ordinary conditions and transition conditions can be combined, suppose one wished to make the raiseLimit rule specific to just the Toy department. This can be done using a selection condition to select the Toy department, and joining the resulting tuples to the emp tuple variable in the normal fashion. A rule that does this is the following: define rule toyRaiseLimit if emp.sal &gt; 1.1 * previous emp.sa1 and emp.dno = dept.dno and dept .name = "Toy" then append to toySalaryError(emp.name, Moreover, event, transition and normal select and join previous emp.sa1, emp.sa1) conditions can all be combined. Consider this example of a rule that uses all three types of conditions to log "demotion" of an employee in the demotions relation: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ARCHITECTURAL OVERVIEW</head><p>The architecture of Ariel, shown in Fig. <ref type="figure" target="#fig_5">3</ref>, is similar to that of System R [2] with additional components attached for rule processing. Ariel has a front-end consisting of a lexer, parser, semantic analyzer, and query optimizer. Ariel is implemented in the E programming language, an extension of C++ that is part of EXODUS <ref type="bibr">[6]</ref>, <ref type="bibr">[32]</ref>. E extends C++ with persistent objects and object collections. The backend of Ariel consists of a query plan executor, and is built on top of E language persistent collections. These collections in turn are built on top of the EXODUS storage manager.</p><p>In addition to the standard front-and back-end components/ Ariel has a rule catalog for maintaining the definitions of rules, a discrimination network for testing rule conditions, a rule execution monitor for managing rule execution, and a rule action planner for binding the data matching a rule condition with the rule action and producing an execution plan for that action. Ariel rule conditions are matched against the data in relations. Hence, relations in Ariel play the role of "working memory" in OPS5 terminology. The rule catalog is composed of a persistent collection of Rule objects. Each rule object contains the rule name, ruleset name, status of the rule (active or inactive), and persistent syntax tree for the rule. The persistent rule syntax tree is obtained by making a persistent copy of the syntax tree output by the parser at the time the rule is defined. The d e catalog maintains the definitions of all rules in the system, and is used whenever a rule is accessed, including the time when a rule is defined, destroyed, activated, deactivated, or triggered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">THE DISCRIMINATION NETWORK</head><p>An efficient strategy for incrementally testing rule conditions as small changes in the database occur is critical for fast rule processing. Rete <ref type="bibr">[13]</ref> and TREAT <ref type="bibr" target="#b21">[26]</ref> are data structures called discrimination networks that are used in main memory implementations of production systems. A simulation study was conducted comparing Rete and TREAT in a database rule system environment, and TREAT usually outperformed Rete <ref type="bibr">[42]</ref>. This lead us to choose a variation of TREAT, called A-TREAT, for use in Ariel. The A-TREAT network in Ariel is a persistent data structure subject to database concurrency control and recovery, unlike the volatile discrimination networks used for typical OPS5 implementations. The network is made up primarily of durable, disk-based objects called nodes. Normally, nodes retain their state between transactions. The few exceptions will be noted later.</p><p>At an abstract level, the A-TREAT algorithm implemented in Ariel works as follows. Logically, a TREAT network for consists of the following: 0 a root node that accepts tokens describing changes to the database, 0 a set of select node2 that test single-relation selection conditions, 0 a set of a-memory nodes, one per select node, that contain the tuples matching the condition in the associated select node, and 0 a set of P-nodes that contain tuples or combinations of tuples that have recently matched rule conditions. The a-memory nodes are connected by join edges labeled with join predicates. Logically, for each transaction there is one P-node for each rule. All types of nodes except P-nodes are persistent. P-nodes are volatile objects that are created on a per-transaction basis for a rule whenever a transaction first causes data to match that rule. The P-nodes created for a transaction are destroyed at the end of the transaction. It is possible that the same rule could be active in two or more transactions simultaneously. Each such transaction would have its own local P-node for that rule.</p><p>Changes to the database are packaged as "+" tokens and "-" tokens, representing inserts and deletes, respectively.</p><p>Condition matching is performed by propagating tokens through the TREAT network. Modifications of existing records are modeled as deletes followed by inserts.</p><p>When a tuple is inserted into the database, a + token is created containing the tuple value and passed to the root node. The root logically broadcasts it to all the select nodes. If a token matches the condition of a select node, it is in-4. In the production systems literature, select nodes are called f-const nodes but the more self-explanatory term borrowed from relational algebra is used here. serted into the associated a-memory node. Next, join processing i s performed. A set called a temporary result (TR) is formed, and initialized to contain only the token t. Then the following algorithm is executed:</p><p>while(there are more a-memory nodes yet to be joined to the TR and the TR is not empty) I</p><p>Let A be any a-memory that has a join edge to another a-memory that has already been processed and is thus already accounted for in the TR.</p><p>l</p><p>Let TR = join(TR,A)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>}</head><p>Once this loop completes, if the TR is empty, processing stops. Otherwise, the contents of the TR are passed to the Pnode (if a P-node does not exist for the rule who's condition was just matched, then a P-node will be created). If the rule</p><p>is not yet on the rule agenda, a rule instantiation is created and placed on the agenda for later execution (see Section 6 for details of the rule agenda). The instantiation contains the rule identifier, and the data in the TR. Since Ariel's instantiations are set-oriented, they contain the entire set of tupIes or compound tuples that have recently matched the rule condition. If the rule is already on the agenda when the TR is passed to the P-node, the data in the TR is added to the data already in the rule instantiation. For a given rule, there will never be more than one active instantiation in a transaction.</p><p>Ariel uses a standard optimization to the TREAT join processing algorithm which is to check immediately after a token is inserted into an a-memory node to see if any other a-memory nodes for the same rule have zero tokens in them. If so, processing stops immediately since no matching can occur.</p><p>If a tuple in the database is deleted, a "-" token for the tuple is created and broadcast from the root. Processing is similar to that for a " + I ' token, except that when a token arrives at an a-memory node, it is deleted from the node, but no joins are performed. Instead, the P-node is scanned to see if any compound tokens in the P-node contain the deleted token as a component. If so, those compound tokens are removed from the P-node. This may cause one or more rule instantiations to be taken off the agenda.</p><p>The example rule in Fig. <ref type="figure">4</ref> will be used to demonstrate different types of discrimination networks. The standard TREAT network for the rule in Fig. <ref type="figure">4</ref> is shown in Fig. <ref type="figure" target="#fig_6">5</ref> . For each ixple variable in the rule, there is a selection condition.</p><p>The portion of the network above the a-memory nodes alphal, alpha2 and alpha3 shows the root node and the select nodes. As an example, suppose the following record was inserted into emp:</p><p>(name="Hilda",age=34, salary=50000, dno=22, jno=17)</p><p>After this insert, the TREAT algorithm would create a + token 5 containing this tuple value. To see if any rule conditions had their conditions matched due to insertion of the tuple, t. would logically be propagated from the root node in Fig. <ref type="figure" target="#fig_6">5</ref> to all nodes connected to the root. It would match only the condition above alphail, sal &gt; 30,000. It would then be inserted into alpha2. Then, if alphal and alpha3 were not empty, t would be joined to either alphal or alpha3. The amemory to join to first would be chosen arbitrarily Then, if the TR formed was not empty, it would be joined to the remaining a node, creating the new, final value of TR. Finally, the contents of TR would be passed to the P-node and the rule agenda would be updated accordingly. define rule SalesClerkRule if emp.sa1 &gt; 30000 and emp.dno = dept.dno and dept.name = "Sales" and emp.jno = job.jno and job.title ="Clerk'' then action Some additional aspects of A-TREAT are designed to both speed up rule processing in a database environment and reduce storage requirements compared with standard TREAT. An important performance optimization in A-TREAT is the use of a special selection predicate index for testing selection conditions of rules <ref type="bibr" target="#b14">[19]</ref>. In addition, A-TREAT introduces a technique for reducing the amount of state information stored in the network, whereby amemory nodes are replaced in some cases by virtual ctmemory nodes which contain only the predicate associated with the node, not the tuples matching the predicate. In addition to these performance enhancement techniques, some extensions to the standard TREAT network have been developed in order to effectively test both transition and event-based conditions with a minimum of restrictions on how such conditions can be used. All of these techniques are discussed in more detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The Selection Predicate Index</head><p>Ariel's predicate indexing method is tailored to the problem of testing rule selection conditions in a database rule system. The predicate testing problem in Ariel is defined as follows. A database is given that contains a set of n relations, R, ... R,, and m production rules (triggers), Y, ... r,. A rule condition can be an expression containing a conjunction of selection conditions and joins. Considering only the selection conditions of the rules, there is a collection of k single-relation predicates, P , 1 I i 5 k. Each predicate restricts one or more attributes of a tuple t from a relation RI where 1 S j S n. It is assumed that any predicate containing a disjunction is broken up into two or more predicates that do not have disjunction, and these predicates are treated separately. The general form of a predicate for purposes of this discussion is a conjunction of the following form:</p><formula xml:id="formula_3">P, s (the tuple t is in relation RI) A C, A C, A ... Cq</formula><p>Each C, 1 I 1 I 9, is a predicate clause defined on a single attribute of relation RI. Such a clause can be either either indexable or a nonindexable. An indexable clause is one of the following, where pl and p, are one of {&lt;, 51:</p><formula xml:id="formula_4">1) C, E const, p, Lattribute p2 const, 2) C, E Lattribute = const,</formula><p>In addition, const, S const,, and both const, and const, are drawn from the domain of legal values for t.attribute. Equality predicates are a special case of range predicates, but since they are so common, they are listed separately. In predicates of type 1, const, may be --oo and const, may be +-. Hence, predicates of the form const, &lt; t.attribute and const, 2 Lattribute and their symmetric variants are special cases of type 1. Nonindexable predicates have the form "function(t.attribute)." Nothing is assumed about the function except that it returns true or false, which is why indexing is not possible.</p><p>Given a set of single-relation selection predicates as described above, Ariel builds a selection predicate index. Searching the index with a tuple t from relation R as search argument quickly returns a list of all the predicates that match t. Predicates can be rapidly inserted or deleted on-line. The selection predicate index has at the top level a hash table, with relation names as keys. Each entry in the table contains a pointer to a second-level index for each relation. This index maintains a list of nonindexable predicates. In addition, the second-level index contains a set of onedimensional indexes, one for each attribute of the relation for which one or more indexable predicate clauses have been defined. All predicate clauses on an attribute which are "indexaMe" are entered in the index on that attribute. A diagram of the data structure implementing this strategy is shown in Fig. <ref type="figure" target="#fig_7">6</ref>.</p><p>An appropriate attribute index for use in this arrangement is one that can efficiently support stabbing queries,</p><p>where given a point, the index can be searched to find all intervals that overlap the point. The index also needs to be efficiently updatable on-line, and relatively simple to implement for different key data types. Indexes that support stabbing queries were discussed in the literature, including the segment tree [34] and the priority search tree <ref type="bibr" target="#b20">[25]</ref> but they do not meet all of Ariel's requirements. Hence, in the design of Ariel, two separate interval indexes, the interval binary search tree (IBS-tree) <ref type="bibr" target="#b13">[18]</ref> and the interval skip list (Islist) 1221, <ref type="bibr" target="#b18">[23]</ref> have been developed for use as these attribute indexes.</p><p>Both the IS-list and the IBS-tree support the execution of stabbing queries. Given a set of n intervals where L intervals overlap the query point, both data structures require O(1og n + L ) time for solution of a stabbing %uery. It has been shown in <ref type="bibr" target="#b17">[22]</ref> that the IS-list requires O(log n) time for insertion and deletion of an intezrval. It is conjectured that IBS-trees also require time O(log n) for insertion and deletion, and empirical evidence suggests this [MI. However, a definitive performance analysis of insertion and deletion time in IBS-trees has not been completed.</p><p>The IBS-tree and the 1S-list are based on the binary search tree and the skip-list <ref type="bibr">[29]</ref>, respectively An IBStree is used in the Ariel implementation. However, the ISlist is somewhat easier to implement than the IBStree and would be preferred for a future implementation. For a compIete discussion of the IBS-tree and IS-list, readers are referred to [HI, 1191 and <ref type="bibr" target="#b17">[22]</ref>, respectively. A simpler one-dimensional attribute index such as a balanced binary search tree or hash table could be used in the arrangement of Fig. <ref type="figure" target="#fig_7">6</ref> if desired. This would make it so only predicates of the form "t.attribute=constant" would be indexable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Saving Storage Using Virtual &amp;Memories</head><p>Ariel uses a variation of the TREAT algorithm that is tuned to minimize storage use. In the standard Rete and TREAT algorithms, there is an a-memory node for every selection condition on every tuple-variable present in a rule condition. If the selection conditions are highly selective, this is not a problem since the a-memories will be small. However, if selection conditions have low selectivity, then a large fraction of the tuples in the database will qual@, and amemories will contain a large amount of data that is redundant since it is already stored in base tables. Storing large amounts of duplicate data is not acceptable in a database environment since the data tables themselves can be huge.</p><p>In order to avoid this problem, for memory nodes that would contain a large amount of data, a virtual memory node can be used which contains a predicate describing the contents of the node rather than the qualifying data itself. This virtual node is like a database view. When the virtual node is accessed, the predicate stored in the node is processed to derive the value of the node. Before processing, the predicate can also be modified by substituting constants from a token in place of variables in the predicate to make the predicate more selective, reducing processing time.</p><p>The algorithm for processing a single insertion token t in an A-TREAT network containing a mixture of stored and virtual a-memory nodes is as follows. A stored a-memory node contains a collection of the tuples matching the associated selection predicate. A virtual a-memory node contains a selection predicate P and the identifier of the relation R on which P is defined. In addition, each transaction maintains a data struchire ProcessedMemories containing a set of the identifiers of the virtual a-memory nodes into which token t has been inserted. ProcessedMemories is initially empty and is emptied before processing of each token.</p><p>Suppose a single tuple X is to be inserted in X. Before actually inserting X in R, a token t is created from X and t is propagated through the selection network. When t filters through the network to an a-memory node A, if A is virtual, the identifier of A is placed in ProcessedMemories.</p><p>Next, t is joined to any a-memories connected to A by a join condition. When joining the token t just placed in A to a memory node A', if A' is a normal a-memory, the system checks to see if t joins to anything in A', just as in the standard TREAT algorithm. If A' is virtual, then the system finds the tuples in the relation from which A' is derived that match the predicate P' of A' , and also match the join condition between t and A'. In addition, if ProcessedMemories contains A' , then t belongs to A'. Hence, the system checks whether the copy o f t just placed in A and the copy of t in A' together match the join condition between A and A'. All the compound tokens created by joining t to A' are placed in a temporary collection, and the system processes each of those compound tokens in a manner similar to the way t was processed. After t is completely processed, Processed-Memories is emptied and the tuple X is inserted into relation R. An analogous procedure is used for processing a deletion token.</p><p>The algorithm just described has the same effect as the normal "TEAT strategy because at every step, a virtual amemory node implicitly contains exactly the same set of tokens as a stored a-memory node. This ensures that if a token joins to itself, it does so exactly the right number of times. The A-TREAT join condition testing algorithm implemented in Ariel makes use of virtual a-memories. In the current Ariel prototype, an a-memory is made virtual only if there is no selection predicate. For example, consider this rule condition: Ariel would generate a virtual a-memory for the tuple variable R2 because it has no selection predicate on Iz2, but the a-memories for R1 and R3 would be stored regardless of how selective their selection predicates were.</p><p>As another example of use of a virtual a-memory an A- TREAT network for the SalesClerkRule rule in Fig. <ref type="figure">4</ref> is shown in Fig. <ref type="figure">7</ref>. Logically equivalent pattern matchingqfor SalesClerkRule can be done using either the network in Fig. <ref type="figure" target="#fig_6">5</ref> or Fig. <ref type="figure">7</ref>. The A-TREAT network is identical to the TREAT network, except that the middle a-memory node (alpha2) is virtual, as indicated by the dashed box around it.</p><p>If the predicate sal &gt; 30,000 is not very selective, then making + append X replace delete alpha2 be virtual may be a reasonable choice for Sales-ClerkRule since it can save a significant amount of storage.</p><p>-A+ A- The ability to use virtual memory nodes opens up several possible avenues of investigation. It allows trading space for time in a Rete or TREAT network. When to use a virtual memory node and when not to use one is an interesting optimization problem. Also, the base relation scan done when joining a token to a virtual a-memory can be done with any scan algorithm-index scan or sequential scan. Some optimization strategy is needed to decide whether or not to use an index if one is available, depending on the type of index (primary or secondary, hash or Btree etc.) and the size of the base relation. More sophisticated heuristics or optimization strategies are being considered as future improvements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Testing Transition, Event, and Normal Conditions</head><p>Unlike standard production systems, Ariel allows rules with transition and event-based conditions in addition to normal selection and join conditions. To integrate all these types of conditions into a coherent framework, the notions of both tokens and a-memory nodes were generalized.</p><p>To accommodate transitions, in addition to standard + andtokens used in traditional production system implementations based on Rete and TREAT, Ariel uses A+ and Atokens which contain an (old, new) pair for a tuple with the value it had before and after being updated. A A+ token inserts a new transition event into the discrimination network, and a A-token removes a transition event from the network.</p><p>To accommodate events, all tokens have an eventspecifier of one of the following forms to indicate the type of event that created the token:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Together append delete replace(turget-list)</head><p>The target-list included with the replace event specifier </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">I Identifying Event and Transition Conditions</head><p>If a tuple variable appears in the on clause of an Ariel rule condition, then the selection condition defined on that variable is considered to be an event-based condition. Similarly, if any tuple variable in the condition has a previous keyword in front of it, then the selection condition associated with that variable is a transition condition. Both transition and event-based conditions have the property that the data matching them is relevant only during the transition in which the matching occurred. Afterwards, the binding between the matching data and the condition should be broken. This is accomplished in Ariel using a-memory nodes that are dynamic, i.e., they only retain their contents during the current transition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Summary of Token and @-memory Types</head><p>The four kinds of tokens that have been identified with respect to transitions are +, -, A+, and A-. To support uniform testing of ordinary conditions as well as transition and event conditions, a total of seven kinds of a-memory nodes have been introduced. The a-memory node types include:</p><p>stored-a: a standard memory node holding a collection of tuples matching the associated selection predicate. virtual-a a virtual memory node holding the predicate but not a collection of matching tuples.</p><p>dynamic-ON-a a dynamic memory node for an ONcondition which has a temporary tuple collection that is flushed after each database transition. dynamic-TRANSa: a dynamic memory node for a trarsition condition which is also flushed after each transition. simple-a an alpha memory for a rule with an ordinary condition containing only one tuple variable. "Simple" memories are only used when the rule has just one tuple variable in its condition. They never contain a persistent collection of data matching the condition associated with them, since matching data is passed directly to the associated P-node. simple-TRANS-a: a simple memory node for a transition condition. simple-ON-a a simple memory node for an event-based (ON) condition.</p><p>If a rule condition has more than one tuple variable, then only stored-a, virtual-a, dynamic-ON-a, and dynamic-TRANS-anodes will be used for the rule.</p><p>A different action needs to be taken when each type of token arrives at each type of memory node. The actions for each of the possible combinations are shown in the table in Fig. <ref type="figure">9</ref>. In the table, "zn,t" represents projection of just the new part of the new/old pair contained in t. A "discard t" entry indicates that the memory node should ignore the token since the combination is not defined.</p><p>The information in this chart allows the standard TREAT algorithm to be generalized to handle normal conditions as well as event-based and transition conditions, changing only the behavior of individual components, not the overall structure or information flow. This strategy is one of the keys to successful use of TREAT to support condition testing for the Ariel rule language.</p><p>As an example of how to apply the table in Fig. <ref type="figure">9</ref>, consider a rule with this condition:  The discrimination network for this rule would have a dynamic-ON-a for the emp tuple variable and a stored-a for the dept tuple variable. Appending an employee named "June" would send an append' token to the dynamic-ON-a for emp. As the table indicates, this token would be inserted in the dynamic-ON-a for emp. In addition, following the rules of the TREAT algorithm, the token would then be joined to the stored-afor dept. The dynamic-ON-afor emp would be cleared after the end of the transition that created the employee "June."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">THE RULE EXECUTION MONITOR</head><p>The rule execution monitor maintains the rule agenda, firing rules as required. The rule agenda is a priority queue, with one entry called a priority group, for each group of rules with equal priority Within a priority group, rules are ordered such that the one whose condition was most recently matched is first.</p><p>The interface to the rule execution monitor includes the foIlowing operations: 0 addRule, called by the discrimination network when a new tuple or combination of tuples matching a rule condition is found. If the rule is not already on the agenda, an activation for the rule is created, and placed at the head of the list for the appropriate priority group.</p><p>* removeRule, called by the discrimination network when a tuple or combination of tuples that used to match the rule condition no longer matches. This tuple or combination of tuples is removed from the Pnode for the rule. If the P-node becomes empty, then the rule is removed from the agenda. 0 FunRules, called by the query executor at the end of processing a database transition. This method transfers control to the rule execution monitor, which dispatches the the most recently triggered rule from the highest priority group fo execution by calling the The operations described above are sufficient to allow the rule execution monitor to maintain a current list of rules eligible to run, and to assume control and run those rules at the appropriate time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Updating the Discrimination Network Structure</head><p>Ariel's discrimination network structure is incrementally modified when a rule is activated or deactivated. At the time a rule is activated, the discrimination network compo-rule action planner. r nents (memory nodes, selection nodes etc.) for it are built and added to the existing discrimination network containing components for all other active rules [33]. Similarly, when a rule is deactivated, its discrimination network components are removed from the overall network. This is different from the approach used by systems like OPS5 where the entire network is built at once, and portions of the network cannot be added or deleted incrementally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">OPTIMIZATION AND EXECUTION OF RULE ACTIONS</head><p>The problem of when to optimize the plan for carrying out a rule action is faced by active database systems like Ariel, but not by production systems such as OPS5. This is because setoriented database commands appear in rule actions in an active DBMS, but in production systems, actions can typically only be single-tuple inserts, updates, or deletes.</p><p>At the time an Ariel rule is scheduled for execution, the data matching the rule condition is stored in the P-node for the rule. Binding between the condition and action of an Ariel rule is indicated by using the same tuple variable in both. These tuple variables are called shared. To run the action of the rule, a query execution plan for each command in the action is generated by the query optimizer. Shared tuple variables implicitly range over the P-node. When a command in the rule action is executed, actual tuples are bound to the shared tuple variables by including a scan of the P-node in the execution plan for the command. Optimization and execution of Ariel rule actions is discussed in detail below, and illustrated using an example.</p><p>When an Ariel rule is first defined, its definition, represented as a syntax tree, is placed in the rule catalog. At the time the rule is activated, the discrimination network for the rule is constructed, and the binding between the condition and the action of the rule is made explicit through a process of query modification [37], after which the modified definition of the rule is stored in the rule catalog. During query modification, references to tuple variables shared between the rule condition and the rule action are transformed into explicit references to the P-node. Specifically for a tuple variable V found in both the condition and action, every occurrence of an expression of the form V.atfribute is replaced by P.V.attribute. In addition, if Vis the target relation of a replace or delete command, then it is replaced by P.V, and the command is modified to be replace' or delete' as appropriate. The commands replace' and delete' behave similarly to the standard replace and delete commands, except that the tuples to be modified or deleted are located by using tuple identifiers that are part of tuples in the P-node, rather than by performing a scan of the relation to be updated.</p><p>For example, consider the rule shown in Fig. <ref type="figure">10</ref>. After query modification is performed on this rule, the commands in its action look as shown in Fig. <ref type="figure" target="#fig_14">11</ref>, where P is a tuple variable that ranges over the P-node. The tuple variable emp which appears both in the condition and action of the rule has been replaced throughout the action by Eemp in Fig. <ref type="figure" target="#fig_14">11</ref>. Also, the replace and delete commands have been transformed into replace' and delete,' respectively The tuple variable dept which does not appear in the condition is unchanged in the action. define rule SalesClerkRule2 if emp.sa1 &gt; 30000 and emp.jno = job.jno and job.title ="Clerkr' then do append to salaryWatch(emp.al1) replace emp (sal = 30000) where emp.dno = dept.dno and dept.name = "Sales" replace emp (sal = 25000) where emp.dno = dept.dno and dept.name != "Sales" end then do append to salaryWatch(P.emp.al1) replace' Pemp (sal = 30000) where P.emp.dno = dept.dno and dept.name = "Sales" replace' Eemp (sal = 25000) where l?emp.dno = dept.dno and dept.name != "Sales" end To execute a command in the rule action, an execution plan for that command must be generated, and this plan must include an operator to scan the P-node if any tuple variables in the command also appear in the rule condition. The Ariel query processor provides an operator called PnodeScan which can scan a P-node and optionally apply a selection predicate to it. When the query optimizer sees the special tuple variable P, it always generates a PnodeScan to find tuples to be bound to P. The rest of the query plan is constructed as usual by the query optimizer. For example, consider construction of the plan for the following command from the action of the rule SalesClerkRule2: The data to be updated by this command are identified by running a query plan which scans P and dept, and joins tuples from these scans. The tuple identifier of each emp sub-tuple bound to the variable P is extracted and used to locate the emp tuple to update.</p><p>One possible query plan that uses a nested loop join, a PnodeScan on and an index scan on dept, is shown in Fig. <ref type="figure" target="#fig_16">12</ref>. The query optimizer is free to choose the best operators for other operations in the plan besides the PnodeScan, e.g., it could have chosen SortMergeJoin instead of Nest-edLoopJoin in Fig. <ref type="figure" target="#fig_16">12</ref>. If a base relation tuple corresponding to a tuple in the Pnode is updated, the P-node tuple itself is not directly modified. In fact, the state of the P-node bound to a single rule action never changes during execution of that rule action. This avoids the potentially serious problem of having the P-node change while it is being scanned by the query executor!</p><p>The following method is used to ensure that the P-node does not change during execution of a rule action <ref type="bibr">[45]</ref>. The set of nonempty P-nodes are kept on a list. Just before a rule action is executed, the rule's P-node is detached from the list. If new data match the rule's condition during execution of the rule's action, a new P-nod&amp; will be created for the rule and added to the list of activk P-nodes. After a rule's action is completed, the P-node that was detached from the list for the rule is discarded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Time of Rule Plan Construction</head><p>The time a rule action plan is constructed can have a substantial impact on performance. Ariel uses a rule action planning strategy called always reoptimize that produces all plans for execution of rule actions at rule fire time. Other strategies can be developed which attempt to preoptimize plans for rule actions, store them, and retrieve them at d e fire time to avoid the cost of run-time optimization. Such strategies may in many cases perform better than the strategy of always reoptimizing. However, all such strategies are more complex than always reoptimize because they require a dependency-tracking facility to make sure invalid plans are not run. Plans may become invalid when, for example, a B-tree index they use as an access path is deleted. A similar issue regarding time of plan compilation is faced by compilers for database application programming languages, such as 4GL's and high-level languages with embedded database statements. Query plan precompilation and invalidation techniques developed for such languages should also apply to the problem of when to compile database commands in rule actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">IMPLEMENTATION</head><p>The current version of Ariel consists of about 31,000 lines of E code. The persistence features of E were useful and helped simplify the design of Ariel. Complex persistent C++ objects were used extensively to represent data and rule catalogs, and the discrimination network. An in-depth discussion of experiences using the persistence features of E in the implementation of Ariel is the subject of another paper <ref type="bibr" target="#b16">[21]</ref>. The well-known benefits of object-oriented programming were observed in the implementation of Ariel. Type hierarchies and inheritance were used extensively to represent fhe syntax trees output by the parser, the different kinds of a-memory nodes, and the operators for constructing query plam. As an example, the class hierarchy for the different types of a-memory nodes in Ariel is shown in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">PERFORMANCE RESULTS</head><p>There are several elements of Ariel's rule processing system that need to be examined from a performance standpoint: I) d e installation and activation facilities, 2) the selection predicate index, 3 ) the join network, and 4) the rule action planner.</p><p>Below we give some performance figures for installing and activating rules in Ariel, as well as for testing tokens using the discrimination network, and executing rule actions. Performance was measured on a Sun SPARCstation 1 computer, running at approximately 12 MIPS. Three types of mles were defined such that type 1,2, and 3 rules have 1,2, and 3 tuple variables, respectively We considered rules with different numbers of tuple variables to assess the cost of testing join conditions of rules. Each rule type has a singlerelation predicate on the table emp of the form C, &lt; empsal and emp.sal 2 C,. For each rule type, a set of unique rules was created by starting with one rule as the base rule (rule 0) and generating rule i by adding i times 1,000 to C, and C , , for i = 1 to the total number of rules. The emp, dept, and proj relations contain only a small number of tuples <ref type="bibr">(25, 7, and 5, respectively)</ref> in the tests performed. We would have preferred to use larger relations, but Ariel does not support indexes on relations, and we felt that without indexes, the cost of processing rules would be dominated by sequential scam of relations and a-memory nodes. Hence, the results would not reflect the potential performance of the discrimination network in the presence of indexes. Performance depends on the structure of the discrimination network, not just the size of the database, so the results with small relations are still somewhat meaningful. With large tables and appropriate indexes defined on those tables, performance results similar to the ones reported below are expected. The Ariel architecture is designed to make use of indexes for installing and activating rules and testing tokens through the discrimination network. B-trees for Ariel will be developed using a new EXODUS B-tree facility Figs. 14 and 15 show the total time required to install and activate 25 to 200 type 1 and 2 rules, as well as the time to test a token generated by a single insert into emp. Fig. <ref type="figure" target="#fig_7">16</ref> 50 100</p><p>shows the same information for 25 to 200 type 3 rules. Rule installation involves storing a persistent copy of the rule syntax tree in the rule catalog, and rule activation involves running one one-variable query for each tuple variable in the rule condition to "prime" the a-memory nodes, plus running a query equivalent to the entire rule condition to load the P-node. These figures show quite reasonable performance for rule installation, which takes a fraction of a second, and rule activation, which takes just under a second. Token testing time takes 2 to 3 milliseconds in the tests performed, which closely matches earlier predictions <ref type="bibr" target="#b14">[19]</ref>. This speed should scale to much larger numbers of rules (given rules of similar structure) because of Ariel's selection predicate index for testing selection conditions of rules <ref type="bibr" target="#b14">[19]</ref>. Not shown in the figures is that it takes approximately 0.06 seconds to run the action of a type 1,2, or 3 rule in all cases. These initial results show that with a good discrimination network it is feasible in an active DBMS to test the conditions of rules with more than one tuple variable. Also, Ariel's selection predicate index makes it possible to efficiently check rule conditions when there are many rules or rule selection conditions (200 or more) on a single table. It should be noted that Ariel's A-TREAT algorithm is not an attempt to obtain higher performance than standard TREAT. Rather, it is a version of TREAT tailored to the database environment to reduce storage usage (via virtual amemories) and handle event, transition, and normal selection and join conditions uniformly (via extended token and a-memory types). However, because TREAT/A-TREAT is being used outside the normal main-memory environment, an important topic for future work is an in-depth study of the performance of Ariel's rule system using a larger database and rules that support a real application. ). Other distinguishing features of Ariel are its close adherence to the production system model, its unified treatment of rules with normal conditions as well as event-based and transition conditions, its ability to run rule action commands without creating any additional joins to the P-node, and its use of a rule-action planner that produces optimal plans for executing rule actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">REVIEW OF RELATED WORK</head><p>The POSTGRES Rule System <ref type="bibr">[38], 1391, [41]</ref>, 1401 is a sophisticated tuple-level rule system that allows triggers and integrity constraints to be defined with event and pattembased conditions on a single tuple. It is a functioning component of the POSTGRES implementation. The POSTGRES designers have made the choice to trigger rules with singletuple conditions as soon as the conditions of the rules are satisfied, during processing of a database update command or query This approach makes it possible to design triggers with fine-grained, immediate response to changes, as well as implement rules which can modify tuple contents as data is being retrieved. This latter feature can be useful for implementing security and integrity features such as denying access to certain records or fields to a particular user. However, compared with rule systems with a rule agenda and scheduling mechanism that runs rules at the end of a command, group of commands, or transaction, the PRS approach is less flexible in its ability to schedule multiple rules based on recency and priority. In addition, since PRS is a tuple-level rule system, it can't take advantage of performance optimizations that can be done by set-oriented rule systems that process all data matching a rule condition together.</p><p>The HiPAC system has a sophisticated trigger model which allows specification of multiple coupling modes describing the time rule conditions are evaluated and rule actions are run. These include immediate, deferred, and decoupled modes for both conditions and actions <ref type="bibr">[e]</ref>. In contrast, Ariel executes all rules in the HiPAC mode condition=immediate and action=deferred. The HiPAC design was partially implemented in a main-memory-based prototype.</p><p>DATEX is focusing on making large production system programs run efficiently on large databases [27], [4]. Its designers have approached the problem by creating an OPS5like system that is tightly coupled with the Genesis DBMS <ref type="bibr">[3]</ref>. DATEX has successfully run real OPS5 programs on persistent databases with a few thousand or more facts, with performance averaging within a factor of 22 of a fast main-memory <ref type="bibr">OPS5 system [4]</ref>. This level of performance should be considered high because in DATEX, the production system's working memory is durable, disk-based data. A philosophical difference between Ariel and DATEX appears to be that Ariel has approached the problem of making production rules run on a database by extending a DBMS with rule processing features, while DATEX has added database features to a rule processing system. Both Ariel and DATEX use variations of the TREAT algorithm for rule condition matching. Unlike DATEX, Ariel's rule language is a natural extension of a data manipulation language. However, a version of DATEX with more database features, in particular an SQL-derived query interface and rule language, is planned.</p><p>RPL has a rule language based on SQL which is quite similar to the Ariel rule language. It provides an interesting model for a production-rule-like trigger language extension for SQL. RPL was implemented on top of another database system without a significant attempt to optimize rule condition testing [ 101.</p><p>The work on the Data Intensive Production System (DIPS) describes a strategy for implementation of OPS5 on top of a relational DBMS <ref type="bibr">[36]</ref>. DIPS uses mechanisms based on tables of partial matches that test rule conditions differently from traditional Rete and TREAT networks. However, no clear performance measuremenk have been done to show which condition testing strategy is superior.</p><p>The Starburst Rule System (SRS) [44], [43] is a setoriented rule system built on top of the Starburst extended relational DBMS. Starburst, similar to Ariel, allows specification of rules with sophisticated transition conditions. SRS provides an elegant form of level 3 transition rule semantics as described in Section 2.3.1. However, it does not use any form of discrimination network for testing rule conditions. It essentially is required to execute a query for every rule that might be affected by a particular update, which could have prohibitive overhead if there are more than a few d e s per relation.</p><p>Alert is another rule system on top of Starburst which uses an architecture for transforming a passive DBMS into an Active DBMS <ref type="bibr">[35]</ref>. Alert provides some interesting mechanisms for defining triggers using queries which return a cursor that can be accessed again to find new matching data even after an end of file (EOF) has been returned. This provides a convenient extension to relational database programming facilities to allow them to use data produced by active rules. However, Alert does not have a rule condition testing mechanism that is efficient for a very general class of rules. Their approach to testing selection conditions of rules is similar to PRS.</p><p>Regarding rule execution semantics, Ariel's set-oriented instantiations are different than the instance-oriented instantiations used in OP5 and PRSII, which allow multiple occurrences of the same rule to be simultaneously eligible to run, with one instance for each combination of tuples matching the rule condition. The set-oriented instantiations of Ariel are most similar to those in SRS.</p><p>Finally there has recently been some work on an active object-oriented database called Ode <ref type="bibr">[14]</ref>. Ode rule conditions are checked for an individual object after the object has been updated by a method call. A general pattern matching mechanism like the one used in Ariel is not used in Ode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">I CONCLUSIONS</head><p>The Ariel project has shown that a database system can be built with an active rule system that is based on the production system model, e is set-oriented, is tightly integrated with the DBMS, * provides condition-action binding based on shared tuple variables, * supports event, transition, and ordinary conditions in a d o r m way and e is implemented in an efficient fashion using a specially designed discrimination network, and a ruleaction planner that takes advantage of the existing query optimizer.</p><p>Ariel is unique in its use of a selection-predicate index that can efficiently test point, interval and range predicates of rules on any attribute of a relation, regardless of whether indexes to support searching (e.g., B+-trees) exist on the attribute. Some commercial database rule systems already support triggers using a general predicate on a single relation (e.g., the commercial INGRES system [l]). A selection predicate index like the one €or Ariel could be incorporated into systems like this to improve performance. Since the effectiveness of the selection-predicate index has been demonstrated [29], and only a few thousand lines of code are required to implement such an index, including one in a commercial system should not be a risky undertaking.</p><p>The concept of virtual a-memory nodes introduced in Ariel can save a tremendous amount of storage, yet still allow eecient testing of rules with joins in their conditions. The ability to use virtual memory nodes in a database rule system discrimination network opens up tremendous possibilities for optimization, in which the most worthy memory nodes would be materialized for the best possible performance given the available storage. Prior to the development of the virtual memory node concept, it was mandatory to materialize the a-memory nodes, limiting potential optimizations.</p><p>Another unique feature of Ariel is its use of generalized tokens and memory nodes to support transition, event, and ordinary conditions uniformly This demonstrated that the semantic features of an active database rule language can be made more powerful than OPS5, yet a discrimination network can still be used to make rule condition testing efficient. For the future, there are a number of research areas being investigated to enhance Ariel. One involves optimization of discrimination network structure to provide good performance given the database update pattern, size of relations and memory nodes, join relationships in the rule condition, etc. <ref type="bibr">[17]</ref>. Another considers support for streamlined development of reliable, recoverable applications that can receive data from database triggers asynchronously <ref type="bibr">[20]</ref>. Potential applications of this proposed active database/application communication mechanism are safety and integrity alert monitors, financial trading analysis programs, and com-mand and control systems. Also, performance gained by effectively using parallelism in an active DBMS may add significant value to the information in databases. Hence, a longer-term goal is support for fast rule condition testing and execution in a DBMS using large-scale parallel processors.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>qual. i f ica t ion 1 delete tuple-variable [from from-list] [where T a l i f i ca t ion1 1041-4347/96$05.00 01996 IEEE replace [to] tuple-variable ( target-list) [from from-list] [where qual i f i ca ti on]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>0</head><label></label><figDesc>append [to] relafion-name 0 delete [from] relation-name e replace [to] relation-name [(attribute-lisf)]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>formal definition of transitions induced by updates in relational database systems has been proposed byWidom and Finkelstein [MI.    </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Transitions for example command and rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Diagram of the Ariel system architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FigFig. 5 .</head><label>5</label><figDesc>Fig. 4. Example rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. High-level diagram of predicate indexing scheme.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>R1.a &gt; 50 and R1.b = R2.c and R2.d = R3.e and R3.f = "blue"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Fig. 7. Example A-TREAT network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Possible update sequences to a single tuple during a transition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Fig. 9.Table showing actions taken by each a-memory type for each</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>S 5 .</head><label>5</label><figDesc>The optimization of a rule action plan is different from optimization of a join order plan for performing rule condition matching using a discrimination network. Other researchers have explored the later issue [28].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. IO .</head><label>IO</label><figDesc>Fig. IO. Example rule to illustrate query modification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Rule action after query modification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>replace' P.emp (sal = 30,000) where P.emp.dno = dept.dno and dept .name = 'Sales"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Example execution plan for a command in a rule action.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>FigFig. 13 .</head><label>13</label><figDesc>Fig. 13. Hierarchy of a-memory node types in Ariel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>end</figDesc><table><row><cell>Update type I</cell></row></table><note><p>description im' insertion of t followed by zero or mnre modifications block containing a list of simple command^.^ Blocks may not be nested. The programmer designing a database transaction thus has control over where transitions occur. If desired, the programmer can put a do ... end block around all</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>emp(name, age, salary, dno, jno) dept(dno, name, building) job(jno, title, paygrade, description) Condition-action binding: This rule</head><label></label><figDesc></figDesc><table><row><cell>illustrates condition-</cell></row><row><cell>action binding based on common tuple variables in the rule</cell></row><row><cell>condition and action:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>define rule FritzRule if emp.name = "Fritz" then delete emp where emp.sa1 &gt; 30,000</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>define rule AnyRule if any(R1) and R2.a &gt; 7 then.. . Logical vs. physical events: Ariel</head><label></label><figDesc>'s use of logical rather than physical events is illustrated by the following example rule:</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>define rule NoBobs on append emp if emp.name = "Bob" then delete emp</head><label></label><figDesc></figDesc><table><row><cell>The effect of this rule is to never let anyone named "Bob"</cell></row><row><cell>be appended to the emp relation. Consider the following</cell></row><row><cell>block of update commands:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>do append emp(name="", age=27, sal=55000, dn0=12) replace emp (name="Bob" ) where emp .name=" " end</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Transition conditions: This rule illustrates use of a transi- tion condition: define rule raiseLimit if emp.sal &gt; 1.1 * previous emp.sal i then append to salaryError(emp.name, previous I emp. sal, emp. sal) I</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>define rule findDemotions on replace emp</head><label></label><figDesc>( jno) if newjob.jno = emp.jno and oldjob.jno = previous emp.jno and newjob.paygrade &lt; oldjob.paygrade from oldjob in job, newjob in job Similar to previous examples, other rules could be made to trigger when new tuples are appended to the demotions relation to take appropriate action.</figDesc><table><row><cell>then append to demotions</cell></row><row><cell>(name=emp.name, dno=emp.dno,</cell></row><row><cell>oldjno=oldjob. jno, newjno=newjob. jno)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>Table showing actions taken by each a-memory type for each</figDesc><table><row><cell>token type.</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>This work was supported in part by the U.S. Air Force Office of Scientific Research under grant number AFOSR-89-0286.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">System R Relational approach to database management</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Blasgen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Eswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Griffiths</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">F</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Mcjones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Mehl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R</forename><surname>Putzolu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Traiger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Wade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Wise</surname></persName>
		</author>
		<idno>131 141 [51 I61 [71 I81 191</idno>
	</analytic>
	<monogr>
		<title level="m">GENESIS An extensible database managment system</title>
		<title level="s">Readings in Object-Oriented Database Systems</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Zdonik</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</editor>
		<meeting><address><addrLine>San Mateo, Calif</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kauhann</publisher>
			<date type="published" when="1976-06">June 1976. 1990</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="500" to="518" />
		</imprint>
	</monogr>
	<note>INGRESISQL Reference Manual</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Index support for rule activation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Brant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Miranker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Int&apos;l Conf Management of Data</title>
		<meeting>ACM SIGMOD Int&apos;l Conf Management of Data</meeting>
		<imprint>
			<date type="published" when="1993-05">May 1993</date>
			<biblScope unit="page" from="42" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Programming Expert Systems in OPS5 An Introduction to Rule-Based Programming</title>
		<author>
			<persName><forename type="first">L</forename><surname>Brownston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Farrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The architecture of the EXODUS extensible DBMS</title>
		<author>
			<persName><forename type="first">M</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shekita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Muralikrishna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Int&apos;l Workshop Object-Oriented Database Systems</title>
		<imprint>
			<date type="published" when="1986-09">Sept. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Rule management and evaluation: An active DBMS perspective</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="20" to="28" />
			<date type="published" when="1989-09">Sept. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Chakravarthy</surname></persName>
		</author>
		<idno>XAIT-89-02</idno>
		<title level="m">HiPAC: A research project in active, timeconstrained database management, final technical report</title>
		<imprint>
			<date type="published" when="1989-08">Aug. 1989</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Xerox Advanced Information Technology</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The HiPAC project: Combining active databases and timing constraints</title>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Blaustein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Buchmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="51" to="70" />
			<date type="published" when="1988-03">Mar. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The relational production language: A production language for relational databases</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M L</forename><surname>Delcambre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Etheredge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M L</forename><surname>Delcambre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Etheredge</surname></persName>
		</author>
		<idno>CMU-CS-81- 135</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-M O D Int&apos;l Conf. Management of Data</title>
		<meeting>ACM SIG-M O D Int&apos;l Conf. Management of Data<address><addrLine>Chicago; Pittsburgh</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1981-07">Apr. 1988. June 1988. July 1981</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="396" to="403" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon Univ</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>OPS5 user&apos;s manual</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Rete: A fast algorithm for the many patterdmany object pattern match problem</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Forgy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Art@cial Intelligence</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="17" to="37" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Ode as an active database: Constraints and triggers</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gehani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int&apos;l Conf. Very Large Data Buses</title>
		<meeting>17th Int&apos;l Conf. Very Large Data Buses</meeting>
		<imprint>
			<date type="published" when="1991-09">Sept. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Starburst mid-flight: As the dust clears</title>
		<author>
			<persName><forename type="first">L</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Lohrnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="160" />
			<date type="published" when="1990-03">Mar. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Rule condition testing and action execution in Ariel</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM SIGMOD Int&apos;l Conf. Management .f Data</title>
		<imprint>
			<biblScope unit="page" from="49" to="58" />
			<date type="published" when="1992-06">June 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Gator: A generalized discrimination network for production rule matching</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IJCAl Workshop on Production Systems and their Innovative Applications</title>
		<meeting>IJCAl Workshop on Production Systems and their Innovative Applications</meeting>
		<imprint>
			<date type="published" when="1993-08">Aug. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The IBS tree: A data structure for finding all intervals that overlap a point</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chaabouni</surname></persName>
		</author>
		<idno>WSU-CS-90-11</idno>
		<imprint>
			<date type="published" when="1990-04">Apr. 1990</date>
		</imprint>
		<respStmt>
			<orgName>Wright State Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A predicate matching algorithm for database rule systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chaabouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-M O D Int&apos;l Con5 Management of Data</title>
		<meeting>ACM SIG-M O D Int&apos;l Con5 Management of Data</meeting>
		<imprint>
			<date type="published" when="1990-05">May 1990</date>
			<biblScope unit="page" from="271" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">An architecture for recoverable interaction between applications and active databases</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dastur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ramaswamy</surname></persName>
		</author>
		<idno>CIS-TR-93-024</idno>
		<imprint>
			<date type="published" when="1993-07">July 1993</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of Florida</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>extended abstract</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Experiences in database system implementation using a persistent programming language</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Harvey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>software Practice and Experience</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The interval skip list: A data structure for finding all intervals that overlap a point</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
		<idno>TR92-016</idno>
		<imprint>
			<date type="published" when="1992-06">June 1992</date>
		</imprint>
		<respStmt>
			<orgName>CIS Dept., Univ. of Florida</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Rule processing in active database systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l]. Expert Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="83" to="119" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The architecture of an active data base management system</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SlGMOD Int&apos;l Conf Management of Data</title>
		<meeting>ACM SlGMOD Int&apos;l Conf Management of Data</meeting>
		<imprint>
			<date type="published" when="1989-06">June 1989</date>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Priority search trees</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Mccreight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Computing</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="257" to="278" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">TREAT: A better match algorithm for AI production systems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Miranker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAl Nat&apos;l Con5 Arf$&amp;l Intelligence</title>
		<meeting>AAAl Nat&apos;l Con5 Arf$&amp;l Intelligence</meeting>
		<imprint>
			<biblScope unit="volume">301</biblScope>
			<biblScope unit="page">1321</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An algorithmic basis for integrating production systems and large databases</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Miranker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Brant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Data Eng</title>
		<meeting>IEEE Data Eng</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="353" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The organization and performance of a TREAT-based production system compiler</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Miranker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Lofaso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Pans. Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="10" />
			<date type="published" when="1991-03">Mar. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Skip lists: A probablistic alternative to balanced trees</title>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="668" to="676" />
			<date type="published" when="1990-06">June 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Exploiting concurrency in a DBMS implementation for production systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Raschid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Lin</surname></persName>
		</author>
		<idno>UMIACS-TR-89-5</idno>
		<imprint>
			<date type="published" when="1989-01">Jan. 1989</date>
		</imprint>
		<respStmt>
			<orgName>Univ. of Maryland</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Transition and event condition testing and rule execution in Ariel</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rastogi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-06">June 1991</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science and Eng., Wright State Univ.</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Programming constructs for database system implementation in EXODUS</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2987 ACM SIGMOD Int&apos;l Con&amp; Management of Data</title>
		<meeting>2987 ACM SIGMOD Int&apos;l Con&amp; Management of Data</meeting>
		<imprint>
			<date type="published" when="1987-05">May 1987. Oct. 1991</date>
			<biblScope unit="page" from="208" to="219" />
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science and Eng., Wright State Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
	<note>Rule condition network generation and activation in Ariel</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">The Design and Analysis of Spatial Data Structures</title>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Addison Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Alert: An architecture for transforming a passive DBMS into an active DBMS</title>
		<author>
			<persName><forename type="first">U</forename><surname>Schreier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mohan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Roc. 27th Int&apos;l Conf</title>
		<imprint>
			<date type="published" when="1991-09">Sept. 1991</date>
			<publisher>Veiy Large Data Bases</publisher>
			<pubPlace>Barcelona</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Implementation of integrity constraints and views by query modification</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Raschid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SCM SIGMOD Int&apos;l Conf. Management of Data</title>
		<meeting>SCM SIGMOD Int&apos;l Conf. Management of Data</meeting>
		<imprint>
			<date type="published" when="1975">Sept. 1989. June 1975</date>
			<biblScope unit="page" from="65" to="78" />
		</imprint>
	</monogr>
	<note>SIGMOD Record</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The POSTGRES rule manager</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Potamianos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="897" to="907" />
			<date type="published" when="1988-07">July 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A commentary on the POSTGRES rules system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hearst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Potaminos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="5" to="11" />
			<date type="published" when="1989-09">Sept. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The POSTGRES nextgeneration database management system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kemnitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="78" to="92" />
			<date type="published" when="1991-10">Oct. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The implementation of POSTGRES</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Row</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hirohama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="125" to="142" />
			<date type="published" when="1990-03">Mar. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A performance comparison of the Rete and TREAT algorithms for testing database rule conditions</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Hanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Data Eng</title>
		<meeting>IEEE Data Eng</meeting>
		<imprint>
			<date type="published" when="1992-02">Feb. 1992</date>
			<biblScope unit="page" from="88" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Implementing setoriented production rules as an extension to Starburst</title>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Cochrane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Lindsay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>27th Int&apos;l Conf. Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Set-oriented production d e s in relational database systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Finkelstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1990 ACM SIGMOD I d 1 Conf. Management of Data</title>
		<meeting>1990 ACM SIGMOD I d 1 Conf. Management of Data</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="259" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Eric N. Hanson received a BS degree in computer science from Cornel1 University in 1983, and M S and PhD degrees from the University of California, Berkeley, in 1984 and 1987, respectively. He joined the University of Florida Computer and Information Sciences Department in 1992 where he is now an assistant professor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">From 1987 through 1991 he served as an activeduty officer in the U.S. Air Force. His main field of research is active database systems with a focus on rule condition testing techniques. His other research interests include strategies for materializing derived objects such as views</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1991-09">Sept. 1991</date>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science and Eng., Wright State Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
	<note>Rule join condition testing in Ariel. as well as scientific databases, and multimedia databases. Dr. Hanson is a member of the IEEE</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
