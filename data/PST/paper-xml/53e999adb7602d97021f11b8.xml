<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Quick Convergecast in ZigBee Beacon-Enabled Tree-Based Wireless Sensor Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Meng-Shiuan</forename><surname>Pan</surname></persName>
							<email>mspan@cs.nctu.edu.tw</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">National Chiao-Tung University Hsin-Chu</orgName>
								<address>
									<postCode>30010</postCode>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yu-Chee</forename><surname>Tseng</surname></persName>
							<email>yctseng@cs.nctu.edu.tw</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">National Chiao-Tung University Hsin-Chu</orgName>
								<address>
									<postCode>30010</postCode>
									<country key="TW">Taiwan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Quick Convergecast in ZigBee Beacon-Enabled Tree-Based Wireless Sensor Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">896C9C67F367DA7ABC03B6FDBC8E9093</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>convergecast</term>
					<term>graph theory</term>
					<term>IEEE 802.15.4</term>
					<term>scheduling</term>
					<term>wireless sensor network</term>
					<term>ZigBee</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Convergecast is a fundamental operation in wireless sensor networks. Existing convergecast solutions have focused on reducing latency and energy consumption. However, a good design should be compliant to standards, in addition to considering these factors. Based on this observation, this paper defines a minimum delay beacon scheduling problem for quick convergecast in ZigBee tree-based wireless sensor networks and proves that this problem is NP-complete. Our formulation is compliant with the lowpower design of IEEE 802.15.4. We then propose optimal solutions for special cases and heuristic algorithms for general cases. Simulation results show that the proposed algorithms can indeed achieve quick convergecast.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The rapid progress of wireless communication and embedded micro-sensing MEMS technologies has made wireless sensor networks (WSNs) possible. A WSN consists of many inexpensive wireless sensors capable of collecting, storing, processing environmental information, and communicating with neighboring nodes. Applications of WSNs include wildlife monitoring <ref type="bibr" target="#b1">[3,</ref><ref type="bibr">4]</ref>, object tracking <ref type="bibr" target="#b13">[16,</ref><ref type="bibr" target="#b15">18]</ref>, and dynamic path finding <ref type="bibr" target="#b12">[15,</ref><ref type="bibr" target="#b16">19]</ref>.</p><p>Recently, several WSN platforms have been developed, such as MICA <ref type="bibr" target="#b3">[6]</ref> and Dust Network <ref type="bibr">[2]</ref>. For interoperability among different systems, standards such as ZigBee <ref type="bibr" target="#b21">[24]</ref> have been developed. In the ZigBee protocol stack, physical and MAC layer protocols are adopted from the IEEE 802.15.4 standard <ref type="bibr" target="#b10">[13]</ref>. ZigBee solves interoperability issues from the physical layer to the application layer.</p><p>ZigBee supports three kinds of networks, namely star, tree, and mesh networks. A Zig-Bee coordinator is responsible for initializing, maintaining, and controlling the network.</p><p>A star network has a coordinator with devices directly connecting to the coordinator. For tree and mesh networks, devices can communicate with each other in a multihop fashion.</p><p>The network is formed by one ZigBee coordinator and multiple ZigBee routers. A device can join a network as an end devices by the associating with the coordinator or a router.</p><p>In a tree network, the coordinator and routers can announce beacons. However, in a mesh network, regular beacons are not allowed. Beacons are an important mechanism to support power management. Therefore, the tree topology is preferred, especially when energy saving is a desirable feature. To support ZigBee beacon-enabled tree networks, the IEEE 802.15 WPAN Task Group 4 further defines a revision of the IEEE 802. <ref type="bibr" target="#b12">15</ref>.4 <ref type="bibr" target="#b11">[14]</ref> specification in 2006. One of the major changes is structure of superframes to support power management. On the contrary, to our understanding, power management is still impossible for mesh-based ZigBee networks in the current specification. Therefore, we will focus on tree-based, beacon-enabled ZigBee networks in this work.</p><p>Considering that data gathering is a major application of WSNs, convergecast has been investigated in several works <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b14">17,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b20">23]</ref>. With the goals of low latency and low energy consumption, reference <ref type="bibr" target="#b17">[20]</ref> shows how to connect sensors as a balanced reporting tree and how to assign CDMA codes to sensors to diminish interference among sensors, thus achieving energy efficiency. The work <ref type="bibr" target="#b20">[23]</ref> aims to minimize the overall energy consumption under the constraint that sensed data should be reported within specified time. Dynamic programming algorithms are proposed by assuming that sensors can receive multiple packets at the same time. As can be seen, both <ref type="bibr" target="#b17">[20]</ref> and <ref type="bibr" target="#b20">[23]</ref> are based on quite strong assumptions on communication capability of sensor nodes and they do not fit into the ZigBee specification.</p><p>In <ref type="bibr" target="#b14">[17]</ref>, the authors propose an energy-efficient and low-latency MAC, called DMAC. Sensors are connected by a tree and stay in sleep state for most of the time. When sensors change to active state, they are first set to the receive mode and then to the transmit mode. DMAC achieves low-latency by staggering wake-up schedules of sensors at the time instant when their children switch to the transmit mode. Similar to <ref type="bibr" target="#b14">[17]</ref>, reference <ref type="bibr" target="#b8">[11]</ref> arranges wake-up schedule of sensors by taking traffic loads into account. Each parent periodically broadcasts an advertisement containing a set of empty slots. Children nodes request empty slots according to their demands. In <ref type="bibr" target="#b6">[9]</ref>, the authors propose a distributed convergecast scheduling algorithm. The basic concept is to connect nodes by a spanning tree. Then the algorithm reduces the tree to multiple lines. For each line, the algorithm schedules nodes' transmission times in a bottom-up manner. Reference <ref type="bibr" target="#b5">[8]</ref> presents a centralized solution to convergecast.</p><p>The algorithm divides nodes into many segments such that the transmission of a node in a segment does not cause interference to other transmissions in the same segment. The aim is to increase the degree of parallel transmissions to decrease latencies. Although these results <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b14">17]</ref> are designed for quick convergecast, the solutions are not compliant to the Zig-Bee standard for the following two reasons. Firstly, in these works, nodes' wake/sleep times are dynamically changed according to their schedules. However, in a ZigBee beacon-enabled tree network, nodes' wake/sleep times must be fixed in the way that each router wakes up twice in each cycle to receive its children's packets and to transmit packets to its parent, respectively. The coordinator (resp., an end device) wakes up once to receive its children's packets (resp., to transmit packets to its parent). Secondly, the scheduling of <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b14">17]</ref> is transmission-based, while ours are receiving-based. The implication is that the former may cause a router to be active multiple times per cycle. This is incompatible with the ZigBee specification.</p><p>This paper aims at designing quick convergecast solutions for ZigBee tree-based, beaconenabled WSNs. This work is motivated by the following observations. First, we see that most related works are not compliant to the ZigBee standard. Second, we believe that treebased topology is more suitable if power management is a main concern in WSNs. The network scenario is shown in Fig. <ref type="figure" target="#fig_0">1</ref>. The network contains one sink (ZigBee coordinator), some ZigBee routers, and some ZigBee end devices. Each ZigBee router is responsible for collecting sensed data from end devices associated with it and relaying incoming data to the sink. According to specifications, a ZigBee router can announce a beacon to start a superframe. Each superframe consists of an active portion followed by an inactive portion.</p><p>On receiving its parent router's beacon, an end device has to wake up for an active portion to sense the environment and communicate with its coordinator. However, to avoid collision with its neighbors, a router should shift its active portion by a certain amount.  In a beacon-enabled star network, a device only needs to be active for 2 -(BO-SO) portion of the time. Changing the value of (BO-SO) allows us to adjust the on-duty time of devices.</p><p>However, for a beacon-enabled tree network, routers have to choose different times to start their active portions to avoid collision. Once the value of (BO -SO) is decided, each router can choose from 2 BO-SO slots as its active portion. In the revised version of IEEE 802.15.4</p><p>[14], a router can select one active portion as its outgoing superframe, and based on the active portion selected by its parent, the active portion is called its incoming superframe (as shown in Fig. <ref type="figure">2(b)</ref>). In an outgoing/incoming superframe, a router is expected to transmit/receive a beacon to/from its child routers/parent router. When choosing a slot, neighboring routers' active portions (i.e., outgoing superframes) should be shifted away from each other to avoid interference. This work is motivated by the observation that the specification does not clearly define how to choose the locations of routers' active portions such that the convergecast latency can be reduced. In our work, we consider two kinds of interference between routers. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Minimum Delay Beacon Scheduling (MDBS) Problem</head><p>This section formally defines the convergecast problem in ZigBee networks. Given a ZigBee network, we model it by a graph G = (V, E), where V contains all routers and the coordinator and E contains all symmetric communication links between nodes in V . The coordinator also serves as the sink of the network. End devices can only associate with routers, but are not included in V . From G, we can construct an interference graph G I = (V, E I ), where edge (i, j) ∈ E I if there are direct/indirect interferences between i and j. There is a duty cycle requirement α for this network. From α and Table <ref type="table" target="#tab_1">1</ref>, we can determine the most appropriate value of BO -SO. We denote by k = 2 BO-SO the number of active portions (or slots) per beacon interval.</p><p>The beacon scheduling problem is to find a slot assignment s(i) for each router i ∈ V , where s(i) is an integer and s(i) ∈ [0, k -1], such that router i's active portion is in slot s(i)</p><p>and</p><formula xml:id="formula_0">s(i) = s(j) if (i, j) ∈ E I .</formula><p>Here the slot assignment means the position of the outgoing superframe of each router (the position of the incoming superframe, as clarified earlier, is determined by the parent of the router). Motivated by Brook's theorem <ref type="bibr" target="#b18">[21]</ref>, which proves that n colors are sufficient to color any graph with a maximum degree of n, we would assume that k ≥ D I , where D I is the maximum degree of G I .</p><p>Given a slot assignment for G, the report latency from node i to node j, where (i, j) ∈ E, is the number of slots, denoted by d ij , that node i has to wait to relay its collected sensory data to node j, i.e.,</p><formula xml:id="formula_1">d ij = (s(j) -s(i)) mod k. (<label>1</label></formula><formula xml:id="formula_2">)</formula><p>Note that the report latency from node i to node j (d ij ) may not by equal to the report latency from node j to node i (d ji ). Therefore, we can convert G into a weighted directed graph</p><formula xml:id="formula_3">G D = (V, E D ) such that each (i, j) ∈ E is translated into two directed edges (i, j) and (j, i) such that w((i, j)) = d ij and w((j, i)) = d ji .</formula><p>The report latency for each i ∈ V to the sink is the sum of report latencies of the links on the shortest path from i to the sink in G D . The latency of the convergecast, denoted as L(G), is the maximum of all nodes' report latencies.</p><formula xml:id="formula_4">Definition 1 Given G = (V, E), G's interference graph G I = (V, E I )</formula><p>, and k available slots, the Minimum Delay Beacon Scheduling (MDBS) problem is to find an interference-free slot assignment s(i) for each i ∈ V such that the convergecast latency L(G) is minimized.</p><p>To prove that the MDBS problem is NP-complete, we define a decision problem as follows.</p><formula xml:id="formula_5">Definition 2 Given G = (V, E), G's interference graph G I = (V, E I ), k available slots,</formula><p>and a delay constraint d, the Bounded Delay Beacon Scheduling (BDBS) problem is to decide if there exists an interference-free slot assignment s(i)</p><formula xml:id="formula_6">for each i ∈ V such that the convergecast latency L(G) ≤ d.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1</head><p>The BDBS problem is NP-complete.</p><p>Proof. First, given slot assignments for nodes in V , we can find the report latency of each i ∈ V by running a shortest path algorithm on G D . We can then check if L(G) ≤ d. Clearly, this takes polynomial time.</p><p>We then prove that the BDBS problem is NP-hard by reducing the 3 conjunctive normal form satisfiability (3-CNF-SAT) problem to a special case of the BDBS problem in polynomial time. Given any 3-CNF formula C, we will construct the corresponding G and G I .</p><p>Then we show that C is satisfiable if and only if there is a slot assignment for each i ∈ V using no more than k = 3 slots such that L(G) ≤ 4 slots.</p><formula xml:id="formula_7">Let C = C 1 ∧ C 2 ∧ • • • ∧ C m , where clause C j = x j,1 ∨ x j,2 ∨ x j,3 , 1 ≤ j ≤ m, x j,i ∈ {X 1 , X 2 , ..., X n }, and X i ∈ {x i , xi }, where x i is a binary variable, 1 ≤ i ≤ n.</formula><p>We first construct G from C as follows:</p><p>1. For each clause C j , j = 1, 2, ..., m, add a vertex C j in G.</p><p>2. For each literal X i , i = 1, 2, ..., n, add four vertices x i1 , x i2 , xi1 , and xi2 in G.</p><p>3. Add a vertex t as the sink of G.</p><p>4. Add edges (t, x i2 ) and (t, xi2 ) to G, for i = 1, 2, ..., n.</p><p>5. Add edges (x i1 , x i2 ) and (x i1 , xi2 ) to G, for i = 1, 2, ..., n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.</head><p>For each i = 1, 2, ..., n and each j = 1, 2, ..., m, add an edge (C j , x i1 ) (resp., (C j , xi1 ))</p><formula xml:id="formula_8">to G if x i (resp., xi ) appears in C j .</formula><p>Then we construct G I as follows.</p><p>1. Add all vertices and edges in G into G I .</p><p>2. Add edges (x i1 , xi1 ) and (x i2 , xi2 ) to G I , for i = 1, 2, ..., n.</p><p>3. Add edges (C j , x i2 ) and (C j , xi2 ) to G I , for i = 1, 2, ..., n and j = 1, 2, ..., m.</p><p>Then we build a one-to-one mapping from each truth assignment of C to a slot assignment of G. We establish the following mapping:</p><formula xml:id="formula_9">1. Set s(t) = 0. 2. Set s(C j ) = 0, j = 1, 2, ..., m. 3. Set s(x i1 ) = 1 and s(x i2 ) = 1, i = 1, 2, ..., n, if x i is true; otherwise, set s(x i1 ) = 2 and s(x i2 ) = 2. 4. Set s(x i2 ) = 1 and s(x i1 ) = 1, i = 1, 2, ..., n, if xi is true; otherwise, set s(x i2 ) = 2 and s(x i1 ) = 2.</formula><p>The above reduction can be computed in polynomial time. By the above reduction, vertices x i1 or xi1 , i = 1, 2, ..., n, that are assigned to slot 1 (resp. slot 2) will have a report latency of 2 (resp. 4) and vertices x i2 or xi2 , i = 1, 2, ..., n, that are assigned to slot 1 (resp.</p><p>slot 2) will have a report latency of 2 (resp. 1). Hence, for those vertices x i1 , xi1 , x i2 , and xi2 , i = 1, 2, ..., n, the longest report latency will be 4. To prove the if part, we need to show that if C is satisfiable, there is a slot assignment such that k = 3 and L(G) ≤ 4. Since C satisfiable, there must exist an assignment such that each clause C j , j = 1, 2, ..., m, is true. If a clause C j is true, at least one variable in C j is true. According to the reduction, C j can always find an edge (C j , x i1 ) or (C j , xi1 ) with w((C j , x i1 )) = 1 or w((C j , xi1 )) = 1, where i = 1, 2, ..., n. Thus, when C is satisfiable, the reporting latency for each clause is 3. This achieves L(G) = 4.</p><formula xml:id="formula_10">1 2 0 0 2 1 0 1 2 2 1 2 1 1 2 0 C 1 C 2 C 3</formula><p>For the only if part, if each vertex C j , j = 1, 2, ..., m, can find at least an edge with weight 1 to one of x i1 and xi1 , for i = 1, 2, ..., n, to achieve a report latency of 3, it must be that each clause has at least one variable to be true. So formula C is satisfiable. Otherwise, the report latency of C j , j = 1, 2, ..., m, will be 6.</p><p>2</p><p>For example, given <ref type="figure" target="#fig_2">3</ref> shows the corresponding G. The truth assignment (x 1 , x 2 , x 3 ) = (T, F, T ) makes C satisfiable.</p><formula xml:id="formula_11">C = (x 1 ∨ x2 ∨ x3 ) ∧ (x 1 ∨ x2 ∨ x 3 ) ∧ (x 1 ∨ x 2 ∨ x3 ), Fig.</formula><p>According to the reduction and the mapping in the above proof, we can obtain the network G and its slot assignment as shown in Fig. <ref type="figure" target="#fig_2">3</ref> such that L(G) = 4. 2</p><p>4 Algorithms for the MDBS Problem</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Optimal Solutions for Special Cases</head><p>Optimal solutions can be found for the MDBS problem in polynomial time for regular linear networks and regular ring networks, as illustrated in Fig. <ref type="figure" target="#fig_4">4</ref>. In such networks, each vertex is connected to one or two adjacent vertices and has an interference relation with each neighbor within h hops from it, where h ≥ 2. In a regular linear network, we assume that the sink t is at one end of the network. Clearly, the maximum degree of G I is 2h. We will show that an optimal solution can be found if the number of slots k ≥ h + 1. The slot assignment can be done in a bottom-up manner. The bottom node is assigned to slot 0. Then, for each vertex v,</p><formula xml:id="formula_12">s(v) = (k + 1) mod k,</formula><p>where k is the slot assigned to v's child.</p><p>Theorem 2 For a regular linear network, if k ≥ h + 1, the above slot assignment achieves a report latency of |V | -1, which is optimal.</p><p>Proof. Clearly, the slot assignment is interference-free. Also the report latency of 1. The bottom node in the left group is assigned to slot 0.</p><p>2. All other nodes in the left group are assigned with slots in a bottom-up manner. For each node i in the left group, we let s(i) = (j + 1) mod k, where j is the slot of i's child.</p><p>3. Nodes in the right group are assigned with slots in a top-down manner. For each node i in the right group, we let s(i) = (jc) mod k, where j is the slot assigned to i's parent and c is the smallest constant (1 ≤ c ≤ k) that ensures that s(i) is not used by any of its interference neighbors that have been assigned with slots.</p><p>It is not hard to prove the slot assignment is interference-free because nodes receives slots sequentially and we have avoided using the same slots among interfering neighbors.</p><p>Although this is a greedy approach, we show that c is equal to 1 in step 3 in most of the cases except when two special nodes are visited. This gives an asymptotically optimal algorithm, as proved in the following theorem. Proof. We first identify three nodes on the ring (refer to Fig. <ref type="figure" target="#fig_4">4(b)):</ref> • l 1 : the bottom node in the left group.</p><p>• r 1 : the first node in the right group.</p><p>• r 2 : the node that is h hops from l 1 counting counterclockwise.</p><p>The report latency of each node can be analyzed as follows. The parent of node x is denoted by par(x).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A1.</head><p>For each node i in the left group except the sink t, the latency from i to par(i) is 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A2.</head><p>The latency from r 1 to t is h.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A3.</head><p>For each node i next to r 1 in the right group but before r 2 (counting clockwise), the latency from i to par(i) is 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A4.</head><p>The latency from r 2 to par(r 2 ) is 1 if the ring size is even; otherwise, the latency is 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A5.</head><p>For each node i in the right group that is a descendant of r 2 , the report latency from i to</p><formula xml:id="formula_13">par(i) is 1.</formula><p>It is not hard to prove that A1, A2, and A3 are true. To see A4 and A5, we make the following observations. The function par i (x) is to apply i times the par() function on node</p><p>x. Note that par 0 (x) means x itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>O1.</head><p>When the ring size is even, the equality s(par i-1 (l 1 )) = s(par i (r 2 )) holds for i = 1, 2, ..., |V |-1 2 h -1. More specifically, this means that (i) l 1 and par(r 2 ) will receive the same slot, (ii) par(l 1 ) and par 2 (r 2 ) will receive the same slot, etc. This can be proved by induction by showing that the i-th descendant of t in the right group will be assigned the same slot as the (h + i -1)-th descendant of t in the left group (the induction can go in a top-down manner). This property implies that when assigning a slot to r 2 in step 3, c = 1 in case that the ring size is even. Further, r 2 and its descendants will be sequentially assigned to slots k -1, k -2, ..., kh, which implies that c = 1 when doing the assignments in step 3. So properties A4 and A5 hold for the case of an even ring.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>O2.</head><p>When the ring size is odd, the equality s(par i (l 1 )) = s(par i (r 2 )) holds for i = 1, 2, ...,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>|V |-1 2</head><p>h. This means that (i) par(l 1 ) and par(r 2 ) will receive the same slot, and</p><p>(ii) par 2 (l 1 ) and par 2 (r 2 ) will receive the same slot, etc. Again, this can be proved by induction as in O1. This property implies that c = 2 when assigning a slot to r 2 in step 3, and c = 1 when assigning slots to descendants of r 2 . So properties A4 and A5 hold for the case of an odd ring.</p><p>The equality of slot assignments pointed out in O1 and O2 is illustrated in Fig. <ref type="figure" target="#fig_4">4(b</ref>) by those numbers in gray nodes. In summary, the report latency of the left group is</p><formula xml:id="formula_14">|V |-1 2 .</formula><p>When the ring size is even, the report latency of the right group is the number of nodes in this</p><formula xml:id="formula_15">group, |V | 2 , plus the extra latency h -1 incurred at r 1 . So L(G) = |V | 2 + h -1 = |V |-1 2 + h.</formula><p>When the ring size is odd, the report latency of right group is the number of nodes in this group, |V |-1 2 , plus the extra latency h -1 incurred at r 1 and the extra latency 1 incurred at</p><formula xml:id="formula_16">r 2 . So L(G) = |V |-1 2 + h.</formula><p>A lower bound on the report latency of this problem is the maximum number of nodes in each group excluding t. Applying |V |-1 2 as a lower bound and using the fact that |V |-1 2 ≥ 2h, L(G) will be smaller than 1.5 × |V |-1 2 , which implies the algorithm is optimal within a factor of 1.5. Note that the condition |V |-1 2 ≥ 2h is to guarantee that t will not locate within h hops from r 2 . Otherwise, the observation O2 will not hold. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A Centralized Tree-Based Assignment Scheme</head><p>Given G = (V, E), G I = (V, E I ), and k, we propose a centralized slot assignment heuristic algorithm. Our algorithm is composed of the following three phases:</p><formula xml:id="formula_17">phase 1.</formula><p>From G, we first construct a BFS tree T rooted at sink t.</p><p>phase 2. We traverse vertices of T in a bottom-up manner. For these vertices in depth d, we first sort them according to their degrees in G I in a descending order. Then we sequentially traverse these vertices in that order. For each vertex v in depth d visited, we compute a temporary slot number t(v) for v as follows.</p><p>1. If v is a leaf node, we set t(v) to the minimal non-negative integer l such that for each vertex u that has been visited and (u, v) ∈ E I , (t(u) mod k) = l. 2. If v is an in-tree node, let m be the maximum of the numbers that have been assigned to v's children, i.e., m = max{t(child(v))}, where child(v) is the set of v's children. We then set t(v) to the minimal non-negative integer l &gt; m such that for each vertex u that has been visited and</p><formula xml:id="formula_18">(u, v) ∈ E I , (t(u) mod k) = (l mod k).</formula><p>After every vertex v is visited, we make the assignment s(v) = t(v) mod k. phase 3. In this phase, vertices are traversed sequentially from t in a top-down manner.</p><p>When each vertex v is visited, we try to greedily find a new slot l such that (s(par(v))-</p><formula xml:id="formula_19">l) mod k &lt; (s(par(v)) -s(v)) mod k, such that l = s(u) for each (u, v) ∈ E I , if</formula><p>possible. Then we reassign s(v) = l.</p><p>Note that in phase 2, a node with a higher degree means that it has more interference neighbors, implying that it has less slots to use. Therefore, it has to be assigned to a slot earlier. Also note that, the number t(v) is not a modulus number. However, in step 2 of phase 2, we did check that if t(v) is converted to a slot number, no interference will occur.</p><p>Intuitively, this is a temporary slot assignment that will incur the least latency to v's children.</p><p>At the end, t(v) is converted to a slot assignment s(v). Phase 3 is a greedy approach to further reduce the report latency of routers. For example, Fig. <ref type="figure" target="#fig_6">5</ref>(a) shows the slot assignment after phase 2. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">A Distributed Assignment Scheme</head><p>In this section, we propose a distributed slot assignment algorithm. Each node has to compute its direct as well as indirect interference neighbors in a distributed manner. To achieve this, we will refer to the heterogeneity approach in <ref type="bibr" target="#b19">[22]</ref>, which adopts power control to achieve this goal. Assuming routers' default transmission range is r, interference neighbors must locate within range 2r. From time-to-time, each router will boost its transmission power to double its default transmission range and send HELLO packets to its neighbor routers. Each HELLO packet further contains sender's 1) depth <ref type="foot" target="#foot_0">1</ref> , 2) the location of outgoing superframe (i.e., slot), and 3) number of interference neighbors. Note that all other packets are transmitted by the default power level. When booting up, each router will broadcast HELLO packets claiming that its depth and slot are NULL. After joining the network and choosing a slot, the HELLO packets will carry the node's depth and slot information. The algorithm is triggered by the sink t setting s(t) = k -1 and then broadcasting its beacon. A router v = t that receives a beacon will decide its slot as follows.</p><p>1. Node v sends an association request to the beacon sender.</p><p>2. If v fails to associate with the beacon sender, it stops the procedure and waits for other beacons.</p><p>3. If v successfully associates with a parent node par(v), it computes the smallest positive integer l such that (s(par(v))l) mod k = s(u) for all (u, v) ∈ E I and s(u) = NULL.</p><p>Then v chooses s(v) = (s(par(v))l) mod k as its slot.</p><p>4. Then, v broadcasts HELLOs including its slot assignment s(v) for a time period t wait .</p><p>If it finds that s(v) = s(u) for any (u, v) ∈ E I , v has to change to a new slot if one of the following rules is satisfied and goes back to step 3.</p><p>(a) Node u has more interference neighbors than v.</p><p>(b) Node u and v have the same number of interference neighbors but the depth of u is lower than v, i.e. u is closer to the sink than v.</p><p>(c) Node u and v have the same number of interference neighbors and they are at the same depth but the u's ID is smaller than v's.</p><p>5. After t wait , v can finalize its slot selection and broadcast its beacons.</p><p>In this distributed algorithm, slots are assigned to routers, ideally, in a top-down manner.</p><p>However, due to transmission latency, some routers at lower levels may find slots earlier than those at higher levels. Also note that the time t wait is to avoid possible collision on slot assignments due to packet loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Simulation Results</head><p>This section presents our simulation results. We first assume that the size of sensory data is negligible and that all routers generate reports at the same time, and compare the performances of different convergecast algorithms. Then we simulate more realistic scenarios where the size of sensory data is not negligible and routers need to generate reports periodically or passively driven by events randomly appearing in certain regions in the sensing field. More specifically, sensors generate reports according to certain application specifications. Devices all run ZigBee and IEEE 802.15.4 protocols to communicate with each other.</p><p>Routers can aggregate child sensors' reports and report to their parents directly. Each router has a fix-size buffer. When a router's buffer overflows, this router will not accept further incoming frames. We also measure the goodput of the network, which is defined as the ratio of sensors' reports successfully received by the sink. Some parameters used in our simulation are listed in Table <ref type="table" target="#tab_2">2</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Comparison of Different Convergecast Algorithms</head><p>We compare the proposed slot assignment algorithms against a random slot assignment (denoted by RAN) scheme and a greedy slot assignment (denoted by GDY) scheme. In RAN, the slot assignment starts from the sink and each router, after associating with a parent router, simply chooses any slot which has not been used by any of its interference neighbors. In GDY, routers are given a sequence number in a top-down manner. The sink sets its slot to k -1. Then the slot assignment continues in sequence. For a node i, it will try to find a slot s(i) = s(j)l mod k, where j is the predecessor of i and l is the smallest integer letting s(i) is the slot which does not assign to any of i's interference neighbors. In the simulations, routers are randomly distributed in a circular region of a radius r and a sink is placed in the center. Our centralized tree-based scheme and distributed slot assignment scheme are denoted as CTB and DSA, respectively. We compare the report latency L(G) (in terms of slots).</p><p>Fig. <ref type="figure" target="#fig_8">6</ref> shows some slot assignment results of CTB and DSA when r = 35 m and k = 64.</p><p>Devices are randomly distributed. The transmission range of routers is set to 20 m. In this case, CTB performs better than DSA.</p><p>Next, we observe the impact of different r, C R (number of routers), and T R (transmission Basically, GDY behaves the same as CTB and DSA. But when the transmission range is larger, the report latency slightly becomes small. and GDY are independent of the number of slots. Contrarily, with a random assignment, RAN even incurs a higher report latency as there are more freedom in slot selection.</p><formula xml:id="formula_20">L(G)=22 k = 64 k = 64 L(G)=19</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Periodical Reporting Scenarios</head><p>Next, we assume that sensors are instructed to report their data in a periodically manner. We set r = 100 m, T R = 20 m, and C R = 300 with 6000 randomly placed sensors associated to these routers, and we further restrict a router can accept at most 30 sensors. BO -SO is fixed to six, so k = 2 BO-SO = 64. Since the earlier simulations show that CTB and DSA perform quite close, we will use only CTB to assign routers' slots. Sensors are required to generate a report every 251.66 second (the length of one beacon interval when BO = 14).</p><p>We set the buffer size of each router is 10 KB. 2 We allocate two mini-slots for each child router of the sink as the GTS slot. 3   Since (BO -SO) is fixed, a small BO implies a smaller slot size (and thus a smaller unit size of L(G)). So, a smaller slot size seemingly implies higher contention among sensors if they all intend to report to their parents simultaneously. In fact, a smaller BO does not hurt the overall reporting times of sensors if we can properly divide sensors into groups. For example, in Fig. <ref type="figure" target="#fig_10">8</ref>, when BO = 14, all sensors of a router can report in every superframe.</p><p>When BO = 13, if we divide sensors into two groups, then they can report alternately in odd and even superframes. Similarly, when BO = 12, four groups of sensors can report alternately. Since the length of superframes are reduced proportionally, the report intervals of sensors actually remain the same in these cases. In the following experiments, we groups sensors according to their parents' IDs. A sensor belongs to group m if the modulus of its parent's ID is m.</p><p>Fig. <ref type="figure" target="#fig_11">9</ref> shows the theoretical and actual report latencies under different BOs. Note that a report may be delayed due to buffer constraint. As can be seen, the actual latency does not always favor a smaller BO. Our results show that BO = 10 ∼ 12 performs better. Fig. <ref type="figure" target="#fig_11">9(b)</ref> shows the goodput of sensory reports, channel utilization at the sink, and the number of 2 Currently, there are some platforms which are equipped with larger RAMs. For example, Jennic JN5121 <ref type="bibr" target="#b2">[5]</ref> has a 96KB RAM and CC2420DBK <ref type="bibr" target="#b0">[1]</ref> has a 32KB RAM. 3 There are sixteen mini-slots per active portion (slot).   dropped frames at the sink. When BO = 14, although there is no frames being dropped at the sink, the goodput is still low. This is because a lot of collisions happen inside the network, causing many sensory reports being dropped at intermediate levels (a frame is dropped after exceeding its retransmission limit). Fig. <ref type="figure" target="#fig_3">10</ref> shows a log of the numbers of frames received by a sink's child router when BO = 14. We can see that more than half of the active portion is wasted. Overall, BO = 10 produces the best goodput and a shorter report latency.</p><p>Some previous works can be also integrated in this periodical reporting scenario, such as the adaptive GTS allocation mechanism in <ref type="bibr" target="#b9">[12]</ref> and the aggregation algorithms for WSNs in [7] <ref type="bibr" target="#b7">[10]</ref>. Fig. <ref type="figure" target="#fig_3">11</ref> shows an experiment that routers can compress reports from sensors with a rate cr when BO = 10. If a router receives n reports and each report's size is 16 Bytes (as in</p><p>Table <ref type="table" target="#tab_2">2</ref>), it can compress the size to 16 × n × (1cr). The report latencies decrease when the cr becomes larger. By compressing the report data, the goodput can up to 98% and the report can arrive to the sink more quickly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Event-Driven Reporting Scenarios</head><p>In the following, we assume that sensors' reporting activities are triggered by events occurred at random locations in the network with a rate λ. The sensing range of each sensors is 3 meters and each event is a disk of a radius of 5 meters. A sensor can detect an event if its sensing range overlaps with the disk of that event. Each router has an 1 KB buffer. When a sensor detects an event, it only tries to report that event once. All other settings are the same as those in Section 5.2.</p><p>Fig. <ref type="figure" target="#fig_13">12</ref> shows the simulation results when λ = 1/5s, 1/15s, and 1/30s. From Fig. <ref type="figure" target="#fig_13">12</ref>(a), we can observe that when BO is small, the report latency can not achieve to the theoretical value. This is because that an active portion is too small to accommodate all reports from sensors, thus lengthening the report latency. When BO becomes larger, the theoretical and actual curves would meet. However, the good put will degrade, as shown in Fig. <ref type="figure" target="#fig_13">12(b</ref>). This is because reports are likely to be dropped due to buffer overflow. How to determine a proper BO, which can contain most of the reports and guarantee low latency, is an important design issue for such scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>In this paper, we have defined a new minimum delay beacon scheduling (MDBS) problem for convergecast with the restrictions that the beacon scheduling must be compliant to the ZigBee standard. We prove the MDBS problem is NP-complete and propose optimal so-lutions for special cases and two heuristic algorithms for general cases. Simulation results indicate the performance of our heuristic algorithms decrease only when the number of interference neighbors is increased. Compared to the random slot assignment and greedy slot assignment scheme, our heuristic algorithms can effectively schedule the ZigBee routers' beacon times to achieve quick convergecast. In the future, it deserves to consider extending this work to an asynchronous sleep scheduling to support energy-efficient convergecast in ZigBee mesh networks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An example of convergecast in a ZigBee tree-based network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1</head><label>1</label><figDesc>shows a possible allocation of active portions for routers A, B, C, and D. The collected sensory data of A in the k-th superframe can be sent to C in the same superframe. However, because the active portion of B in the k-th superframe appears after that of C, the collected data of B in the k-th superframe can only be relayed to C in the (k + 1)-th superframe. The report delay from B to C is almost the length of one superframe.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An example of reduction from the 3-CNF-SAT to the BDBS problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 2≥</head><label>1</label><figDesc>|V | -1 is clearly the lower bound. 2 For a regular ring network, we first partition vertices excluding t into left and right groups as illustrated in Fig. 4(b) such that the left group consists of the sink node t and |V |-1 2 other nodes counting counter-clockwise from t, and the right group consists of those |V |-1 2 nodes counting clockwise from t. Now we consider the ring as a spanning tree with t as the root and left and right groups as two linear paths. Assuming that |V |-2h and k ≥ 2h, the slot assignment works as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Examples of optimal slot assignments for regular linear and ring networks (h = 2). Dotted lines mean interference relations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 3 1 2≥</head><label>31</label><figDesc>For a regular ring network, assuming that k ≥ 2h and |V |-2h, the above slot assignment achieves a report latency L(G) = |V |-1 2 + h, which is optimal within a factor of 1.5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: (a) Slot assignment after phase 2. (b) Slot compacting by phase 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 (</head><label>5</label><figDesc>b) indicates that B, C, and D can find another slots and their report latencies are decreased. This phase can reduce L(G) in some cases. The computational complexity of this algorithm is analyzed below. In phase 1, the complexity of constructing a BFS tree is O(|V | + |E|). In phase 2, the cost of sorting is at most O(|V | 2 ) and the computational cost to compute t(v) for each vertex v is bounded by O(kD I ), where D I is the degree of G I . So the time complexity of phase 2 is O(|V | 2 +kD I |V |). Phase 3 performs a similar procedure as phase 2, so its time complexity is also O(kD I |V |). Overall, the time complexity is O(|V | 2 + kD I |V |).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Slot assignment examples by CTB and DSA.</figDesc><graphic coords="20,299.25,90.36,170.64,138.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 (Fig. 7 (Figure 7 :</head><label>777</label><figDesc>Fig. 7(c) shows the impact of C R when r = 100 m, T R = 20 m, and k = 128. As a larger C R means a higher network density and thus more interference, the report latencies of CTB and DSA increase as C R increases. Since the network diameter is bounded, the report latency of RAN is also bounded. GDY is sensitive to the number of routers when there are less routers. This is because that each router can own a slot and the report latency increases proportionally to the number of routers. With r = 100 m, C R = 300, and T R = 20 m, Fig. 7(d) shows the impact of routers' duty cycle. Note that a lower duty cycle means a larger number of available slots. Interestingly, we see that the report latencies of CTB, DSA,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: An example of report scheduling under different values of BO.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Simulations considering buffer limitation and contention effects: (a) theoretical v.s. actual report latencies and (b) goodput, channel utilization, and number of dropped frames.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>Figure 10: A log of the number of frames received by a sink's child router when BO = 14.</figDesc><graphic coords="24,222.53,101.46,143.35,99.94" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Simulation results of event-driven scenarios: (a) theoretical v.s. actual report latencies and (b) goodput.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>2 Overview of IEEE 802.15.4 and ZigBee Standards</head><label></label><figDesc></figDesc><table><row><cell cols="32">Beacon SO = 15 to indicate that superframes do not exist.) Each active portion consists of 16 equal-Beacon CAP CFP</cell></row><row><cell cols="32">0 length slots, which can be further partitioned into a contention access period (CAP) and a 1 0 9 8 7 6 5 4 3 2 1 1 4 13 12 11 15 GTS 1 GTS 2 GTS Inactive 0 contention free period (CFP). The CAP may contain the first i slots, and the CFP contains</cell></row><row><cell cols="32">SD = aBaseSuperframeDuration×2 SO symbols (Active) the rest of the 16-i slots, where 1 ≤ i ≤ 16. Slotted CSMA/CA is used in CAP. FFDs which</cell></row><row><cell cols="32">BI = aBaseSuperframeDuration×2 BO symbols (a) require fixed transmission rates can ask for guarantee time slots (GTSs) from the coordinator.</cell></row><row><cell cols="32">Received A CFP can support multiple GTSs, and each GTS may contain multiple slots. Note that only Transmitted Received</cell></row><row><cell cols="32">Beacon the coordinator can allocate GTSs. After the active portion, devices can go to sleep to save Beacon Beacon</cell></row><row><cell cols="3">energy.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Inactive</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Inactive</cell></row><row><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell>7</cell><cell>8</cell><cell>9</cell><cell>1 0</cell><cell>11</cell><cell>12</cell><cell>13</cell><cell>1 4</cell><cell>15</cell><cell>0</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell>7</cell><cell>8</cell><cell>9</cell><cell>1 0</cell><cell>11</cell><cell>12</cell><cell>13</cell><cell>1 4</cell><cell>15</cell></row><row><cell cols="16">SD = aBaseSuperframeDuration×2 SO symbols</cell><cell cols="16">SD = aBaseSuperframeDuration×2 SO symbols</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="8">(Incoming superframe)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="8">(Outgoing superframe)</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">Start Time &gt;SD</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="13">BI = aBaseSuperframeDuration×2 BO symbols</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">(b)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="21">Figure 2: IEEE 802.15.4 superframe structure.</cell></row><row><cell cols="32">rate of 20 kbps. Channels 1 to 10 work from 902.0 MHz to 928.0 MHz and each channel</cell></row><row><cell cols="32">schedule the beacons of routers to minimize the convergecast latency. We prove that this provides a data rate of 40 kbps. Channels 11 to 26 are located from 2.4 GHz to 2.4835 GHz,</cell></row><row><cell cols="32">problem is NP-complete by reducing the 3-CNF-SAT problem to it. We show two special each with a data rate of 250 kbps.</cell></row><row><cell cols="32">cases of this problem where optimal solutions can be found in polynomial time and propose IEEE 802.15.4 devices are expected to have limited power, but need to operate for a</cell></row><row><cell cols="32">two heuristic algorithms for general cases. To the best of our knowledge, this is the first longer period of time. Therefore, energy conservation is a critical issue. Devices are clas-</cell></row><row><cell cols="32">result that provides convergecast solutions in ZigBee beacon-enabled tree networks. sified as full function devices (FFDs) and reduced function devices (RFDs). IEEE 802.15.4</cell></row><row><cell cols="32">The rest of this paper is organized as follows. Section 2 briefly introduces IEEE 802.15.4 supports star and peer-to-peer topologies. In each PAN, one device is designated as the co-</cell></row><row><cell cols="32">and ZigBee. The quick convergecast problem is formally defined in Section 3. Section 4 ordinator, which is responsible for maintaining the network. A FFD has the capability of</cell></row><row><cell cols="32">presents our scheduling solutions. Simulation results are given in Section 5. Finally, Sec-serving as a coordinator or associating with an existing coordinator/router and becoming a</cell></row><row><cell cols="32">tion 6 concludes this paper. router. A RFD can only associate with a coordinator/router and can not have children.</cell></row><row><cell cols="32">The ZigBee coordinator defines the superframe structure of a ZigBee network. As shown</cell></row><row><cell cols="32">in Fig. 2(a), the structure of superframes is controlled by two parameters: beacon order (BO)</cell></row><row><cell cols="32">IEEE 802.15.4 [13] specifies the physical and data link protocols for low-rate wireless per-and superframe order (SO), which decide the lengths of a superframe and its active potion,</cell></row><row><cell cols="32">sonal area networks (LR-WPAN). In the physical layer, there are three frequency bands with respectively. For a beacon-enabled network, the setting of BO and SO should satisfy the</cell></row><row><cell cols="32">27 radio channels. Channel 0 ranges from 868.0 MHz to 868.6 MHz, which provides a data relationship 0 ≤ SO ≤ BO ≤ 14. (A non-beacon-enabled network should set BO =</cell></row></table><note><p>The delay can be eliminated if the active portion of B in the k-th superframe appears before that of C. The delay is not negligible because of the low duty cycle design of IEEE 802.15.4. For example, in 2.4 GHz PHY, with 1.56% duty cycle, a superframe can be as long as 251.658 seconds (with an active portion of 3.93 seconds). Clearly, for large-scale WSNs, the convergecast latency could be significant if the problem is not carefully addressed. The quick convergecast problem is to</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Relationship of BO -SO, duty cycle, and the number of active portions in a superframe.</figDesc><table><row><cell>BO -SO</cell><cell>0 1 2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>6</cell><cell>7</cell><cell>8</cell><cell>≥ 9</cell></row><row><cell>Duty cycle (%)</cell><cell cols="8">100 50 25 12.5 6.25 3.13 1.56 0.78 0.39 ≤ 0.195</cell></row><row><cell cols="2">Number of active portions (slots) 1 2 4</cell><cell>8</cell><cell cols="6">16 32 64 128 256 ≥ 512</cell></row></table><note><p><p><p>Two routers have direct interference if they can hear each others' beacons. Two routers have indirect interference if they have at least one common neighbor. Both interferences should be avoided when choosing routers' active portions. Table</p>1</p>lists possible choices of (BO -SO) combinations.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Simulation parameters.</figDesc><table><row><cell>Parameter</cell><cell>Value</cell></row><row><cell>length of a frame's header and tail</cell><cell>18 Bytes</cell></row><row><cell>length of a sensor's report</cell><cell>16 Bytes</cell></row><row><cell>beacon length</cell><cell>18 Bytes</cell></row><row><cell>maximum length of a frame</cell><cell>127 Bytes</cell></row><row><cell>bit rate</cell><cell>250k bps</cell></row><row><cell>symbol rate</cell><cell>62.5k symbols/s</cell></row><row><cell>aBaseSuperframeDuration</cell><cell>960 symbols</cell></row><row><cell>aUnitBackoffPeriod</cell><cell>20 symbols</cell></row><row><cell>aCCATime</cell><cell>8 symbols</cell></row><row><cell>macMinBE</cell><cell>3</cell></row><row><cell>aMaxBE</cell><cell>5</cell></row><row><cell>macMaxCSMABackoffs</cell><cell>4</cell></row><row><cell>maximum number of retransmissions</cell><cell>3</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The depth of a node is the length of the tree path from the root to the node. The root node is at depth zero.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgements</head><p>Y.-C. Tseng's research is co-sponsored by Taiwan MoE ATU Program, by NSC grants 93-2752-E-007-001-PAE, 96-2623-7-009-002-ET, 95-2221-E-009-058-MY3, 95-2221-E-009-060-MY3, 95-2219-E-009-007, 95-2218-E-009-209, and 94-2219-E-007-009, by Realtek Semiconductor Corp., by MOEA under grant number 94-EC-17-A-04-S1-044, by ITRI, Taiwan, by Microsoft Corp., and by Intel Corp.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.chipcon.com/" />
		<title level="m">Chipcon CC2420DBK</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Design and construction of a wildfire instrumentation system using networked sensors</title>
		<ptr target="http://firebug.sourceforge.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://www.jennic.com/" />
		<title level="m">Jennic JN5121</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">smart dust sensors, wireless sensor networks</title>
		<author>
			<persName><surname>Motes</surname></persName>
		</author>
		<ptr target="http://www.xbow.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Minimizing energy consumption in large-scale sensor networks through distributed data compression and hierarchical aggregation</title>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Veciana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1130" to="1140" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Scheduling for information gathering on sensor network</title>
		<author>
			<persName><forename type="first">H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Hughes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>ACM/Kluwer Wireless Networks</publisher>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Distributed minimal time convergecast scheduling in wireless sensor networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gandham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Int&apos;l Conference on Distributed Computing Systems (ICDCS)</title>
		<meeting>of IEEE Int&apos;l Conference on Distributed Computing Systems (ICDCS)<address><addrLine>Lisboa, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An evaluation of multiresolution storage for sensor networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ganesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Greenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Perelyubskiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Int&apos;l Conference on Embedded Networked Sensor Systems (SenSys)</title>
		<meeting>of ACM Int&apos;l Conference on Embedded Networked Sensor Systems (SenSys)<address><addrLine>Los Angeles, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Flexible power scheduling for sensor networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hohlt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Doherty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM/IEEE Int&apos;l Conference on Information Processing in Sensor Networks (IPSN)</title>
		<meeting>of ACM/IEEE Int&apos;l Conference on Information essing in Sensor Networks (IPSN)<address><addrLine>Berkeley, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">AGA: Adaptive GTS allocation with low latency and fairness considerations for IEEE 802</title>
		<author>
			<persName><forename type="first">Y.-K</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-C</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-W</forename><surname>Kuo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Int&apos;l Conference on Communications (ICC)</title>
		<meeting>of IEEE Int&apos;l Conference on Communications (ICC)<address><addrLine>Istanbul, Turkey</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">IEEE standard for information technology -telecommunications and information exchange between systems -local and metropolitan area networks specific requirements part 15.4: wireless medium access control (MAC) and physical layer (PHY) specifications for low-rate wireless personal area networks</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>LR-WPANs</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">IEEE standard for information technology -telecommunications and information exchange between systems -local and metropolitan area networks specific requirements part 15.4: wireless medium access control (MAC) and physical layer (PHY) specifications for low-rate wireless personal area networks (LR-WPANs)(revision of IEEE Std 802</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="4" to="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Distributed algorithm for guiding navigation across a sensor network</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Derosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Int&apos;l Symposium on Mobile Ad Hoc Networking and Computing (MobiHoc)</title>
		<meeting>of ACM Int&apos;l Symposium on Mobile Ad Hoc Networking and Computing (MobiHoc)<address><addrLine>Maryland, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient in-network moving object tracking in wireless sensor networks</title>
		<author>
			<persName><forename type="first">C.-Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Tseng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Mobile Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1044" to="1056" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An adaptive energy-efficient and low-latency MAC for data gathering in wireless sensor networks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Raghavendra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Int&apos;l Parallel and Distributed Processing Symposium (IPDPS)</title>
		<meeting>of IEEE Int&apos;l Parallel and Distributed essing Symposium (IPDPS)<address><addrLine>New Mexico, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Location tracking in a wireless sensor network by mobile agents and its data fusion strategies</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-P</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-F</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Computer Journal</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="448" to="460" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Wireless sensor networks for emergency navigation</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-S</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-Y</forename><surname>Tsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="55" to="62" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A low-latency and energy-efficient algorithm for convergecast in wireless sensor networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Upadhyayula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Annamalai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K S</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Global Telecommunications Conference (Globecom)</title>
		<meeting>of IEEE Global Telecommunications Conference (Globecom)<address><addrLine>San Francisco, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Introduction to Graph Theory</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>West</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Exploiting heterogeneity in sensor networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Yarvis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kushalnagar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rangarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
		<meeting>of IEEE INFOCOM<address><addrLine>Miami, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Energy-latency tradeoffs for data gathering in wireless sensor networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Krishnamachari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Prasanna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
		<meeting>of IEEE INFOCOM<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">ZigBee specification version</title>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
