<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Courant Institute of Mathematical Sciences</orgName>
								<orgName type="institution" key="instit2">New York University</orgName>
								<address>
									<postCode>10012</postCode>
									<settlement>New York</settlement>
									<region>New York</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The Hebrew University of Jerusalem</orgName>
								<address>
									<postCode>91904</postCode>
									<settlement>Jerusalem</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">09E70B8DE8A96172B81B01C0E19364C0</idno>
					<note type="submission">Received by the editors June 15, 1982, and in final revised form February 21, 1984. This work was supported in part by the National Science Foundation under grant MCS-8203307.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:56+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We investigate the complexity of searching a sorted table of n elements on a synchronous, shared memory parallel computer with p processors. We show that f(lg n-lgp) steps are required if concurrent accesses to the same memory cell are not allowed, whereas O(lg n/lg p) steps are sufficient if simultaneous reads are allowed. The lower bound is valid even if only communication steps are counted, and the computational power of each processor is not restricted. In this model, (R)(x/-g n) steps are required for searching when the number of processors is unbounded. If the amount of information that a memory cell may store is restricted, then the time complexity for searching with an unbounded number of processors is O(lg n/lg lg n). If the amount of information a processor may hold is also restricted, then an fl(lg n) lower bound holds. These lower bounds are first proven for comparison-based algorithms; it is next shown that comparison-based algorithms are as powerful as more general ones in solving problems defined in terms of the relative order of the inputs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"> 1. <p>Introduction. With the advance in microelectronics it becomes feasible to build parallel machines with thousands of cooperating processors. Yet, practice indicates that a thousandfold increase in raw computational power does not increase performance by the same amount. There are two main reasons for that. The first one is that not every problem admits an efficient parallel solution. The second one is that not every parallel algorithm can be mapped efficiently onto a realistic parallel computer architec- ture. Work sharing between many processors generates significant overheads for com- munication of data and coordination. The study in parallel complexity is dedicated, to a large extent, to the understanding of these two phenomena.</p><p>One useful model for the study of parallel computations is that of a paracomputer. It consists of many identical autonomous processors, each with its own local memory and its own program. In addition, the machine has a shared memory and each processor can in one step access any cell in shared memory.</p><p>We obtain successively weaker models by varying the assumptions concerning simultaneous accesses to shared memory:</p><p>(1) Concurrent Read, Concurrent Write CRCW). Both simultaneous reads and simultaneous writes to the same memory cell are allowed. The effect of simultaneous actions by the processors is as if the actions occurred in some serial order (for other possible definitions of CRCW, see <ref type="bibr" target="#b1">[2]</ref>). (2) Concurrent Read, Exclusive Write (CREW). Simultaneous reads are allowed but a processor can modify a shared memory cell only if it has exclusive access to it.</p><p>(3) Exclusive Read, Exclusive Write (EREW). Simultaneous accesses to the same shared memory cell are not allowed. This model can be further weakened in two ways: One can restrict the number of shared memory cells. One can also restrict the set of processors that have read or write access to each memory cell. If there is a unique processor that has read access and a unique processor that has write access to each shared memory cell, then each ON PARALLEL SEARCHING 689 memory cell represents a unidirectional link that connects two processors. We speak then of an ultracomputer.</p><p>In these models communication both of data and of control information is done through the shared memory. Thus, studying the relative power of these models is tantamount to studying the effect of constraints on communication and coordination on computational power.</p><p>We consider the problem of searching a key within a sorted list of n keys. The binary search algorithm solves this problem in (optimal) sequential time O(lg n). This can be generalized to a "(p+ 1)-ary" search algorithm that solves the problem in O(logp/ n) steps with p processors. At each step p comparisons are done that split the list into p + equal length segments, and the search proceeds recursively within the unique segment that may contain the key. This algorithm is optimal, so that p processors speed up searching by a factor of lg (p + 1) only: Searching does not admit an efficient parallel solution.</p><p>Consider now the problem of implementing this parallel algorithm. It turns out that the speedup can be achieved only if one item of information can be broadcast to all processors in constant time. On the other hand we show that in the EREW model, where an item of information can be accessed by one processor only at a time, searching requires at least (lg n-lg p) steps. Note that no transmission of data is required for parallel search, but the processors need to coordinate the search at each iteration. It turns out that the time spent in coordinating the processors offsets exactly the gain obtained from simultaneous table look-ups.</p><p>The f(lg n-lg p) lower bound is valid even if each processor may in one step do any amount of local processing or transfer any amount of information. The only restrictions are that at each step a processor may read or write at a unique location in memory.</p><p>This result settles the problem of the relative power of the different shared-memory machine models. It is known that a p-processor machine which supports concurrent accesses to the same location in memory can be simulated by a p-processor machine with no concurrent accesses to the same location in memory with a lg p time penalty <ref type="bibr" target="#b5">[5]</ref>. Our result shows that this simulation is optimal.</p><p>Under the same assumptions we prove that the time complexity of searching with an unbounded number of processors is (R)(/lg n).</p><p>The computational model is very strong since there are no restrictions on the amount of information that can be transmitted in one step. This is remedied by assuming that a memory cell may contain a unique input value, and that inputs are atomic entities, so that an input symbol cannot be used to encode the values of several inputs. A memory cell may also store a symbol taken from a small domain of internal values.</p><p>In this model the time complexity of searching with an unbounded number of p,rocessors is (R)(lg n/lg lg n). Finally, if we impose a similar restriction on the local memory of each of the processors, then an f(lg n) lower bound is valid, independently of the number of processors.</p><p>The (lg n) lower bound on search implies a similar lower bound for the insertion problem on a shared memory parallel machine with no concurrent access to the same memory location. This settles an open problem posed by Borodin and Hopcroft in <ref type="bibr" target="#b1">[2]</ref>.</p><p>The lower bounds for searching with an unbounded number of processors are proven for comparison-based computations. We also prove that comparison-based</p><p>The terms paracomputer and ultracomputer are taken from 10], but are used here in a slightly different meaning.</p><p>Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php algorithms are as efficient as more general ones in solving problems that are defined in terms of the relative order of the inputs. We first show that if such a problem can be solved by comparisons for inputs taken from a subset of values where every possible permutation of the inputs occurs, then it can be solved by comparisons, using the same resources, for any input. We next prove that given a paracomputer, one can build a sufficiently large set of input values where the behavior of each processor at each step depends only on the relative order of the pairs of inputs it has access to, but not on their actual values. The last result is proven by an application of Ramsey's theorem.</p><p>The remainder of this paper is organized as follows. The implementation of the "(p+ 1)-ary" searching algorithm is discussed in the next section. In 3 we prove the [l(lg n-lg p) lower bound for a simplified version of the searching problem. This is followed in 4 by a description of an O(x/g n) algorithm for searching in the EREW model with O(n) processors. In 5 we present the reduction of general paracomputer computations to computations using only comparisons. This reduction is used in 6 to prove the (l(/1-) lower bound for searching with an unrestricted number of processors. In 7 we examine the complexity of searching in restricted paracomputer models. Conclusions and open problems are brought in the last section.</p><p>2. Parallel searching in the CREW model, The search problem has several variants, all of which have essentially the same complexity. For sake of simplicity we consider the following version.</p><p>Range search problem (for a table of size n). Given n + distinct inputs x, , xn, y such that x &lt;... &lt; xn, find the index such that xi &lt; y &lt; xi+l. (By definition Xo =-c and x,+ .)</p><p>We first determine the complexity of searching in the CRCW and CREW models of parallelism.</p><p>THEOREM 2.1. The range search problem for a table of size n can be solved on a CREW machine with p processors in time O(lg (n+ 1)/lg (p+ 1)).</p><p>Proof The algorithm used is the obvious extension of binary search to p processors, namely (p+ 1)-ary search: p keys are chosen that divide the list of keys into p+ intervals of roughly equal length. These keys are compared in parallel to the searched key. The comparisons locate the searched key within one of the subintervals, and the search proceeds recursively within this subinterval. At each iteration the length of the list is decreased by a factor of p + 1, so that the search ends in lgp+ (n + 1) iterations.</p><p>It remains to be shown that each iteration can be implemented in constant time, without concurrent writes.</p><p>Note that the searched key is located within the ith subinterval iff the outcomes of the comparisons made at processor i-1 and at processor are different. Each processor can in constant time match the outcome of the comparison it performed against the outcome of the comparison performed by its right neighbor. The unique processor that detects the subinterval containing the searched key then updates the shared information on the search interval. All the processors next read this information, and proceed to search within the new interval. The complete algorithm is given below. The syntactic construct for in S pardo P(i) odrap indicates parallel execution of the statements P(i) for each value of in the set S.</p><p>Variables declared within a parallel loop are private to the processor executing this instance of the loop. /*Search for key y in sorted list Xbot,""", Xtop.</p><p>We assume that Xbot &lt; Y &lt; Xtop.</p><p>Initially bot-0, top n + (bot, top):= (newbot, newtop) od;</p><p>return (bot) end Note that the full power of concurrent reads is not needed to implement this algorithm. It is sufficient to have a shared memory machine with broadcasting ability: One (fixed) processor is able to broadcast in constant time one item of information to all the other processors.</p><p>Parallel search in the continuous case was studied by Gal and Miranker in  <ref type="bibr" target="#b6">[6]</ref>, where a parallel version of the bisection algorithm for root finding is given (the problem of processors coordination is ignored there). An adversary argument is used there to show that the policy of splitting at each stage the interval of possible values into equal length subintervals is optimal. The same argument applies to the discrete case, and implies the following result. THEOREM 2.2. Let P be a parallel algorithm that solves the range search problem for a table of size n, such that at each step at most p values from the table are accessed. Then the algorithm executes in the worst case at least lg (n + 1)/lg (p + l) steps.</p><p>Thus the complexity of searching by comparisons a table of size n with p processors is (R)(lg (n + 1)/lg (p + 1)), if concurrent reads are supported, both for parallel machines that support concurrent writes and for parallel machines that do not support concurrent writes. (i) If the search interval is small, then a key from the searched table may be accessed by more than one processor.</p><p>(ii) All the processors share the searched key. (iii) After each iteration, all the processors read concurrently the bounds of the new search interval.</p><p>The first type of concurrent reads may be avoided by more careful programming. The concurrent accesses to the searched key may be avoided by initially distributing it to all the processors in O(lg p) steps. If concurrent reads are not supported, then the broadcasting of the next search interval at the end of each iteration will require (lg p) steps, and the running time of the algorithm for fixed p will be l)(lg n-lg p), with practically no gain obtained from parallelism. It turns out that this is indeed the best performance that can be achieved for searching on a parallel machine that does not support concurrent accesses to the same location in memory: (lg n-lg p) steps are required, even if we do not account for the distribution of the searched key.</p><p>3. Lower bounds for discrete root finding. We shall prove the ,t(lg n-lg p) lower bound for the particular case of the range finding problem where the value of the searched key is fixed. This restricted problem can be reformulated as follows. We denote by ' the binary sequence consisting of zeros followed by n-ones. The index n will be omitted when it can be inferred from the. context.</p><p>Discrete root finding (for a sequence of length n). Given a monotonic binary sequence (x,..., xn) count the number of zeros in it, i.e. find the index such that (x, ,x.)= Wi. We first give a more formal definition of the paracomputer model. A paracomputer consists of p processors P1,'", Pp, q registers R,..., Rq, an input set X, a set of processor states S, a set of register symbols V X, a time bound T, a subset of n registers 11, , I, that are used for input, and a subset of k registers O1," , Ok that are used for output.</p><p>With each processor Pi are associated the following (partial) functions. ai: S{1,..., q} {R, RW}--the access function. The first component of c(s) yields the index of the register accessed by P when in state s; the second compo- nent indicates whether the access is a read (R) or a read and write (RW) opera- tion. We assume w.l.g, that each processor accesses at each step a shared memory location.</p><p>to: S -V--the write function, toi(s) yields the symbol written by P, when in state s. 6i:S V S--the state transition function. If Pi in state s accesses a register containing v then the new processor state is 6(s, v).</p><p>The computation starts with input x stored in register L, a designated initial symbol 0 V in each of the remaining registers, and each processor P in a designated initial state si S. Let (xl, , x,) be the tuple of inputs to the computation. We denote by s(Y)</p><p>the state of processor Pi, and by c(Y) the content of register Rj, at step of the computation with input :. The dependency on will be omitted when it is obvious from the context. ,) =(j, R) or a,(s)=(j, RW); t+l cj w,(sl) if a,(sl) =(j, RW) cj otherwise.</p><p>We require in the EREW model that the first components of c(s'i) and uj(sj)t be distinct for any #j. In the CREW model we require that if c(s)=(k, RW), then the first component of cg(s) is distinct from k for any j # i. In both cases the processor states and register contents are well defined.</p><p>The outputs of the computation are contained at step T in the k output registers.</p><p>Thus, a paracomputer H computes the function Fl:X -&gt; X k defined by T T FII(X1, Xn) Cjl (), ", Cjk (X),</p><p>where R2,,..., R2k are the k output registers.</p><p>Note that we do not restrict the size of the alphabet, or the number of processor states (they may both be infinite).</p><p>A function F is finite if it has finite range, say {0,..., k}. Decision problems are represented by finite functions. For example, the range search problem is associ- ated with the function RS(xl,...,Xn, y)=max{i" xi&lt;y}, defined on all (n+l)- tuples of distinct elements that fulfill the condition x &lt;... &lt; xn. The discrete root finding problem is associated with the function DRF(x,..., xn)=max (i" x=0}, defined on all n-tuples of elements from the set {0, 1} that fulfill the condition XI" "Xn Let F" X -{0,.., k} be a finite function. A paracomputer computes a unary encoding of F if it has n input registers and k+ output registers, and at the end of the computation with input 2 the only output register that has been modified is the register with index F(2). If a paracomputer with time bound T computes the finite function F, then a unary encoding of F can be computed by a paracomputer with time bound T+ and the same number of processors. It will be more convenient to prove lower bounds for unary computations, since we have to consider only the indices of the registers accessed, but not the values stored.</p><p>Let H and H' be paracomputers with the same number of processors and registers, and the same set of input symbols. Then H and H' are access .equivalent if for each tt input Y, each i, and each t, c(si(Y))= c(s (Y)). If a unary encoding is used, then two access equivalent paracomputers compute the same function.</p><p>Let us introduce the following definitions. The set [a, b]={a, a+ 1,..., b} is called a segment; we denote by the segment [0, n]. Let 5e {S1," , Sk} be a family of subsets of .Wes ay that r is a critical point of ow if there exist a set S such that r Si &lt;=&gt; r Si. Let 0 &lt; rl &lt;" &lt; r be the critical points of the family .T he segment partition defined by consists of the segments [0, rl-1], [rl, r2--l],'.', Its, n]. The segment partition defined by is the coarsest partition of fi into segments that refines the partition defined by the 2 k sets f3 $7', where e {0, 1}, S o S, and S S. In particular, if is a partition of , then the segment partition defined by O is the coarsest partition of into segments that refines the partition 0. THEOREM 3.1. (lg n--lgp) steps are required to solve the discrete root finding problem for a sequence of length n on an ERE W machine with p processors.</p><p>MARC SNIR Proof The lower bound results from the lack of a mechanism to distribute instantaneously information throughout the system. In order to prove it we have to trace at each step the "information" represented by the state of each processor and the content of each register in shared memory. We do that at each step for all the possible input values, thus obtaining a "synoptic" description of the possible computa- tions.</p><p>The information represented by the state of a processor (the content of a register) consists of the set of input values that could produce this state (content). It is important to note that the information represented by the content of a register may change even if this register is not modified, as the fact that no processor stored a new value is informative in itself. Cook and Dwork show in <ref type="bibr" target="#b4">[4]</ref> how such "negative" information can be used at profit.</p><p>With each processor (register) is associated at each step a partition of the input symbols, according to the distinct states (values) the processor (register) may assume at this step. The lower bound will be obtained by tracing the evolution of these partitions, and showing that the number of sets in these partitions cannot grow too fast. In fact, we shall not trace the partitions that obtain in an actual computation, but the partitions that would obtain in a computation where there is no "loss of informa- tion", i.e. a computation where a processor stores a complete account of the information it has whenever it writes in shared memory. These partitions depend only on the access pattern of the processors.</p><p>Rather than counting the number of classes in each partition, it is easier to count the number of critical points of the partition.</p><p>Let II be an EREW paracomputer with p processors, q registers, and time bound T, that computes a unary encoding of the finite function DRF associated with the discrete root finding problem for sequences of length n. We define inductively sets P(i, t), i= 1,...,p, and R(j, t),j= 1,..., q, such that P(i, t)(R(j, t)) contains all the critical points of the partition defined by processor Pi (register Rj) at step of the computation.</p><p>(i) P(i,O)=th, i=l,...,p. (ii) R(j, O)--{i} if Rj initially contains the ith input b otherwise.</p><p>(iii) r P(i, t) itt (a) r P(i, t-1), or (b) Pi accesses at step of the computation on input fir the register Rj, and r6 R(j, t-1). (iv) r R(j, t) iff (a) re R(j, t-1), or (b) Pi modifies at step of the computation with input fir the register Rj, and re P(i, t-1), or (c) Pi modifies at step of the computation with input fir-1 the register R, and rP(,t-1).</p><p>These definitions are illustrated in Fig. <ref type="figure">1</ref>. CLAIM.</p><p>(i) If r P(i, t), then s(ff) s(ff_).</p><p>(ii) If r : R(j, t), then c(ff) c(ff_). _Proof. By induction on t. The claim is obvious for 0. We suppose it holds for t-1 and prove it for t. (i) Since rP(i,t-1), s (r)--S (r-)" In particular, a(s (r))---- a(Sl--(r_)). Let j be the index of the register accessed. If r R(j, t-1) then, by inductive assertion, C-'(r)= C-'(r-), SO that ,-1(r), ,-I ,-I</p><p>On the other hand, if r R(j, t-1), then r P(i, t).</p><p>t-1</p><p>(ii) As r R(j, t-1), c ()= c (_). Suppose that P modifies R at step of the computation with input If r P(i, t-1), then, by the inductive assumption,</p><formula xml:id="formula_0">t-I t-1 s s r-so that t--l '-'()) ,(s (r-,)) C(r-,)</formula><p>On the other hand, if r P(i, t-1) then r R(L t). A similar argument applies if R is modified in the computation with input _. If R is not modified at step neither in the computation with input nor in the computation with input _ then t--1 t--l Cj( r) Cj (r) Cj (r-1) Cj( r-,)"</p><p>Let c(t) be an upper bound on the number of critical points. c( t) =2 IP( i, t)l+ max (0, ]R(j,</p><formula xml:id="formula_1">Initially (3.1) c(0) =0.</formula><p>If R O then R is not modified during the computations with input _ or +, and is modified during the computation with input i. It follows that i, i+ R (j, T), and (3.2) c(T)n. We shall end our proof by showing that <ref type="bibr">(3.3)</ref> c(t)4c(t-1)+p. Indeed, (3.1) and (3.3) imply that 4'-1 c(t) MARC SNIR Each occurrence of r in a set P(i, t-1) contributes at most one new occurrence of r in a set R(j, t) according to rule (iv.b) and one new occurrence according to rule (iv.c). Thus IR(j, t)l&lt;-Ig(j, t-1)l+2E IP( i, t-1) I.</p><p>Since IR(j, t)l &gt;-RI(j, t-1)[ this implies that Y max (0, IR(j, t)l-1) &lt;--Y max (0, Ig(j, t-1)1-1)+2 Y IP(i, t-1)l. j At most one processor may access at step of a computation on input fir the register Rj (this is the point where we are using the EREW property). Thus each occurrence of r in a set R(j, t-1) contributes at most one new occurrence of r in a set P(i, t) according to rule (iii.b). Let Jt be the set of registers accessed by some processor at step of some computation. The number of distinct registers accessed by Pi at step of some computation is bounded by the number of segments in the segment partition determined by the points in the set P(i, ), i.e. by IP(i, 1)l + 1. It follows that IJ, &lt;_-y IP(i, t-1)l+ p.</p><p>We obtain the inequality</p><formula xml:id="formula_2">P P Y IP(i, t)l-&lt;-Y IP(i, t-1)1 + E IR(j, t- i= i=</formula><p>JJt -E IP(i, t-1)1+ E (IR(j, t-)1-)+11,1 JJt E IP(i, t- max (0, IR(j, t-1)l-l) +p.</p><p>Combining the last two inequalities one obtains that c(t)-Y IP(i, t)l +Y max (0, [C(j, t)l-1) &lt;-_4 IP(i, t-1)1+2 Y max (0, IC(j, t-1)l-1)+p &lt;--4c(t-1)+p. D</p><p>We did not use in the proof the fact that concurrent writes are not allowed. Indeed, the lower bound is still valid for an ERCW (exclusive read, concurrent write) parallel machine. It is also valid even if inputs are initially replicated, so that each input value can be accessed concurrently by all the processors.</p><p>The last lower bound is optimal. An EREW machine with n / processors can solve the root finding problem for n keys x,..., xn in constant time by comparing in parallel xi to xi+, i=0,..., n (Xo-0, x,+-l, by definition). This generalizes to an algorithm that solves the problem with p processors P,. , Pp in O(lg (n/p)) steps as follows. Let ij [j(n + 1)/pl. Firstly, each processor P checks in parallel whether xj_, &lt; xj. Next, the unique processor P that found a strong inequality continues to execute a serial bisection algorithm on the list x_,+,..., x_l.</p><p>This simple algorithm can be extended to solve by comparisons the general range searching problem in O(lg n-lgp) steps, provided that the searched key can be accessed concurrently by all the processors. 4. Searching with an unbounded number of processors. If the searched key cannot be accessed concurrently by all the processors, then 12(lgp) steps are required to distribute it, thus cancelling the gain obtained from parallelism in the last algorithm. This would seem to imply that f(lg n) steps are required to solve the range search problem, independently of the number of processors. It turns out, however, that the range search problem can be solved much faster. Proof The idea of the algorithm is illustrated in Fig. <ref type="figure">2</ref>. The search is carried according to a multiway search tree where the branching factor is doubled at each level (Fig. <ref type="figure">2b</ref>). Such a tree of depth contains 2 t(t-l)/2-keys, so that searching a table of that size requires accesses to nodes of the tree. An access to a node of this tree is done in one memory access provided that an encoding of the tuple of keys at that node has been stored in one memory cell. Once the encoding of the keys at the node has been read, the decoding and the subsequent comparisons are performed locally, i.e. at no cost.  The search will be carried by one processor. Concurrently, the remaining processors will compute and store encodings of tuples of keys. The multiway search tree is obtained by "compressing" the binary search tree: A node at level of the multiway search tree contains the keys belonging to a complete subtree of depth i, rooted at level 1/2i(i 1) + 1, in the binary tree (Fig. <ref type="figure">2a</ref>). The processors will compress the binary search tree, increasing by one at each iteration the depth of the subtrees which encodings has been computed.</p><p>We describe now this algorithm more formally. Assume w.l.g, that n + 2 ''+)/2. Let ak k_ 1/2k(k + 1). The algorithm consists of iterations. At the end of iteration the search has proceeded through levels of the multiway search tree, that correspond to ai levels of the binary search tree. Also, encodings have been computed for the keys belonging to each complete subtree of the binary tree that has depth i+ and has its leaves at level aj, j i+ 1,..., (see Fig. <ref type="figure">2a</ref>). In particular, encodings have been computed for the keys of each subtree of depth i+ rooted at level ai + 1, i.e. for each tuple of keys belonging to a node of the multiway search tree at level i+ 1. During iteration i+ the searching processor accesses one of these encodings to push the search one level down on the multiway search tree; each of the remaining processors computes an encoding of the keys belonging to a binary tree of depth + 2 by combining the encodings for the left and right subtrees which have been computed at the previous iteration, and the key at the root.</p><p>At each iteration, each key and each encoding is accessed at most once, and the total number of new encodings computed is less than n. It follows that each iteration can be performed in constant time using O(n) processors, and that only O(n) registers are needed. The total running time is O(t)= O(x/lg n). [3   5. Order invariant computations and canonical paracomputers. We prove in this section that algorithms using only comparisons are as powerful as more general algorithms in solving comparison based problems. In order to do so, it will be convenient to work with a paracomputer model where information of input values is clearly distinct from other information.</p><p>Let X &lt;--n be the set of strings over X of length at most n. A paracomputer II with n inputs is in canonical form if it fulfills the following conditions.</p><p>(i) The set of processor states is of the form X&lt;--n C and the set of register symbols is of the form X -&lt;-n x D (n is the number of inputs to II). (The input symbol x X is identified with the register symbol (x, 0), where 0 D is a fixed constant.) (ii) If to((cr, s))=(r, v), then every element of r occurs in tr (a processor can write an input symbol only if it is present in its "local memory"). (iii) If ((tr, s), (r, v))= (tr', s') then every element of tr' occurs either in r or in r (a processor can store an input symbol in its "local memory" only if it is already there, or if it accessed it from shared memory). We call C the set of control symbols, and D the set of coordination symbols. The behaviour of a canonical paracomputer is conveniently indicated by specifying the indices of the input symbols that are moved. The functions a3 and are defined by the following identities. If tr and z are strings from X -&lt;" with symbols taken from the set {Xl''' x,), tr'=_ crl and z' =_l, then a,((r, c)= a,((tr', c), a3,((tr, c)-a3,((cr', c), and <ref type="figure">,</ref><ref type="figure">((tr,</ref><ref type="figure">c,</ref><ref type="figure">(z,</ref><ref type="figure">d)= ,</ref><ref type="figure">((cr',</ref><ref type="figure">c,</ref><ref type="figure">(z',</ref><ref type="figure">d</ref>), for a.ny c, d and i.</p><p>It is easy to see that this is indeed an equivalence relation on the n-element subsets of X. The number of distinct values the functions ai, o3i, and may assume is bounded by a function of n, q, ICI and IDI. It follows that the number G of distinct congruence classes is bounded by a function of n, p, q, IC and IDI. According to Ramsey's theorem, for any s there is a number N-N(n, G, s) such that if IXI &gt;_-N then X contains a subset Y such that YI &gt;--s and all n-element subsets of Y belong to the same congruence class. This entails that, if or, tr', , and ' are members of Y--&lt;, tr--or' and '--z' then ai((O" C) ai((O", C) <ref type="figure">,</ref><ref type="figure">(i((O',</ref><ref type="figure">C</ref>))= i(&lt;O", C), and ti((O', C, ('T, d)) 8,((tr', c), (z', d)), for any i, c and d. 71 COROLLARY 5.5. For each p, q and T there exist a number N N(p, q, T) such that the following holds: Let F be a finite order invariant function defined on X. Let II be a canonical paracomputer with p processors, q registers and time bound T, that computes a unary encoding of F. Let IX[ &gt;-N. Then there exists an order invariant canonical paracomputer with the same number of processors and registers, and the same time bound that computes F.</p><p>Proof. Let n be the number of variables of F (n &lt;_-q). According to Theorem 5.4, if X is large enough, then there exists a set Y such that [Y[ &gt;_-n and II is order invariant when restricted to inputs from Y. Each string from X -&lt;-is order equivalent to a string from Y--&lt;.</p><p>Let II' be the canonical paracomputer defined as follows" II' has the same number of processors and registers, same sets of symbols, and the same time bound as H; the access, write and transition functions are defined as follows.</p><p>( <ref type="figure">(,</ref><ref type="figure">c)= ,</ref><ref type="figure">((',</ref><ref type="figure">c</ref>))</p><p>where tr'e Y" is order equivalent to , ((, c&gt;) <ref type="figure">= ,</ref><ref type="figure">,</ref><ref type="figure">((',</ref><ref type="figure">c</ref>) where r'e Y-&lt;-" is order equivalent to t((tr, c), (z', d))= t,((tr', c), (z', d})</p><p>where tr' e Y--&lt;" is order equivalent to tr and z'e Y&lt;-" is order equivalent to</p><p>As II is order invariant on inputs from Y', II' is well defined, and order invariant on all inputs from X ". Also, the computations of II' are identical to the computations of II for inputs taken from Y'. Thus II' computes a unary encoding of F on Y', and by Corollary 5.3, computes a unary encoding of F on all X'. 6. Lower bounds on searching with an unbounded number of processors. We prove in this section that (x/g n) lower bound on searching with an unbounded number of processors. The argument consists of three parts. Firstly, we shall complete the proof of Theorem 5.1, thereby reducing the problem to canonical paracomputers. Secondly, the results of the previous section can be used to reduce the problem to canonical order invariant paracomputers. Finally, an argument similar to that used in the proof of Thm. 3.1 yields the lower bound.</p><p>Proof of Theorem 5.1. We shall build (II) from II by stipulating that whenever a processor of H writes onto shared memory, then the corresponding processor of Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php (II) writes onto shared memory a complete account of the information available to it; whenever a processor of H reads from shared memory, the corresponding processor of 97(II) reads and stores in its local memory (its state) the content of the register accessed. Thus, each processor of (H) has at each step sufficient information to simulate the corresponding processor of II.</p><p>In a processor state ((, c, cr will contain the input symbols which values "are known" to the processor, and c will represent the knowledge of the processor on the memory accesses that were executed. A similar convention holds for register values.</p><p>We shall use S-expressions to encode information on memory accesses. L 5f(X), the set of S-expressions over the set X, if[ L--NIL, or LX, (L is an atom from C) or L (LI L2),</p><p>where LI and L2 are S-expressions over X. The list (LI''' Lk) is the S-expression (... (LI. L2)'' ")" Lk) (this is the reverse of LISP convention).</p><p>Let H be a paracomputer. (Pi, :, t), the history of processor Pi at step of the computation on input , and (Rj, , t), the history of register Rj at step of the computation on input , are lists defined inductively as follows.</p><p>(P,, , 0)= i,</p><p>where is an S-expression with no atoms, encoding the number i;</p><p>(R, , 0)-xi if Rj contains the ith input NIL, otherwise.</p><p>If processor Pi accesses register Rj at step of the computation with input then ((P,, , t) ((P,, , t-1)((Rj, :, t-1)). If processor P modifies register R at step of the computation with input , then otherwise (Rj, , t)= (Rj, , t-1).</p><p>CLAIM. (i) The value of and the state s() of Pi at step of the computation with input are uniquely determined by (P, , t).</p><p>(ii) The content cj() of Rj at step of the computation with input is uniquely determined by j and (R, , t).</p><p>Proof. The claim is trivially true for 0. Assume it is valid for t-1.</p><p>(i) Let L (P, :, t). The value of can be determined from the first element of t--I the list L. From L we can extract (Pi, , t-l) and determine s () and, therefore, the index j of the register accessed by Pi at step t. The history (Rj, , l) of register '-() of Rj at time t-1 can be Rj at time t-1 occurs in L, so that the content cj t-1 t-I determined. But si () and c () determine s[().</p><p>(ii) Let L= (Rj, , t). If L= NIL or L-xj, then no processor wrote on R and its content is known. Otherwise L (P, , t'-l) where t' is the last step where a processor modified R and P is the processor that modified R at step t'. It is possible t'--I to determine from the expression the values of i, and the state s of P at step 1.</p><p>These determine the next value c of R, which is also the value of R at step t.</p><p>We define II' to be a paracomputer with the same number of processors, and registers, the same time bound, and the same set of input symbols as II. The processor Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php t-I (d) Pi accesses Rj at step of the computation on input , ar occurs in si '-() and br occurs in cj (iii) r 6 R( t) iff (a) re R( t-1), or (b) P modifies R at step of the computation with input :?, and r P(i, t-1), or (c) Pg modifies R at step of the computation with input r-, and r P(i, 1).</p><p>CLAIM. (i) Let s,(r_)=(or, c) and Sl(r)= (or', C'). If re!P(i, t), then c=c, or'= tr[ ar and =-tr.</p><p>(ii) Let cj(r_l)=(-, d) and C(r)=(Z', d'). If re!R(j, t) then a=a', -,, and --.</p><p>The proof of this claim is similar to the proof of the corresponding claim in Theorem 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let</head><formula xml:id="formula_3">P q c(t) E IP(i, t)l + E IR( i=1 j=l</formula><p>We have c(0)= 0 and c(T)_-&gt; 2n. Let us consider now the growth of c(t).</p><p>We have the following two facts.</p><p>Fact 1. Let f be the tth element of the Fibonacci sequence (fo =f 1). Then the number of distinct input symbols occurring in the content of a register at step is bounded by f-l, and the number of distinct input symbols occurring in the state of a processor at step is bounded by f. Fact 2. Each input symbol may occur in the states of at most 2 t-1 processors and the contents of at most 2 t-l registers at step of the computation on a fixed vector of inputs.</p><p>Let K =fr-i and H 2r-. Then each processor state and each register content occurring during a computation of II contains at most K input symbols, and each input symbol occurs in the states of at most H processors and the contents of at most H registers during the computation on input ft.</p><p>It is easily seen that (6.1) 2 ]R(j, t)[ &lt;= 2 IR(j, 1)[ + 2 2 IP(i, t-1)[.</p><p>The number of points contributed to sets P(i, t) according to rules (ii.1) and (ii.b) is bounded by (6.2) 2 IP(i, t-1)1 + 2 IR( t-1)l. j It remains to assess the contribution of rules (ii.c) and (ii.d).</p><p>Let (i, t) be the segment partition associated with P(i, t); let y(i, t) be the set of segments in (i, t) corresponding to states of P where an input symbol y br occurs; let (j, t) be the segment partition associated with R(j, t). For each r there are at most H processors that contain y br in their state at step of the computation on input ft. It follows, by Lemma 6.1, that E Iy(i, t)l=&lt;Y (l(i, t)l-1) / H-E [P(i, t)l/ H.</p><p>Replace each segment Sey(i,t-1) by the segments {SfIR'Re(j,t-1)}, where j is the index of the register accessed by Pi when in the states corresponding to the segment S. The total number of segments thus obtained is bounded by Y. Iy(i, t-1)l +Y IR(j, t-1)1&lt;_-[P(i, t-1)l+ H+F IR(j, t-1)l. Each of these segments contributes at most K new critical points, according to rule (ii.c). Thus, the total number of critical points contributed by rule (ii.c) is bounded by (6.3) K( IP(i, t)l+ IR(j, t)l+ H). j A similar argument yields the same bound for the number of new critical points contributed by rule (ii.d).</p><p>We obtain from (6.2) and (6.3) (6.4)</p><p>Z lP(i, t)I&lt;=(2K + I)[ IP(i, t-1)I+ IR(j, t-1)I] +2HK.</p><p>Inequalities (6.1) and (6.4) imply that c(t) Z IP(i, t) which implies that T-&gt;_ /lg n + O(1). rl</p><formula xml:id="formula_4">[ + E ]R( t)l ---(2K+3) ZIP( i, t-1)+(2K+2) Z [R(Z t-1)[+2HK It follows that _-&lt; (2K + 3)c( + 2HK.</formula><p>The last lower bound is valid even if we allow concurrent reads from those input registers that contain the searched table. It is only the access to the searched key that has to be restricted. 7. Paracomputers with bounded bandwidth. The O(x/g n) algorithm relies heavily on the fact that the content of one register may encode the values of an arbitrary number of inputs, so that an arbitrary amount of information can be transferred in one read or write operation, and processed in one instruction cycle. This is not a realistic assumption.</p><p>We can restrict this model by restricting the type of operations that can be performed on inputs. This is the approach usually followed in the analysis of com- parison based algorithms, where it is assumed that inputs are atomic entities that can be only compared. We obtain a "structured" computational model (in the sense used by <ref type="bibr" target="#b3">[3]</ref>), which is more amenable to analysis. Such restriction runs against the basic approach of this paper which is that of assuming powerful computational nodes, but restricted communication ability. We shall instead impose "structure" on the type of items that can be transmitted in one access to memory. We shall assume that a memory register may contain a unique input symbol; it can also contain a communication symbol, taken from a small set. Inputs are transferred atomically, so that an input symbol cannot encode the values of a tuple of input symbols. Formally, let II be a paracomputer with input set X and set of (i) V-X D, where D is a set of d communication symbols. (ii) A processor may write a symbol x X only if it had read it at previous steps. A paracomputer has bounded memory bandwidth if it has memory bandwidth d, for some finite d.</p><p>We shall allow the memory bandwidth d to grow as a function of the problem size n, but assume it is fixed with respect to the size of the input set. This restriction is still not sufficient to imply an II(lg n) lower bound. Indeed, it is still possible to represent the values of a tuple of keys by the state of a processor. We obtain THEOREM 7.1. The range searching problem for a table of size n can be solved by an EREWparacomputer with O( n) processors and registers and O(1) memory bandwidth in time O(lg n/lg lg n).</p><p>Proof. The algorithm used is similar to that given in Theorem 4.1. Assume w.l.g. that n (t + 1)!-1. The search proceeds according to a multiway search tree of depth t= O(lg n/lglg n), where nodes at level contain keys, and have, therefore, i+ children (see Fig. <ref type="figure" target="#fig_10">3</ref>). Such a tree, of depth t, contains (t + 1)!-keys, so that a table of that size can be searched in iterations. A processor is assigned to each node of that tree. This processor reads at each iteration one key, and stores its value in its local memory. At iteration the processors assigned to nodes at level have accessed all the keys at their node. Each processor is also assigned a mailbox. The searched key is initially in the mailbox of the processor assigned to the root. At iteration the processors assigned to level nodes access their mailbox. One processor finds the searched key in its mailbox, and compares it to the keys of its node, thereby selecting a node at level i/ where the search proceeds. It then puts the searched key in the mailbox associated with the node selected.</p><p>It is easy to see that each iteration can be implemented in constant time, using O(n) processors, O(n) registers, and two communication symbols. A matching lower bound can be proven, using the methods of the previous section. We leave to the reader the proof of the following analogue to Theorem 5.1. LEMMA 7.2. To each paracomputer II of bounded memory bandwidth, with p pro- cessors, q registers, time bound T, and set of communication symbols D we can associate an access equivalent canonical paracomputer (II) such that the set of processor states is of the form X&lt;=n C and the set of register symbols is of the form X x D, with IcI &lt;--0(27(p + q + [DI)). THEOREM 7.3. For any p, q and d there is a number N N(p, q, d) such that the following holds: If an EREW paracomputer with p processors, q registers, and memory bandwidth d solves in time T the range search problem for n inputs taken from a totally ordered set X such that Ixl--&gt; N, then T&gt;= lg n/lg lg n + O (1).</p><p>Proof The proof is similar to the proof of Theorem 6.2. We can assume w.l.g. that H is a canonical paracomputer of the form given by Lemma 7.2, and order invariant.</p><p>Let the n + input tuples o, , 3,, the sets P(i, t) and R(.h t), and the sequence c(t) be defined as in Theorem 6.2.</p><p>We have the following two facts. Fact 1. At most input symbols occur in the state of a processor at step t. Fact 2. A fixed input symbol may occur in at most 2 '-processor states and 2 '- register contents at step of a computation on a fixed input.</p><p>It follows that inequality (6.5) of Theorem 6.2 is valid with K T-and H 2 T-I.</p><p>We obtain that n &lt;-1/2H(2K + 3) 7" =&lt; 1/4(4T+ 2) r so that T_&gt;-lg n/lglg n+ O(1).</p><p>We further weaken our computational model by restricting the type of information that a processor may store in its local memory (i.e. its "state"). We assume now that each processor has a fixed number of local registers. Each local register, may store an input symbol. In addition, each processor has a finite state control.</p><p>Formally, let H be a paracomputer of bounded memory bandwidth with input set X, set of states S, and set of communication symbols D. Then II has processor bandwidth (k, c), if the following conditions hold:</p><p>(i) S xk C, where C is a set of c control state symbols.</p><p>(ii) Each input symbol that occurs in wi((tr, c)) occurs in (iii) If i((cr, d), u)= (r', d'), then each symbol of r' occurs either in o-or in u.</p><p>The second condition states that the value of a local register at step is either the value of a local register at step t-or a value read from memory. The third condition states that a processor may write an input symbol only if it is stored in one of its local registers. Note that a paracomputer of bounded processor bandwidth is a canonical paracomputer (provided that k_-&lt; n).</p><p>THEOREM 7.4. For any p, q, c, d, k, and T there is a number N N(p, q, c, d, k, T) such that the following holds: If an EREW paracomputer with p processors, q registers, memory bandwidth d, processor bandwidth c, k), time bound T solves the range search problem for n inputs taken from a totally ordered set X such that IXI &gt;-N, then T &gt;- (lgn/lgk+O(1)).</p><p>Proof The same argument that was twice applied works here as well. Inequality (6.5) of Theorem 6.2 is valid with K =k and H=2 T-I. We obtain that n-&lt;_ 1/2H(2K +3) r_-&lt;1/4(4k+6) , which yields the result. <ref type="bibr" target="#b3">[3</ref> The last result is asymptotically optimal: if processors may store in their local memory k keys, then it is possible to search a table of size n in O(lgk+l n + lg k) steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion.</head><p>As mentioned in the introduction, ultracomputers can be seen as a restricted class of EREW paracomputers. Thus, each of the lower bounds is valid Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php ON PARALLEL SEARCHING 707 for ultracomputers. Consider a network of processors, each directly connected to all the other ones, such that each processor contains one key from the searched table, and one processor contains the searched key. If each processor has a fixed size local memory, then fl(lg n) communication steps are required to perform a search, even if local computations are allowed for free. If local memory is not restricted in size, but only one input value may be transmitted at a time, then the problem can be solved in O(lgn/lg lg n) communication steps. Finally, if there are no restrictions on the type of information that can be transferred in one communication step, then the problem can be solved in O(/g n) steps.</p><p>There are few methods known to prove lower bounds for parallel algorithms, which are not based on fanin arguments. This paper contributes one such new method. It seems to capture two "real-life" problems encountered while writing parallel pro- grams" it is hard to parallelize algorithms with many test and branch operations; and frequent coordination between concurrent processes may offset any gain obtained from concurrency.</p><p>This paper also provides a method to generalize lower bounds obtained for comparison based algorithms to less restricted algorithms. In that, we were inspired by the work of Yao [14]. This method can be useful in other settings as well, and in particular can be used to analyse distributed algorithms <ref type="bibr" target="#b8">[8]</ref>.</p><p>A more natural constraint on information transfer would be to restrict the number of bits that can be stored in one memory cell. We believe that our lower bounds are valid in such model too, but the proofs seem much harder to obtain.</p><p>The paracomputer models we presented may suffer a few interesting variations. As noted in 2, the O(lg n/lgp) searching algorithm can be implemented on any EREW shared memory parallel machine where one processor has the ability to broad- cast messages to all the other processors in constant time (a BEREW machine?). If all the processors share this broadcasting ability (only one broadcast is allowed at a time), then this algorithm can be implemented even in the absence of shared memory.</p><p>We have here a model of parallelism, corresponding to a bus-oriented architecture. A similar model was studied by Stout [11].</p><p>Another natural variation is to assume that conflicting memory accesses do not result in an error, but rather in a busy signal being returned to all but one of the requests; alternatively one may postulate a queuing scheme at the memory.</p><p>In a real parallel machine memory is likely to be organized into modules with exclusive access being enforced at the level of the memory module rather than at the level of the memory cell. This suggests that we consider computational models where the number of shared memory cells is restricted, and where the amount of information that can be transferred in one read or write operation is smaller than the content of a memory cell. The work of Baer, Du and Ladner [1], and of Vishkin and Wigderson [13] is a useful start in the investigation of such systems. 9. Acknowledgments. I would like to thank Clyde Kruskal who provided the initial thrust for this work, and Allan Borodin and Chee Yap for their helpful remarks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Downloaded 12 /</head><label>12</label><figDesc>25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>t--1 t--I t--I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>together with (3.2) yields the inequality nNp, or Tlog4 3 +1 (Ign-lgp).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Downloaded 12 /</head><label>12</label><figDesc>25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php ON PARALLEL SEARCHING 697 THEOREM 4.1. The range search problem for a table of size n can be solved by an EREW paracomputer with O(n) processors and O(n) registers in O(/ig n) steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>FIG. 2b. Corresponding multiway search tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Downloaded 12 /</head><label>12</label><figDesc>25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>where</head><label></label><figDesc>Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php following holds"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Downloaded 12 /</head><label>12</label><figDesc>25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php MARC SNIR</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Downloaded 12 /</head><label>12</label><figDesc>25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php ON PARALLEL SEARCHING 705 register symbols V. Then H has memory bandwidth d if the following two conditions hold:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>FIG. 3 .</head><label>3</label><figDesc>FIG. 3. Multiway search tree for algorithm in Theorem.7.1.   </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>l, Xbot =--, Xtop o*/</figDesc><table><row><cell>COILS</cell><cell></cell></row><row><cell>p;</cell><cell>/*Number of processors*/</cell></row><row><cell>Vll"</cell><cell></cell></row><row><cell cols="2">newbot, newtop;</cell></row><row><cell cols="2">c,..., Cp+;/*Vector storing outcomes of comparisons*/</cell></row><row><cell>begin</cell><cell></cell></row><row><cell>cp+ := 1;</cell><cell></cell></row><row><cell cols="2">while (top &gt;bot + 1) do</cell></row><row><cell cols="2">for j in 1, p] pardo</cell></row><row><cell>vat</cell><cell></cell></row><row><cell>i;</cell><cell></cell></row><row><cell cols="2">/*Compute index of key to be compared*/</cell></row><row><cell cols="2">i:= bot+j,(top-bot)/(p+ 1);</cell></row><row><cell cols="2">/*Compare and store outcome*/</cell></row><row><cell cols="2">c := if y &gt; x then 0 else</cell></row><row><cell>odrap;</cell><cell></cell></row><row><cell cols="2">/*Compute next interval*/</cell></row><row><cell cols="2">(newbot, newtop) := (bot, (top-bot)/(p + 1));</cell></row><row><cell cols="2">for j in 1,p] pardo</cell></row><row><cell cols="2">if c &lt; c+ then (newbot, newtop):= (bot+j*(top-bot)/(p+ 1),</cell></row><row><cell></cell><cell>bot+ (j+ 1)*(top-bot)/(p + 1))</cell></row><row><cell>odrap;</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc><table><row><cell>MARC SNIR</cell></row><row><cell>Concurrent reads may occur at several places in the algorithm given in Theorem</cell></row><row><cell>2.1:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>the</head><label></label><figDesc>Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</figDesc><table><row><cell>ON PARALLEL SEARCHING</cell><cell>695</cell></row><row><cell>FIG. 1. Evolution ofpartitions over one step. Marks critical points at step</cell><cell>marks new critical points</cell></row><row><cell>at step t.</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The definition of a canonical paracomputer is motivated by the following result.</p><p>THEOREM 5.1. To each paracomputer II with p processors, q registers, and time bound T, we can associate an access equivalent canonical paracomputer r(II) with O(2T(p+ q)) control and coordination symbols.</p><p>We postpone the proof of this theorem to the next section. It is important to note that the number of control and coordination symbols of r(II) is independent of the number of input symbols.</p><p>The following definitions will make precise the notion of a comparison based computation. Two strings , 37 X" are order equivalent (-= ) if i,j, x &lt; xcr y &lt; y.</p><p>A function F defined on X" is order invariant if = 37F()= F(37). F is order invariant iff each set F-(y) can be defined by inequalities, that is by Boolean combinations of assertions of the form x &lt; x. The range search function RS is order invariant. Note that an order invariant function has finite range. A canonical paracomputer is order invariant if, when tr--tr' and '= ", the following conditions are fulfilled for any c, d and i.</p><p>(i) a,((tr, c))--ai((tr', c)).</p><p>(ii) a3,((tr, c))= a3,((tr', c)).</p><p>(iii) ,((tr, c), (r, d))= ,((tr', c), (r', d)).</p><p>Informally, a canonical paracomputer is order invariant if the behavior of each processor depends only on the value of the control and coordination symbols, and the relative order of the input values it has access to, but not on the value of the input symbols themselves. In particular, the computation will follow the same course on two sets of input values where the inputs have the same relative order.</p><p>Let trl denote the string obtained by substituting in tr each occurrence of x by an occurrence of y. We leave to the reader the straightforward proof of the following lemma, which formalizes the last claim.</p><p>LEMMA 5.2. Let II be an order invariant canonical paracomputer, and let and be order equivalent input vectors. Then the following holds (i) If s,() (r, c) and s,() (r', c') then c c' and r'= rl (ii) If c () (tr, d) and c () tr', d') then d d' and r' rl (iii) a,(sl())= a,(sl()) for all and t. COROLLARY 5.3. Let F be an order invariant function defined on U X, and let W X" be a set that contains a representative for each order equivalence class in U (i.e. ' U ::1)7 W s.t. -= fi). Let II be an order invariant canonical paracomputer that computes a unary encoding of F for inputs taken from W. Then H computes a unary encoding of F for any input taken from U.</p><p>Proof. Let be an input vector from U. Let )7 W be order equivalent to .T hen F() F(fi). On the other hand, by Lemma 5.2, the computation of H on is access equivalent to the computation on 37, so that a unary encoding of F() is computed.</p><p>We make use of the following well-known theorem <ref type="bibr" target="#b9">[9]</ref>. RAMSEV'S THEOREM. For any k, m and there exist a number N(k, m, t) such that the following is true" Let S be a set of size at least N(k, m, t); if we divide the k-element subsets of S into parts, then at least one part contains all the k-element subsets of some m elements of S.</p><p>THEOREM 5.4. For each m, p, q and T there exist a number N N( m, p, q, T) such that the following holds" Let II be a canonical paracomputer with p processors, q registers, time bound T, and an input set X of size IxI &gt;-N. Then there exists a subset Y X such that YI &gt;-m and II is order invariant when restricted to inputs from Y.</p><p>Proof. Let {x... x,} and {y... y,} be two n-element sets of input symbols, indexed in increasing order. We say that x...x, is congruent to Yl"'Y, if the Downloaded 12/25/12 to 150.135.135.70. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php</p><p>states and register values of H' are S-expression with atoms taken from X. The functions of H' are defined as follows.</p><p>a'i(L) is undefined otherwise. if s sl(), L= (P;, t, to',(L) L. 61(L,, L_) (L,. L2).</p><p>The previous claim implies that H' is access equivalent to II" in fact t(Pi, t, Y) and c.'(Y)= Y((Ri, t, y) for every i, j, t, and Y.</p><p>Each history expression of I1 contains at most n distinct input symbols, and has length at most o(2T(p+q)). Let L be an S-expression with atoms Xl,''',Xk. We represent L by the pair (x Xk, L'"'-), ii...il where J" is an atom-free S-expression (distinct from J') that encodes the number i. The canonical paracomputer (II) is obtained from II' by replacing each state symbol, and each register content symbol by its above representation.</p><p>We leave to the reader the proof of the following technical lemma. LEMMA 6.1. Let 1, r be segment partitions of . Let o be a family of (not necessarily distinct) segments from ,. r with the property that each element in is contained in at most s sets from o. Then Il &lt;-E I,l-r/s, i=l THEOREM 6.2. For any p and q there is a number N(p, q) such that the following holds: If an ERE W paracomputer with p processors and q registers solves in time T the range search problem for n inputs taken from a totally ordered set X such that then T&gt;= lg n + O(1).</p><p>Proof Let H be an EREW paracomputer that computes in T steps a unary encoding of the function RS:X" that is associated with the range search problem. We can assume w.l.g., by Corollary 5.5, that H is a canonical, order invariant paracomputer.</p><p>Let us pick 2n + elements from X, bo &lt; a &lt; b &lt; "On &lt; bn, and consider the behavior of the algorithm on the n + sets of inputs (a,..., an, bi)i 0," ", n. Note that RS(Y,) i.</p><p>We follow now the same approach as in the proof of Theorem 3.1. Let sl(Y_)= (o-, c) and sl(Y)= (o-', c'). The only inputs whose relative order in Y_ is different from their relative order in Y are y and x. Thus, the state of processor Pi distinguishes between input Y_ and input Y if the control symbols are distinct (c # c'), or the set of inputs accessed are distinct (o-'# r] '-'), or neither conditions obtain but both the values of y(=b._ or b) and of x(=a) are known to P (occur in r and or'), in which case r is not order equivalent to o-'. This motivates the following definitions. We define inductively the sets P(i, t) and R(j, t) as follows.</p><p>(i) P(i, 0) R(j, O) . (ii) rP(i,t) iff (a) re P(i, t-1), or (b) P accesses Ri at step of the computation on input Yr, and r R(j, t-1), or t--I (c) P accesses Ri at step of the computation on input Y,, b occurs in si (Yr), </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Binary search in a multiprocessor environment</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Baer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="667" to="676" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Routing, merging, and sorting on parallel models of computations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th ACM Symposium on Theory of Computing</title>
		<meeting>14th ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="338" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Redistribution subject to SIAM license or copyright</title>
		<idno>Downloaded 12/25/12 to 150.135.135.70</idno>
		<ptr target="http://www.siam.org/journals/ojsa.php" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Structured versus general models in computational complexity, in Logic and Algorithmic, Monographie no. 30 de l&apos;Enseignement Math6matique, Universit6 de Geneve</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bounds on the time for parallel RAM&apos;s to compute simple functions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th ACM Symposium on Theory of Computing</title>
		<meeting>14th ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="231" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Simultaneous memory access</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Eckstein</surname></persName>
		</author>
		<idno>Res. Rep. TR-79-6</idno>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Dept., Iowa State Univ., Ames</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Optimal sequential and parallel search forfinding a root</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Miranker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Combin. Theory (A)</title>
		<imprint>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Upper and lower bounds on the performance of parallel algorithms</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Kruskal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<pubPlace>New York</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Dept., New York Univ.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Nancy</forename><surname>Lynch</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>private communication</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On a problem offormal logic</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">P</forename><surname>Ramsev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. London Math. Soc., 2nd ser</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="264" to="286" />
			<date type="published" when="1930">1930</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ultracomputers</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="484" to="521" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Mesh-connected computers with broadcasting</title>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">F</forename><surname>Stout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="826" to="830" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">O/1 parallel searching</title>
		<author>
			<persName><forename type="first">M</forename><surname>Snir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Distributed Computing</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="242" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Trade-offs between depth a/1d width i/1 parallel computation</title>
		<author>
			<persName><forename type="first">U</forename><surname>Vishkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th IEEE Symposium on Foundations of Computer Science</title>
		<meeting>24th IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1983">1983. 1985</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="303" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Should tables be sorted?</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Math</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="615" to="628" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
