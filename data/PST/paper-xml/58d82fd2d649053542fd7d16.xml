<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Search-based software library recommendation using multi-objective optimization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Ali</forename><surname>Ouni</surname></persName>
							<email>ouniaali@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">IST</orgName>
								<orgName type="institution" key="instit2">Osaka University</orgName>
								<address>
									<settlement>Osaka</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="institution">UAE University</orgName>
								<address>
									<country key="AE">UAE</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Raula</forename><surname>Gaikovina Kula</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">IST</orgName>
								<orgName type="institution" key="instit2">Osaka University</orgName>
								<address>
									<settlement>Osaka</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marouane</forename><surname>Kessentini</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Takashi</forename><surname>Ishio</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">IST</orgName>
								<orgName type="institution" key="instit2">Osaka University</orgName>
								<address>
									<settlement>Osaka</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>German</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Victoria</orgName>
								<address>
									<settlement>Victoria</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Katsuro</forename><surname>Inoue</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">IST</orgName>
								<orgName type="institution" key="instit2">Osaka University</orgName>
								<address>
									<settlement>Osaka</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Search-based software library recommendation using multi-objective optimization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F44A1B71CFAE4A13DC2B18C2A349DE5D</idno>
					<idno type="DOI">10.1016/j.infsof.2016.11.007</idno>
					<note type="submission">Received 2 December 2015 Revised 28 October 2016 Accepted 22 November 2016</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Search-based software engineering Software library Software reuse Multi-objective optimization</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Context : Software library reuse has significantly increased the productivity of software developers, reduced time-to-market and improved software quality and reusability. However, with the growing number of reusable software libraries in code repositories, finding and adopting a relevant software library becomes a fastidious and complex task for developers.</p><p>Objective : In this paper, we propose a novel approach called LibFinder to prevent missed reuse opportunities during software maintenance and evolution. The goal is to provide a decision support for developers to easily find "useful" third-party libraries to the implementation of their software systems.</p><p>Method : To this end, we used the non-dominated sorting genetic algorithm (NSGA-II), a multi-objective search-based algorithm, to find a trade-off between three objectives : 1) maximizing co-usage between a candidate library and the actual libraries used by a given system, 2) maximizing the semantic similarity between a candidate library and the source code of the system, and 3) minimizing the number of recommended libraries.</p><p>Results : We evaluated our approach on 6083 different libraries from Maven Central super repository that were used by 32,760 client systems obtained from Github super repository. Our results show that our approach outperforms three other existing search techniques and a state-of-the art approach, not based on heuristic search, and succeeds in recommending useful libraries at an accuracy score of 92%, precision of 51% and recall of 68%, while finding the best trade-off between the three considered objectives. Furthermore, we evaluate the usefulness of our approach in practice through an empirical study on two industrial Java systems with developers. Results show that the top 10 recommended libraries was rated by the original developers with an average of 3.25 out of 5.</p><p>Conclusion : This study suggests that (1) library usage history collected from different client systems and (2) library semantics/content embodied in library identifiers should be balanced together for an efficient library recommendation technique.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Modern software systems build on a significant number of third-party software libraries to deliver feature-rich and highquality software. Several studies have shown that software library reuse promotes efficient and effective software development. Consequently, library reuse leads to a significant increase in the pro-ductivity, reduction in time-to-market, improvement in the overall software quality, as well as reducing the inherent testing costs <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> . Reusing mature software modules can benefit from the collective experience of previous users of the module, as many bugs as well as deficiencies in the documentation have already been discovered <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> .</p><p>Indeed, it is recognized that replacing legacy code with quality components and libraries typically reduces the amount of source code that must be maintained <ref type="bibr" target="#b4">[5]</ref> . The benefits of replacing legacy code by external quality software components was best articulated by Seacord et al. <ref type="bibr" target="#b4">[5]</ref> : "replacing functional components may also provide additional capabilities and improve on such attributes of system quality as robustness or performance ". In fact, replacing legacy code by third-party libraries has recently attracted much attention in both academia and industry. One example is the refactoring of "synchronized" blocks in Java by replacing them with the utility library java.util.concurrent <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref> .</p><p>Today, software systems utilize online code repositories such as Maven Central repository 1 to access to a host of reusable Open Source Software (OSS) libraries. Indeed, reusable software libraries are often reused multiple times and are therefore proven solutions that can provide better quality characteristics compared to newly developed code <ref type="bibr" target="#b7">[8]</ref> . Recent empirical studies have found that 93.3% of modern OSS projects use third-party libraries, with an average of 28 libraries per project <ref type="bibr" target="#b8">[9]</ref> . On the other hand, recent work indicate that developers are still often reinvent the wheel and spend effort and time, on re-implementing functionality, that could be saved by reusing mature and well-tested libraries <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> .</p><p>We conjure two key reasons for this occurrence. First, due to the magnitude of available libraries we consider that, most of the time, developers are unaware or overwhelmed by related libraries. Online sources 2 report that available libraries are growing at an exponential rate. Hence, searching relevant software libraries can be a fastidious task for software developers, which would have an impact their productivity. Second, in addition to different reasons of distrust <ref type="bibr" target="#b11">[12]</ref> , developers are wary of the inherent costs and risks of library incompatibilities <ref type="bibr" target="#b12">[13]</ref> associated with integrating new and unknown libraries into their existing systems. With the motto ' if not broke don't fix ', systems as a consequence risk outdated libraries.</p><p>To help developers, most of existing library recommendation approaches are based on commonly used together library methods, e.g., API usage patterns, at the method level of granularity <ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b16">[16]</ref><ref type="bibr" target="#b17">[17]</ref><ref type="bibr" target="#b18">[18]</ref> . The most related work of recommendation at the library level of granularity is by Thung et al. <ref type="bibr" target="#b8">[9]</ref> . The authors use collaborative filtering and association rule mining on historic software artifacts to determine commonly used libraries without considering the library content. However, a library usage history-based approach would not be able to recommend libraries to projects that only use a small number of libraries or do not use any libraries at all. Thus, the content of a library is an extremely important asset that should be more informative and explicit for an effective library recommendation method. This approach deal with library recommendation as a single objective problem based on usage history. We believe that library recommendation is rather a complex decision making problem where several considerations should be balanced. These complex multi-objective decision problems with competing and conflicting constraints are well suited to Search Based Software Engineering (SBSE) <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b20">20]</ref> .</p><p>To address the library recommendation problem, we introduce a novel approach called LibFinder based on the following two heuristics: a candidate library L can be useful for a given system S if ( i ) L has been commonly used with one or more libraries adopted by S , and ( ii ) L uses identical or similar identifiers, i.e., belongs to the same application domain, as S . To this end, we used the history of library usage as a 'wisdom of the crowd' and semantic similarity embodied in library identifiers mined from large code repositories from the internet. Our multi-objective formulation aims at finding optimal solutions providing the best trade-off between the three following objectives: 1) maximize co-usage between a candidate library and the actual libraries used by a given 1 http://search.maven.org . 2 http://www.modulecounts.com , mvnrepository.com . system, 2) maximize the semantic similarity between a candidate library's code and the system's code, and 3) minimize the total number of recommended libraries. To this end, we used the popular multi-objective search-based algorithm the non-dominated sorting genetic algorithm (NSGA-II) <ref type="bibr" target="#b21">[21]</ref> to find the best trade-off between the three objectives. The complexity of the addressed library recommendation problem is combinatorial since our formulation consists of assigning libraries to different code fragments and the search is guided based on the above dependent evaluation functions.</p><p>To evaluate the efficiency of our approach, we used the history of 32,760 software projects mined from Github, that were clients for 6083 Maven libraries. The obtained results show that our approach is efficient in recommending relevant software libraries. We compare our approach with random search and two other popular search-based algorithms as well as a state-of-the-art approach. The statistical analysis shows better performance of our approach with 92% of accuracy, 51% of precision and 68% of recall. Furthermore, we evaluate the usefulness of our approach in practice through an empirical study on two industrial Java systems with developers. Results show that the top 10 recommended libraries was rated by the original developers of both systems with an average of 3.25 out of 5.</p><p>The main contributions of this paper can be summarized as follows:</p><p>1. We propose a new search-based approach called LibFinder , to detect and recommend third-party libraries that may be relevant to software systems that have already been implemented, and that it is intended for maintenance and evolution. To the best of our knowledge, this is the first attempt to use SBSE to address the library recommendation problem. 2. We collect a rich dataset by ( i ) mining the usage history, and</p><p>( ii ) extracting the identifiers of a large set of popular libraries from Maven Central Repository. The dataset is publicly available to encourage future research in the field of library recommendation <ref type="foot" target="#foot_0">3</ref> . 3. We present an empirical evaluation of the performance of our approach using a 10-fold cross validation, along with statistical analysis of the obtained results. The obtained results show that our approach outperforms random search and two other search techniques at a confidence level of 95% and outperforms a state-of-the-art library recommendation approach <ref type="bibr" target="#b8">[9]</ref> with an accuracy score of 92%, precision score of 51% and recall score of 68% while finding the best trade-off between the considered objectives. We present the results of a second empirical study to evaluate our approach in two industrial systems in real world setting where the recommended libraries were rated 3.25 out of 5 on average.</p><p>The rest of the paper is organized as follows. Section 2 presents the necessary background and a motivating example. Section 3 presents the basic concepts of our approach. Section 4 introduces our search-based approach for library recommendation LibFinder . Section 5 describes our empirical study and reports the obtained results, while Section 6 presents the threats to validity of the study. Section 7 presents the related work. Finally, Section 8 concludes and presents our future research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background and motivating example</head><p>In this section, we first describe the necessary background related to the proposed approach. We then present an example to help readers to better understand the motivation for library recommendation. Our approach is largely inspired by contributions in SBSE and MSR. SBSE studies the application of meta-heuristic optimization techniques to software engineering problems <ref type="bibr" target="#b22">[22]</ref> . Once a software engineering task is framed as a search problem, by formulating it in terms of solution representation, objective function, and solution change operators, there are a multitude of search algorithms that can be applied to solve that problem. SBSE aims at exploring large search spaces of possible solutions for a particular problem in order to discover near optimal solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ARTICLE IN PRESS</head><p>On the other hand, the Mining Software Repositories (MSR) field analyzes the rich data available in software repositories to uncover interesting and actionable information about software systems and projects. MSR transforms software repositories to gain empirical understanding of software development. This can be leveraged by software practitioners to estimate and manage various aspects of their projects <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b24">24]</ref> .</p><p>In recent years, both fields are widely applied to solve several software maintenance and evolution problems including refactoring, testing, modularization, planning, and so on <ref type="bibr" target="#b22">[22]</ref><ref type="bibr" target="#b23">[23]</ref><ref type="bibr" target="#b24">[24]</ref> . However, despite the innate link between both fields, SBSE and MSR communities are still not unified. Indeed, library recommendation is a complex task, and one of the non-obvious software engineering problems that can benefit from both SBSE and MSR techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Recommendation systems</head><p>Recommendation systems support users and developers of various computer and software systems to overcome information overload, perform information discovery tasks and approximate computation, among others <ref type="bibr" target="#b25">[25]</ref> . With the increasing size and complexity of software systems and software engineering data, recommendation systems play an important role in providing a decision support for software engineers. Indeed, recommendation systems have recently become popular in software engineering and have attracted a wide variety of application scenarios from business process modeling to source code maintenance and manipulation <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b27">27]</ref> . Recommendation systems use a number of different technologies <ref type="bibr" target="#b28">[28,</ref><ref type="bibr" target="#b29">29]</ref> , and can be classified into two broad classes.</p><p>• Content-based systems: These systems focus on properties of items. Similarity of items is determined by measuring the similarity in their properties and features. • Collaborative-filtering systems: These systems focus on the relationship between users and items based on the usage history. Similarity of items is determined by the similarity of the utilization/ratings of those items by the users who have used/rated both items.</p><p>Each class has its own advantages and disadvantages. For instance, content-based approaches provide user independence, in contrast to collaborative filtering that needs other users' history to find the similarity between them and then give the recommendations. Content-based methods only need to analyze users and items features. Moreover, collaborative filtering methods provide recommendations for a user based on some unknown users who might have the same taste, while content-based methods provide recommendations based on what item's features the users like. On the other hand, unlike collaborative filtering, new items can be recommended by a content-based method before being used by a substantial number of users. Thus, both classes can be combined together in order to provide more effective recommendation systems.</p><p>Algorithm 1 High level pseudo code for NSGA-II. </p><formula xml:id="formula_0">P t+1 = ∅ and i = 1 8: while | P t+1 | + | F i | N do 9:</formula><p>Apply crowding-distance-assignment( F i ) 10:</p><formula xml:id="formula_1">P t+1 = P t+1 ∪ F i 11: i = i + 1 12:</formula><p>end while</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>Sort(F i , ≺ n ) 14:</p><formula xml:id="formula_2">P t+1 = P t+1 ∪ F i [ N-| P t+1 | ] 15: Q t+1 = create-new-pop( P t+1 ) 16:</formula><p>t = t+1 17: end while</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Multi-objective search-based algorithms</head><p>Multi-objective problems contain several objectives, and the goal is to find solutions that are able to optimally satisfy each objective simultaneously. However, in real world problems, it is difficult (or even impossible) to find a solution that is concurrently perfect for each objective for a problem with two or more objectives due to conflicts that always exist among problem objectives. Thus, certain expenses and trade-offs always exist between the multiple objectives of a problem <ref type="bibr" target="#b30">[30]</ref> . Many real-world problems involve simultaneous optimization of several incommensurable and often competing objectives. Often, there is no single optimal solution, but rather a set of alternative solutions. One of the most popular multi-objective search-based algorithms is the non-dominated sorting genetic algorithm (NSGA-II) <ref type="bibr" target="#b21">[21]</ref> that has shown high performance in solving several software engineering problems <ref type="bibr" target="#b22">[22]</ref> .</p><p>A high-level view of NSGA-II is depicted in Algorithm 1 . NSGA-II starts by randomly creating an initial population P 0 of individuals encoded using a specific representation (line 1). Then, a child population Q 0 is generated from the population of parents P 0 (line 2) using genetic operators (crossover and mutation). Both populations are merged into an initial population R 0 of size N (line 5). Fast-nondominated-sort <ref type="bibr" target="#b21">[21]</ref> is the technique used by NSGA-II to classify individual solutions into different dominance levels (line 6). Indeed, the concept of non-dominance consists of comparing each solution x with every other solution in the population until it is dominated (or not) by one of them. According to Pareto optimality: "A solution x 1 is said to dominate another solution x 2 , if x 1 is no worse than x 2 in all objectives and x 1 is strictly better than x 2 in at least one objective". Formally, if we consider a set of objectives f i , i ∈ 1..n, to maximize, a solution x 1 dominates x 2 :</p><formula xml:id="formula_3">iff ∀ i, f i ( x 2 ) ≤ f i ( x 1 ) and ∃ j | f j ( x 2 ) &lt; f j ( x 1 )</formula><p>The whole population that contains N individuals (solutions) is sorted using the dominance principle into several fronts (line 6). Solutions on the first Pareto-front F 0 get assigned dominance level of 0 Then, after taking these solutions out, fast-non-dominated-sort calculates the Pareto-front F 1 of the remaining population; solutions on this second front get assigned dominance level of 1, and so on. The dominance level becomes the basis of selection of individual solutions for the next generation. Fronts are added successively until the parent population P t+1 is filled with N solutions (line 8). When NSGA-II has to cut off a front F i and select a subset of individual solutions with the same dominance level, it relies on the crowding distance <ref type="bibr" target="#b21">[21]</ref> to make the selection (line 9). This Please cite this article as: A. parameter is used to promote diversity within the population. This front F i to be split, is sorted in descending order (line 13), and the first (N-| P t+1 | ) elements of F i are chosen (line 14). Then a new population Q t+1 is created using selection, crossover and mutation (line 15). This process will be repeated until reaching the last iteration according to stop criteria (line 4). For library recommendation, Pareto optimality means that we do not recommended to the developer a single solution. Instead, we want to provide a decision support tool, by showing a variety of solutions, allowing the developer to see a space of trade-offs between the considered objectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Motivating example</head><p>To illustrate the need for an approach to recommending useful libraries, let us consider the example of JVacation <ref type="foot" target="#foot_1">4</ref> , an open-source stand alone travel-booking-client for travel-agencies.</p><p>JVacation is implemented in java and its current version adopts only one third party library, mysql-connector-java <ref type="foot" target="#foot_2">5</ref> . It is clear that this software system does not effectively take advantage of reusing functionality provided by existing OSS libraries; instead, developers are trying to reinvent the wheel.</p><p>Indeed, several library reuse opportunities are missed. For instance, JVacation is implementing from scratch several functionalities such as entering/editing dates and integrating a date edit panel manually into their GUI as illustrated in the code fragment sketched in Fig. <ref type="figure">1</ref> .</p><p>While using the standard APIs java.util.Calendar with javax.swing.JPanel provided by JDK is helpful, other existing libraries such as JCalendar<ref type="foot" target="#foot_3">6</ref> can be more relevant as it is more specialized for GUI-based software systems. The library JCalender provides an IDateEditor for direct date editing, and a button implementing JDateChooser for opening a JCalendar for graphically selecting date, as well as other calender services that can be useful for this travel-booking software system.</p><p>One can notice that JCalendar share several identifiers/terms with JVacation including Calendar, Date, Panel, Edit, Day, Month, Year , and so on. This is an indication that they implement simi-lar functionalities, and therefore JCalendar can be a candidate library that might be relevant for JVacation .</p><p>In such situations, recommending libraries based only on the library usage history, such as in <ref type="bibr" target="#b8">[9]</ref> , would not be enough. In fact, more informative knowledge about the library content is highly required for effective recommendations. On the other hand, using only library usage history might give no chance for new emerging libraries to be recommended and adopted.</p><p>The above observations tell us that effective libraries recommendation should make the content of library more explicit and informative as well as libraries usage history.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Basic concepts and terminology</head><p>This section defines the basic concepts and terminology underlying the proposed approach in this paper: library usage, co-usage, linked-usage, and semantic similarity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">System and library dependencies</head><p>We are concerned with mining large code repositories to extract the ' wisdom from the crowd '. Specifically in regards to the dependence of third-party libraries in software systems.</p><p>Suppose l ∈ R , where l is a library that belongs to a set of super library repositories R . Examples of popular super repositories that host such libraries include Maven<ref type="foot" target="#foot_4">7</ref> and Nuget<ref type="foot" target="#foot_5">8</ref> . In this study, we are particularly interested in the frequency count of a set of different systems S that use a library l . At this stage we do not consider the granularity of library versions. We define the following terms:</p><p>• Usage . Usage refers to the frequency count of systems that have used a library l . For a specific system S i , S i → l shows that the system S i uses a library l . Formally, let p the total number of available systems, for l ∈ R , we define:</p><formula xml:id="formula_4">usage (l) = p i =1 [ S i → l]<label>(1)</label></formula><p>• Co-usage . The co-usage refers to the frequency count of a pair of libraries used together in one system. Take l 1 and l 2 as two</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ARTICLE IN PRESS</head><p>JID: INFSOF [m5G; <ref type="bibr">December 2, 2016;</ref><ref type="bibr">19:13 ]</ref> libraries, then the co-usage is:</p><formula xml:id="formula_5">co-usage (l 1 , l 2 ) = p i =1 [ S i → l 1 ∧ S i → l 2 ]<label>(2)</label></formula><p>• Linked-usage . The linked-usage metric is a simple average of co-usage score in respect to the usage of different libraries l 1 and l 2 . Formally:</p><formula xml:id="formula_6">linked-usage (l 1 , l 2 ) = 1 2 × co-usage (l 1 , l 2 ) usage (l 1 ) + co-usage (l 1 , l 2 ) usage (l 2 ) (3)</formula><p>The linked-usage is used as a normalized measure of the cousage between two libraries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Semantic similarity</head><p>Inspired by information retrieval (IR) technique, our approach uses semantic similarity as a primary mechanism of capturing similar concepts between a given software system's code and a thirdparty library. Our assumption is that the identifiers/vocabulary of a software element are borrowed from its domain terminology, and thus identifiers can be used as an indicator of source code relatedness. This implies that two software elements could be in the same application domain, i.e., implement similar functionality, if they use similar vocabulary <ref type="bibr" target="#b31">[31]</ref> . One of the widely used techniques in IR to calculate semantic similarity between documents is cosine similarity .</p><p>• Cosine similarity . To capture the semantic relatedness between two bags of words A and B , the cosine similarity is defined as the cosine of the angle between both vectors representing A and B in a vector space using tf-idf (term frequency-inverse document frequency) model. We interpret term sets as vectors in the n-dimensional vector space, such that each dimension corresponds to the weight of the term (tf-idf) and thus n is the overall number of terms. Formally, the semantic similarity ( Sim ) between A and B corresponds to the cosine similarity ( CS ) of their two weighted vectors A and B given by Eq. ( <ref type="formula" target="#formula_7">4</ref>)</p><formula xml:id="formula_7">Sim (A, B ) = CS( A , B ) = A • B A × B = N i =1 w a i × w b i N i =1 w a 2 i × N i =1 w 2 b i (<label>4</label></formula><formula xml:id="formula_8">)</formula><p>where w a i and w b i are respectively the tf-idf weights of the terms a i and b i in the bags of words A and B , respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Search-based software library recommendation</head><p>This section describes our approach that uses SBSE techniques to find and recommend useful third-party software libraries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Framework of the approach</head><p>The proposed approach, LibFinder , is expected to be used with systems that are already implemented. The goal is to keep the developers updated with potentially useful libraries during the maintenance and evolution of their systems, especially with the exponentially growing number of software libraries in open-source repositories. LibFinder , is based on two main assumptions for a library could be potentially useful for a given software project ( i ) if it has been commonly used by the crowd with one or more libraries that the project is currently using, and ( ii ) if it uses identical or similar identifiers, i.e., belongs to the same application domain and thereby implements similar functionalities.</p><p>In order to realize an approach that meets the requirements stated above, we combine SBSE with MSR techniques. Instead of manually deriving a set of useful library for a software system with a variety of application domains, dedicated search algorithms are employed based on a given set of objectives and constraints. In fact, SBSE techniques allow us to address multi-objective problems as they aim to find the Pareto-optimal set of solutions, as opposed to trying to obtain a single optimal solution. For the library recommendation problem, this would mean that we are interested in a set of solutions where all objectives are compensated and optimized instead of being combined into a single metric, which may not achieve optimality <ref type="bibr" target="#b30">[30]</ref> .</p><p>The overall framework of LibFinder is depicted in Fig. <ref type="figure" target="#fig_2">2</ref> . Our framework consists of two important steps: (1) data extraction and processing, and (2) data exploration and search process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1.">Step1: data extraction and processing</head><p>This step consists of collecting the necessary data for our recommendation system including systems and library dependencies. We first collected a large set of Java projects and software libraries from GitHub and Maven, respectively (c.f., Section 5.2.1 ).</p><p>System and library dependency. To mine the current usage of these libraries for our linked-usage metrics, our approach is based on pom.xml files that define explicitly all the project dependencies with external libraries. To this end, we developed a specific tool (PomWalker<ref type="foot" target="#foot_6">9</ref> ) to automatically extract these dependency information from all versions of POM files in a project repository. Fig. <ref type="figure">3</ref> shows an xml snippet of the POM file from the CRest<ref type="foot" target="#foot_7">10</ref> system under the CodeGist project repository. The snippet shows the details including the groupId, artefactId, version , etc. of the system as well as the information about all external libraries the system depends on including the library groupId, artefactId and version .</p><p>Identifier-based semantic similarity . To calculate the semantic similarity, we extracted all identifiers for both libraries and systems. For library identifier extraction, as we deal with jar files, i.e., binary code, we used the asm<ref type="foot" target="#foot_8">11</ref> library to compile and resolve fully qualified identifier names. A library is regarded as a set of package, class and method names defined in the library. In the case of system identifier extraction, as we deal with systems source code directly, we used the JavaParser<ref type="foot" target="#foot_9">12</ref> library to facilitate identifiers extraction for AST generation without compilation. Note that all identifiers related to import and invoke external libraries were excluded during the system's identifiers extraction process.</p><p>After identifiers extraction, we performed a lexical analysis to pre-process all the extracted identifiers. Our lexical analysis consists of the four following steps:</p><p>1. Tokenization . All extracted identifiers are tokenized using a camel case splitter where each identifier is broken down into tokens/terms based on commonly used coding standards. 2. Filtering . We use a stop word list to cut-off and filter out all common English words<ref type="foot" target="#foot_10">13</ref> (e.g., and, the, to ) and reserved words (e.g., static, string, class ) from the extracted tokens. Typically, these words are irrelevant to the code concept. Such words carry a very low information value and can affect the semantic similarity process negatively as they have no direct relation to the application domain <ref type="bibr" target="#b32">[32]</ref> . 3. Lemmatization . This is a morphological process that transforms each word to its basic form, also called lemma. This process aims at reducing a word to its basic form in order to group together the different inflected forms of a basic word so they can be analyzed as a same word. Hence, different forms of words that may have similar meanings are grouped together and handled as identical word. For example, the verb 'to walk' may appear as 'walk', 'walked', 'walks', 'walking'. The base form, 'walk' is then the lemma of all these words. To do so, we use Stanford's CoreNLP 14 to find the base forms of all extracted words. 4. Vocabulary expansion . To enhance the effectiveness of the semantic similarity calculation, our approach utilizes WordNet 15 , a widely used lexical database that groups words into sets of cognitive synonyms (synsets), each representing a distinct concept. We use WordNet to enrich and add more informative vocabulary to the extracted bag of words for each library and system. For instance, the word customer might be used with different synonyms (e.g., client, purchaser , etc.), but pertaining to a common domain concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2.">Step2: data exploration and search process</head><p>The collected data from Maven and Github repositories along with all the processed identifiers represents a very large dataset. To facilitate exploring these data, we stored them within a single local data model, so that accessing them becomes easier and faster. Fig. <ref type="figure" target="#fig_0">4</ref> depicts the used data model. A repository consists of a set of systems. Each system depends on set of libraries that are defined through a pom file. Each system and each library in the dataset has its vocabulary which consists of a set of terms. A term can have a lemma and a set of synonyms. Formally, let S = { s 1 , s 2 , ...s n } denote the set of n systems and L = { l 1 , l 2 , ...l m } denote the set of m libraries. Let R ⊂ S × L denote relation that is defined in the pair of one system and one library. The relation R assumes that s i R l j is valid if the system s i depends on the library l j . The relation l j R s i means the library l j is used by the system s i . The inverse of the relation R is denoted by R -1 and l j R -1 s i is the same as s i R l j . Let S 1 a subset of S let R ( S 1 ) denote the set of those libraries that are dependent on all systems in S 1 . Similarly, a subset R -1 (L 1 ) denotes the set of systems that use all the libraries in L 1 .</p><p>14 nlp.stanford.edu/software/corenlp.shtml . 15 wordnet.princeton.edu .</p><p>To explore our data model, efficient search techniques are needed. Instead of manually searching for common clients of a particular library and compare the used vocabulary in a particular scenario, dedicated search algorithms can be employed to do so based on a given set of objectives and constraints. One way to efficiently explore this huge search space (collected libraries, their client systems, and the extracted vocabulary, etc.), is to apply dedicated SBSE techniques. Hence, SBSE has proven to be efficient technique in solving several software engineering problems where the number of potential solutions is very large and even infinite <ref type="bibr" target="#b22">[22]</ref> .</p><p>The next section describes in more details how SBSE techniques are adopted for this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">NSGA-II adaptation</head><p>Complex decision problems with multiple variables and large search spaces, similarly to this, are well-matched to SBSE, which has proven good performance to provide decision support in several software engineering problems <ref type="bibr" target="#b22">[22]</ref> . Our approach adopts SBSE <ref type="bibr" target="#b19">[19]</ref> , as it provides best practice to formulate software engineering problems in terms of ( i ) computational search algorithm, ( ii ) solution representation, ( iii ) fitness function, ( iv ) change operators, and so on. In the following we describe our SBSE formulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1.">Search algorithm</head><p>As a search method, we employed a widely used multiobjective evolutionary algorithm (MOEA) namely NSGA-II <ref type="bibr" target="#b21">[21]</ref> . NSGA-II tries to ensure diversity to avoid the situation where populations have been filled only with dominating solutions (because of the elitism mechanism, i.e., best solutions are preserved).</p><p>Identifying a Pareto front is useful as the software engineer can use the frontier to make a well-informed decision that balances the trade-offs between the different objectives. In our context, one could select recommended libraries achieving the highest semantic similarity, i.e., implementing similar functionality, the highest linked-usage, the lowest recommendation set size, or a compromise among these objectives. Using Pareto optimality, we can plot the set of solutions found to be non-dominating. In the case where there are three objectives, such as ours, this leads to a three dimensional Pareto surface where the developer can go through and make his decision (c.f., Section 5.4 ).</p><p>Please cite this article as: A. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2.">Solution representation</head><p>A solution in general consists of a number of (decision) variables that are optimized by the respective SBSE algorithm, a number of constraints that need to be fulfilled in order for the solution to be valid, and a number of objective values, one for each of the objective dimensions evaluated by the defined fitness function.</p><p>Candidate solutions for our problem are encoded as chromosomes of length n , where each gene represents a candidate thirdparty library. The length n of a chromosome corresponds to the number of classes in the input software system for which we want to recommend relevant libraries. Note that each class could be assigned either a candidate library or a "NONE" element, i.e., no library is recommended for this specific class. Fig. <ref type="figure" target="#fig_1">5</ref> represents an example of a chromosome that consists of eight recommended libraries. The figure can be interpreted as follows: the library httpclient is recommended for the class C1 , the library bcel is recommended for the classes C2 and C3 , log4j is rec-ommended for the class C4 , and guava is recommended for the classes C5 , C6 , C7 and C8 .</p><p>Additionally, a solution candidate may be subjected to a number of constraints in order for the solution to be valid. Depending on the algorithm, invalid solutions may be filtered out completely or may receive a low ranking in relation to the magnitude of the constraint violation. In our approach, each candidate solution should fulfill the two following constraints:</p><p>1. A candidate library for a class should be different from the ones already used by that class. To check this constraint, we are based on the GroupId (i.e., domain name), without considering the library version. Note that an already used library by a system could be recommended for new classes that are not using it.   mantic similarity. Indeed, having similar libraries in a recommendation set does not add value from the developers' perspective as the recommendations will seem redundant and it takes longer for developers to explore <ref type="bibr" target="#b25">[25]</ref> . Moreover, based on recent studies <ref type="bibr" target="#b33">[33]</ref> , some libraries are potentially copies of other libraries, which might lead to undesirable redundancies, security vulnerabilities, and license violations. This constraint assumes that two libraries are similar if the Jaccard similarity between their identifiers is equals or higher than 0.8. Thus, if a class uses log4j , this constraint will prevent LibFinder from recommending commons-logging .</p><p>Ranking. The recommended libraries are then ranked according to their frequency count in the chromosome. The more the number of classes for which a library is recommended, the more the library is useful for the system. For instance, for the chromosome depicted in Fig. <ref type="figure" target="#fig_1">5</ref> , libraries can be ranked as follows: (1) guava , (2) bcel , (3) httpclient and log4j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3.">Objective functions</head><p>The quality of each candidate solution is defined by a fitness function that evaluates multiple objective and constraint dimensions. Each objective dimension refers to a specific value that should be either minimized or maximized for a solution to be considered "better" than another solution. In our approach, we optimize the following three objectives:</p><p>1. Maximize library linked-usage (LU): Let L a candidate solution, i.e., chromosome, that consists of a set of libraries L = { l 1 , ..., l n } for a given system S that currently uses a set of libraries L S = { l s 1 , ..., l s m } . The linked usage is calculated as follows:</p><formula xml:id="formula_9">LU (L ) = n i =1 m j=1 linked-usage (l s j , l i ) × 1 m × 1 n (<label>5</label></formula><formula xml:id="formula_10">)</formula><p>where the function linked-usage (l s j , l i ) is given by Eq. (3) . </p><formula xml:id="formula_11">SS(L ) = n i =1 Sim (c i , l i ) × 1 n (<label>6</label></formula><formula xml:id="formula_12">)</formula><p>where the function Sim ( c i , l i ) calculates semantic similarity between a class c i and a library l i as described in Eq. ( <ref type="formula" target="#formula_7">4</ref>) , of course after identifiers tokenization, filtering, lemmatization and vocabulary expansion (c.f., Section 4.1.1 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Minimize the recommendation set size (RSS):</head><p>This objective function aims at reducing the number of recommended libraries. Although the number of libraries in our solution representation is propositional to the number of classes in a system, we aim at reducing the number of different libraries in our recommendation set. This objective function is motivated by two reasons. First, we start from the assumption that, typically, developers are unlikely to go through a large recommendation set. Second, adopting a large set of libraries is a costly and errorprone task as it requires an extensive effort from the developer. Indeed, our goal is to get the most from a small set of relevant library recommendations. Formally, let L a candidate solution that consists of a set of libraries L = { l 1 , ..., l n } , then RSS is given by the following function:</p><formula xml:id="formula_13">RSS(L ) = n i =1</formula><p>Unique (l i ) <ref type="bibr" target="#b6">(7)</ref> where the function Unique ( l i ) returns 1 if the library l i is distinct from the previous i -1 libraries in L , 0 otherwise.</p><p>The search process is then guided by these three objective functions where LU and SS are to maximize, while RSS is to be minimized.</p><p>Please cite this article as: A. <ref type="bibr">Ouni</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4.">Genetic operators</head><p>Population-based search algorithms deploy crossover and mutation operators to improve the fitness of the solutions in the population in each iteration (the initial population is completely random). Change operators such as crossover and mutation aim to drive the search towards near-optimal solutions.</p><p>The crossover operator is responsible for creating new solutions based on already existing ones, e.g., re-combining solutions into ones. In our adaptation, we use a single, random cut-point crossover to construct offspring solutions. It starts by selecting and splitting at random two-parent solutions. Then crossover creates two child solutions by putting, for the first child, the first part of the first parent with the second part of the second parent, and vice versa for the second child. An example of crossover is depicted in Fig. <ref type="figure">6</ref> .</p><p>The mutation operator is used to introduce slight, random changes into candidate solutions. This guides the algorithm into areas of the search space that would not be reachable through recombination alone and avoids the convergence of the population towards a few elite solutions. With library recommendation, we use a mutation operator that picks at random one or more genes (i.e., libraries) from their chromosome and replaces them by other ones from our set of libraries extracted from Maven Central Repository (including the "NONE" element) as shown is Fig. <ref type="figure">7</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Evaluation</head><p>This section first presents experiment design including: (1) research questions required to be addressed, (2) evaluation methods and metrics, and (3) the datasets used in our experiments. Moreover, we also describe the inferential statistical methods used for our experiments and the algorithms parameters tuning and setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Research questions</head><p>We design our experiments to address five research questions:</p><p>• RQ1 (Sanity check): How does the proposed approach performs, in exploring the search space, compared to random search and other existing search algorithms? • RQ2 (Accuracy): How accurate is our proposed approach in recommending libraries to client software systems? • RQ3 (Impact of library usage history and semantic similarity): What is the contribution of each of library usage history and semantic similarity heuristics on the overall performance of LibFinder ?</p><p>• RQ4 (State-of-the-art comparison): How does LibFinder comparing to existing library recommendation approaches, LibRec <ref type="bibr" target="#b8">[9]</ref> ? • RQ5 (Usefulness): Is LibFinder useful for software developers in a real-world setting?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Experimental design</head><p>We evaluate our approach from two perspectives. First, we evaluate our approach from SBSE perspective by following Harman's guidelines <ref type="bibr" target="#b19">[19]</ref> . Then, we evaluate our approach from recommendation system perspective <ref type="bibr" target="#b25">[25]</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1.">Dataset</head><p>To evaluate the feasibility of our approach on real world scenarios, we carried out an empirical study on real-world Open Source Software (OSS) projects. As we described in Section 4.1.1 , our study is based on dataset collected from two popular code repositories Github and Maven. Since github is host to varying projects, to ensure validity of quality github projects, we performed the following filtering on the dataset:</p><p>• Size . We only included java projects that had more than 10 0 0 commits. • Forks . We only include projects that are unique and not forks of other projects. • Maven dependent project . Our projects only include projects that employ the maven build process (use pom.xml configuration file).</p><p>Each github repository may contain multiple projects, each which may comprise of several systems. Each of these systems are dependent on a set of maven libraries, that are defined in a pom.xml file within the project.</p><p>For client libraries, we selected the latest release of the library at that period of time. In the beginning we started with 40,936 dependent libraries. However, to remove noise, we filtered out libraries having less than 50 identifiers. This removed specialized libraries that we assume will not be a useful recommendation for other systems. Our dataset resulted in 6083 different maven libraries extracted from unique 32,760 client systems (from 4305 repositories) from Github.</p><p>The dataset is a snapshot of the projects procured as of 15th January 2015. As described in Table <ref type="table" target="#tab_1">1</ref> and 2 , our dataset is very diversified as it includes a multitude of libraries and software systems from different application domains and different sizes. We found in our dataset, that the average number of used libraries per system is 10. <ref type="bibr" target="#b56">56</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2.">Evaluation method and metrics</head><p>To evaluate our approach, we have performed a ten-fold cross validation on our dataset. The basic idea is to randomly split the data into ten equal-sized parts. Each fold consists of a training data (nine parts) and a test data (the remaining part), then train the recommendation system on the training data and evaluate the recommendations using the test data. Note that only client systems are split into ten parts of size 3276 each.</p><p>To answer RQ1 , we compare our NSGA-II formulation against random search (RS) <ref type="bibr" target="#b34">[34]</ref> from two perspectives (1) search algorithm performance, and (2) recommendation system performance, i.e., the performance in solving the problem in hands. The goal is to make sure that there is a need for an intelligent method to explore our search space. Indeed, it is important to compare our search technique to random search, that is if an intelligent search method fails to outperform random search, then the proposed formulation is not adequate <ref type="bibr" target="#b19">[19]</ref> . In addition, to justify the adoption of NSGA-II, we compared our approach against two other popular search algorithms namely MOEA/D <ref type="bibr" target="#b35">[35]</ref> and IBEA <ref type="bibr" target="#b36">[36]</ref> . RQ1 is a sanity check and standard 'baseline' question asked in any attempt at an SBSE formulation <ref type="bibr" target="#b19">[19]</ref> .</p><p>For the search algorithm performance, we provide a quantitative assessment of the performance of each search algorithm in terms of search space exploration. Unlike mono-objective search algorithms, multi-objective evolutionary algorithms return as output a set of non-dominated (also called Pareto optimal ) solutions obtained so far during the search process. To this end, we employ three common performance indicators for evaluating multiobjective optimization algorithms, namely Hypervolume, Spread and Generational Distance <ref type="bibr" target="#b37">[37]</ref> .</p><p>• Hypervolume (HV) : calculates the proportion of the volume covered by the non-dominated solution set returned by the algorithm. A higher HV value means better performance, as it indicates solutions closer to the optimal Pareto front. The most interesting features of this indicator are its Pareto dominance compliance and its ability to capture both convergence and diversity <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b37">37]</ref> . • Spread ( ) : measures the distribution of solutions into a given front. The idea behind the spread indicator is to evaluate diversity among non-dominated solutions. An ideal distribution has zero value for this metric when the solutions are uniformly distributed. An algorithm that achieves a smaller value for Spread can get a better diverse set of non-dominated solutions <ref type="bibr" target="#b37">[37]</ref> . • Generational distance (GD) : computes the average distance between the set of solutions, S , from the algorithm measured and the reference front RF (also called reference set). The distance between S and RF in an n objective space is computed as the average n-dimensional Euclidean distance between each point in S and its nearest neighbouring point in RF . GD is a value representing how "far" S is from RS (an error measure) <ref type="bibr" target="#b38">[38]</ref> .</p><p>The reference front refers to the set of non-dominated solutions found by the union of all algorithms compared <ref type="bibr" target="#b39">[39]</ref> For further details about the formulation of these performance indicators, interested readers could refer to <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b37">37]</ref> and <ref type="bibr" target="#b38">[38]</ref> . Although Hypervolume, Spread and Generational distance are widely used performance indicators when comparing multi-objective algorithms, they ensure the effectiveness of LibFinder as a recommendation system by providing a reasonably diversified set of recommendations.</p><p>For the performance in solving the problem in hands, i.e., finding relevant library recommendations, we used the top-k accuracy, precision and recall on historical datasets. These metrics are commonly used for evaluating recommendation systems in software engineering <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b40">40]</ref> . Library ranking is based on the frequency count a library in the recommendation list as described in Section 4.2.2 . We conduct a 10-fold cross validation by randomly splitting our datasets D (c.f. Section 5.2.1 ) into 10 equal parts of size n each. For each fold, we run our approach using a part P x ∈ D , while training from the 9 other parts P T where P T = D \ { P x } .</p><p>For each system S i ∈ P x , we randomly drop half of the set of its currently used libraries L . Let L d ⊂ L the subset of dropped libraries where</p><formula xml:id="formula_14">| L d | = | L | 2 .</formula><p>LibFinder will then try to retrieve the dropped libraries in its recommendation set.</p><p>• Top-k accuracy of our recommendation for a part P x is calculated as follows.</p><p>Top -k accuracy (P</p><formula xml:id="formula_15">x ) = n -1 i =0 isF ound(S i , l ∈ L d ) | P x | × 100%<label>(8)</label></formula><p>where the function isFound ( S i , l ∈ L d ) returns 1 if at least one dropped library l ∈ L d is part of the returned recommendation set, and returns 0 otherwise. For instance, a top-10 accuracy value of 75% indicates that for 75% of the systems, at least one correct dropped library was returned in the top 10 results. The overall accuracy of our approach corresponds to the average accuracy of the 10 folds. • Top-k precision is calculated from the number of libraries that are either dropped or non-dropped contained in the recommendation set or not. The ground truth is the set of dropped libraries. All possible scores can be arranged in a contingency table (also called the confusion matrix ) (see Table <ref type="table" target="#tab_9">3</ref> ). Once these scores are defined, precision can be calculated. Precision corresponds to true positive accuracy and is calculated as the ratio of recommended libraries that are dropped over the total number of recommended libraries as described in Eq. ( <ref type="formula">9</ref>) .</p><p>Top -k precision = T P T P + F P (9)</p><p>• Top-k recall is calculated similarly to precision from the contingency table (  are dropped over the total number of dropped libraries as described in Eq. <ref type="bibr" target="#b9">(10)</ref> .</p><p>Top -k recall = T P T P + F N <ref type="bibr" target="#b9">(10)</ref> We thus used accuracy, precision and recall to compare the performance of NSGA-II against IBEA, MOEA/D and RS with top-10 recommendations.</p><p>To answer RQ2 , we evaluated LibFinder using our three evaluation measure defined above, accuracy, precision and recall. To better investigate the behavior of LibFinder , we conduct the experiment with different k values 1, 2, 4, 6, 8 and 10.</p><p>To answer RQ3 , we assess the effect of our two heuristics for a library to be useful of a client application if ( i ) if it has been commonly used by the crowd with one or more libraries that the project is currently using, and ( ii ) it uses similar identifiers, i.e., implements similar functionalities. We thus investigate the potential of combining both heuristics formulated respectively through the objective functions libraries linked-usage and semantic similarity. To this end, we assess the accuracy, precision and recall results while excluding 1) LU objective function, and 2) SS objective function from LibFinder . If our approach is demonstrated to outperform each individual heuristic, then we can claim that our formulation is appropriate. To this end, we used NSGA-II with same adaptation described in Section 4.2 to investigate each combination LU with RSS and SS with RSS objectives functions.</p><p>To answer RQ4 , we compare our approach with a recent stateof-art approach called LibRec <ref type="bibr" target="#b8">[9]</ref> . LibRec is library recommendation approach that combines association rule mining and collaborative filtering. The association rule mining component recommends libraries based on library usage history. The collaborative filtering component recommends libraries based on those that are used by other similar projects. However, the library content is not considered. To the best of our knowledge, this is the only existing approach for library recommendation. To conduct a comparative study, we replicated the LibRec on the same collected dataset (c.f., Section 5.2.1 ) using the same metrics top-k accuracy, precision and recall .</p><p>To answer RQ5 , we conducted a qualitative evaluation to better evaluate LibFinder with developers in practice. Indeed, it is important to qualitatively evaluate the relevance and usefulness of the recommended libraries from developer's perspective. To this end, we performed a qualitative evaluation with two large industrial projects provided by our industrial partner, the Ford Motor Company as described in Table <ref type="table" target="#tab_11">4</ref> . The first project is a marketing return on investment tool, called MROI , used by the marketing department of Ford to predict the sales of cars based on the demand, dealers' information, advertisements, etc. The tool can collect, analyze and synthesize a variety of data types and sources related to customers and dealers. It was implemented over a period of more than eight years and frequently changed to add and remove new/redundant features. The second project is a Java-based software system, namely JDI , that helps the Ford Motor Company to create the best schedule of orders from the dealers based on thousands of business constraints. This system is also used by Ford Motor Company to improve their vehicles sales by selecting the right vehicle configuration to match the expectations of their customers. JDI is highly structured and software developers have developed several versions of it at Ford over the past 10 years. Due to the importance of the application and the high number of updates performed on both systems, it is critical to ensure that they reuse and adopt high quality software libraries so to reduce the time required by developers to introduce new features in the future and maintain high quality software.</p><p>Our experiment is based on a survey to collect the feedback of Ford developers about LibFinder 's recommendations. One of the advantages of this industrial validation is the participation of the original/current developers of a system in the evaluation of the recommended libraries. The experiment is conducted as follows.</p><p>We executed LibFinder on each of JDI-Ford and DROI-Ford using our library dataset (cf. Section 5.2.1 ) and selected the top 10 recommended libraries. Thereafter, the software engineers from Ford were asked to manually evaluate each of the recommended libraries by answering the following question:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Is the recommended library useful for the implementation of your system?</head><p>For each library, the participants were asked to assign a score using a five-point Likert scale <ref type="bibr" target="#b41">[41]</ref> to express their level of agreement: 1: Not useful at all ; 2: some what useful ; 3: Useful ; and 4: Very useful ; and 5: Extremely useful . Furthermore, the developers where asked to comment on their ratings by an additional (optional) question "If so, are you willing to adopt this library in your code? " Subjects. Our study involved 8 industrial developers from the Ford Motor Company. Prior the study, the participants were invited to fill a pre-questionnaire about their experience, with Java programming, software library reuse and their experience with the subject systems. The eight subjects claimed they are familiar with Java programming, software maintenance activities with an experience ranging from 8 to 17 years. All claimed to frequently using third-party software libraries in their projects. The eight participants were selected based on having similar development skills, their motivations to participate in the survey and their availability. We organized the participants into two equal groups, each consists of four developers. The first group contains developers who are part of the development team of JDI , while the second group consists of developers who are current developers of the DROI system, and three of them are already part of the original developers' team.</p><p>The first group evaluated the recommendations for JDI , while the second group assessed the DROI system. The survey is completed anonymously thus ensuring the participants confidentiality.</p><p>In a first meeting with the participants, we explained the overall purpose of the study, without giving any details, concerning the libraries and the method used for the recommendation. Following, we gave to each participant a document that contained the following information (a) each recommended libraries, (b) a brief description of the main features of the library and its website url and Maven link, and (c) the list of classes for which the library is recommended. In a second meeting with each of the developers, we collected the documents and we analyzed the developers' feedback.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3.">Inferential statistical test methods used</head><p>Due to the stochastic nature of the used algorithms, they may produce slightly different results when applied to the same problem instance over different runs. To cope with this stochastic nature, the use of a rigorous statistical testing is essential to provide support to the conclusions derived from analyzing such data <ref type="bibr" target="#b42">[42]</ref> . To this end, we used the Wilcoxon Signed Rank test in a pairwise fashion <ref type="bibr" target="#b43">[43]</ref> in order to detect significant performance differences between the algorithms under comparison. The Wilcoxon test does not require that the data sets follow a normal distribution since it operates on values ranks instead of operating on the values themselves. We set the confidence limit, α, at 0.05. In these settings, Please cite this article as: A. <ref type="bibr">Ouni</ref>  each experiment is repeated 30 times, for each algorithm and for each fold. The obtained results are subsequently statistically analyzed with the aim to compare our NSGA-II approach to MOEA/D, IBEA, as well as random search (RS). While Wilcoxon Signed Rank test allows verifying whether the results are statistically different or not, it does not give any idea about the difference magnitude. To this end, we assess the effect size based on Cohen's d <ref type="bibr" target="#b43">[43]</ref> . The effect size is considered: (1) small if 0.2 ≤ d &lt; 0.5, (2) medium if 0.5 ≤ d &lt; 0.8, or (3) high if d ≥ 0.8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4.">Parameter tuning and setting</head><p>An important aspect for metaheuristic search algorithms lies in the parameters tuning and selection, which is necessary to ensure not only fair comparison, but also for potential replication. The initial population/solution of NSGA-II, MOEA/D, IBEA, and RS are completely random. The stopping criterion is when the maximum number of fitness evaluations, set to 350,0 0 0, is reached. After several trial runs of the simulation, the parameter values of the four algorithms are fixed to 100 solutions per population and 3500 iterations. There are no general rules to determine these parameters, and thus, we set the combination of parameter values by trial-anderror method, which is commonly used in the SBSE community <ref type="bibr" target="#b44">[44,</ref><ref type="bibr" target="#b45">45]</ref> .</p><p>For the variation operators, we set crossover probability at 0.9 and a mutation one at 0.4. We used a high mutation rate since we are employing an elitist schema with diverse library contents and co-usage. In fact, as noted by Cohen <ref type="bibr" target="#b43">[43]</ref> , elitism may encourage premature convergence to occur, e.g., reaching the last iteration with solutions having high LU and SS , but belongs to only one application domain. For instance, returning all recommended libraries related to xml parsers, which seems redundant and do not add value from the users perspectives. In order to avoid such a problem, in each generation, we emphasize the diversity of the population by means of the high mutation rate.</p><p>Note that, while for RQ1, we compare our resulted Pareto solutions of each algorithm, for RQs 2-5, we need only one solution for our automated evaluation. As NSGA-II returns a set of optimal solutions instead of single one, the developer can choose one of them according to his preference; however at least for our evaluation as we seek a fair comparison, we need to automatically pick up one single solution from the Pareto front and then compare it with Li-bRec. To address this issue, we proposed a technique that aims at automatically selecting the nearest solution to a 'reference' point from the Pareto front that represents the desired values of the objective function. Ideally, this reference point has the optimum values of each objective function, i.e., a score of 1 for the linked-usage (LU), 1 for the semantic similarity (SS), and 1 for the recommendation set size (RSS), after normalization within the interval [0,1] (c.f. Fig. <ref type="figure" target="#fig_6">12</ref> ). Our recommended solution, RecSol , corresponds to the nearest point p i from the Pareto front PF to the 'reference' point in terms of Euclidean distance. RecSol is calculated as follows:</p><formula xml:id="formula_16">RecSol = min ∀ p i ∈ PF (1 -LU (p i )) 2 + (1 -SS(p i )) 2 + (1 -RSS(p i )) 2 (11)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Results</head><p>In this section, we present the results of our empirical evaluation with respect to our research questions RQs 1-4 set out in Section 5.1 .</p><p>Results for RQ1. For RQ1, we compared NSGA-II against RS, MOEA/D, and IBEA, using the same objective functions, solution representation, and change operators. We describe the obtained results in terms of Hypervolume (HV), Spread ( ), Generational Distance (GD), Accuracy@10, Precision@10 and Recall@10.</p><p>Fig. <ref type="figure">8</ref> and Table <ref type="table">5</ref> present the results of the significance and effect size tests through 30 independent runs (3 runs for each fold) of each search algorithm. The higher the HV, accuracy@10, precision@10, recall@10, and the lower the and GD values, the more likely the recommendation results are better. We observe that RS results are generally poor, whereas MOEA/D, IBEA and NSGA-II obtain higher results. This provides evidence that there is a need for an intelligent search technique to provide better library recommendation results. Furthermore, for all six quality indicators (HV, , GD, accuracy, precision and recall), the Wilcoxon test results showed that NSGA-II achieves significantly better performance than MOEA/D, IBEA and RS with high effect size. This provides evidence that NSGA-II is effective in finding a well-converged and diversified set of Pareto-optimal solutions, i.e., recommended libraries. For the , it is also desired that a multi-objective evolutionary algorithm maintains a good spread of returned solutions. This gives more options to the developer on which library can be useful for his code. The Wilcoxon test results showed that for 17 out of 18 experiments (6 performance indicators, and 3 pairs of algorithms), the quality indicators achieved by NSGA-II were significantly better than those of random search with a Cohen effect size "high". Only for the Spread indicator, a Cohen effect size of "meduim" is achieved against MOEA/D.</p><p>As part of our sanity check, we also studied the extent to which the linked usage (LU) and semantic similarity objective (SS) functions are conflicting. Indeed, if the two objectives are not conflicting, i.e., correlated, then the problem should be formulated as a single objective optimization problem. Fig. <ref type="figure">9</ref> presents the results of studying the conflict relation between our LU and SS objectives. To this end, we execute a mono-objective GA maximizing one of the objectives and we study the behavior of the second objective by recording its values over 100 independent runs. From Fig. <ref type="figure">9</ref> a, we observe that the maximization of LU objective function does not cause any maximization or minimization of the SS objective function as their correlation is less than -0.21. Similar phenomenon could be seen in Fig. <ref type="figure">9</ref> b where a genetic algorithm was used to maximize the SS objective function while recording the behavior of the LU values. The observed correlation was less than 0.18. Based on this finding, we conjuncture that both LU and SS objectives are conflicting.</p><p>To sum up, we conclude that there is a compelling evidence that our multi-objective formulation using NSGA-II is adequate (this answers RQ1).</p><p>Results for RQ2. Table <ref type="table">6</ref> reports the top-1, top-2, top-4, top-6, top-8 and top-10 accuracy, recall and precision results for each of the ten folds obtained over 30 runs of LibFinder using NSGA-II.</p><p>For the top-k accuracy, we observe that LibFinder achieves the top-10 accuracy with 91.8% on average over the ten folds. The lowest top-10 accuracy score is 91.26% while the best one is 92.45%. This provides evidence that the accuracy of our approach is relatively stable over the ten folds for 30 independent runs. The average lowest accuracy score was in the top-1 with a score of 63.34%. This indicates that the chance to have at least one of the dropped libraries in the first rank is 0.63. Furthermore, we found in most cases where our approach fails in finding at least one of the dropped libraries that it relies on libraries from the same category, i.e., application domain. For instance, instead of recommending/retrieving the dropped library commons-logging , most of the cases our recommendation set includes the competitor logging library log4j . This may due to the popularity of log4j manifested by its growing usage score commons-logging and log4j</p><p>have respectively 3587 and 6254 usage scores in Maven Central Repository, as of November 24th, 2015. in Maven while having similar identifiers.</p><p>For precision and recall, LibFinder achieves also good results. Fig. <ref type="figure">8</ref>. Boxplots for the Hypervolume, Spread, Generational distance, accuracy@10, precision@10 and recall@10 performance indicators for NSGA-II, IBEA, MOEA/D and RS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 5</head><p>Statistical significance p-value ( α = 0 , 05 ) and effect size comparison results of NSGA-II against MOEA/D, IBEA and RS for the hypervolume, spread and generational distance, accuracy@10, precision@10 and recall@10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Metric</head><p>Stat. NSGA-II vs MOEA/D NSGA-II vs IBEA NSGA-II vs RS the ten folds. The highest precision score was achieved by the top-1 with a precision of 61.34%. From the recall side, LibFinder achieves better results with a top-10 recall of 68,13% and a top-1 recall of 47.94%. However, still precision and recall scores relatively lower than the accuracy. In fact, an important point to highlight is that these two metrics implies that recommended libraries that the system has not used (i.e., not in the dropped set) are uninteresting or useless. This assumption is not always appropriate in practice. That is, a system might not use a specific library for many reasons mainly when ( i ) the system's developers are not aware by such a library especially with the exponentially growing number of Please cite this article as: A.  available libraries in code repositories, or ( ii ) due to some resource constraints, e.g., budget limitations or deadline pressure.</p><p>To conclude, the obtained accuracy, precision and recall results indicate that leveraging a history of library usage from large source code repositories, with semantic similarity embodied in library identifiers can accurately recommend useful software libraries for client software systems.</p><p>Results for RQ3. Table <ref type="table" target="#tab_15">7</ref> reports the median accuracy, precision and recall values of each of linked-usage and semantic similarity heuristics with top-10 recommendations. The aim is to investigate the effectiveness of our two heuristics that are formulated through LU and SS objective functions and how well they work separately. As shown in the table, the linked-usage reaches an accuracy score of 63.1%, whereas the semantic similarity reaches 61.26%. However, using each heuristic separately is still far from the accuracy score of LibFinder (92%). Similarly, our approach reaches a precision score of 51% while having only 38% and 41% for each individual heuristic, linked usage and semantic similarity respectively. Recall is also following the same trend as the accuracy by a score of 68% for LibFinder while only 34% and 37% are achieved by linked usage and semantic similarity respectively. This finding suggests that both linked-usage and context similarity should be balanced together for an effective library recommendation.</p><p>Results for RQ4. Table <ref type="table">8</ref> presents the results of top-1, top-2, top-4, top-8 and top-10 accuracy, precision and recall of our approach, LibFinder , and a state-of-the-art approach Li-bRec,Thung2013librec. LibFinder achieves much better results for all 18 experiments (3 metrics and 6 top-k values). For instance, LibFinder achieves the top-10 with an accuracy of 92% and the top-1 with an accuracy of 63% while LibRec achieves only 73% and 12% for top-10 and top-1 respectively. Similarly for the precision and recall scores, LinFinder achieves the top-10 with 51% of precision and 68% of recall while only 23% of precision and 46% of recall was achieved by LibRec . This indicates that leveraging only a history of library usage is not enough for recommending relevant libraries. Thus a content-based recommendation should be balanced with usage history for better recommendations. In fact, a historybased approach (e.g., collaborative filtering method and association rule mining methods) provides recommendations for a user based on some unknown users who might have the same taste, while a content-based method provide recommendations based on what item's features the users need. Furthermore, unlike pure historybased approaches such as LibRec , new libraries can be recommended by a content-based method before being used by a substantial number of software projects. Indeed, LibRef is not able to recommend libraries to projects that only use a small number of li-Please cite this article as: A. <ref type="bibr">Ouni</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 8</head><p>Comparison results of our approach LibFinder against LibRec in terms of accuracy, precision and recall scores. braries or do not use any libraries at all. Thus, we believe that finding a trade-off between usage history and content-based method, such as LibFinder is a suitable way in formulation library recommendation problem. Results for RQ5. Fig. <ref type="figure" target="#fig_4">10</ref> reports the developer's rating results of the recommended libraries for the system JDI-Ford . For the ten recommended libraries, the developers ratings were ranging from 2.25 to 4.25. The highly rated library was Quartz , a richlyfeatured, enterprise-category library, that solves complex and small schedules, and get an average rating of 4.25 from the 4 developers. Features in Quartz include JTA clustering and transaction, real time management and monitoring. The four developers claimed that Quartz is a relevant library that could be useful for their current implementation, especially for creating and scheduling the orders with their dealers. On the other hand, while opencsv , a library for reading and writing CSV, was ranked lowest (an average of 2.25) as it only recommended for few classes that are not related to core functionalities in JDI-Ford . Indeed, developers found it not as useful comparing to their current in-house code.</p><p>Another recommended library was Joda-time which also get a high rating of 3.75 as it provides a quality replacement for the Java date and time classes with more useful and efficient features, relieving the developers from the burden of implementing date related features from scratch or based on the basic features provided by Java Development Kit (JDK).</p><p>Similarly, most recommended libraries for DROI-Ford get high ratings as sketched in Fig. <ref type="figure" target="#fig_5">11</ref> . The library mahout-math , a high per-formance scientific and technical computing data structures and methods library, gets the highest rating reaching 3.75 on average by the four developers. Same rating was obtained for Guava , a suite of core and expanded libraries that include utility classes, google's collections, io classes, and much much more useful utilities, get a high ranking of 3.75. However, slf4j , which a simple logging facade library which serves as a simple facade or abstraction for various logging frameworks, get the lowest score of 1.5 for this system. Overall, the eight developers who participated in the survey was generally satisfied with most recommended libraries based on their average score and their feedback. In both systems, we have two cases, opencsv for JDI-Ford and slf4j for DROI-Ford for which some of the developers was not satisfied and rated them by a score 1 ( Not useful at all ).</p><p>To better investigate the usefulness of the recommended libraries, we asked the eight developers if they are willing to consider adopting the libraries that they judged as 'useful' in the next releases of their system. Most of the developers (5 out of 8) expressed a high interest to adopt at least 4 libraries including mahout-math, quartz, guava , and pdfbox , for the coming releases. Their main reservations about such adoption are 1) the quality of the system after using the library and how to make sure that such a library will improve their code quality and 2) the time required to understand the entire library. Indeed, while Joda-time was highly rated, the developers did not express a high interest to adopt it for the short term as it might require additional effort s to incorporate several changes with several classes in the code. However, one Please cite this article as: A. <ref type="bibr">Ouni</ref>   of the developers claimed that they can keep their current code, but use Joda-time for the new features and changes in the next releases. Most of developers from both JDI-Ford and DROI-Ford claimed that this is a valuable reuse opportunity that they missed in the initial design of their system. Another situation highlighted in some comments was that most classes for which Joda-time and opencsv was recommended have very low change frequency during the last two years. Thus, developers would adopt libraries for more frequently changed and active classes in the project. This gives us interesting insights to incorporate the change frequency of classes in LibFinder to improve its recommendation usefulness in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Discussions</head><p>In this section, we further discuss related aspects to our approach including library selection in terms of trade-off, .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1.">Library selection</head><p>To help developers on selecting a library from the set of recommendations, LibFinder provides a user friendly manner to select recommended libraries through 3D visualizations of the Pareto front, as shown in Fig. <ref type="figure" target="#fig_6">12</ref> . This visualization shows the trade offs between the three objectives linked-usage, semantic similarity, the recommendation set size. Each point in the Pareto surface in Fig. <ref type="figure" target="#fig_6">12</ref> b a recommended solution, each solution comprises a set of libraries that will be sorted according to the frequency of each library in the solution (c.f., Section 4.2.2 ).</p><p>The distributions of these recommended solutions on the Pareto from gives more insights. Hence, if a developer is interested in new emerging libraries that implement similar functionality to his system, then he should focus his attention on the back corner of the Pareto surface, i.e., similarity score. For the developer who seeks to reduce the library integration costs and patibility risks, he needs rather to focus on the top corner of the Pareto surface as it recommends libraries that are used with his current libraries, i.e., high linked-usage score. If the developer seeks to check a small set of recommended libraries, the he should focus on the left side of the Pareto surface, or the right side for a variety of recommended libraries, i.e., high RSS score, otherwise. If the developer seeks a kind of trade-off between all objectives, he should then focus his attention on the middle part of the Pareto surface. Hence, as the three objectives are conflicting, maximizing semantic similarity could be possible but with cost of scarifying by some linked-usage.</p><p>For instance, following our motivating example JVacation which is using only the mysql-connector-java library, the recommended solutions comprises { JCalendar, glazedlists, mail, cxf-api, jetty-http, berkeleydb, javaosc-core, webapp-runner }.</p><p>Most of them are likely to be useful for JVacation . For instance, JCalendar is likely to be good candidate as described in Section 2.4 . Glazedlists is an event-driven lists for dynamically filtered and sorted tables. It is typically co-used with mysql-connector-java to process the results of SQL queries.</p><p>In addition, mail can be useful for JVacation to directly contact customers, send invoices and so on. Berkeley is a high performance, transactional storage engine for Java applications.</p><p>This makes sense as JVacation is a database related software system. Other recommendations such as cxf-api , jetty-http and webapp-runner are more related to web servers, building and developing services.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.2.">Developer insights on third-party library recommendation</head><p>The decision to keep in house code or reuse third-party libraries could be a delicate decision to be made by the developer in her individual context. It is important to get some insights from a developer's perspective on the situations where it is useful to adopt a recommended third-party library. To this end, we conducted a think-aloud survey with 17 developers from Ford including the 8 developers who participated in our experiment conducted in RQ5. The participants were first asked to answer the following question:</p><p>When do you think it is appropriate to apply a recommended third-party library to your code? Fig. <ref type="figure" target="#fig_7">13</ref> shows the different answers collected from the survey. A total of 5 out of 17 developers (29%) answered that they would be interested in adopting a recommended library as replacement of buggy code. Four developers answered that if the overall quality of the system will be improved when the recommended library is adopted, then it is worth. Similarly, a total of four developers answered that they are willing to adopt a recommended library if it provides additional features that are useful for the implementation of their system, especially if their current solution is not extendible Please cite this article as: A. <ref type="bibr">Ouni</ref>    enough. Furthermore, three out of the 17 developers answered that they would adopt a library if it will support software migration to provide portable and reusable code. Some other answers were also related to the library popularity and its API stability/quality. Overall, all developers expressed a hight interest to adopt third-party libraries in their code for different motivations and reasons as described in Fig. <ref type="figure" target="#fig_7">13</ref> . This justifies the exponentially increasing trend in adopting third-party software libraries from open source repositories. These results have actionable insights. For example, it would be interesting to consider a profile-based library recommendation system to focus the recommendations on buggy classes, or smelly/low quality classes, or on some packages related to particular features that the developer is interested in.</p><p>Moreover, as a second part of the survey, we wanted to assess how realistic is our problem formulation for the library recommendation, i.e., do the three defined objective functions match the developers high-level expectations. Our second part of the survey consists of three questions about the meaningfulness of our objective functions. It consists of the three following questions:</p><p>• Q1. When searching for a relevant library, do you prefer to select/find libraries that are related/commonly used with your current adopted libraries? • Q2. When searching for a relevant library, do you prefer to select/find libraries that belong to the same application domain as your implemented features, e.g., have textual similarity? • Q3. When searching for a relevant library, do you look for a minimum number of libraries to adapt such as libraries relevant for multiple tasks/features to integrate?</p><p>Participants were asked to answer each of the three questions by following a five-point Likert scale to express their level of agreement: 1: Strongly disagree , 2: Disagree , 3: Neutral , 4: Agree , 5: Fully agree .</p><p>Fig. <ref type="figure" target="#fig_0">14</ref> reports the obtained results from the survey. On average, a score of 4.17 Q3, respectively. As shown in the figure, the ratings distribution is within the range 3-5 with a median of 4 for Q1 and Q3, and 5 for Q3. Indeed, since library recommendation is a subjective decision process, it is normal that not all the developers have the same opinion. Thus, it is important to study the level of agreement between developers. To address this issue, we evaluated the level of agreement using Fleiss's Kappa coefficient κ <ref type="bibr" target="#b46">[46]</ref> , which measures to what extent the developers agree when answering to the three questions about each of our defined objectives. The Kappa coefficient assessments is 0.63, which is characterized as "substantial agreement " by Landis and Koch <ref type="bibr" target="#b47">[47]</ref> . This obtained score makes us more confident that our defined objectives for library recommendation makes sense from software developer's perspective. However, this finding does not necessary mean that these three objectives are the only objectives that should be considered for library recommendation. Indeed, some of the developers suggested to involve library popularity and quality in the recommendation process. As part of our future work, we plan to personalize LibFinder with the defined objectives based on the developer's profile/preferences and make it a more interactive process to learn from the developer decision in which situations he accept or reject a recommended library. It is worth notice that LibFinder allows the developers to give more importance to one objective over the other objectives using the pareto visualization as described in Section 5.4.1 . This visualization supports to the developers to select their libraries based on their preferences between all objectives. Furthermore, LibFinder allows to easily remove or add new objectives to guide the search space based on the developer requirements/preferences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.3.">LibFinder scalability</head><p>It is important to assess the scalability of our approach, as scalability is widely considered as one of the key issues for software engineering research and development <ref type="bibr" target="#b48">[48]</ref> . Indeed, there is a pressing need for scalable solutions to Software Engineering problems. To evaluate the scalability of the performance of our approach for systems of increasing size, we report the results of LibFinder per system size in terms of number of classes. The scalability assessment of LibFinder is only concerned with the exploration and search process (Step 1 in Fig. <ref type="figure" target="#fig_2">2</ref> is not taken into account for the scalability). The results of the experiment are depicted in Fig. <ref type="figure" target="#fig_9">15</ref> . We noticed that when the size of the system increase, the CPU time is still relatively stable as it ranges from 24 s to 35 s for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 9</head><p>Standard deviation of the obtained accuracy@k, precision@k and recall@k results over the 10 folds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Top-k Standard deviation</head><p>Accuracy@k Precision@k Recall@k Top-1 systems with less than 200 classes up to systems with more than 2600 classes, receptively. We also noticed that accuracy, precision and recall are not significantly affected by the systems' size as it tends to be stable with a standard deviation score of 1.15, 073 and 1.23 respectively.</p><p>In fact, we expected that the CPU time will slightly increase when the system size increase as the solution size depends on the number of classes in the system (c.f., Section 4.2.2 . To further investigate this behavior we use the JVM Monitor 16 profiler for Java for tracking which operations are the most expensive. The results obtained from this profiling show that over 46% of the execution time is spent on finding new candidate libraries by evaluating our two constraints: ( i ) recommended libraries should be different than the ones used by the system, and ( ii ) recommended libraries should not be similar as described in Section 4.2.2 . These operations are executed when constructing initial solutions or during crossover and mutation operators. Consequently, execution time is slightly increased with larger solutions that require in turn more constraints to be checked. Overall, we can say that LibFinder is scalable with respect to system size since it provides high precision and recall values, and reasonable execution time.</p><p>Another important point to highlight is about to stability of LibFinder over different folds. Stable results over different folds reflect the suitability of both the data and the exploration technique based on NSGA-II. To this end, we studied the standard deviation of the obtained accuracy, precision and recall for the different topk results. The result for this experiment is shown in Table <ref type="table">9</ref> . We notice that the highest standard deviation of the accuracy score 16  was 1.53 with the accuracy@1, while the lowest score was 0.41 with the accuracy@10. Similarly precision and recall scores does not vary significantly as their standard deviation was lower than 1.32 and 1.98 respectively. This indicates that LibFinder is relatively stable over different systems as they was randomly split over the different folds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Threats to validity</head><p>Several factors can bias the validity of empirical studies. In this subsection, we elaborate on several factors that may threat the validity of our results.</p><p>Internal threats can be related to the stochastic nature of search algorithms employed <ref type="bibr" target="#b42">[42]</ref> . To mitigate this, we conducted nonparametric statistical testing. We used the Wilcoxon Signed Rank test <ref type="bibr" target="#b43">[43]</ref> over 30 independent runs with a 95% ( α &lt; 0.05) confidence level to test if significant differences exist between the measurements for different treatments along with Cohen effect size for measuring the difference magnitude. This test makes no assumption on the data distribution and is suitable for ordinal data. We are, thus, confident that the observed statistical relationships are significant. Other threats to internal validity refers to experimenter bias. Most of our experimental process is automated and randomized. Thus we believe there is little experimenter bias.</p><p>Construct threats to validity may arise from our evaluation metrics accuracy@k, precision@k and recall@k to measure the effectiveness of our approach. Although these metrics are well known measure that are widely used in evaluating recommendation systems is software engineering <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b49">49]</ref> , we believe that there is a little bias towards using these measures. That is, a common assumption when evaluating recommendation systems using such metrics is that items that the user has not selected are uninteresting, or useless, to other users <ref type="bibr" target="#b25">[25]</ref> . Hence, in the library recommendation problem, a system might not adopt a specific library for many reasons mainly if the system's developers are not aware by such a library especially with the exponentially growing number of available libraries in code repositories, or due to other constraints such as budget limitations or deadline pressure, etc. We are thus planning to further evaluate LibFinder with developers in an industrial setting. Another potential threat to validity can be related to extracted identifiers. In fact, identifiers in a system may be influenced by class names and method names from its dependent library. Usually library import statements involve identifiers (package/class names) from the original library, and similarly for method calls which involve method names from the library. The presence of library identifiers in the projects code might bias our semantic similarity measure to retrieve the removed library. In other words, the library dependency is removed, but some of the library identifiers are still in the projects code. To mitigate this potential threat to validity, we excluded all identifiers related to library import and invoke from the projects code.</p><p>Moreover, another possible threat could be related to the dependencies extraction from pom files. Having a dependency declared in the pom.xml does not necessary grantee that the project is actually using it (i.e., invoking it). To address this issue, we compiled and inspected a random set of over 300 projects using jcabi-aether<ref type="foot" target="#foot_11">17</ref> library and JavaCompiler (ver.1.6) eclipse compiler <ref type="foot" target="#foot_12">18</ref> to automatically log all loaded classes. In our effort, less than 4% of library dependencies are not used by their projects. The percentage is insignificant and we believe it does not affect the results of dependency analysis.</p><p>External threats to validity refers to the generalizability of our findings. We considered a large set of open-source Java projects collection from Github that use libraries from Maven. Although Maven is a large and popular tool for the development community, in practice only a subset of developers are based in Maven to help manage their build process. To mitigate this threat, we have tested LibFinder with 32,760 projects with different sizes and from different application domains. We are also planning to conduct an industrial evaluation of our recommendation system to assess its effect on code quality as well as developers productivity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related work</head><p>In recent years, there has been much interest in academia as well as in industry on providing tools to help developers on understanding and using library APIs. Most of the related work relies on library method recommendation and API usage patterns.</p><p>Library method recommendation. Heinemann et al. <ref type="bibr" target="#b14">[15]</ref> proposed an approach for recommending library methods using data mining for learning term-method associations based on identifiers similarity, similarly to our approach. Rascal <ref type="bibr" target="#b50">[50]</ref> uses collaborative filtering to suggest API methods based on a set of already employed methods within a class. Similarly, Javawock,tsunoda2005javawock uses same technique to recommend API classes instead of methods. Thung et al. <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b16">16]</ref> have proposed a technique for recommending API methods based on textual description of feature requests and method history usage. While most of existing approaches suppose that developer has already find his library and he needs support on how to use it, our approach recommends whole library. LibRec <ref type="bibr" target="#b8">[9]</ref> is the approach most related to ours. Li-bRec uses association rule mining and collaborative filtering on historic software artefacts to determine commonly used together libraries. The main limitation of LibRec is that a library is regarded as a black box where recommendations are based on how other client systems previously use it. Consequently, the proposed approach was not able to recommend libraries to projects that only use a small number of libraries or do not use any libraries at all. Unlike LibRec , our approach opts a content-based recommendation combined with library usage history. As shown in our empirical evaluation, effective library recommendation should be driven, most importantly, by the content of the library. Furthermore, our approach is based on a larger dataset of 32,760 client systems, while LibRec uses only 500.</p><p>API usage patterns. Several approaches have been proposed to mine API usage patterns to help developers on using their library APIs. Most of them propose temporal <ref type="bibr" target="#b17">[17]</ref> , unordered <ref type="bibr" target="#b51">[51,</ref><ref type="bibr" target="#b52">52]</ref> and sequential <ref type="bibr" target="#b53">[53,</ref><ref type="bibr" target="#b54">54]</ref> usage patterns, based on clients usage. For instance, MAPO <ref type="bibr" target="#b53">[53]</ref> mines API usage patterns from existing source code. The patterns are given by methods that are frequently called together and that follow certain sequential rules. We believe that these approaches would be complementary to ours, as they provide support on how to use the recommended libraries.</p><p>Use of code identifiers. Source code vocabulary has been widely used in several purposes in software engineering <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b55">[55]</ref><ref type="bibr" target="#b56">[56]</ref><ref type="bibr" target="#b57">[57]</ref><ref type="bibr" target="#b58">[58]</ref><ref type="bibr" target="#b59">[59]</ref><ref type="bibr" target="#b60">[60]</ref> . Bajracharya et al. <ref type="bibr" target="#b61">[61]</ref> used structural semantic indexing (SSI) to associate words to source code entities based on API usage similarities. Their goal is to improve the retrieval of API usage examples from code repositories. Mudablue <ref type="bibr" target="#b62">[62]</ref> is a tool that categorizes software systems based on their code identifiers. Ouni et al. <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b63">63]</ref> proposed a vocabulary-based approach to recommend refactoring in order to preserving the semantic coherence of the code based on the semantic information embodied in code identifiers.</p><p>Combining SBSE and MSR. Software practitioners and researchers are recognizing the benefits of SBSE and MSR techniques to support the maintenance and evolution of software systems, improve software design/reuse, and empirically validate novel ideas Please cite this article as: A. <ref type="bibr">Ouni</ref>  and techniques <ref type="bibr" target="#b22">[22]</ref><ref type="bibr" target="#b23">[23]</ref><ref type="bibr" target="#b24">[24]</ref> . In fact, there is recently an increase in the interactions between these two fields. Harman et al. <ref type="bibr" target="#b64">[64]</ref> used Genetic Improvement for Adaptive Software Engineering where genetic programming is used as a means of program improvement based on a dataset of code fragments collected from software repositories. The research area has come to be known as 'genetic improvement'. You et al. <ref type="bibr" target="#b65">[65]</ref> have proposed an SBSE approach to optimize non-functional properties of a system such as JIT compilation, and hardware dependent algorithm using libraries.</p><p>In the area of bug prediction, Canfora et al. <ref type="bibr" target="#b66">[66]</ref> used a multiobjective optimization approach, named MODEP, to train from 10 datasets from the PRedictOrModels In Software Engineering Software (PROMISE) repository. The proposed approach allows software engineers to choose predictors achieving a specific compromise between the number of likely defect-prone classes or the number of defects that the analysis would likely discover, and lines of code to be analysed/tested. Minku et al. <ref type="bibr" target="#b67">[67]</ref> formulated the problem of software effort estimation as a multiobjective learning problem to understand the trade-off among different performance measures. The conducted study was based on five data sets from the PROMISE repository.</p><p>Another software engineering problem where SBSE has been used to mine software repositories is software product lines (SPL) recommendation and configuration focusing on feature model selection <ref type="bibr" target="#b68">[68,</ref><ref type="bibr" target="#b69">69]</ref> . A Software Product Line represents a set of software products that share features in order to satisfy a specific market segment where a feature represents a functionality that is visible for the user. Sayyad et al. <ref type="bibr" target="#b70">[70]</ref> studied the use of search-based algorithms for SPL feature selection as a multi-objective problem. They make explicit the link between search based software engineering for requirements selection and search based optimization of choices pertaining to feature models. Guo et al. <ref type="bibr" target="#b71">[71,</ref><ref type="bibr" target="#b72">72]</ref> introduced a genetic algorithm to find SPL feature sets while considering the cost and value objective (value-per-unit-cost). Muller <ref type="bibr" target="#b73">[73]</ref> also formulated the choice of products to be built from an SPL as a cost-value trade off, using the simulated annealing algorithm to find suggested choices of features that would form products that balance these trade offs. They focus on differing customer segments (stakeholder groups), observing that not all such groups can necessary be satisfied by the products offered (due to budgetary constraints). Cruz et al. <ref type="bibr" target="#b74">[74]</ref> use a hybrid approach, which combines fuzzy inference systems and the well-known multi-objective genetic algorithm, NSGA-II,to help decision makers manage product lines by generating portfolios of products. These portfolios are based on user segments and the development cost of SPL products.</p><p>Indeed, we expect more adoption and unification of both SBSE and MSR techniques to solve several other software engineering problems in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion and future work</head><p>In this paper, we have introduced LibFinder , a novel approach for third-party library recommendation. LibFinder unifies SBSE and MSR techniques, by exploring a large dataset collected from library usage history and identifiers mined from code in large repositories. The goal is to prevent missed reuse opportunities during software maintenance and evolution, by attracting the attention of developers to potentially useful third-party libraries to their software systems. We empirically evaluated our approach, we mined the usage history of 6083 libraries and 32,760 client systems from Maven and Github repositories, respectively. The obtained results show that our approach is efficient in recommending useful libraries comparing to random search and two other popular search algorithms with more than 92% of accuracy, 51% of precision and 68% of recall with top-10 recommendations. Furthermore, we have shown that LibFinder is significantly better than a state-of-the-art tech-nique which is based on the usage history libraries. Furthermore, we evaluated the usefulness of our approach in practice through an empirical study on two industrial Java systems with developers. Results show that the top 10 recommended libraries was rated by the original developers with an average of 3.25 out of 5.</p><p>As part of our future work, we plan to conduct an industrial evaluation of LibFinder with developers to better understand the impact of adopting external libraries on the quality of their systems as well as their productivity. We also plan to consider more software artifacts from other popular code repositories to better validate and generalize our results. More importantly, we will extend LibFinder by formulating the library recommendation problem as an interactive optimization problem to integrate the developer in the loop when recommending libraries. Another interesting extension of LibFinder can be to consider the change history of a system, so that library recommendation can be addressed to classes that are actively changed and maintained by developers. Moreover, we are planning to integrate LibFinder as an Eclipse plugin and try to provide 'on-the-fly' recommendations in such a way that the developer will be automatically notified by relevant libraries while he is writing his code. Yet another direction is to consider the library version and the internal quality of the recommended library to ensure high quality software systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The data model of the collected dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Chromosome representation for a candidate solution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 .</head><label>2</label><figDesc>Maximize semantic similarity (SS): Let L a candidate solution that consists of a set of libraries L = { l 1 , ..., l n } for a given system S that contains n classes where S = { c 1 , ..., c n } . SS is calculated as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .Fig. 7 .</head><label>67</label><figDesc>Fig. 6. Crossover operator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Average developers ratings for the 10 recommended libraries by LibFinder for the system JDI-Ford.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Average developers ratings for the 10 recommended libraries by LibFinder for the system DROI-Ford.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Example of Pareto optimal solutions obtained by LibFinder for JVacation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 13 .</head><label>13</label><figDesc>Fig.<ref type="bibr" target="#b12">13</ref>. Answers to the question: when do you think it is appropriate to apply a recommended third-party library to your code?</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.</head><label></label><figDesc>Fig. Developers answers for the three questions Q1, Q2 and Q3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Scalability of LibFinder with respect to the systems size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>1 :</head><label>1</label><figDesc>Create an initial population P 0 2: Create an offspring population Q 0 3: t = 0 4: while stopping criteria not reached do</figDesc><table><row><cell>5:</cell><cell>R t = P t ∪ Q t</cell></row><row><cell>6:</cell><cell>F = fast-non-dominated-sort (R t )</cell></row></table><note><p>7:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 1</head><label>1</label><figDesc>Github dataset used in the experiment.</figDesc><table><row><cell>JID: INFSOF</cell><cell>ARTICLE IN PRESS</cell><cell>[m5G; December 2, 2016;19:13 ]</cell></row><row><cell></cell><cell>Dataset</cell><cell></cell></row><row><cell>Snapshot date</cell><cell>15th January 2015</cell><cell></cell></row><row><cell># of github repositories</cell><cell>4305</cell><cell></cell></row><row><cell># of github systems</cell><cell>32 ,760</cell><cell></cell></row><row><cell># of unique dependent libraries</cell><cell>6083</cell><cell></cell></row></table><note><p>while having an average number of 4729 identifiers Please cite this article as: A. Ouni et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 2</head><label>2</label><figDesc>Statistics of the maven library dataset size used in the experiment. Our dataset is available for future replications and to encourage future research in the field of automated library recommendation ( http://sel.ist.osaka-u.ac.jp/ ∼ ali/libRecommendation/ ).</figDesc><table><row><cell></cell><cell>Min</cell><cell>Mean</cell><cell>Median</cell><cell>Max</cell></row><row><cell># of dependent libraries per system</cell><cell>3.00</cell><cell>6.00</cell><cell>10.56</cell><cell>292.00</cell></row><row><cell># of maven identifiers per library</cell><cell>51.0</cell><cell>731.0</cell><cell>4729.0</cell><cell>74,080.0</cell></row><row><cell>per library.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 3</head><label>3</label><figDesc>Contingency table that accumulates the numbers of true/false positive/negative recommendations.</figDesc><table><row><cell></cell><cell>Dropped</cell><cell>Non-dropped</cell><cell>Total</cell></row><row><cell>Recommended</cell><cell>TP</cell><cell>FP</cell><cell>TP + FP</cell></row><row><cell>Non-recommended</cell><cell>FN</cell><cell>TN</cell><cell>FN + TN</cell></row><row><cell>Total</cell><cell>TP + FN</cell><cell>FP + TN</cell><cell>N</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell>JID: INFSOF</cell></row></table><note><p><p>. Recall in corresponds to true positive rate and is calculated as the ratio of recommended libraries that Please cite this article as: A. Ouni et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</p>ARTICLE IN PRESS</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 4</head><label>4</label><figDesc>Studied industrial systems.</figDesc><table><row><cell>System</cell><cell>Release</cell><cell>#Classes</cell><cell>#Libraries</cell><cell>KLOC</cell></row><row><cell>JDI-Ford</cell><cell>v5.8</cell><cell>638</cell><cell>11</cell><cell>247</cell></row><row><cell>DROI-Ford</cell><cell>v6.4</cell><cell>786</cell><cell>19</cell><cell>264</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head>Table 7</head><label>7</label><figDesc>Effect of each individual heuristic on the accuracy, precision and recall results with top-10 rank.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head></head><label></label><figDesc>et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</figDesc><table><row><cell>JID: INFSOF</cell><cell>ARTICLE IN PRESS</cell><cell>[m5G; December 2, 2016;19:13 ]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head></head><label></label><figDesc>et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</figDesc><table><row><cell>JID: INFSOF</cell><cell>ARTICLE IN PRESS</cell><cell>[m5G; December 2, 2016;19:13 ]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18"><head></head><label></label><figDesc>et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</figDesc><table><row><cell>JID: INFSOF</cell><cell>ARTICLE IN PRESS</cell><cell>[m5G; December 2, 2016;19:13 ]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_21"><head></head><label></label><figDesc>et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</figDesc><table><row><cell>JID: INFSOF</cell><cell>ARTICLE IN PRESS</cell><cell>[m5G; December 2, 2016;19:13 ]</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>http://sel.ist.osaka-u.ac.jp/ ∼ ali/libRecommendation/ . Please cite this article as: A. Ouni et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>http://sourceforge.net/projects/jvacation .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>http://dev.mysql.com/downloads/connector/j/ .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>http://toedter.com/jcalendar/ .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>http://search.maven.org .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>https://www.nuget.org . Please cite this article as: A. Ouni et al., Search-based software library recommendation using multi-objective optimization, Information and Software Technology (2016), http://dx.doi.org/10.1016/j.infsof.2016.11.007</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_6"><p>https://github.com/raux/PomWalker .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_7"><p>https://github.com/codegist/crest .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_8"><p>http://asm.ow2.org .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_9"><p>http://javaparser.github.io/javaparser/ .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_10"><p>http://www.textfixer.com/resources/common-english-words.txt .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_11"><p>Aether adapter for maven plugins, http://aether.jcabi.com/index.html , accessed 08-09-2016.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_12"><p>Javacompiler tool, http://docs.oracle.com/javase/7/docs/api/javax/tools/ JavaCompiler.CompilationTask.html , accessed 08-09-2016.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>The authors would like to thank all the particpants of our study. This work was supported by Japan Society for the Promotion of Science, Grant-in-Aid for Scientific Research (S) Collecting, Analyzing, and Evaluating Software Assets for Effective Reuse (Grant Number JP25220 0 03), and by the Ford-University of Michigan alliance Program.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ARTICLE IN PRESS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>JID: INFSOF</head><p>[m5G; <ref type="bibr">December 2, 2016;</ref><ref type="bibr">19:13 ]</ref> Fig. <ref type="figure">9</ref>. Relation study between the Linked Usage (LU) and Semantic Similarity (SS) objective functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 6</head><p>Obtained top-k accuracy, Precision and Recall median results for of the 10-fold cross-validation obtained through 30 independent runs of NSGA-II. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Software reuse</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Krueger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv. (CSUR)</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="131" to="183" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Effects of reuse on quality, productivity, and economics</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Lim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softw</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="23" to="30" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">Software Reuse: A Holistic Approach</title>
		<editor>
			<persName><forename type="first">E.-A</forename><surname>Karlsson</surname></persName>
		</editor>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>John Wiley &amp; Sons, Inc</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Effects of reuse on quality, productivity, and economics</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Lim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softw</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="23" to="30" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Seacord</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plakosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Lewis</surname></persName>
		</author>
		<title level="m">Modernizing Legacy Systems: Software Technologies, Engineering Process and Business Practices</title>
		<meeting><address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Refactoring java programs for flexible locking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schäfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sridharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dolby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tip</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd International Conference on Software Engineering (ICSE)</title>
		<meeting>the 33rd International Conference on Software Engineering (ICSE)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="71" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Refactoring java programs using concurrent libraries</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ishizaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Daijavad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nakatani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Parallel and Distributed Systems: Testing, Analysis, and Debugging (PADTAD)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="35" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Boehm</surname></persName>
		</author>
		<title level="m">Software Engineering Economics, 1st</title>
		<meeting><address><addrLine>Upper Saddle River, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall PTR</publisher>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automated library recommendation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Thung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">20th Working Conference on Reverse Engineering (WCRE)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="182" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Improving api usage through automatic detection of redundant code</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kawrykow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Robillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="111" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Code similarities beyond copy &amp; paste</title>
		<author>
			<persName><forename type="first">E</forename><surname>Juergens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Deissenboeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hummel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th European Conference on Software Maintenance and Reengineering (CSMR)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="78" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Trusting a library: a study of the latency to adopt the latest maven release</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Kula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>German</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ishio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="520" to="524" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Raemaekers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Deursen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Visser</surname></persName>
		</author>
		<title level="m">Semantic versioning versus breaking changes : A study of the maven repositor</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Automatic recommendation of api methods from feature requests</title>
		<author>
			<persName><forename type="first">F</forename><surname>Thung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM 28th International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="290" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Identifier-based context-dependent api method recommendation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Heinemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Herrmannsdoerfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hummel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th European Conference on Software Maintenance and Reengineering</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Search-based software library recommendation using multi-objective optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ouni</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.infsof.2016.11.007</idno>
		<ptr target="http://dx.doi.org/10.1016/j.infsof.2016.11.007" />
	</analytic>
	<monogr>
		<title level="m">ARTICLE IN PRESS JID: INFSOF</title>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="volume">19</biblScope>
		</imprint>
	</monogr>
	<note>Please cite this article as. m5G; December 2</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Searching connected api subgraph via text phrases</title>
		<author>
			<persName><forename type="first">W.-K</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering (FSE)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Temporal analysis of api usage concepts</title>
		<author>
			<persName><forename type="first">G</forename><surname>Uddin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Dagenais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Robillard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">34th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="804" to="814" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Javawock: a java class recommender system based on collaborative filtering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tsunoda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kakimoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ohsugi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Monden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-I</forename><surname>Matsumoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th International Conference on Software Engineering and Knowledge Engineering (SEKE)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="4" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Search-based software engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="833" to="839" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Not going to take this anymore: multi-objective overtime planning for software engineering projects</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ferrucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sarro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ternational Conference on Software Engineering (ICSE)</title>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="462" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A fast and elitist multiobjective genetic algorithm: Nsga-ii</title>
		<author>
			<persName><forename type="first">K</forename><surname>Deb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pratap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Meyarivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evolut. Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="182" to="197" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Mansouri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Search-based software engineering: trends, techniques and applications</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The road ahead for mining software repositories</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Frontiers of Software Maintenance (FoSM)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="48" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A survey and taxonomy of approaches for mining software repositories in the context of software evolution</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kagdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Collard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">I</forename><surname>Maletic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Softw. Maintenance Evolut.: Res. Pract</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="77" to="131" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Dimensions and metrics for evaluating recommendation systems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Avazpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pitakrat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Grunske</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grundy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recommendation Systems in Software Engineering</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="245" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A Mono-and Multi-objective Approach for Recommending Software Refactoring</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ouni</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
		<respStmt>
			<orgName>University of Montreal</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Who should review my code? a file location-based code-reviewer recommendation approach for modern code review</title>
		<author>
			<persName><forename type="first">T</forename><surname>Patanamon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chakkrit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">K</forename><surname>Raula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Norihiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hajimu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ken-Ichi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Toward the next generation of recommender systems: a survey of the state-of-the-art and possible extensions</title>
		<author>
			<persName><forename type="first">G</forename><surname>Adomavicius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tuzhilin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="734" to="749" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Ricci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rokach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shapira</surname></persName>
		</author>
		<title level="m">Introduction to Recommender Systems Handbook</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Multi-objective optimization using evolutionary algorithms</title>
		<author>
			<persName><forename type="first">K</forename><surname>Deb</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>John Wiley &amp; Sons</publisher>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Search-based refactoring: Towards semantics preservation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kessentini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sahraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Hamdi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th IEEE International Conference on Software Maintenance (ICSM)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="347" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schütze</surname></persName>
		</author>
		<title level="m">Introduction to information retrieval</title>
		<imprint>
			<publisher>Cambridge university press Cambridge</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Software ingredients: detection of third-party component reuse in java software release</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ishio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Kula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kanda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>German</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Working Conference on Mining Software Repositories (MSR)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>p. toappear</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Random search techniques for optimization problems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Karnopp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="111" to="121" />
			<date type="published" when="1963">1963</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Multiobjective optimization problems with complicated pareto sets, moea/d and nsga-ii</title>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evolut. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="284" to="302" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Indicator-based selection in multiobjective search, in: Parallel Problem Solving from Nature-PPSN VIII</title>
		<author>
			<persName><forename type="first">E</forename><surname>Zitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Künzli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="832" to="842" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Performance assessment of multiobjective optimizers: an analysis and review</title>
		<author>
			<persName><forename type="first">E</forename><surname>Zitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Laumanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Da Fonseca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evolut. Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="117" to="132" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">On measuring multiobjective evolutionary algorithm performance</title>
		<author>
			<persName><forename type="first">D</forename><surname>Van Veldhuizen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">B</forename><surname>Lamont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Congress on Evolutionary Computation (CEC)</title>
		<imprint>
			<date type="published" when="2000">20 0 0</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="204" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Knowles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Zitzler</surname></persName>
		</author>
		<title level="m">A tutorial on the performance assessment of stochastic multiobjective optimizers</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">216</biblScope>
			<biblScope unit="page">240</biblScope>
		</imprint>
	</monogr>
	<note>International Conference on Evolutionary Multi-Criterion Optimization</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Jannach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zanker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Felfernig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Friedrich</surname></persName>
		</author>
		<title level="m">Recommender Systems: An Introduction</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Questionnaire design, interviewing and attitude measurement</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chisnall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mark. Res. Soc</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="392" to="393" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A practical guide for using statistical tests to assess randomized algorithms in software engineering</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Briand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">rd International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<title level="m">Statistical Power Analysis for the Behavioral Sciences</title>
		<imprint>
			<publisher>Academic press</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">On parameter tuning in search based software engineering</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fraser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Search Based Software Engineering</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="33" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Parameter tuning for configuring and analyzing evolutionary algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Eiben</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Smit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Swarm and Evolut. Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="19" to="31" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Measuring nominal scale agreement among many raters</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Fleiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychol. Bull</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">378</biblScope>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">The measurement of observer agreement for categorical data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Landis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">G</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrics</title>
		<imprint>
			<biblScope unit="page" from="159" to="174" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">I</forename><surname>Sommerville</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Engineering</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="2001">2001</date>
			<publisher>Pearson Education Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">An approach to detecting duplicate bug reports using natural language and execution information</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anvik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="461" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Rascal: a recommender agent for agile reuse</title>
		<author>
			<persName><forename type="first">F</forename><surname>Mccarey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Ó</forename><surname>Cinnéide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kushmerick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell. Rev</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="253" to="276" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Mining multi-level api usage patterns</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mohamed Aymen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Omar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Houari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Analysis, Evolution, and Reengineering (SANER)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Pr-miner: automatically extracting implicit programming rules and detecting violations in large software code</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGSOFT Software Engineering Notes</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="306" to="315" />
			<date type="published" when="2005">2005</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Mapo: Mining and recommending api usage patterns</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming (ECOOP)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Berlin Heidelberg</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5653</biblScope>
			<biblScope unit="page" from="318" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Mining succinct and high--coverage api usage patterns from source code</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Working Conference on Mining Software Repositories (MSR)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="319" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Detecting similar software applications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grechanik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">34th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="364" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">On the naturalness of software</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hindle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gabel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">34th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="837" to="847" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Integrating software project resources using source code identifiers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Inozemtseva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Holmes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">36th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="400" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">What&apos;s in a name? A study of identifiers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lawrie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Morrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Feild</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Binkley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Program Comprehension (ICPC)</title>
		<meeting>the 14th International Conference on Program Comprehension (ICPC)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Search-based peer reviewers recommendation in modern code review</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Gaikovina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Software Maintenance and Evolution</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">SIM: an automated approach to improve web service interface modularization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Salem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Soui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Web Services (ICWS)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Leveraging usage similarity for effective retrieval of examples in code repositories</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Bajracharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ossher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Lopes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Mudablue: an automatic categorization system for open source repositories</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kawaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Matsushita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Softw</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="939" to="953" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Multi-criteria code refactoring using search-based software engineering: an industrial case study</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ouni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kessentini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sahraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Deb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">53</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Langdon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Petke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Moghadam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<title level="m">Genetic improvement for adaptive software engineering (keynote), in: 9th International Symposium on Software Engineering for Adaptive and Self-Managing Systems</title>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Amortised Optimisation of Non-functional Properties in Production Environments</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yoo</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="31" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Defect prediction as a multiobjective optimization problem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Canfora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Oliveto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Panichella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Panichella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Test., Verif. Reliab</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="426" to="459" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Software effort estimation as a multiobjective learning problem</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Minku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">32</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Search based software engineering for software product line engineering: a survey and directions for future work</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Langdon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Petke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">18th International Software Product Line Conference</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="5" to="18" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">A systematic mapping study of search-based software engineering for software product lines</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Lopez-Herrejon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Linsbauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Egyed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="33" to="51" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">On the value of user preferences in search-based software engineering: a case study in software product lines</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Sayyad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Menzies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ammar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="492" to="501" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">A genetic algorithm for optimized feature selection with resource constraints in software product lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Softw</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2208" to="2221" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title level="m" type="main">Formalizing feature selection problem in software product lines using 0-1 programming, in: Practical Applications of Intelligent Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="459" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Value-based portfolio optimization for software product lines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">15th International Software Product Line Conference (SPLC)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="15" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title level="m" type="main">Toward a hybrid approach to generate software product line portfolios</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Neto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Britto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rabelo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Ayala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Soares</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mota</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>IEEE Congress on Evolutionary Computation</publisher>
			<biblScope unit="page" from="2229" to="2236" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
