<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adding Trace Matching with Free Variables to AspectJ</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Chris</forename><surname>Allan</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Tools Group</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pavel</forename><surname>Avgustinov</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Tools Group</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Aske</forename><forename type="middle">Simon</forename><surname>Christensen</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">BRICS</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Laurie</forename><surname>Hendren</surname></persName>
							<affiliation key="aff2">
								<orgName type="laboratory">Sable Research Group University of Oxford University of Aarhus McGill University United Kingdom Denmark Montreal</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sascha</forename><surname>Kuzins</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Tools Group</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ondřej</forename><surname>Lhot Ák</surname></persName>
							<affiliation key="aff2">
								<orgName type="laboratory">Sable Research Group University of Oxford University of Aarhus McGill University United Kingdom Denmark Montreal</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Oege</forename><surname>De Moor</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Tools Group</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Damien</forename><surname>Sereni</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Tools Group</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ganesh</forename><surname>Sittampalam</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Tools Group</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Julian</forename><surname>Tibble</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Programming Tools Group</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<address>
									<settlement>San Diego</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adding Trace Matching with Free Variables to AspectJ</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">58FDB577866898E59ED2DD434D3E3A0E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features Languages</term>
					<term>Design</term>
					<term>Theory Program monitoring</term>
					<term>aspect-oriented programming</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An aspect observes the execution of a base program; when certain actions occur, the aspect runs some extra code of its own. In the AspectJ language, the observations that an aspect can make are confined to the current action: it is not possible to directly observe the history of a computation.</p><p>Recently, there have been several interesting proposals for new history-based language features, most notably by Douence et al. and by Walker and Viggers. In this paper, we present a new history-based language feature called tracematches that enables the programmer to trigger the execution of extra code by specifying a regular pattern of events in a computation trace. We have fully designed and implemented tracematches as a seamless extension of As-pectJ.</p><p>A key innovation in our tracematch approach is the introduction of free variables in the matching patterns. This enhancement enables a whole new class of applications in which events can be matched not only by the event kind, but also by the values associated with the free variables. We provide several examples of applications enabled by this feature.</p><p>After introducing and motivating the idea of tracematches via examples, we present a detailed semantics of our language design, and we derive an implementation from that semantics. The implementation has been realised as an extension of the abc compiler for AspectJ.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Aspect-oriented programming offers a new set of language features to increase modularity and separation of concerns. One could think of an aspect as a special kind of object that observes a base program: when certain patterns of actions happen in the base program, the aspect runs some extra code of its own. The actions that may be intercepted are called joinpoints, and the patterns are called pointcuts. The most popular implementation of these ideas is AspectJ <ref type="bibr" target="#b18">[18]</ref>, an extension of Java.</p><p>In AspectJ, pointcuts can only refer to the current program state, or more precisely, the current joinpoint, including an abstraction of the call stack. It is natural to explore a richer pointcut notation that refers to the whole history of a computation as a trace of the joinpoints encountered so far. Several such history-based approaches have recently been proposed. Walker and Viggers have introduced the idea of tracecuts as a history-based generalisation of pointcuts <ref type="bibr" target="#b31">[31]</ref>. Other history-based proposals have been put forward by Douence et al. <ref type="bibr" target="#b7">[7]</ref><ref type="bibr" target="#b8">[8]</ref><ref type="bibr">[9]</ref><ref type="bibr" target="#b10">[10]</ref>. <ref type="foot" target="#foot_0">1</ref>Inspired by these pioneering efforts, the present paper takes an important step forward by extending the trace patterns with free variables. This innovation, which we term tracematches, enables a whole new class of applications, which we illustrate in Section 2. The key point is that matches can be made not just based on the kind of events, but also on the values bound to free variables. Thus, a tracematch can be used to pick out a trace of events relevant to individual objects.</p><p>Our motivating examples in themselves help to settle a number of important language design decisions, and we discuss those decisions in Section 3. A major goal of our design was to achieve a seamless integration of tracematches into the existing AspectJ language.</p><p>Although our examples provide a general feeling for our new tracematch language feature, we felt that it was important to give a rigorous definition and to use this definition to produce a correct and sound implementation. We first define a reasonably obvious declarative semantics, then we give a non-trivial operational semantics that could be used to guide a reference implementation, and finally we prove that the declarative and operational semantics are equivalent. These two semantics and the equivalence proof are given in Section 4.</p><p>We feel that proceeding in this principled fashion is an important contribution of the paper, since despite the fact that the meaning of tracematches is intuitive and crystalclear, their implementation is quite subtle. The key problem to address is that tracematches must perform two interacting functions. First, tracematches filter the current trace so that they only match on symbols that are explicitly declared in a tracematch declaration. This is important because it means that the patterns don't need to be cluttered with irrelevant details and can focus on the events of interest. Second, tracematches must consistently bind variables across the whole match. This makes it easier to track the behaviour of individual objects in the pattern.</p><p>The declarative semantics makes these two notions of filtering and consistent binding precise, and serves to pin down exactly what behaviour we want. It is tricky to combine filtering and consistent binding in an implementation, however: intuitively, you only know what symbols to filter out once you have a binding for all the variables. In the implementation, you have to "guess" whether a symbol can be skipped and the operational semantics formalises that idea. In our experience it is very hard to get the implementation correct, and indeed, we got it wrong several times before we formally showed the equivalence of the declarative and operational semantics.</p><p>We have derived a concrete reference implementation from the operational semantics. Section 5 discusses some further implementation issues, in particular the choice of concrete representations for the main abstract data types. It is also here that we address the very important question of memory usage -a naive implementation of tracematches would suffer severe memory leaks. We also briefly discuss optimisations for tracematches in Section 6. The design has been fully implemented as an extension to the AspectBench Compiler abc <ref type="bibr" target="#b1">[1]</ref> for the AspectJ language.</p><p>Finally, in Section 7 we discuss in more detail how our design differs from the works cited above, and we conclude in Section 8.</p><p>In summary, this paper presents the following original contributions:</p><p>• An important generalisation of earlier proposals for history-based approaches. Our approach, tracematches, introduces the notion of free variables in trace patterns.</p><p>• A new class of applications of history-based advice, enabled by this generalisation.</p><p>• A careful review of the design decisions for tracematches, in the light of these applications.</p><p>• A seamless integration of tracematches into the existing AspectJ language.</p><p>• A declarative semantics of tracematches, as well as an operational semantics, and a proof of their equivalence.</p><p>• A reference implementation that is derived from the operational semantics.</p><p>• A detailed discussion of implementation decisions, in particular regarding memory usage of compiled code.  In what follows, we assume the reader has a nodding acquaintance with AspectJ, and in fact most of our pure As-pectJ code should be self-explanatory. There is a wealth of textbooks available on the subject, including <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b24">24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">TRACEMATCHES</head><p>Traditional aspects allow programmers to define advicepieces of code that are run when the current program execution state (or 'joinpoint') meets some specified criteria. Tracematches extend this so that the program's entire execution history (or trace) can be examined to determine when the advice should run. The program's trace is modelled as a sequence of entries and exits from standard AOP joinpoints. To wit, the following aspect (in standard AspectJ) prints out a formatted version of a program trace. An enter event occurs before every joinpoint, and upon its completion we have an exit event. System . e r r . p r i n t l n ( " e n t e r : "+ 4 thisJoinPoint ) ; System . e r r . p r i n t l n ( " e x i t : "+ A tracematch defines a pattern and a code block to be run when the current trace matches that pattern. The grammar for a tracematch is shown in Figure <ref type="figure" target="#fig_0">1</ref>. Each tracematch consists of three parts: the declaration of one or more symbols (events of interest), a pattern involving those symbols, and a piece of code to be executed. A match occurs when a suffix of the current program trace, when restricted to the symbols declared in the tracematch, is a word in the regular language specified by the pattern. Here is a very simple example of a tracematch: { System . out . p r i n t l n ( " f g ! " ) ; } 8 } Line 1 is the tracematch header, which defines any tracematch variables (none in this case). Next, on lines 2-3, we define two symbols. The symbol f matches enter events on joinpoints that match the pointcut call( * f (..)). Similarly, the symbol g matches exit events on joinpoints that match the pointcut call( * g(..)). The regular expression on line 5 specifies that advice is triggered on traces that end with a call to f and g. Finally, line 7 gives the advice body to be executed.</p><p>In matching the pattern to the trace, any events in the trace that are not declared as symbols in the tracematch are ignored, and only events declared as symbols can trigger the match. Hence, this tracematch matches any exit from a call to g which was preceded by an enter of a call to f without any exits from calls to g in between.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Examples</head><p>We present a number of typical examples to demonstrate the practical uses of tracematches and to motivate our design. For each example, we describe a problem, give a straightforward solution in terms of tracematches, and show an equivalent solution in plain AspectJ to illustrate the advantages of the declarative tracematch approach. The various features of the tracematch extension will be explained alongside the examples as they are used.</p><p>Autosave. Consider an editor of some sort. We wish to add an 'autosave' feature that ensures a copy of the file is saved to disk after every five actions. This is easy to do with a tracematch. We begin by declaring two symbols: the first one for saves -either those explicitly initiated by the user, or automatic ones (lines 2-4). The other symbol is a call to execute a command -this is what we mean by an 'action' (lines 5-6). Whenever we see five consecutive actions (as specified by the regular pattern on line 8) the autosave() method is called (line 10). Here, the syntax ' <ref type="bibr" target="#b5">[5]</ref>' means exactly 5 repetitions of the same symbol. Any constantvalued expression can go here, so the actual value could be put into a static, final field for clarity.</p><p>This example illustrates an important design decision: all events are ignored, except those that match one of the explicitly declared symbols. The save symbol is included in the alphabet, but not in the regular expression, in order to prevent the expression from matching if the actions are interrupted by a save action. Now consider how the same effect is achieved in pure As-pectJ. We maintain a counter to keep track of the number of actions since the last save (line 2). Whenever a save event happens, the counter is reset to 0 (lines 4-7). Furthermore, upon the completion of each action, we increase the count by 1: if the total reaches 5, the autosave() method is called (lines 10-12). Note how the state of the matching process (the counter) is explicit in the AspectJ solution. In this example, that leads to only minor complications, but as we shall see below, often the burden of such state maintenance is much greater.</p><p>Previous program state can be exposed to tracematches by capturing variables in the symbol pointcuts. These variables are defined in the tracematch header (similarly to the definition of pointcut variables in ordinary pointcuts) and bound by the normal pointcut variable binding constructs in the symbol pointcuts. Unlike ordinary pointcuts, symbol pointcuts in tracematches do not define variables of their own. A tracematch variable is visible in the advice body and in the symbol pointcut by which it is bound. All tracematch variables that are used by the advice body must be bound by at least one symbol in any symbol string matching the pattern. This ensures that these variables have always been given a value whenever the body is executed.</p><p>Whenever the same tracematch variable is bound more than once in a trace (by the same symbol or by different symbols) the variable is not rebound to the new value. Rather, it is checked that the old and the new value are equal (in the sense of ==). If this is not the case, the new symbol is ignored for this particular trace. In other words, a program trace is defined to match the regular expression when there exists some set of values that can be consistently substituted for the pointcut variables in such a way that the program trace matches the defined expression. When more than one set of variable bindings exists that cause the expression to match, the code block is executed multiple times, once for every possible match. This allows the tracematch to match patterns in the behaviour of individual objects, for example to enforce conditions on the order in which the object's methods are called (by reporting runtime errors when the conditions are violated).</p><p>Contextual logging. Our next example is intended to illustrate the use of variable binding in tracematches. The application is to log the actions of the users of a database: whenever a user has logged in, we want to report the queries of that user. For simplicity, we consider a system where only one user is logged in at any time.</p><p>Variables that are to be bound in the pattern of a tracematch are declared in its header (line 1). Here there are two such variables, namely the user u and a query q. The first symbol we declare is the one that binds u, via a call to the login(..) method (lines 2-4). We also track logout actions, so that we stop logging when the user has finished (lines 5-6). Finally, we declare a symbol for query events (lines 7-9), and intercept the value of the query in variable q. The pattern is then very simple: we just look for queries that follow a login event (line 11). Whenever this matches a suffix of the current trace, we print an appropriate logging message that reports both the user u and the query q (lines 13-14). &amp;&amp; args ( q ) ; l o g i n query+ { System . out . p r i n t l n ( u + " made query " + q ) ; } } Note that it does not make sense to replace + in the above pattern (line 11) by * , for that would imply that the q parameter might not have been bound. It is a requirement (checked statically by the compiler) that any variable that is used inside the advice body must be bound by some symbol in all possible traces matched by the regular expression. Now consider how the same functionality is encoded in pure AspectJ. We need a boolean variable to keep track of whether a user has been logged in, and another variable to record the user (lines 2-3). (At a pinch, the two might be combined, as the user field is null precisely when the boolean field is f alse -but we find that less transparent.) Whenever the login() call succeeds, we set the boolean to true, and update the user field as well (lines 5-11). Corresponding updates are made upon a logout (lines <ref type="bibr" target="#b13">[13]</ref><ref type="bibr" target="#b14">[14]</ref><ref type="bibr" target="#b15">[15]</ref><ref type="bibr" target="#b16">[16]</ref><ref type="bibr" target="#b17">[17]</ref>. When a query happens, and a user is logged in, the logging message is output (lines <ref type="bibr" target="#b19">[19]</ref><ref type="bibr" target="#b20">[20]</ref><ref type="bibr" target="#b21">[21]</ref><ref type="bibr" target="#b22">[22]</ref><ref type="bibr" target="#b23">[23]</ref><ref type="bibr" target="#b24">[24]</ref><ref type="bibr" target="#b25">[25]</ref><ref type="bibr" target="#b26">[26]</ref>. Apart from being more verbose, this AspectJ solution is also less flexible than the one based on a tracematch. Suppose we wanted to extend this logging aspect to log the actions of multiple users who can be logged in at the same time. For the tracematch version, all we would have to do would be to extend the login, logout and query symbols to capture some unique information such as a session id (assuming this is made explicit in the base program). This would then tie the login and query events together by their shared session id, allowing the user from the login symbol to be available to the advice body. To add the same functionality to the AspectJ version, the variables would have to be replaced by mappings and the code changed accordingly.</p><p>Observer. This example demonstrates a way of implementing the well-known Observer design pattern. Here we have a set of Subject objects, which represent the state of some entity being modelled, and a set of Observer objects which are attached to a particular Subject and need to be notified in any changes to their Subject's state. The solutions below both provide a way of doing this without the Subject needing to be aware that it is being observed.</p><p>The tracematch based solution declares two events of interest, in lines 2-7: the creation of an observer o (where the subject s is passed as an argument), and updates to that same subject s. We then specify the sequence of events that will cause the view of the observer to be updated, on line 9. In words, we perform an observer update upon creation of the observer, and subsequently upon each update of the subject that follows the creation of the observer. Note how this example illustrates our use of variable bindings in patterns: it is the observer creation that binds variables s and o. The update symbol then only matches execution events with those same variable bindings.  A similar AspectJ solution is shown below. It needs to maintain a vector of observers for each subject. The association of the vector to each subject is achieved via a so-called intertype declaration on lines 2-3. This inserts a new field called observers into the Subject class (or, if it is an inter-face, into each implementor of that interface). When a new observer is constructed, we add it to the observers of subject s (line 8), and we also update its view (line 9). Then, whenever the subject is updated, we update each of its observers (lines <ref type="bibr" target="#b15">[15]</ref><ref type="bibr" target="#b16">[16]</ref><ref type="bibr" target="#b17">[17]</ref><ref type="bibr" target="#b18">[18]</ref><ref type="bibr" target="#b19">[19]</ref><ref type="bibr" target="#b20">[20]</ref>. A comparison of the AspectJ solution with our formulation in terms of tracematches highlights an important point, namely that in a tracematch, the advice is executed for all matching bindings. The iteration that is explicit in the AspectJ solution is implicit when using tracematches.  For brevity, we have chosen a minimal implementation of the observer pattern, but the use of tracematches also simplifies the more advanced formulation in <ref type="bibr" target="#b17">[17]</ref>. In that seminal paper, Hannemann and Kiczales demonstrate convincingly that many design patterns are more easily expressed in AspectJ than in Java. Here we present a further significant improvement over that work.</p><p>In addition to before and after, symbols can also be declared as around. An around symbol matches enter events of the corresponding joinpoints, just as before does. However, the advice body gets executed instead of the original joinpoint, rather than just before it.</p><p>There are certain restrictions on how around symbols can be used. We require that either all the events that could be the last in the matched sequence are of around type, or none are. This restriction is necessary as advice bodies for around advice are incompatible with the ones for before and after, for two reasons: first, around advice must return a value of the return type declared for the advice (declared just before the around keyword); second, similarly to ordinary around advice, around advice in tracematches can call the special method proceed() to invoke the original join point. We will say more about proceed() in Section 3.5. Additionally, we require that around symbols can only appear at the end of matched sequences, as there is no sensible meaning for around if there is no advice to be executed at the matched joinpoint.</p><p>Flyweight. We now consider the Flyweight design pattern.</p><p>The purpose of this pattern is to avoid a huge number of small objects being created. To achieve that, a pool of instances is maintained; where possible, each constructor call is intercepted and instead an object from the pool is returned. For simplicity we stipulate that objects of the Fly-Weight type that were created with the same argument to the constructor are considered equivalent. An implementation of the flyweight pattern thus requires that we cache the result of constructor calls, only creating one object for each different argument value.</p><p>The flyweight pattern has a natural description in terms of a tracematch. We look for the first object creation with a given argument; and after that, any constructor call with the same argument is intercepted. We therefore declare two symbols (lines 2-7). Note that the latter symbol is an instance of around. The advice body does not call proceed(), which means that the original constructor call is not performed. Instead, it just returns the value returned the last time the constructor was called with the same argument. (line 11).  We now consider an encoding of the flyweight pattern in pure AspectJ, as displayed below. Again this is a minor simplification of the code of Hannemann and Kiczales <ref type="bibr" target="#b17">[17]</ref>. It explicitly maintains a table of those objects that have previously been used as arguments to a flyweight constructor, and the associated object that was returned (lines 2-3). An IdentityHashMap is used for this to mimic the object identity behaviour of the tracematch version. Then, upon each constructor call (lines 6-7), we check whether a table entry exists for the given argument (line 9). If so, the corresponding object is returned (lines 10-11). Otherwise, a new object is created, and stored in the table before returning (lines 14-16).   The code using a tracematch is marginally shorter, but in our view that is not its main advantage. The true merit of the tracematch is that it directly states the programmer's intention, crisp and clear, without a need to encode the essential idea.</p><p>Safe iterators. Our next example concerns the safe use of iterators. It is usually the case that the data source that underlies an iterator may not be changed during the iteration process. It is fairly common to explicitly encode that behaviour in the implementation of iterators, by throwing an exception if an iterator is used after the collection has changed, but it would be nicer to specify it as a separate concern, once and for all.</p><p>There are three symbols of interest here: the creation of an iterator on a particular data source (lines 2-4), the next() operation on that same iterator (lines 5-7), and update operations on the given datasource (lines 8-10). Then, whenever we see a creation, followed by some iteration steps, one (or more) update(s) and then another iteration step, we know that an error has occurred. This is captured by the pattern on lines 12-13. In the AspectJ version, we keep track of the state of the DataSource explicitly, in a map from the DataSource to some unique object (lines 3-4). We then reallocate this object each time the state changes (line 30). For each Iterator object, we remember its associated DataSource (lines 5-6 and 13) and the state the DataSource was in upon the creation of the iterator (lines 7-8 and 14). If the DataSource has changed state since the iterator was created, the next() operation fails (lines <ref type="bibr" target="#b21">[21]</ref><ref type="bibr" target="#b22">[22]</ref><ref type="bibr" target="#b23">[23]</ref><ref type="bibr" target="#b24">[24]</ref>. Again, the intent is clearly visible in the tracematch solution, whereas the pure AspectJ solution is formulated in terms of how the constraint is actually implemented. Furthermore, this AspectJ implementation will cause severe memory leaks. Any DataSource and Iterator ever used will end up in the maps and not be garbage collected. For this example, this could be easily fixed by using weak references to ensure that mappings are removed from the maps when their keys are no longer in use. <ref type="foot" target="#foot_1">2</ref> A naïve tracematch implementation would of course suffer from the same problems, but in this case the compiler has the opportunity to analyze the specification and use weak maps wherever applicable. We will return to the issue of weak references in Section 5.</p><p>The AspectJ solution could be expressed a bit more simply (and without the memory leak problem) by using intertype declarations on the DataSource and Iterator classes. However, in order to inject intertype declarations, the AspectJ compiler must have access to modify these classes, either at compile time or by using a weaving class loader. Such access is typically not available for the Java standard library classes, so this proposed solution would not work with, for example, the standard collection classes. The tracematch implementation does not require weaving access to classes bound to tracematch variables, so in order to achieve as close to the same behaviour for the two solutions as possible, the hash map version was chosen.</p><p>Connection management. In our final example, we use an aspect to control the opening and closing of some form of 'connection', for example to a database system. For the sake of the example, we assume that a Connection class has three methods, open(), query() and close(). The query() method should only be called on a Connection that is in the open state. We assume that the open() and close() methods take some time to execute, so should not be called unnecessarily, but also that open connections require some overhead, so connections should not be left open and unused for large periods of time.</p><p>The aspects below allow users of the Connection class to ignore the open() and close() methods, and just assume that they will be opened and closed when needed. To achieve this, a closed connection is opened immediately before a query is called on it, and an open connection that has not been used 'recently' is closed. We define a connection not having been used recently to mean "there have been 5 calls to some logging API since its last use". This might not be a useful heuristic in a realistic setting, but it can be easily replaced by something more sophisticated, since it is encoded as a trace pattern.</p><p>The desired effect is achieved with two tracematches. The first is shown below. It declares symbols for opening, closing, querying, and creating a new connection (lines 2-12). The connection must be opened when we see the first query after a creation, or when we see that a query is performed immediately after a close. This is captured with the pattern on line 14, and it illustrates that all declared symbols must be matched: because open con is one of the symbols, the pattern rules out a situation where the connection is open already. The next step is to define a tracematch that closes a connection when it has been open too long. As said, our heuristic rule defining 'too long' is that there have been 5 logging calls since the last query. Declaring an explicit symbol for closing the connection (lines 2-4) guarantees that the connection has not been closed after the matching query event. This example hints at the need for a language mechanism to name symbols outside a particular tracematch, to allow the same symbol to be used in multiple tracematches. However, often the amount of repetition can be minimised by naming the relevant pointcut, and therefore we have decided (at least for the moment) against such a mechanism.</p><p>Let us now consider a similar solution in plain AspectJ (a much fuller discussion of this type of application can be found in section 7.3 of Laddad's textbook <ref type="bibr" target="#b20">[20]</ref>). To track the number of logs since the last query on each open connection, we have a map from Connections to Integers (lines 2-3). An invariant of the code is that any connection that is a key in this map is open, and all other connections are closed.</p><p>When a connection is opened, we record it in the age map and set its age to 0 (line 8). When a connection is closed, we remove it from the map (line 14). When a query is intercepted, we must open the connection if it is currently closed, and its age is then reset to zero (lines <ref type="bibr" target="#b20">[20]</ref><ref type="bibr" target="#b21">[21]</ref><ref type="bibr" target="#b22">[22]</ref>. Finally, whenever a log call happens, we iterate over the set of all connections (lines 26-39). For each connection, we increase its age, and if this pushes the age of a connection to 5, the connection is closed and removed from the map. It is interesting to contrast this code with our earlier formulation in terms of tracematches. There, the statement of the intended behaviour is purely declarative, and we do not need to create an explicit iteration. Instead, the iteration happens automatically, for each binding that results from matching the regular pattern to suffixes of the current trace. This is similar to the use of iteration in our earlier discussion of the observer pattern.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DESIGN CONSIDERATIONS</head><p>We now review the crucial design choices for tracematches. In particular, we contrast our decisions with alternatives, focussing on those cases where others have made a different choice. In doing so, it is our aim to give a rational account of our design, deferring a detailed comparison with related work till Section 7. As we shall demonstrate, all decisions were informed both by the examples in the preceding section, as well as the desire to have a clean semantics that admits an efficient implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definition of Traces</head><p>A trace is a sequence of events in the execution of a program. Our events are defined as entries and exits from joinpoints. In the tracematch declaration itself, we attach the standard AspectJ advice kinds before, after and around to symbol declarations. Analogously to ordinary advice, around is treated similarly to before for the purposes of matching but then executes in place of the matched joinpoint rather than before it.</p><p>An alternative way to define a trace might be to use joinpoints as events directly, which is similar to the way AspectJ defines the cflow pointcuts. This means thinking of joinpoints as nodes in a program execution tree (a generalisation of the dynamic call graph with nodes for all joinpoints, not just calls), and define the trace as the sequence of joinpoints that have been visited so far. However, joinpoints are not atomic events -in particular they can be nested inside each other. It follows that the ordering of events in the resulting trace depends on the definition of 'visited' that is used. Whether a parent or child node is visited first depends on whether the trace is defined in terms of a preorder or postorder traversal.</p><p>Our definition is more flexible than this alternative approach. The above scenario gives the trace 'before parent; before child; after child; after parent'. By writing appropriate patterns, the programmer can achieve the same effect as either a preorder or postorder traversal would have done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Class of Language Used to Describe Traces</head><p>Our trace patterns are described as regular expressions. The motivation for doing so is that regular expressions provide a concise, easily understood notation. Indeed, in typical use cases of tracematches, regular expressions offer just the right level of expressiveness. Furthermore, regular expressions lend themselves to static analyses: for richer formalisms, the question of language inclusion is typically undecidable, for example.</p><p>The only obvious alternative is to consider context-free language patterns instead. Most examples in the literature that motivate such a generalisation involve dependencies on balanced method calls and returns. However, in these cases, the call stack dependencies can often be described using cflow pointcuts. These pointcuts allow the programmer to assert that program execution is below one of a given set of joinpoints in the execution stack. Together with cflow pointcuts regular trace patterns achieve a high degree of expressiveness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Matching a Pattern to a Trace</head><p>An important design decision concerns the filtering of traces to the events of interest. We have decided to explicitly declare all "interesting" symbols, and restrict the trace to events that match one of these declared symbols. The pattern is then matched against this restricted trace. This decision avoids cluttering the pattern with spurious symbols for events that are irrelevant to the problem in hand. One subtle point is that we never discard the last event of a trace: this last event must match a declared symbol. This is to ensure that advice is only executed at the point a match occurs, and not at each ignored symbol thereafter.</p><p>One could consider defining the set of captured events implicitly as all events matched by symbols that occur in the regular expression (as opposed to all symbols defined in the tracematch). However, with this definition, it would not be possible to explicitly exclude certain events from the trace. If an event was included in the regular expression then by definition it could appear in some matched trace, and if it didn't appear then it would be completely ignored. As shown in the examples, being able to exclude events is highly useful.</p><p>The fact that all symbols for a tracematch must be declared within the tracematch declaration provides a form of encapsulation. Individual tracematches are isolated from each other, so introducing or changing one tracematch does not interfere with the matching of another, except for any changes to the program state or trace that the tracematch causes explicitly. This retains the independency achieved by normal AspectJ pointcuts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Binding Variables</head><p>The most prominent feature of our tracematch design is the handling of variable bindings in the symbol pointcuts: multiple occurrences of the same variable in the pattern must be bound to a single value that is consistent across all the occurrences.</p><p>To see the rationale for this fundamental decision, note that variable bindings in tracematches serve two important purposes:</p><p>• To give code in the advice body access to context values at the joinpoints matched by the tracematch symbols. This is similar to variable binding in ordinary advice.</p><p>• To allow the tracematch to match traces in the behaviour of individual objects or groups of objects, rather than just control-flow traces. This mechanism is vaguely related to per-clauses for ordinary aspects (in the sense that these too associate pointcuts with individual objects) but serves a quite different purpose, as it is binding together traces of events rather than merely selecting an aspect instance.</p><p>As long as a variable is only bound once in a trace, it is simply bound to the corresponding value. When a variable is bound more than once in the same trace (whether by the same symbol or by different symbols), there are a number of options for what the behaviour could be:</p><p>• Re-bind the variable, so that the value seen by the advice is the one bound most recently in the trace. This is similar to what is done for cflow pointcuts, where the values bound by the most closely enclosing joinpoint are the ones seen by the advice.</p><p>• Check for equality with the previous binding. The pointcut is extended with an implicit condition that the values bound must be the same as was previously bound to the same variables. If the value is different, the pointcut does not match, so the trace is rejected.</p><p>In this design, the first value that is bound to a variable in a given trace is the only possible value for that variable.</p><p>• Allow multiple sets of bindings for any given trace. For any given set of bindings, events that cause symbols to bind with different values are ignored in the same way as events that are not matched by any declared symbols.</p><p>The last option here is the only one that fulfils the second purpose above. By viewing the trace as a set of parallel, object-specific traces, the behaviour of individual objects can be easily captured by the tracematch. As witnessed by the examples in Section 2, this is highly useful. This mechanism can in most cases simulate the other two options mentioned above. To only capture the last binding of a variable, rewrite the regular expression so that only the last binding is part of the match. To check equality between bindings, bind the values to different variables and check their equality as an extra condition in the advice body.</p><p>In defining the equality of values above, we have used reference equality, corresponding to Java's == operator. One could consider whether it would be more appropriate to define equality by the equals() method instead. The distinction here is between tracking an object and tracking a value. However, "tracking a value" does not really make sense, since the fact that two objects are equal according the the equals() method does not in any way imply that these objects are related in the data flow of the program. As the examples clearly show, the tracking of particular object instances is very useful in capturing properties of the program data flow. Again, equality of values based on equals() can be checked by binding the values to different variables and checking their equality in the advice body.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Behaviour with multiple matches</head><p>The same pattern can match a single execution trace in multiple ways, producing different variable bindings for each match. Our decision is to execute the advice once for each of the variable bindings. A typical example where this feature proved crucial is that of the Observer pattern, where multiple Observers are notified upon a change in the Subject.</p><p>This decision was motivated by our desire to mimic the behaviour of multiple pieces of ordinary advice that apply to the same joinpoint. From this perspective, it is natural that the advice body is executed multiple times, once with each different set of bindings for the tracematch variables. It is possible that a trace can match the regular expression in two different ways, but result in the same values being bound. When this happens the advice is still executed just once for those particular values. It is the bound values that distinguish the traces.</p><p>It is not obvious how to define the order in which the advice for the different bindings are executed, as this involves the ordering of sets of values. One could consider using the structure of the way the trace was matched or the order in which the values were bound to define an ordering, but this would not give a unique ordering, since different values can be bound by identical traces, and the same values could be bound in several possible ways. This means that any given ordering is not particularly intuitive, since it would be based on some underlying mechanism which is not visible to the programmer. Ordering based solely on the actual values bound to the variables is not possible in general, since some values might not have a natural ordering. At least until more work is done on exploring implementations and applications, we have chosen not to define any particular ordering on the execution of tracematch advice.</p><p>Matters get more complicated when the final symbol is an around symbol. Similarly to ordinary around advice, around advice in tracematches can call the special method proceed() to invoke the original join point. If more than one trace matched at the same joinpoint, proceed() invokes the next match, and only during execution of the final match does proceed() invoke the original joinpoint. It is permissible for the advice body not to call proceed() at all, in which case the original join point is skipped and no more matches are executed. Similarly, if proceed() is called multiple times, the original joinpoint (or the following match) executes multiple times.</p><p>Normally, proceed() takes no arguments. A sometimes confusing feature of AspectJ is that the proceed() call can be given arguments which are used to replace the original value of variables bound by the pointcut. We provide an analogous feature in tracematches by the following mechanism. An around symbol can optionally declare a signature for proceed() by giving a list of tracematch variables after the around keyword (similarly to ordinary around advice but without the types). The actual values passed to proceed() then replace the values at the original join point to which the corresponding variables were bound. In the case of multiple matches, the following match sees the passed values as new values for the corresponding tracematch variables.</p><p>If any final symbols declare such a signature, all final symbols must give the same list of variables, all these variables must be bound by all of the around symbol pointcuts, and they must be bound by the same binding constructs. This ensures that these variables have the same values for all possible matches at a given joinpoint. Thus, if the advice always passes the parameters directly to proceed(), the behaviour is the same as if no variables were specified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Behaviour with multiple threads</head><p>So far, we have implicitly assumed that all programs to which tracematches are applied are single-threaded. We need to define how tracematches behave in the presence of multiple threads. There are at least two sensible behaviours that could be defined in this case: the first is to treat each thread like a separate program, and match the traces of each thread individually. The second is to create a single trace of the entire program, by interleaving the events of each thread. Our decision is to allow either behaviour, leaving the choice to the programmer.</p><p>The first possible behaviour, matching thread traces independently, is useful where a tracematch needs to detect patterns in control flow. Examples of this are to detect control flow patterns that are known to lead to error conditions, or to enforce rules such as "a thread should not use an object of type X until it first acquires a lock on it".</p><p>The second possible behaviour, interleaving thread traces, can be used when a tracematch needs to detect a pattern of events with reference to a particular object, for example to enforce typestate restrictions. Examples include "all Connection objects must be in an open state before being used" or "only one thread may have a lock on an object at a time".</p><p>Because both of these behaviours have important uses, we allow the programmer to select the desired behaviour. The default is to interleave events across threads, but we introduce a modifier, perthread, which can be added to a tracematch declaration to declare that the traces of each thread should be matched independently.</p><p>Both of these kinds of tracematches have their own sources of extra overhead compared to the single-threaded version. For the thread-local version, we have to keep track of the tracematch matching state per thread, using thread locals or For global tracematches, we need to make matching and tracematch state tracking code synchronized in order to ensure that atomic events are properly interleaved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SEMANTICS</head><p>We now pin down the meaning of tracematches so that it is possible to give a high-level description of their implementation. We first define the semantics in a declarative manner, and then refine this into a more operational semantics, geared towards defining a reference implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Roadmap</head><p>Before diving into the formalities, we first give a brief roadmap, motivating our formal decisions later on.</p><p>Declarative semantics. For a tracematch without variables, we match every suffix of the current trace against the pattern. In doing so, the trace is filtered, by ignoring all events that do not correspond to any of the declared symbols. The last event in the trace should, however, always correspond to a declared symbol: this is just the requirement that advice is executed immediately when a match occurs. These three ideas (suffixes, filtering, and last event declared) are the three key features of the declarative semantics.</p><p>To give a declarative meaning to a tracematch that has free variables, we read it as a template for all possible instantiations, where each of the variables has been replaced by a specific runtime value (there may be an infinite number of such instantiations). Each of these instantiations is a tracematch without variables, and we have already given a meaning to those.</p><p>To illustrate these points, consider the tracematch in Figure <ref type="figure" target="#fig_1">2</ref>. and the sequence of calls v.f(); v.h(); w.g(); w.f(); v.g();</p><p>To keep the example short and manageable, we assume that each of f , g and h has void return type and an empty body. A full trace of the above call sequence is shown in Figure <ref type="figure" target="#fig_24">3</ref>.</p><p>As described above, the above tracematch should be seen as a template for all possible instantiations assigning values to x. In this case it is clear that the only relevant values for x are x = v and x = w. Consider first the instantiation x = v. Then the events relating to v.h(), w.g() and w.f () are all filtered out, and the resulting trace is just [e1, e20] e1 enter: call(void FG.f()) on v e2 enter: execution(void FG.f()) on v e3 exit: execution(void FG.f()) on v e4 exit: call(void FG.f()) on v e5 enter: call(void FG.h()) on v e6 enter: execution(void FG.h()) on v e7 exit: execution(void FG.h()) on v e8 exit: call(void FG.h()) on v e9 enter: call(void FG.g()) on v e10 enter: execution(void FG.g()) on w e11 exit: execution(void FG.g()) on w e12 exit: call(void FG.g()) on w e13 enter: call(void FG.f()) on w e14 enter: execution(void FG.f()) on w e15 exit: execution(void FG.f()) on w e16 exit: call(void FG.f()) on w e17 enter: call(void FG.g()) on v e18 enter: execution(void FG.g()) on v e19 exit: execution(void FG.g()) on v e20 exit: call(void FG.g()) on v (labels given in Figure <ref type="figure" target="#fig_24">3</ref>). Now e1 matches the symbol f with x = v, while e20 matches the symbol g. Hence this matches the pattern f g, and the tracematch applies with binding x = v. Now consider the instantiation x = w. Then the only events in the trace that match one of the symbols f and g with x = w are e12 and e13. Hence the filtered trace is [e12, e13]. This trace does not match the pattern f g, and so the tracematch does not match with binding x = w. In fact, this also fails to match for another reason: the last event e20 of the trace is filtered out, while a tracematch only matches if the last event of the trace matches a declared symbol. Now suppose that we added one more symbol to the declarations in the above tracematch, namely 1 sym g2 a f t e r : c a l l ( * g ( . . ) ) ;</p><p>We leave the pattern unchanged, however. Consider the (only possible) binding x = v, as in the above example. The filtered trace from Figure <ref type="figure" target="#fig_24">3</ref> includes the same events as before (e1 and e20), but this time the exit event from w.g() (event e12) also matches g2. The filtered trace is therefore [e1, e12, e20]. This no longer matches the pattern f g, and now the tracematch does not match the trace, solely because we introduced a new declared symbol and therefore reduced the amount of filtering. The reader may wish to check for him/herself that the new tracematch would match the event sequence generated by v.f(); v.h(); w.f(); v.g();</p><p>The declarative semantics is formally defined in Section 4.2 (the definition of events, symbols and tracematches) and Section 4.3 (the definition of matching).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Operational semantics. The definition of tracematches with</head><p>free variables via all possible instantiations is attractive, because it is simple and it gives us an effective way of reasoning about tracematches. It does not give any guidance on their implementation, however.</p><p>Without variables, it is not difficult to see how an implementation might go. Alongside the base program, we run a finite automaton. This finite automaton recognises precisely the language of the regular expression, interspersed with events that do not match any of the declared symbols. Furthermore, construct the automaton to match t if some suffix of t matches the given pattern. Finally, we stipulate that only transitions labelled with a declared symbol can enter a final state. This way the automaton captures all three of the important elements of matching in the declarative definition (filtering, suffixes and last event declared).</p><p>While the base program is running, we keep a flag on each state of the automaton, to track whether the current trace moves the automaton into that state. Note that as the transitions are labelled by symbols, and an event can be matched by more than one symbol, the automaton can be in multiple states simultaneously (a new event causes the automaton to take all matching transitions).</p><p>To start with, the flags are set on the initial states of the automaton. Because every trace can be a prefix of an accepted trace, the flags on the initial states remain set to true at all times. Now when a new event e happens in the base program, we match it against each of the symbols, and make the corresponding changes to the flags: if there is a transition from s to s labelled with symbol a, if the flag on s is set to true, and if a matches the new event e, the flag on s is set to true. If no such transition to s exists, the flag on s is set to false. When a final state becomes reachable, advice is executed. Now how can this be modified to take free variables into account? We use the same automaton construction, but instead of boolean flags to indicate reachability, we use constraints. A constraint label on state s records any assumptions made in reaching s with the current trace. One may think of a constraint as a logical formula that combines assignments of values to variables (x = 1), as well as the negations of such expressions (y = 1). In the same way we updated the boolean flags on states, so one can also update the constraint labels. New equations of the form x = value are generated by AspectJ's pointcut matching.</p><p>To capture filtering of declared symbols on account of wrong variable bindings (for instance, filtering out e12 in the first example above), however, it is not enough to match only on declared symbols. We introduce a new symbol skip to capture events that are ignored in the matching (either because they match no declared symbol, or because of wrong variable bindings). The skip symbol matches exactly under the conditions that cause all declared symbols to fail to match. In particular, if an event is not matched by any declared symbol, then it is matched by skip. Also, if there exists one declared symbol that matches with variable binding x = value, then skip matches with binding x = value. This is the way negative bindings are entered into constraints.</p><p>There are thus two important ideas in the operational semantics: the use of constraints and the anything-but-adeclared-symbol skip. Together they allow us to do the filtering of events incrementally, without knowing the variable bindings in advance.</p><p>In Section 4.4, we make the above intuition precise, and we give a formal definition of skip. Then, in Section 4.5, a formal proof is presented that the declarative and operational semantics coincide. To avoid cluttering that proof, we shall already introduce constraints while discussing the declarative semantics in Sections 4.2 and 4.3. In Section 4.6, we spell out the incremental computation of the constraints that label the automaton states. Finally, in Section 4.7, all this is made concrete, by generating AspectJ code that directly implements the operational semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Events, Symbols and Tracematches</head><p>Events and Traces. An event occurs when a joinpoint is either entered or left. Accordingly, we define: event = {enter, exit} × joinpoint A trace is then simply a finite sequence of events. An example trace is shown in Figure <ref type="figure" target="#fig_24">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Constraints. We shall model variable bindings as constraints,</head><p>that is equations combined with the usual logical connectives. In particular, a constraint may be an equation between a variable and a runtime value, x = v, or an inequation, ¬(x = v). We write C for the set of all constraints. For a given tracematch, the relevant variables are those that are declared in its header.</p><p>Symbols. The symbols defined in a tracematch are just As-pectJ pointcuts. However, it will be convenient to abstract away from the precise details of matching AspectJ pointcuts to joinpoints. We will model symbols as functions from events to constraints:</p><formula xml:id="formula_0">symbol = event → constraint</formula><p>For a symbol a (a pointcut) and an event e, the constraint a(e) defines the assignments of values to the variables of a obtained when matching a to e. If the pointcut does not match, then a(e) = false.</p><p>For example, in the example tracematch shown in Figure <ref type="figure" target="#fig_1">2</ref> with the trace shown in Figure <ref type="figure" target="#fig_24">3</ref>, we have f (e1) = (x = v) and g(e12) = (x = w), while g(e1) = false and f (e20) = false (the symbols f and g are defined in Figure <ref type="figure" target="#fig_1">2</ref>).</p><p>We will assume that for any event e, if a variable x appears in the constraint a(e), then x is one of the variables declared in the tracematch. This is clearly satisfied by pointcut matching.</p><p>A symbol s is said to be a ground symbol if for any event e, s(e) is either true or false. A ground symbol can match or fail to match, but does not bind variables.</p><p>Tracematches. A tracematch is defined as a list of variables, a list of symbols, a pattern, and finally the body of the tracematch (code to execute when the pattern matches). The pattern is a regular expression over symbols. However, as we are only concerned with defining the semantics of matching here, we may ignore the body of the tracematch and define:</p><formula xml:id="formula_1">tracematch = variable set × symbol set × symbol regexp</formula><p>We will fix a tracematch tm = (F, A, P ) in what follows. Hence F is the set of free variables of tm, A is the set of defined symbols, and P the pattern.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Semantics of Tracematches</head><p>Valuations. A valuation is defined as a mapping from identifiers to runtime values, assigning values to each of the free variables of the tracematch:</p><formula xml:id="formula_2">valuation = F → value</formula><p>We define valuation on symbols as follows: the constraint resulting from matching σ(a) to an event e is obtained by applying the valuation σ to a(e): σ(a) = λe. σ(a(e))</p><p>In particular, as σ assigns a value to each variable occurring in a(e), σ(a(e)) is a simple truth value.</p><p>For example, recall that f (e1</p><formula xml:id="formula_3">) = (x = v). If σ = {x → v}, then (σ(f ))(e1) = (v = v) = true, while if σ = {x → w}, then (σ (f ))(e1) = (v = w) = false (provided v and w are distinct).</formula><p>Valuations are lifted to patterns (regular expressions of symbols) by applying the valuation to each symbol in the pattern (in place).</p><p>Matching a trace to a word. We define the match operator to take a sequence of symbols and a trace of events, and evaluate to the constraint that must be satisfied for the symbols to match the trace. If the number of symbols is the same as the number of events, the constraint is the conjunction of the constraints obtained by applying each symbol to the corresponding event. If the sequence of symbols and the trace of events are of different length, there can be no match, so the constraint is false. This can be written as: match( a1, . . . , an , e1, . . . , em ) = ¡ (∧i :</p><formula xml:id="formula_4">1 ≤ i ≤ n : ai(ei)) if n = m false otherwise</formula><p>Note that we use the notation (⊕x : P (x) : v) in lieu of its equivalent L P (x) v throughout. The constraint that must be satisfied to match a trace to a sequence of symbols is just the conjunction of all the individual constraints obtained by matching each event to each symbol. If every symbol ai is a ground symbol, the result is either true or false.</p><p>Filtering. Recall that any events that do not match any defined symbol in a tracematch are simply ignored when matching. To formalise this, we define the event set of a tracematch, and the restriction of a trace to this set.</p><p>The event set of a tracematch tm under a given valuation σ is defined to be the set Ω(tm, σ) of events that are matched by some defined symbol in tm, with variable bindings compatible with the valuation σ. Formally, we define:</p><formula xml:id="formula_5">Ω(tm, σ) = {e ∈ event | (∃a : a ∈ A : σ(a(e)) = true)}</formula><p>Finally, we write the trace obtained from t by removing any events not in a set S as t S.</p><p>We can now define the match of a sequence of symbols to a sequence of events relative to an alphabet S. This is the match of symbols to events, ignoring any events not in S. A minor complication is that we must ensure that the last event in the sequence lies in S. This ensures that events that are ignored do not cause the tracematch to match repeatedly. We therefore define:</p><formula xml:id="formula_6">match S (as, t) = (last t ∈ S) ∧ match(as, t S)</formula><p>The match of a pattern (regular expression over symbols) to a sequence of events, still relative to an alphabet, is the disjunction of the matches of all strings denoted by the pattern to the given sequence of events: matchS(p, t) = (∨as : as in the language of p : matchS(as, t))</p><p>The semantics of tracematches. The semantics of tracematches can now be defined as follows. A tracematch tm is modelled by a function</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[[tm]] : trace → valuation set</head><p>To wit, [[tm]](t) returns the set of valuations that cause tm to match some suffix of t. The body of tm will be executed exactly once for each such valuation.</p><p>Informally, the set of such valuations can be found as follows: replace the tracematch tm by the (possibly infinitely many) tracematches obtained by applying every possible valuation σ to tm. Each of these involve no variables and can be matched against a trace straightforwardly. The result [[tm]](t) is the set of valuations that cause tm to match (some suffix of) t.</p><p>This can be formalised as follows. Write u ≺ v to mean that u is a suffix of v. Then</p><formula xml:id="formula_7">[[tm]](t) = {σ ∈ valuation | (∃t : t ≺ t : match Ω(tm,σ) (σ(P ), t ))}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Operational Semantics</head><p>We have defined the semantics of tracematches in terms of applying all possible assignments of values to variables to a tracematch, and matching the resulting tracematches against a trace. We now wish to derive a more operational semantics that allows the resulting valuations to be effectively computed, leading to an implementation of tracematch matching.</p><p>Alphabet. As before, A is the set of symbols that are explicitely declared in the tracematch. In addition, we introduce a symbol skip intended to capture both events that match no declared symbol (and so are ignored in matching), and events that could match some declared symbol but are ignored because of inconsistent variable bindings. This is defined by:</p><formula xml:id="formula_8">skip(e) = ¬(∨a : a ∈ A : a(e)) = ∧a : a ∈ A : ¬a(e)</formula><p>The constraint skip(e) defines the set of valuations that make e match no defined symbol a. We write Σ = A ∪ {skip}.</p><p>To illustrate, consider the event e1 (see Figure <ref type="figure" target="#fig_24">3</ref>) that occurs upon entering the call v.f (). Here we have f (e 1 ) = (x = v) and g(e 1 ) = false, whence</p><formula xml:id="formula_9">skip(e1) = ¬(x = v ∨ false) = (x = v)</formula><p>Pattern. We now aim to construct a finite automaton to implement matching of traces. To achieve this, it is necessary to transform the pattern P appearing in the tracematch to allow skip to occur.</p><p>For two sets of strings U and V , write U ||| V for the set of all possible interleavings of strings in U and V . <ref type="bibr">It</ref>  skip true e20 exit: call(void FG.g()) A string s lies in Pat precisely when some suffix of s, possibly interleaved with some occurrences of skip representing ignored events, matches P . In addition, it is required that s end with a declared symbol (not skip).</p><formula xml:id="formula_10">g x = v</formula><p>To illustrate, for the tracematch shown earlier, P = f g, A = {f, g}, whence Σ = {f, g, skip}. Then Pat = Σ * f skip * g.</p><p>Executing advice. We wish to execute advice whenever the current trace matches the pattern Pat. Unlike the declarative semantics described previously, there is no need to filter the trace (as skip symbols deal with events not in the alphabet) or to consider suffixes of the trace. We therefore execute the advice body for each solution of the constraint:</p><formula xml:id="formula_11">match(Pat, t)</formula><p>Of course, if the constraint is f alse, there are no solutions and the advice body is not executed at all.</p><p>As an example, Figure <ref type="figure" target="#fig_25">4</ref> shows a match between the trace given in Figure <ref type="figure" target="#fig_24">3</ref> and the string f skip 18 g ∈ Pat, together with resulting constraints. The complete constraint is (x = v) ∧ (x = w) ≡ (x = v) (assuming v and w are distinct), whence the advice is run once, with valuation x → v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Equivalence of the Semantics</head><p>We have defined two semantics for the match of a tracematch tm to a trace t, which we now reconcile. The two results of matching tm to t were defined as: the set of valuations</p><formula xml:id="formula_12">S = {σ | ∃t : t ≺ t : match Ω(tm,σ) (σ(P ), t )} and the constraint c = match(Pat, t)</formula><p>As a notational convenience, we identify a constraint with the set of valuations that satisfy it. We therefore need to show that σ ∈ S ⇐⇒ σ ∈ c.</p><p>The proof is founded on the following crucial observation about our definitions. If we fix a valuation σ, then for each event e, e ∈ Ω(tm, σ) ⇐⇒ ∃a : a ∈ A : σ ∈ a(e) ⇐⇒ σ ∈ skip(e)</p><p>(1) The first equivalence is just the definition of Ω, and the second equivalence follows directly from the definition of skip. We denote the concatenation of sequences r and s by r ++ s.</p><formula xml:id="formula_13">(σ ∈ S ⇒ σ ∈ c). Let σ ∈ S.</formula><p>Then we can split t into p and q such that t = p++q and match Ω(tm,σ) (σ(P ), q) = true. By the definition of match, there exists a sequence of symbols as = a1 . . . an in the language P such that (last(q) ∈ Ω(tm, σ)) ∧ match(σ(as), q Ω(tm, σ))</p><p>Let q = q Ω(tm, σ). First note that as match(σ(as), q ) = true, it is the case that σ ∈ match(as, q ). Now, consider an event qi of q. Then there are two cases: either qi ∈ Ω(tm, σ), or qi is not in this set. In the first case, q i is part of q , say it appears at position j. Then by observation (1), σ ∈ a j (q i ). In the second case, again by observation (1), σ ∈ skip(q i ). Therefore, it is clear that σ ∈ match(as ||| skip * , q). Also, as a consequence of observation ( <ref type="formula">1</ref>), for any event e and valuation σ, there exists some a ∈ Σ such that σ ∈ a(e). Hence σ ∈ match(Σ * , p). Finally, last(q) ∈ Ω(tm, σ), so we can conclude that σ ∈ match(Σ * (P ||| skip * ) ∩ Σ * A, p ++ q), as required.</p><formula xml:id="formula_14">(σ ∈ c ⇒ σ ∈ S). Since σ ∈ match(Σ * (P ||| skip * ) ∩ Σ * A, t),</formula><p>we know that last(t) ∈ Ω(tm, σ), and we can split t into p and q such that t = p++q and σ ∈ match(P |||skip * , q). Then q is an interleaving of two strings of events r and s such that σ ∈ match(P, r) and σ ∈ match(skip * , s). Since P is over the alphabet A, for each event ri of r, ∃a : a ∈ A : σ ∈ a(ri), so r i ∈ Ω(tm, σ). For each event s i of s, σ ∈ skip(s i ), so s i ∈ Ω(tm, σ) (by observation 1). Therefore, r = q Ω(tm, σ). Hence, match Ω(tm,σ) (σ(P ), q) = true, as required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">From Semantics to Implementation</head><p>It is relatively straightforward to derive the implementation from the operational semantics defined above. The main difficulty is to compute match(Pat, t) for the current trace t efficiently at runtime.</p><p>Let M be an automaton for Pat. For each state s of M , define L(s) to be the language obtained by making s the only final state.</p><p>During execution, each state s of M is labelled by the constraint</p><formula xml:id="formula_15">lab(s, t) = match(L(s), t)</formula><p>where t is the current trace. It is shown below how to update these constraints when a new event is appended to the current trace. After we have computed the new decorated version of M , the advice body is executed for all distinct solutions of ∨s : s is a final state of M : lab(s, t)</p><p>Computing Labelled States. We now turn to the question of how to compute lab(s, t) efficiently, making an update when the trace t is extended by another symbol.</p><p>We define lab(s, t) by recursion on t. The base case is</p><formula xml:id="formula_16">lab(s, ε) = match(L(s), ) = ¡ true if s is an initial state false otherwise</formula><p>Now assume that we have computed lab(s, t) for a trace t, and we want to know its new value lab(s, te) for an extended trace te. Write s → a s to indicate that there is a transition labelled a from s to s in M . Then for all states s, it is straightforward to derive that</p><formula xml:id="formula_17">lab(s, te) = ∨a, s : a ∈ Σ ∧ s → a s : lab(s , t) ∧ a(e)</formula><p>This expression treats declared symbols and the newly introduced symbol skip on the same footing, but this is not quite possible in the implementation, for we have an explicit pointcut that corresponds to each a ∈ A, but not for skip. We therefore split off skip as a special case. Since Σ = {skip} ∪ A, the above formula may be rewritten as</p><formula xml:id="formula_18">lab(s, te) = (∨s : s → skip s : lab(s , t) ∧ skip(e)) ∨ (∨a, s : a ∈ A ∧ s → a s : lab(s , t) ∧ a(e))</formula><p>(2) Equation ( <ref type="formula">2</ref>) describes how the bindings are affected by an event e. Intuitively it is only necessary to update the bindings for events that match one of the declared symbols (that is, events e such that skip(e) = true). It is certainly desirable to avoid updates on irrelevant events for efficiency, and we introduce a refinement of (2) to allow this.</p><p>We have thus far not assumed any properties of the automaton M for Pat. However, as Pat = Σ * (P |||skip * )∩Σ * A, there is an automaton N say for Pat satisfying the following:</p><p>(a) Whenever s → skip s in N , s = s (i.e. all skip transitions are self-loops), and (b) For any state s, either s → skip s or s has no outgoing transitions (and s is then final)</p><p>The (nondeterministic) automaton N can be obtained in the following way: start with an automaton for A * P , and add skip self-loops to each state to get an automaton N 1 for Σ * (P ||| skip * ). Let N 2 be the (nondeterministic) automaton for Σ * A with two states, and no transitions from the final state. Then N is derived from N1 and N2 by the product construction (and so the language recognised by N is the intersection of those recognised by N 1 and N 2 , that is Pat), removing states that have no outgoing transitions but are not final. This satisfies conditions (a) and (b) above. Using (a), since skip only occurs on self-loops, we can rewrite (2) as:</p><formula xml:id="formula_19">lab(s, te) = (if s → skip s then lab(s, t) ∧ skip(e) else false) ∨ (∨a, s : a ∈ A ∧ s → a s : lab(s , t) ∧ a(e))<label>(3)</label></formula><p>We can use (3) to derive an implementation that only updates constraints when relevant events occur (where an event e is relevant if it matches some defined symbol, that is if skip(e) = true). The implementation will compute constraints lab impl (s, t), satisfying: lab impl (s, te) = lab(s, te) whenever s has an outgoing transition or skip(e) = true. It is easy to see that this invariant is maintained by applying (3) whenever e is a relevant event -for otherwise lab(s, te) = lab(s, t) for all states except final states, which by (b) have no outgoing transitions.</p><p>Furthermore, this invariant is enough to guarantee correct matching: a tracematch can only apply at a trace te if skip(e) = true, and in this case the computed lab impl (s, te) constraints are valid for all states s.</p><p>Our strategy upon occurrence of a new event e, then, is to first compute skip(e), and subsequently to apply the above formula (if one of the tracematch declared symbols matched).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">A Reference Implementation</head><p>This abstract reference implementation may, at first sight, appear expensive. Note, however, that in AspectJ, most of the pointcut matching in the computation of a(e) can be carried out statically <ref type="bibr" target="#b23">[23]</ref>, and consequently the above transition from lab to lab is also mostly static: it can be pre-computed at compile-time, except for variable bindings.</p><p>Let us assume that there is some suitable implementation of constraints, through a class called Constraint. It is worthwhile to generate a specialised implementation for each tracematch, but for simplicity we assume it is generic. The Constraint type has the obvious operations for the logical operations. A new equality constraint is generated by the static factory method eq(varname, value).</p><p>The key step is the computation of lab(s, te) from lab(s, t) for all states s, whenever the trace t is extended by the event e. The implementation maintains variables labs and labs temp for each state s -the value of labs is lab(s, t) for the current trace, and labs temp is an intermediate result in the computation of lab(s, te). Furthermore, a variable skip is used to store t the constraint skip(e).</p><p>To extend bindings when a new (relevant) event occurs, we compute the value of skip(e) in variable skip as the conjunction of all a(e). Also, the value of the second disjunct of Equation ( <ref type="formula" target="#formula_19">3</ref>) is accumulated in labs temp. Finally, the value of skip is added to labs temp for all non-final s.</p><p>It is straightforward to define an action to be taken when a symbol a matches: it suffices to define a piece of advice with pointcut a. Furthermore, variable bindings are given by AspectJ's advice mechanism.</p><p>Suppose that the defined symbols of the tracematch are named pointcuts a1(vs1), . . . , an(vsn) (where for each i, vsi is the list of variable names bound in ai). Define a pointcut some :</p><formula xml:id="formula_20">a1( * ) ∨ a2( * ) ∨ • • • ∨ an( * )</formula><p>that matches when some of the a i do, ignoring variable bindings. Also, for a list of variable names vs and a list of runtime values os, let eqs(vs, os) denote the constraint (∧ : 1 ≤ i ≤ |xs| : eq(vsi, osi)).</p><p>Then the pseudocode for the implementation of a tracematch is the following aspect:</p><formula xml:id="formula_21">1 aspect Tracematch 2 { 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>// For each i n i t i a l s t a t e s j (1&lt;=j&lt;=N)</head><p>4 private C o n s t r a i n t l a b s j = true ( ) ; 5 private C o n s t r a i n t l a b s j t e m p = f a l s e ( ) ; 6 // For each non-i n i t i a l s t a t e s j (1&lt;=j&lt;=N) 7 private C o n s t r a i n t l a b s j = f a l s e ( ) ; 8 private C o n s t r a i n t l a b s j t e m p = f a l s e ( ) ; This pseudocode cannot be directly expanded into As-pectJ. For, we have omitted to consider the before/after qualifiers for each piece of advice. This is not a serious difficulty (though it makes the translation slightly more complicated) -each advice ai inherits its before or after qualifier from the corresponding declared symbol. The final piece of advice (with poincut some) must be duplicated into before/after versions if both kinds of declared symbols are used (this is correct, as each event unambiguously matches either before or after symbols).</p><p>In the case of around symbols, the matching code is not affected (as around symbols are only allowed in final positions, and otherwise match as before symbols), though the way in which the tracematch body is run must be altered.</p><p>Finally, the main aim of the above translation is clarity, but it should be obvious that opportunities for further specialisation of the code abound. We shall explore these and related issues in Section 5.</p><p>An Example. To conclude this section, we illustrate the translation of tracematches into AspectJ with an example. Recall the Observer example from Section 2. The code is repeated below for ease of reference:   in Section 4.6). State 1 is the initial state, and state 3 is the only final state. The concrete implementation of the pseudocode for this tracematch is given below: Again, it is clear that the code generated for this tracematch could be improved, but we omit this for clarity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION</head><p>We have implemented our design as an extension to abc, the extensible AspectJ compiler <ref type="bibr" target="#b1">[1]</ref>. abc uses Polyglot, an extensible Java compiler <ref type="bibr" target="#b25">[25]</ref>, as its front-end, and Soot, a Java bytecode analysis and transformation framework <ref type="bibr" target="#b29">[29]</ref>, as its backend. Our implementation of tracematches does all the semantic checks via Polyglot, while the bulk of the code generation happens in Soot.</p><p>The implementation given in the previous section is almost complete: it remains to decide on a concrete representation of the abstract type of constraints. We chose the simplest option, namely keeping the logical formula in disjunctive normal form. Below we shall refer to each component of that normal form as a disjunct: a constraint is a represented as a set of disjuncts. The type of disjuncts is specialised to the free variables of a tracematch. That is, a disjunct has a flag for each variable to say whether it is bound, and if not, a set of values it should not be equal to. If the flag is true, then the disjunct records the value bound to the variable in question.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Avoiding space leaks.</head><p>A naive implementation will suffer severe space leaks: the bindings recorded in disjuncts might hold on to objects that could otherwise be garbage collected. We therefore aim to use weak references whenever possible. Clearly, we can use weak references for the 'not' sets in each disjunct. In recording positive bindings, one has to be a little bit more careful.</p><p>For each non-initial state in the finite automaton, we partition the set of all tracematch formals into three sets: collectableWeakRefs: variables that are bound on every path from the current state to a final state.</p><p>weakRefs: variables that are not used in the tracematch body, and which are not in the above set.</p><p>needStrongRefs: all variables that are not in the above two sets.</p><p>These three sets indicate for each variable what kind of reference should be used. For the first two sets, we can use weak references. Furthermore, if a member of collectableWeakRefs becomes invalid, then all disjuncts that contain it can be discarded too: it will not be possible to complete a partial match based on that disjunct, because that would require a live instance of the bound object to reach a final state. For members of weakRefs, no such additional clean-up of the containing disjuncts is possible. All variables in need-StrongRefs are required to be bound with normal, strong references.</p><p>Even with this analysis, it is possible for a tracematch to create an unbounded number of disjuncts that are never released, namely when we have a non-final, non-initial state where collectableWeakRefs is empty. In such cases, our compiler prints a warning message to indicate a leak might occur.</p><p>The above discussion ignores the problems caused by binding null values to members of collectableWeakRefs, as again this could lead to disjuncts to be never reclaimed. For now, our implementation will throw a runtime exception when a tracematch variable is assigned a null value. A more satisfactory solution might be to employ a compile-time nullness analysis to spot such potential problems. For the same reason, tracematches cannot bind values of primitive types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Performance. Our current implementation closely follows</head><p>the exposition in this paper, with an emphasis on correctness rather than speed. In our experience, the tracematch version of the small examples presented earlier is typically a factor of 15 times slower than the best hand-coded AspectJ version. The main reason for this overhead is a purely functional implementation of the constraint-handling code, which leads to substantial heap turnover.</p><p>As a realistic example, we applied our safe iterator tracematch to the use of Enumeration in JHotDraw <ref type="bibr" target="#b13">[13]</ref>, when playing an animation in the JavaDraw application. The total size of JHotDraw is 9422 SLOC. We chose this application because it represents a worst-case scenario for our techniques: if we were to apply tracematches to database connection management, for example, other costs in the system would likely dominate the use of tracematches. As to the utility of this type of application, it turns out that the use of Enumeration in JHotDraw is not safe when the drawing is edited while an animation is in progress. Indeed, we discovered this violation by running our tracematch.</p><p>For the measurements, we removed the timed slow-down in the Animator class (which slows down the animation so it appears as a smooth movement on the screen), and set it to run for 100,000 iterations. In a typical run there are 526K enumerator construction events and 7925K nextElement operations -we are thus instrumenting a very substantial part of the application.</p><p>We measured four versions of the program: with no instrumentation, with a naive aspect as shown earlier in this paper, which uses hash maps, as well as a carefully coded aspect that uses weak references, and finally our tracematch implementation. The experiments were conducted on a 2.2GHz Athlon 64 with a 512K cache, running the HotSpot JVM version 1.5.0 04 under Debian Linux. We measured both the time taken in seconds, as well as the total amount of heap memory used in kilobytes. The memory measurements were taken by calling the garbage collector and subsequently reporting the difference between total and free memory after the animation was completed. Note in particular that the tracematch version uses hardly more memory than the version with no aspect: the techniques discussed above succeed in eliminating all memory leakage. To verify that this is not an artifact of completing the animation, we measured the memory usage at intervals of 5 seconds, taking 56 measurements in all: the result is shown in Figure <ref type="figure" target="#fig_31">6</ref>. This clearly shows the absence of an upward trend, and thus the absence of memory leaks.</p><p>These results demonstrate the feasibility of our approach; indeed, with the tracematch in place, JHotDraw animations are still pleasing to the eye and there is no noticeable slowdown in the interaction. There is however still plenty of scope for optimisations, and the next section discusses some of these. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">OPTIMISATIONS</head><p>A key issue in the design of a language feature is the balance between being sufficiently expressive to be practical, while being restrictive enough to make it possible to reason about the code (both by humans and by automated tools). As we have seen in Section 2, many useful tracematches can be expressed with our design. At the same time, a key goal of our design is to provide enough information to enable compiler tools to analyze tracematch behaviour and optimize their implementation. In this section, we propose analyses and optimizations that our design makes possible, and that we intend to implement in the future.</p><p>The state that a tracematch implementation must represent at run time is a set of configurations of the form (q, σ), where q is a state of the machine M matching P at, and σ is the partial substitution of actual run-time values for tracematch variables that were implied by the events that caused M to transition to the state q. Whenever the executing program encounters a joinpoint matching a symbol of the tracematch (an event), and the variable bindings are consistent with σ, the state q is changed to the appropriate successor in M , and the substitution σ is updated with any new bindings implied by the match. In optimizing the implementation of tracematches, our goal is to reduce the size of the set of configurations that must be maintained by removing configurations which can be proven to never lead to an accepting state.</p><p>Let us begin by considering the simple case of a tracematch with no tracematch variables. In this case, every substitution is empty, so a configuration is just a machine state q. By identifying joinpoint shadows in the program where each symbol may match, and by performing an interprocedural control-flow analysis of the program, an analysis can construct a finite state machine N modelling the possible executions of the program. Each state p in N is a joinpoint shadow matching a symbol m(p) of the tracematch, and there is a transition from state p to p if there is a potential control-flow path from the joinpoint shadow p to the joinpoint shadow p , passing through no other shadow matching any tracematch symbol. Then, when the program execution is at a joinpoint shadow p 0 , and the tracematch is in state q 0 of M , it is possible to reach an accepting state of M only if there is a sequence of joinpoint shadows p0, p1, . . . , pn such that it both is a path in N , and that following the transitions m(p 0 ), m(p 1 ), . . . , m(p n ) in M starting from q 0 leads to an accepting state. This can be determined at compile time by intersecting the automata M and N . If it is not possible to reach an accepting state of M , then at p 0 , the compiler can generate code to omit the configuration q0 from the set of configurations.</p><p>Dealing with tracematch variables requires a more sophisticated analysis, because whether a joinpoint shadow matches a tracematch symbol depends on the values of the tracematch variables. Optimizing even relatively simple tracematches requires a sophisticated analysis of objects in the heap and their flow during program execution. Specifically, a heap analysis for optimizing tracematches would have to identify when bound variables at distinct symbols of the tracematch refer to the same or to distinct heap objects. Because the different symbols match at different joinpoints in the execution of the program, the analysis would have to compute these relationships between variable values at different times during execution. This is more information than what is provided by traditional heap analyses, which only compute relationships between the values of variables at each individual point in the execution.</p><p>To illustrate what kind of analysis information would be required to optimize tracematches in general, we present a simple, realistic example, and discuss the information required to optimize even this simple example. Consider the short program fragment in Figure <ref type="figure">7</ref>, to which we apply the safe iterator tracematch from Section 2. The example creates a collection, adds an element to it, and iterates through it, all repeated within an outer loop. In an actual application, such code would likely be interspersed with other code, and most likely spread out in different methods, but the general pattern of operations is fairly typical.  In a naive tracematch implementation, each time an iterator is created (line 7), a new configuration would be created binding the tracematch variable ds to the current list object, and the tracematch variable i to the iterator object just created. If an analysis could statically prove that the list will not be updated between the creation of the iterator and a call to next() on the iterator, the tracematch would be known never to apply with that configuration, and the configuration would not have to be created. In order to prove this, however, an analysis would have to track the list and iterator objects pointed to by l and i, even across different iterations of the outer loop. Specifically, to prove iterator safety for this simple example, an analysis would need to either prove that the list to which an element is added in line 6 is distinct from every list on which an iterator has ever already been created in line 7 in earlier iterations of the outer loop, or that the iterator on which next is called in line 9 is the iterator that was created in line 7 of the same iteration of the loop, and that it is distinct from all other iterators created in earlier iterations.</p><p>The information needed to optimize tracematches could be obtained by starting with heap information at a program point potentially matching a symbol of a tracematch, then tracking the flow of individual heap objects along execution paths leading to program points potentially matching other symbols of the tracematch. We leave the development of such an analysis to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>It has long been recognised that history-based advice is a powerful and desirable feature in aspect-oriented programming. The contribution of this paper is to enhance the previous proposals through trace filtering and consistent variable bindings, as well as a seamless integration into AspectJ. Below we discuss these previous proposals, and we pin down how our own design differs from them. We also briefly review some related work in property checking -although the techniques are not called 'aspect-oriented', there are many overlapping ideas. Douence et al.. History-based advice first came to our attention through the work of Douence, Fradet, Motelet and Südholt <ref type="bibr" target="#b7">[7]</ref><ref type="bibr" target="#b8">[8]</ref><ref type="bibr">[9]</ref><ref type="bibr" target="#b10">[10]</ref>. In these works, they put forward a calculus of aspects, where advice can be triggered via a sequence of joinpoints. The syntax of their history advice is</p><formula xml:id="formula_22">A ::= µa.A recursion | C I; a base case of recursion | C I; A sequencing | A2A choice</formula><p>The first form is a recursive definition; the base case of such a recursion is the second form, where a stands for the recursive call. Both in the second and third form, C stands for a pointcut, and I for a piece of advice. Intuitively, if a joinpoint matches C, the advice I is executed, and control transfers to a (recursion) or A. Finally, A 1 2A 2 offers the environment a choice between two pieces of history advice A1 and A2: if A1 succeeds, that is the preferred option, and A2 executes only when A1 fails. As a concrete example, consider the history advice below, which is taken from <ref type="bibr">[9]</ref>. It logs file accesses during a session (from a call to login to a call to logout):</p><formula xml:id="formula_23">µ a1 . login skip (µ a 2 . (logout skip ; a 1 ) 2 (read(x) addLog(x) ; a 2 ))</formula><p>The reader is encouraged to contrast this formulation with the contextual logging example presented in Section 2. As a formal calculus, the work of Douence et al. is more geared towards a formal understanding, and somewhat less towards a production programming language than ours. Nevertheless, there are clear similarities in the design: in particular, because only tail-recursive definitions are allowed, the patterns of execution are essentially regular languages. The use of regular languages to identify join points was also considered in <ref type="bibr" target="#b27">[27]</ref>, although there they range over paths in an object hierarchy, not over traces.</p><p>An important difference between our proposal and that of Douence et al. is the association of a piece of advice with every pointcut. In our setting, this would mean that every symbol declaration has an associated piece of code. Clearly this is very powerful, but it also makes it very difficult to track what is happening in the matching process, especially when the advice has side-effects. In cases where such behaviour is needed, we could use two tracematches instead of one.</p><p>A second important difference concerns the treatment of the choice operator. In the design of Douence et al., <ref type="bibr" target="#b2">(2)</ref> is asymmetric, favouring the left-hand component where possible. In our proposal R|S and S|R are equivalent patterns. Furthermore, if both R and S match, that may result in multiple variable bindings, and the advice is executed once for each binding. Several of the examples in Section 2 (in particular Observer and Connection Management) make essential use of such multiple bindings.</p><p>A very nice feature of the design of Douence et al. is that it enables interesting static analysis to determine possible interactions between aspects <ref type="bibr">[9]</ref>. Based on the close similarities with our work, we are fairly confident that their results can be transferred to our setting, and implemented in abc.</p><p>There exist at least two implementations that were loosely inspired by the design of Douence et al., namely in JaSCo <ref type="bibr" target="#b30">[30]</ref> (an integration with Java), and in the Arachne system <ref type="bibr" target="#b11">[11]</ref>. Applications of the former are discussed in <ref type="bibr" target="#b5">[5]</ref> and of the latter in <ref type="bibr" target="#b12">[12]</ref>. Especially the examples of <ref type="bibr" target="#b12">[12]</ref> provide strong indication of the importance of matching with variables as we have defined it: in that paper, the code has many explicit equality tests between variables. In tracematches, such equality tests are expressed by simply using the same variable multiple times.</p><p>Walker and Viggers. The term 'tracecuts' was introduced by Walker and Viggers in <ref type="bibr" target="#b31">[31]</ref>. Unlike the works discussed above, their design has also been integrated with an implementation of AspectJ. It is particularly interesting, therefore, to compare our design decisions to theirs.</p><p>An obvious difference is that their design uses an extension of context-free grammars to define the set of traces to match, rather than the regular expression presented here. The set of languages used are not strictly context-free, however. A 'semantic action block' can be associated with each token, to be executed whenever a current joinpoint matches a token. This block has access to information about the trace matched so far and can reject a match using the fail keyword, which results in the computation continuing as if the joinpoint had not matched the token. The presence of these blocks removes any restrictions on the set of languages that can be used to identify matches. We believe there is merit in restricting the set of languages that is recognised, not least from the point of view of program analysis: while it is trivial to decide whether one regular language is included in another, the problem is undecidable for context-free languages.</p><p>These semantic action blocks can also have side-effects, which complicate the relationship between tracecuts and original program. Without side-effects, a tracecut simply observes the execution of the base program until a match is discovered (so if a match is never found then the behaviour of the program is not altered). When side-effects are allowed, a tracecut may interact with and modify the behaviour of the base program during the matching process, making them more complex than straightforward observers.</p><p>Bockisch et al.. In <ref type="bibr" target="#b3">[3]</ref>, Bockisch, Mezini and Ostermann put forward a very general notion of pointcuts that capture dynamic properties. Their proposal is implemented in the Alpha language <ref type="bibr" target="#b26">[26]</ref>. Alpha provides Prolog queries over a rich representation of the program, including a complete representation of the execution history up to the current joinpoint. It thus provides a flexible testbed for experimenting with radical new pointcut idioms, albeit without regard for efficiency of the implementation. We believe it would be easy to implement our design for tracematches in Alpha, although such an implementation cannot rival the compilation techniques discussed here. Lieberherr et al. raise the interesting issue of the inherent time complexity of various classes of pointcut language <ref type="bibr" target="#b21">[21]</ref>. It would be worthwhile to extend their work to history-based pointcuts, with the proposal of Alpha on one end of the scale, followed by the context-free patterns of tracecuts, and our regular patterns as the least expressive (but more efficient) variant.</p><p>Property checking. Recent years have seen a veritable explosion of work that aims to verify, either dynamically or statically, the correct usage of an API. The Safe Iterators example in Section 2 is a typical instance of the type of property involved. These works on property checking are almost entirely disjoint from the aspect-oriented programming community.</p><p>Typically one specifies erroneous traces in a separate specification language, and then the specification is statically checked against the code, or dynamic tests are woven in as appropriate. Examples of this line of work are <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b16">16]</ref>.</p><p>An important difference with the proposal discussed here is that tracematches are intended as a feature that is fully integrated in the programming language, here AspectJ. As-pectJ has some very weak support for static checking of properties, namely the declare warning and declare error constructs. These take a pointcut and a message: when the pointcut is matched at compile-time, the error message is printed. An obvious generalisation is to provide trace versions of these constructs, and then the formalism is very close in expressive power to the works cited above. Such a feature would require a static analysis such as the one discussed in Section 6.</p><p>In this respect, we are particularly encouraged by the success of program query languages such as PTQL <ref type="bibr" target="#b14">[14]</ref> and PQL <ref type="bibr" target="#b22">[22]</ref>. In these systems, one writes queries over program traces; and these queries are evaluated by instrumenting the object program. Advanced static analyses are used to minimise the overheads of the queries. In the case of PTQL, the queries are phrased in the style of SQL, whereas PQL is based on DataLog. Neither of these adopts the declarative semantics for tracematching we have proposed in this paper, filtering the traces to include precisely those events that correspond to ground instances of the symbols.</p><p>Bodden. In <ref type="bibr" target="#b4">[4]</ref>, Bodden introduces the notion of concernspecific languages (CSLs), which are specific to a crosscutting concern like domain-specific languages are specific to a domain. He considers the concern of Runtime Verification <ref type="bibr" target="#b28">[28]</ref>, and shows how it can be implemented with an example language, namely linear-time temporal logic (LTL) over pointcuts. The language thus defined allows checking of certain run-time properties -among the examples Bodden gives are checking that a user is logged in when performing certain actions and proper use (i.e. timely acquiring and releasing) of locks during program execution. He exhibits an implementation which uses the abc framework to translate the LTL expressions into pure AspectJ.</p><p>The LTL predicates, as defined in this work, offer functionality that is quite similar to tracematches -properties of the program execution as a whole can be checked. Consequently, all the examples he presents have natural equivalents that can be expressed using tracematches. The converse is not necessarily true; in particular for tracematches that use variable bindings, LTL equivalents may be quite cumbersome or even impossible. Also, the focus of the work is verifying properties of the program execution rather than injecting code; tracematches offer more flexibility here. Bodden presents the idea that CSL implementations could benefit from building on top of each other, and this seems justified here: translating his language into tracematches seems easier than into pure AspectJ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>We have presented a novel design for integrating tracematches into the AspectJ language. The main innovation is our treatment of free variables in trace patterns. By defining the meaning of a tracematch through all consistent instantiations of these variables, many more examples are conveniently expressed. Inspired by these applications, we carefully reviewed the design space for tracematches and motivated our design decisions.</p><p>Of course the use of variables in trace patterns is nontrivial, and therefore we presented a precise declarative semantics, intended for reasoning about the behaviour of tracematches. We also presented an operational semantics as a step towards an implementation. The main insight in defining the operational semantics was the need for a new symbol in the alphabet to capture the skipping of other symbols due to variable binding. The declarative and operational semantics were proved to be equivalent. This is quite a satisfactory result, because conceptually they are quite different.</p><p>Furthermore, the operational semantics directly led us to a reference implementation of tracematches. It would have been quite difficult to arrive at this implementation without the careful semantic analysis that preceded it.</p><p>There are also a number of pragmatic issues must be addressed in the implementation, in particular regarding the memory usage of tracematches. We also identified a number of further optimisation opportunities. Some of these require advanced program analyses, and we intend to report on careful performance experiments, involving those advanced optimisations, in a companion paper.</p><p>Finally, this language design exercise exemplifies our philosophy for aspect-oriented programming language research: a rigorous analysis of use cases, followed by a sound definition of the semantics, leading to a neat implementation. The implementation itself has been carried out using the abc compiler, a workbench for aspect-oriented language and compiler research.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Grammar for a tracematch</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1 aspect TraceGen { 2 before</head><label>2</label><figDesc>( ) : ! within ( TraceGen ) { 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>5 } 6 a</head><label>56</label><figDesc>f t e r ( ) : ! within ( TraceGen ) { 7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 tracematch ( ) { 2 sym</head><label>12</label><figDesc>f before : c a l l ( * f ( . . ) ) ; 3 sym g a f t e r : c a l l ( * g ( . . ) ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 tracematch ( ) { 2 sym 4 | 10 A 11 } 12 }</head><label>124101112</label><figDesc>s a v e a f t e r : 3 c a l l ( * A p p l i c a t i o n . s a v e ( ) ) | c a l l ( * A p p l i c a t i o n . a u t o s a v e ( ) ) ; 5 sym a c t i o n a f t e r : 6 c a l l ( * Command . e x e c u t e ( ) ) ; p p l i c a t i o n . a u t o s a v e ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1 aspect Autosave { 2 4 a 5 | 7 } 8 9 14 }</head><label>2457814</label><figDesc>private i n t a c t i o n s s i n c e l a s t s a v e = 0 ; 3 f t e r ( ) : c a l l ( * A p p l i c a t i o n . s a v e ( ) ) | c a l l ( * A p p l i c a t i o n . a u t o s a v e ( ) ) { 6 a c t i o n s s i n c e l a s t s a v e = 0 ; a f t e r ( ) : c a l l ( * Command . e x e c u t e ( ) ) { 10 a c t i o n s s i n c e l a s t s a v e ++; 11 i f ( a c t i o n s s i n c e l a s t s a v e == 5 ) 12 A p p l i c a t i o n . a u t o s a v e ( ) ; 13 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>tracematch ( User u , Query q ) { sym l o g i n a f t e r returning : c a l l ( * LoginManager . l o g i n ( User , . . ) ) &amp;&amp; args ( u , . . ) ; sym l o g o u t a f t e r : c a l l ( * LoginManager . l o g o u t ( ) ) ; sym query before : c a l l ( * Database . query ( Query ) )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>25 } 26 } 27 }</head><label>252627</label><figDesc>aspect Logging { private boolean l o g g e d I n = f a l s e ; private User u s e r ; a f t e r ( User u ) returning : c a l l ( * LoginManager . l o g i n ( User , Password ) ) &amp;&amp; args ( u , . . ) { l o g g e d I n = true ; u s e r = u ; } a f t e r ( ) : c a l l ( * LoginManager . l o g o u t ( ) ) { 15 l o g g e d I n = f a l s e ; 16 u s e r = n u l l ; l ( * Database . query ( Query ) ) 21 &amp;&amp; args ( q ) { 22 i f ( l o g g e d I n ) { 23 System . out . p r i n t l n 24 ( u s e r + " made query " + q ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1 tracematch 4 &amp;&amp; 7 &amp;&amp;</head><label>147</label><figDesc>( S u b j e c t s , O b s e r v e r o ) { 2 sym c r e a t e o b s e r v e r a f t e r returning ( o ) : 3 c a l l ( O b s e r v e r . new ( . . ) ) args ( s ) ; 5 sym u p d a t e s u b j e c t a f t e r : 6 c a l l ( * S u b j e c t . update ( . . ) ) target ( s ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>8 9c 10 { 11 o 12 } 13 }</head><label>810111213</label><figDesc>r e a t e o b s e r v e r u p d a t e s u b j e c t * . u p d a t e v i e w ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>1 aspect O b s e r v e r { 2 private 3 =</head><label>123</label><figDesc>V e c t o r S u b j e c t . o b s e r v e r s new V e c t o r ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>4 5a 7 &amp;&amp; 21 } 22 }</head><label>472122</label><figDesc>f t e r ( S u b j e c t s ) returning ( O b s e r v e r o ) : 6 c a l l ( O b s e r v e r . new ( . . ) ) args ( s ) { 8 s . o b s e r v e r s . add ( o ) ; 9 o . u p d a t e v i e w ( ) ; e r ( S u b j e c t s ) : 13 c a l l ( * S u b j e c t . update ( . . ) ) 14 &amp;&amp; target ( s ) { 15 I t e r a t o r o b s i t = s . o b s e r v e r s . i t e r a t o r ( ) ; 16 while ( o b s i t . hasNext ( ) ) { 17 O b s e r v e r o 18 = ( O b s e r v e r ) o b s i t . n e x t ( ) ; o . u p d a t e v i e w ( ) ; 20 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>1 tracematch 4 &amp;&amp;</head><label>14</label><figDesc>( F l y w e i g h t fw , O b j e c t a r g ) { 2 sym r e t u r n a n o b j a f t e r returning ( fw ) : 3 c a l l ( FlyWeight +.new( O b j e c t ) ) args ( a r g ) ; 5 sym c r e a t e a n o t h e r o b j FlyWeight around : 6 c a l l ( FlyWeight +.new( O b j e c t ) ) 7 &amp;&amp; args ( a r g ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>8 9r</head><label>8</label><figDesc>e t u r n a n o b j c r e a t e a n o t h e r o b j</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>1 aspect FlyWeightAspect { 2 private 3 =</head><label>23</label><figDesc>Map c o n s t r u c t e d O b j e c t s new IdentityHashMap ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>4 5 7 &amp;&amp; args ( a r g ) 8 { 9 i 10 return ( FlyWeight ) 11 c 12 e l s e 13 { 14 FlyWeight</head><label>47891011121314</label><figDesc>FlyWeight around ( O b j e c t a r g ) : 6 c a l l ( FlyWeight +.new( O b j e c t ) ) f ( c o n s t r u c t e d O b j e c t s . c o n t a i n s K e y ( a r g ) ) o n s t r u c t e d O b j e c t s . g e t ( a r g ) ; fw = proceed ( a r g ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>15 c</head><label>15</label><figDesc>o n s t r u c t e d O b j e c t s . put ( arg , fw ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>tracematch ( I t e r a t o r i , DataSource ds ) { sym c r e a t e i t e r a f t e r returning ( i ) : c a l l ( I t e r a t o r DataSource . i t e r a t o r ( ) ) &amp;&amp; target ( ds ) ; sym c a l l n e x t before : c a l l ( O b j e c t I t e r a t o r . n e x t ( ) ) &amp;&amp; target ( i ) ; sym u p d a t e s o u r c e a f t e r : c a l l ( * DataSource . update ( . . ) ) &amp;&amp; target ( ds ) ; c r e a t e i t e r c a l l n e x t * u p d a t e s o u r c e+ c a l l n e x t { throw new C o n c u r r e n t M o d i f i c a t i o n E x c e p t i o n ( ) ; } }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>23 throw new 24 C</head><label>2324</label><figDesc>aspect S a f e I t e r a t o r s { private Map d s s t a t e = new IdentityHashMap ( ) ; private Map i t d s = new IdentityHashMap ( ) ; private Map i t d s s t a t e = new IdentityHashMap ( ) ; a f t e r ( DataSource ds ) returning ( I t e r a t o r i ) : c a l l ( I t e r a t o r DataSource . i t e r a t o r ( ) ) &amp;&amp; target ( ds ) { i t d s . put ( i , ds ) ; i t d s s t a t e . put ( i , d s s t a t e . g e t ( ds ) ) ; } before ( I t e r a t o r i ) : c a l l ( O b j e c t I t e r a t o r . n e x t ( ) ) &amp;&amp; target ( i ) { i f ( d s s t a t e . g e t ( i t d s . g e t ( i ) ) 22 != i t d s s t a t e . g e t ( i ) ) o n c u r r e n t M o d i f i c a t i o n E x c e p t i o n ( ) ; e r ( DataSource ds ) : 28 c a l l ( * DataSource . update ( . . ) ) 29 &amp;&amp; target ( ds ) { 30 d s s t a t e . put ( ds , new O b j e c t ( ) ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>1 tracematch 4 &amp;&amp; 7 &amp;&amp; 8 sym query before : 9 c</head><label>14789</label><figDesc>( C o n n e c t i o n c ) { 2 sym o p e n c o n a f t e r : 3 c a l l ( * C o n n e c t i o n . open ( ) ) target ( c ) ; 5 sym c l o s e c o n a f t e r : 6 c a l l ( * C o n n e c t i o n . c l o s e ( ) ) target ( c ) ; a l l ( * C o n n e c t i o n . query ( . . ) ) 10 &amp;&amp; target ( c ) ; 11 sym c r e a t e a f t e r returning ( c ) : 12 c a l l ( C o n n e c t i o n . new ( ) ) ; 13 14 ( c r e a t e query ) | ( c l o s e c o n query )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>1 tracematch 4 &amp;&amp; 5 sym query before : 6 c 7 &amp;&amp;</head><label>14567</label><figDesc>( C o n n e c t i o n c ) { 2 sym c l o s e c o n a f t e r : 3 c a l l ( * C o n n e c t i o n . c l o s e ( ) ) target ( c ) ; a l l ( * C o n n e c t i o n . query ( . . ) ) target ( c ) ; 8 sym l o g before ( ) : 9 c a l l ( * Log . add ( . . ) ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>1 aspect AJConnectionManagement { 2 private 3 = 5 a 7 &amp;&amp; 9 } 10 11 a 15 } 16 17 before 24 25</head><label>23579101115161724</label><figDesc>Map c o n n e c t i o n a g e new IdentityHashMap ( ) ; 4 f t e r ( C o n n e c t i o n c ) : 6 c a l l ( * C o n n e c t i o n . open ( ) ) target ( c ) { 8 c o n n e c t i o n a g e . put ( c , new I n t e g e r ( 0 ) ) ; f t e r ( C o n n e c t i o n c ) : 12 c a l l ( * C o n n e c t i o n . c l o s e ( ) ) 13 &amp;&amp; target ( c ) { 14 c o n n e c t i o n a g e . remove ( c ) ; ( C o n n e c t i o n c ) : 18 c a l l ( * C o n n e c t i o n . query ( . . ) ) 19 &amp;&amp; target ( c ) { 20 i f ( ! c o n n e c t i o n a g e . c o n t a i n s K e y ( c ) ) 21 c . open ( ) ; 22 c o n n e c t i o n a g e . put ( c , new I n t e g e r ( 0 ) ) ; 23 } before ( ) : c a l l ( * Log . add ( . . ) ) { 26 I t e r a t o r i t 27 = c o n n e c t i o n a g e . e n t r y S e t ( ) . i t e r a t o r ( ) ; 28 while ( i t . hasNext ( ) ) { 29 Map . Entry e = (Map . Entry ) i t . n e x t ( ) ; 30 C o n n e c t i o n c = ( C o n n e c t i o n ) e . getKey ( ) ; 31 i n t age = ( ( I n t e g e r ) e . g e t V a l u e ( ) ) 32 . i n t V a l u e ( ) ; 33 age++; 34 e . s e t V a l u e (new I n t e g e r ( age ) ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: An example tracematch</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An example trace.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Matching a trace to a word.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>9 10private 12 / 14 { 22 some : 24 {</head><label>912142224</label><figDesc>C o n s t r a i n t s k i p = true ( ) ;11 / f o r each symbol a i (1&lt;=i&lt;=n ) a i ( y1 , . . . , yk ) : C o n s t r a i n t c = e q s ( v s i , [ y1 , . . . , yk ] ) ; 15 s k i p = and ( s k i p , not ( c ) ) ; 17 18 f o r e a c h s t a t e s j f o r e a c h s t a t e s l with s l -&gt;a i s j 20 l a b s j t e m p = o r ( l a b s j t e m p , 21 and ( l a b s l , c ) ) ; } f o r each s t a t e s j 25 i f s j has a s k i p s e l f -l o o p then 26 l a b s j t e m p = o r ( l a b s j t e m p , and ( l a b s j , s k i p ) ) ; 28 l a b s j = l a b s j t e m p ; 29 l a b s j t e m p = f a l s e ( ) ; 30 i f s j i s f i n a l 32 f o r e a c h s o l u t i o n s o f l a b s j 33 run t h e tracematch body 34 with b i n d i n g s s } 35 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>1 aspect 2 { 3 tracematch 7 args ( s ) 8 sym</head><label>12378</label><figDesc>ObserveAspect ( S u b j e c t s , O b s e r v e r o ) { 4 sym c r e a t e o b s e r v e r 5 a f t e r returning ( o ) : 6 c a l l ( O b s e r v e r . new ( . . ) ) &amp;&amp; u p d a t e s u b j e c t a f t e r : 9 c a l l ( * S u b j e c t . update ( . . ) ) &amp;&amp; 10 target ( s ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>11 c 12 { 13 o 14 } 15 } 16 }</head><label>111213141516</label><figDesc>r e a t e o b s e r v e r u p d a t e s u b j e c t * . u p d a t e v i e w ( ) ;For brevity, call the creation event c and the update event u. The set of declared symbols is A = {c, u}. The finite automaton N implementing the pattern Pat derived from this tracematch is shown in Figure5(obtained as described</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The automaton for the obs tracematch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>1 aspect 2 { 3 private 5 private C o n s t r a i n t l a b 2 = f a l s e ( ) ; 6 private 17 pointcut 19 a 20 c ( s ) { 21 C o n s t r a i n t c = 22 and 26 } 27 28 a</head><label>1235261719202122262728</label><figDesc>ObserveAspect C o n s t r a i n t l a b 1 = true ( ) ; 4 private C o n s t r a i n t l a b 1 t e m p = f a l s e ( ) ; C o n s t r a i n t l a b 2 t e m p = f a l s e ( ) ; 7 private C o n s t r a i n t l a b 3 = f a l s e ( ) ; 8 private C o n s t r a i n t l a b 3 t e m p = f a l s e ( ) ; 9 10private C o n s t r a i n t s k i p = true ( ) ; 11 12 pointcut c ( S u b j e c t s ) : 13 c a l l ( O b s e r v e r . new ( . . ) ) &amp;&amp; args ( s ) ; 14 pointcut u ( S u b j e c t s ) : 15 c a l l ( S u b j e c t . update ( . . ) ) &amp;&amp; target ( s ) ; 16 some ( ) : c ( * ) | | u ( * ) ; 18 f t e r ( S u b j e c t s ) returning ( O b s e r v e r o ) : ( eq ( " s " , s ) , eq ( " o " , o ) ) ; 23 s k i p = and ( s k i p , not ( c ) ) ; 24 l a b 1 t e m p = o r ( lab1 temp , and ( l ab 1 , c ) ) ; 25 l a b 2 t e m p = o r ( lab2 temp , and ( l ab 1 , c ) ) ; f t e r ( S u b j e c t s ) : u ( s ) { 29 C o n s t r a i n t c = eq ( " s " , s ) ; 30 s k i p = and ( s k i p , not ( c ) ) ; 31 l a b 1 t e m p = o r ( lab1 temp , and ( l ab 1 , c ) ) ; 32 l a b 2 t e m p = o r ( lab2 temp , and ( l ab 2 , c ) ) ; 33 l a b 3 t e m p = o r ( lab3 temp , and ( l ab 2 , c ) ) ; e r ( ) : some ( ) { 37 l a b 1 t e m p = o r ( lab1 temp , s k i p ) ; 38 l a b 1 = l a b 1 t e m p ; l a b 1 t e m p = f a l s e ( ) ; 39 l a b 2 t e m p = o r ( lab2 temp , s k i p ) ; 40 l a b 2 = l a b 2 t e m p ; l a b 2 t e m p = f a l s e ( ) ; 41 l a b 3 = l a b 3 t e m p ; l a b 3 t e m p = f a l s e ( ) ; 42 s k i p = true ( ) ; 43 44 f o r ( s : l a b 3 . s o l s ( ) ) { 45 adviceBody ( ( S u b j e c t ) s . v a l O f ( " s " ) , 46 ( O b s e r v e r ) s . v a l O f ( " o " ) ) ; S u b j e c t s , O b s e r v e r o ) { 51 o . u p d a t e v i e w ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Memory (in Kb) over time (5 secs).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>1 L i s t l ; 2 I</head><label>12</label><figDesc>t e r a t o r i ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head>3 4while 10 } 11 }Figure 7 :</head><label>310117</label><figDesc>Figure 7: Example use of safe iterator tracematch</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>A detailed comparison of our approach to these approaches is given in Section 7.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>No WeakIdentityHashMap exists in the Java Standard Library, but such a class could of course be written specifically for this purpose.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The AspectBench Compiler. Home page with downloads, FAQ, documentation, support mailing lists, and bug database</title>
		<ptr target="http://aspectbench.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">SLAM and static driver verifier: Technology transfer of formal methods inside Microsoft</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Byron</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sriram</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Integrated Formal Methods</title>
		<editor>
			<persName><forename type="first">Eerke</forename><surname>Boiten</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">John</forename><surname>Derrick</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Graeme</forename><surname>Smith</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Quantifying over dynamic properties of program execcution</title>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Bockisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mira</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Ostermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Dynamic Aspects Workshop (DAW05)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="71" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Concern specific languages and their implementation with abc. SPLAT workshop at AOSD</title>
		<author>
			<persName><forename type="first">Eric</forename><surname>Bodden</surname></persName>
		</author>
		<ptr target="http://www.bodden.de/publications" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Dynamic business rules for web service composition</title>
		<author>
			<persName><forename type="first">Augustina</forename><surname>María</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Cibrán</surname></persName>
		</author>
		<author>
			<persName><surname>Verheecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Dynamic Aspects Workshop (DAW05)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="13" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Eclipse AspectJ: Aspect-Oriented Programming with AspectJ and the Eclipse AspectJ development tools</title>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Colyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Harley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Webster</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A framework for the detection and resolution of aspect interactions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN/SIGSOFT Conference on Generative Programming and Component Engineering (GPCE&apos;02)</title>
		<meeting>the ACM SIGPLAN/SIGSOFT Conference on Generative Programming and Component Engineering (GPCE&apos;02)</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="173" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A formal definition of crosscuts</title>
		<author>
			<persName><forename type="first">R</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Motelet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Akinori</forename><surname>Yonezawa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Satoshi</forename><surname>Matsuoka</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2192</biblScope>
			<biblScope unit="page" from="170" to="186" />
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Composition, reuse and interaction analysis of stateful aspects</title>
		<author>
			<persName><forename type="first">Rémi</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd International Conference on Aspect-oriented Software Development</title>
		<editor>
			<persName><forename type="first">Karl</forename><surname>Lieberherr</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Trace-based aspects</title>
		<author>
			<persName><forename type="first">Remi</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Aspect-oriented Software Development</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An expressive aspect language for system applications with arachne</title>
		<author>
			<persName><forename type="first">Rémi</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Loriant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Marc</forename><surname>Menaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Ségura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Aspect-Oriented Software Development</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An application of dynamic AOP to medical image generation</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Ségura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Südholt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Egon</forename><surname>Wuchner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Marc</forename><surname>Menaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd Dynamic Aspects Workshop (DAW05)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="5" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Erich</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><surname>Jhotdraw</surname></persName>
		</author>
		<ptr target="http://sourceforge.net/projects/jhotdraw" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Relational queries over program traces</title>
		<author>
			<persName><forename type="first">Simon</forename><surname>Goldsmith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O'</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName><surname>Aiken</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications</title>
		<meeting>the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Mastering AspectJ: Aspect-Oriented Programming in Java</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">D</forename><surname>Gradecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Lesiecki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A system and language for building system-specific, static analyses</title>
		<author>
			<persName><forename type="first">Seth</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yichen</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawson</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="69" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Design pattern implementation in Java and AspectJ</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hannemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregor</forename><surname>Kiczales</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="161" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An overview of AspectJ</title>
		<author>
			<persName><forename type="first">Gregor</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erik</forename><surname>Hilsdale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Hugunin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mik</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Palm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">Lindskov</forename><surname>Knudsen</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2072</biblScope>
			<biblScope unit="page" from="327" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming with</title>
		<author>
			<persName><forename type="first">I</forename><surname>Kiselev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AspectJ. SAMS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Ramnivas</forename><surname>Laddad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AspectJ in Action. Manning</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Expressiveness and complexity of crosscut languages</title>
		<author>
			<persName><forename type="first">Karl</forename><forename type="middle">J</forename><surname>Lieberherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Palm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ravi</forename><surname>Sundaram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eth workshop on Foundations of Aspect-Oriented Languages (FOAL &apos;05)</title>
		<meeting>the eth workshop on Foundations of Aspect-Oriented Languages (FOAL &apos;05)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Finding application errors using PQL: a program query language</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Monica</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications</title>
		<meeting>the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A compilation and optimization model for aspect-oriented programs</title>
		<author>
			<persName><forename type="first">Hidehiko</forename><surname>Masuhara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregor</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Dutchyn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Compiler Construction</title>
		<title level="s">Springer Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2622</biblScope>
			<biblScope unit="page" from="46" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">AspectJ cookbook</title>
		<author>
			<persName><forename type="first">Russell</forename><surname>Miles</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>O&apos;Reilly</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Polyglot: An extensible compiler framework for Java</title>
		<author>
			<persName><forename type="first">Nathaniel</forename><surname>Nystrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">R</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th International Conference on Compiler Construction</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2622</biblScope>
			<biblScope unit="page" from="138" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Expressive pointcuts for increased modularity</title>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Ostermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mira</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Bockisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A new approach to compiling adaptive programs</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Palsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boaz</forename><surname>Patt-Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karl</forename><forename type="middle">J</forename><surname>Lieberherr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="303" to="326" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Temporal Assertions using AspectJ</title>
		<author>
			<persName><forename type="first">Volker</forename><surname>Stolz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Bodden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fifth Workshop on Runtime Verification (RV&apos;05)</title>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Optimizing Java bytecode using the Soot framework: Is it feasible?</title>
		<author>
			<persName><forename type="first">Raja</forename><surname>Vallée-Rai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurie</forename><forename type="middle">J</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrice</forename><surname>Pominville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Sundaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Compiler Construction, 9th International Conference (CC 2000)</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="18" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Stateful aspects in JAsCo</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Vanderperren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davy</forename><surname>Suvé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">María</forename><surname>Augustina Cibrán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruno</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fraine</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Software Composition at ETAPS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Implementing protocols via declarative event patterns</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Viggers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigsoft International Symposium on Foundations of Software Engineering (FSE-12)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="159" to="169" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
