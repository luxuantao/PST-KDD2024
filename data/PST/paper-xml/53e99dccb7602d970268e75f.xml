<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Symmetry-Breaking in Sparse Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Computer Sciences Dept. M. I. T. M. I. T. Purdue University Cambridge</orgName>
								<orgName type="laboratory">Lab. for Computer Science Lab. for</orgName>
								<address>
									<postCode>02139, 02139, 47907</postCode>
									<settlement>Cambridge, West Lafayette</settlement>
									<region>MA, MA, IN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Serge</forename><forename type="middle">A</forename><surname>Plotkint</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Computer Sciences Dept. M. I. T. M. I. T. Purdue University Cambridge</orgName>
								<orgName type="laboratory">Lab. for Computer Science Lab. for</orgName>
								<address>
									<postCode>02139, 02139, 47907</postCode>
									<settlement>Cambridge, West Lafayette</settlement>
									<region>MA, MA, IN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gregory</forename><forename type="middle">E</forename><surname>Shannon4</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Computer Sciences Dept. M. I. T. M. I. T. Purdue University Cambridge</orgName>
								<orgName type="laboratory">Lab. for Computer Science Lab. for</orgName>
								<address>
									<postCode>02139, 02139, 47907</postCode>
									<settlement>Cambridge, West Lafayette</settlement>
									<region>MA, MA, IN</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Symmetry-Breaking in Sparse Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">272A9D900A27B8919CB924FA8612FE3C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe efficient deterministic techniques for breaking symmetry in parallel.</p><p>The techniques work well on rooted trees and graphs of constant degree or genus. Our primary technique allows us to t-color a rooted tree in O(lg'n) time on an EREW PRAM using a linear number of processors. We apply these techniques to construct fast linear processor algorithms for several problems, including (A + I)-coloring constant-degree graphs, 5-coloring planar graphs, and finding depth-first-search trees in planar graphs. We also prove lower bounds for a-coloring directed lists and for finding maximal independent sets in arbitrary graphs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Some problems for which trivial sequential algorithms exist appear to be much harder to solve in a parallel framework. The situation that is often encountered when converting a sequential algorithm into a parallel one is that, though at each step of the parallel algorithm there is a large number of possible operations, the interdependencies between them prevent their simultaneous execution.</p><p>Symmetry-breaking techniques enable the algorithm to select a large subset of independent operations. This paper is a part of this author's research towards his Ph.D. degree.</p><p>Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. TO copy otherwise, or to republish, requires a fee and/or specfic permission. @ 1987 ACM O-89791 -221-7/87/o&amp;j-03 15 754 graph is a good example of the necessity of symmetrybreaking. At any step, a parallel MIS algorithm might have many candidate vertices to add to the independent set. Not all of these, however, vertices can be added simultaneously. A symmetry-breaking technique is therefore needed to find a large set of vertices to add, as it is done in parallel MIS algorithms in <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b25">25]</ref>.</p><p>Randomization is a natural symmetry-breaking technique. It is often desirable, however, to have a deterministic algorithm. Karp and Wigderson <ref type="bibr" target="#b19">[19]</ref>, and Luby <ref type="bibr" target="#b25">[25]</ref> show how to convert certain randomized algorithms into deterministic ones. Their methods, however, result in sizable increases in the number of processors used.</p><p>In many cases it is sufficient to break symmetry in sparse graphs. In this paper we introduce a determin- The above stated results improve the running time and processor bounds for the respective problems. The best deterministic linear-processor algorithm for finding MIS <ref type="bibr" target="#b15">[16]</ref> runs in O(lg4 n) time on constantdegree graphs, compared to O(lg*n) time of our algorithm. The planar graph 5-coloring algorithms in <ref type="bibr">[7,</ref><ref type="bibr" target="#b28">28]</ref> use O(lg3 n) time and the same number of processors as needed by Luby's MIS subroutine <ref type="bibr" target="#b25">[25]</ref>. The depth-first-search algorithm for planar graphs in <ref type="bibr" target="#b30">[30]</ref> uses O(lg3 n) time and n4 processors on the EREW PRAM. The O(lg3n) running time of the maximal matching algorithm due to Israeli and Shiloach <ref type="bibr" target="#b17">[18]</ref> can be reduced to O(lg2 n) in the restricted case of planar graphs, but our algorithm is faster.</p><p>Although in this paper we have limited ourselves to the application of our techniques for the design ofparallel algorithms for the PRA.M model of computation, the same techniques can be applied in a distributed model of computation <ref type="bibr">[1,</ref><ref type="bibr" target="#b11">12]</ref>. Moreover, the Q(lg*n) lower bound for the maximal independent set problem on a chain in the distributed model, shows that our symmetry-breaking technique is optimal in this model <ref type="bibr">[2,</ref><ref type="bibr" target="#b23">23]</ref>.</p><p>Since we can 3-color a rooted tree in O(lg*n) time it is natural to ask if a rooted tree can be 2-colored as quickly. We answer this question by giving an n(lg n/ lglg n) lower bound for 2-coloring of a rooted tree. We also present an R(lg n/ lglg n) lower bound for finding a maximal independent set in a general graph, thus answering the question. posed by Luby P51.</p><p>In the next section we give some 'definitions, notation, and computation model specifics. In section 3 we present the algorithm for 3-coloring rooted trees. In section 4 we use the tree 3-coloring algorithm to (A + l)-color constant-degree graphs. In section 5 we use the MIS algorithm of section 4 to develop algorithms for planar graphs. In section 6 we outline how to quickly find a cyclic separator with a linear number processors. This implies a more efficient planar graph DFS algorit,hm. In section 7 we prove the lower bounds mentioned earlier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>This sections describes the assumptions about the computational model and introduces the notation used throughout the paper. We consider simple, undirected graphs with n vertices and m edges. The maximum degree of the graph is A. The graph induced by a set of nodes X is denoted by G[X].</p><p>Given a graph G = (V, E), we say that a subset of nodes I E V is independent if no two nodes in I are adjacent. A coloring of a graph G is an assignment C : V + N of positive integers (colors) to nodes of the graph. A coloring is volid if no two adjacent nodes have the same color. The ith bit in the color of a node v is denoted by C"(i). A subset of edges M E E is a matching if any two distinct edges in M have no nodes in common. A set of edges C is a cyclic separator of G if the edges in C form a simple cycle and the number of nodes in the largest connected component of G[V -C] is at most in.</p><p>The following problems are discussed in the paper: l</p><p>The vertex-coloring (VC) problem: find a valid coloring of a given graph that uses at most A+1 colors.</p><note type="other">l</note><p>The maximal independent set (MIS) problem: find a maximal independent set of vertices in a given graph.</p><note type="other">l</note><p>The maximal matching (MM) problem: find a maximal matching in a given graph. The Cyclic Separator (CS) problem: find a cyclic separator in an embedded planar graph.</p><p>We make a distinction between unrooted and rooted trees. In a rooted tree, each nonroot node knows which of its neighbors is its parent.</p><p>The following notation is used:  We assume a PRAM model of computation</p><p>[l&amp;6] where each processor is capable of executing simple word and bit operations. The word width is assumed to be O(lgn).</p><p>The word operations we use include bit-wise boolean operations, integer comparisons, and unary-to-binary conversion. In addition, we assume that each processor has a unique identification number O(lgn) bits wide, which we denote by PE-ID. We assign a processor to each edge and each node of the graph. We use exclusive-read, exclusive-write (EREW) PRAM, concurrent-read, exclusive-write (CREW) PRAM, and concurrent-read, concurrentwrite (CRCW) PRAM, as appropriate.</p><p>The write conflicts in CRCW PRAM are assumed to be resolved arbitrarily.</p><p>All lower bounds are proven for a CRCW PRAM with a polynomial number of processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Coloring Rooted Trees</head><p>This section describes an O(lg*n) time algorithm for 3-coloring rooted trees. First we describe an O(lg*n) time algorithm for 6-coloring rooted trees. Then we show how to transform a 6-coloring of a rooted tree into a 3-coloring in constant time.</p><p>The procedure 6-Color-Rooted-Tree is shown in Figure <ref type="figure" target="#fig_4">1</ref>. This procedure accepts a rooted tree T = (V, E) and 6-colors it in time O(lg*n). Starting from the valid coloring given by the processor ID's, the procedure iteratively reduces the number of bits in the color descriptions by recoloring each nonroot node v with the color obtained by concatenating the index of a bit in which Cu differs from Cjolhe,.(") and the value of this bit. The root r concatenates 0 and Cr[O] to form its new color.</p><p>Theorem 1 The algorithm 6-Color-Rooted-Tree produces a valid 6-coloring of a tree in O(lg*n) time on a CREW PRAM using a linear number of processors.</p><p>Proof: First we prove by induction that the coloring computed by the algorithm is valid, and then we prove the upper bound on the execution time.</p><p>Assume that the coloring C is valid at the beginning of an iteration, and show that the coloring at the end of the iteration is also valid. Let w and w be two adjacent nodes with TV being the father of 20. By the algorithm, w chooses some index i s&amp;h that G(i) # C,,,( ) i an u chooses some index j such d that C"(j) # ~Z'f~~,,~~(~)(j). The new color of w is (i, G(i))</p><p>and the new color of u is (j, G(j)).</p><p>If i # j, the new colors are different and we are done. On the other hand, if i = j, then C"(i) # Cw(i) and again the colors are different.</p><p>Hence, the validity of the coloring is preserved. 3 possible values of the index iv and 2 possible values of the bit b,.</p><p>The algorithm terminates at this point.</p><p>We use concurrent-read capability to broadcast the newly computed color Cv to all the sons of V; no concurrent-write capabilities are required. For constant-degree trees the concurrent-read capability is not needed either. i</p><p>We now describe the algorithm S-Color-Rooted-Tree(T) which 3-colors a rooted tree T. First the algorithm calls 6-color-rooted-tree(T) to produce a valid 6-coloring of T. Then the algorithm executes 3 stages, each time reducing the number of colors by one.</p><p>Each stage works as follows. By shifting down the coloring we mean recoloring each nonroot node with the color of its parent and recoloring the root with a color different from its current color. To remove the color c, first shift down the current coloring.</p><p>Then recolor every node of color c with the smallest color different from c, its father's color, an.d from the color of its sons. To describe the subsequent algorithms, we introduce the concept of pseudo-forest. A pseudo-forest of G = (V, E) is a directed graph G' = (V, E'), such that E' c E, outdegree of any node is at most one, and any zero-degree node in G' is zero-degree in G. Nodes with zero out-degree are roots of the pseudo-forest. A pseudo-forest can be constructed in constant time by choosing an adjacent edge for every node and directing the edge outwards.</p><p>The coloring algorithms presemed in this section work for pseudo-forests as well as for rooted trees. Therefore, a pseudo-forest can be 3-colored in O(lg'n) time on an EREW PRAM using a linear number of processors. Note that an odd cycle is a pseudo-forest that can not be colored in less than 3 colors.</p><p>Any tree can be 2-colored.</p><p>In fact, it is easy to 2-color a tree in polylogarithmic time. For example, one can use treefix operations <ref type="bibr">[21,2'7]</ref> to compute the distance from each node to the root, and color even level nodes with one color and odd. level nodes with the other color. It is harder to find a a-coloring of a rooted trele in parallel, however, than it is to find a 3-coloring of a rooted tree. In section 7 we show a lower bound of R(lg n/ lglgn) on 2-coloring of a directed list by a CRCW PRAM with a polynomial number of processors, which implies the same lower bound for rooted trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Coloring Constant-Degree Graphs</head><p>The method for coloring rooted trees described in the previous, section is a generalization of the deterministic coin-flipping technique described in <ref type="bibr">[9]</ref>. The method can be generalized even further <ref type="bibr" target="#b13">[14]</ref> to color constant-degree graphs in a constant number of colors. In the ,generalized algorithm, a current color of a node is replaced by a new color obtained by looking at each neighbor, appending the index of a bit in which the current color of the node is different from the neighbor's color to the value of the bit in the node color, and concatenating the resulting strings. This algorithm runs in O(lg*n) time, but the number of colors, although constant, is exponential in the degree of the graph.</p><p>In this section we show how to use the procedure J-Color-Rooted-Tree described in the previous section to color a constant-degree graph with (A+l) colors, where A is the maximum degree of the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The algorithm</head><p>Color-Constant-Degree-Graph that colors constant-degree graph with (A + 1) colors is presented in. Figure <ref type="figure" target="#fig_6">2</ref>. The algorithm consists of two phases. In the first phase we iteratively construct a pseudo-forest and remove its edges. This phase continues until no edges remain, at which point we color all the nodes with one color.</p><p>In the second phase we iteratively return the edges of the current pseudo-forest, each time recoloring the nodes to maintain a consistent coloring. At the beginning of each iteration of this pha.se, the edges of the current pseudo-forest (E') are a.(i(l~ad, making the existing (A + l)-co oring inconsistent.</p><p>This forest is 1</p><p>Color-Constant-Degree-Graph. E' c E;  Proof: At each iteration all edges of the pseudoforest are removed. From the definition of a pseudoforest it follows that each node that still has neighbors in the beginning of an iteration, has at least one edge removed during that iteration and therefore its degree decreases. Hence, the first phase of the algorithm terminates in at most A iterations.</p><p>The second phase terminates in at most A iterations as well.</p><p>Each iteration consists of two stages. First, the current forest is colored using procedure 3-Color-Rooted-Tree, which takes, by theorem 2, O(lgA lg*n) time on an EREW PRAM (the 1gA factor appears because we do not use the concurrentread capability). Now we iterate over all the colors. Since in this section we assume that A is a constant, each iteration can be done in O(lg A) time using word operations. Hence, one iteration of the second phase takes O(lgA lg'n + A 1gA) time, leading to an overall O(A lg A(A + lg'n)) running time on an EREW PRAM.</p><p>1</p><p>Having a (A+ 1)-coloring of a graph enables us to find an MIS in this graph. One can find an MIS by iterating over the colors, taking all the remaining nodes of the current color, adding them to the independent set, and removing them and all their neighbors from the graph. (We refer to this procedure as Constant-Degree-MIS in the subsequent sections.) The following theorem states this fact formally. Remark: The proofs of theorems 3 and 4 also imply that the algorithms Color-Consian&amp;Degree-Graph and Constant-Degree-MIS have a polylogarithmic running times for graphs with polylogarithmic maximum degrees. In this case, however, the assumption that the word size is greater then A is unreasonable, so the running time of the algorithms becomes O(A(A2 + 1gA lg*n)).</p><p>For graphs with maximum degree A = w(lgn), we can use the following algorithm. First, the graph is partitioned into two subgraphs with approximately equal number of nodes, and the subgraphs are recursively colored in A + 1 colors. Then we iterate through all the colors of one of the subgraphs, recoloring each node with a color different from the colors of all of its neighbors. This algorithm colors a graph with a maximum degree of A with A+ 1 colors in O(A2 lg n) time. In <ref type="bibr" target="#b29">[29]</ref>, Shannon used fiat forests to develop a similar n processor constant-degree MIS algorithm which used time exponential in A. A forest is flat if each of its trees, when properly oriented, has a height of at most 1, and any zero-degree node in the forest is zero-degree in the input graph. Using the techniques introduced in this section, we can find a flat forest of a graph by proceeding as follows. Find a pseudoforest P = G(V, E'). Note that there exists a flat forest F = (V, E"), such that E" c 15'. Use the algorithm J-Color-Rooted-Tree to find a 3-coloring of the pseudo-forest P and subsequently find an MIS I of P. Each node not in the independent set I adds an edge to E" which connects itself with a node in I. Each node in I with no adjacent edges in E", but some adjacent edges in E', chooses one adjacent edge in E' and adds it to E". The graph F indu.ced by the edges in E" is almost a flat forest -each tree has a height of at most 2. Now we split trees of height 2 in F into height one trees to get a flat forest. All operations use constant time except finding the 3-coloring of P which uses O(lg'n) time. Therefore, we can Ilnd a flat forest in O(lg*n) time on a CRElW PRAM using n processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Coloring and Ma.tching in Planar Graphs</head><p>From Euler's formula <ref type="bibr" target="#b16">[17]</ref> it follows that every planar graph has a constant fraction of nodes of degree 6 or less. In this section we use this property in conjunction with the techniques developed above to construct efficient algorithms for coloring and finding a maximal matching in planar graphs.</p><p>First, we describe a Planar-LIS procedure that given a planar graph, finds an independent set containing a constant fraction of nodes. The procedure constructs a graph induced by the rrodes with degree at most 6 and finds an MIS in this graph using the Constant-Degree-MIS procedure described in the previous section. The number of nodes in an MIS of a graph with maximum degree 6 contains at least 1/7th of the nodes in the graph. Hence, by Euler's formula, the constructed independent set contains a constant fraction of the nodes in the planar ,graph. Now we present the algorithm 'I-Color-Planar-Graph which finds a 7-coloring of a planar graph in O(lgn lg'n) time. If G has no node of degree 7 or greater, then use the algorithm Color-Constant-Degree to 7-color G. Otherwise, find an LIS I of G using the algorithm Planar-LIS. Recurse to find a 7coloring C' of G-I. Color each node in I to transform C' into a valid 'I-coloring C of G. Proof: The vertices in I can be colored independently since I is an independent set in G and they are of degree 6 or less. There are O(lg n) levels of re- cursion since the algorithm Planar-LIS produces an O(n) size independent set of G. In the CRCW PRAM there is no need to compact edge-lists at each recursion step. On the EREW PRAM, each recursion level uses O(lg A) additional time compact the edge-lists ofG-1. '1</p><p>Remark: If, at each stage, instead of removing from the graph all the nodes with degree less than 6, we remove all t'he nodes with degree less or equal to the average deg:ree, the algorithm described above runs in polylogarithmic time for any graph G such that the average degree of any node-induced subgraph G' of G is polylogarithmic in the size of G'. This class contains many important subclasses including graphs that are unions of a polylogarithmic number of planar graphs (i.e. graphs with polylogarithmic thickness).</p><p>After the planar graph is 'I-colored, we can find MIS in the graph by iterating through colors in the same way it is done in the Constant-Degree-MIS procedure. Hence, MIS in planar graph can be found in O(lgn lg'n) time on a CRCW PRAM using a linear number of processors.</p><p>The best deterministic parallel algorithms for 5coloring pla.nar graphs <ref type="bibr">[7,</ref><ref type="bibr" target="#b28">28]</ref> run O(lg3 n) and use O(n3) processors. These algorithms use a large number of processors because they use Luby's MIS algorithm 1241. 1Jsing the Constant-Degree-MIS algorithm described in. the previous section, we can reduce the number of processors to linear, but the running time will still be O(lg3 nlg'n) <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Cyclic Separators</head><p>In this section we outline the algorithm Cyclic-Separaior which finds a cyclic separator of a biconnetted embedded planar graph in O(lgn) time. We use spanning trees in the dual graph to find a specific separator among the many possible ones. Similar approach was used in [3] to find an eulerian cycle in a graph. Our algorithm can be used as a subroutine in the algorithm of <ref type="bibr" target="#b30">[30]</ref> to obtain a linear processor algorithm for constructing a depth-first tree in a planar graph.</p><p>The main idea of the algorithm is to either find a face whose boundary can be used as a separator or, if such a face does not exist, to find faces that can be merged into a superface whose boundary can be used as a separator. (Since the input graph is biconnected, any face boundary is a cycle.) Straight-forward merging of adjacent faces (i.e. faces that share at least one edge) does not work, because the boundary of the superface will not always be a simple cycle. Let T be a spanning tree of G', the dual graph of G. To find the faces that can be merged, we use the fact that if we merge all the faces that correspond to some subtree of T, the boundary of the resulting superface is a simple cycle. Define the weight of a superface to be the number of nodes on the superfac.e boundary plus the number of nodes inside the superface.</p><p>The algorithm proceeds as follows. If G has a face f whose boundary is a legal separator, return the boundary off as the separator. Otherwise, construct a spanning tree T of the dual graph G'. Let Fi denote the superface constructed by merging the faces that correspond to the subtree rooted at fi. The boundary of every Fi constructed this way is a simple cycle. Using treefix computations, we can check if there exists a node fc such the boundary of F, corresponds to a legal separator, i.e. the weight of Fe is at least in and at most $n.</p><p>If such node does not exist, find EL critical node fc such that the weight of F, is greater than in but the weights of Fi are less than in, where {f;) are the sons of fe. Merging fe with some subset of { Fi} gives a superface whose boundary is a separator. Note that not all the subsets of { Fi}, when merged with fc, produce the desired superface, even if its weight is bet.ween fn and gn, because the boundary of this superface is not necessary a simple cycle. To find a legal subset, consider the graph G" with nodes c.orresponding to superfaces F; and edges between two superfaces if they are adjacent. Construct a spanning tree of G" and find a critical node fi. If F,' corresponds to a legal separator, we are done. Otherwise, merge the superfaces i:n each one of the subtrees rooted at the sons of fl to get the set {F/}. Each superface in {Fi} is adjacent .to both fc and fi, and therefore we can find the separator using a prefix computation. Proof: Given an instance of MAJORITY, we construct an instance of MIS in constant CRCW PRAM time.</p><p>MAJORITY is harder that PARITY <ref type="bibr">[ll]</ref>, which was proven to take SZ(lgn/ lglgn) time on a CRCW PRAM in <ref type="bibr">[4,</ref><ref type="bibr">5]</ref>. Therefore the lower bound claimed in the theorem follows.</p><p>Let +1,22,...,rn be an instance of MAJORITY. We construct a complete bipartite graph G = (V, E) with nodes corresponding to '0' bits of the input on one side and nodes corresponding to '1' bits on the other side. A maximal matching in a complete bipartite graph is also a maximum one. By constructing a maximal independent set in the line-graph G' of G, one can find a maximal matching in G. To construct the graph G' assign a processor Pijk for each distinct i, j, k 5 n. Each Pijk writes 1 into location h!f(i,j),(j,k) if Mij = hfjk = 1 and 0 otherwise. Proof: We show a constant time reduction from PARITY to the 2-coloring of a directed list. First, we show how to construct, in constant time, a directed list with elements corresponding to all the input bits zi with value of 1. Let 21, ~2,. . . , t, be an instance of PARITY.</p><p>Associate a processor P; with each input cell Mi that initially holds the value of xi. Associate a set of processors P{" with each index i,, 1 5 k 5 j &lt; i. In one step, each processor Pik reads the value of Mk and, if it equals to 1, writes 1 into Mj, effectively computing the ORfunction on the input values xi-j, Zi-j+l,.</p><p>. . , ~i-1. Assign a processor P,?' to each Mj. Each processor Pj reads ll# and Mi+' and writes j into M,! if and only if nrl:' # Mi+'.</p><p>It can be seen that for all 0 5 i 5 n, M,! lfiolds max{j 1 j &lt; i, xj = 1).</p><p>We have constructed a directed list with elements corresponding to all the input bits xi with value of 1. Assume this list is P-colored. Then PARITY equals to 1 if and only if both ends of the list are colored with the same color, which can be checked in constant time. m</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Finding a maximal independent set (MIS) of a *Supported by n Fannie and John Hertz Foundation Fellowship and ONR Contract N00014-80-C-0622. This paper is a part of this author's research towards his Ph.D. degree. tsupported by ONR Contract NOOO14-80-C-0622. *Supported in part by Hewlett-Packard's Faculty Develop ment Program, NSF Grant DCR-8320124, and ONR Contract N00014-86-K-0689.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>istic symmetry-breaking techniques for sparse graphs that use only a linear number of processors. Our primary technique allows us to color a rooted tree in O(lg*n) time on an CREW PRAM. This technique was motivated by the deterministic coin-flipping technique developed by Cole and Vishkin [9]. We use our techniques to develop the linear-processor algorithms listed below. l For graphs whose maximum degree is A, we give an O(A lg A(lg*n + A))-time EREW PRAM al-gorithm for (A + 1)-coloring and for finding a maximal independent set. For planar graphs, we give 7-coloring, MIS, and maximal matching algorithms that run in O(lg nlg*n) time on a CRCW PRAM and in O(lg2n) time on an EREW PRAM. We give an O(lg n lg*n)-time CRCW PRAM algorithm for 5-coloring an embedded planar graph. We also give an algorithm for constructing a depth-first search tree in planar graph. This algorithm runs in O(lg2 n) tim.e on a CRCW PRAM and in O(lg2 nlg'n) tim.e on an EREW PRAM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(') x = Iglg@l) 3: Yg'x = min{;l lg(') 2 &lt; 2) Procedure 6-Color-Rooted-Tree(T) J5 + pf3nj; for all v E V in parallel do C, + PE-ID(u); while L &gt; 3for all v E V in parallel do begin if v is the root then begin i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The Coloring Algorithm for Rooted Trees</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Now we show that the algorithm terminates after O(lg*n) iterations.Let Lk denote the number of bits in the representation of colors after k iterations. For k = 1 we haveL1 = l-w4 + 1 5 2i-w if [IgLJ &gt; 1.Assume for some k we have Lk-1 &lt; 2pg("-') L] and pgck) L] &gt; 2) L)l + 1 &lt; 2j-lg@)Ll -Therefore, as long as pg(") L] &gt; 2, Lk 5 2pgck) 1;1 I Hence, the number of bits in the representation of colors Lk decreases Until, after O(lg*n) iterations, pg(") Ll becomes 1 and Lk reaches the value of 3 (the solution of L = pg L] -I-1). Another iteration of the algorithm produces a g-coloring:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Theorem 2</head><label>2</label><figDesc>Given a rooted tree T, the algorilhrn 3-Color-Rooted-Tree constructs a valid J-coloring C of T using n processors and O(lg*n) time on a CREW PRAM. Proof: After shifting the colors, the sons of any node have the same color. Therefore, each stage of the algorithm reduces the number of c'olors by one, as long as the number of colors is greater than 3. Each stage takes a constant time on a CR:EW PRAM. The theorem follows from theorem 1. a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>i + 0; while E' # 0 do begin (( the first phase)) for all v E V in parallel do if 3(~, U) E E' then Ei * Ei + (v, U) ; E' +-E' -E;; (( Ei are edges of a pseudofor i + i -1 to 0 do begin (( the second phase)) C' + 3-Color-Rooted-Tree (V, Ei); E' + E'+ Ei; for L+2to3,jcltoA+ldo V' + v; for all v E V' in parallel do if C(v) = j and C'(v) = k then begin C(v) ~max{{l,2,...A+l)-{C(w) I (v, ~1 f WI; V' + V' -{v}; end</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The Coloring Algorithm for Constant Degree Graphs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Theorem4</head><label></label><figDesc>An MIS in constant-degree graphs can be found in O(lg*n) lime on an EREW PRAM using O(n) P rocessors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>The above algorithms can be implemented in the distributed model of computation [1,12], where processors have fixed connections determined by the input graph. The algorithms in the distributed model achieve the same O(lg"n) bound a23 in the EREW PRAM model. It was recently shown that R(lg*n) time is required in the distributed model to find a maximal independent set on a chain [2,23]. Our algorithms are therefore optimal (to within a constant factor) in the distributed model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>coloring using n processors and O(lgnlg*n) time on an CRCW PRAM, and O(lgn(lg A -+ lg'n)) time on an EREW PRAM.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>algorithm Y-Color-Planar-Graph. The related result for MIS on bounded-genus graphs follows as before.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Theorem 8</head><label>8</label><figDesc>Given a biconnected plane graph, the al- gorithm Cyclic-Separator constructs a cyclic separator of the graph in O(lgn) time on a CRCW PRAM and in O(lg n lg'n) time on an ERE W PRAM using a linear number of processors. Proof: Omitted. 1 Based on our cyclic separator algorithm and recent work on embeddings and biconnected components, we have the theorem below for finding DFS trees in planar graphs. Theorem 9 Given a planar graph, we can construct a depth-first-search tree in O(1g2 n) time on a CRCW PRAM, O(lg*nlg2n) time on an CREW PRAY, using a linear number of processors. this section we prove two lower bounds for a CRCW PRAM with a polynomial number of processors: l Finding a maximal independent set in a general graph takes n(lg ra/ lglg n) time. l 2-coloring a directed list takes IZ(lgn/ lglgn) time. The first lower bound complements the O(lgn) CRCW PR.AM upper bound for the MIS problem that is achieved by Luby's algorithm [25]. The second rower bound complements Theorem 2 in this paper. Theorem 10 The running time of any Mls' a/gorilhm on a CRCW PRAM with a polynomial number of processors is n(lg n,/ lglg n).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>graph, assign a processor Pij for each pair 1 5 i &lt; j &lt; n. Then, each processor Pij writes 1 into location Mij if xi # zj and writes 0 otherwise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>The MAJORITY equals to 1 if and only if there is an unmatched node i E G such that xi = 1, which can be checked on a CRCW PRAM in constant time. 1 Theorem 11 Th.e time 20 %-color a directed list on a CRCCY PRAM with a polynomial number of processors is Q(lg n/ lglg n).</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank Greg Frederickson, Charles Leiserson, and David Shmoys for fruitful and stimulating discussions, and for their valuable comments on a draft of this paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The 5-coloring algorithm presented below is essentially a parallelization of the sequential algorithms in [8, <ref type="bibr">26 .</ref> in O(k A Given embedding (which can be computed 4 PO1 1, our algorithm runs in O(lg n lg'n) time on a CRCW PRAM using a linear number of processors. Given a graph G, the algorithm finds a special large independent set 1 of nodes in G, merges some of the neighbors of I (as described below) to create a new graph G', recursively colors G', and uses this coloring to color the nodes in G.</p><p>The special independent set I, mentioned above, is constructed as follows. Let &amp; be the set of all nodes in G of degree 25 or greater. Let V, be the set of all nodes of degree 4 or less. Let Vs and Vc be the set of all nodes of degree 5 with at most one neighbor in &amp; and the set of all nodes of degree 6 with no neighbors in Q, respectively.</p><p>Let S = Vd U Vs U VS. Let G' = (V',E") b e a graph which is a square of the graph induced by the nodes V -Q in G. The set I is a maximal independent set induced by the nodes in S in the graph G" U G. Since G" is of constant degree, we can find I using the procedure Constant-Degree-MIS.</p><p>In order to construct the graph G', the algorithm proceeds as follows. For each node in I n Vs we find two of its non-adjacent neighbors that have low degree (less than 25), and merge them into a single supernode. For each node in InVe we either merge three of its non-adjacent neighbors into a single supernode, or we merge two non-adjacent pairs of its neighbors into two supernodes. The embedding information is used to find the pairs that can be merged preserving planarity.</p><p>Then we remove all the nodes in I to get the graph G'.</p><p>After we recursively 5-color the graph G', we obtain the coloring of G as follows. First, we color all the nodes of G that correspond to nodes or supernodes of G' with the same color they were colored in G'. Now we add all the nodes in I and simultaneously color every one of them with a color different from the colors of its neighbors. Proof: Correctness of the algorithm follows from [8] and from the fact that the nodes in I are independent, Following an approach found in [S] for manipulating Euler's formula, we can show that the size of S is n(n). The graph G" has a constant maximum degree and hence the size of the set I is a(n) as well. Therefore, the depth of recursion is at most O(lgn).</p><p>On a CRCW PRAM, we can find S and Q in constant time as in the algorithm %Color-Planar-Graph. The construction of G" U G takes constant time. The algorithm Constant-Degree-MIS finds I in O(lg*n) time since G" has a constant degree. In constant time nodes in I can merge appropriate neighbors and delete themselves from G and form G'. Edge lists in G' need not be compacted since we are using the CRCW PRAM. After coloring G', we can color G in constant time.</p><p>On the EREW PRAM, O(lg A) additional time per recursion level is needed since we must compact edge lists of G' (so that the set S in G' can be found in constant time). 1</p><p>Using the techniques described in this section it is easy to construct a fast algorithm for finding a maximal matching in a planar (or constant-degree) graph, To find a maximal matching in a planar graph, repeat the following until there are no more edges left. Find flat forest in the graph. Arbitrarily add one edge to the matching from each tree in the forest. Remove all end points of the edges just added to M and repeat on the graph induced by the remaining nodes. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Complexity of network synchronization</title>
		<author>
			<persName><forename type="first">B</forename><surname>Pi</surname></persName>
		</author>
		<author>
			<persName><surname>Awerbuch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="804" to="823" />
			<date type="published" when="1985-10">October 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">A tight lower bound on the time of distributed maximal independent set algorithms</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-02">February 1987</date>
		</imprint>
	</monogr>
	<note>Unpublished manuscript</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Finding euler circuits in logarithmic parallel time</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Israeli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shiloach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lower Bounds in Parallel Machine Computation</title>
		<imprint>
			<date type="published" when="1984">1984. 1986</date>
			<biblScope unit="page" from="249" to="257" />
		</imprint>
		<respStmt>
			<orgName>University of Toronto</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
	<note>Proc. 16th ACM Symp. on Theory of Computing</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Optimal bounds for decision problems on the CRCW PRAM</title>
		<author>
			<persName><forename type="first">P</forename><surname>Beame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hastad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ACM Symp. on Theory of Compuling</title>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Routing, merging, and sorting on parallel models of computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="130" to="145" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Coloring planar graphs in parallel</title>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Boyar</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Karloff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
	<note>Unpublished Manuscript</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A linear 5-color algorithm of planar graphs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nishizeki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Saito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="317" to="327" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Deterministic coin tossing and accelerating cascades: micro and macro techniques for designing parallel algorithms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Vishkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th ACM Symp. on Theory of Computing</title>
		<meeting>18th ACM Symp. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="206" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Parallelism in random access machines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fortune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wyllie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th ACM Symp. on Theory of Compuling</title>
		<meeting>10th ACM Symp. on Theory of Compuling</meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="4" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Furst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
		<title level="m">Parity, circuits, and the polynomial time hierarch.y. In Proc. 22nd IEEE Conf on Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="260" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A distributed algorithm for minimumweight spanning trees</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Gallager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Hum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Sp Ira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="66" to="77" />
			<date type="published" when="1983-01">January 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Eficient Parallel Algorithms for (,4 + I)-Coc&apos;oring and Maximal Independent Set Problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
		<idno>MIT/LCS/TM-320</idno>
	</analytic>
	<monogr>
		<title level="j">MIT</title>
		<imprint>
			<date type="published" when="1987-01">January 1987</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parallel (A + 1) coloring of constant-degree graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
	<note>Accepted for publication</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">E&apos;cient Graph Algorithms for Sequential and Parallel Computers</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
	<note>PhD t,hesis, M.I.T.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A new parallel algorithm for the maximal independent set problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Spencer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
	<note>Submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Graph Theory</title>
		<author>
			<persName><forename type="first">F</forename><surname>Harary</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">An improved parallel algorithm for maximal matching</title>
		<author>
			<persName><forename type="first">A</forename><surname>Israeli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shiloach</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Information</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Processing Letters</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="57" to="60" />
			<date type="published" when="1986-01">January 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A fast parallel algorithm for the maximal independent set problem</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16fh ACM Symp. on Theory of Computing</title>
		<meeting>16fh ACM Symp. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="266" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An efficilent parallel algorithm for planarity</title>
		<author>
			<persName><forename type="first">P</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the t7&apos;h Annual Symposium on Foundations of Computer Science</title>
		<meeting>of the t7&apos;h Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="465" to="477" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Communicationefficient parallel graph algorithms</title>
		<author>
			<persName><forename type="first">C</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Maggs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Conference on Pa;.rallel Processing</title>
		<meeting>of International Conference on Pa;.rallel essing</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="861" to="868" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">A fast parallel algorithm for region labeling</title>
		<author>
			<persName><forename type="first">C</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Phillips</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986-10">October 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Locality as an obstacle to distributed computing</title>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1987-02">February 1987</date>
			<publisher>Unpublished manuscrint</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A simple parallel algorithm for the maximal independent set problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Comp</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1036" to="1052" />
			<date type="published" when="1986-11">November 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A simple parallel algorithm for the maximal independent set problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th ACM Symn. on Theory of Computing</title>
		<meeting>17th ACM Symn. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Two Linear-time Algorithms for Five-coloring a Planar Graph</title>
		<author>
			<persName><forename type="first">D</forename><surname>Matula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shiloach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tarjan</surname></persName>
		</author>
		<idno>STAN-CS-80-830</idno>
		<imprint>
			<date type="published" when="1980-11">November 1980</date>
			<pubPlace>Palo Alto, California</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Stanford University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Parallel tree contraction and its application</title>
		<author>
			<persName><forename type="first">G</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 26&apos;th Annual Symposium on Foundations of Computer Science</title>
		<meeting>of 26&apos;th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1985-10">October 1985</date>
			<biblScope unit="page" from="478" to="489" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Two P arallel Algorithms in Graph Theory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nao</surname></persName>
		</author>
		<idno>CS-86-6</idno>
		<imprint>
			<date type="published" when="1986-06">June 1986</date>
			<pubPlace>Jerusalem, Israel</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, The Hebrew University of Jerusalem</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Reduction techniques for designing linear-processor parallel algorithms on sparse graphs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Shannon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
	<note>Extended Abstract</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Parallel algorithms for depth-first searches I. planar graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Computing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="814" to="830" />
			<date type="published" when="1986-08">August 1986</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
