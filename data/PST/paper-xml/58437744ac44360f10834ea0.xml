<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">big-data: The Q3 NoSQL landscape</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alejandro</forename><surname>Corbellini</surname></persName>
							<email>alejandro.corbellini@isistan.unicen.edu.ar</email>
						</author>
						<author>
							<persName><forename type="first">Cristian</forename><surname>Mateos</surname></persName>
							<email>cristian.mateos@isistan.unicen.edu.ar</email>
						</author>
						<author>
							<persName><forename type="first">Alejandro</forename><surname>Zunino</surname></persName>
							<email>alejandro.zunino@isistan.unicen.edu.ar</email>
						</author>
						<author>
							<persName><forename type="first">Daniela</forename><surname>Godoy</surname></persName>
							<email>daniela.godoy@isistan.unicen.edu.ar</email>
						</author>
						<author>
							<persName><forename type="first">Silvia</forename><surname>Schiaffino</surname></persName>
							<email>silvia.schiaffino@isistan.unicen.edu.ar</email>
							<affiliation key="aff1">
								<orgName type="institution">Also Consejo Nacional de Investigaciones Científicas y Técnicas</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">ISISTAN (CONICET-UNCPBA) Research Institute 1</orgName>
								<orgName type="institution" key="instit2">UNICEN University</orgName>
								<address>
									<addrLine>Campus Universitario</addrLine>
									<postCode>B7001BBO</postCode>
									<settlement>Tandil</settlement>
									<country key="AR">Argentina</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">big-data: The Q3 NoSQL landscape</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">289622AC513D5DBA4500399FBDC64423</idno>
					<idno type="DOI">10.1016/j.is.2016.07.009</idno>
					<note type="submission">Received 11 March 2014 Accepted 21 July 2016 Recommended by: G. Vossen</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>NoSQL databases Relational</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The growing popularity of massively accessed Web applications that store and analyze large amounts of data, being Facebook, Twitter and Google Search some prominent examples of such applications, have posed new requirements that greatly challenge traditional RDBMS. In response to this reality, a new way of creating and manipulating data stores, known as NoSQL databases, has arisen. This paper reviews implementations of NoSQL databases in order to provide an understanding of current tools and their uses. First, NoSQL databases are compared with traditional RDBMS and important concepts are explained. Only databases allowing to persist data and distribute them along different computing nodes are within the scope of this review. Moreover, NoSQL databases are divided into different types: Key-Value, Wide-Column, Document-oriented and Graphoriented. In each case, a comparison of available databases is carried out based on their most important features.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Relational databases or RDBMSs (Relational Database Management Systems) have been used since the 1970s and, as such, they can certainly be considered a mature technology to store data and their relationships. However, storage problems in Web-oriented systems pushed the limits of relational databases, forcing researchers and companies to investigate non-traditional forms of storing user data <ref type="bibr" target="#b102">[105]</ref>. Today's user data can scale to terabytes per day and they should be available to millions of users worldwide under low latency requirements.</p><p>The analysis and, in particular, the storage of that amount of information is challenging. In the context of a single-node system, increasing the storage capacity of any computational node means adding more RAM or more disk space under the constraints of the underlying hardware. Once a node reaches its storage limit, there is no alternative but to distribute the data among different nodes. Traditionally, RDBMSs systems were not designed to be easily distributed, and thus the complexity of adding new nodes to balance data is high <ref type="bibr" target="#b64">[67]</ref>. In addition, database performance often decreases significantly since joins and transactions are costly in distributed environments <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b83">86]</ref>. All in all, this does not mean RDBMSs have became obsolete, but rather they have been designed with other requirements in mind and work well when extreme scalability is not required.</p><p>Precisely, NoSQL databases have arisen as storage alternatives, not based on relational models, to address the mentioned problems. The term "NoSQL" was coined by Carlo Strozzi in 1998 to refer to the open-source database called NoSQL not having an SQL interface <ref type="bibr" target="#b105">[108]</ref>. In 2009, the term resurfaced thanks to Eric Evans in the context of an event about distributed databases. 2 Since then, some researchers <ref type="bibr" target="#b55">[58,</ref><ref type="bibr" target="#b54">57]</ref> have pointed out that new information management paradigms such as the Internet of Things would need radical changes in the way data is stored. In this context, traditional databases cannot cope with the generation of massive amounts of information by different devices, including GPS information, RFIDs, IP addresses, Unique Identifiers, data and metadata about the devices, sensor data and historical data.</p><p>In general, NoSQL databases are unstructured, i.e., they do not have a fixed schema and their usage interface is simple, allowing developers to start using them quickly. In addition, these databases generally avoid joins at the data storage level, as such operations are often expensive, leaving this task to each application. The developer must decide whether to perform joins at the application level or, alternatively, denormalize data. In the first case, the decision may involve gathering data from several physical nodes based on some criteria and then join the collected data. This approach requires more development effort but, in recent years, several frameworks such as MapReduce <ref type="bibr" target="#b30">[31]</ref> or Pregel <ref type="bibr" target="#b71">[74]</ref> have considerably eased this task by providing a programming model for distributed and parallel processing. In MapReduce, for example, the model prescribes two functions: a map function that process keyvalue pairs in the original dataset, producing new pairs, and a reduce function that merges the different results associated to each pair produced by the map function.</p><p>Instead, if denormalization is chosen, multiple data attributes can be replicated in different storage structures. For example, suppose a system to store user photos. To optimize those queries for photos belonging to users of a certain nationality, the Nationality field may be replicated in the User and Photo data structures. Naturally, this approach rises special considerations regarding updates of the Nationality field, since inconsistencies between the User and Photo data structures might occur.</p><p>Many NoSQL databases are designed to be distributed, which in turn allows increasing their capacity by means of just adding nodes to the infrastructure, a property also known as horizontal scaling. In NoSQL databases (as in most distributed database systems), a mechanism often used to achieve horizontal scaling is sharding, which involves splitting the data records into several independent partitions or shards using a given criterion, e.g. the record ID number. In other cases, the mechanism employed is replication, i.e. mirroring data records across several servers, which while not scaling well in terms of data storage capacity, allows increasing throughput and achieving high availability. Both sharding and replication are orthogonal concepts that can be combined in several ways to provide horizontal scaling.</p><p>In most implementations, the hardware requirements of individual nodes should not exceed those of a traditional personal computer, in order to reduce the costs of building such systems and also to ease the replacement of faulty nodes.</p><p>NoSQL databases can be divided into several categories according to the classification proposed in <ref type="bibr" target="#b110">[113,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b64">67,</ref><ref type="bibr" target="#b47">49]</ref>, each prescribing a certain data layout for the stored data: Key-Value: These databases allow storing arbitrary data under a key. They work similarly to a conventional hash table, but by distributing keys (and values) among a set of physical nodes.</p><p>Wide Column or Column Families: Instead of saving data by row (as in relational databases), this type of databases store data by column. Thus, some rows may not contain part of the columns, offering flexibility in data definition and allowing to apply data compression algorithms per column. Furthermore, columns that are not often queried together can be distributed across different nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Document-oriented:</head><p>A document is a series of fields with attributes, for example: name¼"John", lastname¼" Smith" is a document with 2 fields. Most databases of this type store documents in semi-structured formats such as XML <ref type="bibr" target="#b15">[16]</ref> (eXtensible Markup Language), JSON <ref type="bibr" target="#b27">[28]</ref> (JavaScript Object Notation) or BSON <ref type="bibr" target="#b74">[77]</ref> (Binary JSON). They work similarly to Key-Value databases, but in this case, the key is always a document's ID and the value is a document with a pre-defined, known type (e.g., JSON or XML) that allows queries on the document's fields.</p><p>Moreover, some authors also conceive Graph-oriented databases as a fourth category of NoSQL databases <ref type="bibr" target="#b47">[49,</ref><ref type="bibr" target="#b110">113]</ref>:</p><p>Graph-oriented: These databases aim to store data in a graph-like structure. Data is represented by arcs and vertices, each with its particular attributes. Most Graphoriented databases enable efficient graph traversal, even when the vertices are on separate physical nodes. Moreover, this type of database has received a lot of attention lately because of its applicability to social data. This attention has brought accompanied new implementations to accommodate with the current market. However, some authors exclude Graph-oriented databases from NoSQL because they do not fully align with the relaxed model constraints normally found in NoSQL implementations <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b64">67]</ref>. In this work, we decided to include Graph-oriented databases because they are essentially non-relational databases and have many applications nowadays <ref type="bibr" target="#b1">[2]</ref>.</p><p>In the following sections we introduce and discuss the most prominent databases in each of the categories mentioned before. Table <ref type="table" target="#tab_0">1</ref> lists the databases analyzed, grouped by category. Although there are many products with highly variable feature sets, most of the databases are immature compared to RDBMSs, so that a very thorough analysis should be done before choosing a NoSQL solution. Some factors that may guide the adoption of NoSQL as data storage systems are: Data analysis: In some situations it is necessary to extract knowledge from data stored in a database. Among the approaches for running jobs over big data stands out MapReduce <ref type="bibr" target="#b30">[31]</ref>. In many of these processing frameworks, the developer must code the query in a given imperative programming language. Although this is much more complex than just executing a SELECT… GROUP BY query against the database, it is more suitable for large data volumes. Languages such as Pig 3 and Hive <ref type="bibr" target="#b109">[112]</ref> simplify the development of applications with MapReduce, significantly reducing its learning curve.</p><p>Scalability: NoSQL databases are designed to store large amounts of data or to support demanding processing by adding new nodes to the system. Additionally, they are usually designed under a "let it crash" philosophy, where nodes are allowed to crash and their replicas are always ready to receive requests. This type of design provides a sense of robustness in terms of system failover capabilities. In some cases, when the crash seems to be permanent, the data is automatically redistributed among the available nodes in the computer cluster.</p><p>Flexible schema: The NoSQL databases presented in this paper do not have a fixed schema. Key-Value databases do not make assumptions about the values of keys (except for Redis and Hazelcast which allow users to store lists and sets). Document-oriented and Wide Column databases tolerate discrepancies between fields/rows of elements. In Graph-oriented databases, vertices and arcs can have any structure. Oppositely, relational databases are composed of tables with a fixed scheme and all tuples have the same number of fields.</p><p>Fast deployment: In general terms, NoSQL systems can be easily deployed in a cluster. In addition, replication and sharding configuration are usually automatic, speeding up their adoption.</p><p>Location awareness: In general, as NoSQL databases are designed to be distributed, the location of the data in the cluster is leveraged to improve network usage, usually by caching remote data, and making queries to those nodes located closer in the network topology (e.g., nodes located in the same local-area network). This mechanism is often referred to as data affinity.</p><p>Moreover, the choice of a NoSQL database must be based on the type of data to be stored as well as the form of access (read and write). An extreme example would be a Web site that gets millions of hits per second whose data may drastically change to support new functionality. Facebook, Google Search and Amazon are some notable examples. In these systems, data may grow without estimable bounds and, therefore, the system infrastructure must allow increasing storage space without losing performance. In these situations, the use of relational databases is scarce and several non-relational technologies can accommodate these requirements.</p><p>It is worth noting that there is a minority of hybrid databases that store more than one data layout. Examples of multi-layout databases are OpenLink Virtuoso <ref type="bibr" target="#b33">[35]</ref>, OrientDB <ref type="bibr" target="#b79">[82]</ref> and AlchemyDB <ref type="bibr" target="#b91">[94]</ref>. However, we will not discuss these efforts in a separate section as the mechanisms for supporting the different layouts do not conceptually differ from those offered by single-layout databases.</p><p>As an alternative to NoSQL and traditional RDMBSs, new database systems have recently emerged under the name of "NewSQL databases" <ref type="bibr" target="#b101">[104]</ref>. NewSQL databases are relational databases supporting sharding, automatic replication and distributed transaction processing, i.e., providing ACID guarantees even across shards. Examples of this type of database are NuoDB, 4 VoltDB 5 and Clustrix 6  As an example, Google's Spanner <ref type="bibr" target="#b24">[25]</ref> is a globally distributed database system created at Google that supports distributed transactions, designed as a replacement to Megastore <ref type="bibr" target="#b9">[9]</ref>, a BigTable-based storage. Nevertheless, like NoSQL databases, NewSQL databases must undergo a strict analysis before being adopted by any organization.</p><p>It is worth mentioning that although this work aims at assisting in the selection of a NoSQL database for a given situation, the analysis cannot be reduced only to benchmarking each database in a use case context. This is due to the diversity of techniques, implementations and querying methods that NoSQL databases exhibit, which makes it hard to establish a common ground of comparison. Nonetheless, benchmarking frameworks for NoSQL databases are mentioned in Section 2 since they are useful for understanding the performance of NoSQL databases under different workloads. As such, these frameworks might complement in practice the selection criteria presented in this paper.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Category</head><p>NoSQL databases analyzed Key-Value (Section 4) Hazelcast <ref type="bibr" target="#b46">[48]</ref> Redis <ref type="bibr" target="#b94">[97]</ref> Membase/Couchbase <ref type="bibr" target="#b25">[26]</ref> Riak <ref type="bibr">[11]</ref> Voldemort <ref type="bibr" target="#b67">[70]</ref> Infinispan <ref type="bibr" target="#b72">[75]</ref> Wide-Column (Section 5) HBase <ref type="bibr" target="#b38">[40]</ref> Hypertable [54] Cassandra <ref type="bibr" target="#b61">[64]</ref> Document-Oriented (Section 6) CouchDB <ref type="bibr" target="#b65">[68]</ref> MongoDB <ref type="bibr" target="#b20">[21]</ref> Terrastore <ref type="bibr" target="#b14">[15]</ref> RavenDB <ref type="bibr" target="#b48">[50]</ref> Graph-Oriented (Section 7) Neo4J <ref type="bibr" target="#b77">[80]</ref> InfiniteGraph <ref type="bibr" target="#b80">[83]</ref> InfoGrid <ref type="bibr" target="#b78">[81]</ref> HypergraphDB <ref type="bibr" target="#b52">[55]</ref> AllegroGraph <ref type="bibr" target="#b0">[1]</ref> BigData <ref type="bibr" target="#b106">[109]</ref> 3 Apache Pig Web Site, https://pig.apache.org/. 4 NuoDB Web Page, http://www.nuodb.com/. The rest of the paper is organized as follows. Section 2 explores related reviews and benchmarking tools used to compare NoSQL databases. Section 3 describes some preliminary concepts that need to be explained before starting with the description and analysis of the different implementations of databases available on the market. Section 4 introduces Key-Value databases. Section 5 presents Wide Column or Column Families databases. Document-oriented and Graph-oriented databases are described in Sections 6 and 7, respectively. Section 8 offers a discussion about the application of NoSQL databases and when they should be considered in the selection of a data storage support. Finally, Section 9 presents conclusions, perspectives on the findings and tools described, as well as future trends in the area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related works</head><p>There are some works listing and comparing NoSQL databases, exposing their virtues and weaknesses. Catell <ref type="bibr" target="#b18">[19]</ref> analyzed and compared several databases with respect to their concurrency control methods, where they store data (i.e., in main memory or disk), the replication mechanism used (synchronous or asynchronous), and their transaction support. This comparison includes both commercial and non-commercial databases but does not include Graph-oriented databases, which are generally considered part of NoSQL. As indicated previously, graphs are the essential data layout of Web applications such as social networks <ref type="bibr" target="#b60">[63]</ref>. Similarly, Padhy et al. <ref type="bibr" target="#b85">[88]</ref> present a comparison of six relevant NoSQL databases, including databases of different type or schema model. They also exclude from their analysis Graph-oriented databases and other relevant implementations of NoSQL databases. Hecht and Jablonski <ref type="bibr" target="#b47">[49]</ref> present another comparison between NoSQL databases, including graph databases. The authors focus on data partitioning and replication aspects over 14 NoSQL databases, whereas in this paper we perform a more in-depth analysis over 19 databases.</p><p>Other studies <ref type="bibr" target="#b107">[110,</ref><ref type="bibr" target="#b104">107,</ref><ref type="bibr" target="#b112">115]</ref> list the most influential NoSQL databases along with their characteristics and basic concepts. However, they do not include a full comparison between databases, since they only expose some of their advantages and disadvantages.</p><p>There are other studies that analyze NoSQL databases using a given dataset or application. For example, Sakr et al. <ref type="bibr" target="#b92">[95]</ref> carried out a thorough analysis of data stores suited for Cloud Computing environments <ref type="bibr" target="#b17">[18]</ref>, which includes NoSQL databases. The authors present a set of goals that a data-intensive application should accomplish in the Cloud. They also describe essential structures and algorithms of well-known databases such as BigTable and Dynamo. In addition, they compare several APIs related to massive data query and manipulation.</p><p>Another comparison of NoSQL databases in this line is presented by Orend <ref type="bibr" target="#b83">[86]</ref>. The ultimate goal of the study was to select a NoSQL solution for a Web Collaboration and Knowledge Management Software. MongoDB, a Documentoriented database, was selected from the available databases because of its support for queries on multiple fields.</p><p>Then, the study makes a performance comparison of MongoDB against MySQL and HyperSQL.</p><p>Todurica and Bucur <ref type="bibr" target="#b110">[113]</ref> provide an extensive list of available NoSQL databases, and benchmark two of them -Cassandra and HBaseagainst MySQL and Sherpa, a variation of MySQL. Their results indicate that, at high load, Cassandra and HBase keep their response latency relatively constant, whereas MySQL and Sherpa increase their response latency. On the other hand, Lith and Mattson <ref type="bibr" target="#b68">[71]</ref> present a study based on an application of their own where a MySQL-based approach gives better performance than using a NoSQL solution. In the study, five NoSQL databases were considered. The authors claim that the difference in performance is due to the application data structure and the way it is accessed.</p><p>Although this work does not focus on database benchmarking, it is worth mentioning some of the existing benchmarks and benchmarking tools that may complement the analysis carried out in this review. Benchmarks are very important to determine strengths and weaknesses of each database under different stress scenarios and deployment environments. YCSB <ref type="bibr" target="#b22">[23]</ref> (Yahoo Cloud Serving Benchmark) is one of the most relevant frameworks for benchmarking both NoSQL and RDBMS databases. It provides an extensible framework for querying databases and a workload generator to benchmark various access patterns. Recent extensions of YCSB can be found in the literature, including the use of distributed clients <ref type="bibr" target="#b86">[89]</ref> and support for transactional operations <ref type="bibr" target="#b31">[33]</ref>. LinkBench <ref type="bibr" target="#b6">[6]</ref> takes a similar approach to YCSB, but targets graphstructured data, in particular, the Facebook social graph. Other efforts explore different types of databases and workloads. For example, HiBench <ref type="bibr" target="#b51">[53]</ref> is designed for Hadoop and uses a set of microbenchmarks as well as realworld application workloads. In an attempt to create realworld scenarios, some benchmarks such as BigBench <ref type="bibr" target="#b39">[41]</ref> and BigDataBench <ref type="bibr" target="#b114">[117]</ref> focus their efforts on querying different data types, such as structured, semi-structured and unstructured data, under diverse types of workload.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Background concepts</head><p>This section covers background concepts required to understand the decisions taken in the design of NoSQL databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">The CAP theorem</head><p>A fundamental trade-off that affects any distributed system forces database designers to choose only two out of these three properties: data consistency, system availability or tolerance to network partitions. This intrinsic limitation of distributed systems is known as the CAP theorem, or Brewer's theorem <ref type="bibr" target="#b42">[44]</ref>, which states that it is impossible to simultaneously guarantee the following properties in a distributed system: Consistency: If this attribute is met, it is guaranteed that once data are written they are available and up to date for every user using the system. Availability: This property refers to offering the service uninterruptedly and without degradation within a certain percentage of time.</p><p>Partition Tolerance: If the system meets this property, then an operation can be completed even when some part of the network fails.</p><p>In 2000, Eric Brewer conjectured that at any given moment in time only two out of the three mentioned characteristics can be guaranteed. A few years later, Gilbert and Lynch <ref type="bibr" target="#b42">[44]</ref> formalized and proved this conjecture, concluding that only distributed systems accomplishing the following combinations can be created: AP (Availability-Partition Tolerance), CP (Consistency-Partition Tolerance) or AC (Availability-Consistency). Table <ref type="table" target="#tab_2">2</ref> summarizes NoSQL databases reviewed in this paper organized according to the supported data layout. Within each group, databases are further grouped according to the properties of the CAP theorem they exhibit. As illustrated, most of the surveyed databases fall in the "AP" or the "CP" group. This is because resigning P (Partition Tolerance) in a distributed system means assuming that the underlying network will never drop packages or disconnect, which is not feasible. There are few exceptions to this rule given by NoSQL databasese.g., Infinispan <ref type="bibr" target="#b72">[75]</ref> that are able to relax "P" while providing "A" and "C". Because some databases, such as Infinispan and MongoDB, can be configured to provide full consistency guarantees (sacrificing some availability) or eventual consistency (providing high availability), they appear in both AP and CP columns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">ACID and BASE properties</head><p>In 1970, Jim Gray proposed the concept of transaction <ref type="bibr" target="#b44">[46]</ref>, a work unit in a database system that contains a set of operations. For a transaction to behave in a safe manner it should exhibit four main properties: atomicity, consistency, isolation and durability. These properties, known as ACID, increase the complexity of database systems design and even more on distributed databases, which spread out data in multiple partitions throughout a computer network. This feature, however, simplifies the work of the developer by guaranteeing that every operation will leave the database in a consistent state. In this context, operations are susceptible to failures and delays of the network itself. Extra precautions should be taken to guarantee the success of a transaction.</p><p>Distributed RDBMSs allow, for some time now, to perform transactions using specific protocols to maintain the consistency of data across the partitions. An example of this type of RDBMs is Megastore <ref type="bibr" target="#b9">[9]</ref> a distributed database that supports ACID transactions in specific tables and limited transaction support across different data tables. Megastore is supported by BigTable <ref type="bibr" target="#b19">[20]</ref> (Section 5.1), but unlike BigTable, it provides a schema language that supports hierarchical relationships between tables, providing a semi-relational model. Although Megastore did not provide good performance <ref type="bibr" target="#b24">[25]</ref> (in comparison to using directly BigTable), several applications needed the simplicity of the schema and the guarantees of replica synchronization. As in many databases, replicas in Megastore are synchronized using a variation of the Paxos algorithm <ref type="bibr" target="#b63">[66]</ref>. The idea of hierarchical semi-relational schemas was then used by Spanner, a global-scale database that supports transactions, based on a timestamp API implemented using GPS and atomic clocks. These high-precision timestamps allowed Spanner to reduce the latency of transaction processing. Spanner thus served as the new supporting storage of the revenue-critical AdSense service backend, called F1 <ref type="bibr" target="#b97">[100]</ref>, which was previously supported by a sharded MySQL-based solution. F1 is a globally consistent and replicated database developed for supporting Google advertising services. F1 is a rather extreme example showing how hard building consistent distributed databases is, while, at the same time, meeting performance requirements.</p><p>In these systems, one of the most commonly used protocols for this purpose is 2PC (Two-phase commit), which has been instrumental in the execution of transactions in distributed environments. The application of this protocol has spread even to the field of Web Services <ref type="bibr" target="#b26">[27]</ref>, allowing transactions in REST (REpresentational State Transfer) architectures otherwise not possible <ref type="bibr" target="#b28">[29]</ref>. The 2PC protocol consists of two main parts: 1. A stage in which a coordinator component asks to the databases implicated by the transaction to do a precommit operation. If all of the databases can fulfill the operation, stage 2 takes place. Conversely, if any of the databases rejects the transaction (or fails to respond), then all databases roll back their changes. 2. The coordinator asks the databases to perform a commit operation. If any of the databases rejects the commit, then a rollback of the databases is carried out.</p><p>According to the CAP theorem the use of a protocol, such as 2PC (i.e., in a CP system) impacts negatively on system  availability. This means that if a database fails (e.g., due to a hardware malfunction), all transactions performed during the outage will fail. In order to measure the extent of this impact, an operation availability can be calculated as the product of the individual availability of the components involved in such operation. For example, if each database partition has a 99.9% of availability, i.e., 43 min out of service are allowed per month, a commit using 2PC over 2 partitions reduces the availability to 99.8%, which is translated to 86 min per month out of service <ref type="bibr" target="#b88">[91]</ref>. Additionally, 2PC is a blocking protocol, which means that the databases involved in a transaction cannot be used in parallel while a commit is in progress. This increases system latency as the number of transactions occurring simultaneously grows. Because of this, many NoSQL databases approaches decided to relax the consistency restrictions. These approaches are known as BASE (Basically Available, Soft State, Eventually Consistent) <ref type="bibr" target="#b88">[91]</ref>. The idea behind the systems implementing this concept is to allow partial failures instead of a full system failure, which leads to a perception of a greater system availability.</p><p>The design of BASE systems, and in particular BASE NoSQL databases, allows certain operations to be performed leaving the replicas (i.e., copies of the data) in an inconsistent state. As its name indicates, BASE systems prioritize availability by introducing replicated soft state, i.e., each partition may fail and be reconstructed from replicas. Besides, these systems also establish a mechanism to synchronize replicas. Precisely, this mechanism is known as Eventual Consistency, a technique that solves inconsistencies based on some criteria that ensures to return to a consistent state. Although Eventual Consistency provides no guarantees that clients will read the same value from all replicas, the bounds for stalled reads are acceptable for many applications considering the latency improvements. Moreover, the expected bounds for stalled reads have been analyzed by Bailis et al. <ref type="bibr" target="#b8">[8]</ref>. For example, the Cassandra NoSQL database <ref type="bibr" target="#b61">[64]</ref> implements the following high-level update policies:</p><p>Read-repair: Inconsistencies are corrected during data reading. This means that writing might leave some inconsistencies behind, which will only be solved after a reading operation. In this process, a coordinator component reads from a set of replicas and, if it finds inconsistent values, then it is responsible for updating those replicas having stale data, slowing the operation. It is worth noticing that conflicts are only resolved for the data involved in the reading operation.</p><p>Write-repair: When writing to a set of replicas, the coordinator may find that some replicas are unavailable. Using a write-repair policy, the updates are scheduled to run when the replicas become available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Asynchronous-repair:</head><p>The correction is neither part of the reading nor of the writing. Synchronization can be triggered by the elapsed time since the last synchronization, the amount of writes or other event that may indicate that the database is outdated.</p><p>In addition to consistency of reads and writes, in distributed storage systems the concept of durability arises, which is the ability of a given system of persisting data even in the presence of failures. This causes data to be written in a number of non-volatile memory devices before informing the success of an operation to a client. In eventually consistent systems there are mechanisms to calibrate the system durability and consistency <ref type="bibr" target="#b113">[116]</ref>. Next, we will clarify these concepts through an example. Let N be the number of nodes a key is replicated on, W the number of nodes needed to consider a writing as successful and R the number of nodes where a reading is performed on. Table <ref type="table" target="#tab_3">3</ref> shows different configurations of W and R as well as the result of applying such configurations. Each value refers to the number of replicas needed to confirm an operation success.</p><p>Strong Consistency is reached by fulfilling W þ R 4N, i.e., the set of writings and readings overlaps such that one of the readings always obtain the latest version of a piece of data. Usually, RDBMs have W¼N, i.e., all replicas are persisted and R¼1 since any reading will return up-to-date data. Weak Consistency takes place when W þR r N, in which readings can obtain outdated data. Eventual Consistency is a special case of weak consistency in which there are guarantees that if a piece of data is written on the system, it will eventually reach all replicas. This will depend on the network latency, the amount of replicas and the system load, among other factors.</p><p>If writing operations need to be faster, they can be performed over a single or a set of nodes with the disadvantage of less durability. If W¼ 0, the client perceives a faster writing, but the lowest possible durability since there is no confirmation that the writing was successful. In the case of W¼1, it is enough that a single node persists the writing for returning to the client, thereby enhancing durability compared to W¼0. In the same way it is possible to optimize data reading. Setting R ¼0 is not an option, since the same reading confirms the operation. For reading to reach the optimum, R¼1 can be used. In some  situations (e.g., if using Read-repair), it might be necessary to read from all the nodes, this is R ¼N, and then merge the different versions of the data, slowing down such operation. An intermediate scheme for writing or reading is quorum, in which the operation (reading or writing) is done over a subset of nodes. Frequently, the value used for quorum is N=2 þ 1, such that 2 subsequent writings or readings share at least one node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Comparison dimensions</head><p>In this paper, available NoSQL databases are analyzed and compared across a number of dimensions. The dimensions included in the analysis are expected to help in the decision of which NoSQL database is the most appropriate for a given set of requirements of the user's choice. The dimensions considered are the following:</p><p>Persistence: It refers to the method of storing data in non-volatile or persistent devices. Several alternatives are possible, for example, indexes, files, databases and distributed file systems. Another alternative used in some cases is to keep data in RAM and periodically make snapshots of them in persistent media.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Replication: It refers to the replication technique pro-</head><p>vided by the database to ensure high availability. Data is replicated in different computational nodes as backups in case the original node fails when performing writing operations on the NoSQL database. Replication can also mean an increase in performance when reading or writing from the replicas is permitted and, thus, relieving the load on the original node. Depending on the consistency level desired, the clients may be allowed to read stalled versions of the data from the replicas. A classical example of replication is the Master-Slave replication mechanism, in which a "master" node receives all the write operations from the client and replicates them on the "slave" node. When a client is allowed to write on any replica the mechanism is called Master-Master. Using such scheme may lead to inconsistencies among the different replicas.</p><p>Sharding: Data partitioning or sharding <ref type="bibr" target="#b70">[73]</ref> is a techni- que for dividing a dataset into different subsets. Each subset is usually assigned to a computing node, so as to distribute the load due to executing operations. There are different ways of sharding. An example would be hashing the data to be stored and divide the hashing space into multiple ranges, each assigned to a shard. Another example is to use a particular field from the data schema for driving partitioning. A database that supports sharding allows to decouple the developer from the network topology details, automatically managing node addition or remotion. Thus, sharding creates the illusion of a single super node, while in fact there is a large set of nodes. In this paper, the Sharding dimension indicates whether the database supports sharding and how it can be configured. If sharding is not integrated into the database functionality, then the client has to deal with the partitioning of data among nodes.</p><p>Consistency: A large number of NoSQL databases are designed to allow concurrent readings and/or writings and, therefore, control mechanisms are used to maintain data integrity without losing performance. This dimension indicates the type of consistency provided by a database (ACID transactions or eventual consistency) and the methods used to access data concurrently. API: It refers to the type of programming interface used to access the database. In general, NoSQL databases in the Web era allow access through the HTTP protocol. However, accessing a database using an HTTP client is cumbersome for the developer, and hence it is common to find native clients in certain programming languages. This dimension lists the programming languages that have native clients for the current database. In addition, the message format that is used to add or modify items in the database is indicated.</p><p>Query Method: It describes the methods to access the database and lists the different ways of accessing these methods through the database API. This dimension indicates the strategies or query languages supported by each database.</p><p>Implementation Language: It describes the programming language the database is implemented with. In some cases, it may indicate a preference of the database developer for a particular required technology.</p><p>Only databases that persist data on disk, providing a considerable degree of durability, are analyzed in this paper. That is, when a user performs a writing operation on the database, data is eventually stored in a non-volatile device such as a hard disk. Moreover, we considered only databases that aim at increasing performance or storage capacity by adding new nodes to the network. There are several databases that store their data structures in main memory <ref type="bibr" target="#b84">[87,</ref><ref type="bibr" target="#b103">106]</ref> and use a persistent, disk-based log as a backup (i.e., in case of power outages, the database must be rebuilt from this backup). This new trend of in-memory databases is often targeted to applications with lowlatency requirements, such as real-time applications. However, despite the sustained drop in prices of RAM memory, the gap in costs with hard-disk drives is still noticeable, especially if building a support for large-scale data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Key-Value databases</head><p>Databases belonging to this group are, essentially, distributed hash tables that provide at least two operations: get(key) and put(key, value). A Key-Value database maps data items to a key space that is used both for allocating key/value pairs to computers and to efficiently locate a value, given its key. These databases are designed to scale to terabytes or even petabytes as well as millions of simultaneous operations by horizontally adding computers.</p><p>A simple example of a key-value store, shown in Fig. <ref type="figure" target="#fig_7">1</ref>, is a distributed web content service where each key represents the URL of the element and the value may be anything from PDFs and JPEGs to JSON or XML documents. This way, the application designers may leverage the The following sections enumerate some techniques used in Key-Value databases. In Section 4.1 we describe Consistent Hashing, a mechanism frequently used to distribute keys among nodes. In Section 4.2 we describe Virtual Buckets, an alternative mechanism used to distribute keys among nodes. In Section 4.3, we describe a set of techniques used by Dynamo [32], a Key-Value store created by Amazon that influenced several other databases. In Section 4.4 we describe some of the most notorious Key-Value databases available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Consistent hashing</head><p>Key-Value stores commonly allocate key/value pairs by applying some hashing function to the key and using the result to obtain a specific node of the physical network where the value will be finally stored. The distribution of keys using a standard hashing allocation mechanism (i.e., based on the amount of computers in the network) is sensible to node failures, i.e., if one of the nodes is not available, all the key/value pairs need to be reallocated because of the change in the size of the network. Several databases [32, <ref type="bibr" target="#b100">103,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr">11,</ref><ref type="bibr" target="#b72">75]</ref> take advantage of the concept of Consistent Hashing <ref type="bibr" target="#b57">[60,</ref><ref type="bibr" target="#b58">61]</ref> to deal with this situation.</p><p>Consistent Hashing models a key space of size K as a circular array or key ring (i.e., the successor of key K À 1 is the 0 key). Thereby, the original key is hashed to fit the 0; K ½ Þ range and each of the N nodes in the system is assigned a range of contiguous keys. In its simplest form, Consistent Hashing assigns ranges of K=N keys to nodes, although ranges can vary according to each node's characteristics (larger ranges may be assigned to nodes with larger capacity). If one of the nodes in the ring fails, only the keys belonging to such node should be rebalanced, putting them in the next node. Using this scheme, key replication can be performed in the N À1 nodes succeeding each node in the keyring.</p><p>The problem of using physical nodes for partitioning the key space is that successive changes in the network, such as the failure or addition of new nodes may unbalance the distribution of keys among nodes (i.e., how many keys a node is responsible for). This problem is further accentuated when the network has heterogeneous hardware, for example if a node is serving as failover of a node with greater capacity.</p><p>An improvement over this partitioning scheme is to create virtual nodes, as proposed in Dynamo's [32] implementation. In this technique, instead of assigning a single contiguous range of keys to each node, a node may be responsible for one or more key ranges that act as virtual nodes in the keyring. In consequence, when one node crashes, its assigned key ranges are distributed among different physical nodes. Similarly, when a new physical node is added, it creates new virtual nodes in the keyring and may receive data from different physical nodes.</p><p>Fig. <ref type="figure" target="#fig_8">2</ref> shows an example of using virtual nodes distribution. In the figure it can be seen that the virtual nodes A, C and F are stored in the physical node 1, the virtual nodes B, D and G in the physical node 2 and the virtual node E on the physical node 3. In this example, the virtual node A is responsible for storing the keys in the range (G, A]. Also, the virtual node A is responsible for replicating data about the keys on the precedent N À 1 ranges. If N equals to 2, A would be responsible for replicating the keys in the range (F, G]. The rest of the virtual nodes behave similarly.</p><p>If the physical node 2 fails, then the range of keys (F, G] becomes part of the virtual node A, the range (A, B] moves to the virtual node C and the range (C, D] to the virtual node E. Then, the keyset is distributed among the physical nodes 1 and 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Virtual buckets</head><p>Like Consistent Hashing, Virtual Buckets or vBuckets is a technique introduced by Membase/CouchBase <ref type="bibr" target="#b25">[26]</ref> to overcome the problem of redistributing keys when a node fails. Similar to Consistent Hashing, vBuckets provide a level of indirection between keys and server addresses. The aim of vBuckets is dividing the key space in a fixed amount of vBuckets (e.g., 4096) and map every vBucket to a server.</p><p>From a server perspective, a vBucket can be in one of three states: Available: The current server contains the data about the vBucket.   From a client perspective, only one server can serve requests for a given vBucket.</p><p>As a result, Available vBuckets can be replicated to other servers by using the corresponding vBuckets marked as Dead. In this way, replication can be set in a 1: N or a chained configuration. In the first case, every vBucket replicates to N servers. On the other hand, in a chained configuration, a vBucket replicates to another server, and in turn, the replicated vBucket has a replica on a third server. Fig. <ref type="figure" target="#fig_9">3</ref> shows a possible vBuckets scenario where the amount of vBuckets is 5 and the replication scheme is 1: N. The vBuckets marked as "A" are available vBuckets, whereas vBuckets marked as "R" are replicas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Dynamo-based mechanisms</head><p>One of the most influential databases in the development of highly scalable Key-Value databases is Amazon's Dynamo <ref type="bibr">[32]</ref>. Dynamo was used for the shopping cart and session management service of Amazon, each supporting tens of millions of requests. This database proved to be a highly available system in addition to meet strong latency requirements <ref type="bibr">[32]</ref>. Then, Dynamo offers data storage and access mechanisms that represent the inspiration of many existing Key-Value databases.</p><p>The most important techniques involved in the implementation of Dynamo are introduced below:</p><p>Vector clocks: Dynamo provides eventual consistency, which allows to achieve high availability. Inconsistencies are solved during reading (read-repair), which implies that a writing can return to the client before the actual writing has spread to all replicas. The different values are unified using a versioning scheme known as vector clocks <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b62">65]</ref>. Originally proposed by Leslie Lamport <ref type="bibr" target="#b62">[65]</ref> in 1978, a vector clock is a structure containing a list of pairs (physical node, counter). One vector clock is associated with every version of every key/value pair. This versioning scheme allows nodes to discard old versions of the same object (if all counters are less or equal than the current counters), or to reconcile conflicted versions. The latter case arises when the same version of an object is modified in different servers, leading to inconsistencies in the state of that object. For example, if a user modifies the same version of a shopping cart from different clients (e.g. a notebook and a phone), these two modifications may be handled by different servers. Due to eventual consistency, the servers may not be aware of the modifications carried out on other servers, creating two valid versions of the same cart. The reconciliation mechanism can be automatic, e.g. the different versions of a shopping cart can be merged adding all items into a unique cart, which may involve that items deleted by the user appear again in the cart.</p><p>Sloppy quorum and hinted handoff: Sloppy quorum persists (or reads) an element on the first N available nodes of a preference list when the node's replicas are not available. Then, some copies of the data to be written can be found in nodes that are not replicas of such data. When this situation occurs, the node receives, along with the data, a hint about the copy owner. This mechanism, known as Hinted Handoff, along with Sloppy Quorum, allows the client to return as soon as possible without waiting to persist data in all replicas.</p><p>Merkle trees: For persistent failures in which hinted copies cannot return to the original replica, elements of the remaining replicas must be re-synchronized by detecting outdated keys. Comparing the keys one by one according to their hash value can take too long and consume a lot of bandwidth. Dynamo uses a tree structure known as Merkle Tree <ref type="bibr" target="#b75">[78]</ref> where each node represents a hash value, calculated starting from their children, which in turn are also hashes. The leaves of the tree are the hash values calculated using the stored keys. This allows a fast comparison of sets of keys, but updating a key range when a node fails can be expensive.</p><p>Dynamo implements all the concepts described above to create a highly scalable and available system. However, it is a proprietary system used within Amazon and only accessible through the services provided by the company. There are, nevertheless, several open-source implementations of Dynamo and other Key-Value databases that can be installed in a network. The next section summarizes some of the relevant databases in this line.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Discussion of Key-Value databases</head><p>Table <ref type="table" target="#tab_4">4</ref> summarizes several relevant Key-Value databases that support persistent storage and distribution. Other databases such as Kyoto Cabinet <ref type="bibr" target="#b34">[36]</ref>, LevelDB <ref type="bibr" target="#b43">[45]</ref>, Memcached <ref type="bibr" target="#b36">[38]</ref>, BerkeleyDB <ref type="bibr" target="#b82">[85]</ref> and Scalaris <ref type="bibr" target="#b95">[98]</ref> were excluded from this review since they do not meet these requirements.</p><p>The listed databases are Riak [11], Infinispan <ref type="bibr" target="#b72">[75]</ref>, Hazelcast <ref type="bibr" target="#b46">[48]</ref>, Redis <ref type="bibr" target="#b94">[97]</ref>, Membase/CouchBase <ref type="bibr" target="#b25">[26]</ref> and Voldemort <ref type="bibr" target="#b67">[70]</ref>. At the time of writing this review, all of these databases were under active development and heavily employed by some user community. This means that each database is supported by a group of developers releasing periodical updates, fixing bugs and incorporating new functionality. Since adopting a currently active database for a new project assures the existence of documentation and assistance from those responsible for the database software, persistent and distributed databases whose development has been abandoned were not included in the comparison. The Key-Value databases analyzed are described below:</p><p>Riak and voldemort: Among the listed databases, the ones which are more related to Dynamo are Riak and Voldemort since they are direct implementations of the associated Amazon specification <ref type="bibr">[32]</ref>. Hence, they use consistent hashing for partitioning and replicating, and provide eventual consistency based on read-repair.</p><p>Redis: Redis is distinguished for providing more complex structures such as lists, hash tables, sets and ordered sets for representing values. This functionality makes Redis very similar to Document-oriented databases, which are described in Section 6. However, in Redis, different keys may have different type of values, i.e. one key can refer to a list and the other key can refer to a set. In Documentoriented databases, all values are documents of the same schema. One limitation of Redis is that sharding has to be performed by the client application, which implies that the client must know the network topology to distribute keys among nodes.</p><p>Infinispan: Infinispan, formerly known as JBoss Cache, was born as a support tool to scale up Web applications and achieve fault tolerance in the well-known JBoss Application Server. In particular, JBoss Cache was used to replicate and synchronize session state among servers in a cluster of JBoss servers. The main difference with the other databases is that Infinispan has traditionally been biased towards consistency and availability, sacrificing partition tolerance.</p><p>Hazelcast: Hazelcast differs from the rest of the reviewed Key-Value databases in that it easily and seamlessly integrates with existing non-distributed Java programs. To achieve this, Hazelcast provides distributed implementations of the typical built-in Java data structures such as List, Vector, Set, and Hashtable. Then, using Hazelcast in a program is just a matter of replacing Java import statements in the client code, and then tuning several parameters such as nodes belonging to the cluster, replication mode, distributed data structures used, etc. Hazelcast does not provide persistence support by default, but allows developers to define their own storage support, which can be persistent instead.</p><p>Membase: Membase is a Key-Value database that has been recently merged with the Document-oriented database CouchBase. It uses the vBuckets mechanism to distribute and replicate data across servers. Writing consistency is immediate because writing and reading is always performed on the key's master node (which has the only Available vBucket). Thus, a client always gets the latest value written. One of the most attractive features of CouchBase is its configuration simplicity. Once installed on the nodes, the network can be configured through a friendly Web interface. On the downside, Membase requires manual rebalancing of keys when a server is down and needs to be removed from the cluster. Key rebalancing is a costly operation that depends on the amount of keys handled by the removed server.  Hazelcast and Redis keep all key/value pairs in memory and eventually persist them on disk. In all cases, new requests to add keys are rejected when RAM runs out of space. For this reason, it is necessary to take into account whether the number of keys to be stored exceeds the amount of RAM in the network and, if this is the case, chose another alternative or augment the network size.</p><p>A further feature to consider in the selection of a database is the expected data durability. The level of durability must be decided according to the importance of the data stored in the network, which sometimes can be configured. Redis is a case of configurable durability. By default, Redis offers the possibility of making data snapshots in memory at time intervals. If a failure occurs during such interval, the current data of the node are lost. For this reason, the database offers to do more frequent writings to disk in a file that only supports appends. Conceptually, this is similar to a log in a log-structured file system. This type of files is often used when high writing throughput needs to be achieved.</p><p>The query method varies from database to database, but the Get operation (i.e., get a value by key) is always present. Some alternative query methods are worth mentioning. For example, Riak provides a graph-like querying method called Link Walking. This method consists in creating relationships between keys and tagging each relationship. For example, if there is a relationship tagged "friend" between a key named "Mark" and all its friends' keys, Riak can be queried using the "friend" tag to obtain all Mark's friends. Other databases provide alternative query methods like Cursors (a wellknown structure in SQL), XQuery (an XML Query language) and even MapReduce (Section 5.1.3). Some databases also allow the user to perform "bulk gets", i.e., getting the values of several keys in a single operation, resulting in considerable performance improvements and network communication savings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Wide column databases</head><p>Wide Column or Column Families databases store data by columns and do not impose a rigid scheme to user data. This means that some rows may or may not have columns of a certain type. Moreover, since data stored by column have the same data type, compression algorithms can be used to decrease the required space. It is also possible to do functional partitioning per column so that columns that are frequently accessed are placed in the same physical location.</p><p>Most databases in this category are inspired by BigTable <ref type="bibr" target="#b19">[20]</ref>, an ordered, multidimensional, sparse, distributed and persistent database, that was created by Google to store data in the order of petabytes. Therefore, a brief description of the most important features of BigTable and how it achieves its objectives is given in the following section.</p><p>Unlike Key-Value databases, all Wide-Column databases listed in this section are based on BigTable's data scheme or mechanisms. This lack of diversity can be explained by the fact that this type of databases has a very specific objective: to store terabytes of tuples with arbitrary columns in a distributed environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">BigTable</head><p>BigTable <ref type="bibr" target="#b19">[20]</ref> was developed in order to accommodate the information from several Google services: Google Earth, Google Maps and Blogger, among others. These applications use BigTable for different purposes, from high throughput batch job processing, to data provisioning to the end user considering data latency constraints. BigTable does not provide a relational model, which allows the client application to have complete control over data format and arrangement.</p><p>In BigTable, all data are arrays of bytes indexed by columns and rows, whose names can be arbitrary strings. In addition, a timestamp dimension is added to each table to store different versions of the data, for example the text of a Web page. Moreover, columns are grouped into sets called column families. For example, the column family course can have Biology and Math columns, which are represented as course:Biology and course:Math. Column families usually have the same type of data, with the goal of being compressed. Moreover, disk and memory access is optimized and controlled according to column families.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1.">SSTable, tablets and tables</head><p>BigTable works on the GFS (Google File System) [42,43] distributed file system and has three types for storage structures: SSTables, Tablets and Tables, which are shown in Fig. <ref type="figure" target="#fig_12">4</ref>. SSTable is the most basic structure, which provides an ordered key/value map of byte strings. This basic block consists of a sequence of blocks (usually of 64 KB) and a search index to determine which block is a certain datum, avoiding the unnecessary load of other blocks in memory and decreasing disk operations. Each SSTable is immutable, so no concurrency control is needed for reading. A garbage collector is required to free deleted SSTables.</p><p>A set of SSTables is called a Tablet. A Tablet is a structure that groups a range of keys and represents a distribution unit for load balancing. Each table is composed of multiple tablets and, as the table grows, it is divided into more Tablets. The sub-Tables often have a fixed size of 100-200 MB.</p><p>The location of each Tablet is stored in the network nodes using a tree structure of three levels, like a Bþ tree. First, the file that contains the physical location of the root can be found. The root of the tree is a special Tablet named Root Tablet. The leaves of the tree are called Metadata Tablets and are responsible for storing the location of the user Tablets.</p><p>Chubby <ref type="bibr" target="#b16">[17]</ref>, a distributed lock service, is used to find and access each Tablet. Chubby keeps the location of the Root Tablet, information about the database scheme (the column families and tables) and access checklists. In addition, it synchronizes and detects Tablets nodes (a.k.a. servers) that store Tablets.</p><p>A Master Server is in charge of assigning Tablets to Tablet servers. The Master Server monitors the addition and expiration of Tablet servers, balances the load of such servers and performs garbage collection of files stored in the GFS. It also monitors changes in the scheme, i.e., addition of new column families and Tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2.">Tablets servers</head><p>Fig. <ref type="figure" target="#fig_13">5</ref> depicts how a Tablet is stored on a Tablet server. The updates performed on Tablets belonging to a Tablet Server are stored in a Commit log that saves records to redo committed operations in case that the Tablet Server dies. The most recent records are kept in memory in a buffer known as Memtable.</p><p>To obtain a Tablet the server reads from a table called METADATA that contains the list of SSTables that form a Tablet and a set of pointers to the Commit log called redo points. The server then applies the updates carried out starting from the redo points to rebuild the memtable. Finally, to read from a Tablet, the Tablet Server forms a merged view from the set of SSTables and the memtable.</p><p>For writing operations, after verifying that the operation is well formed and that the user is authorized (through Chubby), a valid mutation (write, update or delete) is registered in the Commit log. Groups of commits are used to improve the throughput of small mutations. After making the commit, its content is inserted into the memtable. If a certain limit of the memtable is exceeded, a new memtable is created, the previous memtable is transformed into a SSTable.</p><p>For reading operations, well-formedness and authorization are also checked, after which the user is presented with a joint view of the SSTables sequence and the memtable. Thus, the latest updates are shown to the user without keeping the last SSTables on disk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3.">MapReduce</head><p>MapReduce is a framework based on the division of labor for parallelizing data-intensive computations on large datasets <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b66">69]</ref>. Basically, this framework consists of two programming abstractions that must be instantiated by programmers: map and reduce. The map function is responsible for processing key-value pairs and generating as output a set of key-value pairs with intermediate results. In turn, the reduce function is responsible for generating a list of results from such intermediate results. As MapReduce consists of programming abstractions, a support materializing them at the middleware level including storage support is needed McCreadie et al. <ref type="bibr" target="#b73">[76]</ref>.</p><p>BigTable (and many other databases) supports passing data to map jobs and storing data from reduce jobs by defining input and output wrappers for MapReduce. This way, MapReduce jobs allow to query and transform data stored in BigTable in parallel, provided that queries can be expressed in this paradigm.</p><p>MapReduce queries can be written in an imperative language like Java or C, although even relatively simple queries can often span multiple lines of code. For example, in Java, implementing a distributed summatory using a list of values requires creating a "map" method to divide the list to create jobs, and implementing a "reduce" method that sums the results of the tasks. The task of dividing a list of elements into jobs and summing the results can be easily generalized and offered as a generic operation. For this reason, Google developed Sawzall <ref type="bibr" target="#b87">[90]</ref>, an interpreted procedural language to act as an interface to MapReduce. Sawzall focuses on providing "syntactic sugar" that allows programmers to implement the map function of MapReduce, i.e., query operations, at a higher level of abstraction. First, the code is interpreted and distributed among the different nodes where the files to be processed are located. The first three lines define how to aggregate results. The table count stores the amount of records found, total stores the sum of floating point numbers, and sum_of_squares stores the sum of squares. The predefined variable input holds the input record that, in this case, it is interpreted like a floating point number and stored in the x variable. Hence, the last three lines aggregate the intermediate values in the result tables. Usually, aggregations are performed in other "aggregator" nodes that receive intermediate data and combine them. Finally, when all records have been read the values are displayed or stored in a file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">List of Wide-Column databases</head><p>BigTable is a system used internally by Google, i.e., the community has no access to its source code or executables.</p><p>However, several open source alternatives offering similar services were developed based on the academic publications made by the company.</p><p>Table <ref type="table" target="#tab_6">5</ref> summarizes these alternatives. The table compares the HBase <ref type="bibr" target="#b38">[40]</ref>, Hypertable <ref type="bibr">[54]</ref> and Cassandra <ref type="bibr" target="#b61">[64]</ref> databases. Following, we further describe them:</p><p>HBase and hypertable: HBase belongs to the Apache Software Foundation and it is based directly on BigTable. The storage support is HDFS (Hadoop Distributed File System) <ref type="bibr" target="#b98">[101]</ref>, which in turn is based on GFS. Hypertable is also modeled based on BigTable, but implemented in C þ þ. Like HBase, Hypertable relies on HDFS for storage and replication. Both databases allow consulting the database using Hadoop MapReduce <ref type="bibr" target="#b98">[101]</ref>, an open source implementation of Google MapReduce. Furthermore, querying is done through languages similar to Sawzall, such as Pig <ref type="bibr" target="#b37">[39]</ref> and Hive <ref type="bibr" target="#b109">[112]</ref>. Querying can also be combined with a workflow scheduler system like Apache Oozie <ref type="bibr" target="#b53">[56]</ref>, which allows the creation of DAGs (Directed Acyclic Graphs) of jobs that obtain data from HDFS.</p><p>Cassandra: Cassandra, which recently moved to the Apache Software Foundation, uses columns and columns families to model data, but uses Dynamo mechanisms to manage storage and replication, namely Consistent Hashing, Read-Repair, Vector Clocks, Gossip Protocol, among others. Cassandra does not have a single point of failure because of its peer-to-peer architecture, which can be considered an advantage. Hypertable or HBase, both based on HDFS, have a single point of failure, the so-called NameNode. This component is a Master Server that manages the file system namespace and controls its access from the clients. The drawback is that this component is unique for the entire file system. NameNode replication can be done by any software that can copy all disk writings to a mirror node. An example of this type of software is DRBD (Distributed Replicated Block Device), a distributed mirroring system analogous to a RAID-1 array <ref type="bibr" target="#b32">[34]</ref>. Another feature of Cassandra is the possibility to choose between two partitioning schemes: Order Preserving Partitioning and Random Partitioning. Order Preserving Partitioning distributes keys in a ring preserving their order. This allows to efficiently perform range queries, i.e., obtain consecutive keys. However, this partitioning scheme tends to unbalance load across nodes, e.g., frequent write operations on a key range may fall on the same node. This problem translates into an administrative overhead to try to distribute key ranges according to their access patterns. Regarding querying, Cassandra offers a SQL-Like query language called CQL (Cassandra Query Language) and Hadoop MapReduce for distributed job processing. The Hadoop support also extends to Pig and Hive query languages, and Apache Oozie. Some of the surveyed databases in this paper provide native clients in many languages with the help of an interface definition language, which specifies the service interface and data types, and a code-generation software, which generates clients and servers in a specified language. Thrift <ref type="bibr" target="#b99">[102]</ref> is an example of such a tool. It allows to specify service interfaces and data types in the Thrift IDL (Interface Definition Language) and, using a set of code-generation tools, create native  It is notable the reduced number of Wide Column databases available with respect to other types of NoSQL databases. In principle, this can be attributed to two reasons. First, the complexity in the development of such databases is considerably high. Considering Bigtable, for example, a storage medium such as GFS, a distributed lock server as Chubby and a Table server similar to the Master Server are required. Second, the application domain of Wide Column databases is limited to particular problems: data to be stored need to be structured and potentially reaching the order of petabytes, but search can only be done through the primary key, i.e., the ID of the row. Queries on certain columns are not possible as this would imply to have an index on the entire dataset or traverse it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Document-oriented databases</head><p>Document-oriented or Document-based databases can be seen as Key-Value databases where the value to store has a known structure determined at database design time. As a consequence, the architecture of these systems is based on several concepts, some of them defined earlier in this work, to achieve scalability, consistency and availability. In contrast to Wide-Column and Key-Value databases, there is no reference Document-oriented database design (like BigTable or Dynamo), which reflects in the diversity of techniques and technologies applied by database vendors.</p><p>In this context, documents are understood as semistructured data types, i.e., they are not fully structured as tables in a relational database, but new fields can be added to the structure of each document according to certain rules. These rules are specified in the standard format or encoding of the stored documents. Some popular document formats are XML, JSON and BSON. Like Wide Column databases, Document-oriented ones are schemaless, i.e., they have no predefined schema data to conform with. Then, the number and type of fields in the documents in the same database may be different.</p><p>Since the database knows the type of data stored, operations that are not available in traditional Key-Value databases become possible in document-oriented databases. Among these operations we can mention add and delete value fields, modify certain fields and query the database by fields. If a Key-Value database is used to store documents, a "document" represents values, and the addition, deletion and modification of fields imply replacing the entire document for a new document. Instead, a Document-oriented database can directly access the fields to carry out the operations.</p><p>In a Key-Value database, queries are performed by providing one or more keys as an input. In Documentoriented databases queries can be done on any field using patterns. Then, ranges, logical operators, wildcards, and more, can be used in queries. The drawback is that for each type of query a new index needs to be created, because document databases index elements by the document identifier. In general, the document identifier is a number that uniquely identifies a document in the database.</p><p>A Document-oriented database is useful when the number of fields cannot be fully determined at application design time. For example, in an image management system, a document could be written in JSON format as follows:</p><p>New features can be added as the system evolves. For example, when updating the previous document with the ability to access the image owner's Web site, a checksum of the image and user ratings, the above document would become:</p><p>New tables must be created to achieve the same goal in a relational database, which can lead to perform joins between tables containing numerous rows or modify the existing table schema, upgrading all rows in the database.</p><p>Table <ref type="table" target="#tab_7">6</ref> summarizes the most representative NoSQL Document-oriented databases: CouchDB <ref type="bibr" target="#b65">[68]</ref>, MongoDB <ref type="bibr" target="#b20">[21]</ref>, Terrastore <ref type="bibr" target="#b14">[15]</ref> and RavenDB <ref type="bibr" target="#b48">[50]</ref>. Following, we describe them:</p><p>CouchDB: CouchDB is a database maintained by the Apache Foundation and supported mostly by two companies: Cloudant and CouchBase. This database uses Multiple Version Concurrency Control (MVCC) <ref type="bibr" target="#b11">[12]</ref> to provide concurrent access to stored documents. This mechanism allows multiple versions of a document to co-exist in the database, similar to the branch concept in a Version Control System (VCS). Each user editing a document receives a snapshot of the current document and after working on it, a version is saved with the most recent timestamp. Earlier versions are not deleted so that readers can continue accessing them. When a reader wants to access the document, the database resolves which is the newest version using the timestamps. This flexibility comes at an extra cost of storage space and has the disadvantage that conflicts between versions of documents might arise. The last issue is usually solved by alerting the client that is trying to write a conflicting version, just like a VCS would. Unlike a VCS, the database must ensure obsolete documents are periodically cleaned, i.e., those that are not in use and correspond to older versions. CouchDB provides ACID transactions only per document, i.e., each operation on a document is atomic, consistent, complete and durable. This is achieved by serializing operations made by clients and never overwriting documents on disk. Replication follows the Master-Master model, i.e., the replicas also serve requests from the clients, both for writing and reading. The goal is that server nodes can be distributed among different networks and clients can write or read from the closest servers. Updates between replicas are bidirectional and, if there are network failures, synchronization waits for the connectivity to be reestablished. This replication approach may result in clients reading old documents from replicas that have not received updates yet. For querying documents, CouchDB uses the concept of views, which is borrowed from RDBMSs. These structures are defined in JavaScript and enable to display structured contents starting from documents. The code of a view is equivalent to the map function of MapReduce, but it is not done in a distributed manner. To overcome this limitation, there are extensions to use CouchDB in a cluster, facilitating the addition and remotion of nodes. As a result, the end user has the illusion that there is only one node. Freely available extensions for distributing CouchDB are Big-Couch <ref type="bibr" target="#b21">[22]</ref>, Lounge <ref type="bibr" target="#b35">[37]</ref> and Pillow <ref type="bibr" target="#b50">[52]</ref>. Additionally, some of these extensions provide an automatic sharding technique such as Consistent Hashing (Section 4.1).</p><p>MongoDB: MongoDB is a free Document-oriented database that runs on a wide range of platforms. It is developed and maintained by the 10gen company. 7 This database implements different techniques for storing documents. Firstly, documents are encoded in BSON, a binary version JSON. BSON provides faster reading and less space usage than JSON. To achieve the former goal, BSON uses prefixes that indicate the size of each element and its position. BSON documents have the disadvantage of having a space limit up to 16 MB. BSON files larger than 16 MB are stored in GridFS <ref type="bibr" target="#b12">[13]</ref>, a distributed file system that allows large files to be split into smaller parts to access them separately, to deal with big files in parallel. Regarding data sharding, MongoDB integrates the functionality for distributing data and queries through different nodes. For this purpose, the database uses a router for queries, called Mongo, which evenly distributes queries to nodes to balance the cluster load. For simpler queries, MongoDB provides an API find() that uses BSON documents to highlight where the fields and query values match. These documents are traversed using a cursor allowing to visit each document matching the query as in a RDBMS. For  Please cite this article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i more advanced queries, that require to group data belonging to multiple documents, MongoDB can run MapReduce jobs. Replication in MongoDB can be achieved through the classic Master-Slave scheme but it also introduces an alternative known as Replica Sets. Like in a Master-Slave schema, Replica Sets allow replicated nodes to be grouped while being one of them the primary node and the remaining are secondary ones, but also offer failover and automatic fail recovery. Optionally, reading can be done from the secondary nodes balancing the load over the Replica set, but reducing the consistency level with respect to the primary node. The goal of the Replica Sets is improving the plain Master-Slave scheme, easing cluster maintenance. For supporting concurrency, MongoDB provides atomic operations per document which means that, when a document is updated using atomic operations, the database ensures that the operation will succeed or fail without leaving inconsistencies. Unlike CouchDB, Mon-goDB does not provides MVCC, whereby readings can be blocked until the atomic operations are completed.</p><p>Terrastore: Another alternative for storing documents in a distributed manner is Terrastore. This database is based on Terracotta <ref type="bibr" target="#b108">[111]</ref>, a distributed application framework based on Java. Documents must follow the JSON notation and can be directly accessed both via HTTP or specific clients in Java, Clojure and Scala, among others. Like MongoDB, Terrastore has integrated sharding support to transparently add and remove nodes. Replication is done using Master-Slave, where slaves are kept in hot-standby, i.e., they can replace the master at any time if it fails. Terracotta operations are consistent at document level and concurrency is handled with the read-committed strategy. Write-locks are used throughout a write transaction, but readings are only blocked for each query or SELECT within the transaction allowing to alternate writing and reading operations. As a result of this strategy, it may be possible that during a transaction a reading returns a value, the document is modified and then the same reading within the transaction returns a different value.</p><p>RavenDB: Finally, RavenDB is an alternative developed on the .Net platform. Although implemented in C#, it provides an HTTP interface to access the database from other languages. ACID transactions are supported, but RavenDB is based on an optimistic transaction scheme to avoid the use of locks. To access stored documents RavenDB allows defining indexes through LINQ queries, a query language developed by Microsoft with a syntax similar to SQL. LINQ queries can define free fields that can be passed as parameters by the user, filtering the indexed documents. A feature that differentiates RavenDB from other Document-oriented databases is the mechanism to configure the sharding of documents. Albeit sharding support is integrated, it is not automatic. The database client must define the shards and strategies to distribute the documents across the different network nodes. One of the major drawbacks of RavenDB is the requirement of a paid license for use in commercial products or services.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Graph-oriented databases</head><p>Nowadays, graphs are used for representing many large real-world entities <ref type="bibr" target="#b60">[63]</ref> such as maps and social networks. For example, OpenStreetMap, an open geographic data repository maintained by a huge user community, reached more than 1800 million nodes in 2013. On the other hand, Twitter has experienced a tremendous growth <ref type="bibr" target="#b5">[5]</ref>, and nowadays has more than 200 million active users tweeting 400 million tweets per day and supporting billions of follower/followed relationships. The interest for storing large graphs and, more importantly, querying them efficiently has resulted in a wide spectrum of NoSQL databases known as Graph-oriented or Graph-based databases. These databases address the problem of storing data and their relationships as a graph, allowing to query and navigate it efficiently. Similar to Document-oriented databases, there is no Graph-oriented database that can be used as a "reference design".</p><p>Browsing graphs stored in a large RDBMS is expensive because each movement through the edges implies a join operation. Usually, Graph-oriented databases represent data and their relationships in a natural way, i.e., using a structure that contains the vertex information and a list of pointers to other vertices. Fig. <ref type="figure" target="#fig_16">6</ref> shows an example where users in a system may have friendship relationships (i.e., undirected edges) and send messages to each other (i.e., directed edges). Undirected edges are commutative and can be stored once, whereas directed edges are often stored in two different structures in order to provide faster access for queries in different directions. Additionally, vertices and edges have specific properties associated to them and thereby, these properties must be stored in separate structures. In this example, a simple sharding policy may involve splitting each table using the vertex ID in order to keep all data related to a single vertex in a single machine.</p><p>In addition to the interest for storing graphs, recent studies have addressed the problem of efficiently processing large graphs stored in a distributed environment. In this context, distributed graph processing presents a challenge in terms of job parallelization. For example, in <ref type="bibr" target="#b23">[24]</ref>, we propose a framework for storing Twitter adjacency lists and query them to efficiently provide recommendations of users to follow. In our experiments, storing 1.4 billion of relationships among 40 million users proved to be challenging in terms of storage and distributed graph algorithm design.</p><p>Generally, graph algorithms are dictated by the arcvertex pairs of the graph being processed, i.e., the execution of the algorithm depends on the structure of the graph. Additionally, a partitioning strategy is difficult to express in source code because the structure of the graph (unlike lists or hashes) is not known a priori. This also directly affects the computing locality, especially in distributed environments. Furthermore, although parallelism can be achieved, the algorithms do not perform too much processing on the vertices, but focus on traversing the graph through their arcs. This generates a significant communication overhead when the vertices are located in different computing nodes <ref type="bibr" target="#b69">[72]</ref>. The former is one of the greatest pitfalls in the application of MapReduce-based frameworks in graph processing <ref type="bibr" target="#b56">[59]</ref>. The problems of MapReduce on graphs have led to the creation of new processing models and frameworks such as Pregel <ref type="bibr" target="#b71">[74]</ref>, Apache Giraph (based on Pregel) <ref type="bibr" target="#b4">[4]</ref>, Trinity <ref type="bibr" target="#b96">[99]</ref>, HipG <ref type="bibr" target="#b60">[63]</ref> or Mizan (also based on Pregel) <ref type="bibr" target="#b59">[62]</ref>. However, graph processing frameworks store all data in memory, i.e., they obtain data from files on disk and load the structure of the graph on each node in RAM to perform processing afterwards. Once processing is completed, updates made on the graph residing in main memory are not persisted. In this survey, special attention is paid to those databases that allow persisting data and, therefore, frameworks for intensive graph computing are not included in the comparison.</p><p>Then, Table <ref type="table" target="#tab_8">7</ref> presents a comparison between the following Graph-oriented databases: Neo4J <ref type="bibr" target="#b77">[80]</ref>, Infinite-Graph <ref type="bibr" target="#b80">[83]</ref>, InfoGrid <ref type="bibr" target="#b78">[81]</ref>, HyperGraph <ref type="bibr" target="#b52">[55]</ref>, AllegroGraph <ref type="bibr" target="#b0">[1]</ref> and BigData <ref type="bibr" target="#b106">[109]</ref>. As mentioned before, open source or free distributed Graph-oriented databases are presented, limited to those providing some type of persistence and bringing a certain durability. Furthermore, we provide a description of the Graph-oriented databases analyzed:</p><p>Neo4J: Neo4J is an open source project that uses Lucene indexes to store data so that access to vertices and   relationships is more efficient. Neo4J also uses an MVCC mechanism with a read-committed strategy to increase reading and writing concurrency. These decisions enable the storage of millions of vertices in a single computational node. In Neo4J, sharding of the vertices across nodes is done manually (by the developer) using domain-specific knowledge and access patterns. Additionally, a periodical defragmentation (vertex relocation) using rules has been proposed but not implemented yet. <ref type="foot" target="#foot_1">8</ref> A Neo4J graph is accessed via a Java API or graph query languages such as SparQL <ref type="bibr" target="#b89">[92]</ref> or Gremlin <ref type="bibr" target="#b90">[93]</ref>. SparQL is a language used for querying data stored in RDF (Resource Description Framework) format, a metadata data model originally created by the World Wide Web Consortium (W3C) to describe resources (i.e., adding semantic information) on the Web. In general, RDF data are stored as 3-tuples indicating a subject, a predicate and an object. Intrinsically, it represents a labeled directed graph: the source vertex, the relationship type and the destination vertex. Gremlin is a language for doing graph traversal over graphs stored in various formats. In addition to a free version, Neo4J has enterprise versions that add monitoring, online backup and high availability clustering. The Neo4J module that enables to define a Master-Slaves node structure is only available in the paid version.</p><formula xml:id="formula_0">C þ þ C þ þ,</formula><p>InfiniteGraph: InfiniteGraph has its own storage media called Objectivity/DB. Unlike Neo4J, it features automatic sharding using "managed placement" to distribute a graph over a cluster. Managed placement allows the user to define rules for custom sharding and, for example, keep related vertices close to each other. Unfortunately, the free license allows storing just 1 million edges and vertices.</p><p>InfoGrid:</p><p>InfoGrid is an open-source storage based on structures known as NetMeshBase, which contains the vertices of the graph, called MeshObjects, and its relationships. It can be persisted using a RDBMS like MySQL or PostgresSQL, or using a distributed file system like HDFS or Amazon S3. If a distributed file system like HDFS is used, the benefits of availability and performance of the system can be attained. Furthermore, NetMeshBase structures can communicate with each other so that graphs can be distributed among different clusters.</p><p>HyperGraphDB: HyperGraphDB <ref type="bibr" target="#b52">[55]</ref> introduces a different approach for representing stored data through the use of hypergraphs. A hypergraph defines an n-ary relation between different vertices of a graph. This reduces the number of connections needed to connect the vertices and provides a more natural way of relating the nodes in a graph. An example of a hypergraph is the relationship borderlines, where nodes such as Poland, Germany and Czech Republic can be added. The database only requires a hypergraph containing these vertices to store the relationship, whereas a graph representation uses three arcs among the nodes. For storage, HyperGraphDB relies on BerkeleyDB <ref type="bibr" target="#b82">[85]</ref>, providing two layers of abstraction over it: a primitive layer, which includes a graph of relations between vertices, and a model layer, which includes the relations among the primitive layers adding also indexes and caches. These abstractions allow defining different graph interpretations, including RDF, OWL (an extension to RDF that allows to create ontologies upon RDF data), a Java API and a Prolog API, among others.</p><p>BigData: Finally, BigData is an RDF database scalable to large numbers of vertices and edges. It relies on a logstructured storage and the addition of B þ indexes, which are partitioned as the amount of data increases. For single node configurations, BigData can hold up to 50 billion vertices or arcs without sacrificing performance. If vertices need to be distributed, the database provides a simple dynamic sharding mechanism that consists in partitioning RDF indexes and distributing them across different nodes. Moreover, it provides the possibility of replicating nodes with the Master-Slave mechanism. BigData offers an API for SparQL and RDFSþ þ queries. The latter is an extension of RDFS (Resource Description Framework Schema), a set of classes or descriptions for defining ontologies in RDF databases and to make inferences about the data stored.</p><p>AllegroGraph: AllegroGraph is a RDF Store that supports ACID transactions marketed by a company named Franz Inc., which offers a free version limited to 3 million RDF triplets in the database. Like HyperGraphDB, this database has a very wide range of query methods including: SPARQL, RDFSþ þ, OWL, Prolog and native APIs for Java, Python, C# among others.</p><p>In addition to the listed databases, there are other similar application-specific databases that deserve mention. One is FlockDB <ref type="bibr" target="#b111">[114]</ref>, a Graph-oriented database developed by Twitter. This is a database with a very simple design since it just stores the followers of the users, i.e., their adjacency list. Among its most important features are its horizontal scaling capabilities and the ability to perform automatic sharding. Although it was not officially announced by Twitter, the FlockDB project was abandoned and it may have been replaced by other solution, such as Manhattan, <ref type="foot" target="#foot_2">9</ref> a distributed database also built by Twitter, or Cassandra.</p><p>A second database worth mentioning is Graphd <ref type="bibr" target="#b76">[79]</ref>, the storage support of FreeBase <ref type="bibr" target="#b13">[14]</ref>, a collaborative database that stores information about movies, arts and sports, among others. Graphd storage medium is an append-only file in which tuples are written. Each tuple can define either a node or a relationship between nodes. Tuples are never overwritten, when a new tuple is created the modified tuple is marked as deleted. Inverted indexes are used to accelerate access, going directly to the positions of tuples in the file. MQL (Metaweb Query Language), a language of Freebase analogous to SparQL, is used for querying the database. Graphd is a proprietary system, therefore, it was not included in the comparison. However, access to the database query API is available on the Web. <ref type="foot" target="#foot_3">10</ref>Finally, in <ref type="bibr" target="#b93">[96]</ref> the authors propose an extension to SPARQL, named G-SPARQL, and, more important to this work, an hybrid storage approach in which the graph structure and its attributes are stored in a relational database. Queries on the graph attributes are executed on the relational database whereas topological queries are executed on an in-memory graph representation. This strategy avoids the performance penalty of making recursive join operations on the database tables while still benefiting from the querying and storage efficiency of a relational database. However, the authors do not mention a distributed variant of the mentioned approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Discussion</head><p>As can be observed in this review, the spectrum of NoSQL databases is very broad and each of them is used for different applications today. However, NoSQL solutions cannot be seen as the law of the instrument or Maslow's Hammer 11 and should not be used for every application. In fact, many alternatives could be in general considered when selecting a storage solution. At the other extreme of the above example are the majority of low and medium scale applications, such as desktop applications and low traffic Web sites where stored data is in the order of megabytes, up to gigabytes, and do not have higher performance requirements. The use of relational databases can easily overcome the storage requirements in those situations. Nevertheless, the simplicity of the API of a Document-oriented database or a Key-Value database may also be a good fit.</p><p>Furthermore, in some situations, it may be necessary to define a hybrid data layer dividing the application data in multiple databases with different data layouts. For example, application data requiring a relational schema and high consistency, such as data from user accounts, can be stored in a RDBMS. On the other hand, if there is data of instant messaging between users requiring no transaction consistency but a fast access is necessary, a NoSQL database can provide an adequate solution.</p><p>Therefore, the goal of this review was to better understand the characteristics of the different types of NoSQL databases available. Particularly, in this paper we have reviewed NoSQL databases that support sharding and persist data storage. The aim of these restrictions was to compare databases that can be used as horizontally scalable data stores. This excludes many other storage solutions including: (1) databases that cannot be distributed, (2) in-memory stores, which are usually used as caches, and (3) distributed processing frameworks that generate a temporal (in-memory) representation of data extracted from a secondary database. On one hand, the distribution or sharding of data between different computing nodes allows the user to increase the storage capacity just by adding new nodes. Moreover, many NoSQL databases use this distribution to parallelize data processing among nodes having relevant data for the execution. On the other hand, data persistence is essential when the nodes of the cluster may suffer electric power outages.</p><p>Broadly speaking, for NoSQL systems like BigTable, the main design problems to solve are consistency management and fast access to large amounts of data. In this case, the database must scale to petabytes of data running on standard hardware. Contrarily, relational databases scale with certain difficulty because their latency is dramatically affected with each new node addition.</p><p>Some studies have shown that relaxing consistency can benefit system performance and availability. An example of this situation is a case study in the context of Dynamo [32], which models the shopping cart of an ecommerce site. Dynamo premise is that an operation "Add to cart" can never be rejected as this operation is critical to the business success. It might happen that a user is adding products to the shopping cart and the server saving the information suffers a failure and becomes no longer available. Then, the user can keep adding products on another server, but the shopping cart version of the original server was distributed to other replicas, generating different versions. In scenarios where faults are normal, multiple cart versions can coexist in the system. Versions are differentiated in Dynamo using Vector Clocks (Section 4.3). However, branching of versions can lead to several shopping carts, possibly valid, but with different products. To solve this conflict, Dynamo tries to unify the cart versions by merging them into a new cart that contains all user products, even if the new version contains previously deleted products.</p><p>Compared to these supports, relational databases, alternatively, provide much simpler mechanisms to manage data updates maintaining consistency between tables. Instead, NoSQL databases with eventual consistency delegate the problem of solving inconsistencies to developers, which causes such functionality to be error-prone.</p><p>Document-oriented databases are useful for semistructured data without a fixed schema, but complying to certain formatting rules, such as XML, JSON, and BSON documents, among others. The goal of these databases is to store large amounts of text and provide support for querying on their fields, which in turn are indexed in different ways (keywords, exact word, numeric, etc.). A typical example application of such databases is text mining, where recognized elements of a textual document can vary in type and quantity. For example, a document may be composed of the syntactic structure of the text and also entities such as cities, names and people. xTAS <ref type="bibr" target="#b29">[30]</ref> is a project that examines multilingual text and stores the internal results in MongoDB.</p><p>Moreover, there are applications that have large amounts of highly correlated data, with diverse relationships. Usually, this type of data is extracted from social networks or the Semantic Web. Graph-oriented databases are more suitable for such data as they allow to efficiently explore vertex-tovertex relationships. Furthermore, there are also graph processing frameworks for executing distributed algorithms, although they are not usually designed to store data. Examples of such frameworks are Pregel <ref type="bibr" target="#b71">[74]</ref>, Trinity <ref type="bibr" target="#b96">[99]</ref> and HipG <ref type="bibr" target="#b60">[63]</ref>. These frameworks, which are to NoSQL-based applications what the model layer represents to conventional Web applications, provide a middleware layer on top of the data store layer where the logic related to data traversal and parallelism resides. In general, it is not necessary to know SQL for using NoSQL databases. However, since each NoSQL database has its own API, consistency, replication and sharding mechanisms, every change of NoSQL technology involves learning a new storage paradigm. In some cases, such as Key-Value databases, this learning is fast as the API can be very easy to learn (get and set), but in other cases, such as Wide-Column databases, it involves learning concepts such as Column Families and MapReduce. Some NoSQL databases provide SQL-Like languages for querying data so this transition is less drastic. There are also efforts in creating a unified API to query different NoSQL databases with different types of schema. For example, SOS (Save Our Systems) <ref type="bibr" target="#b7">[7]</ref> provides a unified API consisting in 3 basic operations: GET, PUT and DELETE. The implementation of those operations depends on the database selected (SOS was tested against MongoDB, Redis and HBase). By unifying the API for different databases, the application code can be reused for a different type of database. However, hiding the specifics of the underlying database also hides its features and, therefore, possible optimization opportunities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusions</head><p>NoSQL databases are now part of the software designer's toolbox and are relentlessly occupying a market niche once completely owned by RDBMSs. Currently, the "NoSQL movement" is going through a hype where the technology is receiving substantial attention and the expectations on it may be exaggerated. This is, in part, due to the proliferation of NoSQL databases created by many companies and open-source communities, each of which promoting its own implementation. This also makes using NoSQL technology in a production environment a tough decision. However, there is plenty of community support and, in many cases, official support can be acquired.</p><p>As mentioned, NoSQL databases have been adopted by many organizations, including organizations that provide storage solutions themselves. There are some databases that use NoSQL databases as the underlying storage support. For example, Titan 12 is a graph-oriented database that allows the user to choose from three underlying storage supports: Cassandra, BerkeleyDB and HBASE. This in principle suggests that in the future, different data layouts at both the representation and the storage level might coexist, thus increasing the available options for developers.</p><p>There is also a growing number of Cloud storage systems that use NoSQL databases as storage support. As an example, Riak CS 13 is a file storage system on the Cloud that uses Riak as a persistent storage and provides an API (similar to Amazon S3 14 ) to store files containing terabytes of data. Another kind of Cloud storage systems that is being increasingly adopted is database-as-a-service (DBaaS)a.k.a. data as a servicesystems <ref type="bibr" target="#b45">[47]</ref>. A DBaaS is a database, installed and maintained by a vendor, in which developers can store data usually in exchange for a fee. A number of DBaaS providers are based on NoSQL databases. For example, OpenRedis<ref type="foot" target="#foot_4">15</ref> provides a hosted Redis database that can be purchased and accessed remotely. Another example is MongoLab, <ref type="foot" target="#foot_5">16</ref> a DBaaS based on MongoDB. As stated in <ref type="bibr" target="#b45">[47]</ref>, DBaaS presents security challenges if appropriate strategies are not implemented. Data encryption and third party data confidentiality are examples of security concerns inherent to DBaaS.</p><p>In many PaaS (Platform as a Service) environments the databases offered range from RDBMSs to NoSQL databases. For example, PaaS vendors such as Heroku<ref type="foot" target="#foot_6">17</ref> run applications written in a variety of languages and frameworks. As a storage backend, a Heroku user can choose from a set of databases including Postgres, ClearDB (a MySQL-based distributed database), Neo4J, Redis and MongoDB. Another example is OpenShift, <ref type="foot" target="#foot_7">18</ref> a PaaS vendor that provides three database supports, namely MySQL, Postgres and MongoDB. Therefore, data storage layers where RDBMSs and NoSQL solutions coexist also seems to be in the agenda of backend providers. This evidences the fact that RDBMSs and NoSQL databases are indeed complementary technologies rather than competitors.  12 Titan Web Page, http://thinkaurelius.github.io/titan/. 13 Riak CS Web Page, http://basho.com/riak-cloud-storage. 14 Amazon S3 Web Page, http://aws.amazon.com/es/s3. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i nodes available in a cluster of machines to manage a large number of requests and big amounts of web content.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A simple key-value store example for serving static web content.</figDesc><graphic coords="8,306.48,56.58,180.00,152.62" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Example of Consistent Hashing with virtual nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 3 .</head><label>3</label><figDesc>Fig.3. Virtual Buckets example using 3 servers, a vBucket size of 5 and a 1: N replication scheme.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. SSTable, Tablet and Table structures.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Operating diagram of a Tablet server.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Example of vertex representation in a Graph-oriented database. Please cite this article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>Maslow: "I suppose it is tempting, if the only tool you have is a hammer, to treat everything as if it were a nail." Please cite this article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Databases analyzed grouped by category.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2</head><label>2</label><figDesc>Grouping of NoSQL systems grouped by data layout and CAP properties.</figDesc><table><row><cell>Data layout</cell><cell>AP</cell><cell>CP</cell><cell>AC</cell></row><row><cell>Key-Value (Section 4)</cell><cell>Riak, Infinispan, Redis, Voldemort, Hazelcast</cell><cell>Infinispan, Membase/CouchBase, Berke-</cell><cell>Infinispan</cell></row><row><cell></cell><cell></cell><cell>leyDB, GT.M</cell><cell></cell></row><row><cell>Wide Column (Section 5)</cell><cell>Cassandra</cell><cell>HBase, Hypertable</cell><cell>-</cell></row><row><cell>Document-oriented</cell><cell>MongoDB, RavenDB , CouchDB, Terrastore</cell><cell>MongoDB</cell><cell>-</cell></row><row><cell>(Section 6)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Graph-oriented (Section 7)</cell><cell>Neo4J, HypergraphDB, BigData, AllegroGraph, InfoGrid,</cell><cell>InfiniteGraph</cell><cell>-</cell></row><row><cell></cell><cell>InfiniteGraph</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3</head><label>3</label><figDesc>Configurations of eventual consistency.</figDesc><table><row><cell>Value</cell><cell>Writing (W)</cell><cell>Reading (R)</cell></row></table><note><p><p><p><p><p><p><p>0</p>No confirmation is awaited from any node (it can fail) N/A 1 A single node confirmation is enough (optimized for writings)</p>Reading is performed from a single replica (optimized for readings) M, with M o N (Quorum)</p>Confirmations of several replicas are awaited Reading is performed from a given set of replicas (conflicts on the client side might need to be solved) N (all nodes)</p>Confirmations of all replicas are awaited (reduces availability, but increases durability)</p>Reading is performed from all replicas increasing the reading latency</p>Please cite this article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4</head><label>4</label><figDesc>Comparison of reviewed Key-Value databases. Value databases maintain a subset of key/ value pairs stored in RAM, dramatically improving performance. From the databases analyzed in this review, Hazelcast, Membase, Redis and Riak use this strategy. However, this decision comes with a cost: as the number of keys increases, the use of RAM increases. Riak and Membase always keep keys in memory, whereas values are removed from memory if space is needed for new keys.</figDesc><table><row><cell>API Query method</cell><cell></cell><cell>PBC (Protocol Buffer Client), Get, MapReduce, Link</cell><cell>HTTP, Java, Erlang, C þ þ, Walking</cell><cell>PHP, Ruby, Python</cell><cell></cell><cell>HTTP, Java Get, MapReduce,</cell><cell>others</cell><cell>HTTP, Java, C# and any Get, MapReduce</cell><cell>Memcache client</cell><cell>Java, C, C#, Ruby, Perl, Scala Get (also depends on</cell><cell>the value structure)</cell><cell></cell><cell>Get Java, C, C#</cell><cell>Java, Python</cell></row><row><cell>Implementation</cell><cell>language</cell><cell>Erlang</cell><cell></cell><cell></cell><cell></cell><cell>Java</cell><cell></cell><cell>Java</cell><cell></cell><cell>C</cell><cell></cell><cell></cell><cell>þ, Erlang C/Cþ</cell><cell>Java</cell></row><row><cell>Sharding Consistency</cell><cell></cell><cell>Consistent Hashing Eventual Consistency</cell><cell></cell><cell></cell><cell></cell><cell>Consistent Hashing Strong Consistency or</cell><cell>Eventual Consistency</cell><cell>Consistent Hashing Strong Consistency</cell><cell></cell><cell>No (in charge of Eventual Consistency</cell><cell>the application)</cell><cell></cell><cell>vBuckets Strong Consistency</cell><cell>Consistent Hashing Eventual Consistency</cell></row><row><cell>Replication</cell><cell></cell><cell>Ring (next N À 1)</cell><cell></cell><cell></cell><cell></cell><cell>Ring (next N À 1)</cell><cell></cell><cell>Ring (next N À 1)</cell><cell></cell><cell>Master-Slave (Slave</cell><cell>chains can be</cell><cell>formed)</cell><cell>vBuckets 1: N</cell><cell>Replication</cell><cell>Ring (next N À 1)</cell></row><row><cell>Persistence</cell><cell></cell><cell>Bitcask (log-structured store),</cell><cell>LevelDB, In-Memory and Multi-</cell><cell>backend (different stores for different</cell><cell>keys)</cell><cell>Simple File Storage, BerkeleyDB,</cell><cell>JDBM, JDBC</cell><cell>User-defined MapStore, which can be</cell><cell>persistent</cell><cell>Snapshots at specified intervals by</cell><cell>default or an Append-only file. Both</cell><cell>can be combined</cell><cell>SQLLite or CouchDB</cell><cell>BerkeleyDB, In-Memory, MySQL</cell></row><row><cell>Name</cell><cell></cell><cell>Riak</cell><cell></cell><cell></cell><cell></cell><cell>Infinispan</cell><cell></cell><cell>Hazelcast</cell><cell></cell><cell>Redis</cell><cell></cell><cell></cell><cell>Membase/</cell><cell>CouchBase</cell><cell>Voldemort</cell></row></table><note><p><p>Get</p>Please cite this article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i Some Key-</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Reduce functions, i.e., aggregation of intermediate results, are much less varied and thus are usually provided as generic operations. Sum and average are examples of generic reduce functions frequently used in MapReduce applications. A simple program in Sawzall to process a file that stores floating point numbers is shown below:</figDesc><table><row><cell>count: table sum of int;</cell></row><row><cell>total: table sum of float;</cell></row><row><cell>sum_of_squares: table sum of float;</cell></row><row><cell>x: float¼input;</cell></row><row><cell>emit count o -1;</cell></row><row><cell>emit total o -x;</cell></row><row><cell>emit sum_of_squares o -x n x;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 5</head><label>5</label><figDesc>Characteristics of Wide Column databases. clients and servers in languages such as Java, Ruby or Python, among others. Avro<ref type="bibr" target="#b3">[3]</ref> is a similar tool to Thrift. In this case, Avro provides its own IDL, but supports JSON to specify interfaces and data types.</figDesc><table><row><cell>Query method</cell><cell>Hadoop MapReduce, Pig, Hive</cell><cell></cell><cell>HQL (Hypertable Query Language), Hadoop</cell><cell>MapReduce, Hive, Pig</cell><cell>CQL (Cassandra Query Language), Hadoop</cell><cell>MapReduce, Pig, Hive</cell></row><row><cell>Implementation language API</cell><cell>Java Java, HTTP þ JSON,</cell><cell>Avro, Thrift [102]</cell><cell>C þ þ Thrift</cell><cell></cell><cell>Java Thrift</cell></row><row><cell>Consistency</cell><cell>Strong Consistency</cell><cell></cell><cell>Strong Consistency</cell><cell></cell><cell>Eventual</cell><cell>Consistency</cell></row><row><cell>Replication Sharding</cell><cell>HDFS replication By key ranges</cell><cell></cell><cell>HDFS replication By key ranges</cell><cell></cell><cell>Ring (next N À 1) Consistent</cell><cell>Hashing</cell></row><row><cell>Name Persistence</cell><cell>HBase HDFS (Hadoop File System)</cell><cell></cell><cell>Hypertable HDFS by default (other supports</cell><cell>are available)</cell><cell>Cassandra Proprietary format</cell></row></table><note><p>RPC</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 6</head><label>6</label><figDesc>Comparison of different document-oriented databases.</figDesc><table><row><cell>Query method</cell><cell></cell><cell>Views using JavaScript þ</cell><cell>MapReduce</cell><cell></cell><cell>Queries per field, Cursors</cell><cell>and MapReduce</cell><cell></cell><cell>Conditional queries, quer-</cell><cell>ies by range Predicates,</cell><cell>MapReduce</cell><cell>LINQ</cell></row><row><cell>API</cell><cell></cell><cell>HTTP þ JSON, and clients</cell><cell>for different languages</cell><cell>(including Java)</cell><cell>Mongo Wire Protocol þ</cell><cell>BSON, HTTP þ JSON, and</cell><cell>clients for most languages</cell><cell>HTTP þ JSON, and clients</cell><cell>for some languages (Java,</cell><cell>Clojure [51], Scala [84])</cell><cell>HTTP þ JSON, .Net</cell></row><row><cell>Implementation</cell><cell>language</cell><cell>Erlang</cell><cell></cell><cell></cell><cell>Cþ þ</cell><cell></cell><cell></cell><cell>Java</cell><cell></cell><cell></cell><cell>C#</cell></row><row><cell>Consistency</cell><cell></cell><cell>Eventual Consistency</cell><cell></cell><cell></cell><cell>Strict Consistency by default,</cell><cell>but can be relaxed to Even-</cell><cell>tual Consistency</cell><cell>Eventual Consistency</cell><cell></cell><cell></cell><cell>Eventual Consistency</cell></row><row><cell>Sharding</cell><cell></cell><cell>No, but there are extensions</cell><cell>to CouchDB that allow</cell><cell>sharding</cell><cell>By field, which can be any</cell><cell>field in a document collection</cell><cell></cell><cell>Consistent Hashing</cell><cell></cell><cell></cell><cell>Allows the user to define a</cell><cell>sharding function based on</cell><cell>the documents' fields</cell></row><row><cell>Replication</cell><cell></cell><cell>Master-Master</cell><cell></cell><cell></cell><cell>Replica Sets (sets of</cell><cell>Master-Slaves) or sim-</cell><cell>ply Master-Slave</cell><cell>Master-Slave with N</cell><cell>replicas in hot-standby</cell><cell></cell><cell>Master-Slave on</cell><cell>N-replicas</cell></row><row><cell>Name Persistence</cell><cell></cell><cell>CouchDB CouchDB Storage</cell><cell>Engine (B-Tree)</cell><cell></cell><cell>MongoDB BSON Objects or</cell><cell>GridFS for big files</cell><cell></cell><cell>Terrastore Terrastore storing</cell><cell>support</cell><cell></cell><cell>RavenDB Microsoft's ESE</cell><cell>(Extensible Storage</cell><cell>Engine)</cell></row></table><note><p><p>7 </p>10gen Web Page, http://www.10gen.com/.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 7</head><label>7</label><figDesc>Comparison of graph databases.</figDesc><table><row><cell>Query method</cell><cell></cell><cell>SPARQL (RDF and OWL),</cell><cell>Java API, Gremlin</cell></row><row><cell>API</cell><cell></cell><cell>Java, HTTP þ JSON, bind-</cell><cell>ings in Ruby, Clojure,</cell><cell>Python, among others</cell></row><row><cell>Implementation</cell><cell>language</cell><cell>Java</cell><cell></cell></row><row><cell>Consistency</cell><cell></cell><cell>Eventual Consistency</cell><cell></cell><cell>Strong Consistency or</cell><cell>Eventual Consistency</cell></row><row><cell>Sharding</cell><cell></cell><cell>Manual</cell><cell></cell><cell>Rule based sharding</cell></row><row><cell>Replication</cell><cell></cell><cell>Master-Slave</cell><cell></cell><cell>Synchronous replica-</cell><cell>tion of Objectivity/DB</cell></row><row><cell>Persistence</cell><cell></cell><cell>Indexes on disk (Apache</cell><cell>Lucene by default)</cell><cell>Objectivity/DB</cell></row><row><cell>Name</cell><cell></cell><cell>Neo4J</cell><cell></cell><cell>InfiniteGraph</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>A.Corbellini  et al. / Information Systems ∎ (∎∎∎∎) ∎∎∎-∎∎∎</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_1"><p>On Sharding Graph Databases, http://jim.webber.name/2011/02/ on-sharding-graph-databases/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_2"><p>Manhattan announced in Twitter Blog,https://www.blog.twitter. com/2014/manhattan-our-real-time-multi-tenant-distributed-databasefor-twitter-scale.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_3"><p>10 http://www.freebase.com/queryeditor. Please cite this article as: A. Corbellini, et al., Persisting big-data: The NoSQL landscape, Information Systems (2016), http: //dx.doi.org/10.1016/j.is.2016.07.009i</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_4"><p>OpenRedis, http://openredis.com/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_5"><p>MongoLab Web Page, http://mongolab.com/welcome/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_6"><p>http://www.heroku.com/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_7"><p>OpenShift Web Page, http://www.openshift.com/.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work has been partially funded by ANPCyT (Argentina) under Project PICT-2011-0366 and by CONICET (Argentina) under Project PIP no. 112-201201-00185.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Allegro Graph: RDF Triple Database</title>
		<author>
			<persName><forename type="first">Jans</forename><surname>Aasman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Franz Incorporated</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report 1</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A comparison of current graph database models</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 28th International Conference on Data Engineering Q5</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Workshops (ICDEW</title>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="171" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Apache avro</title>
		<idno>05.07.13</idno>
		<ptr target="http://avro.apache.org/" />
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Apache Foundation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<idno>04.11.13</idno>
		<ptr target="http://giraph.apache.org/" />
		<title level="m">Apache Foundation, Apache giraph</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Towards a followee recommender system for information seeking users in Twitter</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Armentano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Godoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Analía</forename><surname>Amandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Semantic Adaptive Social Web (SASWeb&apos;11) at the 19th International Conference on User Modeling, Adaptation, and Personalization (UMAP 2011)</title>
		<meeting>the International Workshop on Semantic Adaptive Social Web (SASWeb&apos;11) at the 19th International Conference on User Modeling, Adaptation, and Personalization (UMAP 2011)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">LinkBench: a database ,benchmark based on the facebook social graph</title>
		<author>
			<persName><forename type="first">Timothy G</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vamsi</forename><surname>Ponnekanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dhruba</forename><surname>Borthakur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Callaghan</surname></persName>
		</author>
		<idno type="DOI">10.1145/2463676.2465296</idno>
		<ptr target="http://dx.doi.org/10.1145/2463676.2465296" />
	</analytic>
	<monogr>
		<title level="m">SIGMOD&apos;13 Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1185" to="1196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Uniform access to NoSQL systems</title>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Atzeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesca</forename><surname>Bugiotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Rossi</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.is.2013.05.002</idno>
		<ptr target="http://linkinghub.elsevier.com/retrieve/pii/S0306437913000719" />
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<idno type="ISSN">03064379</idno>
		<imprint>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2013-06">June. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Quantifying eventual consistency with PBS</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Bailis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shivaram</forename><surname>Venkataraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00778-013-0330-1</idno>
		<ptr target="http://dx.doi.org/10.1007/s" />
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<idno type="ISSN">00778-013-0330-1. 0949877X</idno>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="279" to="302" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Megastore: providing scalable, highly available storage for interactive services</title>
		<author>
			<persName><forename type="first">Jason</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Khorlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Michel</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yawei</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vadim</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><surname>Yushprakh</surname></persName>
		</author>
		<idno type="DOI">10.1037/h0054295</idno>
		<ptr target="http://dx.doi.org/10.1037/h0054295" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Innovative Data Systems Research</title>
		<meeting>the Conference on Innovative Data Systems Research</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="223" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fundamentals of distributed computing: A practical tour of vector clock systems</title>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Baldoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Klusch</surname></persName>
		</author>
		<ptr target="http://doi.ieeecomputersociety.org/null" />
	</analytic>
	<monogr>
		<title level="j">IEEE Distrib. Syst. Online</title>
		<idno type="ISSN">1541-4922</idno>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Concurrency control in distributed database systems</title>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="185" to="221" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">GridFS: highly scalable i/o solution for clusters and computational grids</title>
		<author>
			<persName><forename type="first">Dheeraj</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manish</forename><forename type="middle">K</forename><surname>Sinha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Comput. Sci. Eng</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="287" to="291" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Freebase: a collaboratively created graph database for structuring human knowledge</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Bollacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Praveen</forename><surname>Paritosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Sturge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jamie</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2008 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1247" to="1250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Bossa</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://code.google.com/p/terrastore/" />
		<title level="m">Terrastore-Scalable, Elastic, Consistent Document Store</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Extensible markup language (XML)</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Paoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Michael Sperberg-Mcqueen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eve</forename><surname>Maler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Yergeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">World WideWeb J</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="27" to="66" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Chubby lock service for loosely-coupled distributed systems</title>
		<author>
			<persName><forename type="first">Mike</forename><surname>Burrows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Symposium on Operating Systems Design and Implementation (OSDI&apos;06)</title>
		<meeting>the 7th Symposium on Operating Systems Design and Implementation (OSDI&apos;06)<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="335" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Cloud computing and emerging IT platforms: vision, hype, and reality for delivering computing as the 5th utility</title>
		<author>
			<persName><forename type="first">Rajkumar</forename><surname>Buyya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shin</forename><surname>Chee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srikumar</forename><surname>Yeo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Venugopal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivona</forename><surname>Broberg</surname></persName>
		</author>
		<author>
			<persName><surname>Brandic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Gener. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="599" to="616" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<author>
			<persName><forename type="first">Rick</forename><surname>Cattell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Scalable SQL and NoSQL data stores</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="12" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Bigtable: a distributed storage system for structured data</title>
		<author>
			<persName><forename type="first">Fay</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wilson</forename><forename type="middle">C</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deborah</forename><forename type="middle">A</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tushar</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Gruber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">MongoDB: The Definitive Guide</title>
		<author>
			<persName><forename type="first">Kristina</forename><surname>Chodorow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Dirolf</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>O&apos;Reilly Media</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><surname>Cloudant</surname></persName>
		</author>
		<author>
			<persName><surname>Bigcouch</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://bigcouch.cloudant.com/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Benchmarking cloud serving systems with ycsb</title>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">F</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erwin</forename><surname>Tam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Russell</forename><surname>Sears</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM Symposium on Cloud Computing, ACM</title>
		<meeting>the 1st ACM Symposium on Cloud Computing, ACM</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="143" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Supporting the efficient exploration of large-scale social networks for recommendation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Corbellini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Mateos</forename><surname>Diaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Godoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zunino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schiaffino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the II Brazilian Workshop on Social Network Analysis and Mining</title>
		<meeting>the II Brazilian Workshop on Social Network Analysis and Mining<address><addrLine>Maceió, AL, Brazil</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">BraSNAM 2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Spanner: Google&apos;s globally-distributed database</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName><surname>Hochschild</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation</title>
		<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation<address><addrLine>Hollywood, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="page" from="251" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Membase</forename><surname>Couchbase</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://www.couchbase.org/membase" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A survey of approaches to Web service discovery in service-oriented architectures</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Crasso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alejandro</forename><surname>Zunino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Campo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Database Manag</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="103" to="134" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">JSON: the fat-free alternative to XML</title>
		<author>
			<persName><forename type="first">Douglas</forename><surname>Crockford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of XML 2006</title>
		<meeting>XML 2006</meeting>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A timestamp-based two phase commit protocol for Web services using REST architectural style</title>
		<author>
			<persName><forename type="first">Luiz</forename><surname>Alexandre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hiane</forename><surname>Da</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silva</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Celso</forename><surname>Massaki Hirata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Eng</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="266" to="282" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Maarten de Rijke, xTAS: Text analysis in a timely manner</title>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Ork De Rooij</surname></persName>
		</author>
		<author>
			<persName><surname>Vishneuski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Dutch-Belgian Information Retrieval Workshop</title>
		<meeting>the 12th Dutch-Belgian Information Retrieval Workshop<address><addrLine>Gent; Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">MapReduce: simplified data processing on large clusters</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Decandia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deniz</forename><surname>Hastorun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madan</forename><surname>Jampani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gunavardhan</forename><surname>Kakulapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avinash</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Pilchin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swaminathan</forename><surname>Sivasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Vosshall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Vogels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="205" to="220" />
			<date type="published" when="2007">2008. 2007</date>
		</imprint>
	</monogr>
	<note>Commun. ACM</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Ycsb þ t: Benchmarking web-scale transactional databases</title>
		<author>
			<persName><forename type="first">Akon</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghunath</forename><surname>Nambiar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uwe</forename><surname>Röhm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 30th International Conference on Data Engineering Workshops (ICDEW)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="223" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m">Lars Ellenberg, DRBD 8.0. x and Beyond: Shared-Disk Semantics on a Shared-Nothing Cluster, LinuxConf Europe</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Virtuoso: RDF support in a native RDBMS</title>
		<author>
			<persName><forename type="first">Orri</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Mikhailov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web Information Management</title>
		<imprint>
			<biblScope unit="page" from="501" to="519" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="middle">Kyoto</forename><surname>Fal Labs</surname></persName>
		</author>
		<author>
			<persName><surname>Cabinet</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://fallabs.com/kyotocabinet/" />
		<title level="m">A Straightforward Implementation of DBM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Ferguson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Randall</forename><surname>Leeds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaun</forename><surname>Lindsay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lounge</forename></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://tilgovi.github.io/couchdb-lounge/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Memcached-A Distributed Memory Object Caching System</title>
		<author>
			<persName><forename type="first">Brad</forename><surname>Fitzpatrick</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://memcached.org/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Building a high-level dataflow system on top of Map-Reduce: the Pig experience</title>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">F</forename><surname>Gates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olga</forename><surname>Natkovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shubham</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pradeep</forename><surname>Kamath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shravan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Narayanamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santhosh</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Utkarsh</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1414" to="1425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">HBase: The Definitive Guide</title>
		<author>
			<persName><forename type="first">L</forename><surname>George</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>O&apos;Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Bigbench: towards an industry standard benchmark for big data analytics</title>
		<author>
			<persName><forename type="first">Ahmad</forename><surname>Ghazal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tilmann</forename><surname>Rabl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minqing</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francois</forename><surname>Raab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meikel</forename><surname>Poess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alain</forename><surname>Crolette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans-Arno</forename><surname>Jacobsen</surname></persName>
		</author>
		<idno type="DOI">10.1145/2463676.2463712</idno>
		<ptr target="http://dl.acm.org/citation.cfm?id¼2463712" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2013 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1197" to="1208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The Google file system</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shun-Tak</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM Symposium on Operating Systems Principles (SOSP&apos;03)</title>
		<meeting>the 9th ACM Symposium on Operating Systems Principles (SOSP&apos;03)<address><addrLine>Bolton Landing, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="29" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Shun-Tak Leung, The Google file system</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Gobioff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="43" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Brewer&apos;s conjecture and the feasibility of consistent, available, partition-tolerant web services</title>
		<author>
			<persName><forename type="first">Seth</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nancy</forename><surname>Lynch</surname></persName>
		</author>
		<idno type="DOI">10.1145/564585.564601</idno>
		<ptr target="http://www.dl.acm.org/citation" />
	</analytic>
	<monogr>
		<title level="j">ACM SIGACT News</title>
		<idno type="ISSN">01635700</idno>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">51</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>cfm?id¼ 564585.564601.</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<idno>acces- sed 05.07.13</idno>
		<ptr target="http://code.google.com/p/leveldb/" />
		<title level="m">LevelDB-A Fast and Lightweight Key/Value Database Library by Google</title>
		<imprint>
			<publisher>Google Inc</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Transaction Processing: Concepts and Techniques, 1st ed</title>
		<author>
			<persName><forename type="first">Jim</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Reuter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992 ISBN 1558601902</date>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Data security services, solutions and standards for outsourcing</title>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">W</forename><surname>Hamlen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bhavani</forename><surname>Thuraisingham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Stand. Interfaces</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="5" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<author>
			<persName><forename type="first">Inc</forename><surname>Hazelcast</surname></persName>
		</author>
		<author>
			<persName><surname>Hazelcast</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://www.hazelcast.com/http://www.hazelcast.com/http://www.hazelcast.com/" />
		<title level="m">Memory Data Grid</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">NoSQL evaluation: a use case oriented survey</title>
		<author>
			<persName><forename type="first">Robin</forename><surname>Hecht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Jablonski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Cloud and Service Computing (CSC 2011)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="336" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<idno>05.07.13</idno>
		<ptr target="http://www.ravendb.net/" />
		<title level="m">Hibernating Rhinos. RavenDB</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">The Clojure programming language</title>
		<author>
			<persName><forename type="first">Rich</forename><surname>Hickey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 Symposium on Dynamic Languages (DLS&apos;08)</title>
		<meeting>the 2008 Symposium on Dynamic Languages (DLS&apos;08)<address><addrLine>Paphos, Cyprus</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Scaling CouchDB</title>
		<author>
			<persName><forename type="first">B</forename><surname>Holt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Oreilly &amp; Associates Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The hibench benchmark suite: characterization of the mapreducebased data analysis</title>
		<author>
			<persName><forename type="first">Shengsheng</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinquan</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tao</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Frontiers in Information and Software as Services</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="209" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A generalized graph database</title>
		<author>
			<persName><forename type="first">Borislav</forename><surname>Iordanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><forename type="middle">H</forename><surname>Hypergraphdb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Özsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-W</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Web-Age Information Management</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Zhuang</surname></persName>
		</editor>
		<editor>
			<persName><surname>Shao</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6185</biblScope>
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Alejandro Abdelnur, Oozie: towards a scalable workflow management system for hadoop</title>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelo</forename><forename type="middle">K</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohamed</forename><surname>Battisha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michelle</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santhosh</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Neumann</surname></persName>
		</author>
		<idno type="DOI">10.1145/2443416.2443420</idno>
		<ptr target="http://doi.acm.org/10.1145/2443416.2443420" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM SIGMOD Workshop on Scalable Workflow Execution Engines and Technologies, SWEET &apos;12, ACM</title>
		<meeting>the 1st ACM SIGMOD Workshop on Scalable Workflow Execution Engines and Technologies, SWEET &apos;12, ACM<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Challenges for database management in the Internet of things</title>
		<author>
			<persName><forename type="first">Anne</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><surname>Cooper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IETE Tech. Rev</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="320" to="329" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">The Internet of things: the death of a traditional database?</title>
		<author>
			<persName><forename type="first">Keith</forename><surname>Jeffery</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IETE Tech. Rev</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="313" to="319" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Wojciech Indyk, Parallel Processing of Large Graphs</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Kajdanowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Przemyslaw</forename><surname>Kazienko</surname></persName>
		</author>
		<idno>CoRR, abs/1306.0326</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web</title>
		<author>
			<persName><forename type="first">David</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rina</forename><surname>Panigrahy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Lewin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual ACM Symposium on Theory of Computing (STOC &apos;97)</title>
		<meeting>the 29th Annual ACM Symposium on Theory of Computing (STOC &apos;97)<address><addrLine>El Paso, TX, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="654" to="663" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Web caching with consistent hashing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sherman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Berkheimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bogstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dhanidina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Iwamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Matkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yerushalmi</surname></persName>
		</author>
		<idno type="DOI">10.1016/S1389-1286(99)00055-9</idno>
		<ptr target="http://dx.doi.org/10.1016/S1389-1286(99)00055-9" />
	</analytic>
	<monogr>
		<title level="j">Comput. Netw</title>
		<idno type="ISSN">13891286</idno>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1203" to="1213" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Mizan: a system for dynamic load balancing in large-scale graph processing</title>
		<author>
			<persName><forename type="first">Zuhair</forename><surname>Khayyat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karim</forename><surname>Awara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amani</forename><surname>Alonazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hani</forename><surname>Jamjoom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Panos</forename><surname>Kalnis</surname></persName>
		</author>
		<idno type="DOI">10.1145/2465351.2465369</idno>
		<ptr target="http://doi.acm.org/10.1145/2465351.2465369" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM European Conference on Computer Systems, EuroSys &apos;13, ACM</title>
		<meeting>the 8th ACM European Conference on Computer Systems, EuroSys &apos;13, ACM<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="169" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">HipG: parallel processing of large-scale graphs</title>
		<author>
			<persName><forename type="first">Elzbieta</forename><surname>Krepska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thilo</forename><surname>Kielmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wan</forename><surname>Fokkink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henri</forename><surname>Bal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="3" to="13" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Cassandra: a decentralized structured storage system</title>
		<author>
			<persName><forename type="first">Avinash</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prashant</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Time clocks and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
		<idno type="DOI">10.1145/360000/359563/p558-lamport.pdfip131.252.96.28id359563accACTIVESERVICEkeyB63ACEF81C6334F5.CA8B0988038A4DF4.4D4702B0C3E38B35.4D4702B0C3E38B35CFID744655214CFTOKEN36213872acm1452760285b7c0f</idno>
		<ptr target="http://www.delivery.acm.org.proxy.lib.pdx.edu/10.1145/360000/359563/p558-lamport" />
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<idno type="ISSN">00010782</idno>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
	<note>pdf? ip¼131.252.96.28{&amp;}id¼359563{&amp;}acc¼ ACTIVESERVICE{&amp;}key¼ B63ACEF81C6334F5.CA8B0988038A4DF4.4D4702B0C3E38B35. 4D4702B0C3E38B35{&amp;}CFID¼744655214{&amp;}CFTOKEN¼ 36213872{&amp;} {_}{_}acm{_}{_}¼ 1452760285{_}b7c0f</note>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">The part-time parliament</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
		<idno type="DOI">10.1145/279227.279229</idno>
		<ptr target="http://dx.doi.org/10.1145/279227.279229" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<idno type="ISSN">07342071</idno>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Will NoSQL databases live up to their promise</title>
		<author>
			<persName><forename type="first">Neal</forename><surname>Leavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="12" to="14" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Introduction to CouchDB, Beginning CouchDB</title>
		<author>
			<persName><forename type="first">Joe</forename><surname>Lennon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="3" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Google&apos;s MapReduce programming model-revisited</title>
		<author>
			<persName><forename type="first">Ralf</forename><surname>Lïmmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comput. Program</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<idno>05.07.13</idno>
		<ptr target="http://www.project-voldemort.com/voldemort/" />
		<title level="m">Voldemort</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>LinkedIn Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Investigating storage solutions for large data</title>
		<author>
			<persName><forename type="first">Adam</forename><surname>Lith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakob</forename><surname>Mattsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science and Engineering-Chalmers University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Challenges in parallel graph processing</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Lumsdaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Douglas</forename><surname>Gregor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Hendrickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Berry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parallel Process. Lett</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="20" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Rapid scalability of complex and dynamic web-based systems: challenges and recent approaches to mitigation</title>
		<author>
			<persName><forename type="first">Srini</forename><surname>Mani Malarvannan</surname></persName>
		</author>
		<author>
			<persName><surname>Ramaswamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on System of Systems Engineering</title>
		<meeting>the 5th International Conference on System of Systems Engineering</meeting>
		<imprint>
			<date type="published" when="2010">SoSE 2010. 2010</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Pregel: a system for large-scale graph processing</title>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">H</forename><surname>Austern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Aart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilan</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naty</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName><surname>Czajkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 International Conference on Management of Data (SIGMOD &apos;10)</title>
		<meeting>the 2010 International Conference on Management of Data (SIGMOD &apos;10)<address><addrLine>Indianapolis, IN, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title level="m" type="main">Infinispan Data Grid Platform</title>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Marchioni</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Packt Pub Limited</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Mapreduce indexing strategies: studying scalability and efficiency</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Mccreadie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><surname>Macdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iadh</forename><surname>Ounis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Manag</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="873" to="888" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Membrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Plugge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hawkins</surname></persName>
		</author>
		<title level="m">The Definitive Guide to Mon-goDB: The NoSQL Database for Cloud and Desktop Computing</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">A digital signature based on a conventional encryption function</title>
		<author>
			<persName><forename type="first">Ralph</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology (CRYPTO&apos;87)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Carl</forename><surname>Pomerance</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">293</biblScope>
			<biblScope unit="page" from="369" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Optimizing schema-last tuple-store queries in Graphd</title>
		<author>
			<persName><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jutta</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Degener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barak</forename><surname>Giannandrea</surname></persName>
		</author>
		<author>
			<persName><surname>Michener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 International Conference on Management of Data (SIGMOD &apos;10)</title>
		<meeting>the 2010 International Conference on Management of Data (SIGMOD &apos;10)<address><addrLine>Indianapolis, IN, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1047" to="1056" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<author>
			<persName><forename type="middle">Neo</forename><surname>Inc</surname></persName>
		</author>
		<author>
			<persName><surname>Technology</surname></persName>
		</author>
		<idno>05.08.13</idno>
		<ptr target="http://www.neo4j.org/" />
		<title level="m">Neo4J</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<monogr>
		<title level="m" type="main">InfoGrid Web Graph Database</title>
		<author>
			<persName><forename type="first">Netmesh</forename><surname>Inc</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://infogrid.org/trac/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<title level="m" type="main">OrientDB Graph-Document NoSQL DBMS</title>
		<author>
			<persName><surname>Nuvolabase</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://www.orientdb.org/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<idno>05.08.13</idno>
		<ptr target="http://www.objectivity.com/infinitegraph" />
		<title level="m">InfiniteGraph</title>
		<imprint>
			<publisher>Objectivity Inc</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<author>
			<persName><forename type="first">Martin</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Altherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Cremet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Burak</forename><surname>Emir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stphane</forename><surname>Micheloud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Mihaylov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Schinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erik</forename><surname>Stenman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Zenger</surname></persName>
		</author>
		<ptr target="http://www.scala-lang.org/docu/files/ScalaReference.pdf" />
		<title level="m">The Scala Language Specification</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<author>
			<persName><forename type="first">Keith</forename><surname>Michael A Olson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Margo</forename><surname>Bostic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Berkeley</forename><surname>Seltzer</surname></persName>
		</author>
		<author>
			<persName><surname>Db</surname></persName>
		</author>
		<title level="m">Proceedings of the FREENIX Track: 1999 USENIX Annual Technical Conference</title>
		<meeting>the FREENIX Track: 1999 USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="183" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
		<title level="m" type="main">Analysis and classification of NoSQL databases and evaluation of their ability to replace an object-relational persistence layer</title>
		<author>
			<persName><forename type="first">Kai</forename><surname>Orend</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">The RAMCloud storage system</title>
		<author>
			<persName><forename type="first">John</forename><surname>Ousterhout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mendel</forename><surname>Rosenblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Rumble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><surname>Stutsman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arjun</forename><surname>Gopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankita</forename><surname>Kejriwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Collin</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Behnam</forename><surname>Montazeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Ongaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jin</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><surname>Qin</surname></persName>
		</author>
		<idno type="DOI">10.1145/2806887</idno>
		<ptr target="http://dl.acm.org/citation.cfm?doid¼2818727.2806887" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<idno type="ISSN">07342071</idno>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="55" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">RDBMS to NoSQL: reviewing some next-generation non-relational database&apos;s</title>
		<author>
			<persName><forename type="first">Rabi</forename><surname>Prasad Padhy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manas</forename><surname>Ranjan Patra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chandra</forename><surname>Suresh</surname></persName>
		</author>
		<author>
			<persName><surname>Satapathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Adv. Eng. Sci. Technol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="15" to="30" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">YCSB þ þ: benchmarking and performance debugging advanced features in scalable table stores</title>
		<author>
			<persName><forename type="first">Swapnil</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Milo</forename><surname>Polte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wittawat</forename><surname>Tantisiriroj</surname></persName>
		</author>
		<idno type="DOI">10.1145/2040000/2038925/a9-patil.pdf?ip216.47.142.197accACTIVESERVICECFID109271215CFTOKEN98003812acm1346244093a6bcc6cb50e08c5afe762da04819e6b5backslashn</idno>
		<ptr target="nhttp://dl.acm.org/citation.cfm?id¼2038925" />
	</analytic>
	<monogr>
		<title level="m">?ip ¼216.47.142.197{&amp;}acc ¼ ACTIVESERVICE{&amp;}CFID ¼109271215{&amp;}CFTOKEN ¼98003812{&amp;} {_}{_}acm{_}{_}¼ 1346244093{_}a6bcc6</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
	<note>Proceedings of the 2nd ACM Symposium on Cloud Computing, ACM. cb50e08c5afe762 da04819e6b5$backslash</note>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Interpreting the data: parallel analysis with Sawzall</title>
		<author>
			<persName><forename type="first">Rob</forename><surname>Pike</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Dorward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Griesemer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><surname>Quinlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Program. J</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="277" to="298" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">BASE: an acid alternative</title>
		<author>
			<persName><forename type="first">San</forename><surname>Pritchett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Queue</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="48" to="55" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<monogr>
		<title level="m" type="main">SPARQL query language for RDF, W3C Recomm</title>
		<author>
			<persName><forename type="first">Eric</forename><surname>Prud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">'</forename><surname>Hommeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Seaborne</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Marko</forename><forename type="middle">A</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gremlin</forename></persName>
		</author>
		<idno>05.08.13</idno>
		<ptr target="http://github.com/tinkerpop/gremlin/wiki" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<monogr>
		<title level="m" type="main">Alchemy Database-A Hybrid Relational-Database/ NOSQL-Datastore</title>
		<author>
			<persName><forename type="first">Sullivan</forename><surname>Russell</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="https://code.google.com/p/alchemydatabase/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">A survey of large scale data management approaches in cloud environments</title>
		<author>
			<persName><forename type="first">Anna</forename><surname>Sherif Sakr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohammad</forename><surname>Batista</surname></persName>
		</author>
		<author>
			<persName><surname>Alomari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun. Surv. Tutorials</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="311" to="336" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Hybrid query execution engine for large attributed graphs</title>
		<author>
			<persName><forename type="first">Sameh</forename><surname>Sherif Sakr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuxiong</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName><surname>He</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.is.2013.10.007</idno>
		<ptr target="http://linkinghub.elsevier.com/retrieve/pii/S0306437913001452" />
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<idno type="ISSN">03064379</idno>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="45" to="73" />
			<date type="published" when="2014-05">May. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Salvatore</forename><surname>Sanfilippo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Redis</forename></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://redis.io" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Scalaris: reliable transactional p2p key/value store</title>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Schutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Schintke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Reinefeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM SIGPLAN workshop on ERLANG</title>
		<meeting>the 7th ACM SIGPLAN workshop on ERLANG</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<monogr>
		<title level="m" type="main">The Trinity Graph Engine</title>
		<author>
			<persName><forename type="first">Bin</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yatao</forename><surname>Li</surname></persName>
		</author>
		<idno>MSR-TR-2012-30</idno>
		<imprint>
			<date type="published" when="2012-03">March 2012</date>
			<publisher>Microsoft Research</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b97">
	<monogr>
		<title level="m" type="main">* Phoenix Tong, F1-the fault-tolerant distributed rdbms supporting google&apos;s ad business</title>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Shute</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mircea</forename><surname>Oancea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Ellner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ben</forename><surname>Handy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Rollins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Samwel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radek</forename><surname>Vingralek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chad</forename><surname>Whipkey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Beat</forename><surname>Jegerlehner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyle</forename><surname>Littlefield</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">The Hadoop distributed file system</title>
		<author>
			<persName><forename type="first">Konstantin</forename><surname>Shvachko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hairong</forename><surname>Kuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Radia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Chansler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th IEEE Symposium on Mass Storage Systems and Technologies (MSST 2010)</title>
		<meeting>the 26th IEEE Symposium on Mass Storage Systems and Technologies (MSST 2010)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<monogr>
		<title level="m" type="main">Thrift: scalable cross-language services implementation, Facebook White Pap</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Slee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Chord: a scalable peer-to-peer lookup service for Internet applications</title>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Comput. Commun. Rev</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="149" to="160" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">New opportunities for New SQL</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="10" to="11" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">10 rules for scalable performance in &apos;simple operation&apos; datastores</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rick</forename><surname>Cattell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="72" to="80" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">The VoltDB main memory DBMS</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Weisberg</surname></persName>
		</author>
		<ptr target="http://sites.computer.org/debull/a13june/voltdb1.pdf" />
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="page" from="21" to="27" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">NoSQL databases</title>
		<author>
			<persName><forename type="first">Christof</forename><surname>Strauch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Walter</forename><surname>Kriha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
		<respStmt>
			<orgName>Stuttgart Media University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<monogr>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Strozzi</surname></persName>
		</author>
		<idno>05.07.13</idno>
		<ptr target="http://www.strozzi.it/cgi-bin/CSA/tw7/I/en_US/nosql/Home-Page" />
		<title level="m">NoSQL Relational Database Management System: Home Page</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Llc</forename><surname>Systap</surname></persName>
		</author>
		<author>
			<persName><surname>Bigdata</surname></persName>
		</author>
		<idno>05.08.13</idno>
		<ptr target="http://www.systap.com/bigdata.htm" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Comparative study of the new generation, agile, scalable, high performance NOSQL databases</title>
		<author>
			<persName><forename type="first">Clarence</forename><surname>Tauro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Aravindh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shreeharsha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Comput. Appl</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">20</biblScope>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<monogr>
		<title level="m" type="main">The Definitive Guide to Terracotta: Cluster the JVM for Spring, Hibernate and POJO Scalability: Cluster the JVM for Spring</title>
		<author>
			<persName><forename type="first">Inc</forename><surname>Terracotta</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Hibernate and POJO Scalability, Apress</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Raghotham Murthy, Hive: a warehousing solution over a map-reduce framework</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Thusoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joydeep</forename><surname>Sarma Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Namit</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zheng</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prasad</forename><surname>Chakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suresh</forename><surname>Anthony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pete</forename><surname>Wyckoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1626" to="1629" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">A comparison between several NoSQL databases with comments and notes</title>
		<author>
			<persName><forename type="first">Bogdan</forename><surname>George Tudorica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Bucur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Roedunet International Conference</title>
		<meeting>the 10th Roedunet International Conference</meeting>
		<imprint>
			<date type="published" when="2011">RoEduNet 2011. 2011</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<monogr>
		<idno>05.08.13</idno>
		<ptr target="http://github.com/twitter/flockdb" />
		<title level="m">FlockDB</title>
		<imprint>
			<publisher>Twitter Inc</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<monogr>
		<title level="m" type="main">No relation: the mixed blessings of non-relational databases</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Varley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<pubPlace>Austin, Texas</pubPlace>
		</imprint>
		<respStmt>
			<orgName>The University of Texas</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">Eventually consistent</title>
		<author>
			<persName><forename type="first">Werner</forename><surname>Vogels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="40" to="44" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">BigData-Bench: a big data benchmark suite from Internet services</title>
		<author>
			<persName><forename type="first">Lei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianfeng</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chunjie</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuqing</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiang</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongqiang</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wanling</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhen</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yingjie</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shujie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chen</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kent</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaona</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bizhu</forename><surname>Qiu</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2014.6835958</idno>
		<ptr target="http://dx.doi.org/10.1109/HPCA.2014.6835958" />
	</analytic>
	<monogr>
		<title level="m">Proceedings-International Symposium on High-Performance Computer Architecture</title>
		<meeting>-International Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="488" to="499" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
