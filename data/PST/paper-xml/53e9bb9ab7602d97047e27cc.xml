<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Expressive ABox Reasoning with Number Restrictions, Role Hierarchies, and Transitively Closed Roles</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Volker</forename><surname>Haarslev</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Hamburg</orgName>
								<address>
									<addrLine>Vogt-Kölln-Str. 30</addrLine>
									<postCode>22527</postCode>
									<settlement>Hamburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ralf</forename><surname>Möller</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Hamburg</orgName>
								<address>
									<addrLine>Vogt-Kölln-Str. 30</addrLine>
									<postCode>22527</postCode>
									<settlement>Hamburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Expressive ABox Reasoning with Number Restrictions, Role Hierarchies, and Transitively Closed Roles</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">47DC37FFF279CBFF8185DCB1F80D08FA</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:21+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present a new tableaux calculus deciding the ABox consistency problem for the expressive description logic ALCN H R + . Prominent language features of ALCN H R + are number restrictions, role hierarchies, transitively closed roles, and generalized concept inclusions. The ABox description logic system RACE is based on the calculus for ALCN H R + .</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Experiences with concept languages indicate that at least description logics (DLs) with negation and disjunction are required to solve practical modeling problems without resorting to ad hoc extensions. The requirements derived from practical applications of DLs ask for even more expressive languages. For instance, in <ref type="bibr" target="#b13">[14]</ref> the need for transitive roles is demonstrated for representing part-whole relations, family relations or partial orders in general. It is argued that the trade-off between expressivity and complexity favors the integration of transitively closed roles instead of a transitive closure operator for roles. Other examples are given in <ref type="bibr" target="#b7">[8]</ref>, where the area of medical terminology is discussed. Design studies for the Galen project identified the need for modeling of transitive part-whole, causal and compositional relations, and to organize these relations into a hierarchy. Moreover, generalized concept inclusions were also required as a modeling tool, e.g. for expressing sufficient conditions of concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Description Logic ALCN H R +</head><p>Motivated by the above-mentioned requirements we introduce in this paper an ABox tableaux calculus for the description logic ALCN H R + . It augments the basic logic ALC <ref type="bibr" target="#b14">[15]</ref> with number restrictions, role hierarchies, and transitively closed roles. Note that these language features imply the presence of generalized concept inclusions and cyclic concepts. The use of number restrictions in combination with transitive roles and role hierarchies is syntactically restricted: no number restrictions are possible for (i) transitive roles and (ii) for any role which has a transitive subrole. Furthermore, we assume that the unique name assumption holds for ABox individuals.</p><p>ALCN H R + is an extension of ALCN H that itself can be polynomially reduced to ALCN R <ref type="bibr" target="#b0">[1]</ref> and vice versa. It is possible to rephrase every hierarchy of role names with a set of role conjunctions and vice versa <ref type="bibr" target="#b0">[1]</ref>. Thus, our work on ALCN H R + extends the work on ALCN R by additionally providing transitively closed roles. ALCN H R + also extends other related description logics such as ALC R + <ref type="bibr" target="#b13">[14]</ref> and ALCHf R + <ref type="bibr" target="#b7">[8]</ref>. Recently, the work on these logics has been extended and a tableaux calculus for deciding concept consistency for the language ALCQHI R + has been presented in <ref type="bibr" target="#b10">[11]</ref>. Another approach is presented in <ref type="bibr" target="#b1">[2]</ref> where the logic CIQ for reasoning with TBoxes and ABoxes is introduced. In comparison to ALCN H R + and the other approaches mentioned above CIQ offers more operators (e.g. the transitive closure) but does not support role hierarchies and allows number restrictions only for primitive roles.</p><p>ABox reasoning truly extends the usefulness of description logics in practical applications. The increase of expressiveness is also reflected in an increase of the complexity of the tableaux rules (see Section 4.1 for more details). An alternative might be the so-called "precompletion approach" originally developed for the language ALCQ <ref type="bibr" target="#b6">[7]</ref> and recently adapted to ALCH R + <ref type="bibr" target="#b15">[16]</ref>. The idea behind the precompletion approach is to transform given ABoxes in a way such that ABox satisfiability is reduced to concept satisfiability. How-ever, there currently exist no calculi for computing the precompletion of ABoxes for languages such as ALCN H R + or even ALCQHI R + .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Concept Language</head><p>We present the syntax and semantics of the language for specifying concept and role inclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Role Inclusions, Role Hierarchy)</head><p>Let P and T be disjoint sets of non-transitive and transitive role names, respectively, and let R be defined as R = P ∪ T . Let R and S be role names, then R S (role inclusion axiom) is a terminological axiom. Given a set of role inclusion axioms, we define a role hierarchy where * is the reflexive transitive closure of over R.</p><p>Additionally we define the set of ancestors and descendants of a role. Definition 3 (Concept Terms) Let C be a set of concept names which is disjoint from R. Any element of C is a concept term. If C and D are concept terms, R ∈ R is an arbitrary role, S ∈ S is a simple role, n &gt; 1, and m &gt; 0, then the following expressions are also concept terms:</p><formula xml:id="formula_0">• (top concept), • ⊥ (bottom concept), • C D (conjunction), • C D (disjunction), • ¬C (negation), • ∀ R . C (concept value restriction), • ∃ R . C (concept exists restriction),</formula><p>• ∃ ≤m S (at most number restriction), • ∃ ≥n S (at least number restriction).</p><p>For an arbitrary role R, the term ∃ ≥1 R can be rewritten as ∃ R . , ∃ ≥0 R as , and ∃ ≤0 R as ∀ R . ⊥. Thus, we do not consider these terms as number restrictions in our language.</p><p>The concept language is syntactically restricting the combination of number restrictions and transitive roles. Number restrictions are only allowed for simple roles. This restriction is motivated by doubtful semantics for an unrestricted combinability and a simplified tableaux decision procedure. Moreover, this decision is supported by a recent undecidability result for the logic ALCHN I R + in case of an unrestricted combinability <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Generalized Concept Inclusions)</head><p>If C and D are concept terms, then C D (generalized concept inclusion or GCI ) is a terminological axiom as well.</p><p>A finite set of terminological axioms T is called a terminology or TBox . GCIs can be used to represent terminological cycles. There exist at least two ways to deal with GCIs in a tableaux calculus. The 'internalization' approach (e.g. see in <ref type="bibr" target="#b8">[9]</ref>) makes use of the fact that the expressiveness of GCIs is already implied by the combination of role hierarchies and transitive roles. However, with the presence of arbitrary ABoxes one has also to consider unrelated individuals. Therefore, we pursue a different and more direct approach that extends an ABox tableaux calculus by new constructs and rules directly dealing with GCIs (see <ref type="bibr">Definition 7)</ref>.</p><p>The next definition gives a set-theoretic semantics to the language introduced above.  </p><formula xml:id="formula_1">(C D) I := C I ∩ D I (C D) I := C I ∪ D I (¬C) I := ∆ I \ C I (∃ R . C) I := {a ∈ ∆ I | ∃ b ∈ ∆ I : (a, b) ∈ R I , b ∈ C I } (∀ R . C) I := {a ∈ ∆ I | ∀ b ∈ ∆ I : (a, b) ∈ R I ⇒ b ∈ C I } (∃ ≥n R) I := {a ∈ ∆ I | {b | (a, b) ∈ R I } ≥ n} (∃ ≤n R) I := {a ∈ ∆ I | {b | (a, b) ∈ R I } ≤</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Assertional Language</head><p>In the following, the language for representing knowledge about individual worlds is introduced. An ABox A is a finite set of assertional axioms which are defined as follows: </p><formula xml:id="formula_2">Definition 6 (ABox Assertions) Let O = O O ∪ O N be</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">An ABox Example</head><p>Before we continue with the calculus for ALCN H R + , we illustrate in the following the expressiveness of ALCN H R + with a TBox and ABox example about family relationships. This example uses prominent features of ALCN H R + such as transitive roles, role hierarchies, number restrictions and generalized concept inclusions.</p><p>In the TBox family we assume a role has descendant which is declared to be transitive, has gender which is declared as a feature (e.g. this can be achieved by adding the axiom ∃ ≤1 has gender), and a role has sibling. The TBox family contains the following role axioms. The next axioms describe some aspects of relatives of a family. Note the inferred equivalences between the concept pairs "mother with . . ." and "mother having . . ." as shown in Figure <ref type="figure" target="#fig_2">1</ref>. </p><formula xml:id="formula_3">mother</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Tableaux Calculus for ALCN H R +</head><p>In the following we devise a tableaux algorithm to decide the consistency of ALCN H R + ABoxes. The algorithm is characterized by a set of tableaux or completion rules and by a particular completion strategy ensuring a specific order for applying the completion rules to assertional axioms of an ABox. The strategy is essential to guarantee the completeness of the ABox consistency algorithm. First, we have to introduce new assertional axioms needed to define the augmentation of an ABox.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7 (Additional ABox Assertions) Let</head><p>C be a concept term, the individual names a, b ∈ O, and x ∈ O , then the following expressions are also assertional axioms:</p><formula xml:id="formula_4">• ∀ x . x : C (universal concept assertion), 1 • a . = b (inequality assertion).</formula><p>An interpretation I satisfies an assertional axiom</p><formula xml:id="formula_5">∀ x . x : C iff C I = ∆ I and a . = b iff a I = b I .</formula><p>Given the new ABox assertions we define for any concept term its negation normal form that is needed to introduce the notion of an augmented ABox.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (Negation Normal Form)</head><p>The same naming conventions as in Definition 3 are assumed. The negation normal form is defined by applying the following transformations in such a way that a negation sign may occur only in front of concept names. This transformation is possible in linear time: </p><formula xml:id="formula_6">• ¬ ≡ ⊥, • ¬⊥ ≡ , • ¬(C D) ≡ ¬C ¬D, • ¬(C D) ≡ ¬C ¬D, • ¬∀ R . C ≡ ∃ R . ¬C, • ¬∃ R . C ≡ ∀ R . ¬C, • ¬∃ ≤m S ≡ ∃ ≥m +1 S, • ¬∃ ≥m S ≡ ∃ ≤m -1 S.</formula><formula xml:id="formula_7">. = a j | a i , a j ∈ O O , i, j ∈ 1.</formula><p>.n, i = j} is added to A. From this point on, if we refer to an initial ABox A we always mean its augmented ABox.</p><p>The tableaux rules also require the notion of blocking their applicability. This is based on so-called concept sets, an ordering for new individuals, and blocking individuals. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10 (Concept</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Completion Rules</head><p>We are now ready to define the completion rules that are intended to generate a so-called completion of an ABox (see also below).   "⇒" In order to show that A is satisfiable after applying a deterministic rule to the satisfiable ABox A, we examine each applicable rule separately. We assume that I = (∆ I , • I ) satisfies A. If the number restriction exists rule is applied to a :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 13 (Completion</head><formula xml:id="formula_8">, . . . , b n ∈ O , S 1 , . . . , S n ∈ R ↓ : {(a, b k ) : S k | k ∈ 1..n} ∪ {b i . = b j | i, j ∈ 1..n, i = j} ⊆ A then A = A ∪ {(a, b k ) : R | k ∈ 1..n} ∪ {b i . = b j | i,</formula><formula xml:id="formula_9">: i = j, b i . = b j ∈ A then A = A[b i /b j ], i.e. replace</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>If the conjunction rule is applied to a : C D ∈ A, then we get a new Abox</head><formula xml:id="formula_10">∃ ≥n R ∈ A, then we get A = A ∪ {(a, b k ) : R | k ∈ 1..n} ∪ {b i . = b j | i, j ∈ 1..n, i = j}. Since I satisfies A, there must exist n distinct in- dividuals y i ∈ ∆ I , i ∈ 1..n such that (a I , y i ) ∈ R I .</formula><p>We define the interpretation function • I such that b i I := y i and x I := x I for x ∈ {b 1 , . . . , b n }. It is easy to show that I = (∆ I , • I ) satisfies A .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">"⇐"</head><p>Assume that A is satisfied by I = (∆ I , • I ). We show that A is also satisfiable by examining the nondeterministic rules.</p><p>If A is obtained from A by applying the disjunction rule, then A is a subset of A and therefore satisfied by I .</p><p>If A is obtained from A by applying the number restriction merge rule to a : Given an initial ABox A, more than one rule might be applicable to A. This is controlled by a completion strategy in accordance to the ordering for new individuals (see <ref type="bibr">Definition 11)</ref>.</p><formula xml:id="formula_11">∃ ≤n R ∈ A, then there ex- ist b i , b j in A such that A = A[b i /b j ]. We</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 15 (Completion Strategy)</head><p>We define a completion strategy that must observe the following restrictions.</p><p>• Meta rules:</p><formula xml:id="formula_12">-Apply a rule to an individual b ∈ O N only if no rule is applicable to an individual a ∈ O O . -Apply a rule to an individual b ∈ O N only if no rule is applicable to another individual a ∈ O N such that a ≺ b.</formula><p>• The completion rules are always applied in the following order. A step is skipped in case the corresponding set of applicable rules is empty.</p><p>1. Apply all nongenerating rules (R , R , R∀C, R∀ + C, R∀ x , R∃ ≤n ) as long as possible. 2. Apply a generating rule (R∃C, R∃ ≥n ) and restart with step 1 as long as possible.</p><p>In the following we always assume that rules are applied in accordance to this strategy. It ensures that the rules are applied to new individuals w.r.t. the ordering '≺'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 16 (Clash Triggers)</head><p>We assume the same naming conventions as used above. An ABox A is called contradictory if one of the following clash triggers is applicable. If none of the clash triggers is applicable to A, then A is called clash-free.</p><p>• Primitive clash: a : ⊥ ∈ A or {a : C, a : ¬C} ⊆ A, where C is a concept name.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Number restriction merging clash</head><formula xml:id="formula_13">: ∃S 1 , . . . , S m ∈ R ↓ : {a : ∃ ≤n R} ∪ {(a, b i ) : S i | i ∈ 1..m} ∪ {b i . = b j | i, j ∈ 1..m, i = j} ⊆ A with m &gt; n</formula><p>A clash-free ABox A is called complete if no completion rule is applicable to A. A complete ABox A derived from an ABox A is also called a completion of A. Any ABox containing a clash is obviously unsatisfiable. The purpose of the calculus is to generate a completion for an initial ABox A that proves the satisfiability of A or its unsatisfiability if no completion can be found. In the following we have to show that a model can be constructed for any complete ABox.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Decidability of the ABox Consistency Problem</head><p>The following lemma proves that whenever a generating rule has been applied to an individual a, the concept set σ(•, a) of a does not change in succeeding ABoxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 17 (Stability)</head><p>Let A be an ABox and a ∈ O N be in A. Let a generating rule be applicable to a according to the completion strategy. Let A be any ABox derivable from A by any (possibly empty) sequence of rule applications. Then: </p><formula xml:id="formula_14">1. No rule is applicable in A to an individual b ∈ O N with b ≺ a 2. σ(A, a) = σ(A ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. 1. By contradiction: Suppose</head><formula xml:id="formula_15">A = A 0 → * • • • → * A n = A ,</formula><p>where * is element of the completion rules and a rule is applicable to an individual b with b ≺ a in A . Then there has to exist a minimal i with i ∈ 1..n such that this rule is also applicable in A i . If a rule is applicable to a in A then no rule is applicable to b in A due to our strategy. So no rule is applicable to any individual c such that c ≺ a in A 0 , . . . , A i-1 . It follows that from A i-1 to A i a rule is applied to a or to a d such that a ≺ d. Using an exhaustive case analysis of all rules we can show that no new assertion of the form b : C or (b, e) : R can be added to A i-1 . Therefore, no rule is applicable to b in A i . This is a contradiction to our assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>By contradiction: Suppose σ(A, a) = σ(A , a). Let b be the direct predecessor of a with b ≺ a. A rule must have been applied to a and not to b because of point 1. Due to our strategy only generating rules are applicable to a that cannot add new elements to σ(•, a). This is an obvious contradiction.</p><p>The next lemma guarantees the uniqueness of a blocking individual for a blocked individual. This is a precondition for defining a particular interpretation from A.</p><p>Lemma 18 Let A be an ABox and a be a new individual in A . If a is blocked then 1. a has no direct successor and 2. a has exactly one blocking individual.</p><p>Proof. 1. By contradiction: Suppose that a is blocked in A and (a, b) : R ∈ A . There must exist an ancestor ABox A where a generating rule has been applied to a in A. It follows from the definition of the generating rules that for every new individual c with c ≺ a in A we had σ(A, c) ⊇ σ(A, a). Since A has been derived from A we can use Lemma 17 and conclude that for every new individual c with c ≺ a in A we also have σ(A , c) ⊇ σ(A , a). Thus there cannot exist a blocking individual c for a in A . This is a contradiction to our hypothesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>This follows directly from condition 3 in Definition 12.</p><p>Definition 19 Let A be an ABox. We define the canonical interpretation I A = (∆ IA , • IA ) as follows:</p><formula xml:id="formula_16">1. ∆ IA := {a | a is an individual in A} 2. a IA := a iff a is mentioned in A 3. a ∈ A IA iff a : A ∈ A 4. (a, b) ∈ R IA iff (a) (a, b) : S ∈ A for a role S ∈ R ↓ or (b) ∃ c 1 , . . . , c n-1 in A : (a, c 1 ) : S 1 , (c 1 , c 2 ) : S 2 , . . . , (c n-1 , b) : S n ∈ A, n &gt; 1, S i ∈ R ↓ for i ∈ 1..n and R ∈ T , or (c) ∃ c in A, c ∈ O N , c is a blocking individual for a, and (c, b) : S ∈ A, for a role S ∈ R ↓ , or (d) ∃ c in A, c ∈ O N , c is a blocking individual for a, and (c, b 1 ) : S 1 ∈ A, and ∃ b 2 , . . . , b n-1 in A : (b 1 , b 2 ) : S 2 , . . . , (b n-1 , b) : S n ∈ A, n &gt; 1, S i ∈ R ↓ for i ∈ 1..n and R ∈ T .</formula><p>Theorem 20 (Soundness) Let A be a complete ABox, then A is satisfiable.</p><p>Proof. Let I A = (∆ IA , • IA ) be the canonical interpretation for the ABox A. In the following we prove that I A satisfies every assertion in A. If C = ¬D, then D is a concept name since all concepts are in negation normal form (see <ref type="bibr">Definition 9)</ref>. A is clash-free and cannot contain a : D. Thus, a ∈ D IA , i.e. a ∈ ∆ IA \ D IA . Hence a ∈ (¬D)</p><p>IA . Theorem 21 (Completeness) Let A be a satisfiable ABox, then there exists at least one completion of A computed by applying the completion rules.</p><formula xml:id="formula_17">If C = C 1 C 2 then (since A is complete) a : C 1 ∈ A and a : C 2 ∈ A. By induction hypothesis, a ∈ C 1 IA and a ∈ C 2 IA . Hence a ∈ (C 1 C 2 ) IA . If C = C 1 C 2 then (since A is complete) either a : C 1 ∈ A or a : C 2 ∈ A. By induction hypothesis, a ∈ C 1 IA or a ∈ C 2 IA . Hence a ∈ (C 1 C 2 ) IA . If C = ∀ R . D,</formula><p>Proof. Obviously, an Abox containing a clash is unsatisfiable. If every completion of A is unsatisfiable, then it follows from Proposition 14 that ABox A is unsatisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 22 For any augmentation of an initial</head><p>ABox A, we define the concept size n A as the number of concepts or subconcepts occurring in A. <ref type="foot" target="#foot_3">4</ref> Note that n A is bound by the length of the string expressing A. The size of an ABox A is defined as</p><formula xml:id="formula_18">n A × T + O O .</formula><p>Lemma 23 Let A be an ABox and let A be a completion of A. In any set X consisting of individuals occurring in A with a cardinality greater than 2 nA there exist at least two individuals a, b ∈ X whose concept sets are equal (a ≡ A b).</p><p>Proof. Each assertion a : C i ∈ A may contain at most n A different concepts C i . So there cannot exist more than 2 nA different concept sets for the individuals in A .</p><p>Lemma 24 Let A be an ABox and let A be a completion of A. Then there occur at most 2 nA non-blocked new individuals in A . Proof. Let A be a completion of A T . From Lemma 24 we know that A has at most 2 n non-blocked new individuals. Therefore, a total of at most m × 2 n new individuals may exists in A , where m is the maximum number of direct successors for any individual in A .</p><p>Note that m is bound by the number of ∃ R . C concepts (≤ n) plus the total sum of numbers occurring in ∃ ≥n R. Since numbers are expressed in binary, their sum is bound by 2 n . Hence, we have m ≤ 2 n + n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Since the number of individuals in the initial ABox is also bound by n, the total number of individuals in</head><formula xml:id="formula_19">A is at most m × (2 n + n) ≤ (2 n + n) × (2 n + n), i.e. O(2 2n ).</formula><p>The number of different assertions of the form a : C or ∀ x . x : C in which each individual in A can be involved, is bound by n and each assertion has a size linear in n. Hence, the total size of these assertions is bound n × n × 2 2n , i.e. O (2 3n ). Proof. This follows immediately from the Theorems 20, 21, and 25.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Practical Reasoning with RACE</head><p>The tableaux calculus introduced in the previous sections is of theoretical interest for proving the decidability of the ABox consistency problem. For practical purposes such calculi are highly inefficient. Therefore, the development of optimization techniques is a very important research topic. In order to support practical ABox reasoning with ALCN H R + and to empirically   evaluate optimization techniques for this tableaux calculus, the DL system RACE 5 has been developed <ref type="bibr" target="#b5">[6]</ref>. RACE implements an ALCN H R + reasoner for answering queries concerning ABoxes and TBoxes. It is a successor of HAM-ALC <ref type="bibr" target="#b2">[3]</ref>. The RACE architecture incorporates established and novel optimization techniques for TBox and ABox reasoning <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b4">5]</ref>.</p><p>The combined effectiveness of these and other techniques are demonstrated with knowledge bases (KBs) derived from actual applications (Figure <ref type="figure" target="#fig_0">2</ref>) and a set of ABox benchmark problems (Figures <ref type="figure" target="#fig_14">3,</ref><ref type="figure" target="#fig_15">4</ref>). The 'Galen' application KBs are described in <ref type="bibr" target="#b7">[8]</ref>. Their employed DLs range from ALE to ALCHf R + . The KBs 'ESPR', 'WISBER', 'CKB', and 'FSS' (using ALCN H with GCIs) are taken from previous DL benchmarks but role hierarchies and domain and/or range restrictions for primitive roles (using GCIs) are restored <ref type="bibr" target="#b3">[4]</ref>. The  'Bike' KBs (using ALCN H with GCIs) contain configuration knowledge about various types of bicycles. Their corresponding ABoxes describe example configurations of bikes. The KBs 'BCS3' and 'BCS4' (using ALC with GCIs) are derived from a telecommunication application. Their characteristics is the heavy use of terminological cycles and GCIs.</p><p>A set of five ABoxes is iteratively realized using the KBs 'bike7-9' (see Figure <ref type="figure" target="#fig_14">3</ref>). The ABoxes describe bike example configurations and exemplify typical classification tasks. The TBoxes 'bike7-9' are almost identical except that they vary in the degree of specifying disjointness between atomic concepts. Figure <ref type="figure" target="#fig_15">4</ref> reports on the runtimes for realizing synthetic ABoxes with an increasing level of difficulty (1-21, see <ref type="bibr" target="#b5">[6]</ref> for further explanations).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We presented the first treatment for a tableaux calculus deciding the ABox consistency problem for the description logic ALCN H R + . A highly optimized variant of this calculus is already implemented in the ABox description logic system RACE demonstrating the practical usefulness of ALCN H R + . Although TBox reasoners for logics such as ALCQHI R + are available, the development of ALCN H R + and its optimized implementation in RACE is a novel approach. Practical reasoning is only possible with the design and implementation of appropriate optimization techniques. This is supported by recent empirical findings suggesting that RACE dramatically outperforms other known DL reasoners for logics at least as expressive as ALCN H R + . To the best of our knowledge there currently exists no other ABox DL system with a performance comparable to RACE.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 2 (</head><label>2</label><figDesc>Role Descendants/Ancestors) Given a role hierarchy the set R ↑ := {S ∈ R | R * S} defines the ancestors and R ↓ := {S ∈ R | S * R} the descendants of a role R. We also define the set S := {R ∈ P | R ↓ ∩ T = ∅} of simple roles that are neither transitive nor have a transitive role as descendant.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 5 (</head><label>5</label><figDesc>Semantics) An interpretation I = (∆ I , • I ) consists of a set ∆ I (the domain) and an interpretation function • I . The interpretation function maps each concept name C to a subset C I of ∆ I , each role name R to a subset R I of ∆ I × ∆ I . Let the symbols C, D be concept expressions, and R, S be role names. Then the interpretation function can be extended to arbitrary concept and role terms as follows ( • denotes the cardinality of a set):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Concept hierarchy of the TBox family augmented with the individuals from the ABox smith family. Ovals represent atomic concepts, rectangles denote ABox individuals, solid lines show the direct subsumption relationship, and dashed lines the instance membership of the individuals for their direct types.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Set, A-blocked) Given an ABox A and an individual a occurring in A, we define the concept set of a as σ(A, a) := { } ∪ {C | a : C ∈ A}. We define two individuals as A-equivalent , written a ≡ A b, if their concept sets are equal, i.e. σ(A, a) = σ(A, b). We say that an individual b is A-blocked 2 by a, written a A b, if σ(A, a) ⊇ σ(A, b). Definition 11 (Individual Ordering) We define an individual ordering '≺' for new individuals (elements of O N ) occurring in an ABox A. If b ∈ O N is introduced in A, then a ≺ b for all new individuals a already present in A. Definition 12 (Blocking Individual) Let A be an ABox and a, b ∈ O N be individuals in A. We call a the blocking individual of b if the following conditions hold: 1. a A b 2. a ≺ b 3. ¬∃ c in A : c ∈ O N , c ≺ a, c A b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>R</head><label></label><figDesc>Rules) The conjunction rule. if 1. a : C D ∈ A, and 2. {a : C, a : D} ⊆ A then A = A ∪ {a : C, a : D} R The disjunction rule. if 1. a : C D ∈ A, and 2. {a : C, a : D} ∩ A = ∅ then A = A ∪ {a : C} or A = A ∪ {a : D} R∀C The role value restriction rule. if 1. a : ∀ R . C ∈ A, and 2. ∃ b ∈ O , S ∈ R ↓ : (a, b) : S ∈ A, and 3. b : C ∈ A then A = A ∪ {b : C} 2 We may omit the reference to A by speaking of blocked if the context is obvious.R∀ + C The transitive role value restriction rule. if 1. a : ∀ R . C ∈ A, and 2. ∃ b ∈ O , T ∈ R ↓ , T ∈ T , S ∈ T ↓ : (a, b) : S ∈ A, and 3. b : ∀ T . C ∈ A then A = A ∪ {b : ∀ T . C} R∀ x The universal concept restriction rule. if 1. ∀ x . x : C ∈ A, and 2. ∃ a ∈ O : a mentioned in A, and 3. a : C ∈ A then A = A ∪ {a : C} R∃C The role exists restriction rule. if 1. a : ∃ R . C ∈ A, and 2. a ∈ O N ⇒ (¬∃ c in A : c ∈ O N , c is a blocking individual for a), and 3. ¬∃ b ∈ O , S ∈ R ↓ : {(a, b) : S, b : C} ⊆ A then A = A ∪ {(a, b) : R, b : C} where b ∈ O N is not used in A R∃ ≥n The number restriction exists rule. if 1. a : ∃ ≥n R ∈ A, and 2. a ∈ O N ⇒ (¬∃ c in A : c ∈ O N , c is a blocking individual for a), and 3. ¬∃ b 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>j ∈ 1..n, i = j} where b 1 , . . . , b n ∈ O N are not used in A R∃ ≤n The number restriction merge rule. if 1. a : ∃ ≤n R ∈ A, and 2. ∃ b 1 , . . . , b m ∈ O , S 1 , . . . , S m ∈ R ↓ : {(a, b 1 ) : S 1 , . . . , (a, b m ) : S m } ⊆ A with m &gt; n, and 3. ∃ b i , b j ∈ {b 1 , . . . , b m }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>A = A ∪ {a : C, a : D}. Since I satisfies a : C D, I satisfies a : C and a : D and therefore A . If the role value restriction rule is applied to a : ∀ R . C ∈ A, then there must be a role assertion (a, b) : S ∈ A with S ∈ R ↓ such that A = A ∪ {b : C}. Since I satisfies A, it holds that (a I , b I ) ∈ S I ⊆ R I . Since I satisfies a : ∀ R . C, it holds that b I ∈ C I . Thus, I satisfies b : C and therefore A . If the transitive role value restriction rule is applied to a : ∀ R . C ∈ A, there must be an assertion (a, b) : S ∈ A with S ∈ T ↓ ⊆ R ↓ , T ∈ T such that we get A = A ∪ {b : ∀ T . C}. Since I satisfies A, we have a I ∈ (∀ R . C) I and (a I , b I ) ∈ S I ⊆ T I ⊆ R I . Since I satisfies a : ∀ T . C and T ∈ T , T ∈ R ↓ , it holds that b I ∈ (∀ T . C) I unless there exists a successor c of b such that (b, c) : S ∈ A, (b I , c I ) ∈ S I ⊆ T I and c I ∈ C I . It follows from (a I , b I ) ∈ T I , (b I , c I ) ∈ T I , and T ∈ T that (a I , c I ) ∈ T I ⊆ R I and a I ∈ (∀ R . C) I in contradiction to the assumption. Thus, I satisfies b : ∀ T . C and therefore A . If the universal concept restriction rule is applied to an individual a in A because of ∀ x . x : C ∈ A, then A = A ∪ {a : C}. Since I satisfies A, it holds that C I = ∆ I . Thus, it holds that a I ∈ C I and I satisfies A . If the role exists restriction rule is applied to a : ∃ R . C ∈ A, then we get the ABox A = A ∪ {(a, b) : R, b : C}. Since I satisfies A, there exists a y ∈ ∆ I such that (a I , y) ∈ R I and y ∈ C I . We define the interpretation function • I such that b I := y and x I := x I for x = b. It is easy to show that I = (∆ I , • I ) satisfies A .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>define the interpretation function • I such that b i I := b j I and x I := x I for every x = b i . Obviously I = (∆ I , • I ) satisfies A. "⇒" We suppose that I = (∆ I , • I ) satisfies A and a nondeterministic rule is applicable to an individual a in A. If the disjunction rule is applicable to a : C D ∈ A and A is satisfiable, it holds a I ∈ (C D) I . It follows that either a I ∈ C I or a I ∈ D I (or both). Hence, the disjunction rule can be applied in a way that I also satisfies the ABox A . If the number restriction merge rule is applicable to a : ∃ ≤n R ∈ A and A is satisfiable, it holds a I ∈ (∃ ≤n R) I and {b | (a, b) ∈ R I } ≤ n. However, it also holds {b | (a I , b I ) ∈ R I } &gt; m with m ≥ n. 3 Thus, we can conclude by the Pigeonhole Principle (e.g. see [13, page 26]) that there exist at least two R-successors b i , b j of a such that b i I = b j I . Since I satisfies A, we have b i . = b j ∈ A and at least one of the two individuals must be a new individual. Let us assume that b i ∈ O N and b i = b j , then I obviously satisfies A[b i /b j ].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>a), i.e. the concept set of a remains unchanged in A . 3. If b ∈ O N is in A with b ≺ a then b is an individual in A , i.e. the individual b is not substituted by another individual.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>For any (a, b) : R ∈ A or a . = b ∈ A, I A satisfies them by definition. Next we consider assertions of the form a : C. We show by induction on the structure of C that a ∈ C IA . If C is a concept name, then a ∈ C IA by definition of I A . If C = , then obviously a ∈ IA . The case C = ⊥ cannot occur since A is clash-free.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>then we have to show that for all b with (a, b) ∈ R IA it holds that b ∈ D IA . If (a, b) ∈ R IA , then according to Definition 19 the following cases can occur: (4a) b is a direct S-successor of a for a role S ∈ R ↓ with S IA ⊆ R IA ; then we have b : D ∈ A since A is complete and by induction hypothesis b ∈ D IA . (4b) b is a R-successor of a via a subrole chain of S i 's with S i IA ⊆ R IA , R ∈ T ; then we have c n-1 : ∀ R . D ∈ A and b : D ∈ A since A is complete and by induction hypothesis we have b ∈ D IA . (4c) There has to exist a blocking individual c such that c : ∀ R . D ∈ A and (c, b) : S ∈ A for a role S ∈ R ↓ and because A is complete we have b : D ∈ A and again by induction hypothesis it holds b ∈ D IA . (4d) This case combines the cases (4b-c) because the individual b is reachable from the blocking individual c via a chain of subroles of the transitive role R. It can be proven analogously. If C = ∃ R . D, then we have to show that there exists an individual b ∈ ∆ IA with (a, b) ∈ R IA and b ∈ D IA . Since ABox A is complete, we have either (a, b) : R ∈ A and b : D ∈ A or a is blocked by an individual c and (c, b) : R ∈ A. In the first case we have (a, b) ∈ R IA and b ∈ D IA by induction hypothesis and the definition of I A . In the second case there exists the blocking individual c with c : ∃ R . D ∈ A. By definition c cannot be blocked and by hypothesis A is complete. So we have an individual b with (c, b) : R ∈ A and b : D ∈ A. By induction hypothesis we have b ∈ D IA and by the definition of I A (case 4c) we have (a, b) ∈ R IA . If C = ∃ ≥n R, we prove the hypothesis by contradiction. We assume that a ∈ (∃ ≥n R) IA . Then there exist at most m (0 ≤ m &lt; n) distinct R-successors of a. Two cases can occur: (1) the individual a is not blocked in I A . Then we have less than n R-successors of a in A and the R∃ ≥n -rule is applicable to a. This contradicts the assumption that A is complete. (2) a is blocked by an individual c but the same argument as in case (1) holds and leads to the same contradiction. For C = ∃ ≤n R we show the goal by contradiction. Suppose that a ∈ (∃ ≤n R) IA . Then there exist at least n + 1 distinct individuals b 1 , . . . , b n+1 such that (a, b i ) ∈ R IA , i ∈ 1..n + 1. According to Definition 19 the following two cases can occur. (1) We have n + 1 (a, b i ) : S i ∈ A with S i ∈ R ↓ and S i ∈ T , i ∈ 1..n + 1. The R∃ ≤n rule cannot be applicable since A is complete and the b i are distinct, i.e. b i . = b j ∈ A, i, j ∈ 1..n + 1, i = j. This contradicts the assumption that A is clash-free. (2) There exists a blocking individual c with (c, b i ) : S i ∈ A, S i ∈ R ↓ , and S i ∈ T , i ∈ 1..n + 1. This leads to an analogous contradiction. If ∀ x . x : D ∈ A, then -due to the completeness of Afor each individual a in A we have a : D ∈ A and, by the previous cases, a ∈ D IA . Thus, I A satisfies ∀ x . x : D. Finally, since I A satisfies all assertions in A, I A satisfies A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Proof.</head><label></label><figDesc>Suppose we have 2 nA + 1 non-blocked new individuals in A . From Lemma 23 we know that there exist at least two individuals a, b in A such that a ≡ A b. By Definition 11 we have either a ≺ b or b ≺ a. Assume without loss of generality that a ≺ b holds and a ≡ A b implies σ(A , a) ⊇ σ(A , b). Then we have either a A b or there exists an individual c with c A b and c ≺ a. Both cases contradict the hypothesis.Theorem 25 (Termination) Let A T be the augmented ABox w.r.t a TBox T and let n be the size of A T . Every completion of A T is finite and its size is O(2 4n ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>ESP WIS CKB FSS Bk1 Bk2 Bk3 Bk4 Bk5 Bk6 Bk7 Bk8 Bk9 BC3 BC4 Runtimes in secs for application knowledge bases (Gal=Galen, Bk=Bike, BC=BCS)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Runtimes for application KBs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Runtimes for Bike TBoxes and ABoxes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Runtimes for synthetic ABoxes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>I = (R I ) + . A concept term C subsumes a concept term D w.r.t. a TBox T (written D T C), iff D I ⊆ C I for all models I of T . A concept term C is satisfiable w.r.t. a TBox T iff there exists a model I of T such that C I = ∅.</figDesc><table><row><cell>One of the basic reasoning services for a description</cell></row><row><cell>logic formalism is computing the subsumption rela-</cell></row><row><cell>tionship for atomic concepts. This inference is needed</cell></row><row><cell>in the TBox to build a hierarchy of concept names</cell></row><row><cell>w.r.t. specificity. Satisfiability and subsumption can</cell></row><row><cell>be mutually reduced to each other since C T D iff</cell></row><row><cell>C ¬D is not satisfiable w.r.t. T and C is unsatisfi-</cell></row><row><cell>able w.r.t. T iff C T ⊥.</cell></row></table><note><p>n} An interpretation I is a model of a TBox T iff it satisfies (1) C I ⊆ D I for all terminological axioms (GCIs) C D in T and R I ⊆ S I for all terminological axioms R S (role inclusions) in T , and (2) iff for every R ∈ T : R</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Using the TBox family, the ABox smith family is specified. It consists of several assertions about the individuals alice, betty, charles, doris, and eve. The individual alice is the mother of her two children betty and charles. These inferences demonstrate the expressiveness of ALCN H R + . The ABox smith family contains only minimal knowledge about the individuals and their relationships.</figDesc><table /><note><p>having only female kids . = mother ∀ has child . ∀ has gender . female mother having only daughters . = mother ∃ ≥1 has child ∀ has child . woman mother with kids . = mother ∃ ≥2 has child grandpa . = man ∃ has child . parent great grandpa . = man ∃ has child . (∃ has child . parent) grandma . = woman ∃ has child . parent great grandma . = woman ∃ has child . (∃ has child . parent) aunt . = woman ∃ has sibling . parent uncle . = man ∃ has sibling . parent sibling . = sister brother sister . = woman ∃ ≥1 has sibling brother . = man ∃ ≥1 has sibling mother with siblings . = mother ∀ has child . sibling There still exists no formal relationship between the notions "having kids" and "having siblings." This is expressed by the next two axioms. The last axiom defines a concept mother having only sisters which has the other specific "mother . . ." concepts as parents (see Figure 1). ∃ ≥2 has child ∀ has child . sibling ∃ has child . sibling ∃ ≥2 has child mother having only sisters . = mother ∀ has child . (sister ∀ has sibling . sister) alice : woman ∃ ≤2 has child (alice, betty) : has child (alice, charles) : has child The individual betty is the sibling of charles and the mother of doris and eve, who are the only siblings of each other. The individual charles is the only brother of betty. betty : woman ∃ ≤2 has child ∃ ≤1 has sibling (betty, doris) : has child (betty, eve) : has child (betty, charles) : has sibling charles : brother ∃ ≤1 has sibling (charles, betty) : has sibling doris : ∃ ≤1 has sibling eve : ∃ ≤1 has sibling (doris, eve) : has sister (eve, doris) : has sister Figure 1 also shows the inferred direct types of the individuals in ABox smith family. alice has as direct types {mother with siblings, grandma}, betty has {mother having only sisters, sister}, charles has {uncle}, and doris and eve have {sister}.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>every occurrence of b i in A by b jWe call the rules R and R∃ ≤n nondeterministic rules since they can be applied in different ways to the same ABox. The remaining rules are called deterministic rules. Moreover, we call the rules R∃C and R∃ ≥n generating rules since they are the only rules that introduce new individuals in an ABox.The increase of expressiveness in ALCN H R + gained by supporting ABox reasoning is reflected in tableaux rules that are more complex than in comparable approaches for concept consistency. The universal concept restriction rule takes care of GCIs and usually causes additional complexity by adding disjunctions to an ABox. The generating rules have a more complex premise since they may test only for a blocking situation if they are applied to new individuals, i.e. a blocking situation can never occur for old individuals. The necessity of this additional precondition is illustrated by the following example. We define a concept D where R is a transitive superrole of S.Then, we define an ABox A which is obviously unsatisfiable due to a clash for the individual k with C ¬C. However, if blocking were allowed for old individuals, the role exists restriction rule would not create a Ssuccessor with qualification C for the individual j. As a consequence, the number restriction merge rule would never merge this successor with the individual k which results in the unsatisfiability of A.</figDesc><table /><note><p><p>D . = C ∃ S . C ∃ ≤1 S ∀ R . ∃ S . C A := {(i, j) : S, (j, k) : S, i : D, j : D, k : ¬C} Proposition 14 (Invariance) Let A and A be ABoxes. Then:</p>1. If A is derived from A by applying a deterministic rule, then A is satisfiable iff A is satisfiable. 2. If A is derived from A by applying a nondeterministic rule, then A is satisfiable if A is satisfiable. Conversely, if A is satisfiable and a nondeterministic rule is applicable to A, then it can be applied in such a way that it yields a satisfiable ABox A . Proof. 1. "⇐" Due to the structure of the deterministic rules one can immediately verify that A is a subset of A . Therefore, A is satisfiable if A is satisfiable.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>The number of different assertions of the form (a, b) : R or a . = b is bound by (2 2n ) 2 , i.e. O(2 4n ). In conclusion, we have a size of O(2 4n ) for A . Let A T be an ABox w.r.t. a TBox T . Checking whether A T is satisfiable is a decidable problem.</figDesc><table><row><cell>Theorem 26 (Decidability)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>∀ x . x : C should be read as ∀ x . (x : C).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Without loss of generality we only need to consider the case that m = n + 1.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This follows from point 1 and the completion strategy.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We have to increase nA by 1 if does not occur in A.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are grateful to Carsten Lutz, Stephan Tobies, and Michael Wessel for detailed and thoughtful comments on an earlier version of this paper. Recently, in a parallel development, a calculus for deciding the ABox consistency problem for the description logic ALCQHI R + has been proposed in a revised version of <ref type="bibr" target="#b9">[10]</ref>.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Decidable reasoning in terminological knowledge representation systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Buchheit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Donini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schaerf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="109" to="138" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">TBox and ABox reasoning in expressive description logics</title>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fifth International Conference on Principles of Knowledge Representation</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Aiello</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Doyle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Shapiro</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, Mass.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-05-08">Nov. 5-8, 1996. November 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Applying an ALC ABox consistency tester to modal logic SAT problems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, International Conference on Automatic Reasoning with Analytic Tableaux and Related Methods, TABLEAUX&apos;99</title>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Neil</forename><forename type="middle">V</forename><surname>Murray</surname></persName>
		</editor>
		<meeting>International Conference on Automatic Reasoning with Analytic Tableaux and Related Methods, TABLEAUX&apos;99<address><addrLine>Saratoga Springs, NY, USA; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1999-06">June 1999</date>
			<biblScope unit="page" from="24" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">An empirical evaluation of optimization strategies for ABox reasoning in expressive description logics</title>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
		<editor>Lambrix et al.</editor>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="115" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Optimization techniques for reasoning with expressive ABox and concept expressions</title>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
		<idno>FBI-HH-M-290/00</idno>
		<ptr target="http://kogs-www.informatik.uni-hamburg.de/˜haarslev/publications/report-FBI-290-2000.ps.gz" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
		<respStmt>
			<orgName>University of Hamburg, Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">RACE user&apos;s guide and reference manual version 1.1</title>
		<author>
			<persName><forename type="first">V</forename><surname>Haarslev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Möller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-Y</forename><surname>Turhan</surname></persName>
		</author>
		<idno>FBI-HH-M- 289/99</idno>
		<ptr target="http://kogs-www.informatik.uni-hamburg.de/˜haarslev/publications/report-FBI-289-99.ps.gz" />
		<imprint>
			<date type="published" when="1999-10">October 1999</date>
		</imprint>
		<respStmt>
			<orgName>University of Hamburg, Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Algorithmic Foundations of Terminological Knowledge Representation Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hollunder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Saarbrücken, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Using an expressive description logic: FaCT or fiction?</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Sixth International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;98)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Cohn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Schubert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Shapiro</surname></persName>
		</editor>
		<meeting>Sixth International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;98)<address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-06-05">June 2-5, 1998. June 1998</date>
			<biblScope unit="page" from="636" to="647" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A description logic with transitive and inverse roles and role hierarchies</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="410" />
			<date type="published" when="1999-06">June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A description logic with transitive and converse roles, role hierarchies and qualifying number restrictions</title>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tobies</surname></persName>
		</author>
		<idno>LTCS-99-08</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>RWTH Aachen</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Practical reasoning for expressive description logics</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulrike</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Tobies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Logic for Programming and Automated Reasoning (LPAR&apos;99), number 1705 in Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Harald</forename><surname>Ganzinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Mcallester</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andrei</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting>the 6th International Conference on Logic for Programming and Automated Reasoning (LPAR&apos;99), number 1705 in Lecture Notes in Artificial Intelligence</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="161" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Lambrix</surname></persName>
		</author>
		<title level="m">Proceedings of the International Workshop on Description Logics (DL&apos;99)</title>
		<meeting>the International Workshop on Description Logics (DL&apos;99)<address><addrLine>Linköping, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999-06">July 30 -August 1, 1999. June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<title level="m">Elements of the Theory of Computation</title>
		<meeting><address><addrLine>New Jersey</addrLine></address></meeting>
		<imprint>
			<publisher>Englewood Cliffs</publisher>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A concept language extended with different kinds of transitive roles</title>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">20. Deutsche Jahrestagung für Künstliche Intelligenz, number 1137 in Lecture Notes in Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Görz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Hölldobler</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="333" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Attributive concept descriptions with complements</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt-Schauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">ABox reasoning with transitive roles and axioms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tessaris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gough</surname></persName>
		</author>
		<editor>Lambrix et al.</editor>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="101" to="104" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
