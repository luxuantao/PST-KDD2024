<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Keyword Searching and Browsing in Databases using BANKS</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gaurav</forename><surname>Bhalotia</surname></persName>
							<email>bhalotia@cs.berkeley.edu</email>
						</author>
						<author>
							<persName><forename type="first">Arvind</forename><surname>Hulgeri</surname></persName>
						</author>
						<author>
							<persName><forename type="first">¡</forename><surname>Charuta</surname></persName>
							<email>charuta@pspl.co.in</email>
						</author>
						<author>
							<persName><forename type="first">Nakhe</forename><forename type="middle">¢</forename><surname>Soumen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Chakrabarti</forename><forename type="middle">S</forename><surname>Sudarshan</surname></persName>
							<email>sudarsha¥@cse.iitb.ac.in</email>
						</author>
						<author>
							<persName><forename type="first">Byron</forename><forename type="middle">Dom</forename><surname>Byrond</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sunita</forename><surname>Sarawagi</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sunitas</forename><surname>Soumen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Chakrabarti</forename><surname>Soumenc</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Soumenc</forename><surname>Chakrabartisd98</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sunitas</forename><surname>Chakrabartisd98</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Byrond</forename><surname>Chakrabartisd98</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engg. Dept</orgName>
								<address>
									<settlement>I.I.T. Bombay</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Paper Tuple Author Tuple Author Tuple Author Tuple PaperId PaperName Writes Tuple Writes Tuple Writes Tuple</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Keyword Searching and Browsing in Databases using BANKS</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7275DB4ACADE8291193FF26FAB743A26</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Mining Surprising Patterns Using Temporal Description Length Cites Citing</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>With the growth of the Web, there has been a rapid increase in the number of users who need to access online databases without having a detailed knowledge of the schema or of query languages; even relatively simple query languages designed for non-experts are too complicated for them. We describe BANKS, a system which enables keyword-based search on relational databases, together with data and schema browsing. BANKS enables users to extract information in a simple manner without any knowledge of the schema or any need for writing complex queries. A user can get information by typing a few keywords, following hyperlinks, and interacting with controls on the displayed results.</p><p>BANKS models tuples as nodes in a graph, connected by links induced by foreign key and other relationships. Answers to a query are modeled as rooted trees connecting tuples that match individual keywords in the query. Answers are ranked using a notion of proximity coupled with a notion of prestige of nodes based on inlinks, similar to techniques developed for Web search. We present an efficient heuristic algorithm for finding and ranking query results.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Relational databases are commonly searched using structured query languages. The user needs to know the data schema to be able to ask suitable queries. Search engines on the Web have popularized an alternative unstructured querying and browsing paradigm that is simple and user-friendly. Users type in keywords and follow hyperlinks to navigate from one document to the other. No knowledge of schema is needed. ¦ Current affiliation: University of California, Berkeley § With the growth of the World Wide Web, there has been a rapid increase in the number of users who need to access online databases without having a detailed knowledge of schema or query languages; even relatively simple query languages designed for non-experts are too complicated for such users. Query languages for semi-structured/XML data are even more complex, increasing the impedance mismatch further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Supported by an Infosys Fellowship</head><p>Unfortunately, keyword search techniques used for locating information from collections of (Web) documents cannot be used on data stored in databases. In relational databases, information needed to answer a keyword query is often split across the tables/tuples, due to normalization. As an example consider a bibliographic database shown in Figure <ref type="figure" target="#fig_1">1</ref>. This database contains paper titles, their authors and citations extracted from the DBLP repository. The schema is shown in Figure <ref type="figure" target="#fig_1">1(A)</ref>. Figure <ref type="figure" target="#fig_1">1</ref>(B) shows a fragment of the DBLP database. It depicts partial information-paper title and authors-about a particular paper. As we can see, the information is distributed across seven tuples related through foreign key references. A user looking for this paper may use queries like "sunita temporal" or "soumen sunita". In keyword based search, we need to identify tuples containing the keywords and ascertain their proximity through links.</p><p>Answers to keyword queries on the Web are often only the starting point for further browsing to locate required information. Similar browsing facilities are needed in the context of searching for information from databases.</p><p>In this paper, we describe techniques for keyword searching and browsing on databases that we have developed as part of the BANKS system (BANKS is an acronym for Browsing ANd Keyword Searching). The BANKS system enables data and schema browsing together with keyword-based search for relational databases. BANKS enables a user to get information by typing a few keywords, following hyperlinks, and interacting with controls on the displayed results; absolutely no query language or program- The contributions of this paper are as follows:</p><p>1. We outline a framework for keyword querying of relational databases. Our framework makes joins implicit and transparent, and incorporates notions of proximity and prestige when ranking answers.</p><p>There has been a fair amount of earlier work on keyword querying of databases, including <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref>.</p><p>We describe the connections of the BANKS model to related work on keyword search in Section 6.</p><p>2. We present novel, efficient heuristic algorithms for executing keyword queries.</p><p>3. We describe key features of the BANKS system.</p><p>Keyword searching in BANKS is done using proximity based ranking, based on foreign key links and other types of links. We model the database as a graph, with the tuples as nodes and cross references between them as edges. BANKS allows query keywords to match data (tokens appearing in any textual attribute), and meta data (e.g., column or relation name).</p><p>The greatest value of BANKS lies in near zero-effort Web publishing of relational data which would otherwise remain invisible to the Web <ref type="bibr" target="#b1">[2]</ref>. BANKS may be used to publish organizational data, bibliographic data, and electronic catalogs. Search facilities for such applications can be hand crafted: many Web sites provide forms to carry out limited types of queries on their backend databases. For example, a university Web site may provide form interface to search for faculty and students. Searching for departments would require yet another form, as would searching for courses offered. Creating an interface for each such task is laborious, and is also confusing to users since they must first expend effort finding which form to use.</p><p>An approach taken in some cases is to export data from the database to Web pages, and then provide text search on Web documents. This approach results in duplication of data, with resultant problems of keeping the versions up-todate, in addition to space and time overheads. Further, with highly connected data, it is not feasible to export every possible combination. For instance, a bibliographic database can export details of each paper as a Web document, but a query that requires finding a citation link between two papers would not be supported.</p><p>BANKS provides a rich interface to browse data, and automatically generates hyperlinks, corresponding to foreign keys and other links, on displayed results. BANKS helps create hierarchical and graphical views of data with hyperlink facilities built in. The BANKS system is developed in Java using servlets and JDBC, and can be run on any schema without any programming. BANKS is accessible over the Web at the URL: http://www.cse.iitb.ac.in/banks/ The rest of the paper is organized as follows: Section 2 outlines our graph model for representing connectivity information, as well as our model for answer relevance. Section 3 outlines an algorithm for incrementally finding the best answers to keyword queries. We present an overview of the browsing features of BANKS in Section 4. Section 5 outlines a preliminary evaluation of our system. We discuss related work in Section 6. Section 7 outlines directions for future work and Section 8 concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Database and Query Model</head><p>In this section we describe how a relational database is modeled as a graph in the BANKS system. First we evaluate various options available and describe our model informally, and then formalize it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Informal Model Description</head><p>We model the database as a directed graph and each tuple in the database as a node in the graph. Each foreign-keyprimary-key link is modeled as a directed edge between the corresponding tuples. This can be easily extended to other type of connections; for example, we can extend the model to include edges corresponding to inclusion dependencies, where the values in the referencing column of the referencing table are contained in the referred column of the referred table but the referred column need not be a key of the referred table.</p><p>Intuitively, an answer to a query should be a subgraph connecting nodes matching the keywords. Just by looking at a subgraph it is not apparent as to what information it conveys. We wish to identify a node in the graph as a central node that connects all the keyword nodes, and strongly reflects the relationship amongst them. We therefore consider an answer to be a rooted directed tree containing a directed path from the root to each keyword node. (The motivation for directionality is outlined later in this section.) We call the root node an information node and the tree a connection tree. Conceptually this model is similar to the one described in <ref type="bibr" target="#b12">[13]</ref> although there are several differences which are detailed in Section 6.</p><p>In general, the importance of a link depends upon the type of the link i.e. what relations it connects and on its semantics; for example, in the bibliographic database, the link between the Paper table and the Writes table is seen as a stronger link than the link between the Paper table and the Cites table. The link between Paper and Cites tables would have a higher weight. The weight of a tree is proportional to the total of its edge weights, and the relevance of a tree is inversely related to its weight.</p><p>The example in Figure <ref type="figure" target="#fig_1">1</ref> illustrates that some links point towards the root of the tree, instead of away from the root as required by our model. For instance, the Writes relation has foreign keys to the Paper and Author relations, whereas we require paths from Paper to Author, traversing a foreign key edge in the opposite direction. However, we cannot simply regard the edges as undirected.</p><p>Ignoring directionality would cause problems because of "hubs" which are connected to a large numbers of nodes. For example, in a university database a department with a large number of faculty and students would act as a hub. As a result, many nodes would be within a short distance of many other nodes, reducing the effectiveness of proximitybased scoring.</p><p>To solve the problem, we create for each link/edge ¢¡ ¤£ ¦¥ ¨ § a backward edge ¢¥ ©£ ¦¡ § with a different edge weight; we model the weight of ¥ £ ¡ § as directly proportional to number of links to ¥ from the nodes of the same type as ¡ . (Equations for computing the weights are presented in Section 2.2.) In the example from Figure <ref type="figure" target="#fig_1">1</ref>, the backward edges ensure that there is a directed tree rooted at the paper, with a path to each leaf. To illustrate the effect of backward edge weights, let us return to the university department example. A forward edge from a student to her department and a back edge from the department to another student would form a path between each pair of students in the department. If there are more students in a department, the back edges would be assigned a higher weight, resulting in lower proximity (due to the department) for each pair of students, than if there are fewer students registered. In contrast, in the bibliographic database, papers (typically) have smaller numbers of authors, and the backward edge weights from Paper to Writes nodes would be less resulting in higher proximity between co-authors.</p><p>We may restrict the information node to be from a selected set of nodes of the graph; for example, we may exclude the nodes corresponding to the tuples from a specified set of relations, such as Writes, which we believe are not meaningful root nodes (this is similar to the scheme in <ref type="bibr" target="#b12">[13]</ref>). In the example from Figure <ref type="figure" target="#fig_1">1</ref>(B), let the keyword nodes be SunitaS, SoumenC and ByronD. These nodes, which are author nodes, have a relationship induced due to paper node ChakrabartiSD98. The tree shown in Figure <ref type="figure" target="#fig_1">1</ref>(B) (with backward edges from the Paper node to the Writes nodes) would be a connection tree for the keyword nodes, with the paper node as the information node.</p><p>We incorporate another interesting feature, namely node weights, inspired by prestige rankings such as PageRank in Google <ref type="bibr" target="#b3">[4]</ref>. With this feature, nodes that have multiple pointers to them get a higher prestige. In our current implementation we set the node prestige to the indegree of the node. Higher node weight corresponds to higher prestige. E.g., in a bibliography database containing citation information, if the user gives a query Query Optimization our technique would give higher prestige to the papers with more citations. As another example, in a TPCD database storing information about parts, suppliers, customers and orders, the orders information contains references to parts, suppliers and customers. As a result, if a query matches two parts (or suppliers, or customers) the one with more orders would get a higher prestige.</p><p>Node weights and tree weights need to be combined to get an overall relevance score as discussed in Section 2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Formal Database Model</head><p>Based on the discussion thus far, our model comprises nodes with node weight and edges with forward and backward edge weights, and a similarity measure between relations.</p><p>Nodes/vertices: For each tuple in the database, the graph has a corresponding node ¡ ¢¡ . We will speak inter- changeably of a tuple and the corresponding node in the graph.</p><p>Node weights: Each node ¡ in the graph is assigned a weight £ ¢¡ § which depends upon the prestige of the node.</p><p>In our current implementation we set the node prestige to a function of the indegree of the node. Extensions to handle transfer of prestige (as is done, e.g., in Google's PageRank <ref type="bibr" target="#b3">[4]</ref>) can be easily added to the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Edges:</head><p>For each pair of tuples ¥¤ and §¦ such that there is a foreign key from ¥¤ to §¦ , the graph contains an edge from ¡ ¡ ©¨to ¡ ¡ and a back edge from ¡ ¡ to ¡ ¡ ¨(this can be extended to handle other types of connections).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Similarity between relations:</head><p>Let ¤ £ ¦ § be the (gen- erally asymmetric) similarity from relation ¤ to relation ¦ where ¤ is the referencing relation and !¦ is the refer- enced relation. The similarity ¤ £ ¦ § depends upon the type of the link from relation ¤ to relation ¦ . ¤ £ " ¦ § is set to infinity if relation ¤ doesn't refer to relation ¦ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Edge weights:</head><p>In our model, the weight of a forward link along a foreign key relationship reflects the strength of the proximity relationship between two tuples and is set to 1 by default. It can be set to any desired value to reflect the importance of the link (small values correspond to greater proximity).</p><p>Consider two nodes ¡ and ¥ in the database. Let ¢¡ § and ¢¥ ¨ § be the respective relations that they belong to.</p><p>The weight of the directed edge ¡ £ ¥ § depends on two conditions: whether the database has a link from ¡ to ¥ , and whether it has a link from ¥ to ¡ . Neither, one or both links may exist.</p><p>If ¢¡ ¤£ ¦¥ ¨ § exists but ¢¥ ©£ ¦¡ § does not, we can simply as-</p><formula xml:id="formula_0">sign the weight # ¢¡ § £ ¥ § § to ¢¡ ¤£ ¦¥ ¨ § . If ¡ £ ¥ § does not</formula><p>exist and ¢¥ ©£ ¦¡ § does, according to our earlier arguments, we ought to assign weight $ %£ '&amp; ¢¡ § ( ¢¥ ¨ § £ " ¢¡ § ¦ § to ¢¡ ¤£ ¦¥ ¨ § , where $ )£ &amp; ¢¡ § is the indegree of ¡ contributed by the tuples belonging to relation ¢¥ ¨ § .</p><p>If both ¢¡ ¤£ ¦¥ ¨ § and ¥ £ ¡ § exist in the graph, we assign the weight 0 ¢¡ ¤£ ¦¥ ¨ § as the minimum of the two values, i.e.,</p><formula xml:id="formula_1">1 32 54 76 ¡ § £ ¢¥ ¨ § ¦ § £ $ )£ &amp; ¢¡ § ( ¥ § £ ¢¡ § ¦ § 98 %@ (1)</formula><p>Other choices are possible. For instance, if one were to view the two weights as resistances in an electrical network, one may use the equivalent parallel resistance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Query and Answer Model</head><p>Generally, a query consists of A B C search terms D ¤ £ D ¦ £ E@ @ E@ £ D GF . The first step is to locate nodes matching search terms. A node is relevant to a search term if it contains the search term as part of an attribute value or metadata (such as column, table or view names). E.g., all tuples belonging to a relation named AUTHOR would be regarded as relevant to the keyword 'author'. For each search term D "H in the query we find the set of nodes I H that are relevant to D PH .</p><p>Let I RQ SI ¤ £ TI ¦ £ TI 7U £ @ E@ @ £ "I F § . Extensions of the model to incorporate queries such as "author:Levy" which would require the keyword "Levy" to be in an author name attribute, can be easily incorporated. Approximate matching of keywords to words present in tuples can also be supported, by extending the model to incorporate node relevances. These features are not currently implemented in our prototype, and we omit further details.</p><p>An answer to a query is a rooted directed tree containing at least one node from each I H . Note that the tree may also contain nodes not in any I H and is therefore a Steiner tree. The relevance score of an answer tree is computed from the relevance scores of its nodes and its edge weights.</p><p>(The condition that one node from each I H must be present can be relaxed to allow answers containing only some of the given keywords.) Figure <ref type="figure">2</ref> shows a sample result of a query containing the keywords soumen and sunita executed on the bibliographic database. Each result is a tree containing node tuples (including intermediate nodes) along with the resp. table names and column names. Indentation is used to depict the tree structure, and nodes containing keywords are distinguished from intermediate nodes by the color of the nodes.</p><p>Each answer tree has to be assigned a relevance score, and answers have to be presented in decreasing order of that score. Scoring involves a combination of relevance clues from nodes and edges. Node weights and edge weights provide two separate measures of relevance. We desire a final relevance score in the range [0,1]. We also wish to control the variation in individual weights so that a few nodes or edges with very large weights do not skew the results excessively. We therefore take the following approach.</p><p>V We scale individual node weights to £ XW `Y a , the max- imum node weight in the graph. We can additionally depress the scale using logarithms (as with 'IDF' weighting in Information Retrieval); accordingly, the normalized score £ b c ed ©f hg ¢¥ ¨ § of a node ¥ is defined as £ ¢¥ ¨ § i e£ W `Y a or p 5q sr GC ut v£ ¢¥ ¨ § i 9£ W `Y a § respectively. These are both scale-free quantities in w x £ EC ey (if log is to base 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. Result of query "soumen sunita"</head><p>To get the overall node score £ b c ed ©f hg , we take the av- erage of the node scores. To favor meaningful root nodes, and to reduce the effect of intermediate nodes, we consider only leaf nodes (containing the keywords) and the root node when computing the average. A node containing multiple search terms is counted as many times as the number of search terms it contains, to avoid giving extra weight to trees with separate nodes for each keyword.</p><p>V We get the normalized edge score c ed ©f hg g § of an edge by dividing the edge weight by 0 uW ¢¡ £ , the mini- mum edge weight in the graph, to make it scale-free, and may additionally depress the scale by defining the edge score of g as p 5q sr GC t 0 #g § "i ©0 ¥¤ H F § .</p><p>The overall edge score is then defined to be c ed ©f hg Q C ©i GC t §¦ © c ed ©f hg g § § , since we wish to give lower relevance to large trees. This quantity is also in the range w x £ C ey . There are a total of eight combinations, since we have three options (for edge score, node score and combination) each of which can take two values. In our evaluation we discarded three combinations: those that involve log scaling and multiplication as these scores tended to become quite small, and compared the remaining combinations.</p><p>While inspired by standard IR weighting and smoothing practice, the choices and parameters above are somewhat ad-hoc, but this appears to be inescapable in all related systems that we have reviewed <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b16">17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Searching for the Best Answers</head><p>The computation of minimum Steiner trees is already a hard (NP complete) problem, and is made complicated by node weight considerations, required to compute the overall relevance of a tree. We are interested in not just the most relevant tree, but also in other trees with high relevance scores, since they may be part of what the user is searching for. We also wish to generate answers incrementally to avoid generating answers of low relevance that the user may never look at.</p><p>In this section, we present an outline of the backward expanding search algorithm which offers a heuristic solution for incrementally computing query results. Complete details can be found in the full version of the paper <ref type="bibr" target="#b2">[3]</ref>.</p><p>We assume that the graph fits in memory. This is not unreasonable, even for moderately large databases, because the in-memory node representation need not store any attribute of the corresponding tuple other than the RID. The only other in-memory structure is an index to map RIDs to the graph nodes. Indices to map keywords to RIDs can be disk resident. As a result the graphs of even large databases with millions of nodes and edges can fit in modest amounts of memory.</p><p>Given a set of keywords, first we find, for each keyword term D H , the set of nodes, I H , that are relevant to the keyword by using disk resident indices on keywords.</p><p>Let ! Q #" `I H . The backward expanding search al- gorithm concurrently runs $ ! %$ copies of Dijkstra's single source shortest path algorithm, one for each keyword node A in ! , with A as the source. The copies of the algorithm Global: #Keywords = n; Keywords: ¢¡ ¤£ ¢¥ ¦¡ ¨ § ©¥ ¤ ¢ ¢ ¢¥ ¦¡ , Keyword node sets:  Each copy of the single source shortest path algorithm traverses the graph edges in reverse direction. The idea is to find a common vertex from which a forward path exists to at least one node in each set I H . Such paths will define a rooted directed tree with the common vertex as the root and the corresponding keyword nodes as the leaves. The tree thus formed is a connection tree and root of the tree is the information node.</p><formula xml:id="formula_2">£ ¥ ¨ § ¥ ¢ ¤ ¢ ¢¥ ! " , # %$ '&amp; ( !) IteratorHeap = 0 ; OutputHeap = 0 For each keyword</formula><p>In the example from Figure <ref type="figure" target="#fig_1">1</ref>(B), let the keyword nodes be SunitaS, SoumenC and ByronD. The algorithm will have three shortest path iterators one starting from each keyword node. All the iterators will visit paper node Chakrabar-tiSD98. Thus, the algorithm generates a connection tree rooted at the paper node (the information node in the tree) with the keyword nodes as the leaf nodes. The tree shown in Figure <ref type="figure" target="#fig_1">1</ref>(B) is the connection tree with all edges directed away from the paper node. (Note that each edge in the figure has a corresponding opposite edge in the graph but is not shown.) Note, that the algorithm may generate more re-sults as it may detect other information nodes, e.g., if the authors have coauthored more than one paper.</p><p>Figure <ref type="figure" target="#fig_3">3</ref> shows (high-level) pseudocode for the backward expanding search algorithm. In each iteration, the algorithm picks an iterator whose next vertex to be output is at the least distance from the source vertex of the iterator. (The distance measure can be extended to include node weights of nodes matching keywords.)</p><p>To find information nodes and the corresponding connection trees incrementally, within each vertex <ref type="bibr">(</ref> to a connection tree rooted at node ¥ . Trees whose root has only one child are discarded, since the tree formed by removing the root node would also have been generated, and would be a better answer. <ref type="foot" target="#foot_0">1</ref> After generating all connection trees, we insert node ¡ in list ¥ @ R H .</p><p>The connection trees generated by the algorithm are only approximately sorted in the increasing order of their weights. (The weight of a tree is the sum of the weights of the edges.) The relevance of a tree is computed using the tree weight and the node weights as discussed in Section 2.3. Currently, node weights are not considered while generating the connection trees. As a result, trees may not be generated in exact decreasing relevance order.</p><p>We could generate all connection trees and then sort them in decreasing relevance order, but this would increase computation costs and leads to a greatly increased time to generate initial results. To avoid these overheads, as a heuristic, we maintain a small fixed-size heap of generated connection trees. The heap is ordered on the relevance of the trees. We keep adding trees to the heap as they are generated, without outputing them. When the heap is full, and we want to add a new tree, we output the tree of highest relevance and replace it in the heap. When all answers have been generated, the remaining trees in the heap are output in decreasing order of relevance. While this heuristic does not guarantee that the trees are generated in decreasing order, we have found it works well even with a reasonably small heap size.</p><p>The algorithm may generate trees that are isomorphic modulo direction; that is, their undrected versions are same. We call such trees as duplicate trees. They represent the same result, except with different information nodes. We retain only the one with the highest relevance and discard the rest. We mainatin a list of all the results generated so far to allow duplicate detection. When a new result is generated, if a duplicate is in the heap, and its relevance is smaller than the that of the new result, we remove the duplicate from the heap and insert the new result into the heap. This can happen since results are not necessarily generated in decreasing order of relevance. In fact, a duplicate of the result might have already been output; in that case we discard the new result even if its relevance is higher that a duplicate that was output earlier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Browsing</head><p>The BANKS system provides a rich interface to browse data stored in a relational database. The browsing system automatically generates browsable views of database relations and query results; no content programming or user intervention is required. Every displayed foreign key attribute value becomes a hyperlink to the referenced tuple. In addition, primary key columns can be browsed backwards, to find referencing tuples, organized by referencing relations (a specific referencing relation can be selected by the user).</p><p>Each table displayed comes with a variety of tools for interacting with data.</p><p>V Columns can be projected away (dropped) V Selections can be imposed on any column V For foreign key columns, clicking on "join" results in the referenced table being joined in, and its columns also displayed. This eliminates the need for explicitly writing join queries for the normal case of foreign key join. The join feature can also be used in the other direction, from a primary key to a referencing foreign key.</p><p>V Results can be grouped-by on a column; this results in only the distinct values for that column being displayed. The user can click on any of the values to see the tuples associated with that value.</p><p>V Tuples in the displayed table can be sorted by a speci- fied column Controls for these operations can be accessed by clicking on the column names in the table header. In addition, displayed data is paginated, and schema browsing is supported.</p><p>Figure <ref type="figure" target="#fig_4">4</ref> shows the result of browsing the thesis database starting with the student relation, using a pop-up menu on the roll number attribute to effect a join with the thesis relation and dropping columns. The join is made possible Underlined attribute values are hyperlinks.</p><p>BANKS templates provide several predefined ways of displaying any data. Template instances are customized, stored in the database, and given a hyperlink name, which is used to access the template. The BANKS system currently provides four types of templates:</p><p>V Cross-tabs (similar to OLAP cross-tabs).</p><p>V The group by template provides for hierarchical view of data, by specifying a sequence of grouping attributes. For example, grouping a student relation by department and program attributes initially displays all departments; clicking on a department shows all programs in the department, and clicking on a program then shows all students in that program in the selected department.</p><p>V Folder views are similar to grouping, but are modeled after the folder view of files and directories supported in many environments such as Windows Explorer.</p><p>V The graphical interface template permits information to be displayed in bar chart, line chart or pie chart format. Hyperlinks are provided on the graphical data via HTML image maps; clicking on a bar of a bar chart, or a slice of a pie chart shows tuples with the associated value.</p><p>Another interesting feature of templates is that they can be composed together in a hyperlinked, visual manner. The action associated with a hyperlink may be scripted to take the user to another template, instead of showing the detailed tuples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experience and Performance</head><p>We have implemented BANKS using servlets, with JDBC connections to an IBM Universal Database. We have experimented with two datasets. The first dataset contained a part of the DBLP information, represented in structured relational format. There are about 100000 nodes and 300000 edges in the resultant BANKS graph. The other dataset had information about Masters and Phd dissertations in IIT Bombay, and its graph had thousands of nodes and tens of thousands of edges.</p><p>There are no agreed-upon benchmarks for evaluating ranking algorithms in this domain. To work around this, we selected data sets that we as academics and database researchers can relate to, and picked queries that illustrated different ways of querying this information (e.g. keywords from two authors who are coauthors, authors who have a common coauthor, an author and a title, keywords from titles alone, and so on). Across all the queries (with proper parameter settings, discussed later) we found the system returning the most intuitive answers ahead of less intuitive ones in almost all cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Anecdotes</head><p>We give a few examples of queries and the answers returned by BANKS. For the query "Mohan" on the DBLP database, C. Mohan came out at the top of the ranking, with Mohan Ahuja and Mohan Kamat following. This was due to the prestige conferred by the writes relation which had many tuples for these authors. The query "transaction" returned Jim Gray's classic paper and the book by Gray and Reuter as the top two answers.</p><p>As another example, on the thesis database, the query "computer engineering" returned the Computer Science and Engineering department with a higher relevance than a number of thesis that had these two words in their title, since the larger number of references to the department gave it a higher node weight. The query "sudarshan aditya" returned a thesis written by Aditya whose advisor is Sudarshan.</p><p>On the DBLP database, the query "soumen sunita" returned the answer shown in Figure <ref type="figure">2</ref>. The query "seltzer sunita" returned Stonebraker as the root, with connections to Sunita and Seltzer through papers co-authored by Stonebraker with each of them separately. Without log scaling on edges, this answer got a lower rank than other less meaningful answers with large trees, since the backward edge from Stonebraker to the Writes tuples has a very high weight due to the large number of papers written by Stonebraker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Space and Time</head><p>For a bibliographic database with 100K nodes and 300K edges, memory utilization was around 120 MB. Java implementations are notorious for wasting space. The graph cur- rently takes about 2 minutes to load initially, with almost all the time spent in Java structure creation. We expect much smaller memory utilization and loading/running time with a properly tuned Java/C implementation.</p><p>Once the database graph is loaded, queries take about a second to a few seconds for most queries on the bibliographic database. Overall, even with a prototype which has not been tuned carefully, it is feasible to use BANKS for moderately large databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Effect of Parameters</head><p>Our performance evaluation was conducted using 7 different queries whose form was outlined earlier. For each query we chose answers that we felt were the most meaningful, and we call these the ideal answers; there were an average of 4 such answers per query. We ran our algorithm on each query, with different combinations of the parameters (edge and node scoring functions and score combination), stopping at 10 answers. For each query, for each parameter setting, we computed the absolute value of the rank difference of the ideal answers with their rank in the answers for that parameter setting. The sum of these rank differences gives the raw error score for that parameter setting. We scaled the scores to set the worst possible error score to 100. We considered answers to be the same if their trees were the same, even if the roots were different. For answers that were missing at a parameter setting, the rank difference was assumed to be 11 (one more than the number of answers examined).</p><p>Figure <ref type="figure" target="#fig_5">5</ref> shows error scores against and log-scaling of edge weights (EdgeLog=1 represents log-scaling). The following conclusions can be drawn from our performance study.</p><p>V It was important to keep the effect of node ranking rel- atively small, but non-zero. Setting to 0.2 with log scaling of edge weights did best, with an error score of x @ x , while setting to 0.5 with log scaling of edge weights did almost as well with error scores of around 3. Setting to 1 (ignore edge weights) did the worst, with error scores of around 15, followed by Q 0.8 and Q 0 (ignore node weights) with scores of be- tween 8 and 12, with and without log scaling of edge weights respectively. Note that the absolute values of the error scores are relatively small, even when we ignore edge weights. This is because results are generated in increasing order of edge weight and then sorted by relevance score using a limited buffer, and our heuristic of discarding trees where the root node has only one child eliminates larger trees even if their root nodes have high node weight.</p><p>V Reducing the edge weight range by log-scaling was important, otherwise back edges from some popular nodes had a high weight and resulted in some intuitively correct answers getting a very poor relevance rank. With good settings for other parameters, using log scores reduced the error score by around 5.</p><p>V The "mode" of score combination (addi- tive/multiplicative) has almost no impact on the ranking (and as a result on error scores), although the absolute values of the relevance scores were different.</p><p>V For node weights, log scaling gave the same ranking as no log scaling on our examples, although we can construct scenarios where log scaling does better.</p><p>In conclusion, the rankings are relatively stable across different choices of parameter values, but Q 0.2 coupled with log scaling of edge weights does best.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>BANKS is closely related to the DataSpot system <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref>. (Dataspot is now part of the Mercado software system.) In particular, the model of query answers as rooted trees corresponds to the DataSpot model, where the roots are called "fact nodes". DataSpot also computes relevance scores for trees, and returns trees of maximum relevance. However, the details of the underlying graph formalisms differ. BANKS currently assumes a model where only those references corresponding to equivalence edges in DataSpot are explicitly represented. Since edges in our model can have attributes such as type and weight, we can model containment (as in DataSpot and in nested XML) simply as edges of a new type. (We are currently working on adding XML support to BANKS.) The BANKS technique of assigning weights to back edges based on indegree as well as its use of node weights have no counterpart in DataSpot. The use of node weights based on prestige has proved critical in Web search, and our anecdotal evidence shows their importance in the context of database search as well. BANKS also takes the effect of metadata queries into account, which is not made explicit in DataSpot.</p><p>The idea of proximity search in databases represented as graphs was also proposed by Goldman et al. <ref type="bibr" target="#b6">[7]</ref>. They support queries of form find object near object. They restrict results to tuples from one relation near a set of keywords, whereas we permit results to be structured as trees which helps explain how we arrive at an answer. Unlike BANKS, they do not consider node and edge weighting techniques. EasyAsk (www.easyask.com) is another commercial system that provides natural language search (including keyword search) on data stored in relational databases. EasyAsk does a variety of tasks such as approximate word matching and natural language understanding. However, details of how they handle keyword queries are not publicly available.</p><p>Web search provides another natural application where the best response may comprise a graph of connected pages rather than a single page. Like us, Li et al. <ref type="bibr" target="#b8">[9]</ref> couch this problem in terms of Steiner trees. However, in their formulation, the graphs are not directed, and they do not handle queries that exploit meta-data. Proximity is the primary concern in their setting, whereas BANKS combines proximity with link-based prestige. Unlike BANKS, they do not consider structured data sources such as databases.</p><p>Another system for keyword search and browsing of databases is Mragyati, by Sarda and Jain <ref type="bibr" target="#b13">[14]</ref>. Their implementation does not handle paths of length greater than two. Their ranking system can use user-specified criteria, but the default ranking system uses indegree, which is one of many criteria in BANKS.</p><p>Miller et al. <ref type="bibr" target="#b9">[10]</ref> describe a system for querying and browsing of data stored in databases. They concentrate on dynamically generating multiple hierarchical views for users to drill down to find required data. They allow selection predicates but do not consider keyword queries. Object oriented database browsers such as OdeView <ref type="bibr" target="#b0">[1]</ref> and Pesto <ref type="bibr" target="#b4">[5]</ref> provide navigation by clicking on object references, but do not support keyword search. Our system also provides more powerful browsing facilities. BBQ <ref type="bibr" target="#b10">[11]</ref> presents an interface for blended browsing and querying but querying in BBQ requires the user to know the database schema. Shneiderman et al. <ref type="bibr">[15] [16]</ref> have developed systems to display chemical elements, search for homes or movies, and so on, based on the concept of dynamic queries. Their systems focus on graphical user interface and do not consider keyword queries, unlike BANKS.</p><p>Hulgeri et al <ref type="bibr" target="#b7">[8]</ref> provide a more detailed survey of related work in this area; our graph model and query model are presented in that paper, but many details of the model, and details of query evaluation algorithms and browsing are new to this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Ongoing and Future Work</head><p>We are currently extending the BANKS system to handle browsing and keyword searching of XML data. We plan to implement attribute:keyword queries such as author:Levy. We are investigating authority transfer (a form of spreading activation), wherein nodes pointed to by heavy nodes (perhaps via user feedback) become heavier. We are considering implementing some form of approximate matching, such as concurrency approx(1988) to look for papers about concurrency published around 1988.</p><p>We also want to summarize the output, i.e., group the output tuples into sets that have the same tree structure, and allow the user to look for further answers with a particular tree structure.</p><p>We are exploring support for external links, such as HTML HREFs, to aid in browsing. Such support is particularly useful when integrating information from multiple databases. Other planned system features include authorization mechanisms to selectively expose data to different users.</p><p>Query evaluation with keywords matching metadata can be relatively slow, since a large number of tuples may be defined to be relevant to the keyword. This problem also arises with non-metadata keywords that match large number of nodes. We are working on techniques to speed up such queries by not performing backward search from large numbers of nodes, and instead searching forwards from probable information nodes corresponding to more selective keywords.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>We have developed BANKS, an integrated browsing and keyword querying system for relational databases. BANKS allows users with no knowledge of database systems or schema to query and browse relational database with ease. BANKS greatly reduces the effort involved in publishing relational data on the Web and making it searchable. Examples of the types of data that could be published using BANKS include organizational data, bibliographic data and product catalogs.</p><p>We have proposed a framework for answering keyword queries, and implemented an algorithm to find query answers incrementally. We have evaluated our prototype in terms of speed and meaningfulness of answers using academic and bibliographic databases. Our observations are that BANKS is practical to use on moderately large databases, and that the results are intuitive and useful.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>¨Current affiliation: Persistent Systems Pvt. Ltd., Pune, India © Partly supported by an IBM Faculty Partnership Grant</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The DBLP Bibliography Databases</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>V</head><label></label><figDesc>Finally, we can combine the overall edge score and node score, to get an overall relevance score, either by addition or by multiplication; in both cases, a factor controlling their relative weightage. The additive combination uses the formula PC © § c ed ©f hg t ¥£ b c ed ©f hg , while the multiplicative combination uses the formula c ed ©f hg £ c Ed ©f ©g .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Backward Expanding Search are run concurrently by creating an iterator interface to the shortest path algorithm, and creating an instance of the iterator for each keyword node.Each copy of the single source shortest path algorithm traverses the graph edges in reverse direction. The idea is to find a common vertex from which a forward path exists</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Sample browsing session.</figDesc><graphic coords="7,307.68,71.98,236.07,168.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Error scores vs. parameter choices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>node, 1 32 4# Create a single source shorest path iterator with 1 as the source and put it in IteratorHeap ordered on the distance of the first node it will output while IteratorHeap is not empty and more results required Iterator = remove top iterator from IteratorHeap 5 = Get next node from IteratorIf Iterator has more nodes to output Insert Iterator again in IteratorHeap ordered on the distance of the next node it will output if 5 is not visited before by any iterator then for i = 1 to n: Create 5 6 ) and set 5 6 ) $ 70 CrossProduct = origin 8 @9 ) BA C ED5 6 D    where origin is the origin of Iterator and origin 2 3 ) /* CrossProduct is empty if any 5 6 D is empty */ Insert origin in5 6 )  for each tuple 2 CrossProduct</figDesc><table /><note><p>create ResultTree from tuple /* ResultTree is rooted at 5 and contains a path from 5 to each origin node in ¡ F HG I QP */ if root of ResultTree has only one child continue /* duplicate result */ if OutputHeap is full Output and remove top result from OutputHeap Insert ResultTree into OutputHeap ordered by its relevance score</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Generally the smaller tree would have higher relevance, although if the root of the larger tree has a higher node weight it is possible for the larger tree to have higher relevance.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments:</head><p>We wish to thank B. Aditya, Urmila Kelkar, Megha Meshram and Parag for implementing some parts of the BANKS system, and helping with the performance evaluation.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">OdeView: The graphical interface to Ode</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Gehani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMOD</title>
		<meeting>of ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="34" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dark matter on the Web</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Craswell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hawking</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Poster Proceedings, 9th World-Wide Web Conference</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Keyword searching and browsing in databases using BANKS</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-11">November 2001</date>
			<pubPlace>Bombay</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Indian Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The anatomy of a large-scale hypertextual Web search engine</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Page</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks and ISDN Systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1-7</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">PESTO : An integrated query/browser for object databases</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Maganty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on VLDB</title>
		<meeting>of the Int&apos;l Conf. on VLDB</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="203" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">DTL&apos;s DataSpot: Database exploration using plain language</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Entin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Geva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Palmon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on VLDB</title>
		<meeting>of the Int&apos;l Conf. on VLDB</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="645" to="649" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Proximity search in databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shivakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Conf. on VLDB</title>
		<meeting>of the Int&apos;l Conf. on VLDB</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="26" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Keyword search in databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Engineering Bulletin</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="22" to="31" />
			<date type="published" when="2001-09">Sept. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Retrieving and organizing Web pages by &quot;information unit</title>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Candan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th World-wide Web Conference</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="230" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">DataWeb: Customizable database publishing for the web</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">G</forename><surname>Tsatalos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Multi-Media</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="14" to="21" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">BBQ: A visual interface for integrated browsing and querying of XML</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Munroe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visual Database Systems</title>
		<imprint>
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Associative search method for heterogeneous databases with an integration mechanism configured to combine schema-free data models such as a hyperbase. United States Patent Number 5,740,421, Granted April 14</title>
		<author>
			<persName><forename type="first">E</forename><surname>Palmon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
	<note>filed in 1995. Available at www.uspto.gov</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Associative search method with navigation for heterogeneous databases including an integration mechanism configured to combine schema-free data models such as a hyperbase. United States Patent Number 5,819,264, granted October 6</title>
		<author>
			<persName><forename type="first">E</forename><surname>Palmon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Geva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
	<note>filed in 1995. Available at www.uspto.gov</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Mragyati: A system for keywordbased searching in databases</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">L</forename><surname>Sarda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<idno>cs.DB/011052 on CORR</idno>
		<ptr target="http://xxx.lanl.gov/archive/cs" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Dynamic queries for visual information seeking</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="70" to="77" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Dynamic queries, starfield displays, and the path to Spotfire</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<ptr target="http://www.cs.umd.edu/hcil/spotfire/" />
		<imprint>
			<date type="published" when="1999-02">Feb. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">HyPursuit: A hierarchical network search engine that exploits content-link hypertext clustering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Vélez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Sheldon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nemprempre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Szilagyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Duda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Gifford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM Hypertext</title>
		<meeting>of ACM Hypertext</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="180" to="193" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
