<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Kinematic Roadmap: A Motion Planning Based Global Approach for Inverse Kinematics of Redundant Robots</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Juan</forename><forename type="middle">Manuel</forename><surname>Ahuactzin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Kamal</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Departamento de Sistemas Computa-cionales</orgName>
								<orgName type="institution">Universidad de las Am√©ricas-Puebla</orgName>
								<address>
									<settlement>Puebla</settlement>
									<country key="MX">Mexico</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of Engineering Science</orgName>
								<orgName type="institution">Simon Fraser University</orgName>
								<address>
									<postCode>V5A 1S6</postCode>
									<settlement>Burnaby</settlement>
									<region>B.C</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Kinematic Roadmap: A Motion Planning Based Global Approach for Inverse Kinematics of Redundant Robots</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">AE23F83E88E78EE40DD5183395849474</idno>
					<note type="submission">received September 15, 1998; revised April 21, 1999.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Collision-avoidance</term>
					<term>global planning</term>
					<term>inverse kinematics</term>
					<term>kinematic roadmap</term>
					<term>local planning</term>
					<term>motion planning</term>
					<term>path planning</term>
					<term>redundant manipulators</term>
					<term>roadmap approach</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper proposes a novel and global approach to solving the point-to-point inverse kinematics problem for highly redundant manipulators. Given an initial configuration of the robot, the problem is to find a reachable (path-connected) configuration (and a feasible path to it) that corresponds to a desired position and orientation of the end-effector. Our approach is inspired by recent motion planning research and explicitly takes into account constraints due to joint limits, self-collisions, and static obstacles in the environment. Central to our approach is the novel notion of kinematic roadmap for a manipulator. The kinematic roadmap captures the connectivity of the connected component (that contains the initial configuration) of the free configuration space of the manipulator in a finite graph like structure. The point-to-point inverse kinematics problem is then solved using this roadmap. We provide completeness results for our algorithm. Our current implementation, based on Ariadne's Clew Algorithm [5], [32], is composed of two sub-algorithms: EXPLORE, an appealingly simple algorithm that builds the kinematic roadmap by placing landmarks in the free configuration space; and SEARCH, a local planner, that uses this roadmap to reach the desired end-effector configuration. Our implementation of SEARCH is an efficient closed form solution, albeit local, to inverse kinematics that exploits the serial kinematic structure of serial manipulator arms. Initial experiments with a seven-DOF manipulator have been extremely successful.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>closed-form inverse kinematics solutions don't exist in general, and the latter because of the increase in the dimensionality of the configuration space.</p><p>The inverse kinematic problem, indeed a very basic and widely studied problem in robotics, has been formulated in different ways. We summarize them below, making certain distinctions between them explicit, distinctions that are pertinent to our work but have been somewhat implicit (and ignored) in the literature so far. The first one-we call it the existence problem-is to determine a robot configuration corresponding to a given position and orientation (configuration) of the endeffector. Formally, it is stated as solving <ref type="bibr" target="#b0">(1)</ref> where denotes a robot configuration (joint vector) and denotes the desired configuration of the end-effector in workspace and :</p><p>is the forward kinematic function. Note that this formulation does not concern itself with a key question, that is, if the solution (the robot configuration) is reachable<ref type="foot" target="#foot_0">1</ref> from a given initial configuration. Indeed due to joint limits, self-collisions, and of course, obstacles in the environment, there may exist a solution, however it may not be reachable from a given initial configuration. Even if a closed form analytical solution for exists for a particular kinematic geometry (no such general solution for arbitrary geometries is known), one has the answer for the existence question but not for the reachability (path-connectedness) of the solution.</p><p>A variant of the above problem that explicitly addresses the reachability issue is the so-called point-to-point problem. It is stated as:</p><p>Given an initial robot configuration, , and a desired end-effector configuration, , determine a reachable robot configuration and a feasible path to it such that .</p><p>Note that for an existing robot, at least in the sole presence of joint limits and self-collisions, it suffices to solve the point-to-point problem, i.e., get the reachable solutions. The solutions that are not reachable are really not of interest. However, from a robot design perspective it may indeed be useful to solve the existence problem and characterize all solutions.</p><p>Another formulation, also called the tracking problem <ref type="bibr" target="#b40">[41]</ref>, is stated as: Given a workspace trajectory, , of the end-effector, and a start robot configuration , determine an entire (feasible) joint space trajectory such that , .</p><p>Most approaches to solve this problem often implicitly assume that the start robot configuration corresponds to the start end-effector configuration, i.e., . In general, such a condition is not satisfied and one may need to solve the point-to-point problem from a known (say, home) configuration to . Furthermore, the two formulations (point-to-point and tracking) are formally related (analogous to the relationship between pure position regulation and trajectory tracking in control theory). Loosely put, the point-to-point inverse kinematics can be employed for solving the tracking problem (in a local sense), by repeatedly applying the solution to the point-to-point problem, successively to the end-effector configurations along the given end-effector trajectory.</p><p>In this paper, we address the point-to-point inverse kinematic problem for arbitrary geometry of robots, with either revolute or prismatic joints, in the presence of joint limits, selfcollision constraints and static obstacles in the environment. Contrary to most approaches, we make no assumptions that should be close to the solution. could either be specified by the user, or one could use a standard configuration such as the home configuration, specified for all commercially available manipulators.</p><p>Despite extensive literature and work, the inverse kinematics problem for redundant manipulators is not satisfactorily solved. There are two main aspects of solution to any inverse kinematic problem: motion planning, <ref type="foot" target="#foot_1">2</ref> which deals with existence of a feasible path, and redundancy resolution, which deals with selecting a single configuration among a set of many possible ones (this set is the self-motion manifold) <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b27">[28]</ref>. Most research in inverse kinematics algorithms has primarily focused on local algorithms for redundancy resolution <ref type="bibr" target="#b40">[41]</ref>. These approaches address the problem in the velocity domain, i.e., they use the linearized mapping , where is the Jacobian matrix. These algorithms, by their very nature (and design) are intended to be online and able to take into account varying constraints or moving obstacles. However, they do not address the existence issue (they assume that a feasible solution exists), assume that the solution is close to the start configuration, and are limited (see <ref type="bibr" target="#b3">[4]</ref> for limits on abilities of such algorithms). Along another line, "global" (offline) approaches based on calculus of variations seek optimal (say, w.r.t. total kinetic energy along the path) joint space trajectories subject to path-tracking of the end-effector (hence they apply to the tracking problem) <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b41">[42]</ref>. Ultimately these approaches numerically solve some type of boundary value problems <ref type="bibr" target="#b41">[42]</ref>. Note that these are not truly global approaches. They are somewhat "global" in the sense that they optimize the cost function along the entire trajectory, but the space of paths searched is very local. As mentioned in <ref type="bibr" target="#b27">[28]</ref>, there are degrees of globality in the range of approaches, but a truly global approach does not yet exist.</p><p>In motion planning terminology, there is no guarantee of completeness<ref type="foot" target="#foot_2">3</ref> in any of the current approaches. All the current approaches treat hard kinematic constraints-due to joint limits, self-collisions, <ref type="foot" target="#foot_3">4</ref> and collisions with static obstacles-by transforming them into some sort of potential functions (or closest distance) and can be easily caught in local minima <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b28">[29]</ref>. These approaches often implicitly assume that the given initial configuration is fairly close to the desired solution (for the point to point problem); or, that corresponds to the start configuration of the end-effector trajectory (for tracking problem). Research in motion planning, on the other hand, has dealt with such constraints in a very different and effective manner by explicitly characterizing the free regions in the configuration space (joint space) <ref type="bibr" target="#b25">[26]</ref>.</p><p>Tools from topology have been employed to characterize the global set of solutions for point-to-point inverse kinematics-in particular, -bundles and self-motion manifolds <ref type="bibr" target="#b5">[6]</ref>-but these works do not give algorithms for finding a solution if there exists one. Reference <ref type="bibr" target="#b11">[12]</ref> has applied learning techniques to characterize the distinct solution branches. Reference <ref type="bibr" target="#b27">[28]</ref> discusses a three-layered conceptual framework for inverse kinematics. The top layer essentially addresses the motion planning aspects, i.e., determine if a feasible path exists and if it does, determine a sequence of "regions" (c-bundles) that the path passes through. The middle layer generates continuous paths traversing these regions and the bottom layer is responsible for optimizing (local redundancy resolution or more global optimization based on calculus of variations). Note that almost all existing algorithms for inverse kinematics fall in the bottom layer category.</p><p>In <ref type="bibr" target="#b27">[28]</ref>, it is assumed that a graph like compact description of the free configuration space is available, and it is suggested that an type algorithm could be used for searching this graph. However, the topology and the geometry of the free configuration space can be extremely complicated and it is not clear how to automatically obtain this graph like structure in general.</p><p>In the motion planning literature, several much more effective approaches have been suggested to search high dimensional spaces with extremely complicated topological structure <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b25">[26]</ref>. In particular, an appealingly simple emerging paradigm (although there are differences in specific details) in solving classical motion planning problems is to capture the connectivity of the free configuration space using a finite (but possibly large) set of nodes (or landmarks) <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b22">[23]</ref>-generally called a roadmap <ref type="bibr" target="#b25">[26]</ref>.</p><p>In this paper, we propose that this roadmap paradigm is eminently suitable for the inverse kinematics problem and apply this paradigm to solve the point-to-point inverse kinematics problem for redundant manipulators in the presence of joint limits, self-collisions and obstacle constraints. It makes absolute sense to capture the connectivity of the free configuration space-in the presence of joint limits and self-collisions-in what we call the kinematic roadmap of the manipulator, since the kinematic structure of a manipulator does not change and once built, this very general and practical data structure can be used to quickly find a solution for inverse kinematics problem. The emphasis of our approach is on the motion planning aspects of the problem, i.e., finding a path if there exists one (completeness property). We note that to the best of our knowledge, such completeness issues have not been addressed in the kinematics literature. Our approach, as it stands now, is mainly off-line and considers geometric and environmental (obstacles) constraints. Once a feasible path is found, more elaborate optimization criteria (e.g., energy minimization) can then be used to optimize it. In other words, our approach could provide the top layer in the three layered framework discussed above.</p><p>Due to the hard kinematic constraints mentioned above, the free configuration space may consist of several connected components. The specific approach we use builds the roadmap for the connected component of the free configuration space-we call it the reachable configuration space-that contains the initial configuration. Our implemented algorithm (and the completeness results) therefore, addresses the pointto-point kinematic problem and not the existence problem. See Section X for a brief discussion on this.</p><p>In summary, the salient features of our algorithm are 1) it proposes and builds a novel representation-the kinematic roadmap-of the reachable configuration space of the manipulator with a finite number of nodes; the roadmap is then used to efficiently find a feasible solution; 2) hard kinematic constraints due to joint limits, selfcollisions and other static obstacles are explicitly taken into account while building this roadmap; 3) it is global and addresses completeness issues; 4) it does not address the problem in velocity domain. The paper is organized as follows. We start with a brief overview of our approach in Section II. Section III poses the inverse kinematic problem as an optimization problem that minimizes a novel metric between two end-effector frames. We then present our local algorithm SEARCH in Section IV. EXPLORE is explained in Section V. The overall algorithm INVKIN is then presented in Section VI. Implementation details and simulation results for a seven-DOF manipulator are presented in Section VII. The completeness results are presented in Section VIII. Section IX presents some numerical complexity and efficiency results for our local algorithm SEARCH. Two important future extensions are discussed in Section X, and finally, conclusions are stated in Section XI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. OVERVIEW OF OUR APPROACH</head><p>We first formulate the inverse kinematic problem as an optimization problem (as is normally done in the kinematics literature) over the reachable configuration space of the robot, however, with the objective function being a somewhat novel metric between the initial and the desired end effector frames. This optimization problem is then solved using a framework analogous to Ariadne's Clew algorithm (ACA), originally proposed for classical motion planning <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b4">[5]</ref>. Our approach is best described as composed of two sub-algorithms: EXPLORE and SEARCH, executed in an interleaved manner. The EXPLORE algorithm "explores" the reachable configuration space from the given initial point by iteratively placing "landmarks" in it. The landmarks are placed so that a path from the initial position to any landmark is known. The set of landmarks with the associated paths is a kinematic roadmap that represents the connectivity of the reachable configuration space in the presence of hard kinematic constraints. The SEARCH algorithm is a local planner <ref type="foot" target="#foot_4">5</ref> that attempts to attain the goal configuration from a newly placed landmark. SEARCH exploits the serial kinematic structure of a manipulator, and solves the optimization problem sequentially, in a closed form, thereby making it efficient. Fig. <ref type="figure" target="#fig_0">1</ref> shows a schematic representation of the process. Each denotes a landmark , with being the start configuration. The continuous paths show the trajectories used by EXPLORE to place a landmark and the dotted ones show the attempts by SEARCH to reach the goal position. The tip of the arrows shows how far the local planner SEARCH could proceed. In the schematic, SEARCH succeeds from . The final trajectory will be then constructed using landmarks (and the corresponding paths connecting them) , , , and the path to the goal point found by SEARCH. The resolution completeness of the ACA approach for classical motion planning has been shown in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b31">[32]</ref>. In this paper we show a similar claim for the inverse kinematics problem. Furthermore, we demonstrate the practical effectiveness of our approach.</p><p>We have implemented this approach for a seven-DOF manipulator arm (with polyhedral models for links and jointlimits) shown in Fig. <ref type="figure" target="#fig_9">7</ref>, and our initial experiments have been extremely successful (see Section VII for details). The planner always found a feasible path. A main reason for the success of our approach appears to be that has a rather large pre-image region-the set of all points from which SEARCH succeeds in getting to the goal, . Therefore, the probability that EXPLORE will place a landmark in this pre-image region is quite high. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PROBLEM FORMULATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Notation</head><p>We use different metrics in different spaces in this paper. is used to denote a novel metric (defined later) between two endeffector frames corresponding to two different end-effector configurations. The symbol is used to denote the standard Euclidean norm in . denotes the distance between a point and a set in , i.e., . Let denote the robot arm, denote a robot configuration, denote the end-effector of , and denote a configuration of the endeffector, where , , denote an appropriate parameterization of . and denote the configuration spaces of and , respectively. Let denote the collision-free subset of (where the robot is free of constraints due to jointlimits, obstacles and self-collisions); and denotes the entire reachable (path connected) component of containing the point . We also define the -free Cspace as , where denotes the complement of . A feasible path is defined as a path that satisfies the joint limits and the collision constraints, i.e., it lies completely in . A landmark is a point in the configuration space and is denoted by . A set of landmarks is denoted by .</p><p>Following standard -notation in <ref type="bibr" target="#b8">[9]</ref>, we use to denote a frame attached to th joint, and is the homogeneous transformation matrix (or simply matrix) that represents w.r.t.</p><p>. The trailing superscript may be omitted if the base frame is implicitly understood.</p><p>represents the matrix corresponding to a configuration of the end-effector frame .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. The Metric</head><p>One could use any number of metrics between two configurations of the end-effector as the objective function, however, it is well known that these metrics mix translational and rotational components <ref type="bibr" target="#b25">[26]</ref>. Although there is no natural way of doing it in general since any distance metric in will ultimately depend on a choice of length scale <ref type="bibr" target="#b36">[37]</ref>, what we need is a way of measuring distance between two configurations of the same object and such metrics have been proposed before <ref type="bibr" target="#b23">[24]</ref>. These metrics, however, are computationally expensive <ref type="bibr" target="#b36">[37]</ref>. Instead, we define a novel metric between two coordinate frames, <ref type="foot" target="#foot_5">6</ref> say and represented (w.r.t. some common frame</p><p>) by matrices and as follows. The tips of the unit vectors (along the respective coordinate axes of the frame) of a frame determine a set of three physical points (vertices) in the workspace, one vertex for each of the three axes. The distance is defined as square root of the sum of squares of Euclidean distances between the corresponding vertices of the two frames, i.e., <ref type="bibr" target="#b1">(2)</ref> where , , and are the distances between the vertices of the , , and axes unit vectors, respectively (see Fig. <ref type="figure" target="#fig_1">2</ref>). Note that trailing superscript may be dropped since this metric is left-invariant, i.e., it is independent of the base frame .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. The Problem</head><p>This metric is then used to pose the inverse kinematics problem as an optimization problem. A cost function is first defined as <ref type="bibr" target="#b2">(3)</ref> Stated in words it is the distance between the end-effector configuration and the goal end-effector configuration . The point-to-point inverse kinematic problem can then be posed as follows:</p><p>Given an initial robot configuration, , and a desired end-effector configuration, , determine a reachable robot configuration and a feasible path to it such that (4)</p><p>Note that , and furthermore, the global minimum of is not unique. In the next two sections, we show an algorithm to solve this problem within the ACA paradigm. First we present a local algorithm (SEARCH) that computes a local minimum of the optimization problem, and then we present EXPLORE that spreads landmarks over the reachable configuration space. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. LOCAL ALGORITHM SEARCH</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Algorithm</head><p>Our approach exploits the serial kinematic structure of manipulator <ref type="bibr" target="#b17">[18]</ref>- <ref type="bibr" target="#b19">[20]</ref> to construct an efficient local algorithm to solve the optimization problem posed in the previous section. Let , , , , , be a free configuration of the robot. We denote by , the collision-free interval (the one that contains ) of joint at configuration (see Fig. <ref type="figure" target="#fig_2">3</ref>). and represent the maximal increment of joint in the negative and positive direction, respectively. The joint limits are naturally represented as an interval and the collision constraints are easily computed as an interval by simple computational geometric methods <ref type="bibr" target="#b26">[27]</ref>. The intersection of these intervals then gives the desired interval , which determines the feasible range of motion for joint . Formally, let denote this feasible interval set for joint , i.e., Let be the desired configuration of . For an arbitrary , a function is defined as follows:</p><p>(5) Note that it is a one dimensional optimization problem (in ) and that is the unique global minimum in . For brevity, we have not explicitly shown as one of the arguments of . Note that the values of joints other than do not change as a result of applying , i.e., if  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Starting from</head><p>, SEARCH repeatedly applies , each time using the result of previous iteration as the starting point for the current iteration. Note that SEARCH , is a global minimum (i.e., a solution to the inverse kinematic problem) if , else a local minimum has been found. In practice, one may bound the number of iterations with an upper limit or to a given resolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Implementing</head><p>We now describe how is implemented for a revolute joint, the case for prismatic joint is similar. (see Fig. <ref type="figure" target="#fig_3">4</ref>) at the configuration of the robot. Let represent the rotation matrix corresponding to an angle about -axis (as in the notation of <ref type="bibr" target="#b8">[9]</ref>). Then, ( <ref type="formula">5</ref>) can be solved by writing <ref type="bibr" target="#b6">(7)</ref>, shown at the bottom of the next page, and then differentiating w.r.t. . Note that as a direct consequence of -notation <ref type="bibr" target="#b8">[9]</ref>, the coordinate of remains constant and therefore the symbolic differentiation of the cost function (rather, its square) is simplified. For example, the first term in (7) can be written as <ref type="bibr" target="#b7">(8)</ref> Note that the term is a constant and therefore has no influence in the optimization.</p><p>Differentiating square of in ( <ref type="formula">7</ref>) w.r.t. (using MAPLE) and equating to zero, we get with and . This yields the following expression for the extremum value for a revolute joint:</p><p>(9) The global extreme of over the interval are at , or ; one corresponds to the maximum and the other to the minimum. We simply evaluate both and compare to determine the minimum. If the true minimum lies outside the valid range , , the minimum within the valid range is taken at the appropriate endpoint of the interval [see Fig. <ref type="figure" target="#fig_5">5(a)</ref> and<ref type="figure">(b)</ref>]. The value returned by is .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. ALGORITHM EXPLORE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Ideal Version</head><p>The goal of EXPLORE is to capture the connectivity of the reachable configuration space from an initial configuration . A representation of that space is obtained by generating free paths and placing landmarks all over the reachable configuration space, beginning from the initial landmark (configuration)</p><p>. The structure obtained by EXPLORE is essentially a tree where the set of nodes represents a set of configurations in and the set of links represents free paths connecting these configurations. This structure is a kinematic roadmap.</p><p>We first present a description of EXPLORE , the ideal version that requires a global optimization. Let denote the set of existing landmarks at step . We initialize the set of landmarks to where . Let be a configuration in that is farthest from , i.e., becomes the second landmark, i.e., and . For the next iteration, the third landmark is placed by maximizing the distance from over from either landmark in the set (recall that denotes distance between a point and a set), i.e., More generally, for iteration , we obtain the th landmark so that it maximizes the distance from the current set of landmarks, i.e., <ref type="bibr" target="#b9">(10)</ref> (7) EXPLORE can then be written as follows: begin th end</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Implemented Version</head><p>The ideal version, EXPLORE requires a global optimization, a complex problem in itself. Less than ideal versions of EXPLORE may be implemented in several ways. Here we present an appealingly simple but effective implementation that has been very successful in our experiments. This implementation is based on a quasirandom (or quasi Monte Carlo) method for global optimization <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b39">[40]</ref>. It executes random paths, one each from the current set of landmarks. Each of these paths lie completely in . The end points of these random paths are called embryos. The embryo that is the farthest from the current set of landmarks is then chosen as the new landmark, and the process is repeated. Note that this may not be the true maximum (as in the ideal EXPLORE), and is simply an estimate of the true maximum (Section VIII-B-3 for more on this).</p><p>Formally, at the th iteration, let denote the set of existing landmarks, and let be the set of paths from one landmark to another.</p><p>represents the path going from the father of landmark to , for example, is the path from landmark to in Fig. <ref type="figure" target="#fig_0">1</ref>. Let denote the set of existing embryos, and denote the set of paths going from landmarks to their corresponding embryos, where is the path from landmark to . The tree structure is the kinematic roadmap of the manipulator . A schematic representation of is shown in Fig. <ref type="figure" target="#fig_0">1</ref>. Note that the cardinality of , and is . At times, we may omit the sub-index and simply write . EXPLORE iteratively builds by placing one new landmark at each iteration.</p><p>The set of landmarks is initialized to . EXPLORE generates a random feasible path and the end of this path is initialized to the first embryo, i.e.,</p><p>. The edge set of the tree is initialized to null set, i.e., , and . At step , the embryo, say that is farthest from , [i.e., , ], becomes the th landmark, i.e., . The corresponding path, is added to the edge set, i.e., . Two new embryos are generated-one embryo to replace the embryo that just became a landmark and the other from this newly generated landmark. Each of these is obtained, as before, by executing a random feasible path. The first path, is generated from and the end of the path becomes an embryo, i.e., . The second path, is generated from and the end of this path becomes the corresponding embryo, i.e., takes the roadmap as its input and returns an updated roadmap and is stated in pseudocode form as follows: where the generates a random path beginning at configuration .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Generating Random Feasible Paths: Manhattan Paths and Bouncing Technique</head><p>As we have shown in the previous section, each of the landmarks generated by the algorithm is obtained by generating a random feasible path. In order to do this we use a special class of paths, the Manhattan paths, which consist of moving one robot link at a time. Formally, a Manhattan path for a n-DOF robot is completely defined by Note that the semantic of this path is "move link 1 a distance " followed by "move link 2 a distance ," and so on. Furthermore, the product of single Manhattan paths is a Manhattan path of order .</p><p>There are several advantages to using Manhattan paths. They can be represented by a vector in , (note that in general a path is represented by a function not a vector). They are easy to test for collisions. Since only one link moves at a time, the collision test can be done by successively computing the intervals of motion for a single degree of freedom <ref type="bibr" target="#b26">[27]</ref> (see Fig. <ref type="figure" target="#fig_2">3</ref>). A closed-form solution to compute the collisionfree interval for a single degree of freedom exists. This makes it possible to compute continuous paths. Other simple classes of paths, such as straight line paths, will require much more elaborate ways of characterizing collision-free regions, and some arbitrary discretization will need to be used. Finally, the class is resolution complete in that if a trajectory exists from one configuration to another and the minimal distance of this trajectory to the -obstacles is 0, then there exists a Manhattan path from to <ref type="bibr" target="#b0">[1]</ref>. It is clear that all valid Manhattan paths of order can be represented by a vector but not all vectors represent a valid Manhattan path, since could easily violate a kinematic constraint, either due to an obstacle or due to joint limit. The bouncing technique allows us to map an arbitrary Manhattan path into an admissible Manhattan path. The basic idea is to bounce off the obstacle and has been used in <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b20">[21]</ref> (see Fig. <ref type="figure" target="#fig_7">6</ref>). Suppose a certain leads to collision. As mentioned before, at the given configuration, a collision-free interval can be easily obtained (as in <ref type="bibr" target="#b26">[27]</ref>) such that every joint value within this interval is collision-free (see Fig. <ref type="figure" target="#fig_2">3</ref>). We can then map the original incremental interval modulo the collision-free interval to the collision-free interval . Physically speaking, it is as if the robot link repeatedly bounces off the obstacles until the entire is travelled. Obviously, this bouncing movement is not executed by the robot, it is just a mapping from to . Note that the range of link depends on the moves of link , i.e., and are functions of for . We can now generate a random Manhattan path (by randomly generating each , which is equivalent to generating a random vector</p><p>) and then transform it into an admissible Manhattan path using the bouncing technique. In Section VIII we show that it is possible to compute the number of iterations (</p><p>) that ensures the resolution completeness of INVKIN. Note that the solution path going from to the inverse kinematic solution, can be easily obtained by concatenating the paths (corresponding to the path in the kinematic tree from to , the last placed landmark) and the path obtained by SEARCH from to .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. SIMULATION RESULTS</head><p>The above algorithm, INVKIN has been implemented (on an SGI Indigo II) for a seven-DOF manipulator arm in three-dimensional (3-D) environments. All joints are revolute and each joint has a joint limit (e.g., 90 to 90 for joint 1, and similar limits for other joints). Polyhedral CAD models were used for both the robot and the environment. The collision detection scheme is based on the algorithm in <ref type="bibr" target="#b26">[27]</ref> that efficiently computes a collision-free interval for a given robot link as it rotates, keeping all other degrees of freedom fixed. These collision-free intervals are then used by the bouncing technique to convert an arbitrary Manhattan path into a collision-free Manhattan path. Several standard techniques-simplified and hierarchical representations for manipulator links and obstacles, etc.-were employed for efficient collision detection. The robot links and the fixed obstacles are each represented by a parallelepiped.</p><p>In order to test our algorithm INVKIN, we needed to make sure that a solution indeed exists for each of the test cases, i.e., there is a manipulator configuration corresponding to the desired end-effector frame. This guarantee for the test cases was achieved as follows. We first generated several random and collision-free configurations of the robot and saved the corresponding configurations of the end-effector. These endeffector configurations were then used as goal configurations to test INVKIN and obtain various test statistics such as percentage success, average number of landmarks placed, and average run time. We limited the maximum number of landmarks to 512 (somewhat empirically chosen). The following pseudocode succinctly states the testing procedure, with , being the initial configuration specified by the user (or, any standard configuration, such as the home configuration of the manipulator) begin end where random_free_conf() generates a random and collisionfree configuration of the robot. This is simply a matter of using a standard random-number generator times (each corresponding to a degree of freedom), scaling it to the corresponding joint limits, and checking if the resulting configuration is collision free.</p><p>We ran two series of tests: 1) without precomputing the roadmap 2) with a precomputed roadmap. Each of the series were carried out with and without obstacles. Five different environments were used for the tests with obstacles and the same initial configuration was used for each. INVKIN planner always found a solution.</p><p>Table <ref type="table">I</ref> summarizes the result of our experiments without precomputing the roadmap. These run times include the time for incrementally generating the roadmap . Note that the algorithm stops as soon as SEARCH finds a solution, hence the number of landmarks varies from example to example. Fig. <ref type="figure" target="#fig_9">7</ref> pictorially illustrates one of the examples (with obstacles) in our test set. The initial configuration of the arm, and the desired end-effector location is shown in Fig. <ref type="figure" target="#fig_9">7(a)</ref>. Note that the desired location of the end-effector is under the table and therefore, quite constrained. Small moves of the robot must be executed to achieve this (if it is indeed possible). Fifty to 80 landmarks were needed to solve this example and the total execution time was 30 s.</p><p>For the precomputed roadmap test, we first constructed and stored the entire kinematic roadmap with a predetermined number (512) of landmarks in a preprocessing step. Then for each inverse kinematics query, we simply executed SEARCH from each of the precomputed landmarks until a solution was found (or a failure was reported). INVKIN planner always found a solution. Table <ref type="table">II</ref> summarizes the run times.</p><p>We believe these times can be further reduced by order magnitude (with more efficient programming and collisiondetection techniques) to make the inverse kinematics computation online.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. COMPLETENESS</head><p>In this section we discuss and present several results related to the completeness aspects of our inverse kinematics algorithm. Although on surface, the domain of the problem is continuous, we use the notions of packing and covering <ref type="bibr" target="#b7">[8]</ref> to turn it into a "discrete" domain. The resolution completeness of ACA for the basic motion planning problem was shown in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b31">[32]</ref>. The proofs here are enhanced versions, with several extensions and deal with the fact that for inverse kinematics, we are dealing with two different spaces, the configuration space of the robot, and the configuration space of the endeffector, each with its own metric.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. General Discussion</head><p>First we derive some expressions for the probability of finding the solution in iterations (or landmarks) with a simple random scheme. Then, we show that with the ideal version EXPLORE (it optimizes globally), the number of landmarks needed to approximate a solution with in a given distance is finite. This directly leads to resolution completeness of EXPLORE (SEARCH in this case is not needed). We extend this result to the case when EXPLORE optimizes over a localized domain.</p><p>In our implementation the optimization realized by EX-PLORE however, is not guaranteed to be global even within a restricted region. It has an element of random optimization. We show that, in this case, EXPLORE is probabilistically resolution complete. Furthermore, for inverse kinematics, it may often be of interest to find a solution within a distance of the desired end-effector configuration, (i.e., find such that ). We show that indeed this is the case. We also show that if SEARCH is a local planner such that it is guaranteed to find a solution with in an -dimensional ball of radius (i.e., SEARCH is complete in that ball), then INVKIN which interleaves EXPLORE and SEARCH is a probabilistic complete planner. Moreover, our conjecture is that SEARCH, as implemented by us (Section IV) has an -dimensional preimage. In this case, resolution completeness in above results could be substituted with stronger completeness. For avoiding cluttered notation, from now on we use to denote the connected component . We define the pre-image of SEARCH as a region, , such that for every configuration in the region, SEARCH succeeds in finding a path to the goal , i.e., , with . Note that the pre-image for redundant manipulators may be a very complex (singly or multiply connected) region. Clearly, if we find a configuration , we will find a solution for the inverse kinematics problem (by executing SEARCH from that configuration). The larger is , the bigger is the probability of finding a solution.</p><p>Let denote the volume of a subspace . The probability, of placing a configuration in with a single trial is Therefore, the probability of finding a solution within trials is Clearly, 1. This leads to probabilistic completeness. Now suppose that somehow there exists a finite set of landmarks (configurations) in with some . One could then randomly select a landmark, execute SEARCH to check if it succeeds. The probability of finding the solution within such trials is Note that in this discrete case, one is guaranteed to find a solution (if there exists one) in trials. Furthermore, the probability of finding a solution increases with .</p><p>The question then becomes how we can guarantee that there is a landmark in the . This is where the notion of covering is useful. Consider a maximal -dimensional ball (a sphere)</p><p>of radius in such that it fits completely in the pre-image. The basic idea is that we place enough landmarks in such that any point in is within a distance of some landmark. Effectively, the entire is covered with balls of radius , centered at landmarks. This will guarantee that there exists at least one landmark in the ball (and hence in the pre-image). The next question is how many landmarks in (that cover</p><p>) we can chose such that the distance between any two landmarks is at least . Is this number finite? This is where the notion of packing is useful. Since is compact, the number of landmarks has an upper bound. We show that the ideal version EXPLORE places landmarks in such a way that they define a packing (with one radius) and a covering (with a larger radius). The fact that it is a covering ensures that there is a landmark within the pre-image ball and the fact that it is a packing ensures that this number is bounded. If (the number of landmarks) is greater than this bound, it implies that for any configuration there exists a landmark within distance , and therefore, there exists a landmark in . We now state these notions more formally.  The density , of a packing , is defined as the fraction of the volume of that is occupied by the spheres of <ref type="bibr" target="#b7">[8]</ref>, i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Formal Proofs</head><p>It is well known that the density of any -dimensional packing has an upper bound, called the Roger's density, and denoted by , i.e., . Intuitively, this corresponds to the "densest" packing. <ref type="foot" target="#foot_7">8</ref> A related concept is Roger's central density, defined as , where denotes the volume of a unit ball in . corresponds to an upper bound on the number of unit spheres that one can place in a unit volume in an -dimensional space.</p><p>Definition: Let be a finite set of points in . We call an -dimensional covering of if . is the covering radius of the covering.</p><p>For a given set of landmarks in , let denote the least upper bound of the distance from any point of to the closest landmark . is called the minimum covering radius<ref type="foot" target="#foot_8">9</ref> of , i.e., <ref type="bibr" target="#b10">(11)</ref> Note that for any , is not a covering of <ref type="bibr" target="#b7">[8]</ref>. We now show that EXPLORE constructs a covering and a packing of the set . The covering ensures that for any point , there exists with . On the other hand, the packing ensures that this approximation is obtained with a finite number of iterations.</p><p>2) Completeness of EXPLORE : Recall that at the th iteration, EXPLORE chooses the landmark by maximizing the distance from , the set of landmarks at iteration . Formally stated, Let be the center of , its radius, and let . Lemma: is a packing in and is a covering of (see Fig. <ref type="figure" target="#fig_10">8</ref>). Proof: First we show that is a covering of . We do this by contradiction. Suppose that is not a covering of then, there exists a point such that but . This leads to contradicting the fact that is the upper bound in <ref type="bibr" target="#b10">(11)</ref>. We now show that is a packing in . Note that is a set of points in , therefore, , . Furthermore, note that for , therefore with . This shows that is a packing in and concludes the proof. Lemma: 0. Proof: We know that is a packing in . Then <ref type="bibr" target="#b11">(12)</ref> Corollary: For any , there exists a finite integer such that . Proof: Consider the densest packing (call it ) one can obtain with packing radius . Let the corresponding set of points (not necessarily placed by EXPLORE) be denoted by , i.e.,</p><p>) is the densest packing in . Clearly, the density of this packing must be bounded by the Roger's density, i.e.,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Card</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Card</head><p>Any packing that has greater cardinality than that of must therefore have a smaller packing radius. So if we now let EXPLORE run until an iteration (say, ) greater than the cardinality of , the resulting packing radius must be less than , i.e., we have <ref type="bibr" target="#b12">(13)</ref> This shows that EXPLORE will place a landmark within a distance of the goal, i.e., it is resolution complete. Let be the radius of the pre-image ball for a given goal configuration in . We can also state that the probability of finding a solution with EXPLORE within iterations is ( <ref type="formula">14</ref>)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) Completeness of EXPLORE : In placing a new landmark, EXPLORE globally [in the entire</head><p>] optimizes the distance between it and the current set of landmarks. Often, solving global optimization is not practical. We now relax this assumption. We assume a version of EXPLORE (EXPLORE ) which optimizes within a subset of . In particular, we assume that starting from each landmark, , EXPLORE has an optimizer that can optimize within a ball, . Therefore, at the th iteration, EXPLORE optimizes with in . Given the initial landmark , EXPLORE begins with and the th landmark is chosen as follows:</p><p>(15) with <ref type="bibr" target="#b15">(16)</ref> Lemma: Suppose EXPLORE is started with and is obtained for th iteration. Then is a covering of , the connected component of containing , i.e., such that . Proof: We show this by contradiction. Let denote the boundary of . Assume that is not a covering of , then it implies that . Now consider any configuration and let be the closest landmark to then because belongs to . Furthermore because belongs to (see Fig. <ref type="figure">9</ref>). This indicates that there exists for which and is connected to because . This contradicts the fact that .</p><p>Fig. <ref type="figure">9</ref>. Boundary of K m in C Afree (q o ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4) Completeness of Implemented EXPLORE:</head><p>Our implementation of EXPLORE optimizes using Manhattan paths. Therefore, the optimization space is different from a ball in . However, if the set of points that can be attained with the Manhattan paths starting from a landmark (we call it the forward projection), contains a ball in , our results still apply.</p><p>Let denote the set of Manhattan paths (beginning at ) of order in , and denote the set of existing landmarks at iteration . Let . We define the forward projection of in as follows:</p><p>Stated otherwise, belongs to iff there exists a Manhattan path with initial point in and end point . Note that depends on , , and , however, for brevity we are not showing it explicitly in our notation.</p><p>We now show that this set contains a ball of some radius, i.e., for , , and we have that . This is verified as follows consider any and the closest landmark to then there exists a Manhattan path from to , particularly is precisely such a path. Furthermore, recall (Section V) that our implementation of explore selects a set of random (Manhattan) paths for optimization. In particular, and in ( <ref type="formula">15</ref>) and ( <ref type="formula">16</ref>) is estimated as follows. </p><p>Conversely, <ref type="bibr" target="#b16">(17)</ref>, can be used to find the minimal number of embryos that must be generated such that at least one approximation is in with a given probability . However, since is a priori unknown, the use of the previous expression is limited to making some hypothesis about its value and then computing the number of embryos that has to be generated in order to ensure that we will obtain an acceptable solution with probability . For example assuming that and that a probability of success is required, we get <ref type="bibr" target="#b39">[40]</ref>. It is known in stochastic literature <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b39">[40]</ref> that if has a positive probability for every value of , and given that is continuous then</p><p>We have already shown that the EXPLORE algorithm permits approximation of any configuration with in a given resolution . We now show that a similar property exists in the configuration space of the end-effector, i.e., if a solution (reachable from a given ) to the inverse kinematics problem exists, then it is possible to find a landmark (a configuration of the robot) such that . This is essentially a direct consequence of the following theorem in topology <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b13">[14]</ref>.</p><p>Theorem: Let be a compact metric space, a metric space and a continuous function. Then, for each 0, there exists a 0 (which depends on ) such that the image of the open ball under belongs to the open ball , or, stated otherwise, . Let be the end-effector configuration corresponding to the landmark in the robot configuration space, and let denote the corresponding set of landmarks in the end-effector configuration space. The following lemma shows that if is a reachable configuration from with , then can be approximated by some with and for some finite iteration .</p><p>Lemma: Let . There exists a finite such that Proof: This is a direct consequence of the previous theorem. If then . And (13) tells us that , and indeed this condition is satisfied, thereby concluding the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5) Completeness-Combining SEARCH and EXPLORE:</head><p>Assume that we have a SEARCH algorithm that is guaranteed to find a solution with in an -dimensional ball of radius (i.e., SEARCH is complete in that ball). It is then clear that INVKIN which interleaves EXPLORE and SEARCH, is a probabilistic complete planner.</p><p>Let be the radius of the pre-image ball for a given goal configuration in . Let be the radius of . We can now state that there exists a finite number of iterations (given by ( <ref type="formula">13</ref>) with replaced by ) within which a solution is guaranteed if there exists one. Of course, the bound on number of iterations depends on the structure and size of the of SEARCH. Finally, we conclude this section with the conjecture that our implemented SEARCH algorithm (assuming that an inverse kinematic solution exists) will always have an -dimensional pre-image. If indeed this is the case, "resolution completeness" in the above results can be substituted with "completeness."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. RUN-TIME COMPARISONS AND NUMERICAL COMPLEXITY OF THE LOCAL PLANNER SEARCH</head><p>As mentioned earlier, a complete global algorithm for pointto-point inverse kinematics has not previously been reported in the literature. There is nothing to compare our global algorithm INVKIN with. We present some numerical complexity results for our local algorithm, SEARCH, and compare it with other reported local approaches for redundancy resolution. First, our results with SEARCH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Run-Time and Numerical Complexity of SEARCH</head><p>For revolute joints, one complete iteration (with all joints) of SEARCH requires operations, where denotes time cost for a single multiplication, denotes the time cost for a single addition, and denotes the time cost for a single trigonometric function. See the Appendix for details. This complexity is a general upper bound assuming that none of the -parameters are zero. For most manipulators, many -parameters are zero, the complexity is therefore considerably reduced. For example if or then the cost of SEARCH is . Substituting , we get</p><p>. Symbolic preprocessing can be used to further reduce the number of operations, and for specific robot geometries, even further efficiencies can be achieved.</p><p>Since most approaches in literature are reported with tracking type examples, our simulations for testing SEARCH were similar and are as follows. The end-effector path is a vertical line with constant end-effector orientation starting with a given end-effector configuration. We used a sequence of equidistant configurations ( ) along a path of length 10 cm. As before, the start end-effector configuration was chosen randomly, i.e., with , and the corresponding inverse kinematic solution was solved by solving the . The inverse kinematic solution for an in the sequence is obtained by . For example, , , and so on. For fair comparison with other approaches, no collision detection is executed for the experiments presented in this section.</p><p>An estimate is said to be a solution to the desired endeffector configuration , if</p><p>, where is the maximal allowable error. For fair comparison, we used the more common metrics in the literature and for computing this error. Let , and be two homogeneous matrices. consists in extracting the --Euler angles , and from and , respectively, and then defining (see <ref type="bibr" target="#b8">[9]</ref> for further details). A different metric uses the orientation vectors , and , and is defined as . The metrics and give the orientation error but not the position error. The position error for both metrics is defined as . In our tests, we considered to be an inverse kinematic solution to if and . Table <ref type="table" target="#tab_4">III</ref> shows the results for 0.1 mm and various values of . For each value, a sample of 100 random tests with 100 and 10 cm has been tested. The number of iterations and CPU times correspond to a problem of the form . The values of our metric (the distance between unitary vectors) in the table correspond to unitary vectors of length 1 m [see Fig. <ref type="figure" target="#fig_1">2</ref> and<ref type="figure" target="#fig_1">(2)</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Summary of Reported Run-Times of Other Local Approaches</head><p>As mentioned in Section I, most approaches to inverse kinematics are based on local resolution of redundancy at the velocity level. See <ref type="bibr" target="#b40">[41]</ref> for a comprehensive survey (although a bit dated, the basic categories are still relevant). The basic categories are:</p><p>1) simple Jacobian-based techniques;</p><p>2) gradient projection method; 3) task space augmentation 4) inverse kinematic functions. Categories 1)-3), at the core of their numerical computations use either a pseudoinverse or transpose of the Jacobian matrix. The numerical complexity for one iteration of the Jacobian pseudoinverse based methods has been mentioned as and that of the Jacobian transpose based methods as <ref type="bibr" target="#b33">[34]</ref>. In general, the references provide very sketchy computational information about the tests (run times, CPU used, etc.) and the metrics used are often different. We have compiled the available and relevant information in Table <ref type="table">IV</ref> for comparison of different algorithms. First column indicates whether the algorithm has been applied to redundant robots (indicated by ), or, if it is potentially applicable to redundant robots (indicated by ). We have also included a couple of works that are applicable to nonredundant robots (indicated by ) only. Third column gives the CPU time and the fourth column gives the number of iterations needed to solve a point-to-point problem. Fifth column gives the complexity that corresponds to one iteration of the algorithm. The column with "D" indicates the dimension of the problem (two-dimensional (2-D) or 3-D). The last two columns indicate the accuracy of the solution and the metric used to measure it. The accuracy in orientation (first value) is given in radians and the accuracy in position in millimeters. In case the metric used mixes translational and rotational components, only one value is given. We recommend that the reader consult the respective references for further details on those metrics. If an entry is not provided in a paper, it is marked with a "-" in the corresponding column.</p><p>It is difficult to make a rigorous comparison between SEARCH and many of the existing algorithms, particularly for 7 or more degrees of freedom. The most complete information was available for the algorithm of Dubey et al. <ref type="bibr" target="#b12">[13]</ref>. Hence we compare SEARCH with it. The numerical complexity for one iteration of the joint velocity computation step in the algorithm is 231 multiplications and 183 additions. Note that these do not include the overhead of computing the next point ( ) in the iteration, so it is somewhat less than the actual cost of one full iteration. Their reported run time is 6.5 ms on a 16 MHz Motorola 68 020. Note however that the accuracy parameter is not reported in their work making comparison somewhat difficult. This contrasts with 1526 multiplications, 1141 additions, and 35 trigonometric functions for SEARCH. Also, SEARCH takes of the order of 100 ms on an R 4000 (50 MHz) SGI Indigo II.</p><p>Indeed the algorithm of Dubey et al. is more efficient than SEARCH. However, there are additional factors that are in favor of SEARCH. First and foremost is that it is not velocity based and naturally incorporates and treats constraints due to collisions and joint limits as hard constraints. In Jacobian based approaches, these hard constraints are usually transformed into some sort of potential functions by assigning a repulsion factor to distance between robot links and the obstacles. Such factors are selected heuristically, and they may not guarantee that safety distance to the obstacles will be respected <ref type="bibr" target="#b16">[17]</ref>. The additional advantages of SEARCH are that it is completely general, and it has a rather large pre-image region. So the initial can be arbitrarily far from the solution, whereas most velocity (or Jacobian) based approaches require an initial close to the solution.</p><p>Notwithstanding these advantages, one could use some of the existing local algorithms (including that of <ref type="bibr">Dubey et al.)</ref>, suitably augmented to include joint-limits, self-collisions, and collisions with other obstacles, instead of SEARCH as a local algorithm within our overall kinematic roadmap framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. DISCUSSION</head><p>An important extension would be to exploit the topology of the configuration space while creating this kinematic roadmap. It is known that the configuration space can be subdivided into -bundles (collection of self-motion manifolds that are homotopic) separated by coregular surfaces (self-motion manifolds that contain a singular point). The forward mapping of the set of -bundles divides the work space in different regions called -sheets and, the coregular surfaces are mapped into regions that correspond to the border between two different -sheets.</p><p>The connectivity among different -bundles of the configuration space could be represented via a two-level hierarchical organization of kinematic roadmap. The first level would consist of a kinematic roadmap capturing the connectivity of the configuration space (just as shown in this paper), with each landmark in it corresponding to a particular c-bundle. Each , in turn, would be the root of a second level roadmap . Each , would capture the connectivity of the corresponding -bundle. Such a hierarchical organization would be useful in succinctly characterizing the infinite solution set-one solution corresponding to each self-motion manifold.</p><p>One way of generating a second level roadmap representing a particular -bundle would be to start with an initial landmark in the -bundle, treat the coregular surfaces as an obstacle, (and use the bouncing technique), and use EXPLORE. Note that a -bundle may consist of several connected components (via -obstacles that arise due to physical obstacles, self-collisions, and joint limits).</p><p>We ran preliminary experiments with a nonredundant robot (PUMA 560) to investigate if we could find all different (up to eight <ref type="bibr" target="#b8">[9]</ref>) solutions to a given end-effector configuration. We ran INVKIN, however, upon reaching a solution, instead of stopping, we continued the algorithm. It took about 10 s to find all eight solutions.</p><p>The specific approach we use (algorithm ACA) builds the roadmap for the connected component that contains the initial configuration. Our implemented algorithm, therefore, solves the point-to-point kinematic problem and not the existence problem. Another important issue is to extend our approach to solving the existence problem. One could pose two versions of existence problem: i) a pure decision problem, where one is interested in determining if there exists a solution and ii) a more constructive characterization problem, where one is interested in determining and characterizing all possible solutions. In either case, one would most likely need to build the kinematic roadmap for all connected components of the configuration space. Our current research is focusing on these issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XI. CONCLUSION</head><p>We proposed a new and global approach to solving the point-to-point inverse kinematics problem for redundant manipulators. Inspired by recent motion planning research, we proposed the notion of kinematic roadmap of a manipulator that captures the connectivity of the connected component (containing the given initial configuration) of the configuration space-including joint limits, self collisions, and static obstacles-of a manipulator in a finite graph like structure. The kinematic roadmap is a general and practical data structure, and once built (for a given manipulator), it can be used to quickly find a set of solutions for the inverse kinematic problem.</p><p>The standard formulation of inverse kinematics problem is then solved using this kinematic roadmap. Our inverse kinematic algorithm is composed of two subalgorithms: EX-PLORE, an appealingly simple algorithm that builds the kinematic roadmap (starting from the given initial configuration) by placing landmarks in the configuration space, and SEARCH, a local planner, that uses this kinematic roadmap to reach the desired end-effector configuration. Our implementation of SEARCH is an efficient closed form solution, albeit local, to inverse kinematics that exploits the serial kinematic structure of serial manipulator arms. We present several completeness results for our algorithm. Initial experiments with a seven-DOF manipulator have been extremely successful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Various Types of Completeness</head><p>We state the precise definitions of various types of completeness used in the motion planning field <ref type="bibr" target="#b25">[26]</ref>. In our notation, denotes the given initial configuration and denotes the desired final configuration.</p><p>1) Complete: A complete algorithm will find a solution if there exists one. If no solution exists then the algorithm will return a failure. That is, if a solution exists then the algorithm finds a free-path with and .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Resolution Complete:</head><p>The resolution completeness is related to the discretization of the search space. An algorithm is said to be resolution-complete if it guarantees to find a path (if there exists one) in such that and with with . If no such solution exists, then the algorithm will return a failure.</p><p>3) Probabilistically Complete: An algorithm is said to be probabilistically-complete if the probability of finding a freepath (if there exists one) can be made arbitrarily close to 1 (as you let the algorithm run longer). Note that a probabilistically complete algorithm may not terminate in a finite time (especially if a solution does not exist).</p><p>4) Probabilistically Resolution Complete: An algorithm is probabilistically resolution-complete if the probability of finding a free-path (if there exists one with the given resolution ) such that and with and can be made arbitrarily close to 1 (as you let the algorithm run longer).</p><p>5) Heuristic: An algorithm is heuristic if it is not guaranteed to find a solution (exact or approximate). Such algorithms are often problem specific and can simply fail in more complex scenarios. However, they may often be useful for some practical engineering applications. Heuristic algorithms may have a polynomial worst case complexity (in the dimension of the configuration space) whereas every known complete algorithm has an exponential running time (variants of motion planning problems have been shown NP-Complete or P-SPACE hard <ref type="bibr" target="#b25">[26]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Numerical Complexity of the Local Planner Search</head><p>We now analyze the numerical complexity of our local algorithm SEARCH by giving the number of multiplications ( ), additions ( ), and trigonometric functions ( ) required for one iteration. Essentially, the complexity of SEARCH is given by the cost of computing the transformation matrices and the cost of computing minimum in the function times. The homogenous matrix is given by <ref type="bibr" target="#b17">(18)</ref> where , , , and are the standard -parameters <ref type="bibr" target="#b8">[9]</ref>, and , denote , , respectively, (same for and</p><p>). The computational cost of computing each of the matrices is then . Computing [optimization of <ref type="bibr" target="#b6">(7)</ref>] requires the following steps:</p><p>1) get and ; 2) use to get , and to get ; 3) compute by using ( <ref type="formula">9</ref>) and get the new matrix with . is established by the computational cost of computing matrices , and . A product of a matrix with any other matrix requires of . The inversion of a homogeneous -matrix requires . Thus, for an -DOF robot, we require products of matrices and one matrix inversion. The total cost of step 1) is, therefore . The costs of step 2) and 3) are (straightforwardly computed) and , respectively. The computational cost of function is then . Consequently the cost of and SEARCH [see <ref type="bibr" target="#b5">(6)</ref>] is . A minor detail is that an initial cost of computing the matrices at the very first iteration must be added to the cost of SEARCH. More precisely, the cost for iterations of SEARCH is . The analysis involving prismatic joints is similar.</p><p>The previous analysis considers that , , , and . If some of these parameters are zero, the numerical complexity is considerably reduced. For example, if 0 or then and the cost of SEARCH is , or more precisely, the cost for iterations is .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Schematic representation of the kinematic roadmap. The set of landmarks and the associated paths capture the connectivity of the reachable configuration space in the presence of self-collisions and joint limits.</figDesc><graphic coords="4,80.64,59.58,175.92,184.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. dx, dy, and dz are shown graphically. Square root of sum of squares of these three quantities defines the metric d between two frames, F a and F b .</figDesc><graphic coords="4,314.88,59.58,233.52,68.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Illustration of collision-free interval [1 min 1 ; 1 max 1 ] due to a physical obstacle. Constraints due to joint limits and self-collisions are also represented as an interval.</figDesc><graphic coords="5,94.74,59.58,147.84,117.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Vectors P j and P 0 j corresponding to the desired goal configuration and an arbitrary configuration of the end-effector. Both are defined w.r.t. F i .</figDesc><graphic coords="5,328.56,59.58,206.16,163.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>It is analytically derived by symbolically differentiating the cost function in w.r.t. , that is the increment of joint . It is computationally advantageous to represent the goal frame w.r.t. frame . Let , 1, 2, 3 denote the vectors that represent the tips of unit axes vectors ( , , and ) of w.r.t. . Similarly, , 1, 2, 3 denote the vectors that represent the tips of unit axes vectors w.r.t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Two cases presented for the global (with only the ith joint varying) minimum for i : (a) within the interval [1 min i ; 1 max i ] and (b) outside the interval, [1 min i ; 1 max i ].</figDesc><graphic coords="6,129.60,55.02,341.04,157.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Physical illustration of bouncing technique.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>VI. ALGORITHM INVKINUsing SEARCH and EXPLORE, our inverse kinematics algorithm INVKIN is obtained as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Inverse kinematics in the presence of fixed obstacles. The initial robot configuration and the desired end-effector configuration are shown in (a). A zoomed-in view of the desired end-effector configuration is shown in the bottom right subsquare in (a). The solution determined by our algorithm is shown in (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. (a) The packing of outer ball B(q c ; R + 1 2 m ) and (b) covering of X (shaded region) produced by EXP LORE 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE III SIMULATION</head><label>III</label><figDesc>RESULTS (AVERAGES) OVER A SAMPLE OF 100 RANDOM TESTS WITH E p max = 1.0 mm, N = 100, AND l = 10 cm</figDesc><table><row><cell>point-to-point problem from a user specified configuration</cell></row><row><cell>(one could use the home configuration of the robot),</cell></row><row><cell>i.e.,</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The term reachable unless explicitly clarified, may have different interpretations in kinematics and motion planning literatures. In kinematics, the term reachable embodies the notion of existence of a solution. For instance, "reachable workspace" is defined as the range of the forward kinematic map, f<ref type="bibr" target="#b44">[45]</ref>. Note that an end-effector configuration may lie in the reachable workspace, but may not be path-connected to another end-effector configuration (also in the reachable workspace) due to constraints such as joint limits, self-collisions and obstacles. In motion planning, the term reachable</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In motion planning problem, the initial and final configurations of the robot are specified and the aim is to find a collision-free path connecting the two<ref type="bibr" target="#b25">[26]</ref>. Note that the typical motion planning problem does not address the inverse kinematics problem, since the final robot configuration is assumed to be given. However, in some works, instead of specifying the final configuration, control points on the robot have been used to specify the final configuration(s)<ref type="bibr" target="#b1">[2]</ref>,<ref type="bibr" target="#b43">[44]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>A complete algorithm will find a solution if there exists one. See Appendix A for more details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>In fact, most approaches completely ignore self-collisions among various links of the manipulators, probably assuming joint limits suffice to avoid such self-collisions, which is simply not true.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Note that the specific algorithm (SEARCH) we use is motivated by ease of incorporating collision (self and with other static obstacles) checks; it is not essential for our approach. One could substitute it with other local algorithms without changing the essence of our approach. See Section IX-B for more on this.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>It is relatively straightforward to show that d is indeed a metric.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>In path planning context, X corresponds to C Afree .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>This packing corresponds to the following scenario. Let S be a ndimensional simplex of edge length 2. Imagine a sphere of radius 1 centered at each vertex of S. Roger's density is the ratio of the volume of spheres to that of S.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p><ref type="bibr" target="#b8">9</ref> This is also known as the Hausdorff metric.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper was recommended for publication by Associate Editor R. G. Simmons and Editor V. Lumelsky upon evaluation of the reviewers' comments. This work was supported in part by NSERC Research and CRD Grants and a grant from the Advanced Systems Institute, British Columbia.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Juan Manuel Ahuactzin received the B.S. degree in computer systems engineering from the Universidad de las Americas (UDLA), Puebla, Mexico, in 1989, and the M.S. and Ph.D. degrees in computer science from the Institut Polytechnique National de Grenoble (INPG), France, in 1991 and 1994, respectively.</p><p>From 1994 to 1995, he was a Postdoctoral Fellow with the Robotics Group, Simon Fraser University (SFU), Burnaby, B.C., Canada. He continues to collaborate with the SFU Robotics Lab. He is an Associate Professor in the Computer Systems Engineering Department, UDLA. In 1996, he was selected as a National Researcher in Mexico. His research interests include robotics, motion planning, computational geometry, and genetic algorithms. Kamal K. Gupta received the Ph.D. degree in electrical engineering from McGill University, Montreal, P.Q., Canada, in 1987.</p><p>Since then he has been a faculty member in the School of Engineering Science, Simon Fraser University, Burnaby, B.C., Canada. His research interests and contributions are in the geometric aspects of robotics and automation, in particular motion planning, manipulation and geometric reasoning, and 3-D vision for robotic tasks. He has also consulted for robotics and automation companies in these areas. He has held visiting scientist positions at INRIA, Rh√¥ne-Alpes, France, and at the Robotics Laboratory, Stanford University, Stanford, CA, from 1993 to 1994. He is a co-editor of Practical Motion Planning in Robotics: Current Approaches and Future Directions (New York: Wiley, 1999).</p><p>Dr. Gupta serves as a co-chair of the IEEE Robotics and Automation Society's Technical Committee on Motion and Path Planning.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Le Fil d&apos;Ariane. Une m√©thode de planification g√©n√©rale. Application √† la planification automatique des trajectoires</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Ahuactzin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Inst. Nat. Polytech. de Grenoble</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Robot motion planning: A distributed representation approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Barraquand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Latombe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="628" to="649" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A complete generalized solution to the inverse kinematics of robots</title>
		<author>
			<persName><forename type="first">B</forename><surname>Benhabib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goldenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fenton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Robot. Automat</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="14" to="20" />
			<date type="published" when="1985-02">Feb. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On the inverse kinematics of redundant manipulators</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wampler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="3" to="21" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Ariadne&apos;s clew algorithm: Global planning with local methods</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bessiere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Ahuactzin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/RSJ Conf. Intell. Robots Syst</title>
		<meeting>IEEE/RSJ Conf. Intell. Robots Syst</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On the inverse kinematics of redundant manipulators: Characterization of the self-motion manifolds</title>
		<author>
			<persName><forename type="first">J</forename><surname>Burdick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="264" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Sandros: A motion planner with performance proportional to task difficulty</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">K</forename><surname>Hwang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
		<title level="m">Sphere Packings, Lattices and Groups</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Introduction to Robotics</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Craig</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Croom</surname></persName>
		</author>
		<title level="m">Principles of Topology</title>
		<meeting><address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<publisher>Saunders College</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Inverse kinematic algorithms for redundant systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-J</forename><forename type="middle">E</forename><surname>Slotine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Sheridan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="43" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Issues in learning global properties of the robot kinematic mapping</title>
		<author>
			<persName><forename type="first">D</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kreutz-Delgado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1993">1993. 1993</date>
			<biblScope unit="page" from="205" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Real-time implementation of optimization scheme for seven-degree-of-freedom redundant manipulator</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Dubey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Euler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Babcock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="579" to="588" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">J</forename><surname>Dugundji</surname></persName>
		</author>
		<author>
			<persName><surname>Topology</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Boston</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1966">1966</date>
			<publisher>Allyn and Bacon</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Concepts, Algorithms, and Application</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Fishman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Monte</forename><surname>Carlo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Iterative inverse kinematics with manipulator configuration control</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">Z</forename><surname>Grudiƒá</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Lawrence</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="476" to="483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Joint trajectory generation for redundant robots in environments with obstacles</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Hsia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Robot. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="199" to="215" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fast collision avoidance for manipulator arms: A sequential search strategy</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Automat</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="522" to="532" />
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Motion planning for many degrees of freedom: Sequential search with backtracking</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Automat</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="897" to="906" />
			<date type="published" when="1995-12">Dec. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Practical global motion planning for many degrees of freedom: A novel approach within sequential framework</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Robot. Syst</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="118" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Motion planning for many degrees of freedom-random reflections at c-space obstacles</title>
		<author>
			<persName><forename type="first">T</forename><surname>Horsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Scwarz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Tolle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="3318" to="3323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Gross motion planning: A survey</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">K</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ahuja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="219" to="291" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Probabilistic roadmaps for path planning in high dimensional configuration space</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kavraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Svetska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Latombe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Overmars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Automat</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="566" to="580" />
			<date type="published" when="1996-08">Aug. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Object norms: A class of coordinate and metric independent norms for displacements</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kazerouinian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rastegar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Flexible Mechanisms, Dynamics and Analysis</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Kinzel</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ASME</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page">47</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Combined analyticalpseudoinverse kinematic solution for simple redundant manipulators and singularity avoidance</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Kirƒáanski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Petroviƒá</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="189" to="196" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Robot Motion Planning</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Latombe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Norwell, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A simple motion planning algorithm for general robot manipulators</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lozano-Perez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Automat</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="224" to="238" />
			<date type="published" when="1987-06">June 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Global path planning of redundant manipulators based on self-motion topology</title>
		<author>
			<persName><forename type="first">C</forename><surname>L√ºck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="372" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Obstacle avoidance for kinematically redundant manipulators in dynamically varying environments</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Maciejewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="109" to="117" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Real time inverse kinematics for general 6r manipulators</title>
		<author>
			<persName><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Canny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int. Conf. Robot. Automat</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="383" to="389" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A fast algorithm for inverse kinematic analysis of robot manipulators</title>
		<author>
			<persName><forename type="first">R</forename><surname>Manseur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Doty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="52" to="63" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">The Ariadne&apos;s clew algorithm</title>
		<author>
			<persName><forename type="first">E</forename><surname>Mazer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Ahuactzin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bessi√®re</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Grenoble, France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>LEIBNIZ Lab</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. 97-1</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Task-priority based redundancy control of robot manipulators</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Nakamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hanafusa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yoshikawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="3" to="15" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A solution of the inverse kinematics problem using the sliding mode</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">R</forename><surname>Navakoviƒá</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nemec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int. Conf. Robot. Automat</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="247" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A local solution with global characteristics for the joint torque optimization of redundant manipulators</title>
		<author>
			<persName><forename type="first">A</forename><surname>Nedungadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kazerouinian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Robot. Syst</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="632" to="654" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Random Numbers Generation and Quasi-Montecarlo Method</title>
		<author>
			<persName><forename type="first">H</forename><surname>Niederreiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Soc. Ind. Appl. Math</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<pubPlace>Philadelphia, PA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Distance metrics on the rigid-body motions with applications to mechanism design</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ASME J. Mech. Design</title>
		<imprint>
			<biblScope unit="volume">117</biblScope>
			<biblScope unit="page" from="48" to="54" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Inverse kinematics of redundant robots using genetic algorithms</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Khoogar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="271" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Manipulator inverse kinematics based on joint functions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Lawrence</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="669" to="675" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Montecarlo Optimization, Simulation and Sensitivity of Queuing Networks</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Y</forename><surname>Rubinstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Kinematic control of redundant manipulators: A tutorial</title>
		<author>
			<persName><forename type="first">B</forename><surname>Siciliano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Intell. Robot. Syst</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="201" to="212" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Local versus global torque optimization of redundant manipulators</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hollerbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="619" to="624" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A modular architecture for inverse robot kinematics</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Tourassis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Ang</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="555" to="568" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A formulation for path planning of manupulators in complex environments by using adjacent configurations</title>
		<author>
			<persName><forename type="first">F</forename><surname>Valero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">I</forename><surname>Cuadrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ceccarelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Robot</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="33" to="56" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Inverse kinematic functions for redundant manipulators</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Wampler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Robot. Automat</title>
		<meeting>IEEE Int. Conf. Robot. Automat</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="610" to="617" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
