<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Petri Net Plans A framework for collaboration and coordination in multi-robot systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010-07-31">31 July 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Ziparo</surname></persName>
							<email>ziparo@dis.uniroma1.it</email>
						</author>
						<author>
							<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
							<email>iocchi@dis.uniroma1.it</email>
						</author>
						<author>
							<persName><forename type="first">Pedro</forename><forename type="middle">U</forename><surname>Lima</surname></persName>
						</author>
						<author>
							<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
							<email>nardi@dis.uniroma1.it</email>
						</author>
						<author>
							<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Palamara</surname></persName>
							<email>palamara@dis.uniroma1.it</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica e Sistemistica &quot;Antonio Ruberti&quot; (DIS)</orgName>
								<orgName type="institution">Sapienza University of Rome</orgName>
								<address>
									<addrLine>Via Ariosto 25</addrLine>
									<postCode>00185</postCode>
									<settlement>Roma</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Institute for Systems and Robotics (ISR)</orgName>
								<orgName type="institution">Instituto Superior Técnico (IST)</orgName>
								<address>
									<settlement>Lisbon</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Petri Net Plans A framework for collaboration and coordination in multi-robot systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2010-07-31">31 July 2010</date>
						</imprint>
					</monogr>
					<idno type="MD5">11F037692617C55054B995330465305E</idno>
					<idno type="DOI">10.1007/s10458-010-9146-1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Programming the behavior of multi-robot systems is a challenging task which has a key role in developing effective systems in many application domains. In this paper, we present Petri Net Plans (PNPs), a language based on Petri Nets (PNs), which allows for intuitive and effective robot and multi-robot behavior design. PNPs are very expressive and support a rich set of features that are critical to develop robotic applications, including sensing, interrupts and concurrency. As a central feature, PNPs allow for a formal analysis of plans based on standard PN tools. Moreover, PNPs are suitable for modeling multi-robot systems and the developed behaviors can be executed in a distributed setting, while preserving the properties of the modeled system. PNPs have been deployed in several robotic platforms in different application domains. In this paper, we report three case studies, which address complex single robot plans, coordination and collaboration.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The design of complex behaviors in dynamic, partially observable and unpredictable environments is a crucial task for the development of effective robotic applications. This is particularly true when the task to accomplish requires coordination and collaboration among multiple robots, which must act as a team: teamwork can indeed boost performance.</p><p>Typically, complex multi-agent (or robot) behaviors, or more specifically plans, can be achieved through:</p><p>-Plan design: based on a representation formalism, an expert designs by hand the behaviors, which allow for the accomplishment of a given task; -Plan generation: based on a description of the goals and the capabilities of a system, a planner generates a solution, whose execution achieves the task.</p><p>The former approach can be used to write very rich plans which are limited solely by the expressiveness of the representational formalism used and by the capabilities of the designer. Nevertheless, it can be very hard to deal with such plans when they become large and complex in realistic applications. The latter approach is clearly more desirable, because it automates a task that requires considerable effort of specialized operators and is prone to errors. Nevertheless, the complexity of tasks for multi-robot systems, and in general for the physical world, limits the possibility of applying such approaches. Indeed, either they are not enough expressive to represent all the features of interest or they are too complex to compute solutions for realistic applications.</p><p>In this article, we present a representation and execution framework for high level multirobot plan design, called Petri Net Plans (PNPs) <ref type="bibr" target="#b69">[58,</ref><ref type="bibr" target="#b70">59]</ref>. The goal of PNPs is to support developers in designing and implementing complex high-level robot and multi-robot behaviors, by providing a rich modeling language that offers several key features (such as, modeling concurrency, distributed execution, formal analysis, etc. …) that are very often required in robotic systems, but that have not been previously integrated into state of the art frameworks.</p><p>The syntax and the semantics of PNPs is based on Petri Nets (PNs) <ref type="bibr" target="#b51">[40]</ref> and, indeed, PNPs are the first systematic and methodological approach for plan design based on PNs. PNPs inherit from PNs many of their features, which are very useful in robotic applications. An additional advantage of using PNs is that they have an appealing and intuitive graphical representation, that is (sometimes exponentially) more compact than state of the art behavior representation languages. Such graphical representation allows for both: at design time, understanding static properties of the net and, at runtime, visually monitoring the evolution of tokens in the net, and thus the actual robot behavior. The tools for task design, development and debug, based on "Petri Net languages" have been extensively used in distinct robotic applications by the many students involved in our projects. While a comprehensive and formal evaluation of how users work with the framework is out of the scope of this paper, our experience suggests that PNPs are more intuitive and easy to use as compared with competing approaches.</p><p>Despite the usability and intuitiveness of PNPs, several types of errors may frequently occur in plan design. Consequently, we identify some properties of plans that, when verified, prevent the designer from incurring into these errors. We show that verifying such properties can be reduced to standard PN analysis problems. These problems can then be solved using standard PN analysis tools, thus enabling for debugging tools to support plan design. The support on formal models is fundamental to ensure that plan formal specifications are satisfied, and represents a feature not often found in current robot task "models" and architectures.</p><p>It is worth noticing that, when using other formalisms, plan verification is typically based on empirical evaluation.</p><p>PNPs take inspiration from action languages (e.g., <ref type="bibr" target="#b56">[45]</ref>), and, thus, are explicitly defined as composition of actions. As any robotic system takes time to perform actions, we describe actions as non-instantaneous. This has a relevant impact on the language and allows for complex forms of execution control in terms of monitoring and failure recovery. Moreover, given that the environment is partially observable to robots, we model sensing actions, as a form of knowledge acquisition <ref type="bibr" target="#b21">[10,</ref><ref type="bibr" target="#b58">47]</ref>. Another relevant feature of many robots is that they can concurrently actuate several parts of their body. For example, a humanoid robot can use simultaneously, for different purposes, its arms, legs and head. To this end, PNPs include operators to handle concurrent actions.</p><p>Multi-robot systems require robots to coordinate their actions in order to perform complex tasks, which are not achievable by a single robot, and to avoid interference. To this end, we introduce coordination operators, which allow the designer to ensure synchronization constraints among actions of different robots. In a PNP, one can specify a global model of the multi-robot system, where actions of different robots can be synchronized using direct communication. However, in order to avoid a central coordinator agent, which would introduce a single point of failure and a bottleneck for communication in the system, we provide a mechanism to automatically decompose a multi-robot PNP into a set of single-robot PNPs, which can thus be executed in a distributed fashion. We show that the properties that hold for the original centralized model, are still valid in the decomposed model of distributed execution, if the robots have access to a reliable communication channel.</p><p>PNPs can also be used for the implementation of collaborative behaviors. In particular, we show that in order to model collaborative behaviors, coordination is not enough. Thus, we introduce a new operator, the joint committed action, which we use to model a general theory of teamwork, namely the Joint Intentions theory. As for coordination, we show that collaborative behaviors described through PNPs allow for distributed execution.</p><p>The proposed framework has been implemented and is available <ref type="foot" target="#foot_0">1</ref> both as a C + + library and as an Open-RDK <ref type="bibr">[2]</ref> module. PNPs have been tested on several robotic platforms (i.e., wheeled robots, quadruped robots AIBO and humanoid robots NAO) and in different domains (i.e., Search and Rescue <ref type="bibr">[3]</ref>, Soccer <ref type="bibr" target="#b44">[33,</ref><ref type="bibr" target="#b70">59]</ref>, Foraging <ref type="bibr" target="#b27">[16]</ref> and Manufacturing <ref type="bibr" target="#b37">[26]</ref>). A PNP implementation for the soccer domain obtained the Best Robotic Demo Award at AAMAS'08 <ref type="bibr" target="#b52">[41]</ref>. In this article, we present three case studies which show many of the relevant features of PNPs: a single robot task for search and rescue, complex coordination in a collaborative foraging problem and advanced collaboration using the Joint Intentions theory in a soccer domain. The case studies have been implemented on the AIBO robots and on a Pioneer wheeled platform.</p><p>In summary, the contributions of the proposed approach are manifold:</p><p>1. a methodological approach to Plan Design through PNs that, as a central feature, allows for automated plan verification; 2. a formal model for coordination and collaboration in multi-robot systems;</p><p>3. an open source implementation of a development environment.</p><p>The paper is organized as follows. After presenting some related work in the next section, we define the basics of PNPs in Sect. 3. Then, in Sect. <ref type="bibr">4</ref> we provide operational semantics in terms of an execution algorithm for PNPs. In Sect. 5 we show some advanced features of the language for coordination, which include operators for synchronizing actions of different robots and a distributed execution algorithm. Finally, in Sect. 6, we show how PNPs can be used to achieve collaboration. We conclude by showing some of the multi-robot systems we have implemented in Sect. 7 and by discussing the features of the proposed approach in Sect. 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>This section gives an overview of the main approaches that have been proposed in the past few years for the representation and execution of robotic behaviors, in order to provide the context in which PNPs have been developed. We identify three broad classes of approaches to plan design and high-level programming for intelligent robots: FSA-based approaches, BDI approaches and PN-based approaches. We conclude the section with a comparative discussion of the these approaches with respect to PNPs.</p><p>It is worth noticing that there are a number of approaches that do not fall in the aforementioned three categories. These approaches are mostly programming tools (frameworks) for robotics, with no underlying formal model or with a limited underlying formal model, that usually have ad-hoc semantics and do not support formal analysis, making it difficult to develop robust and effective behaviors. The resulting tools often take the form of frameworks for ordinary programming languages. For example, ESL <ref type="bibr" target="#b31">[20]</ref> is a language based on LISP that defines several constructs commonly used in robotics. In a similar way, the Task Description Language (TDL) <ref type="bibr" target="#b60">[49]</ref> extends C++ in order to include asynchronous constrained procedures, called Tasks. TDL programs have a hierarchical structure, called Task Tree, where each child of a given task is an asynchronous process and execution constraints among siblings are explicitly represented. The Reactive Action Packages (RAPs) <ref type="bibr" target="#b30">[19]</ref> are expressed in LISP-like syntax and describe concurrent tasks along with execution constrains. RAPs are an ad-hoc tool for execution of concurrent tasks in robotic applications that have some similarities with PNs. In ESL, TDL and RAP no analysis of the resulting behavior is possible and coding coherent behaviors requires a considerable modeling effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">FSA-based approaches</head><p>Many robot programming languages are based on Finite State Automata (FSA). FSA are either used explicitly, possibly supported by a graphical language, or they provide the underlying semantic model for the language. FSA-based approaches stem from the need to implement effective behaviors in real-time systems <ref type="bibr" target="#b31">[20]</ref>. Several frameworks have been implemented, proving their effectiveness in real world applications (e.g., <ref type="bibr" target="#b32">[21]</ref>). Although modeling behaviors based on FSAs is a very intuitive task, these approaches have been mostly limited to single-robot systems due to the lack of expressiveness in modeling concurrency. Notably, some methods for an automated FSA-based plan generation have also been developed (e.g. <ref type="bibr" target="#b45">[34]</ref>).</p><p>Colbert <ref type="bibr" target="#b42">[31]</ref> is a robot programming language that was developed as a component of the Saphira architecture <ref type="bibr" target="#b43">[32]</ref>. Colbert has a syntax which is a subset of ANSI C, while its semantic is based on FSA. In particular, states correspond to actions while edges are events associated to conditions. Moreover, Colbert allows some simple form of concurrency even though, in this case, the semantics are considerably different from standard FSA semantics and it is very hard to ensure coherence in the behaviors.</p><p>Xabsl <ref type="bibr" target="#b47">[36]</ref> is a more recent approach and is based on hierarchical finite state automata. Xabsl is bundled with a set of language specific tools, which allow for an efficient development of behaviors.</p><p>Although FSA-based approaches have been very successful in modeling many singlerobot systems, their expressive power limits their applicability to multi-robot systems. In general, more expressive formalisms are required in order to model the inherent concurrency of multi-robot systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Belief, Desire, Intention</head><p>The Belief, Desire, Intention framework (BDI) <ref type="bibr" target="#b55">[44]</ref> has been proposed as an alternative to FSA-based robot programming. In a BDI architecture, an agent selects behaviors to be executed (intentions), based on its goals (desires), and the current representation of the environment's state (beliefs). The procedural knowledge is typically encoded in a predefined library of plans (e.g. <ref type="bibr" target="#b33">[22]</ref>). In order to obtain the desired balance between reactivity and goaldirected behaviors, an agent can commit to the execution of plans and periodically reconsider them. One key advantage of BDI over FSA-based robot programming is that the designer needs not specify a predefined ordering of basic behaviors, allowing him or her to draw the executed plans from a potentially very large search space. On the other hand, no automated planners nor validation tools are available for BDI frameworks (though see <ref type="bibr" target="#b23">[12,</ref><ref type="bibr" target="#b61">50]</ref> for recent promising developments).</p><p>Several architectures inspired by the BDI framework have been proposed for modeling Multi-Agent Systems (MAS). Two notable such architectures that also model collaboration among multiple agents are STEAM <ref type="bibr" target="#b62">[51]</ref> and, more recently, BITE <ref type="bibr" target="#b39">[28]</ref>.</p><p>STEAM is implemented with a focus on collaborative behaviors, by relying on Cohen and Levesque's Joint Intentions Theory <ref type="bibr" target="#b17">[6]</ref>. Agents in a STEAM architecture distributedly monitor the execution of collaborative behaviors (which are organized in a partial hierarchy of joint intentions), possibly reorganizing the team. Cooperation is implemented in STEAM through a set of complex domain-independent rules, incorporated in the architecture to form sophisticated hierarchical team structures. STEAM was used in a number of applications (e.g. simulated military missions and virtual soccer players), but never on real robotic platforms.</p><p>The BITE architecture was specifically designed for robotic applications that involve collaboration and coordination. To manage teamwork, BITE maintains an organization hierarchy, a task/sub-task behavior graph, and a library of hierarchically linked social interaction behaviors. Although no explicit methodological guidance to teamwork design is provided, one of the strengths of the BITE architecture is the possibility to specify different types of interaction templates (e.g. for synchronization and task allocation), which can be reused to automate individual robots' task selection in different scenarios. BITE is focused on the automation of teamwork, while the design of individual behaviors is not extensively addressed. As with other systems based on BDI, BITE does not provide formal validation tools to verify the consistency of the designed behaviors.</p><p>The general BDI approach is orthogonal to PNPs, as PNPs can be used as a representation formalism for intentions. In fact, in Sect. 6.2, we show an implementation of a joint action, following the guidelines of the Joint Intentions Theory used in STEAM. Moreover, PNPs have an organization hierarchy (plans/sub-plans) as in BITE, but are not limited only to model teamwork. Finally, the use of PNPs allows for exploiting standard validation tools based on PNs to verify the consistency of the designed behaviors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">PN-based approaches</head><p>A solution to robot programming that recently gained interest in the scientific community is the modeling of robotic behaviors through PNs. In particular, there has been a considerable effort in modeling MAS through PNs <ref type="bibr" target="#b28">[17]</ref>, given their capability of representing concurrent systems and shared resources. PN-based systems offer two main advantages with respect to FSA <ref type="bibr" target="#b51">[40]</ref>: PN languages (languages marked by PNs) are a super-set of regular languages (languages marked by FSA), due to memory and concurrency characteristics. Therefore, the set of modeled roles and behaviors is potentially richer when using PNs; secondly, PNs allow for automatic analysis and verification of formal properties on the performance of the modeled systems. Available tools such as PIPE <ref type="bibr">[1]</ref> or TimeNET <ref type="bibr" target="#b68">[57]</ref> check PN properties, both through simulation and closed-form equivalent Markov Chain analysis. <ref type="foot" target="#foot_1">2</ref>Therefore, PNs have been widely used in the literature to model Discrete Event Systems (DES), namely manufacturing systems <ref type="bibr" target="#b64">[53]</ref>. PN-based models of robot tasks started with the pioneer work of Wang et al. <ref type="bibr" target="#b65">[54]</ref>, where they were used to implement the Coordination Level of Saridis' 3-level hierarchy for intelligent machines, including reinforcement learning algorithms. In the past few years, approaches to plan generation and representation based on PNs, have gained increasing interest, addressing both multi-agent (MAS) and multi-robot systems (MRS).</p><p>Action representation using PNs in MAS is proposed, for example, in <ref type="bibr">[4]</ref>. The model is limited to purely reactive agents: actions are instantaneous, as they are represented by PN transitions, and the places of the PN model represent the environmental state of the agent. In a MAS framework, issues that are typical of embodied agents such as non-instantaneous actions or uncertain action effects are not specifically addressed. Interactions among agents have also been modeled by PNs in the literature, with a special focus on the formal modeling of conversations using colored PNs <ref type="bibr" target="#b19">[8]</ref>. A substantial comparative review of the different approaches, including a colored PN model of multi-agent conversations, where places explicitly represent joint interaction states and messages, can be found in <ref type="bibr" target="#b36">[25]</ref>. Poutakidis et al. <ref type="bibr" target="#b54">[43]</ref> introduced interaction protocols, specified using Agents UML and translated to PNs, to debug agent interaction. The debugger uses the PNs to monitor conversations and to detect when protocols are not correctly followed by the agents. While these works provide formal scalable models of interaction, they do not model actions explicitly, and they are not concerned with commitment issues, which are relevant in applications where the interaction among agents/robots is cooperative.</p><p>A first group of works using PNs for designing robotic systems develops ad-hoc models for specific applications rather than providing a formal language for robot programming. For example, in <ref type="bibr" target="#b59">[48]</ref>, PNs are used to model a multi-robot coordination algorithm which is based on an auction mechanism to perform environment exploration. Similarly, <ref type="bibr" target="#b67">[56]</ref> shows an agent based extension of Fuzzy Timed Object-Oriented PNs (proposed in <ref type="bibr" target="#b49">[38]</ref>) for the design of collaborative multi-robot systems for a specific industrial application. Another example is <ref type="bibr" target="#b46">[35]</ref>, where the authors report the use of distributed agent-oriented PNs for the modeling of a Multi-Robot System for playing soccer. These works focus mainly on the PN that controls the robotic system and on its execution, providing no systematic method to program such a controller using PNs and/or for the analysis of the whole system properties.</p><p>A second kind of PN-based approaches models the robotic system, representing plans as PNs so as to analyze their properties and/or to synthesize optimal plans from conditional ones. In <ref type="bibr" target="#b48">[37]</ref>, the authors propose an approach for modeling single-robot systems. In this case, users define several possible plans to carry out a task. Then, a reinforcement learning algorithm is used to select an optimal solution. This approach also exploits formal analysis of the PN models allowing for qualitative evaluation (i.e. stability, controllability and possibility of error recovery). This single-robot approach has been tested in two real world applications regarding manipulators and mobile robots. A follow-up work is presented in <ref type="bibr" target="#b20">[9]</ref>, but in this case the PN model explicitly includes a representation of the environment. Nevertheless, none of these works provide a formal PN-based language for plan description and composition. Furthermore, though they focus on modeling, no models of cooperation or coordination are proposed.</p><p>A third category of works addresses specification and execution monitoring of plans for multi-robot systems using PNs. The compilation of plans for multiple robots into PNs for analysis, execution, and monitoring is proposed by King et al. <ref type="bibr" target="#b40">[29]</ref>. In this work, plans for each single robot are generated either by using a graphical interface or by using some automated planning method. The operators that are used for the PN representation of the plans are inspired by the STRIPS <ref type="bibr" target="#b29">[18]</ref> planning system. Supervisory control techniques are applied to the PN controller in order to identify possible conflicts that may arise due to the presence of shared resources among the multiple robots. To deal with unforeseen events, re-planning is used at run-time, which severely limits the applicability of this approach to real-rime systems in dynamic environments. Novel supervisory control techniques are also introduced and applied to simulated and real sensor networks, thereby mixing static and mobile sensors in <ref type="bibr" target="#b35">[24]</ref>. Another formal framework for robotic collaboration based on an extension to PNs, known as workflow nets, is introduced by Kotb et al. <ref type="bibr" target="#b41">[30]</ref> to establish a protocol among mobile agents/robots based on the task coverage they maintain. PNs are used to ensure the soundness of the framework and to quantify task performance and determine goal state reachability. However, none of these works provides a formal PN-based language for plan description and composition.</p><p>Despite the large body of work on modeling robot and multi-robot behaviors through PNs, there currently is not a standard representation formalism for representing multi-robot systems based on PNs. Indeed, most approaches provide ad hoc solutions to specific problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Comparison with PNPs</head><p>Our goal is to provide a systematic approach to robot behavior programming and verification, which addresses cooperation in multi-robot teams supported by a well-defined plan specification language. Furthermore, the design methodology we present can exploit existing techniques and tools for plan analysis. To this end, we define PNPs (first introduced in <ref type="bibr" target="#b69">[58]</ref>) as a subset of PNs, by relying on modeling primitives of action languages inspired by Situation Calculus <ref type="bibr" target="#b50">[39]</ref>, such as ConGolog <ref type="bibr" target="#b22">[11]</ref>, and specific structures to model cooperation among multiple robots, such as Joint Intentions Theory <ref type="bibr" target="#b17">[6]</ref>. The resulting language is more expressive than most approaches in the literature, allowing for complex forms of sensing, loops, interrupts, concurrency, coordination and cooperation.</p><p>It is important to notice that PNPs are very expressive, but also allow for a compact representation of the behavior of a robot. In comparison with other well-known models for transition systems based on FSA, PNs (and thus PNPs) are in general exponentially more compact. For example, a finite structure (but unbounded) PN can represent even an infinite state automaton. Specifically, we stress that PNPs are more powerful when compared to FSA in modeling concurrency. In fact, in FSA-based representations each state of the system is associated with a node of the automaton, and the execution of concurrent actions requires to define many states according to all the possible combinations of events occurring during the parallel execution. The number of FSA states needed to represent the concurrent execution of different sequences of actions is thus exponential in the number of such sequences, while in PNPs the number of places and transitions is proportional to the number of these sequences.</p><p>BDI architectures try to address the issue of reducing the dimensionality of the space of plans by avoiding to commit to assigning a specific ordering in behaviors. This is indeed a very powerful approach in many application domains, but has the drawback that it is very hard to design plans, when the domain requires complex behaviors where atomic actions are highly coupled and the degree of optimality of the solution is a key factor.</p><p>PNs, like as FSA, implicitly commit to assigning a specific ordering of behaviors. Indeed, this is claimed as an advantage, because this way one reduces the dimensionality of the space of plans where the optimal plan must be searched. This stems from the claim that one can design simple FSA or PNs for components of the involved behaviors and their interaction with the world: the actual behavior results from the composition of those behaviors, filtering out combinations that can never occur and/or that the designer knows right from the start how to avoid. In fact, the initial components force some behavior sequences based on the designer expertise, which leaves the possibility of other combinations so as to enable different alternative plans for the same task (e.g., through conflicts in PNs). Clearly, quality and complexity of the plans comes at a cost: the modeling effort required for designing behaviors based on PNs.</p><p>In order to address the complexity of plan design, and opposed to state of the art PN-based approaches, PNPs provide a clear systematic methodology for modeling complex single robot and collaborative behaviors through PNs. PNPs are very intuitive and require a small modeling effort, due to the explicit characterization of atomic structures, which are explicitly interpreted as actions and operators to combine actions. PNPs support plan design through the use of PN analysis methods. These methods can be used to verify important properties of the plans which are required for a robust execution. Moreover, PNPs allow for a distributed execution of plans which has the notable characteristic of preserving the properties verified for the plans at design time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Petri Net Plans syntax</head><p>Petri Net Plans allow for specifying plans describing complex behaviors for mobile robots. These plans are defined by combining different kinds of actions (ordinary actions and sensing actions) using control operators. Initially we ignore multi-robot operators that are used to achieve coordination and collaboration. Thus, we can consider the multi-robot system, as composed by robots which execute their own PNP independently from each other. Nevertheless, as we will see in Sects. 5 and 6, PNPs naturally model multi-robot systems when enriched with multi-robot operators.</p><p>In the following, we first provide an interpretation of PNs for behavior execution, namely PNP structures. Then, we define the PNP Language (PNPL). PNPL is a high-level robot programming language that builds upon PNP structures and that provides a methodology for building PNP structures. Finally, we define PNPs as elements of PNPL, that must obey to runtime constraints. These constraints can be verified based on standard PN analysis tools. More details on the (operational)semantics of PNPs are given in Sect. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">PNP structures</head><p>PNP structures are PNs with a domain specific interpretation aimed at modeling robotic behaviors. In particular, they are PNs that have at most one token per place and edges of weight one.</p><p>Definition 1 (PNP structure) A PNP structure is a PN pn = P, T, F, W, M 0 and a goal marking G which specifies the set of desired termination states. We define a PNP structure as the following 6-tuple:</p><formula xml:id="formula_0">P, T, F, W, M 0 , G -P = {p 1 , p 2 , . . . , p m } is a finite set of places. -T = {t 1 , t 2 , . . . , t n } is a finite set of transitions. -F ⊆ (P × T ) ∪ (T × P) is a set of edges. -W : F → {1} is a weight function for edges. In PNPs w( f s , f d ) = 1 for each pair f s , f d ∈ F. -M 0 : P → {0, 1}</formula><p>is the initial marking, denoting the initial state of the structure.</p><p>-P ∪ T = ∅ and P ∩ T = ∅ -G : P → {0, 1} is the goal marking.</p><p>PNP structures can be considered as PNs, with a domain specific interpretation and an extended semantics. In a PNP, places have different interpretations, thus they are partitioned into four classes: P = P I ∪ P O ∪ P E ∪ P C , where:</p><p>1. P I is the set of input places, which model initial configurations of the PNP; 2. P O is the set of output places, which model final configurations of the PNP; 3. P E is the set of execution places, which model the execution state of actions in the PNP; 4. P C is the set of connector places, which are used to connect different PNPs.</p><p>Also transitions are partitioned in three subsets T = T S ∪ T T ∪ T C , where:</p><p>1. T S is the set of start transitions, which model the beginning of an action/ behavior; 2. T T is the set of termination transitions, which model the termination of an action/behavior; 3. T C is the set of control transitions, which are part of the definition of an operator.</p><p>A PNP structure models the execution of actions by using specific places, that represent the execution states of the related behaviors. In particular, each action has an execution place e ∈ P E and M(e) determines whether the behavior is active or not. Thus, the set of execution places of a PNP structure (i.e., P E ) models the execution state of the system and its temporal evolution characterizes the system dynamics.</p><p>In the remainder of this section, we describe PNP structures ignoring their markings. Moreover, we will omit W , since it is constantly set to 1. Therefore, we consider a generic PNP structure as the triple P, T, F and, for the sake of readability, we present the topological structure of nets (i.e., F) through the graphical representation of PNs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">PNP Language</head><p>PNP Language defines a subset of PNP structures aimed at providing a methodology for designing PNP structures. We define the PNPL in terms of PNP structures, which can be build upon atomic actions and combined through operators. In the following, we will refer to PNP structures, simply as structures. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(b) (a)</head><p>Fig. <ref type="figure">1</ref> Actions: a ordinary action and bsensing action</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Actions</head><p>Actions represent primitive behaviors of robots and are the atomic concept upon which we build complex PNP structures. Actions are characterized by having T C = ∅. There are two types of actions: (1) ordinary action and (2) sensing action.</p><p>Ordinary-action. This elementary structure models a deterministic action. It explicitly represents the action as non-instantaneous, by defining its start event t s , execution state p e , and termination event t e . An ordinary action is the structure shown in Fig. <ref type="figure">1a</ref>, where:</p><formula xml:id="formula_1">-P I = {p i }, P E = {p e } and P O = {p o }, -T S = {t s } and T T = {t e }.</formula><p>Sensing-action. Sensing actions are a special kind of non-deterministic actions, where the actual outcome of the action depends on some property which may be known only at execution time. A sensing action is the structure shown in Fig. <ref type="figure">1b</ref>, where:</p><formula xml:id="formula_2">-P I = {p i }, P E = {p e }, P O = {p o t , p o f }, -T S = {t s } and T T = {t e t , t e f }.</formula><p>and where t e t and t e f are the transitions ending the action, when the sensed property is true, and when it is false, respectively. Analogously, the places p o t and p o f terminate the action, when the sensed property is true and when it is false. Notice that, it is possible to extend sensing actions in order to have more than two mutually exclusive outcomes by augmenting the number of termination transitions and output places. We also consider an instantaneous variant of sensing actions (i.e., without t s and p e ), which we call evaluation action. Evaluation actions are used to query the knowledge of the robot, and do not require to act in the real world.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Operators</head><p>PNP structures are modular, since they allow for combining multiple structures in order to build more complex ones. Two structures can be combined by merging two places, one for each structure. This allows for sequencing behaviors and constructing loop structures. Moreover, it is possible to monitor the execution state of structures by using interrupt operators, that tie the execution places of an action with the input places of another structure, through a transition (interrupt) that suspends the execution of the current action and triggers Therefore, in order to create complex PNPs, four kinds of operators are defined: sequence, interrupt, fork and join. Operators are PNs used as control structures, which do not refer to specific behaviors. Operators are thus characterized by having P E = ∅, T S = ∅, and T T = ∅. Sequence operator. The sequence operator combines two structures by merging two of their places. For example, an output place of a first structure can be merged with an input place of a second one, to obtain a chain of the two structures. The sequence of a motion behavior for approaching a ball (i.e., gotoball) and a kicking behavior are shown in Fig. <ref type="figure">2</ref>. The dashed circle shows the result of merging the output place of the gotoball action and the input place of the kick action. Formally, given two PNP structures</p><formula xml:id="formula_3">P N 1 = P 1 , T 1 , F 1 and P N 2 = P 2 , T 2 , F 2 , a non-execution place p ∈ P I 1 ∪ P O 1 ∪ P C</formula><p>1 and an output place o ∈ P O 2 , the sequence of P N 1 and P N 2 obtained by merging p with o is a PNP structure P N = P, T, F , with</p><formula xml:id="formula_4">P = P 1 ∪ P 2 -{o}, T = T 1 ∪ T 2 , F = F 1 ∪ F 2 -{ t e , o } ∪ t e ∈ • o { t e , p }, where • o is the set of input transitions of o. Moreover, P I = P I 1 ∪ P I 2 -{p}, P O = P O 1 ∪ P O 2 -{o}, P E = P E 1 ∪ P E 2 , P C = P C 1 ∪ P C 2 ∪ {p}, if p ∈ P I 1 , while P C = P C 1 ∪ P C 2 otherwise</formula><p>. This operator can be applied to two places of the same structure for creating loops. Thus, when P N 2 = P N 1 , we call this operator loop-sequence.</p><p>Interrupt operator. The interrupt operator, shown in Fig. <ref type="figure">3a</ref>, is a very powerful tool for handling action failures. In fact, it can interrupt actions upon failure events and activate recovery procedures. In the example shown in Fig. <ref type="figure">4</ref>, the gotoball action is monitored by an interrupt triggered when the ball is stolen by an opponent. As a recovery procedure, the robot starts a defensive behavior. The dashed circles show the result of merging the execution place of the gotoball action with the interrupt and the result of merging of the interrupt and the input place of the defend action. Interrupts can also be used to interrupt multiple actions simultaneously (see Fig. <ref type="figure" target="#fig_1">6b</ref> for an example). Formally, given two PNP structures P N 1 = P 1 , T 1 , F 1 and P N 2 = P 2 , T 2 , F 2 , a set of execution places {e i } such that e i ∈ P E  1 and a non-execution place p ∈ P I 2 ∪ P O 2 ∪ P C 2 , the interrupt of P N 1 through P N 2 is a PNP structure P N = P, T, F , with <ref type="figure">4</ref> The interrupt of an action and its recovery procedure Fig. <ref type="figure">5</ref> The fork and the subsequent join of two actions</p><formula xml:id="formula_5">P = P 1 ∪ P 2 , T = T 1 ∪ T 2 ∪ {t int }, Fig.</formula><formula xml:id="formula_6">F = F 1 ∪ F 2 ∪ i { e i , t int } ∪ { t int , p },</formula><p>where t int is the transition associated to the interrupt condition. Moreover,</p><formula xml:id="formula_7">P I = P I 1 ∪ P I 2 -{p}, P O = P O 1 ∪ P O 2 , P E = P E 1 ∪ P E 2 , P C = P C 1 ∪ P C 2 ∪ {p}, if p ∈ P I 1 , while P C = P C 1 ∪ P C 2 otherwise. Finally, T C = T C 1 ∪{t int }.</formula><p>Interrupt is often used to go back to a previous part of the plan in order to re-try the execution of a portion of it. In these cases, P 2 = P 1 and we call this operator loop-interrupt.</p><p>Many robotic systems are required to handle concurrency due to: (1) the possibility of actuating simultaneously, and independently, several parts of the body and (2) the possibility of controlling multiple robots. In the following, we deal with the first issue, while we provide a discussion of multi-robot distributed execution, along with the definition of appropriate operators, in Sects. 5 and 6. In particular, here we present fork and join operators for dealing with multiple actuators.</p><p>Fork operator. Each token in a structure can be thought as a thread of execution. The fork operator generates multiple threads from a single thread of execution. Figure <ref type="figure">3b</ref> shows a fork structure producing two threads of execution. The fork operator is characterized by T C = {t f }, P I = {p i } and P O = {p o1 , p o2 }. Notice that the operator can be extended to generate more threads by adding new output places. Formally, the fork operator of two PNP structures P 1 and P 2 is the sequence of a fork structure with P 1 , through p o1 , and P 2 , through p o2 . The left side of Fig. <ref type="figure">5</ref> shows the fork of the actions gotoBall and track Ball. The dashed circles show the result of merging the output places of the fork operator with the input places of the actions.</p><p>Join operator. The join operator allows the synchronization of multiple threads of execution. This operator consumes multiple threads of execution simultaneously, and generates a single synchronized thread. The join structure is shown in Fig. <ref type="figure">3c</ref>, for the case of two threads. As in the previous case, the operator can be generalized to synchronize more threads by adding new input places. The join operator is characterized by T C = {t j }, P I = {p i1 , p i2 } and P O = {p o }. Formally, the join operator of two PNP structures P 1 and P 2 is the sequence of P 1 , through p i1 , and of P 2 , through p i2 , with the join structure. The right side of Fig. <ref type="figure">5</ref> shows the join of the actions gotoBall and track Ball. The dashed circles show the result of merging the output places of the actions with the input places of the join operator.</p><p>Notice that the fork and join operators allows for duplicating tokens, thus enabling concurrent execution of actions. Indeed, in the example before, when the execution places of both the actions gotoBall and track Ball are marked, the actions are actually executed in parallel. This mechanism is not limited to concurrent execution of two actions, but it can be used to model concurrent execution of complex behaviors. By using a different token for each execution thread, it is possible to model in a compact way all the possible combinations of event occurring during such a parallel execution. For example, the parallel execution of n sequences of actions of length k, is represented in a PNP with O(k n) places and transitions, while it would require for example O(k n ) states if using a FSA-based representation.</p><p>The PNPL describes the subset of PNP structures inductively defined as the closure of actions, under the sequence, interrupt, fork and join operators. In particular, the PNPL is the set of PNP structures described as follows.</p><p>Definition 2 (PNP Language) A PNP structure s is in PNPL (i.e., s ∈ PNPL) if and only if there exist s 1 ∈ PNPL and s 2 ∈ PNPL, such that at least one of the following assertions hold:</p><p>-s is an ordinary or a sensing action; -s is the sequence of s 1 and s 2 ; -s is the interrupt of s 1 and s 2 ; -s is the fork of s 1 and s 2 ; -s is the join of s 1 and s 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">PNP definition</head><p>In order to define behaviors that are actually executable, PNPs must fulfill some additional requirements on their behavior at runtime.</p><p>Tokens of PNPs are defined as execution threads, which activate the execution of atomic behaviors, represented by actions. A first important property is to enforce that the number of execution threads is bounded, in the sense that for any possible execution state there is no more than a token in each place. If this is not the case, it could be that multiple execution threads control the same atomic action. This is an undesirable situation because the semantics of PNPs assumes that each action is an atomic behavior, thus controlled by a single thread of execution. Nevertheless, there is no guarantee that any PNP respects this constraint during execution. Definition 3 A PNP structure P, T, F, W, M 0 , G is safe if any reachable marking M satisfies:</p><formula xml:id="formula_8">∀ p i ∈ P M( p) ≤ 1 that is, the net is 1-bounded.</formula><p>In PNs, this property is called 1-boundedness, and can be automatically verified through standard analysis techniques (e.g., coverability tree).</p><p>Another common requirement is that any transition defined in a PNP is not dead, in the sense that there exists a sequence of markings from M 0 such that the transition is fired at least once. Clearly, if there exists a transition which can never be fired, there is something wrong in the plan, e.g., because there is a dead-lock in the net. Thus, we want a minimal PNP, in the sense that each transition in the net is necessary and, thus, it can be fired at least once in some sequence of markings. This property corresponds to L1-liveness in PNs.</p><formula xml:id="formula_9">Definition 4 A PNP structure P, T, F, W, M 0 , G is minimal if it is L1-live.</formula><p>In PNs, this property (L-liveness) can be automatically verified through standard analysis techniques (i.e., liveness analysis).</p><p>Finally, notice that, as a structural difference from PNs, PNPs have a set of goal markings which describe the success of the plan. In this case, it makes sense to execute a plan if the goal is reachable from any state. In PNs, such goal state is called a home state. If the goal state is not a home state, the plan execution could prescribe useless actions or get stuck in a dead-lock. Definition 5 A PNP structure P, T, F, W, M 0 , G is effective, if the goal marking is a home state.</p><p>In PNs, the property that the goal state is a home state can be automatically verified through standard analysis techniques (i.e., reachability analysis).</p><p>Based on the previous considerations, we constrain PNPs to be safe, minimal and effective.</p><p>Definition 6 (Petri Net Plan) A Petri Net Plan (PNP) P is a PNP structure such that P ∈ PNPL and such that:</p><p>-P is safe (Definition 3) -P is minimal (Definition 4) -P is effective (Definition 5)</p><p>PNPs, as defined above, are actually executable by the execution algorithm described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Sub-plans</head><p>In the design of a PNP, sub-plans can be used for modularity and readability. A sub-plan is represented as an ordinary action, but it refers to a structure rather than to a primitive behavior. A plan execution module, running on the robot, takes care of dynamically loading sub-plans in case a super-plan invokes its execution. In particular, whenever a start transition of a sub-plan is fired, the marking of the sub-plan is set to the initial one. The sub-plan will then be executed, possibly concurrently with other primitive behaviors or sub-plans, until it reaches its goal marking or a condition labeling its ending transition is met. Moreover, sub-plans allow for a more powerful use of interrupts, which can be used to inhibit a whole complex behavior (i.e., a sub-plan) at once.</p><p>A complete discussion of PNPs with sub-plans is outside of the scope of this paper. Nevertheless, the discussion which follows can be generalized in many cases to PNPs with sub-plans. In the simplest case where sub-plans are used as macros, a PNP with sub-plans can be transformed to a PNP without sub-plans by recursively unfolding sub-plans. In the following, we discuss only PNPs without sub-plans.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Robotic soccer example</head><p>Consider a soccer robot, which must find a ball in a soccer field, reach it and then shoot. In this simple example we assume that, initially, the ball is not far away from the robot. The PNP in Fig. <ref type="figure" target="#fig_1">6a</ref> shows a possible PNP for this behavior. The robot starts to seek for the ball using a sensing action. Notice that a branch of the sensing action, is closed in a loop. Thus, the robot will continue to seek for the ball until it finds it. Then, the PNP has a fork operator, in order to: (1) approach the ball by actuating the legs of the robot and (2) track the ball with the head. Both actions are monitored by interrupt operators. In one case, if the tracking behavior looses visual contact with the ball, it will rollback to the seek behavior. In the other case, if someone moves the ball far away from the robot, it will rush to get again close to it. Finally, once the robot has reached the ball, the two actions join, and then the robot shoots the ball towards the opponent goal.</p><p>The analysis of such plan brings about some issues. First, the net is not safe. If the robot sees the ball, but this is far away, it will rush and correctly continue to track the ball. Nevertheless, once it is closer to the ball, the approach ball and the track ball behaviors will both receive an execution token, thus resulting in two tokens in the trackball behavior. Moreover, the PNP is also not minimal. In particular, the join transition can never be fired because it has an input place which is a source, and has no tokens in the initial marking. In this specific case, this also means that the PNP is not effective, because the goal marking can never be reached. These issues can all be detected with PN analysis tools. A valid PNP for this behavior is shown in Fig. <ref type="figure" target="#fig_1">6b</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Petri Net Plans execution</head><p>The operational semantics of PNPs, as for any PN, is defined by the firing rule. The firing rule describes the dynamics of the system based on events, which are generally model dependent. That is, events, specific to the model at hand, determine the actual firing of enabled transitions. The main difference with respect to PNs, is in the way PNPs interpret events and transitions: we can distinguish among controllable and non-controllable transitions, depending on whether the controller (i.e., executor) of the plan can control or not the related events. Non-controllable transitions usually depend on external events, while controllable ones depend on control strategies.</p><p>The only controllable transitions in PNPs are the ones which correspond to action starts. In this paper, we assume that plans do not have non-deterministic choices for controllable transitions. In this case, we can adopt a very simple control strategy, which states that all the controllable transitions, when enabled, must fire. Nevertheless, the proposed approach is applicable also if an appropriate control strategy is adopted when plans contain nondeterministic choices (e.g., GOLOG like).</p><p>In PNPs, non-controllable transitions are those which depend on observable properties of the environment. For example, a robot could fire a transition (e.g., interrupting a gotoball behavior), if it looses visual contact with the ball. In order to specify external events for non-controllable transitions, we define a labeling mechanism. In particular, all non-controllable transitions may be labeled with conditions to be verified in order for the related event to occur. A condition φ on the transition t is denoted with t.φ. If no condition is specified for a non-controllable transition, we will consider it to be T rue. We assume that the actual knowledge of a robot is accessible for the executor through a knowledge base kb. During the execution of a plan, we determine whether a given external event occurs by querying its local knowledge base kb. That is, an enabled transition t fires if kb | t.φ. During the execution of a PNP the knowledge base of the robot could change, due to the acquisition of new knowledge. In particular, we characterize the evolution of a PNP through a sequence of Definition 7 (Evolution) An Evolution of a PNP P = P, T, F, W, M 0 , G is a temporally annotated sequence of pairs ( M 0 , kb 0 , . . . , M n , kb n ). In particular, each M i , kb i represents a marking M i obtained, given a knowledge base kb i , at time τ i .</p><p>An Admissible Evolution of a PNP P is a sequence of markings, which can be obtained by evolving P from the initial marking, according to the semantics of events in PNPs. Definition 8 (Admissible Evolution) An Admissible Evolution of a PNP P = P, T, F, W, M 0 , G is a an evolution ( M 0 , kb 0 , . . . , M n , kb n ), where M 0 is the initial marking, ∀ i&lt;n M i ∈ G and such that:</p><formula xml:id="formula_10">∀ i∈{0..n-1} ∃ t∈T | enabled(t, M i ) ∧ f ire(M i , t) = M i+1 ∧ kb i+1 | t.φ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Abstract robot architecture</head><p>For the sake of clarity, we describe the execution algorithm for PNPs based on an abstract robot architecture shown in Fig. <ref type="figure" target="#fig_2">7</ref>. Nevertheless, the use of PNPs is not restricted to this particular type of architecture. Specifically, we define a two layer architecture:</p><p>-Symbolic layer: composed by a PNP library, a knowledge base and a PNP executor.</p><p>-Numeric layer: composed by data fusion modules and low level robotic behaviors. Symbolic layer. The symbolic layer consists of the PNP executor, which implements the PNP execution algorithm, and the Knowledge Base, which maintains the current information on the environment. The evolution of the plan must be controlled according to the robot's actual knowledge (i.e., according to its epistemic state of knowledge), since we can not assume that the robot has complete knowledge about all the properties of the environment. The Knowledge Base can be implemented in any formalism: for example, in our implementation, we use a simple conjunction of propositions. Analogously, queries can be represented as terms or formulas in any formalism consistent with the knowledge base. For the purposes of our plan execution method, we only require that the robot is able to evaluate queries over the current model of the world, i.e., to compute kb | t.φ. Numeric layer. In order to effectively interpret noisy and unreliable sensor data, we assume that our robot can use standard numeric approaches for data fusion <ref type="bibr" target="#b63">[52]</ref>, such as localization, mapping, tracking, etc. Notice that this numerical information must be anchored to the symbols in the knowledge base <ref type="bibr" target="#b18">[7]</ref>. In order to effectively control the behavior of the robot, we assume the availability of a set of implemented actions A = {a 1 , . . . , a k }. According to the specification on PNPs, each action considered here is an abstraction for the implementation of a specific behavior that the robots can execute. PNPs allow for both threaded and interleaved concurrency. In the threaded case, each action is executed in a separate thread with respect to other actions. This means that after an action is started, it will remain active until either end or interrupt is invoked. In the interleaved case, a unique thread is used both for the executor and all the actions. Roughly, the idea is that each action implements an executeStep() method, which executes a single step of the action. The PNP executor then invokes at each cycle such methods for all actions which have a token in their execution place. Both execution models can be used for executing PNPs. For simplicity, in this paper we refer to the case of threaded execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">PNP execution algorithm</head><p>Algorithm 1 is the execution algorithm for PNPs. As previously described, it relies on a Knowledge Base kb for evaluating events related to non-controllable transitions and on a set of implemented actions, which can be controlled through the start (), end() and interrupt () procedures. The main procedure execute takes as input a PNP P, T, F, W, M 0 , G and evolves it producing the control commands for the basic behaviors (which are associated to the firing of transitions). This process generates a sequence of transitions {M 0 , . . . , M n } that, possibly, evolve the system from the initial marking M 0 to a goal marking M n ∈ G.</p><p>In particular, at each step, Algorithm 1 checks (line 4) if each transition t ∈ T is enabled (enabled(t, Current Marking)) and if the related event occurs. If these two conditions are satisfied, the procedures for action control are handled within the sub-procedure handleT ransition (line 5) and the transition t is fired (line 6) resulting in a new marking. handleT ransition takes care of appropriately activating, interrupting or deactivating the related action. The details of how this is done depend on the actual implementation of the system.</p><p>The algorithm correctly executes a PNP, as shown by the following theorem.</p><p>Theorem 1 (Correctness) Algorithm 1 correctly executes any PNP P, i.e.:</p><p>-any computed evolution ( M 0 , kb 0 , . . . , M n , kb n ) of P is an admissible evolution -the behaviors of a robot are started, interrupted or ended, when the start, the end and interrupt transitions of the corresponding actions are fired; Proof In order to prove that Algorithm 1 correctly executes a PNP we must show that:</p><p>1. any evolution is admissible 2. behaviors are controlled according to the semantics of PNPs.</p><p>To prove that any evolution is admissible, we need to show that evolutions obey the firing rule (i.e. enabled(t, M i ) ∧ f ire(M i , t) = M i+1 ), and that the conditions labeling transitions are correctly evaluated (kb i+1 | t.φ). The former requirement is explicitly satisfied by lines 4 and line 6, while the latter by line 4.</p><p>The second part of the proof is verified by a direct analysis of the procedure handleT ransition(•).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Coordination using PNPs</head><p>PNPs can be effectively used also to model multi-robot behaviors, allowing for dealing with the typical issues encountered when designing a multi-robot systems, in particular, action synchronization and joint intentions.</p><p>In the following, we show how PNPs can be used to support coordination so as to avoid interference among robots and enhance the performance of the system through the use of joint actions. In the literature, the design of multi-robot plans has been considered either as plan sharing (or centralized planning), where the objective is to distribute a global plan to robots executing them, or as plan merging, where individual plans are merged into a multi-robot plan (see <ref type="bibr" target="#b26">[15]</ref> for details). In our work, we follow centralized planning. Specifically, we provide a distributed execution model by implementing a centralized planning for distributed plans approach <ref type="bibr" target="#b26">[15]</ref>. Our distributed execution model allows to execute a set of single-robot PNPs, derived from a multi-robot PNP, without the need of a central coordinator robot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Synchronization operators</head><p>We can consider a multi-robot PNP, for a team of robots R 1 , . . . , R n , as the union of n PNPs (one for each robot). In a multi-robot PNP, each element of the net is labeled with the unique name of the robot that is in charge of its execution. This will be indicated in the following with the prefix R j . For example, R j .P refers to the set of places associated to robot R j . Thus, given n single-robot PNPs { R j .P, R j .T, R j .F } j=1...n we define a multi-robot PNP as:</p><formula xml:id="formula_11">P = P, T, F</formula><p>where P = n j=1 R j .P, T = n j=1 R j .T, F = n j=1 R j .F. Such a multi-robot plan consists simply of n independent plans. When dealing with multirobot systems, the main issue is how to represent the interactions among actions performed by different robots (i.e. among plans). The multi-robot plan, as previously defined, fails to capture such interactions and may result in the execution of conflicting actions. Therefore, we want to be able to order actions across plans so that overall consistency is maintained and conflicting situations are avoided.</p><p>We model multi-robot plans as a collection of single-robot plans enriched with synchronization constraints to avoid unsafe interactions. In particular, we introduce new types of operators, assuming that robots can communicate through a reliable channel. In the following, we describe a hard synchronization operator (h_sync), that synchronizes two plans at a given point in time, and a soft synchronization operator (s_sync), which introduces a precedence relation among the actions of two plans. Hard synchronization operator. The hard synchronization operator (h_sync), shown in Fig. <ref type="figure">8</ref>, supports time synchronization for the actions of two robots R 1 and R 2 . The operator has two input places P I = {p i1 , p i2 } and two output places P O = {p o1 , p o2 } and T C = {t}. The operator is similar to a join and a fork, except that it is used to synchronize behaviors of different robots. Formally, consider two robots R 1 and R 2 , four PNPs R 1 .P 1 , R 1 .P 2 , R 2 .P 1 , and R 2 .P 2 , and the h_sync operator. The PN formed by the sequence of R 1 .P 1 and h_sync through the place p i1 , the sequence of R 2 .P 1 and h_sync through the place p i2 , the sequence of R 1 .P 2 and h_sync through the place p o1 , and the sequence of R 2 .P 2 and h_sync through the place p o2 is a multi-robot PNP.  <ref type="figure">11a</ref> shows a PNP for two robots which have to lift a table by grabbing it at two opposite sides. The nodes for action structures and synchronization operators are grouped, for readability, by a common label. In this example, R 1 and R 2 can reach the two sides of the table asynchronously, but have to lift it simultaneously. The h_sync operator ensures that the robots will start to lift the table when both have reached it. In particular, the input transition t acts as a join waiting for both actions R 1 .gotoLe f t SideT able and R 2 .gotoRight SideT able to terminate. When both actions have terminated, the transition t acts like a fork enabling the simultaneous execution of the lift actions.</p><p>Soft synchronization operator. The soft synchronization operator (s_sync), shown in Fig. <ref type="figure">9</ref>, can be used to force a precedence relation among the actions of two different robots. The operator has two input places P I = {p i1 , p i2 }, two output places P O = {p o1 , p o2 }, one connector place P C = {p m } and two control transitions T C = {t f , t j }. Formally, consider two robots R 1 and R 2 , four PNPs R 1 .P 1 , R 1 .P 2 , R 2 .P 1 , and R 2 .P 2 , and the s_sync operator. The PN formed by the sequence of R 1 .P 1 and s_sync through the place p i1 , the sequence of R 2 .P 1 and s_sync through the place p i2 , the sequence of R 1 .P 2 and s_sync through the place p o1 , and the sequence of R 2 .P 2 and s_sync through the place p o2 is a multi-robot PNP.</p><p>Example 2 Figure <ref type="figure">12a</ref> shows an example of the use of the s_sync. In this example, there are two robots R 1 and R 2 . The first robot is a mail delivery robot and has a manipulator, while the second is a vacuum cleaner robot and has no manipulation ability. The first robot opens the door of the room to be cleaned and then moves on to deliver the mail. The second robot moves to the door and the enters the room to clean it. The problem is that the second robot has to be sure that the door is open before entering the room. To this end, we can add a s_sync. This allows the first robot to notify the second that the door is open, without having to wait for the second robot to reach the door. On the other hand, the second robot, when received the notification, can go on and enter the room safely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Distributed execution</head><p>The semantics of a multi-robot PNP is the same as a single-robot PNP, in the case of multibody planning <ref type="bibr" target="#b57">[46]</ref>, where a single centralized agent can dictate actions prescribed by the plan and query the knowledge base of each robot. Nevertheless, this approach is not desirable, because it introduces a single point of failure in the system (i.e. the centralized agent).</p><p>We show that multi-robot PNPs allow for distributed execution by providing an operational semantics for distributed execution. Roughly, given a multi-robot PNP, we can automatically produce a set of single-robot PNPs, by isolating the portion of the plans relative to each robot and by replacing synchronization operators with communication actions. Each single-robot plan can be locally executed by a robot without the need of a centralized coordinator, while correctness is maintained by communication actions. In particular, we aim at reproducing the behavior of synchronization operators in a distributed way, by replacing the synchronization operators with appropriate combinations of a non-blocking send action and a blocking receive action. The replacement of synchronization operators with communication actions leads to a distributed version of the firing rule, specific to synchronization structures.</p><p>We assume communication to be reliable. Moreover, we assume that the communication actions are instantaneous, and as such, we represent them as a single transition (see Fig. <ref type="figure">10</ref>).</p><p>The assumption of communication being instantaneous is often reasonable, given that robot actions involve moving actuators in the physical world that usually requires orders of magnitude more time than communication. So in this article we consider reliable communication Fig. <ref type="figure">9</ref> A s_sync operator Fig. <ref type="figure">10</ref> The communication primitives: blocking receive and non-blocking send whose execution time is bounded and significantly lower than action execution cycle. When this is not guaranteed, the current formulation should be extended with more complex forms of synchronization that use a non-instantaneous model of communication, but this aspect is beyond the scope of the present article.</p><p>The two communication actions are receive(R s , id) and send(R r , id), where R r is the robot that receives the message id and R s is the robot sending it; id is a unique identifier for the synchronization operators (which can be obtained by enumerating the operators). When R s performs the send(R r , id) action, it instantaneously and reliably sends the message id to R r , which stores it as the pair R s , id in a buffer. Pairwise, a receive(R s , id) is executed by R r only if there is a pair R s , id in the buffer. If this is the case, the action fires removing the pair from the buffer. Distributed hard synchronization. Figure <ref type="figure">11</ref> shows the decomposition of a centralized plan using h_sync, Fig. <ref type="figure">11a</ref>, into two single robot plans, Fig. <ref type="figure">11b</ref>, where the top plan belongs to R 1 and the bottom one to R 2 . The decomposed plans look very similar to the centralized one, but for the h_sync being replaced by two communication actions. The joint execution of the two plans leads to the same behavior of the multi-robot plan, when executed centrally. To this end, the behavior of the communication primitives send(r, id) and receive(r, id) has a key-role. Assume, without loss of generality, that R 2 reaches the table first. This means that it will perform a non-blocking send(R 1 , id) in a separate thread, and then stop on the blocking receive receive(R 2 , id). When R 2 arrives on the other side of the table, it will perform a non-blocking send(R 2 , id) in a separate thread. At this point, both robots will have received the id message, and will move on lifting the table together.</p><p>Distributed soft synchronization. Consider now the example of s_sync shown in Fig. <ref type="figure">12a</ref>, and the two plans derived from it in Fig. <ref type="figure">12b</ref>. In this case, the s_sync operator s_sync(R 1 , R 2 ), is decomposed in only two primitives: a non-blocking send and a blocking receive. The reason for the asymmetric decomposition is that the s_sync has a different behavior depending on the robot. In particular, the robot R 1 needs only to send a message id to robot R 2 , that states that it accomplished its task (i.e., opening the door). The send message is non-blocking because there is no need to wait for executing enter Room. Nevertheless, robot R 2 is blocked at receive(R 1 , id) on the main thread, because it has to be sure that open Door has ended, before performing enter Room.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Distributed execution algorithm</head><p>We can, thus, decompose a PNP P into several nets R 1 .P, . . . , R n .P , one for each robot. Each R i .P can be executed locally on robot R i and asynchronously with respect to other robots. The exchange of messages among the robots allows to coordinate the behavior of each R i .P. Definition 9 (Distributed Execution Algorithm-DEA) Given a PNP P for n robots, and its decomposition R 1 .P, . . . , R n .P , the distributed execution of P consists of the parallel execution of each R i .P according to Algorithm 1.</p><p>Notice that the execution of each R i .P is accomplished as described in Sect. 4 and the execution of each R i .P is performed based on the local knowledge base</p><formula xml:id="formula_12">R i .kb of robot R i . Thus, each transition t ∈ R i .T is fired, if t is enabled and if R i .kb | t.φ. The distributed evolution of a set of P N Ps {R i .P = R i .P, R i .T, R i .F, R i .W, M 0 , G } is a set of evolutions e i = ( M 0 , R i .kb 0 , . . . , M n , R i .kb n ), one for each R i .P.</formula><p>In order to compare the behavior of a centralized execution with respect to a distributed one, we introduce the concept of behavioral evolutions. Behavioral evolutions show the evolution of a net considering the marking of places, which actually control the behavior of the robot. This is obtained through the projection of the marking vector to a subspace, where places of synchronization operators (both centralized and distributed) are dropped. This allows us to verify if a centralized execution is equivalent to a distributed one, independently of the specific synchronization operator used.</p><p>Definition 10 (Behavioral Evolution) Given the evolution e = ( M 0 , R i .kb 0 , . . . , M n , R i .kb n ), we say that its behavioral evolution is be =</p><formula xml:id="formula_13">( M b 0 , R i .kb 0 , . . . , M b n , R i .kb n ),</formula><p>where M b j is the projection of M j , obtained by ignoring the places of multirobot operators, such as hard and soft synchronizations for the case of a centralized execution, and of the communication primitives send and receive in the case of distributed execution.</p><p>We can prove that a centralized execution by Algorithm 1 of a PNP, in the case of multibody planning, and its distributed execution by DEA, produce the same behavioral evolutions. During the execution of a multi-robot PNP, each robot executes the portions of the plan which are associated to it, except for h_sync and s_sync operators which require a central operator.</p><p>We show that synchronization operators have the same behavioral evolutions when centralized or distributed, by considering the behavior of the communication primitives send(R 2 , id) and receive(R 1 , id). All the communication primitives of a given decomposed operator will have the same id value, which identifies the operator itself.</p><p>Thus, if the distributed execution of the synchronization operators, when considering only their input and output places, has the same behavioral evolution of the centralized execution, then also the entire PNP has the same behavioral evolution if executed in a distributed or centralized way. The consequence of this is that, if a PNP is bounded, live or has a home state, then also the distributed execution will be bounded, live and have the same homing state.</p><p>Theorem 2 Assuming a reliable communication channel and instantaneous communication, DEA correctly executes any PNP P when using the multi-robot operators h_sync and s_sync, i.e. it produces the same behavioral evolution of the centralized execution of P with the same input.</p><p>Proof Since synchronization operators do not involve queries to the knowledge base, we consider the behavioral evolution ignoring the kb term. In particular, we consider for both the hard and soft synchronization the marking (Figs. <ref type="figure">8,</ref><ref type="figure">9</ref>):</p><formula xml:id="formula_14">M( p i1 ), M( p i2 ), M( p o1 ), M( p 02 )</formula><p>Hard synchronization. Without loss of generality, consider the h_sync and its distributed counterpart depicted in Fig. <ref type="figure">11a</ref> and<ref type="figure">b</ref>. Given that a PNP must be 1-bounded and that the underlying PN model prescribes at most one transition firing at every step, we have the following two possible scenarios for the centralized execution, based on the order with which transitions fire (Fig. <ref type="figure">11a</ref>):</p><p>1. t 1 , t 2 : t 1 fires producing the marking 1, 0, 0, 0 and enables the send action which fires producing the marking 0, 0, 1, 0 . Then, t 2 fires producing the marking 0, 1, 1, 0 . Now, the receive action is enabled (and unblocked by the previous send action); it thus fires producing the marking 0, 0, 1, 1 . 2. t 2 , t 1 : t 2 fires producing the marking 0, 1, 0, 0 , but the receive action is blocked (because it did not receive the id message) and thus no further firing can occur. Then, t 1 fires producing the marking 1, 1, 0, 0 . Now, the send action is enabled and can fire producing the marking 0, 1, 1, 0 . Finally, the receive action, that has been unblocked by the send, fires producing the marking 0, 0, 1, 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Collaboration using PNPs</head><p>In this section, we describe the use of PNPs to model collaboration in a team of robots.</p><p>Collaboration is, in fact, a key feature in the design of a large number of multi-robot applications. PNPs can be used to achieve a simple form of dynamic task assignment by exploiting the h_sync operator. Nevertheless, h_sync and s_sync are not enough to model more general forms of explicit collaboration. To this end, we introduce a new synchronization mechanism, called joint committed action, that can be used to model explicit forms of collaboration such as Cohen and Levesque's Joint Intentions theory <ref type="bibr" target="#b17">[6,</ref><ref type="bibr" target="#b62">51]</ref>, also allowing for a distributed execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Task assignment</head><p>An example of multi-robot collaboration is given by task assignment, which is the problem of assigning a set of tasks to a set of robots. Notice that, in multi-robot systems the knowledge bases R i .kb and R j .kb of two different robots, due to perceptual errors, may be inconsistent. Thus, it may be impossible to agree on a common description of the current situation.</p><p>There are a number of papers which explicitly address task assignment problems for robots (e.g., Token Passing <ref type="bibr" target="#b27">[16]</ref>, Market Based <ref type="bibr" target="#b25">[14,</ref><ref type="bibr" target="#b71">60]</ref>, Reactive Task Assignment <ref type="bibr" target="#b38">[27,</ref><ref type="bibr" target="#b66">55]</ref>, Iterative Task Assignment <ref type="bibr" target="#b53">[42]</ref> or Sequential Task Assignment <ref type="bibr" target="#b16">[5,</ref><ref type="bibr" target="#b24">13,</ref><ref type="bibr" target="#b34">23]</ref>). Among them, we consider the PNP implementation of a dynamic task assignment approach based on utility functions <ref type="bibr" target="#b38">[27]</ref>, which has been demonstrated to be effective on real robots, especially when facing a dynamic environment. The main idea is that each robot, based on its local knowledge, broadcasts to its teammates its utility in performing each role. We implement the task assignment algorithm through an h_sync, where each send action communicates the id of the h_sync and its own computed utility for the task. The communicated utility allows for sharing knowledge on the task to be performed. Then, each robot decides, based on the common knowledge of the utilities, which task it must perform.</p><p>Example 3 Consider a task assignment problem with two robots and two roles: two soccer robots need to perform a pass. Each of the two robots needs to initially decide whether it should pass or receive the ball. The robot that is closer to the ball is typically required to execute the pass task, whereas the robot which is far from the ball should execute the receive task.</p><p>A PNP that models task assignment in this scenario is shown in Fig. <ref type="figure" target="#fig_5">13</ref>. Once the soccer ball has been successfully located by the two robots (the portion of plan for finding the location of the ball is not shown in the figure), a h_sync operator is used to synchronize the execution and to exchange information about each robot's utility in each of the two roles. This communication ensures that both robots share the same set of beliefs about their individual utilities. The task assignment is then consistently performed, in this case, through the evaluation of the condition closest T oBall. In case Robot1 is the closest to the ball (R1.closest T oBall is true), the robot will perform a pass task. The pass and receive procedures are encoded in the remaining branches of the plan, not shown in the figure. The example considers the case of two robots and two roles, but the task assignment can be extended to the case of a larger number of robots and roles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Joint intentions</head><p>Collaboration plays an important role in multi-robot systems, as teamwork can lead to consistent performance improvements. Cohen and Levesque's Joint Intentions (JI) theory <ref type="bibr" target="#b17">[6]</ref> provides a detailed formal specification for the design of collaborative behaviors. Its prescriptive approach can be expressed using PNPs, which provide the required level of expressiveness, while maintaining the desired generality to allow for the design of a wide range of collaborative tasks. This section briefly summarizes the concepts behind the JI theory, and shows how it is possible to use it to design a PNP for explicit collaboration among multiple robots. The Joint Intentions theory isolates a set of basic requirements that the collaborative behavior should fulfill. The theory is rooted in the concept of commitment: members that are committed to the execution of a collaborative behavior will continue their individual action execution until the commitment holds. Communication is used to achieve mutual belief about Fig. <ref type="figure">14</ref> The joint committed action. Transitions implicitly encode events associated to the change of the current state of the joint action. When distributed, mutual belief on the current state of the joint actions is established by sending ids that implicitly encode the state of the system. Individual robots commit to the execution of a collaborative behavior using an h_sync operator. In case all individual behaviors are successfully concluded the collaboration successfully terminates and the robots break their commitment thought a second h_sync operator. Individual robots are able to determine if the collaboration should be interrupted, and communicate to achieve mutual belief on the necessity to break their commitment the necessity of interrupting the collaboration (i.e. breaking the members' commitment), in case any member of the team believes one of the following conditions is true:</p><p>1. the behavior was successfully concluded, 2. the behavior will never be concluded successfully (it is impossible), 3. the behavior became irrelevant.</p><p>The prescriptive approach of the Joint Intentions theory can be used to provide a systematic design of collaborative behaviors in a multi-robot team. The concepts behind the JI theory, in fact, can be embodied in the design of multi-robot PNPs for collaborative tasks. To this end, we define a joint committed action structure, which uses the h_sync operator to establish commitment and to assess the successful conclusion of the joint action. Moreover, we introduce a new set of transitions which act as multi-robot interrupts, to consistently interrupt the joint action when it becomes irrelevant or fails. Figure <ref type="figure">14</ref> shows the joint committed action: a multi-robot PNP operator for collaborative behavior, according to the specifications of the JI theory.</p><p>After a first hard synchronization (during which the commitment is established), the two robots perform the collaborative behavior, executing their individual actions (behavior1 and behavior2). In our implementations, the behavior1 and behavior2 are sub-plans rather than single actions. This allows for higher modularity and for avoiding proliferation of multi-robot interrupts required to monitor all possible configurations of the execution state of parallel sequences of actions. Following the JI theory, the commitment is broken, if one of the above listed conditions holds. If one of the engaged robots senses that the action has become irrelevant or that the action has failed, the multi-robot interrupts ensure that the event is communicated to the partner, and the execution of the individual actions is interrupted. In the case of a successful termination of both behavior1 and behavior2, a hard sync is performed to successfully end the commitment.</p><p>The decomposition of a joint committed action amounts to decomposing the h_syncs and the transitions that act as multi-robot interrupt. The decomposition of the h_sync is performed as described in the previous section, hence we focus on the decomposition of the multi-robot interrupt (Fig. <ref type="figure" target="#fig_6">15</ref>). Specifically, let us focus on the case when R1 recognizes that the joint committed action fails or becomes irrelevant (Fig. <ref type="figure" target="#fig_7">16</ref>). In the centralized model, this situation is handled by two transitions which break the commitment and move the robots to some recovery plan. The two transitions are required to handle the two possible configurations in which the system may be: <ref type="bibr">(1)</ref> both robots are executing their actions; (2) R1 is currently executing its action, while R2 has finished his action. Notice that the two configurations depend on the state of R2. The decomposition can thus be obtained as follows. First, we add an instantaneous send action for R1 that acts as an interrupt for behavior1 and that is guarded by the interrupt conditions. The send action when performed interrupts behavior1 and starts the recovery procedure for R1. Second, we add two receive actions to R2, one for each possible configuration of R2, which are triggered by the message sent by R1. Both receive actions, which are mutually exclusive given the topology of the net, produce a token in the same place, which is the input place of some recovery procedure for R2. Notice that mutual knowledge is obtained through the communication primitives that implicitly encode the current state of the joint behavior in the ids. Specifically, ids relative to h_syncs encode the commitment to a joint action or the achievement of a goal, while ids of multi-robot interrupts encode failures or the irrelevance of a task.</p><p>The semantics of distributed execution described in Sect. 5 is extended to the joint committed action. As a consequence of Theorem 2 and of the correspondence of the behavioral evolution of the centralized and the distributed multi-robot interrupt, we can prove that DEA correctly executes any multi-robot PNP P which includes joint committed actions.</p><p>Theorem 3 DEA correctly executes any PNP P when using joint committed actions, i.e. it produces the same behavioral evolution of the centralized execution of P with the same input.</p><p>Proof The proof of this theorem is similar to the one for Theorem 2. The main difference is that the joint committed action requires the query of the local kb of a robot in order to identify the interrupt conditions. Given that the interrupt explicitly requires to specify on which Knowledge Base the interrupt condition must be verified, we can consider the behavioral evolution ignoring the kb term:</p><formula xml:id="formula_15">M( p i1 ), M( p i2 ), M( p e1 ), M( p e2 ), M( p o1 ), M( p o2 ), M(R1.int), M(R2.int) .</formula><p>Given that it has been shown that h_sync preserves behavioral evolutions (Theorem 2), in order to obtain the proof we discuss the case of the multi-robot interrupt. Specifically, given that the behavior of the interrupts is symmetrical, we consider the case of multi-robot interrupts detected on robot R1 (Fig. <ref type="figure" target="#fig_7">16</ref>).</p><p>Given that a Joint committed always starts with a hard sync, we always begin with a token in the input place of both actions (i.e., 1, 1, 0, 0, 0, 0, 0, 0 ). Moreover, given that the start of an action, if enabled, is automatically fired by the executor and that the executor's cycle time is orders of magnitude faster than any robot action, we assume that, independently of which actions fires first, the system will instantaneously transition to the marking (i.e., 0, 0, 1, 1, 0, 0, 0, 0 ).</p><p>Consider now the multi-robot interrupt (Fig. <ref type="figure" target="#fig_7">16a</ref>) and its distributed counterpart (Fig. <ref type="figure" target="#fig_7">16b,</ref><ref type="figure">c</ref>). For the centralized model, we have the following possible cases (Fig. <ref type="figure" target="#fig_7">16a</ref>): execution, before reaching the marking 0, 0, 0, 0, 0, 0, 1, 1 , may reach for some bounded amount of time the markings 0, 0, 0, 1, 0, 0, 0, 1 or 0, 0, 1, 0, 0, 0, 0, 1, . Despite this, the system will eventually reach the marking 0, 0, 0, 0, 0, 0, 1, 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Evaluation</head><p>The proposed framework has been implemented and used to control different robotic systems in different domains. In particular, the implementation includes a plan executor for PNPs and a set of tools for designing and debugging plans. Plans are executed reacting to the events occurring in the environment and to the state of the robot.</p><p>In this section we first present three case studies showing the capabilities of the proposed framework and then we show some examples of PNP validation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Case studies</head><p>Among several applications realized with our PNP framework, we describe experimental tests implemented on two different robotic platforms: a wheeled robot used for search and rescue missions and four legged AIBO robots used for robotic soccer. In particular, we describe three case studies: single-robot exploration and search in unknown environment, collaborative multi-robot foraging, and robotic soccer ball passing.</p><p>Our aim is to highlight the features of PNPs used for representing single-robot and multirobot plans needed to accomplish them. The search and rescue activities described in <ref type="bibr">[3]</ref> address the need of complex plan structures, like interrupts and concurrent execution of complex actions. The case study on multi-robot foraging <ref type="bibr" target="#b27">[16]</ref> shows an example of complex coordination and action synchronization. Finally, the case study on robotic soccer presents many of the issues related both to coordination and collaboration. The videos showing the execution of these tasks with the robots are available at: pnp.dis.uniroma1.it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Exploration and search in an unknown environment</head><p>Exploration and search in an unknown environment is an important task for many robotic applications, related to security and surveillance. The main difficulties arise from the impossibility of specifying all the possible situations that a robot will encounter during a mission. In this context, we put a special emphasis on the evaluation of different strategies for rescue robots <ref type="bibr">[3]</ref> and we use PNPs to model the different strategies and perform a set of experiments with real and simulated robots to assess performance of such strategies.</p><p>Figure <ref type="figure" target="#fig_8">17</ref> shows the Pioneer 3 AT robot used in these experiments. It is a wheeled robot with on board sensors and computation. In particular, it uses a laser range finder for navigation and mapping, and a camera mounted on a pan-tilt unit for object detection and recognition. We also use a simulated scenario with similar characteristics.</p><p>While the description of the exploration strategies, the PNPs and the results of the experiments are detailed reported in <ref type="bibr">[3]</ref>, in this article we comment on the use of PNPs.</p><p>In the plans describing the exploration strategies we need to use all the single-agent PNP features described in the previous sections. Examples of ordinary actions are: NavigateAndSearch, NavigateToCandidateVictim and AnalyzeVictim; while sensing actions like FireFound are used to drive the plan according to some perception. The use of interrupts is very important, both to model action failures due to the uncertainty in perception and action execution and to take into account some other task more important to be performed. For example, during the execution of the action NavigateAndSearch, that is the basic action used to move around the environment, if a victim is seen, an interrupt on a condition new-VictimFound allows the robot to abort the search action and to start navigating towards the victim. Finally, concurrent actions are used in many situations to drive the robot wheels and the pan-tilt unit moving the camera independently.</p><p>In the above mentioned paper, we analyze four different scenarios and several strategies implemented with PNPs. PNPs embody all the features needed to model such a complex domain and the corresponding robot behaviors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Coordination in robotic foraging</head><p>In the second case study, we focus on coordination issues in a multi-robot foraging domain.</p><p>Here we show the use of complex coordination for object manipulation, delegating collaborative issues to an external algorithm. While the coordination algorithm, as well as a detailed description of the experiments, can be found in <ref type="bibr" target="#b27">[16]</ref>, in this paper, we describe the PNPs which have been used to coordinate the robots.</p><p>The multi-robot foraging test we have considered involves three robots that perform a synchronized operation on a set of similar objects scattered in the environment (Fig. <ref type="figure">18</ref>). In order to collect the objects, it is necessary to be able to synchronize actions across plans. Each robot can take one of two tasks: collector, that grabs the object (a ball), supporter, that supports the collector robot during the grabbing phase. An external module is used to dynamically assign tasks (a collector and a supporter) to the robots. The robots then execute a multi-robot PNP to jointly grab the objects and collect them in a predefined location in the environment.</p><p>Figure <ref type="figure">19</ref> shows the multi-robot plan used for this test. Hard synchronization is used to synchronize the robots after they reach the corresponding target positions. Then, the collector robot waits for the supporter one to push the ball below his neck. After that, the collector robot grabs the ball and the supporter robot moves away. Finally, the collector robot brings the object in the target area. All these synchronization activities are implemented on the robots by pairs of communication actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.3">Collaboration in robotic soccer</head><p>The third case study shows a complete example of using PNPs, addressing both coordination and collaboration. The goal of the case study is to have two robots passing the ball to each Fig. <ref type="figure">18</ref> AIBO robots during the foraging task Fig. <ref type="figure">19</ref> The multi-robot PNP for foraging test other (Fig. <ref type="figure" target="#fig_9">20</ref>). We require the resulting behavior to be robust to both action failures and exogenous events. To this end, we need to model, through PNPs, action synchronization, dynamic task assignment and teamwork implemented through Joint Intentions theory. Thus, in contrast with the previous case study, here there is no external module for collaboration. Indeed, collaboration is accomplished by using the PNP structures described in the previous sections.</p><p>The multi-robot plan (Fig. <ref type="figure">21</ref>) is divided in three phases: (1) task assignment based on the distance to the ball, (2) preparation to the pass, (3) actual pass behavior.</p><p>In the task assignment phase, the robot which is closer to the ball takes the role of the Passer and the other robot behaves as the Receiver. This is obtained by using the PNP task assignment mechanism illustrated by Fig. <ref type="figure" target="#fig_5">13</ref>. Note that this assignment is dynamic and depends on the actual position of the ball. After the task assignment phase, the robots are committed to the execution of their tasks for passing/receiving the ball. The Passer robot moves to reach the ball, grabs it and rotates towards its partner. In the meantime, the Receiver robot reaches the desired position and prepares to intercept the passed ball, by rotating towards the Passer. At the end of this phase, the robots renew their commitment through another synchronization. The h_sync operator is again used to ensure that both the robots have completed their actions, before they can proceed with the pass. This preparation phase (Fig. <ref type="figure" target="#fig_10">22</ref>) is prone to action failures, due to the difficulty of implementing reliable grab and rotation primitives with AIBO robots, and due to possible occurrence of exogenous events (e.g. collisions with other robots), that may interfere with the predicted performance of the primitives. Reflecting the principles of the JI theory, the robots break their commitment in case a failure occurs during this phase (in this particular task the collaborative behavior is never considered irrelevant, as the robots have the unique task of passing the ball). More specifically, the Lost Ball condition becomes true, whenever the Passer robot realizes that the ball has been lost during the grab or the rotation phases. The ball may in fact roll away from the robot, causing the need for a new task assignment procedure. In case the control of the ball is lost by the Passer robot, the Receiver robot needs to be notified, in order to break its commitment to the current execution of the pass. A multi-robot interrupt operator is used to consistently interrupt the execution of the actions of both the Passer and the Receiver.</p><p>In case the preparation phase is successfully completed, the pass can take place. The Passer robot kicks the ball towards the Receiver, that in the meanwhile performs an intercept behavior. This phase does not require special attention for action interruption, as the kick and the intercept behaviors are atomically performed and the pass behavior is concluded both in case of success and in case of failure of the pass. A further synchronization (through a hard </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Example of PNP validation</head><p>Figure <ref type="figure" target="#fig_0">23</ref> shows another possible experimental test, which combines the two previous ones: a collector robot C collects balls as they arrive, it passes the collected balls to a supporter robot S, that stores them somewhere. In this richer setting, it is possible to identify several design features that can be supported by the analysis of PNPs. Fig. <ref type="figure" target="#fig_0">23</ref> A foraging task with pass behavior and commitment. The PNP in this example is not valid 123 -The 2-robot system can recover from commitment loss when the collector C fails, but not when the supporter S fails. This means that the net is not effective. The problem can be found through reachability analysis. -There is a deadlock when the reached marking has a single token in any of the places, after commitment break on the supporter S subnet, therefore the net is not minimal, and the goal of continuously collecting balls is not achievable (will be undermined by a commitment break by S). The problem can be found through liveness analysis. -If we replace the current h_sync with a s_sync, assuming the collector C will throw the ball to wherever the supporter S is, whenever C grabs a ball, another unbounded place would show up at the new s_sync place, meaning that the collector performs its task faster than the supporter, an undesirable feature. Thus the net is not safe. The problem can be found using coverability trees.</p><p>As this example shows, PN analysis tools can be used to study several features of PNPs. In general, these features may not only be limited to safeness, effectiveness and minimality as presented in Sect. 3.3. Moreover, we recall that once we verify that some properties hold for the centralized PNP, we also know that they will hold for the distributed version as a consequence of the fact that multi-robot operators preserve behavioral evolutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>In this article, we have presented a new formalism, called PNPs, for high level programming of multi-robot systems. PNPs provide for a methodological and systematical approach for developing robotic behaviors through PNs, which allows for modeling many applicationcritical features such as: complex actions, concurrency and multi-robot coordination and collaboration. Moreover, PNPs implement a rich set of capabilities to support: (1) behavior design; (2) distributed execution; and (3) analysis and validation of the resulting behaviors. Our experience suggests that these features are very often required in the development of robotic systems, yet they can not be found in competing approaches.</p><p>PNPs are the result of the large body of experience in building multi-robot plans in a variety of domains, including robot soccer and disaster response robotics. The expressive power of PNPs provides suitable means to deal with most of the situations encountered, when designing autonomous robots and multi-robot systems. An implementation of the PNP executor, used in the case studies presented in this paper, is available as an open-source software. Additionally, PNPs can be supported by a wide range of PN tools that can ease the design and debug of PNPs through graphical interfaces and validate plans through automated analysis.</p><p>Although PNPs are the result of a decade of experience in designing multi-robot systems, there are still interesting developments in our research agenda. On the one hand, we need better ways to deal with the symbol grounding problem to establish a proper connection between low-level code and symbols in the plan representation framework: not only do we need to consider environment properties related to sensing actions and knowledge base predicates, but also we need better tools to define the action primitives and their counterpart in the low-level implementation. On the other hand, although PNPs are defined largely using notions from action theories, we aim at establishing a precise correspondence between PNPs and action theories as in the CONGOLOG language. In this way, the approach could also benefit from reasoning about actions as an additional tool to establish properties about states based upon the action representation. To this end, it is worth noticing that the combination of constructs that is provided by PNPs is richer than the CONGOLOG language; for example, the inclusion of interrupts and commitments deserve further investigation.</p><p>Finally, another line of research could address the automatic generation or synthesis of PNPs. In this respect, it is possible to identify sublanguages of PNPs, with the goal of applying plan generation techniques to obtain PNPs from action representations, or to apply learning techniques (e.g., genetic programming or reinforcement learning) for refining or generating plans by experiments and user training.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 Fig. 3</head><label>23</label><figDesc>Fig.2The sequence of two ordinary actions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 6 A</head><label>6</label><figDesc>Fig.<ref type="bibr" target="#b17">6</ref> A robotic soccer example: striker robot. The labeling shown is an example of the actual syntax used for our executable plans. Labels characterize action nodes and conditions associated to transitions. The net a denotes a PNP structure which is not a valid PNP, while net b is a valid PNP</figDesc><graphic coords="15,45.12,76.74,321.88,538.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 7</head><label>7</label><figDesc>Fig. 7 An abstract robot architecture for PNPs</figDesc><graphic coords="17,106.61,55.53,226.80,218.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 8 A h_sync operator 123 Example 1 Figure</head><label>81231</label><figDesc>Fig. 8 A h_sync operator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 11 aFig. 12 a</head><label>1112</label><figDesc>Fig. 11 a A multi-robot PNP using h_sync. b The single-robot PNPs obtained from the decomposition of the multi-robot one</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 13</head><label>13</label><figDesc>Fig. 13 PNP used for task assignment: a multi-robot plan and b single-robot plans</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 15 a</head><label>15</label><figDesc>Fig. 15 a Portion of the Joint Committed Action ignoring h_sync. b The decomposed PNP for robot R1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 16</head><label>16</label><figDesc>Fig.<ref type="bibr" target="#b27">16</ref> Detail on the decomposition of a Joint Committed Action</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 17</head><label>17</label><figDesc>Fig. 17 Rescue robots used for exploration and search tasks</figDesc><graphic coords="33,49.59,56.19,340.36,115.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 20</head><label>20</label><figDesc>Fig. 20 AIBO robots during the passing task</figDesc><graphic coords="35,49.59,55.74,340.36,92.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 22</head><label>22</label><figDesc>Fig. 22 Preparation phase of the pass behavior</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>A = {a 1 , . . . , a k }: Set of Implemented actions : Set of terms and formulas about the environment T r T ype = {start, end, interrupt, standard}</figDesc><table><row><cell cols="2">Algorithm 1 PNP Execution Algorithm</cell></row><row><cell cols="2">Domains:</cell></row><row><cell cols="2">Structures:</cell></row><row><cell cols="2">T ransition : a ∈ A, φ ∈ , t ∈ T r T ype</cell></row><row><cell cols="2">Action : start (), end(), interrupt ()</cell></row><row><cell cols="2">Global variables:</cell></row><row><cell cols="2">K nowledgeBase : kb</cell></row><row><cell cols="2">procedure execute(P N P P, T, F, W, M 0 , G )</cell></row><row><cell cols="2">1: Current Marking = M 0</cell></row><row><cell cols="2">2: while Current Marking ∈ G do</cell></row><row><cell cols="2">3: for all t ∈ T do</cell></row><row><cell>4:</cell><cell>if enabled(t, Current Marking) ∧ kb | t.φ then</cell></row><row><cell>5:</cell><cell>handleT ransition(t)</cell></row><row><cell>6:</cell><cell>Current Marking = f ire(Current Marking, t)</cell></row><row><cell>7:</cell><cell>end if</cell></row><row><cell cols="2">8: end for</cell></row><row><cell cols="2">9: end while</cell></row><row><cell cols="2">procedure handleT ransition(t)</cell></row><row><cell cols="2">if t.t = start then</cell></row><row><cell></cell><cell>t.a.start ()</cell></row><row><cell cols="2">else if t.t = end then</cell></row><row><cell></cell><cell>t.a.end()</cell></row><row><cell cols="2">else if t.t = interrupt then</cell></row><row><cell></cell><cell>t.a.interrupt ()</cell></row><row><cell cols="2">end if</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Available at pnp.dis.uniroma1.it.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For an exhaustive list of available tools see http://www.informatik.uni-hamburg.de/TGI/PetriNets/tools/.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">producing the marking 1, 0, 0, 0 , t is not enabled and thus no further firing can occur</title>
		<imprint/>
	</monogr>
	<note>t 1 , t 2 : t 1 fires. Then, t 2 fires producing the marking 1, 1, 0, 0 . Now t is enabled an can fire producing the marking 0, 0, 1, 1</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">producing the marking 0, 1, 0, 0 , t is not enabled and thus no further firing can occur. Then, t 1 fires producing the marking 1, 1, 0, 0 . Now t is enabled an can fire producing the marking 0, 0</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
	<note>t 2 , t 1 : t 2 fires</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">We show that the distributed execution has the same behavioral evolution (Fig</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">At this point, the send action is instantaneously performed on a separate thread and no tokens are produced (notice that the token in the input place of the send action is not considered in the behavioral evolution because part of a send operator). The receive action can not fire because it is blocked. Then, t 2 fires producing the marking 1, 1, 0, 0 . The send action is instantaneously performed on a separate thread and no tokens are produced. Now, both receive actions have been unblocked</title>
		<imprint/>
	</monogr>
	<note>t 1 , t 2 : t 1 fires producing the marking 1, 0, 0, 0. and can instantaneously terminate producing the marking 0, 0, 1, 1</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Soft synchronization. Without loss of generality, consider the s_sync and its distributed counterpart depicted in Fig. 12a and b. Given that a PNP must be 1-bounded and that the underlying PN model prescribes at most one transition firing at every step, we have the following two possible scenarios for the centralized execution</title>
		<imprint/>
	</monogr>
	<note>t 2 , t 1 : The same applies here, because this case is the symmetric of the previous. based on the order with which transitions fire (Fig. 12a</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">producing the marking 1, 0, 0, 0 , t f is enabled fires producing the marking 0, 0, 1, 0 (notice that a token is also placed in p m , which is not considered in the behavioral evolution because part of an operator)</title>
		<imprint/>
	</monogr>
	<note>t 1 , t 2 : t 1 fires. Then, t 2 fires producing the marking 0, 1, 1, 0 . Now t j is enabled an can fire producing the marking 0, 0, 1, 1</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">producing the marking 0, 1, 0, 0 , t j is not enabled and thus no further firing can occur. Then, t 1 fires producing the marking 1, 1, 0, 0 . Now t f is enabled an can fire producing the marking 0, 1, 1, 0 . Finally</title>
		<imprint/>
	</monogr>
	<note>t 2 , t 1 : t 2 fires. t j fires producing the marking 0, 0, 1, 1 . We show that the distributed execution has the same behavioral evolution (Fig. 12b</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">the condition (R1.failure OR R1.irrelevant) is true and t int1 fires leading to the marking</title>
		<imprint>
			<date>0, 0, 0, 0, 0, 0, 1, 1</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">then the condition (R1.failure OR R1.irrelevant) is true and t int2 fires leading to the marking</title>
		<imprint>
			<date>0, 1, 0, 0, 1, 0, 0. 0, 0, 0, 0, 0, 0, 1,</date>
		</imprint>
	</monogr>
	<note>1 . Let us consider the same situations. in the case of distributed execution (Fig. 16b</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">the condition (R1.failure OR R1.irrelevant) becomes true, thus in the local net of R1 the guard of send(R2,id) is true and the send action fires sending the message id to R2. Simultaneously, the receive action connected to p e2 is enabled and unblocked, thus</title>
		<imprint/>
	</monogr>
	<note>it fires leading to the marking 0, 0, 0, 0, 0, 0, 1, 1</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">then the condition (R1.failure OR R1.irrelevant) becomes true, thus in the local net of R1 the guard of send(R2, id) is true and the send action fires sending the message id to R2. Simultaneously, the receive action connected to p o2 is enabled and unblocked, thus</title>
		<imprint>
			<date type="published" when="2000">0, 1, 0, 0, 1, 0, 0</date>
		</imprint>
	</monogr>
	<note>t e2 fires leading to the marking 0. it fires leading to the marking 0, 0, 0, 0, 0, 0, 1, 1</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Notice that if we drop the assumption of instantaneous communications and allow some bounded delay, the system may have some spurious evolutions</title>
		<imprint/>
	</monogr>
	<note>Specifically, the distributed References</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Pipe2: Platform independent petri net editor</title>
		<author>
			<persName><forename type="first">N</forename><surname>Akharware</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>London, UK.</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Imperial College of Science, Technology and Medicine, University of London</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">M.Sc. thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">OpenRDK: a modular framework for robotic software development</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Censi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of international conference on intelligent robots and systems (IROS)</title>
		<meeting>international conference on intelligent robots and systems (IROS)</meeting>
		<imprint>
			<date type="published" when="2008-09">2008, September</date>
			<biblScope unit="page" from="1872" to="1877" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Multi-objective exploration and search for autonomous rescue robots</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Farinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Field Robotics, Special Issue on Quantitative Performance Evaluation of Robotic and Intelligent Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="763" to="777" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Modeling and analysis of multi-agent systems using petri nets</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Celaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Desrochers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Graves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE international conference on systems, man and cybernetics (ISIC)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1439" to="1444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dynamic role assignment for cooperative robots</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chaimowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F M</forename><surname>Campos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 IEEE international conference on robotics and automation</title>
		<meeting>the 2002 IEEE international conference on robotics and automation<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-05">2002. May</date>
			<biblScope unit="page" from="292" to="298" />
		</imprint>
	</monogr>
	<note>ICRA02</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Teamwork. Special Issue on Cognitive Science and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="486" to="512" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An introduction to the anchoring problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Coradeschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saffiotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Robotics and Autonomous Systems</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="85" to="96" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using colored petri nets for conversation modeling</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Cost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Finin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">K</forename><surname>Labrou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Peng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in AI</title>
		<imprint>
			<biblScope unit="volume">1916</biblScope>
			<biblScope unit="page" from="178" to="192" />
			<date type="published" when="2000">2000</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Modelling, analysis and execution of robotic tasks using petri nets</title>
		<author>
			<persName><forename type="first">H</forename><surname>Costelha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/RSJ international conference on Intelligent robots and systems (IROS)</title>
		<imprint>
			<date type="published" when="2007-10-29">2007. October 29-November 2, 2007</date>
			<biblScope unit="page" from="1449" to="1454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Planning with sensing for a mobile robot</title>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th European conference on planning (ECP&apos;97)</title>
		<meeting>4th European conference on planning (ECP&apos;97)</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Congolog, a concurrent programming language based on the situation calculus</title>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lespérance</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">121</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="109" to="169" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">First principles planning in bdi systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sardina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Padgham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAMAS &apos;09: Proceedings of the 8th international conference on Autonomous agents and multiagent systems</title>
		<meeting><address><addrLine>Richland, SC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="1105" to="1112" />
		</imprint>
	</monogr>
	<note>International Foundation for Autonomous Agents and Multiagent Systems</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A market approach to multirobot coordination</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Stentz</surname></persName>
		</author>
		<idno>CMU-RI-TR-01-26</idno>
		<imprint>
			<date type="published" when="2001-08">2001. August</date>
			<pubPlace>Pittsburgh, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Robotics Institute, Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Opportunistic optimization for market-based multirobot control</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stentz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2002 IEEE/RSJ international conference on Intelligent robots and systems (IROS&apos;02)</title>
		<imprint>
			<date type="published" when="2002-09">2002. September</date>
			<biblScope unit="page" from="2714" to="2720" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Multiagent systems: A modern approach to distributed artificial intelligence</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Durfee</surname></persName>
		</author>
		<editor>G. Weiss</editor>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>MIT Press</publisher>
			<biblScope unit="page" from="121" to="164" />
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
	<note>Distributed problem solving and planning</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Assignment of dynamically perceived tasks by token passing in multi-robot systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Ziparo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE, Special issue on multi-robot systems</title>
		<meeting>the IEEE, Special issue on multi-robot systems</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="1271" to="1288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Multi-agent systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ferber</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">STRIPS: A new approach to the application of theorem proving to problem solving</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nilsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="189" to="208" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Adaptive execution in complex dynamic worlds</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Firby</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<pubPlace>Yale</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Integrating planning and reacting in a heterogeneous asynchronous architecture for controlling real-world mobile robots</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the tenth national conference on artificial intelligence</title>
		<meeting>the tenth national conference on artificial intelligence</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="809" to="815" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">ESL: A language for supporting robust plan execution in embedded autonomous agents</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE aerospace conference</title>
		<meeting>the IEEE aerospace conference<address><addrLine>Aspen, CO</addrLine></address></meeting>
		<imprint>
			<publisher>Snowmass</publisher>
			<date type="published" when="1997-02">1997. February</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="319" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Procedural knowledge</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Georgeff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Lansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE special issue on knowledge representation</title>
		<meeting>the IEEE special issue on knowledge representation</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="page" from="1383" to="1398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Principled communication for dynamic multi-robot task allocation</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gerkey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Matarić</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international symposium on experimental robotics</title>
		<meeting>the international symposium on experimental robotics<address><addrLine>Waikiki, Hawaii</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-12">2000, December</date>
			<biblScope unit="page" from="353" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Supervisory control of mobile sensor networks: Math formulation, simulation, and implementation</title>
		<author>
			<persName><forename type="first">V</forename><surname>Giordano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ballal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Turchiano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man and Cybernetics-Part B: Cybernetics</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="554" to="562" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Representing conversations for scalable overhearing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gutnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Kaminka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="349" to="387" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Modeling distributed transportation systems composed of flexible automated guided vehicles in flexible manufacturing systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Herrero-Perez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Martinez-Barbera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Industrial Informatics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="166" to="180" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Distributed coordination in heterogeneous multi-robot systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Piaggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sgorbissa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Autonomous Robots</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="168" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Flexible teamwork in behavior-based robots</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Kaminka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Frenkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="108" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Coordinated execution of tasks in a multiagent environment</title>
		<author>
			<persName><forename type="first">J</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Pretty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Gosine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man, and Cybernetics, Part A</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="615" to="619" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Petri net-based cooperation in multi-agent systems</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kobt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Beauchemin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Barron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th Canadian conference on computer and robot vision</title>
		<meeting>4th Canadian conference on computer and robot vision</meeting>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">COLBERT: A language for reactive control in Saphira</title>
		<author>
			<persName><forename type="first">K</forename><surname>Konolige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1303</biblScope>
			<biblScope unit="page" from="31" to="50" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">The Saphira architecture: A design for autonomy</title>
		<author>
			<persName><forename type="first">K</forename><surname>Konolige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">L</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Ruspini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saffiotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Experimental and Theoretical Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="215" to="235" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Coordinated team play in the four-legged robocup league</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kontes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Lagoudakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE international conference on Tools with artificial intelligence (ICTAI)</title>
		<meeting>IEEE international conference on Tools with artificial intelligence (ICTAI)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="109" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Temporal logic-based reactive mission and motion planning</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kress-Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Fainekos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Robotics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1370" to="1381" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Modeling and control of autonomous soccer robots using distributed agent oriented petri nets</title>
		<author>
			<persName><forename type="first">C.-H</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-H</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE international conference on Systems, man and cybernetics</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="4090" to="4095" />
		</imprint>
		<respStmt>
			<orgName>SMC apos</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Xabsl-A pragmatic approach to behavior engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Loetzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Risler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jungel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/RSJ international conference on Intelligent robots and systems</title>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="page" from="5124" to="5129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Petri net models of robotic tasks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Milutinovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE international conference on Robotics and Automation</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>ICRA&apos;02</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Object coloured petri nets-A formal technique for object oriented modelling. Concurrent object-oriented programming and petri nets: Advances in petri nets</title>
		<author>
			<persName><forename type="first">C</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Moldt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="406" to="427" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Some philisophical problems from the standpoint of artificial intelligence</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hayes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="463" to="502" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Petri nets: Properties, analysis and applications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Murata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="541" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A robotic soccer passing task using petri net plans (demo paper)</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Palamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Ziparo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Costelha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 7th international conference on Autonomous agents and multiagent systems</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Parkes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Müller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Padgham</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">&amp;</forename><forename type="middle">S</forename><surname>Parsons</surname></persName>
		</editor>
		<meeting>7th international conference on Autonomous agents and multiagent systems<address><addrLine>Estoril, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>IFAAMAS Press</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="1711" to="1712" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">ALLIANCE: An architecture for fault tolerant multirobot cooperation</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Robotics and Automation</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="220" to="240" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Debugging Multi-agent systems using design artifacts: The case of interaction protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Poutakidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Padgham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winikoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1998 IEEE international conference on Systems, man and cybernetics</title>
		<meeting>1998 IEEE international conference on Systems, man and cybernetics<address><addrLine>San Diego, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Modeling rational agents within a BDI-architecture</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Georgeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the second international conference on Principles of knowledge representation and reasoning</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Allen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Fikes</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">&amp;</forename><forename type="middle">E</forename><surname>Sandewall</surname></persName>
		</editor>
		<meeting>the second international conference on Principles of knowledge representation and reasoning<address><addrLine>San Mateo</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Knowledge in action: Logical foundations for describing and implementing dynamical systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Norvig</surname></persName>
		</author>
		<title level="m">Artificial intelligence: A modern approach</title>
		<imprint>
			<publisher>Pearson Education</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note>Singapore</note>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">The frame problem and knowledge producing actions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Scherl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Levesque</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th national conference on Artificial intelligence (AAAI&apos;93)</title>
		<meeting>the 11th national conference on Artificial intelligence (AAAI&apos;93)</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="689" to="695" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Peer-to-peer multi-robot coordination algorithms: Petri net based analysis and design</title>
		<author>
			<persName><forename type="first">W</forename><surname>Sheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="2005-07-24">2005, July 24-28. 2005</date>
			<biblScope unit="page" from="1407" to="1412" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A task description language for robot control</title>
		<author>
			<persName><forename type="first">R</forename><surname>Simmons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Apfelbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE/RSJ international conference on Intelligent robots and systems (IROS)</title>
		<meeting>IEEE/RSJ international conference on Intelligent robots and systems (IROS)<address><addrLine>Victoria, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-10">1998, October</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1931" to="1937" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Validation of bdi agents</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sudeikat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Braubach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pokahr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lamersdorf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 4th international workshop on Programming multiagent systems</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Bordini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Dastani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Dix</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">El</forename><surname>Fallah</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Seghrouchni</forename></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="185" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Towards flexible teamwork</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tambe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="83" to="124" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">Probabilistic Robotics (Intelligent robotics and autonomous agents)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Burgard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fox</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Performance modelling of automated manufacturing systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vishwanadham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Narahari</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>New Delhi</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">A petri-net coordination model for an intelligent mobile robot</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Kyriakopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tsolkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Saridis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Robotics and Automation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="257" to="271" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Broadcast of local eligibility for multi-target observation</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">B</forename><surname>Werger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Mataric</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DARS00</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="347" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Modeling and verifying multi-agent behaviors using predicate/transition nets</title>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Volz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ioerger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SEKE &apos;02: Proceedings of the 14th international conference on Software engineering and knowledge engineering</title>
		<meeting><address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="193" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">TimeNETMS-an integrated modeling and performance evaluation tool for manufacturing systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Freiheit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1998 IEEE international conference on Systems, man and cybernetics</title>
		<meeting>1998 IEEE international conference on Systems, man and cybernetics<address><addrLine>San Diego, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Petri net plans</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Ziparo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<idno>FBI-HH-B-272/06</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of fourth international workshop on modeling of objects, components, and agents (MOCA)</title>
		<meeting>fourth international workshop on modeling of objects, components, and agents (MOCA)<address><addrLine>Turku, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">272</biblScope>
			<biblScope unit="page" from="267" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Petri net plans: a formal model for representation and execution of multi-robot plans</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Ziparo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Iocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Palamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Costelha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAMAS &apos;08: Proceedings of the 7th international joint conference on Autonomous agents and multiagent systems</title>
		<meeting><address><addrLine>Richland, SC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
	<note>International Foundation for Autonomous Agents and Multiagent Systems</note>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Multi robot exploration controlled by a market economy</title>
		<author>
			<persName><forename type="first">R</forename><surname>Zlot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stenz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE international conference on robotics and automation (ICRA&apos;02)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="3016" to="3023" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
