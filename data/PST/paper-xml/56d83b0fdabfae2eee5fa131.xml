<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adaptive Mesh Refinement Method for Optimal Control Using Nonsmoothness Detection and Mesh Size Reduction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Fengjin</forename><surname>Liu</surname></persName>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Ph.D. Student</orgName>
								<orgName type="department" key="dep2">Department of Mechanical and Aerospace Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">William</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
							<email>hager@ufl.edu</email>
						</author>
						<author>
							<persName><forename type="first">Anil</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
							<email>anilvrao@ufl.edu</email>
						</author>
						<author>
							<persName><forename type="first">Adaptive</forename><surname>Mesh</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Refinement Method for Optimal Control Using Nonsmoothness Detection and Mesh Size Reduction</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Florida Gainesville</orgName>
								<address>
									<postCode>32611</postCode>
									<region>FL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adaptive Mesh Refinement Method for Optimal Control Using Nonsmoothness Detection and Mesh Size Reduction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7F66050AE5D74F3DB27AC31D9C179F4A</idno>
					<idno type="DOI">10.1016/j.jfranklin.2015.05.028</idno>
					<note type="submission">Received date: 24 January 2015 Revised date: 22 April 2015 Accepted date: 13 May 2015</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>An adaptive mesh refinement method for solving optimal control problems is developed. The method employs orthogonal collocation at Legendre-Gauss-Radau points, and adjusts both the mesh size and the degree of the approximating polynomials in the refinement process. A previously derived convergence rate is used to guide the refinement process. The method brackets discontinuities and improves solution accuracy by checking for large increases in higher-order derivatives of the state. In regions between discontinuities, where the solution is smooth, the error in the approximation is reduced by increasing the degree of the approximating polynomial. On mesh intervals where the error tolerance has been met, mesh density may be reduced either by merging adjacent mesh intervals or lowering the degree of the approximating polynomial. Finally, the method is demonstrated on two examples from the open literature and its performance is compared against a previously developed adaptive method.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over the past two decades, direct collocation methods have become popular in the numerical solution of nonlinear optimal control problems. In a direct collocation method, the state and control are discretized at a set of appropriately chosen points in the time interval of interest. The continuous-time optimal control problem is then transcribed to a finite-dimensional nonlinear 1 programming problem (NLP) and the NLP is solved using well known software <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>. Originally, direct collocation methods were developed as h methods (for example, Euler or Runge-Kutta methods) where the time interval is divided into a mesh and the state is approximated using the same fixed-degree polynomial in each mesh interval. Convergence in an h method is then achieved by increasing the number and placement of the mesh points <ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref>. More recently, a great deal of research as been done in the class of direct Gaussian quadrature orthogonal collocation methods <ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref>. In a Gaussian quadrature collocation method, the state is typically approximated using a Lagrange polynomial where the support points of the Lagrange polynomial are chosen to be points associated with a Gaussian quadrature. Originally, Gaussian quadrature collocation methods were implemented as p methods using a single interval. Convergence of the p method was then achieved by increasing the degree of the polynomial approximation. For problems whose solutions are smooth and well-behaved, a Gaussian quadrature collocation method has a simple structure and converges at an exponential rate <ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref>. The most well developed Gaussian quadrature methods are those that employ either Legendre-Gauss (LG) points <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b14">15]</ref>, Legendre-Gauss-Radau (LGR) points <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref>, or Legendre-Gauss-Lobatto (LGL) points <ref type="bibr" target="#b5">[6]</ref>.</p><p>Many mesh refinement methods employing h or p direct collocation methods have been developed previously. Reference <ref type="bibr" target="#b26">[27]</ref> describes what is essentially a p method where a differentiation matrix is used to identify switches, kinks, corners, and other discontinuities in the solution.</p><p>References <ref type="bibr" target="#b27">[28]</ref> and <ref type="bibr" target="#b28">[29]</ref> locally refine the grids by splitting selected intervals according to some splitting criterion. Reference <ref type="bibr" target="#b4">[5]</ref> develops a fixed-order method that uses a density function to generate a sequence of non-decreasing size meshes on which to solve the optimal control problem. References <ref type="bibr" target="#b29">[30]</ref> and <ref type="bibr" target="#b30">[31]</ref> (and the references therein) describe a dual weighted residual (DWR) method for mesh refinement and goal-oriented model reduction. The DWR method uses estimates of a dual multiplier together with local estimates of the residuals to adaptively refine a mesh and control the error in problems governed by partial differential equations. Finally, in Ref. <ref type="bibr" target="#b2">[3]</ref> an error estimate is developed by integrating the difference between an interpolation of the time derivative of the state and the right-hand side of the dynamics. The error estimate developed in Ref. <ref type="bibr" target="#b2">[3]</ref> is predicated on the use of a fixed-order method (for example, trapezoid, Hermite-Simpson, Runge-Kutta) and computes a low-order approximation of the integral of the aforementioned difference. Different from all of this previous research where the order of the method is fixed and the mesh can only increase in size, in the method of this paper varies the degree of the polynomial approximation is varied and the mesh size can be be reduced.</p><p>While h methods have a long history and p methods have shown promise in certain types of problems, both the h and p approaches have limitations. Specifically, achieving a desired accuracy tolerance may require an extremely fine mesh (in the case of an h method) or may require the use of an unreasonably large degree polynomial approximation (in the case of a p method). In order to reduce significantly the size of the finite-dimensional approximation, and thus improve computational efficiency of solving the NLP, hp collocation methods have been developed. In an hp method, both the number of mesh intervals and the degree of the approximating polynomial within each mesh interval is allowed to vary. Originally, hp methods were developed as finite-element methods for solving partial differential equations <ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref><ref type="bibr" target="#b33">[34]</ref><ref type="bibr" target="#b34">[35]</ref><ref type="bibr" target="#b35">[36]</ref>. In the past few years the problem of developing hp methods for solving optimal control problems has been of interest <ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref>. References <ref type="bibr" target="#b19">[20]</ref> and <ref type="bibr" target="#b20">[21]</ref> describe hp adaptive methods where the error estimate is based on the difference between an approximation of the time derivative of the state and the right-hand side of the dynamics midway between the collocation points. It is noted that the approach of Refs. <ref type="bibr" target="#b19">[20]</ref> and <ref type="bibr" target="#b20">[21]</ref> creates a great deal of noise in the error estimate, thereby making these approaches computationally intractable when a high-accuracy solution is desired. Furthermore, the error estimate of Refs. <ref type="bibr" target="#b19">[20]</ref> and <ref type="bibr" target="#b20">[21]</ref> does not take advantage of the exponential convergence rate of a Gaussian quadrature collocation method. On the other hand, Ref. <ref type="bibr" target="#b21">[22]</ref> develops an error estimate based on the difference between the state interpolated on an increased number of Legendre-Gauss-Radau points in each mesh interval and the state obtained by integrating the dynamics on the solution using the interpolated state and control. Similar to the methods of Refs. <ref type="bibr" target="#b19">[20]</ref> and <ref type="bibr" target="#b20">[21]</ref>, however,the method of Ref. <ref type="bibr" target="#b21">[22]</ref> can only increase the size of the mesh.</p><p>As stated above, two key limitations of previous mesh refinement methods for optimal control is that the mesh can neither be decreased in size nor does the method attempt to detect discontinuities in the solution as the mesh refinement progresses. As a result, these previous methods may either create an unnecessarily large mesh. In addition, such methods place a larger than required number of mesh intervals near discontinuities or rapid changes in the solution.</p><p>Both of these limitations are addressed by the adaptive hp mesh refinement method described in this paper. The method of this paper is fundamentally different from any of these previously developed methods because it detects points where smoothness in the solution is lost and allows for reducing the size of the mesh. First, motivated by the approach similar to that of Ref. <ref type="bibr" target="#b36">[37]</ref>, nonsmoothness in the solution is determined by examining local maxima in the magnitude of the second derivative of the state within mesh intervals. Specifically, if a local maximum of the magnitude of the second derivative of the state is a user-specified factor greater than this second derivative at the same point on the previous mesh, then the mesh interval where this local maximum occurs is deemed to be a nonsmooth interval and the interval is divided. Mesh interval division in this manner then brackets the discontinuity within a narrow mesh interval. Outside of these intervals where the solution may be nonsmooth, the accuracy of the solution is improved by increasing the degree of the approximating polynomial. The method can reduce the size of the mesh either by combining mesh intervals or by reducing the degree of the approximating polynomial within a mesh interval. On mesh intervals where the error tolerance is satisfied, the degree of the approximating polynomial can be reduced when the high order terms in a power series expansion of the solution are sufficiently small. Similarly, adjacent mesh intervals can be combined into a single mesh interval when the degree of the polynomial approximation in these adjacent mesh intervals is essentially the same. The procedure for determining the intervals of nonsmoothness or for determining the mesh width is based on the solution of the collocated control problem on two meshes, one finer than the other, and an upper bound for the error in the collocation approximation given in Ref. <ref type="bibr" target="#b37">[38]</ref>. Finally, it is noted that a preliminary version of the approach developed in this paper is given in Ref. <ref type="bibr" target="#b38">[39]</ref>. This paper is organized as follows. In Section 2 the Bolza optimal control problem of interest in this research is described. In Section 3 the Legendre-Gauss-Radau collocation method used as the basis of the method of this paper is described. In Section 4 the mesh refinement method is described in detail. In Section 5 the method developed in Section 4 is demonstrated on two examples taken from the open literature. In Section 6 we provide a discussion of the method and the results obtained in the numerical examples. Finally, in Section 7 we provide conclusions on our research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Bolza Optimal Control Problem</head><p>Without loss of generality, consider the following general optimal control problem in Bolza form.</p><p>Determine the state y(τ ) ∈ R ny and the control u(τ ) ∈ R nu on the domain τ ∈ [-1, +1], the initial time, t 0 , and the terminal time t f that minimize the cost functional</p><formula xml:id="formula_0">J = M(y(-1), t 0 , y(+1), t f ) + t f -t 0 2 +1 -1 L(y(τ ), u(τ ), t(τ, t 0 , t f )) dτ,<label>(1)</label></formula><p>subject to the dynamic constraints</p><formula xml:id="formula_1">dy dτ = t f -t 0 2 a(y(τ ), u(τ ), t(τ, t 0 , t f )),<label>(2)</label></formula><p>the inequality path constraints</p><formula xml:id="formula_2">c min ≤ c(y(τ ), u(τ ), t(τ, t 0 , t f )) ≤ c max ,<label>(3)</label></formula><p>and the boundary conditions</p><formula xml:id="formula_3">b min ≤ b(y(-1), t 0 , y(+1), t f ) ≤ b max . (<label>4</label></formula><formula xml:id="formula_4">)</formula><p>It is noted that the time interval τ ∈ [-1, +1] can be transformed to the time interval t ∈ [t 0 , t f ] via the affine transformation</p><formula xml:id="formula_5">t ≡ t(τ, t 0 , t f ) = t f -t 0 2 τ + t f + t 0 2 . (<label>5</label></formula><formula xml:id="formula_6">)</formula><p>In the hp discretization, the domain τ ∈ [-1, +1] is partitioned into a mesh consisting of K</p><formula xml:id="formula_7">mesh intervals S k = [T k-1 , T k ], k = 1, . . . , K, where -1 = T 0 &lt; T 1 &lt; . . . &lt; T K = +1.</formula><p>The mesh intervals have the property that</p><formula xml:id="formula_8">K k=1 S k = [-1, +1]. Let y (k) (τ )</formula><p>and u (k) (τ ) be the state and control in S k . The Bolza optimal control problem of Eqs. ( <ref type="formula" target="#formula_0">1</ref>)-( <ref type="formula" target="#formula_3">4</ref>) can then rewritten as follows. Minimize the cost functional</p><formula xml:id="formula_9">J = M(y (1) (-1), t 0 , y (K) (+1), t f ) + t f -t 0 2 K k=1 T k T k-1 L(y (k) (τ ), u (k) (τ ), t(τ, t 0 , t f )) dτ,<label>(6)</label></formula><p>subject to the dynamic constraints</p><formula xml:id="formula_10">dy (k) (τ ) dτ = t f -t 0 2 a(y (k) (τ ), u (k) (τ ), t(τ, t 0 , t f )), (k = 1, . . . , K),<label>(7)</label></formula><p>the path constraints</p><formula xml:id="formula_11">c min ≤ c(y (k) (τ ), u (k) (τ ), t(τ, t 0 , t f )) ≤ c max , (k = 1, . . . , K), (<label>8</label></formula><formula xml:id="formula_12">)</formula><p>and the boundary conditions</p><formula xml:id="formula_13">b min ≤ b(y (1) (-1), t 0 , y (K) (+1), t f ) ≤ b max . (<label>9</label></formula><formula xml:id="formula_14">)</formula><p>Because the state must be continuous at each interior mesh point, it is required that the condition y(T - k ) = y(T + k ), (k = 1, . . . , K -1) be satisfied at the interior mesh points (T 1 , . . . , T K-1 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Legendre-Gauss-Radau Collocation</head><p>The multiple-interval form of the continuous-time Bolza optimal control problem in Section 2 is discretized using collocation at Legendre-Gauss-Radau (LGR) points <ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b21">22]</ref>. In the LGR collocation method, the state of the continuous-time Bolza optimal control problem is approxi-</p><formula xml:id="formula_15">mated in S k , k ∈ [1, . . . , K],</formula><p>as</p><formula xml:id="formula_16">y (k) (τ ) ≈ Y (k) (τ ) = N k +1 j=1 Y (k) j (k) j (τ ), (k) j (τ ) = N k +1 l=1 l =j τ -τ (k) l τ (k) j -τ (k) l , (<label>10</label></formula><formula xml:id="formula_17">)</formula><p>where τ ∈ [-1, +1],</p><p>(k)</p><formula xml:id="formula_18">j (τ ), j = 1, . . . , N k + 1, is a basis of Lagrange polynomials, τ (k) 1 , . . . , τ (k) N k</formula><p>are the Legendre-Gauss-Radau (LGR) <ref type="bibr" target="#b39">[40]</ref> collocation points in <ref type="bibr" target="#b9">(10)</ref> with respect to τ gives</p><formula xml:id="formula_19">S k = [T k-1 , T k ),<label>and</label></formula><formula xml:id="formula_20">τ (k) N k +1 = T k is a noncollocated point. Differentiating Y (k) (τ ) in Eq.</formula><formula xml:id="formula_21">dY (k) (τ ) dτ = N k +1 j=1 Y (k) j d (k) j (τ ) dτ . (<label>11</label></formula><formula xml:id="formula_22">)</formula><p>The dynamics are then approximated at the N k LGR points in mesh interval k ∈ [1, . . . , K] as</p><formula xml:id="formula_23">N k +1 j=1 D (k) ij Y (k) j = t f -t 0 2 a(Y (k) i , U<label>(k)</label></formula><p>i , t(τ</p><formula xml:id="formula_24">(k) i , t 0 , t f )), (i = 1, . . . , N k ),<label>(12)</label></formula><p>where</p><formula xml:id="formula_25">D (k) ij = d (k) j (τ (k) i ) dτ , (i = 1, . . . , N k , j = 1, . . . , N k + 1)</formula><p>are the elements of the N k × (N k + 1) Legendre-Gauss-Radau differentiation matrix <ref type="bibr" target="#b15">[16]</ref> in mesh interval S k , k ∈ [1, . . . , K]. The LGR discretization then leads to the following nonlinear programming problem (NLP). Minimize the LGR quadrature approximation to the cost functional</p><formula xml:id="formula_26">J ≈ M(Y (1) 1 , t 0 , Y (K) N K +1 , t f ) + K k=1 N k j=1 t f -t 0 2 w (k) j L(Y (k) j , U (k) j , t(τ (k) j , t 0 , t f ))<label>(13)</label></formula><p>subject to the collocation equations</p><formula xml:id="formula_27">N k +1 j=1 D (k) ij Y (k) j - t f -t 0 2 a(Y (k) i , U (k) i , t(τ (k) i , t 0 , t f )) = 0, (i = 1, . . . , N k ),<label>(14)</label></formula><p>the discretized path constraints</p><formula xml:id="formula_28">c min ≤ c(Y (k) i , U (k) i , t(τ (k) i , t 0 , t f )) ≤ c max , (i = 1, . . . , N k ),<label>(15)</label></formula><p>and the discretized boundary conditions</p><formula xml:id="formula_29">b min ≤ b(Y (1) 1 , t 0 , Y (K) N K +1 , t f ) ≤ b max . (<label>16</label></formula><formula xml:id="formula_30">)</formula><p>It is noted that the continuity in the state at the interior mesh points (T 1 , . . . , T K-1 ) is enforced via the condition</p><formula xml:id="formula_31">Y (k) N k +1 = Y (k+1) 1 , (k = 1, . . . , K -1).<label>(17)</label></formula><p>Computationally, the constraint of Eq. ( <ref type="formula" target="#formula_31">17</ref>) is eliminated from the problem by using the same variable for both Y (k)</p><formula xml:id="formula_32">N k +1 and Y (k+1) 1</formula><p>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Adaptive Mesh Refinement Method</head><p>In this section the adaptive mesh refinement method of this paper is described. The description of the method is divided into five parts. First a review is provided of the approach of Ref. <ref type="bibr" target="#b21">[22]</ref> for estimating the relative error in the solution on a given mesh. Next, the methods for both mesh interval division and polynomial degree increase are described. Finally, two approaches are described for reducing the size of the mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Approximation of Solution Error</head><p>In this Section the approach of Ref. <ref type="bibr" target="#b21">[22]</ref> for estimating the relative error in the solution on a given mesh is reviewed. The relative error approximation derived in Ref. <ref type="bibr" target="#b21">[22]</ref> is obtained by comparing two approximations to the state, one with higher accuracy. The key idea is that for a problem whose solution is smooth, an increase in the number of LGR points should yield a state that more accurately satisfies the dynamics. Hence, the difference between the solution associated with the original set of LGR points, and the approximation associated with the increased number of LGR points should yield an approximation of the error in the state.</p><p>Assume that the NLP of Eqs. ( <ref type="formula" target="#formula_26">13</ref>)-( <ref type="formula" target="#formula_29">16</ref>) corresponding to the discretized Bolza optimal control problem has been solved on a mesh</p><formula xml:id="formula_33">S k = [T k-1 , T k ], k = 1, . . . , K, with N k LGR points in mesh interval S k .</formula><p>Suppose that the objective is to approximate the error in the state at a set of</p><formula xml:id="formula_34">M k = N k + 1 LGR points τ (k) 1 , . . . , τ (k) M k , where τ (k) 1 = τ (k) 1 = T k-1 , and that τ (k) M k +1 = T k .</formula><p>Suppose further that the values of the state approximation at the points</p><formula xml:id="formula_35">τ (k) 1 , . . . , τ (k) M k are denoted y(τ (k) 1 ), . . . , y(τ (k) M k ) .</formula><p>Next, let the control be approximated in S k using the Lagrange interpolating polynomial</p><formula xml:id="formula_36">U (k) (τ ) = N k j=1 U (k) j ˆ (k) j (τ ), ˆ (k) j (τ ) = N k l=1 l =j τ -τ (k) l τ (k) j -τ (k) l , (<label>18</label></formula><formula xml:id="formula_37">)</formula><p>and let the control approximation at τ(k) i be denoted u(τ</p><formula xml:id="formula_38">(k) i ), 1 ≤ i ≤ M k .</formula><p>The value of the right-hand side of the dynamics at (Y(τ</p><formula xml:id="formula_39">(k) i ), U(τ (k) i ), τ (k) i</formula><p>) is used to construct an improved approximation of the state. Let Ŷ(k) be a polynomial of degree at most M k that is defined on the interval S k . If the derivative of Ŷ(k) matches the dynamics at each of the Radau quadrature</p><formula xml:id="formula_40">points τ(k) i , 1 ≤ i ≤ M k , we then have Ŷ(k) (τ (k) j ) = Y (k) (τ k-1 ) + t f -t 0 2 M k l=1 Î(k) jl a Y (k) (τ (k) l ), U (k) (τ (k) l ), t(τ (k) l , t 0 , t f ) , j = 2, . . . , M k + 1,<label>(19)</label></formula><p>where</p><formula xml:id="formula_41">Î(k) jl , j, l = 1, . . . , M k , is the M k × M k</formula><p>LGR integration matrix corresponding to the LGR points defined by</p><formula xml:id="formula_42">τ (k) 1 , . . . , τ (k) M k . Using the values y(τ (k) l ) and ŷ(τ (k) l ), l = 1, . . . , M k + 1</formula><p>, the absolute and relative errors in the i th component of the state at (τ</p><formula xml:id="formula_43">(k) 1 , . . . , τ (k) M k +1</formula><p>) are then defined, respectively, as</p><formula xml:id="formula_44">E (k) i (τ (k) l ) = Ŷ (k) i (τ (k) l ) -Y (k) i (τ (k) l ) , e (k) i (τ (k) l ) = E (k) i (τ (k) l ) 1 + max j∈[1,...,N k +1] k∈[1,...,K] Y (k) i (τ (k) j ) , ⎡ ⎣ l = 1, . . . , M k + 1, i = 1, . . . , n y , ⎤ ⎦ . (<label>20</label></formula><formula xml:id="formula_45">)</formula><p>The maximum relative error in S k is then defined as</p><formula xml:id="formula_46">e (k) max = max i∈[1,...,ny ] l∈[1,...,M k +1] e (k) i (τ (k) l ).<label>(21)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">LGR Collocation Error Bound for Use in Mesh Refinement</head><p>It has been shown In Refs. <ref type="bibr" target="#b37">[38]</ref> that, under suitable assumptions, the maximum difference between the LGR approximation (x, u) generated on a uniform mesh and the true solution (x * , u * ) evaluated on the same mesh satisfies an estimate of the form</p><formula xml:id="formula_47">x -x * ∞ + u -u * ∞ ≤ ch q N q-5/2 , (<label>22</label></formula><formula xml:id="formula_48">)</formula><p>where c is a constant, N is the number of LGR collocation points on each interval, h is the width of the mesh interval, q is the minimum of N and number of continuous derivatives in the solution, and • ∞ denotes the sup-norm over the mesh points. Although Eq. ( <ref type="formula" target="#formula_47">22</ref>) is an inequality that provides an upper bound for the error in the domain [-1, +1], it is useful in developing a variable-order mesh refinement method that allows for changes in the width of each mesh interval, changes in the number of mesh intervals, and changes in the number of collocation points in each mesh interval.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Refining the Mesh</head><p>After solving the NLP of Eqs. ( <ref type="formula" target="#formula_26">13</ref>)-( <ref type="formula" target="#formula_29">16</ref>) on a given mesh, the maximum relative error estimate is computed in each mesh interval using Eq. ( <ref type="formula" target="#formula_46">21</ref>). If in any mesh interval the estimated maximum relative error exceeds the mesh refinement accuracy tolerance , then the mesh interval is modified either by dividing it into smaller intervals or by increasing the degree of the approximating polynomial. As described earlier, a mesh interval is divided into subintervals when the solution is not sufficiently smooth in the mesh interval, while the polynomial degree in a mesh interval is increased when the solution is estimated to be sufficiently smooth in the mesh interval. The criterion for determining if a mesh interval is smooth or nonsmooth is based on whether the magnitude of the maximum second derivative of the state has increased by a specified factor from the previous mesh to the current mesh. In Section 4.3.1 an approach is developed for locating mesh intervals where the solution is nonsmooth, while Sections 4.3.2 and 4.3.3 provide methods for dividing a mesh interval (if the solution in the mesh interval is determined to be nonsmooth) or increasing the degree of the polynomial approximation (if the solution in the mesh interval is determined to be smooth).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Method for Locating Mesh Intervals Where Solution is Nonsmooth</head><p>Assume now that an optimal control problem has been solved on a mesh M using the previously described Radau collocation method and that </p><formula xml:id="formula_49">Y (M ) (τ ) = [Y (M ) 1 (τ ) • • • Y (M ) ny (τ )]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , K] on mesh</head><p>M is considered to be nonsmooth if the condition</p><formula xml:id="formula_50">R ij = P (M ) ij P (M -1) ij ≥ R<label>(23)</label></formula><p>is satisfied for some i ∈ [1, . . . , n y ] and for some j ∈ [1, . . . , L i ] with τ ij ∈ S k , where R is a user-specified ratio.</p><p>The motivation for Eq. ( <ref type="formula" target="#formula_50">23</ref>) is Ref. <ref type="bibr" target="#b36">[37]</ref> where the function values on two uniform meshes, a fine mesh and a coarse mesh, are used to estimate low order derivatives of a function. If a maximum in the magnitude of the (k + 1) th derivative on the fine mesh is much greater than corresponding (k + 1) th derivative on the coarse mesh, then it is predicted that the k th derivative is discontinuous in an interval near the maximum. In the context of optimal control, the optimal control can be discontinuous at one or more switch point which often implies that the state has a discontinuous derivative. Thus, in a manner similar to that of Ref. <ref type="bibr" target="#b36">[37]</ref>, in the mesh refinement method of this paper the growth condition of Eq. ( <ref type="formula" target="#formula_50">23</ref>) in the second derivative is used to determine if the solution in a mesh interval is nonsmooth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Method for Dividing a Mesh Interval</head><p>Assume now that the condition in Eq. ( <ref type="formula" target="#formula_50">23</ref>) is satisfied, that is,</p><formula xml:id="formula_51">P (M ) l /P (M -1) l &gt; R in a mesh interval</formula><p>S k on the current mesh, and that the mesh interval needs to be divided. Treating Eq. ( <ref type="formula" target="#formula_47">22</ref>) as an equality gives the relationship</p><formula xml:id="formula_52">e (M ) k = c h (M ) k q N (M ) k q-5/2 . (<label>24</label></formula><formula xml:id="formula_53">)</formula><p>Furthermore, assume for the ensuing mesh M +1 that it is desired to achieve a maximum relative error accuracy . Again, treating Eq. ( <ref type="formula" target="#formula_47">22</ref>) as an equality gives</p><formula xml:id="formula_54">= c h (M +1) k q N (M +1) k q-5/2 . (<label>25</label></formula><formula xml:id="formula_55">)</formula><p>Since the mesh interval S k is being divided, assume that N</p><formula xml:id="formula_56">(M +1) k = N (M ) k</formula><p>(that is, the number of collocation points in each subinterval of S k on mesh M + 1 is the same as the number of collocation points in S k on mesh M). Equations ( <ref type="formula" target="#formula_52">24</ref>) and 25 can then be solved for the ratio</p><formula xml:id="formula_57">H = h (M +1) k /h (M ) k as H = h (M ) k h (M +1) k = e (M ) k 1/q . (<label>26</label></formula><formula xml:id="formula_58">)</formula><p>To obtain an estimate for q, consider the relative error on the mesh M -1, which is assumed to contain mesh M:</p><formula xml:id="formula_59">e (M -1) k = c h (M -1) k q N (M -1) k q-5/2 . (<label>27</label></formula><formula xml:id="formula_60">)</formula><p>The constant c is eliminated by forming the ratio of ( <ref type="formula" target="#formula_52">24</ref>) and ( <ref type="formula" target="#formula_59">27</ref>), and then solve for q. The ratio H given in Eq. ( <ref type="formula" target="#formula_57">26</ref>) is then used to determine the number of subintervals into which S k should be divided. Specifically, the number of newly created subintervals must be at least H , the next largest integer greater than or equal to H. Now, because H can become large for certain problems, it is necessary to limit the growth in the number of subintervals. In this research the maximum number of subintervals into which S k divided is based on the ratio of the relative error in the solution and the mesh refinement accuracy tolerance and is given as</p><formula xml:id="formula_61">H max = log N (e (k) / ) , (<label>28</label></formula><formula xml:id="formula_62">)</formula><p>where • is the next largest integer of the argument. The upper limit on the number of subintervals given in Eq. ( <ref type="formula" target="#formula_61">28</ref>) is given as follows. First, when e (k) (say 10 6 ) the value of H max will typically in the range of 15 to 25. Next, it is seen that H max will decrease to zero as e (k) → . Thus, it will always be the case that H max will provide a reasonable upper limit on allowable number of subintervals. Using Eq. ( <ref type="formula" target="#formula_61">28</ref>) together with Eq. ( <ref type="formula" target="#formula_59">27</ref>), the number of subintervals, denoted S, into which S k is divided is given as</p><formula xml:id="formula_63">S = min( H , H max ).<label>(29)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Method for Increasing the Degree of the Polynomial Approximation</head><p>Suppose now that the error tolerance in a given mesh interval S k has not been met and that the condition in Eq. ( <ref type="formula" target="#formula_50">23</ref>) is not satisfied. In this case the solution in the mesh interval is regarded as smooth in S k and, if possible, the degree of the polynomial approximation used on mesh M + 1 is increased in order to reduce the solution error. Let e (M ) k denote the error on interval S k of mesh M. If the width of the mesh interval is the same on meshes M and M + 1, then h</p><formula xml:id="formula_64">(M ) k = h (M +1</formula><p>) k and Eqs. ( <ref type="formula" target="#formula_52">24</ref>) and ( <ref type="formula" target="#formula_54">25</ref>), together with the value of q computed in Section 4.3.2, can be used to solve</p><p>for</p><formula xml:id="formula_65">N (M +1) k as N (M +1) k = N (M ) k e (M ) k 1/(q-5/2) . (<label>30</label></formula><formula xml:id="formula_66">)</formula><p>Now, in order to obtain a strict increase in the number of collocation points in S k on mesh M + 1, the result of Eq. ( <ref type="formula" target="#formula_65">30</ref>) is replaced with</p><formula xml:id="formula_67">N (M +1) k = ⎡ ⎢ ⎢ ⎢ N (M ) k e (M ) k 1/(q-5/2) ⎤ ⎥ ⎥ ⎥ . (<label>31</label></formula><formula xml:id="formula_68">)</formula><p>Finally, to ensure that the polynomial degree does not grow to an unreasonably large value, an upper limit N max is set for the maximum allowable polynomial degree. If N</p><formula xml:id="formula_69">(M +1) k &gt; N max , then</formula><p>the mesh interval is divided into equally spaced subintervals with N (M ) k collocation points in each subinterval using the procedure of Section 4.3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Reducing the Number of Collocation Points in a Mesh Interval</head><p>In addition to the two approaches for increasing the size of the mesh as described in Sections 4.3.2 and 4.3.3, the mesh size can be decreased either by reducing the number of collocation points or by reducing the number of mesh intervals. Both of these methods for mesh size reduction are now described.</p><p>Consider any mesh interval S k = [T k-1 , T k ] where the accuracy tolerance has been satisfied.</p><p>Suppose further that it is desired to determine if it is possible to reduce the degree of the polynomial approximation of the state in S k while retaining the same accuracy as has been attained using the current polynomial degree. The determination as to whether or not the polynomial degree can be reduced is based on the following representation of the polynomial approxima- </p><formula xml:id="formula_70">tion of the state in S k . Let μ k = (T k-1 + T k )/2, h k = (T k -T k-1 )/2,</formula><formula xml:id="formula_71">Y (k) i (τ ) = N k +1 j=1 Y ij j τ -μ k h k , j (s) = N k +1 i=1 i =j s -s i s j -s i , (<label>32</label></formula><formula xml:id="formula_72">)</formula><p>where -1 = s 1 &lt; s 2 &lt; . . . &lt; s N k &lt; 1 are the LGR points on the interval [-1, +1] and s N k +1 = +1.</p><p>The polynomial j (s) can then written in the form</p><formula xml:id="formula_73">j (s) = N k l=0 a lj s l , (<label>33</label></formula><formula xml:id="formula_74">)</formula><p>where a lj are coefficients that depend only on the LGR points and are computed as follows. First, suppose that Q j (s) is a power series whose roots are the same as those of j (s), that is,</p><formula xml:id="formula_75">Q j (s) has roots {s k } N k +1 k=1 k =j</formula><p>and has the form</p><formula xml:id="formula_76">Q j (s) = N k l=0 Q lj s l . (<label>34</label></formula><formula xml:id="formula_77">)</formula><p>Then, because j (s j ) = 1,</p><formula xml:id="formula_78">j (s) = 1 Q j (s j ) Q j (s) = N k l=0 Q lj Q j (s j ) s l , (<label>35</label></formula><formula xml:id="formula_79">)</formula><p>which implies that</p><formula xml:id="formula_80">a lj = Q lj Q j (s j ) . (<label>36</label></formula><formula xml:id="formula_81">)</formula><p>It is noted that the coefficients a lj depend only on N k and, thus, only need to be computed once for each value of N k after which they can be stored for future use on other intervals and meshes.</p><p>Next, combining <ref type="bibr" target="#b31">(32)</ref> and <ref type="bibr" target="#b32">(33)</ref> gives</p><formula xml:id="formula_82">Y (k) i (τ ) = N k l=0 b il τ -μ k h k l , b il = N k +1 j=1 Y ij a lj . (<label>37</label></formula><formula xml:id="formula_83">)</formula><p>Now, it follows from the definitions of mesh interval midpoint and the mesh interval half-width that |τμ k |/h k ≤ 1 for τ ∈ S k . Therefore, if the N th k degree term in Eq. ( <ref type="formula" target="#formula_82">37</ref>) is dropped, the pointwise absolute error in mesh interval S k is at most |b iN k |. In order to obtain a error estimate in mesh interval S k that can be compared with the mesh refinement accuracy tolerance, however, it is necessary to normalize the coefficients b il . The quantities used to normalize the coefficients b il for each component of the state i ∈ [1, . . . , n y ] are similar to the manner in which the relative error estimate in the solution from Eq. ( <ref type="formula" target="#formula_46">21</ref>) is obtained and is given as</p><formula xml:id="formula_84">β i = 1 + max k∈[1,...,K] max τ ∈S k |Y (k) i (τ )|, (i = 1, . . . , n y ). (<label>38</label></formula><formula xml:id="formula_85">)</formula><p>13</p><p>Then, starting with the highest power, all terms in Eq. ( <ref type="formula" target="#formula_82">37</ref>) can continue to be removed (thus lowering the degree of the polynomial) until a coefficient b il /β i is found such that |b il |/β i &gt; .</p><p>The aforementioned process of polynomial degree reduction is repeated for all components of the state i ∈ [1, . . . , n y ], resulting in reduced polynomial degrees</p><formula xml:id="formula_86">N (k) 1 , . . . , N (k)</formula><p>ny . Then, the degree of the polynomial used for Y (k) (τ ) in mesh interval S k on the ensuing mesh is the one that corresponds to maximum of (N</p><formula xml:id="formula_87">(k) 1 , . . . , N (k)</formula><p>ny ). In other words, the reduced polynomial degree in mesh interval S k is the one that corresponds to the largest of the reduced polynomial degrees over all components of the state. Finally, because the Radau collocation method requires at least one collocation point in each mesh interval, the polynomial approximation cannot be reduced to a constant but can only be reduced to a linear function in each mesh interval.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.5">Merging Mesh Intervals</head><p>The second manner in which the mesh size can be reduced is by merging two adjacent mesh intervals into a single mesh interval. Before testing whether two subintervals can be merged, the highest powers in the polynomial approximation are eliminated when possible using the process described in Section 4.3.4. Next, two mesh intervals are joined into a single interval when the polynomials on the adjacent subintervals are roughly the same. First note that if</p><formula xml:id="formula_88">N k+1 = N k , then mesh intervals S k+1 = [T k , T k+1 ] and S k = [T k-1 , T k</formula><p>] cannot be merged because the degree of the polynomials in each mesh interval are different. The test for deciding when two intervals can be merged is the following: If the polynomial on the larger interval is extended into the smaller interval and if the pointwise difference between the original polynomial on the small interval and the extension from the large interval is at most , the state accuracy tolerance, then the mesh intervals S k and S k+1 are merged to form a single interval.</p><p>By continuity, the polynomials on S k and S k+1 are equal at T k , the point where the intervals join. Typically, the difference between the original polynomial on the small interval and the extension from the large interval is largest at the end point, either T k-1 or T k+1 . If this difference is greater than , then the intervals should not be joined. On the other hand, if the difference is less than , then it is necessary to examine the polynomial difference over the entire smaller interval.</p><p>It is possible to approximate the pointwise difference between the polynomials by evaluating the polynomials at more points on the smaller interval. An alternative to this approach, which is now described, is to derive an upper bound for this difference that is valid over the entire interval.</p><p>From Eq. ( <ref type="formula" target="#formula_82">37</ref>) it is seen that the midpoint and mesh half-width of mesh interval S k are different from the midpoint and mesh half-width of mesh interval S k+1 . Consequently, using the representation in Eq. ( <ref type="formula" target="#formula_82">37</ref>), it is difficult to bound the difference between the polynomial approximations in S k and S k+1 . In order to bound the difference between these two polynomials, it is convenient to expand these two polynomials about the junction, T k , between the mesh intervals S k and S k+1 . These expansions are obtained by expressing the Lagrange basis in Eq. ( <ref type="formula" target="#formula_71">32</ref>) in terms of the following two power series using the points +1 and -1:</p><formula xml:id="formula_89">j (s) = N k l=0 (s -1) l a (k) lj , (<label>39</label></formula><formula xml:id="formula_90">)</formula><formula xml:id="formula_91">j (s) = N k l=0 (s + 1) l a (k+1) lj . (<label>40</label></formula><formula xml:id="formula_92">)</formula><p>The representations of the Lagrange polynomials given in Eqs. ( <ref type="formula" target="#formula_89">39</ref>) and ( <ref type="formula" target="#formula_91">40</ref>) can then be evaluated in an analogous manner to the approach used to compute the coefficients in Eq. ( <ref type="formula" target="#formula_73">33</ref>). Furthermore, combining Eq. ( <ref type="formula" target="#formula_71">32</ref>) with Eq. ( <ref type="formula" target="#formula_89">39</ref>) in mesh interval S k and with Eq. ( <ref type="formula" target="#formula_91">40</ref>) in mesh interval S k+1 , the i th component of the state approximations Y (k) (τ ) and Y (k+1) (τ ) in mesh intervals S k and S k+1 are given, respectively, as</p><formula xml:id="formula_93">Y (k) i (τ ) = N k l=0 c (k) il τ -T k h k l , c (k) il = N k +1 j=1 Y ij a (k) lj , (<label>41</label></formula><formula xml:id="formula_94">)</formula><formula xml:id="formula_95">Y (k+1) i (τ ) = N k l=0 c (k+1) il τ -T k h k+1 l , c (k+1) il = N k +1 j=1 Y ij a (k+1) lj . (<label>42</label></formula><formula xml:id="formula_96">)</formula><p>The representations of <ref type="formula" target="#formula_93">41</ref>) and ( <ref type="formula" target="#formula_95">42</ref>) now differ only in that h k appears in the denominator of Eq. ( <ref type="formula" target="#formula_93">41</ref>) while h k+1 appears in the denominator of Eq. <ref type="bibr" target="#b41">(42)</ref>. In order to unify Eqs. ( <ref type="formula" target="#formula_93">41</ref>) and ( <ref type="formula" target="#formula_95">42</ref>) into a form such that the denominators are the same, let hk = min{h k , h k+1 }. The representations of the state approximation in mesh intervals S k and S k+1 can then be written, respectively, as</p><formula xml:id="formula_97">Y (k) i (τ ) and Y (k+1) i (τ ) in Eqs. (</formula><formula xml:id="formula_98">Y (k) i (τ ) = N k l=0 b (k) il τ -T k hk l , b (k) il = c (k) il hk h k l , (<label>43</label></formula><formula xml:id="formula_99">)</formula><formula xml:id="formula_100">Y (k+1) i (τ ) = N k l=0 b (k+1) il τ -T k hk l , b (k+1) il = c (k+1) il hk h k+1 l . (<label>44</label></formula><formula xml:id="formula_101">)</formula><p>Because the powers in both expansions are the same, the difference between the polynomials</p><formula xml:id="formula_102">Y (k) i (τ ) and Y (k+1) i (τ ) is Y (k) i (τ ) -Y (k+1) i (τ ) = N k l=0 b (k) il -b (k+1) il τ -T k hk l .</formula><p>Then, because |τ -T k |/ hk ≤ 2 for τ in the smaller interval, it follows from the triangle inequality that the polynomial difference has the pointwise bound</p><formula xml:id="formula_103">max{|Y (k) i (τ ) -Y (k+1) i (τ )|} ≤ N k l=0 2 l |b (k) il -b (k+1) il |, τ ∈ Sk (<label>45</label></formula><formula xml:id="formula_104">)</formula><p>where Sk is the smaller of S k and S k+1 . Now the result of Eq. ( <ref type="formula" target="#formula_103">45</ref>) provides an upper bound on the maximum absolute difference between</p><formula xml:id="formula_105">Y (k) i (τ ) and Y (k+1) i (τ ).</formula><p>In order to obtain a difference that can be compared with the mesh refinement accuracy tolerance, however, it is necessary to scale Eq. ( <ref type="formula" target="#formula_103">45</ref>) appropriately to obtain an upper bound on the maximum relative difference between the polynomials Y  <ref type="formula" target="#formula_84">38</ref>) and which were used in the approach for polynomial reduction as described in Section 4.3.4. Scaling</p><p>Eq. ( <ref type="formula" target="#formula_103">45</ref>) by β i gives the following relative difference between</p><formula xml:id="formula_106">Y (k) i (τ ) and Y (k+1) i (τ ): 1 β i max{|Y (k) i (τ ) -Y (k+1) i (τ )|} ≤ 1 β i N k l=0 2 l |b (k) il -b (k+1) il |, τ ∈ Sk , (i = 1, . . . , n y ).<label>(46)</label></formula><p>Then, if</p><formula xml:id="formula_107">1 β i N k l=0 2 l |b (k) il -b (k+1) il | &lt; , τ ∈ Sk , (i = 1, . . . , n y ),<label>(47)</label></formula><p>for all components of the state i ∈ [1, . . . , n y ] (where we recall that is the mesh refinement accuracy tolerance), the mesh intervals S k and S k+1 are merged into a single mesh interval. Finally, it is noted that S k and S k+1 cannot be merged if Eq. ( <ref type="formula" target="#formula_107">47</ref>) is violated for any component of the state</p><formula xml:id="formula_108">i ∈ [1, . . . , n y ].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.6">Mesh Refinement Method</head><p>The mesh refinement method described in this paper is summarized in the following steps shown below.</p><p>I. Supply an initial mesh that consists of K mesh intervals S k = [T k-1 , T k ], k = 1, . . . , K, with N k collocation points on each interval.</p><p>II. Solve the NLP of Eqs. ( <ref type="formula" target="#formula_26">13</ref>)-( <ref type="formula" target="#formula_29">16</ref>) on the initial mesh.</p><p>III. If the maximum relative error in all mesh intervals is less than the mesh refinement accuracy tolerance, , then terminate.</p><p>IV. Generate a second mesh as follows:</p><p>(i) Compute the maximum relative error given by Eq. ( <ref type="formula" target="#formula_46">21</ref>).</p><p>(ii) In every mesh interval where the maximum relative error of Eq. ( <ref type="formula" target="#formula_46">21</ref>) is greater than the mesh refinement accuracy tolerance, , add three collocation points in the mesh interval.</p><p>(iii) In every mesh interval where the maximum relative error of Eq. ( <ref type="formula" target="#formula_46">21</ref>) is less than than the mesh refinement accuracy tolerance, , use the mesh size reduction approaches given in Sections 4.3.4 and 4.3.5 to decrease the degree of the approximating polynomial or merge mesh intervals where possible.</p><p>For every mesh after the second mesh, employ the following steps.</p><p>V. Repeat the following steps until the mesh refinement accuracy tolerance is satisfied in every mesh interval S k , (k = 1, . . . , K) or a specified maximum number of mesh refinement iterations is reached:</p><p>(i) Solve the problem on the current mesh and estimate the maximum relative error e (k) max in each mesh interval.</p><p>(ii) Increase or decrease the size of the mesh using steps (a)-(c) below.</p><p>(a) For every mesh interval k ∈ [1, . . . , K] where e (k) max ≥ , estimate the ratio R ij for every component of the state using the approach in Section 4.3.1. If R ij &gt; R (where R is a threshold of significance of the ratio of second derivatives) for any component of the state, then divide the mesh interval into subintervals using the approach in Section 4.3.2. Otherwise, increase the degree of the polynomial approximation in mesh interval k ∈ [1, . . . , K] using the approach in Section 4.</p><p>(b) For every mesh interval k ∈ [1, . . . , K] where e (k) max &lt; , determine if the number of collocation points in the mesh interval can be reduced using the the approach of Section 4.3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(c) For every pair of adjacent mesh intervals</head><formula xml:id="formula_110">k ∈ [1, . . . , K] and k + 1 ∈ [1, . . . , K]</formula><p>where e (k) max &lt; and e (k+1) max &lt; , determine if these mesh intervals can be combined using the approach of Section 4.3.5.</p><p>(iii) Construct the new mesh, interpolate the solution from the previous mesh to this new mesh, and go to Step IV(i).</p><p>A schematic of the method is shown in Fig. <ref type="figure">1</ref>.</p><p>Figure <ref type="figure">1</ref>: Schematic of hp Mesh Refinement Method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Examples</head><p>In this Section the mesh refinement method described in Section 4 is applied to two examples</p><p>taken from the open literature. The first example is the robot arm optimal control problem taken from Ref. <ref type="bibr" target="#b40">[41]</ref>. This example demonstrates the ability of the mesh refinement method to accurately determine regions of nonsmoothness in the problem on a problem whose solution contains multiple control discontinuities. The second example is the hyper-sensitive optimal control problem taken from Ref. <ref type="bibr" target="#b41">[42]</ref>. This second example demonstrates the ability of the mesh refinement method to reduce the size of the mesh by eliminating unneeded mesh points and collocation points.</p><p>The following terminology is used in the examples. First, the method developed in this paper is called an hp method while the method of Ref. <ref type="bibr" target="#b21">[22]</ref> (used for comparison) is called a ph method. Next, the notation ph-(N min , N max ) refers to a variant of the aforementioned ph method where the number of collocation points in a mesh interval is allowed to vary between N min and N max . Furthermore, the quantity M denotes the number of the mesh refinement, where M = 0 corresponds to the initial mesh, and the quantities N and K denote the total number of LGR collocation points and the number of mesh intervals, respectively. Finally, it is noted that the hp method will maintain at least two collocation points in a mesh interval and does not require that an upper limit on the number of collocation points be specified.</p><p>All results shown in this paper were obtained using the MATLAB optimal control software GPOPS -II <ref type="bibr" target="#b42">[43]</ref> using the NLP solver SNOPT <ref type="bibr" target="#b0">[1]</ref> using an optimality tolerance of 10 -10 and a feasibility tolerance of 2 × 10 -10 . All first derivatives for the NLP solver were obtained using the MATLAB automatic differentiation tool AdiGator <ref type="bibr" target="#b43">[44]</ref>. In all results a mesh refinement accuracy tolerance = 10 -6 was used with an initial mesh consisting of ten uniformly-spaced mesh intervals and the four collocation points per mesh interval, a second derivative ratio threshold R = 1.2 (which is the same value used in Ref. <ref type="bibr" target="#b44">45</ref>), and a maximum number of collocation points to solve the problem on the initial guess is the same for any method and, thus, adds a constant to the total CPU time).</p><formula xml:id="formula_111">N max =</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1</head><p>Consider the following minimum time reorientation of a robot arm taken from Ref. <ref type="bibr" target="#b40">[41]</ref>. The objective is to minimize the cost functional</p><formula xml:id="formula_112">J = t f (48)</formula><p>subject to the dynamic constraints</p><formula xml:id="formula_113">ẏ1 = y 2 , ẏ2 = u 1 /L, ẏ3 = y 4 , ẏ4 = u 2 /I θ , ẏ5 = y 6 , ẏ6 = u 3 /I φ ,<label>(49)</label></formula><p>the control inequality constraints</p><formula xml:id="formula_114">-1 ≤ u i (t) ≤ 1, (i = 1, 2, 3),<label>(50)</label></formula><p>and the boundary conditions</p><formula xml:id="formula_115">y 1 (0) = y 10 , y 1 (t f ) = y 1f , y 2 (0) = y 20 , y 2 (t f ) = y 2f , y 3 (0) = y 30 , y 3 (t f ) = y 3f , y 4 (0) = y 40 , y 4 (t f ) = y 4f , y 5 (0) = y 50 , y 5 (t f ) = y 5f , y 6 (0) = y 60 , y 6 (t f ) = y 6f ,<label>(51)</label></formula><p>where    viously developed ph mesh refinement method of Ref. <ref type="bibr" target="#b21">[22]</ref>. First, it is seen from Fig. <ref type="figure" target="#fig_13">3f</ref> that the CPU time required to solve the problem grows as the product of the number of collocation points and the number of mesh refinements, NM. In other words, as one might expect, the CPU time increases due to an increase in either the size of the mesh or an increase in the number of mesh refinement iterations required to meet the mesh refinement accuracy tolerance. An alternate view of this same trend in the CPU time is reflected in Table <ref type="table" target="#tab_0">1</ref>. Comparing Fig. <ref type="figure" target="#fig_13">3f</ref> and Table <ref type="table" target="#tab_0">1</ref>, it is seen that the CPU time required by the hp method lies in the lower left-hand corner of the data shown in Fig. <ref type="figure" target="#fig_13">3f</ref>. Next, Figs. <ref type="figure" target="#fig_13">3c-3d</ref> show the mesh refinement history for both the hp and the ph - <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b7">8)</ref> method (where the ph -(3, 8) method is the best performing of the ph methods on this example). First, it is seen that the ph -(3, 8) method introduces more mesh intervals during the first few mesh refinements when compared with the hp method. Furthermore, the ph - <ref type="bibr" target="#b2">(3,</ref><ref type="bibr" target="#b7">8)</ref> method takes one more mesh refinement to meet the accuracy tolerance and the mesh points are less concentrated near the discontinuities when compared with the hp method. Finally, Table 1 that, while the total number of collocation points using the hp method is slightly larger using the hp method than it is for most of the ph methods, the hp method meets the mesh refinement accuracy tolerance in many fewer mesh refinements when compared with most of the ph methods. Finally, it is seen that the number of collocation points required by the hp method is significantly less than the number of collocation points required by either the h -2 or h -3 methods and is comparable in size to the mesh produced by the h -4 method. It is noted, however, that the h -4 method is still less computationally efficient than the hp method. In addition,</p><formula xml:id="formula_116">I θ = ((L -y 1 ) 3 + y 3 1 ) 3 sin 2 (y 5 ), I φ = ((L -y 1 ) 3 + y 3 1 ) 3 , L = 5,<label>(52)</label></formula><p>the hp mesh refinement method of this paper is compared with the mesh refinement method used in the Sparse Optimization Suite (SOS) <ref type="bibr" target="#b45">[46]</ref>. It is noted that 128 grid points and six mesh refinement iterations were required to solve the problem using (SOS) to meet a relative error accuracy tolerance = 10 -6 . Thus, the final SOS grid is approximately 1.5 times larger than the final mesh obtained using the method of this paper while SOS required approximately twice the number mesh iterations when compared with the method of this paper. Finally, it is noted that the SOS computation times are not compared with those obtained in this research because the SOS NLP solver is different from SNOPT (used in this research), SOS is written in FORTRAN 95 (whereas the work of this research was performed using MATLAB), and the machine on which SOS was used to perform the computations is completely different from the machine on which the computations in this research were performed.       </p><note type="other">8 Control Discontinuity</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2</head><p>Consider the following hyper-sensitive optimal control problem taken from Refs. <ref type="bibr" target="#b21">[22]</ref> and <ref type="bibr" target="#b41">[42]</ref>.</p><p>Minimize the cost functional</p><formula xml:id="formula_117">J = 1 2 t f 0 (y 2 + u 2 )dt<label>(54)</label></formula><p>subject to the dynamic constraint ẏ = -y + u (55) and the boundary conditions</p><formula xml:id="formula_118">y(0) = 1.5, y(t f ) = 1,<label>(56)</label></formula><p>where t f is fixed. The exact solution to the optimal control problem of Eqs. ( <ref type="formula" target="#formula_117">54</ref>)-( <ref type="formula" target="#formula_118">56</ref>) is</p><formula xml:id="formula_119">⎡ ⎣ y * (t) u * (t) ⎤ ⎦ = ⎡ ⎣ 1 1 1 + √ 2 1 - √ 2 ⎤ ⎦ ⎡ ⎣ e t √ 2 c 1 e -t √ 2 c 2 ⎤ ⎦ , ⎡ ⎣ c 1 c 2 ⎤ ⎦ = 1 e -t f √ 2 -e t f √ 2 ⎡ ⎣ 1.5e -t f √ 2 -1 1 -1.5e t f √ 2 ⎤ ⎦ . (<label>57</label></formula><formula xml:id="formula_120">)</formula><p>The exact solution for t f = 10000 is shown in Figs. <ref type="figure" target="#fig_14">4a</ref> and<ref type="figure" target="#fig_14">4b</ref> It is seen that the solution has an initial rapid decay segment followed by a long constant middle segment and a rapid terminal growth segment. Next, Fig. <ref type="figure" target="#fig_20">5a</ref> shows the mesh point history along with the regions where R &gt; R. Two key features of the hp method emerge from this example.</p><p>First, on the early meshes it is found that the hp method correctly assesses that the solution is much less smooth (R &gt; R) near the initial and terminal time, while the solution is smooth (R &lt; R) in the long constant middle segment. Next, the mesh interval merging procedure works well in that the hp method drastically reduces the size of the mesh in the middle constant segment while retaining the mesh points in the initial and terminal segments. Specifically, it is seen from Fig. <ref type="figure" target="#fig_20">5a</ref> that, upon reaching the 5 th mesh refinement (that is, M = 5), the collocation points are concentrated in extremely small segments near t = 0 and t = t f .</p><p>The hp mesh refinement method is now compared against various h methods and the previously developed ph mesh refinement method of Ref. <ref type="bibr" target="#b21">[22]</ref>. Figures <ref type="figure" target="#fig_20">5a-5d</ref> show the mesh refinement history for both the hp and the h -3 method (where the h -3 is the best performing of the methods other than the hp method on this example). It is seen from Figs. 5c and 5d that the h -3 improves accuracy by increasing significantly the number of collocation points and  the number of mesh intervals in the initial decay segment whereas the hp method improves accuracy by reducing the mesh size in these segments and concentrating the mesh points only in small segments near t = 0 and t = t f . Next, Tables 2a-2c provides a comparison between the hp and h methods for increasing values of t f . First, it is seen that the mesh size using the hp method is much smaller than either the h or the ph methods for all values of t f . Next, it is seen that the hp mesh size remains the same as t f increases, while the h and ph mesh sizes grow significantly as t f increases. In fact, the difference in the computation times for different values of t f using the hp method is due mostly to the increase in the number of mesh refinement iterations (where M = (5, 6, 7) for t f = (10000, 100000, 1000000), respectively). More importantly, the gap between the hp computation time and the (ph, h) computation time grows significantly as t f increases. The slow growth in computation time using the hp method is also seen in Tables 2a-2c and in Fig. <ref type="figure" target="#fig_20">5e</ref> where the hp computation times are (4.92, 12.84, 18.68) s for t f = (10000, 100000, 1000000), respectively. The computation times using using the h and ph methods, however, change by almost two orders of magnitude as t f increases from 10000 to 1000000. Finally, Table <ref type="table" target="#tab_3">2d</ref> provides a comparison between the hp mesh refinement method of this paper and the mesh refinement used in the optimal control software Sparse Optimization Suite (SOS). It is seen for t f = 10000 that the final SOS mesh is three times as large as the mesh obtained using the hp method. Furthermore, for t f = 100000 and t f = 1000000 the SOS meshes are approximately 5 and 22 times larger than the hp meshes.</p><p>Segments Where R &gt;       </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>Each of the examples illustrates different features of the hp mesh refinement method. The first example demonstrates the ability of the method to accurately determine locations of discontinuities in the solution by predicting correctly the segments where the solution is not smooth.</p><p>The second example highlights the ability of the hp method to significantly reduce the size of the mesh by eliminating collocation points and merging mesh intervals in regions where the solution does not change appreciably and shows that the method concentrates the collocation points in the region where the solution changes rapidly. In contrast, the ph method of Ref. <ref type="bibr" target="#b21">[22]</ref> does not allow for mesh size reduction and the mesh can only grow to satisfy the accuracy criterion. It is important to note that the performance of the ph method depends upon the choice of the parameters N min and N max while the performance of the hp method depends more strongly upon the choice of R and more weakly upon the choice of N max (because the maximum number of collocation points is attained only in rare cases). Furthermore, the numerical results indicate that, for an appropriate choice of R, the hp method can be more computationally efficient than the ph method for almost any choice of N min and N max . Finally, it is noted that, as with any mesh refinement method, the performance of the hp method depends upon the initial mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>A variable-order adaptive mesh refinement method for solving optimal control problems has been developed. The method has the ability to both increase and decrease the mesh size. The mesh refinement is guided by a previously derived convergence rate. Mesh interval refinement is performed in regions where the solution is nonsmooth, while the polynomial degree is increased in regions where the solution is smooth. Furthermore, the size of the mesh can be decreased either by dropping the negligible terms in a power series representation of the state or by combining mesh intervals that share the same polynomial approximation. The method is described in detail and applied successfully to two examples from the open literature. The results obtained in this research show that the method out performs fixed-order methods and a previously developed variable-order method.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>is the state approximation that results from the solution on mesh M. Let τ ij , (i = 1, . . . , n y , j = 1, . . . , L i ) be the values of τ ∈ [-1, +1] corresponding to the local maxima of | Ÿ (M ) i (τ )| that lie on the interior of mesh intervals. [that is, τ ij , (i = 1, . . . , n y , j = 1, . . . , L i ) are the interior local maxima of the absolute value of the i th component of the state, i ∈ [1, . . . , n y ], on mesh M]. For compactness, let P (M ) ij = | Ÿ (M ) i (τ ij )|, (i = 1, . . . , n y , j = 1, . . . , L i ). Similarly, let P (M -1) ij be the biggest interior local maximum of the function | Ÿ (M -1) i (τ )| in the mesh interval on mesh M -1 that contains a particular value τ ij from mesh M. The solution in the mesh interval S k , k ∈ [1, . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>and Y (k) (τ ) be the midpoint of the mesh interval, the mesh interval half-width, and the state approximation, respectively, in mesh interval S k . Then the Lagrange polynomial representation of the i th component of the state approximation, Y (k) i (τ ), is given as</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>i</head><label></label><figDesc>(τ ) and Y (k+1) i (τ ). The quantities used to normalize each of the absolute differences |Y (k) i (τ ) -Y (k+1) i (τ )| are the values β i , (i = 1, . . . , n y ) given in Eq. (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>14 for the hp method. Furthermore, the initial guess for all examples is a straight line for variables with boundary conditions at both endpoints and is a constant for variables with boundary conditions at only one endpoint. All computations were performed on a 2.5 GHz Intel Core i7 MacBook Pro running MAC OS-X version 10.8.5 (Mountain Lion) with 16GB 1333MHz DDR3 of RAM and MATLAB Version R2012b (build 7.13.0.564). The central processing unit (CPU) times reported in this paper are ten-run averages of the execution time and exclude the time required to solve the NLP on the first mesh (because for any example the CPU time required</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>u 1 (t) vs. t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>u 2 (t) vs. t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>u 3 (t) vs. t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Optimal Control for Example 1 Using the hp Method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>hp Mesh Point History.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>hp Collocation Point History.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>ph Mesh Point History.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>hp Mesh Point History Starting from Nine Equally Mesh Intervals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>log 10 (CPU time) vs. log 10 (N M ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Mesh Refinement History of Example 1 When Using the hp and ph -(3, 8) Methods. 24</figDesc><graphic coords="25,95.00,3.34,406.22,713.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: State Solution Near t = 0 and t = t f for Example 2 with t f = 10000 Using the hp Method.</figDesc><graphic coords="28,95.00,3.34,406.22,713.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>hp Mesh Point History.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>hp Collocation Point History.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>4 (c) h - 3</head><label>43</label><figDesc>Mesh Point History.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>4 (d) h - 3</head><label>43</label><figDesc>Collocation Point History.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>log 10 (CPU time) vs. log 10 (N M ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Mesh Refinement History of Example 2 When Using the hp and h -3 Methods. 29</figDesc><graphic coords="30,95.00,3.34,406.22,713.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Mesh Refinement Results for Example 1 Using hp and Various ph-(N min , N max ) Methods.</figDesc><table><row><cell cols="5">Method N min N max CPU Time (s) N</cell><cell>K M</cell></row><row><cell>hp</cell><cell>-</cell><cell>14</cell><cell>0.15</cell><cell cols="2">87 15 3</cell></row><row><cell>h</cell><cell>2</cell><cell>2</cell><cell>0.29</cell><cell cols="2">170 81 3</cell></row><row><cell>h</cell><cell>3</cell><cell>3</cell><cell>0.26</cell><cell cols="2">100 32 4</cell></row><row><cell>h</cell><cell>4</cell><cell>4</cell><cell>0.24</cell><cell cols="2">80 20 4</cell></row><row><cell>ph</cell><cell>3</cell><cell>8</cell><cell>0.19</cell><cell cols="2">78 18 4</cell></row><row><cell>ph</cell><cell>3</cell><cell>10</cell><cell>0.42</cell><cell cols="2">76 19 6</cell></row><row><cell>ph</cell><cell>3</cell><cell>12</cell><cell>0.57</cell><cell cols="2">88 22 7</cell></row><row><cell>ph</cell><cell>3</cell><cell>14</cell><cell>0.58</cell><cell cols="2">84 18 9</cell></row><row><cell>ph</cell><cell>4</cell><cell>8</cell><cell>0.27</cell><cell cols="2">86 18 4</cell></row><row><cell>ph</cell><cell>4</cell><cell>10</cell><cell>0.50</cell><cell cols="2">82 16 6</cell></row><row><cell>ph</cell><cell>4</cell><cell>12</cell><cell>0.42</cell><cell cols="2">84 19 6</cell></row><row><cell>ph</cell><cell>4</cell><cell>14</cell><cell>0.52</cell><cell cols="2">82 16 8</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>, while Figs. 4c and4d shows the state in the initial decay segment t ∈ [0, 50] and in the terminal growth segment t ∈ [9950, 10000].</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Mesh Refinement Results for Example 2 Using hp and Various ph-(N min , N max ) Methods.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">(b) t f = 100000.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Method N min N max CPU Time (s) N</cell><cell>K</cell><cell>M</cell><cell cols="5">Method N min N max CPU Time (s) N</cell><cell>K</cell><cell>M</cell></row><row><cell>hp</cell><cell>-</cell><cell>14</cell><cell>4.92</cell><cell>91</cell><cell>15</cell><cell>5</cell><cell>hp</cell><cell>-</cell><cell>14</cell><cell>12.84</cell><cell>91</cell><cell>17</cell><cell>6</cell></row><row><cell>h</cell><cell>2</cell><cell>2</cell><cell>7.69</cell><cell cols="3">638 315 5</cell><cell>h</cell><cell>2</cell><cell>2</cell><cell>58.10</cell><cell cols="3">732 362 6</cell></row><row><cell>h</cell><cell>3</cell><cell>3</cell><cell>7.55</cell><cell cols="3">421 139 6</cell><cell>h</cell><cell>3</cell><cell>3</cell><cell>42.07</cell><cell cols="3">508 168 8</cell></row><row><cell>h</cell><cell>4</cell><cell>4</cell><cell>10.85</cell><cell cols="2">380 95</cell><cell>7</cell><cell>h</cell><cell>4</cell><cell>4</cell><cell>26.34</cell><cell cols="3">452 113 9</cell></row><row><cell>ph</cell><cell>3</cell><cell>8</cell><cell>12.98</cell><cell cols="2">371 94</cell><cell>6</cell><cell>ph</cell><cell>3</cell><cell>8</cell><cell>46.03</cell><cell cols="3">456 121 7</cell></row><row><cell>ph</cell><cell>3</cell><cell>10</cell><cell>11.32</cell><cell cols="2">348 77</cell><cell>5</cell><cell>ph</cell><cell>3</cell><cell>10</cell><cell>37.49</cell><cell cols="3">431 101 7</cell></row><row><cell>ph</cell><cell>3</cell><cell>12</cell><cell>10.33</cell><cell cols="2">343 59</cell><cell>5</cell><cell>ph</cell><cell>3</cell><cell>12</cell><cell>34.95</cell><cell cols="2">418 80</cell><cell>6</cell></row><row><cell>ph</cell><cell>3</cell><cell>14</cell><cell>10.09</cell><cell cols="2">294 39</cell><cell>4</cell><cell>ph</cell><cell>3</cell><cell>14</cell><cell>46.66</cell><cell cols="2">385 56</cell><cell>6</cell></row><row><cell>ph</cell><cell>4</cell><cell>8</cell><cell>8.85</cell><cell cols="2">324 66</cell><cell>6</cell><cell>ph</cell><cell>4</cell><cell>8</cell><cell>32.77</cell><cell cols="2">397 83</cell><cell>8</cell></row><row><cell>ph</cell><cell>4</cell><cell>10</cell><cell>9.30</cell><cell cols="2">311 56</cell><cell>6</cell><cell>ph</cell><cell>4</cell><cell>10</cell><cell>34.79</cell><cell cols="2">371 69</cell><cell>7</cell></row><row><cell>ph</cell><cell>4</cell><cell>12</cell><cell>7.92</cell><cell cols="2">290 43</cell><cell>5</cell><cell>ph</cell><cell>4</cell><cell>12</cell><cell>27.59</cell><cell cols="2">356 49</cell><cell>8</cell></row><row><cell>ph</cell><cell>4</cell><cell>14</cell><cell>10.44</cell><cell cols="2">304 39</cell><cell>7</cell><cell>ph</cell><cell>4</cell><cell>14</cell><cell>26.53</cell><cell cols="2">357 48</cell><cell>8</cell></row><row><cell></cell><cell></cell><cell cols="2">(c) t f = 1000000.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">(d) SOS Mesh Refinement Summary.</cell><cell></cell><cell></cell></row><row><cell cols="5">Method N min N max CPU Time (s) N</cell><cell>K</cell><cell>M</cell><cell>t f</cell><cell cols="3">N min N max CPU Time (s)</cell><cell>N</cell><cell cols="2">K M</cell></row><row><cell>hp</cell><cell>-</cell><cell>14</cell><cell>18.68</cell><cell>92</cell><cell>17</cell><cell>7</cell><cell>10000</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>313</cell><cell cols="2">-11</cell></row><row><cell>h</cell><cell>2</cell><cell>2</cell><cell>260.31</cell><cell cols="3">814 401 7</cell><cell>100000</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>609</cell><cell cols="2">-13</cell></row><row><cell>h</cell><cell>3</cell><cell>3</cell><cell>95.02</cell><cell cols="3">593 196 10</cell><cell>1000000</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell cols="3">2284 -15</cell></row><row><cell>h</cell><cell>4</cell><cell>4</cell><cell>109.37</cell><cell cols="3">568 142 10</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>3</cell><cell>8</cell><cell>115.56</cell><cell cols="3">532 144 8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>3</cell><cell>10</cell><cell>103.54</cell><cell cols="3">517 129 9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>3</cell><cell>12</cell><cell>77.63</cell><cell cols="3">492 106 7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>3</cell><cell>14</cell><cell>67.04</cell><cell cols="2">450 70</cell><cell>7</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>4</cell><cell>8</cell><cell>106.30</cell><cell cols="3">476 102 9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>4</cell><cell>10</cell><cell>79.74</cell><cell cols="2">461 90</cell><cell>9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>4</cell><cell>12</cell><cell>76.42</cell><cell cols="2">436 67</cell><cell>8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ph</cell><cell>4</cell><cell>14</cell><cell>82.06</cell><cell cols="2">416 57</cell><cell>9</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>(a) t f = 10000.</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors gratefully acknowledge support for this research from the U.S. Office of Naval Research under grants N00014-11-1-0068 and N00014-15-1-2048, from the U.S. Defense Advanced Research Projects Agency under Contract HR0011-12-C-0011, and from the U.S. National Science Foundation under grant CBET-1404767.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(53)</p><p>It is known for this problem that the optimal control has five discontinuities at t ≈ (2.286, 2.827, 4.570, 6.385, 6.855). Figures. 2a-2c show the three components of the optimal control obtained by solving the optimal control problem of Eqs. ( <ref type="formula">48</ref>)-( <ref type="formula">51</ref>) where these control discontinuities are clearly seen. Next, Fig. <ref type="figure">3a</ref> shows the evolution of the mesh points for this example where it is seen that the second derivative ratio, R, is greater than the threshold R = 1.2 in segments that contain four of the five control discontinuities, while the fifth (middle) discontinuity is already accurately located due to the fact that a mesh point is located at t ≈ 4.570. Furthermore, it is seen that the mesh continues to be refined only in neighborhoods of the discontinuities because the solution is smooth outside of these small segments. Thus, the error outside of the neighborhoods of the discontinuities is reduced by increasing the degree of the polynomial approximation and not by dividing mesh intervals. Moreover, it is seen that the mesh quickly progresses to a point where the accuracy tolerance is satisfied and stops after three (M = 3) mesh refinements. Now, in order to demonstrate that the hp method correctly identifies all of the discontinuities even when none of the initial mesh points lie close to a discontinuity, consider now the hp mesh refinement using an initial mesh that consists of nine equally spaced mesh intervals. The mesh history for this initial mesh is shown in Fig. <ref type="figure">3e</ref>. As alluded to earlier, this alternate initial mesh does contain a mesh point that lies close to a discontinuity. As the mesh refinement progresses from this initial mesh it is seen in Fig. <ref type="figure">3e</ref> that the mesh interval S = <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> is found to be nonsmooth (R &gt; R) on the second mesh (M = 1) and the hp method divides this mesh interval into two equally spaced mesh intervals in order to meet the accuracy tolerance. Furthermore, as with the initial ten-interval mesh, it is seen for the initial nine-interval mesh that the hp method adds mesh intervals that either closely surround or lie at the location of the five discontinuities and adds very few mesh points anywhere else on the interval [0, t f ].</p><p>The hp mesh refinement method is now compared against various h methods and the pre-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Disclaimer</head><p>The views, opinions, and findings contained in this article are those of the authors and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">SNOPT: An SQP Algorithm for Large-Scale Constrained Optimization</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Saunders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Review</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="99" to="131" />
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Large-Scale Nonlinear Programming Using IPOPT: An Integrating Framework for Enterprise-Wide Optimization</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Biegler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">M</forename><surname>Zavala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Chemical Engineering</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="575" to="582" />
			<date type="published" when="2008-03">March 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Practical Methods for Optimal Control and Estimation Using Nonlinear Programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Betts</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>SIAM Press</publisher>
			<pubPlace>Philadelphia, 2nd</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Trajectory Optimization Using Multiresolution Techniques</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tsiotras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Control, and Dynamics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1424" to="1436" />
			<date type="published" when="2008-10">September-October 2008</date>
		</imprint>
	</monogr>
	<note>Journal of Guidance</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Density Functions for Mesh Refinement in Numerical Optimal Control</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tsiotras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Guidance, Control, and Dynamics</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="271" to="277" />
			<date type="published" when="2011-02">January-February 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Pseudospectral Legendre Method for Discretizing Optimal Control Problems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Elnagar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kazemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Razzaghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1793" to="1796" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Collocation-Type Method for Linear Quadratic Optimal Control Problems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Elnagar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Razzaghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optimal Control Applications and Methods</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="227" to="235" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Costate Estimation by a Legendre Pseudospectral Method</title>
		<author>
			<persName><forename type="first">F</forename><surname>Fahroo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Guidance, Control, and Dynamics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="277" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Direct Trajectory Optimization by a Chebyshev Pseudospectral Method</title>
		<author>
			<persName><forename type="first">F</forename><surname>Fahroo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Guidance, Control, and Dynamics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="160" to="166" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Direct Trajectory Optimization and Costate Estimation via an Orthogonal Collocation Method</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Huntington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Thorvaldsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Guidance, Control, and Dynamics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1435" to="1440" />
			<date type="published" when="2006-12">November-December 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Optimal Configuration of Tetrahedral Spacecraft Formations</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Huntington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of the Astronautical Sciences</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="141" to="169" />
			<date type="published" when="2007-06">April-June 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal Reconfiguration of Spacecraft Formations Using the Gauss Pseudospectral Method</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Huntington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Guidance, Control, and Dynamics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="689" to="698" />
			<date type="published" when="2008-06">May-June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Spectral Algorithm for Pseudospectral Methods in Optimal Control</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fahroo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Guidance, Control, and Dynamics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2008-06">May-June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Connections Between the Covector Mapping Theorem and Convergence of Pseudospectral Methods</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fahroo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Optimization and Applications</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="307" to="335" />
			<date type="published" when="2008-12">December 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Algorithm 902: GPOPS, A Matlab Software for Solving Multiple-Phase Optimal Control Problems Using the Gauss Pseudospectral Method</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Darby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Francolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Huntington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2010-06">April-June 2010</date>
		</imprint>
	</monogr>
	<note>Article 22, 39 pages</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Direct Trajectory Optimization and Costate Estimation of Finite-Horizon and Infinite-Horizon Optimal Control Problems via a Radau Pseudospectral Method</title>
		<author>
			<persName><forename type="first">D</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Darby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Francolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Huntington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10589-00-09291-0</idno>
	</analytic>
	<monogr>
		<title level="j">Computational Optimization and Applications</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="335" to="358" />
			<date type="published" when="2011-06">June 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Unified Framework for the Numerical Solution of Optimal Control Problems Using Pseudospectral Methods</title>
		<author>
			<persName><forename type="first">D</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Huntington</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.automatica.2010.06.048</idno>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1843" to="1851" />
			<date type="published" when="2010-11">November 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Pseudospectral Methods for Solving Infinite-Horizon Optimal Control Problems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.automatica.2011.01.085</idno>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="829" to="837" />
			<date type="published" when="2011-04">April 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Convergence Rates for Direct Transcription of Optimal Control Problems Using Collocation at Radau Points</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kameswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Biegler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Optimization and Applications</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="126" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An hp-Adaptive Pseudospectral Method for Solving Optimal Control Problems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Darby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optimal Control Applications and Methods</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="476" to="502" />
			<date type="published" when="2011-08">July-August 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Direct Trajectory Optimization Using a Variable Low-Order Adaptive Pseudospectral Method</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Darby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Spacecraft and Rockets</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="433" to="445" />
			<date type="published" when="2011-06">May-June 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A ph Mesh Refinement Method for Optimal Control</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<idno type="DOI">10.1002/oca2114</idno>
	</analytic>
	<monogr>
		<title level="m">Optimal Control Applications and Methods, Published Online in Early View</title>
		<imprint>
			<date type="published" when="2014-01">January 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Costate Approximation in Optimal Control Using Integral Gaussian Quadrature Collocation Methods</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Francolin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<idno type="DOI">10.1002/oca2112</idno>
	</analytic>
	<monogr>
		<title level="m">Optimal Control Applications and Methods, Published Online in Early View</title>
		<imprint>
			<date type="published" when="2014-01">January 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Canuto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Hussaini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Quarteroni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Zang</surname></persName>
		</author>
		<title level="m">Spectral Methods in Fluid Dynamics</title>
		<meeting><address><addrLine>Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Spinger-Verlag</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A Practical Guide to Pseudospectral Methods</title>
		<author>
			<persName><forename type="first">B</forename><surname>Fornberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Trefethen</surname></persName>
		</author>
		<title level="m">Spectral Methods Using MATLAB</title>
		<meeting><address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<publisher>SIAM Press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Spectral Algorithm for Pseudospectral Methods in Optimal Control</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fahroo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Guidance, Control and Dynamics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="460" to="471" />
			<date type="published" when="2008-06">May-June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Variable Resolution Discretization in Optimal Control</title>
		<author>
			<persName><forename type="first">R</forename><surname>Munos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="291" to="323" />
			<date type="published" when="2002-12">November-December 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">An Adaptive Grid Scheme for the Discrete Hamilton-Jacobi-Bellman Equation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Grune</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="319" to="337" />
			<date type="published" when="1997-01">January 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Adaptive Finite Element Discretization of Flow Problems for Goal-Oriented Model Reduction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rannacher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Fluid Dynamics</title>
		<imprint>
			<biblScope unit="page" from="31" to="45" />
			<date type="published" when="2008">2008. 2009</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Goal-Oriented Space-Time Adaptivity in the Finite Element Galerkin Method for the Computation of Nonstationary Incompressible Flow</title>
		<author>
			<persName><forename type="first">M</forename><surname>Besier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rannacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal for Numerical Methods in Fluids</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1139" to="1166" />
			<date type="published" when="2012-11">November 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The p and hp Version of the Finite Element Method, an Overview</title>
		<author>
			<persName><forename type="first">I</forename><surname>Babuska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Methods in Applied Mechanics and Engineering</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="5" to="26" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The p and hp Version of the Finite Element Method, Basic Principles and Properties</title>
		<author>
			<persName><forename type="first">I</forename><surname>Babuska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Review</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="578" to="632" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The h, p, and hp Versions of the Finite Element Method in 1 Dimension. Part I. The Error Analysis of the p Version</title>
		<author>
			<persName><forename type="first">W</forename><surname>Gui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Babuska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="577" to="612" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The h, p, and hp Versions of the Finite Element Method in 1 Dimension. Part II. The Error Analysis of the h and h -p Versions</title>
		<author>
			<persName><forename type="first">W</forename><surname>Gui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Babuska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="613" to="657" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The h, p, and hp Versions of the Finite Element Method in 1 Dimension. Part III. The Adaptive h -p Version</title>
		<author>
			<persName><forename type="first">W</forename><surname>Gui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Babuska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="659" to="683" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Piecewise Smooth Chebfuns</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pachon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Platte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Trefethen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IMA Journal of Numerical Analysis</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="898" to="916" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Convergence Analysis of Orthogonal Collocation Methods for Unconstrained Optimal Control</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-08">August 2013</date>
		</imprint>
		<respStmt>
			<orgName>University of Florida</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">An hp Mesh Refinement Method for Optimal Control Using Discontinuity Detection and Mesh Size Reduction</title>
		<author>
			<persName><forename type="first">F</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Hager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE Conference on Decision and Control</title>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-12">December 2014</date>
			<biblScope unit="page" from="5868" to="5873" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abramowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stegun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1965">1965</date>
			<publisher>Dover Publications</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Benchmarking optimization software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dolan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>More</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Munson</surname></persName>
		</author>
		<idno>with CPOPS 3.0</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>Argonne, IL</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Argonne National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. ANL/MCS-273</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Eigenvector Approximate Dichotomic Basis Method for Solving Hyper-Sensitive optimal Control Problems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">D</forename><surname>Mease</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optimal Control Applications and Methods</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2000-02">January-February 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">GPOPS -II, A MATLAB Software for Solving Multiple-Phase Optimal Control Problems Using hp-Adaptive Gaussian Quadrature Collocation Methods and Sparse Nonlinear Programming</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">37</biblScope>
			<date type="published" when="2015-10">October 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A Source Transformation via Operator Overloading Method for the Automatic Differentiation of Mathematical Functions in MAT-LAB</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Weinstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Rao</surname></persName>
		</author>
		<ptr target="http://vdol.mae.ufl.edu/SubmittedJournalPublications/gatorad-TOMS-November-2013.pdf" />
	</analytic>
	<monogr>
		<title level="m">Revision</title>
		<imprint>
			<date type="published" when="2014-04">April 2014</date>
		</imprint>
	</monogr>
	<note>Current manuscript available</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Piecewise-smooth chebfuns</title>
		<author>
			<persName><forename type="first">R</forename><surname>Pachón</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Platte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">N</forename><surname>Trefethen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IMA Journal of Numerical Analysis</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="898" to="916" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Sparse Optimal Control Software -SOCS</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Betts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Huffman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-07">July 1997</date>
			<publisher>Boeing Information and Support Services</publisher>
			<pubPlace>Seattle, Washington</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. MEA-LR-085</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
