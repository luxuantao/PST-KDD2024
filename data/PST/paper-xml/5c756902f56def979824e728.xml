<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Branch-and-reduce exponential/FPT algorithms in practice: A case study of vertex cover ✩</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2015-09-28">28 September 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Takuya</forename><surname>Akiba</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">National Institute of Informatics</orgName>
								<address>
									<addrLine>2-1-2 Hitotsubashi, Chiyoda-ku</addrLine>
									<settlement>Tokyo</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Yoichi</forename><surname>Iwata</surname></persName>
							<email>y.iwata@is.s.u-tokyo.ac.jp</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Tokyo</orgName>
								<address>
									<addrLine>7-3-1 Hongo, Bunkyo-ku</addrLine>
									<settlement>Tokyo</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Branch-and-reduce exponential/FPT algorithms in practice: A case study of vertex cover ✩</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-09-28">28 September 2015</date>
						</imprint>
					</monogr>
					<idno type="MD5">B3EFBCA52A411CF10BB32B402EFA0958</idno>
					<idno type="DOI">10.1016/j.tcs.2015.09.023</idno>
					<note type="submission">Received 3 June 2015 Received in revised form 24 August 2015 Accepted 21 September 2015</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Branch-and-reduce Vertex cover Exact exponential algorithms FPT algorithms</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We investigate the gap between theory and practice for exact branching algorithms. In theory, branch-and-reduce algorithms currently have the best time complexity for numerous important problems. On the other hand, in practice, state-of-the-art methods are based on different approaches, and the empirical efficiency of such theoretical algorithms has seldom been investigated probably because they are seemingly inefficient because of the plethora of complex reduction rules. In this paper, we design a branchand-reduce algorithm for the vertex cover problem using the techniques developed for theoretical algorithms and compare its practical performance with other state-of-the-art empirical methods. The results indicate that branch-and-reduce algorithms are actually quite practical and competitive with other state-of-the-art approaches for several kinds of instances, thus showing the practical impact of theoretical research on branching algorithms.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Branching algorithms have been both theoretically and experimentally well studied to exactly solve NP-hard problems. However, there is a gap between the theoretically fastest algorithms (i.e., those currently having the best time complexity) and the empirically fastest algorithms (i.e., those currently with the best running time for popular benchmark instances). In the theoretical research on exponential complexity or parameterized complexity of branching algorithms, branch-and-reduce methods, which involve a plethora of branching and reduction rules without using any lower bounds, currently have the best time complexity for a number of important problems, such as Independent Set (or, equivalently, Vertex Cover) <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b5">6]</ref>, Dominating Set <ref type="bibr" target="#b12">[13]</ref>, and Directed Feedback Vertex Set <ref type="bibr" target="#b18">[19]</ref>. On the other hand, in practice, branch-and-bound methods that involve problem-specific lower bounds or LP-based branch-and-cut methods, which generate new cuts to improve the lower bounds, are often used. While a number of complex rules have been developed to improve time complexity in theoretical research, they seldom have been used for these empirical methods.</p><p>In this paper, we study the practical impact of theoretical research on branching algorithms. As a benchmark problem, we choose Vertex Cover because it has been both theoretically and empirically well studied. In this study, we design an algorithm that combines a variety of rules and lower bounds from several theoretical studies. We also develop new rules, called the packing branching and packing reduction rules, which are inspired by these previous studies. Then, we conduct experiments on a variety of instances and compare our algorithm with two state-of-the-art empirical methods: a branchand-cut method by a commercial integer programming solver, CPLEX, and a branch-and-bound method called MCS <ref type="bibr" target="#b21">[22]</ref>. Although the rules in our algorithm are not designed for specific instances but are developed for theoretical purposes, the results show that our algorithm is actually quite practical and competitive with other state-of-the-art approaches for several cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Relations to theoretical research on exact algorithms for vertex cover</head><p>We introduce recent theoretical research on exact algorithms for Vertex Cover. Two types of research exist: exact exponential algorithms, which analyze the exponential complexity with regard to the number of vertices, and FPT algorithms, which introduce a parameter to the problem and analyze the parameterized complexity with regard to both the parameter and the graph size.</p><p>First, we explain how the algorithms are designed and analyzed using a simple example. Let us consider a very simple algorithm that selects a vertex v and branches into two cases: either 1) including v to the vertex cover or 2) discarding v while including its neighbors to the vertex cover. Apparently, this algorithm runs in O * (2 n ) time, where the notation O * hides factors polynomial in n. Can we prove a better complexity? The answer to this question would be No. When a graph is a set of n isolated vertices, the algorithm needs to branch on each vertex, which takes * (2 n ) time. To avoid this worst case, we can add the following reduction rule: if a graph is not connected, we can solve each connected component separately. Now, we can assume that v has a degree of at least one. Then, after the second case of the branching, where v is discarded and its neighbors are included, the number of vertices to be considered decreases by at least two. Let T (n) be a time bound for solving an n-vertex instance. By solving the recurrence of T (n) ≤ T (n -1) + T (n -2), we can prove a complexity of O * (1.6181 n ). The worst case occurs when we continue to select a vertex of degree one. Here, we note that if n is at least three, a vertex of degree at least two always exists. Thus, by adding the following branching rule, we can avoid this worst case: select a vertex of the maximum degree. Now, we can assume that v has a degree of at least two, and by solving the recurrence of T (n) ≤ T (n -1) + T (n -3), we can prove the complexity of O * (1.4656 n ). We continue this process and create increasingly complex rules to avoid the worst case and improve the complexity. Thus, currently, the theoretically fastest algorithms involve a number of complicated rules. Although much of the current research uses a more sophisticated analytical tool called the measure and conquer analysis <ref type="bibr" target="#b8">[9]</ref>, the design process is basically the same.</p><p>As for exact exponential algorithms, since Fomin, Grandoni, and Kratsch <ref type="bibr" target="#b8">[9]</ref> gave an O * (1.2210 n )-time algorithm by developing the measure and conquer analysis, several improved algorithms have been developed <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b24">25]</ref>. Since improving the complexity on sparse graphs is known to also improve the complexity on general graphs <ref type="bibr" target="#b4">[5]</ref>, algorithms for sparse graphs also have been well studied <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b24">25]</ref>. Among these algorithms, we use rules from the algorithm for general graphs by Fomin et al. <ref type="bibr" target="#b8">[9]</ref>, and the algorithm for sparse graphs by Xiao and Nagamochi <ref type="bibr" target="#b24">[25]</ref>. These rules are also contained in many of the other algorithms. We also develop new rules inspired from the satellite rule presented by Kneis, Langer, and Rossmanith <ref type="bibr" target="#b15">[16]</ref>.</p><p>On FPT algorithms, Vertex Cover has been studied under various parameterizations. Among them, the difference between the LP lower bound and the IP optimum is a recently developed parameter; however, many interesting results have already been obtained <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b22">23]</ref>. While the exact exponential algorithms do not use any lower bounds to prune the search, with this parameterization, the current fastest algorithms are based on the branch-and-bound method and use a (simple) LP lower bound to prune the search. Let k be the parameter value, i.e., the difference between the LP lower bound and the IP optimum. In our algorithm, we use an LP-based reduction rule from the O (4 k m + m √ n) <ref type="foot" target="#foot_0">3</ref> -time algorithm by Iwata, Oka, and Yoshida <ref type="bibr" target="#b13">[14]</ref> and the LP lower bound. Since we do not give the parameter to the algorithm, its search space may not be bounded by the parameter. However, if we were to use the iterative deepening strategy (we do not use it in this experiment), the running time of our algorithm would also be bounded by O * (4 k ). The research on this parameterization also suggests that for many other problems, including Odd Cycle Transversal, the fastest way to solve them is to reduce them into Vertex Cover. Therefore, we conduct experiments on the graph reduced from an instance of Odd Cycle Transversal. The results show that solving Odd Cycle Transversal through the reduction to Vertex Cover strongly outperforms the state-of-the-art algorithm for Odd Cycle Transversal. In our experiments, we used two different lower bounds that may give a better lower bound than LP relaxation. We also investigated the parameterized complexity above these lower bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.">Organization</head><p>In Section 2, we give definitions used in this paper. The overview of our algorithm is described in Section 3. In Sections 4, 5, and 6, we give a list of the branching rules, the reduction rules used in our algorithm, and the lower bounds we use, respectively. We investigate the parameterized complexity above the lower bounds we use in Section 7. We explain our experimental results in Section 8. Finally, we conclude in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1</head><p>The branch-and-reduce algorithm for Vertex Cover. (G, P, c) ← Reduce(G, P, c)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3:</head><p>if Unsatisfied(P) then return k 4:</p><formula xml:id="formula_0">if c + LowerBound(G) ≥ k then return k 5: if G is empty then return c 6: if G is not connected then 7:</formula><p>for all (G i , P i ) ∈ Components(G, P) do 8:</p><formula xml:id="formula_1">c ← c + Solve(G i , P i , 0, k -c) 9:</formula><p>return min(k, c) 10:</p><formula xml:id="formula_2">((G 1 , P 1 , c 1 ), (G 2 , P 2 , c 2 )) ← Branch(G, P, c) 11: k ← Solve(G 1 , P 1 , c 1 , k)</formula><p>Updating the upper bound k by trying the first case. 12:</p><formula xml:id="formula_3">k ← Solve(G 2 , P 2 , c 2 , k)</formula><p>The updated k is used to bound the search space for the second case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>return k k has been updated by the minimum of the two cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>Let G = (V , E) be an undirected graph. The degree of a vertex v is denoted by d(v). We denote the neighborhood of a vertex v by N(v) = {u ∈ V | uv ∈ E} and the closed neighborhood by N[v] = N(v) ∪ {v}. For a vertex subset S ⊆ V , we use the notation of N(S) = v∈S N(v) \ S and N[S] = N(S) ∪ S. The set of vertices at distance d from a vertex v is denoted by N d (v). For a vertex subset S ⊆ V , we denote the induced subgraph on the vertex set V \ S by G -S. When S is a single vertex v, we simply write Gv.</p><p>A vertex cover of a graph G is a vertex subset C ⊆ V such that, for any edge e ∈ E, at least one of its endpoints are contained in C . We denote the set of all minimum vertex covers of G by vc(G). Vertex Cover is a problem to find a minimum vertex cover of a given graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Algorithm overview</head><p>The overview of our algorithm is described in Algorithm 1. For ease of presentation, the described algorithm only addresses the size of the minimum vertex cover. However, obtaining the minimum vertex cover itself is not difficult. Indeed, in our experiments, the minimum vertex cover is also computed, and the time consumption to accomplish this is also accumulated. The packing constraints in the algorithm are created by our new branching and reduction rules. They are not used to strengthen the LP relaxation, as in the branch-and-cut methods, but are used for the pruning and the reduction. We describe the details in Sections 4.4 and 5.4. We start the algorithm by setting P = ∅, c = 0, and k = |V |. On each branching node, we first apply a list of reduction rules. Then, we prune the search if the packing constraints are not satisfied or if the lower bound is at least the size of the best solution we have. If the graph is empty, we update the best solution. If the graph is not connected, we separately solve each connected component. Otherwise, we branch into two cases by applying the branching rule. In our implementation, for time and space efficiency, we do not create new graphs after the branching but dynamically modify a single graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Branching rules</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Vertex selection</head><p>In our main implementation, we completely use the same strategy as the one used in the theoretical exact exponential algorithm by Fomin et al. <ref type="bibr" target="#b8">[9]</ref> for selecting a vertex to branch on. Basically, a vertex of the maximum degree is selected. If there are multiple possibilities, we choose the vertex v that minimizes the number of edges among N(v). In our experiments (Section 8.3.1), we compare this strategy to the random selection strategy and the minimum degree selection strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Mirror branching</head><formula xml:id="formula_4">For a vertex v, a vertex u ∈ N 2 (v) is called a mirror of v if N(v) \ N(u)</formula><p>induces a clique or is an empty set. We denote the set of mirrors for v by M(v) and use the notation of M[v] = M(v) ∪ {v}. For the mirror branching rule by Fomin et al. <ref type="bibr" target="#b8">[9]</ref>, we branch into two cases: 1) including M <ref type="bibr">[v]</ref> to the vertex cover or 2) discarding v while including N(v) to the vertex cover. In our implementation, we use this branching rule when the selected vertex v has mirrors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Satellite branching</head><formula xml:id="formula_5">For a vertex v, a vertex u ∈ N 2 (v) is called a satellite of v if there exists a vertex w ∈ N(v) such that N(w) \ N[v] = {u}.</formula><p>We denote the set of satellites for v by S(v) and use the notation of S[v] = S(v) ∪ {v}. Kneis et al. <ref type="bibr" target="#b15">[16]</ref> introduced the following satellite branching rule for the case in which there are no mirrors: 1) including v to the vertex cover or 2) discarding S(v) while including N(S(v)) to the vertex cover. In our implementation, instead of using this branching rule, we use a more powerful branching rule introduced in the next subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Packing branching</head><p>Let v be the selected vertex to branch on. The proof outline for the correctness of the satellite branching is as follows. If there exists a minimum vertex cover of G that contains the vertex v, we can find it by searching for a minimum vertex cover of Gv. Otherwise, we can assume that no minimum vertex covers contain the vertex v. If there exists a minimum vertex cover C of G that does not contain the vertex v but contains a satellite u ∈ S(v), then by discarding the vertex w ∈ N(v) that satisfies N(w) \ N[v] = {u} from C and including v to C , we obtain a vertex cover that contains the vertex v of the same size, which is a contradiction.</p><p>The key idea of satellite branching is that during the search for a minimum vertex cover that does not contain the vertex v, we can assume that there are no minimum vertex covers that contain the vertex v. To avoid the search of vertex covers from which we can confirm the existence of a vertex cover of the same size containing v, we exploit this idea by explicitly creating constraints as follows.</p><formula xml:id="formula_6">For a vertex w ∈ N(v), let N + (w) = N(w) \ N[v].</formula><p>During the search for a minimum vertex cover that does not contain v, if we include all the vertices of N + (w) to the vertex cover, by discarding the vertex w and including the vertex v, we can obtain a vertex cover of the same size. Thus, in the search for a minimum vertex cover that does not contain v, for each vertex w ∈ N(v), we can introduce a constraint of u∈N + (w) x u ≤ |N + (w)| -1, where x u is a variable that indicates whether the vertex u is in the vertex cover <ref type="bibr" target="#b0">(1)</ref> or not (0). We call these constraints packing constraints. We keep and manage the constraints during the search; when we include a vertex v to the vertex cover, for each constraint that contains the variable x v , we delete the variable and decrease the right-hand side by one, and when we delete a vertex v from the graph without including it to the vertex cover, for each constraint that contains the variable x v , we delete the variable while keeping its right-hand side. When some constraint is not satisfied at some node, i.e., the right-hand side of the constraint becomes negative, we prune the subsequent search from the node. We note that without packing constraints, we can prune the search only when the graph becomes empty or when the lower bound exceeds the best solution we have found so far.</p><p>We can also introduce a packing constraint when we search for a minimum vertex cover that contains a vertex v. If all the neighbors of v are contained in the vertex cover, by discarding v, we can obtain a vertex cover of smaller size. Thus, in the search for a minimum vertex cover that contains v, we can introduce a constraint of</p><formula xml:id="formula_7">u∈N(v) x u ≤ |N(v)| -1.</formula><p>Moreover, we can also use packing constraints for reductions. If the right-hand side of a constraint becomes zero but the left-hand side contains a variable x u , we can delete the vertex u from the graph while including its neighbors N(u) to the vertex cover. The satellite branching corresponds to the case that N + (w) is a single vertex set. In Section 5.4, we introduce more sophisticated reduction rules to exploit packing constraints.</p><p>We note that the total size of packing constraints scales at most linearly with the graph size because we create at most one constraint for each vertex w and the size of each constraint is at most the degree of the corresponding vertex. Thus explicitly keeping all the constraints does not seriously affect the computation time. We also note that packing constraints are auxiliary; i.e., our objective is not to search for a minimum vertex cover under the constraints but to search for a minimum vertex cover or conclude that there exists a minimum vertex cover not satisfying the constraints (which can be found in another case of the branching).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Reduction rules</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Reductions from exponential algorithms</head><p>First, we introduce four reduction rules from the exact exponential algorithm by Fomin et al. <ref type="bibr" target="#b8">[9]</ref>. Three of them are quite simple. The first one is the components rule. When a graph is not connected, we can solve for each component separately. The second one is the degree-1 rule. If a graph contains a vertex of degree at most one, there always exists a minimum vertex cover that does not contain the vertex. Therefore, we can delete it and include its neighbors to the vertex cover.</p><p>The third one is the dominance rule. We say a vertex v dominates a vertex</p><formula xml:id="formula_8">u if N[u] ⊆ N[v].</formula><p>If a vertex v dominates some vertex, there always exists a minimum vertex cover that contains v. Therefore, we can include it to the vertex cover. We note that the degree-1 rule is completely contained in the components rule and the dominance rule. However, it is still useful because its computational cost is smaller in practice. The final rule, degree-2 folding, is somewhat tricky. It removes a vertex of degree two and its neighbors while introducing a new vertex as in the following lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1 (Degree-2 folding). (See [9].) Let v be a vertex of degree two whose two neighbors are not adjacent, and let G be a graph obtained from G by removing N[v], introducing a new vertex w which is connected to N 2 (v). Then, for any</head><formula xml:id="formula_9">C ∈ vc(G ), the following C is in vc(G): C = C ∪ {v} (w / ∈ C ), (C \ {w}) ∪ N(v) (w ∈ C ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Reductions from FPT algorithms</head><p>We use the LP-based reduction rule which was first developed by Nemhauser and Trotter <ref type="bibr" target="#b17">[18]</ref>, and then, strengthened by Iwata, Oka, and Yoshida <ref type="bibr" target="#b13">[14]</ref>.</p><p>The LP relaxation of Vertex Cover can be written as follows:</p><formula xml:id="formula_10">minimize v∈V x v s.t. x u + x v ≥ 1 for uv ∈ E, x v ≥ 0 f o rv ∈ V .</formula><p>Nemhauser and Trotter <ref type="bibr" target="#b17">[18]</ref> showed that the above LP has the following two properties:</p><p>• There exists an optimal solution such that each variable takes a value 0, 1, or 1 2 (Half-integrality).</p><p>• If a variable x v takes an integer value in an optimal LP solution, there always exists an optimal integer solution in which</p><p>x v takes the same value (Persistency).</p><p>They also showed that a half-integral optimal solution of the LP relaxation can be computed by reducing it to the bipartite matching problem as follows. From the input graph G = (V , E), we construct a bipartite graph Ḡ = (L V ∪ R V , Ē) such that:</p><formula xml:id="formula_11">L V = {l v | v ∈ V }, R V = {r v | v ∈ V }, Ē = {l u r v | uv ∈ E} ∪ {l v r u | uv ∈ E}.</formula><p>Let C be a minimum vertex cover of the bipartite graph Ḡ, which can be computed in linear-time from a maximum matching of Ḡ. Then, the value of x * v of the half-integral optimal solution is determined as follows:</p><p>x</p><formula xml:id="formula_12">* v = ⎧ ⎪ ⎨ ⎪ ⎩ 0 (l v , r v / ∈ C), 1 (l v , r v ∈ C), 1 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(otherwise).</head><p>From the persistency of the LP relaxation, we can fix the integral part of a half-integral optimal solution; i.e., we can discard the vertices of value zero and include the vertices of value one to the vertex cover.</p><p>Iwata, Oka, and Yoshida <ref type="bibr" target="#b13">[14]</ref> presented an algorithm for computing a half-integral optimal solution of the LP relaxation whose half-integral part is minimal. We call such an optimal solution an extreme optimal solution. The algorithm runs in linear time after computing a maximum matching of the graph described above. Instead of using an arbitrary half-integral optimal solution, we use a half-integral extreme optimal solution computed by this algorithm. If x * is a half-integral extreme optimal solution, the graph induced on the half-integral part has a unique optimal solution of the all-half vector. Thus no more vertices can be deleted by using other optimal solutions. We note that the famous crown reduction rule <ref type="bibr" target="#b0">[1]</ref> is completely contained in the LP reduction rule if we use an extreme optimal solution. Thus, we do not use it in our algorithm.</p><p>In our implementation, we compute the maximum matching by using the Hopcroft-Karp algorithm <ref type="bibr" target="#b10">[11]</ref>, which runs in</p><formula xml:id="formula_13">O (|E| √ |V |) time.</formula><p>When the graph is changed by reductions or branchings, we do not recompute the maximum matching from scratch but modify the current non-maximum matching to the maximum one by searching for augmenting paths of the residual graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Reductions from exponential algorithms for sparse graphs</head><p>Now, we introduce the four reduction rules that appeared in the exact exponential algorithm for sparse graphs by Xiao and Nagamochi <ref type="bibr" target="#b23">[24]</ref>. These rules are very complicated, but as we see in Section 8, they are quite useful in practice.</p><p>The first rule, unconfined, is a generalization of the dominance and the satellite rules by Kneis et al. <ref type="bibr" target="#b15">[16]</ref>. A vertex v is called unconfined if the following procedure returns yes:</p><formula xml:id="formula_14">1. Let S = {v}. 2. Find u ∈ N(S) such that |N(u) ∩ S| = 1 and |N(u) \ N[S]| is minimized. 3. If there is no such vertex, return no. 4. If N(u) \ N[S] = ∅, return yes. 5. If N(u) \ N[S]</formula><p>is a single vertex w, go back to line 2 by adding w to S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Return no.</head><p>For any unconfined vertex v, there always exists a minimum vertex cover that contains v. Thus, we can include it to the vertex cover.</p><p>The second rule, twin, is similar to the degree-2 folding rule. Two vertices u and v are called a twin if</p><formula xml:id="formula_15">N(u) = N(v) and d(u) = d(v) = 3.</formula><p>If there is a twin, we can make the graph smaller, as in the following lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2 (Twin). (See [24].) Let u and v be a twin. If there exists an edge among N(u), for any C ∈ vc(G -N[{u, v}]), C ∪ N(u) ∈ vc(G). Otherwise, let G be a graph obtained from G by removing N[{u, v}], introducing a new vertex w connected to N 2 (u) \ {v}.</head><p>Then, for any C ∈ vc(G ), the following C is in vc(G): </p><formula xml:id="formula_16">C = C ∪ {u, v} (w / ∈ C ), (C \ {w}) ∪ N(u) (w ∈ C ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 (Alternative). (See [24].) Let A, B be alternative subsets of vertices, and G be a graph obtained from G by removing (N(A) ∩ N(B)) ∪ A ∪ B and introducing an edge between every two nonadjacent vertices u ∈</head><formula xml:id="formula_17">N( A) \ N[B] and v ∈ N(B) \ N[ A]. Then, for any C ∈ vc(G ), the following C is in vc(G): C = C ∪ (N(A) ∩ N(B)) ∪ A (N(B) \ N[ A] ⊆ C ), C ∪ (N(A) ∩ N(B)) ∪ B (N(A) \ N[B] ⊆ C ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Packing reductions</head><p>In Section 4.4, we introduce the branching rule that creates auxiliary constraints, called packing constraints, and introduce the simple reduction rule on the basis of these constraints. In this section, we introduce more sophisticated reduction rules to exploit packing constraints. Let v∈S x v ≤ k be a packing constraint such that S is nonempty.</p><p>The first rule is for the case in which k is zero. To satisfy the constraint, we cannot include any vertices in S to the vertex cover. Thus, if there is an edge among S, we can prune the subsequent search. Otherwise, we can delete S from the graph while including N(S) to the vertex cover. Here, we can introduce additional packing constraints. Let u be a vertex such that N(u) ∩ S is a single vertex w, and let</p><formula xml:id="formula_18">N + (u) = N(u) \ N[S].</formula><p>If we include all the vertices of N + (u) to the vertex cover, by discarding the vertex u and including w, we can obtain a vertex cover of the same size that does not satisfy the constraint of v∈S x v ≤ 0. Thus, we can introduce a new constraint of v∈N + (u)</p><formula xml:id="formula_19">x v ≤ |N + (u)| -1.</formula><p>The second rule is for the case in which k is positive. Let u / ∈ S be a vertex such that |S ∩ N(u)| &gt; k. If we do not include u to the vertex cover, all the vertices of N(u) must be contained in the vertex cover. Thus, the constraint is not satisfied.</p><p>Therefore, we can include u to the vertex cover. Moreover, if at least |N(u)| -1 vertices of N(u) are included to the vertex cover, by discarding u and including the remaining vertex of N(u), we can obtain a vertex cover of the same size that does not satisfy the constraint. Thus, we can introduce a new constraint of</p><formula xml:id="formula_20">v∈N(u) x v ≤ |N(u)| -2.</formula><p>When we also use reduction rules such as the degree-2 folding, which modifies the graph by deleting some vertices and creating new vertices, the deleted vertices might be included to the vertex cover later on. In that case, we revert the modification until all the vertices in the constraint are recovered and then check the constraint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Lower bounds</head><p>We introduce several lower bounds that can be easily computed. In our main implementation, we take the maximum of them as a lower bound. This lower bound is also used in the state-of-the-art branch-and-bound algorithm MCS <ref type="bibr" target="#b21">[22]</ref>. MCS computes a clique cover using a more sophisticated strategy to obtain a better lower bound. However, it does not scale for large graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Clique cover</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">LP relaxation</head><p>The optimal value of the LP relaxation gives a lower bound for the size of the minimum vertex cover. After the LP-based reduction, the remaining graph admits a half-integral optimal solution of value</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>|V |</head><p>2 . This lower bound has been used in FPT algorithms parameterized by the difference between LP lower bounds and the IP optimum <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b13">14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Cycle cover</head><p>A set of disjoint cycles C 1 , . . . , C k is called cycle cover if it covers all the vertices. Here, two adjacent vertices are considered as a cycle of length two, but a single vertex does not form a cycle of length one. For a cycle cover C 1 , . . . , C k , the value</p><formula xml:id="formula_21">k i=1 |C i | 2</formula><p>gives a lower bound for the size of the minimum vertex cover.</p><p>We do not have to compute a cycle cover from scratch. After the LP-based reduction, the bipartite graph Ḡ of Section 5.2 admits a perfect matching. Thus, by taking an edge uv for each edge l u r v in the perfect matching, we can obtain a cycle cover of the graph G in O (|V |) time. Since the optimal value of the LP relaxation is</p><formula xml:id="formula_22">|V | 2 = k i=1 |C i |</formula><p>2 , the lower bound given by this cycle cover is never worse than the LP optimum. Let v 1 , . . . , v n be vertices forming a cycle. If there are four vertices {v i , v i+1 , v j , v j+1 } with edges v i v j+1 and v j v i+1 , we can split the cycle into two smaller cycles. In our implementation, if it is possible to split a cycle of even length into two smaller cycles of odd length, we split it to improve the lower bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Parameterized complexity of vertex cover above lower bounds</head><p>The previous theoretical research has shown that if the LP relaxation gives a lower bound that is close to the optimal value, Vertex Cover can be efficiently solved in the context of parameterized complexity <ref type="bibr" target="#b16">[17]</ref>. In our algorithm, we used two different lower bounds, clique cover and cycle cover, which can give a better lower bound than LP relaxation. In this section, we investigate the parameterized complexity of Vertex Cover above these lower bounds and show that even if these lower bounds are very close to the optimal value, Vertex Cover can become very difficult.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Vertex cover above clique cover</head><p>Let us define a parameterized problem, Vertex Cover above Clique Cover. In this problem, we are given a graph G, a clique cover C of G, and a parameter k; our objective is to find a vertex cover of size at most |V | -|C| + k. Here, |V | -|C| is the lower bound of the optimal solution obtained from the given clique cover. In contrast to LP lower bound, we prove that this parameterized problem is parameterized NP-hard; i.e., even if the difference between the lower bound obtained from the clique cover and the optimal value is constant, Vertex Cover is still NP-hard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. Vertex Cover above Clique Cover is parameterized NP-hard.</head><p>Proof. We prove the theorem by a reduction from 3-SAT. Let (X, F ) be an instance of 3-SAT, where X = {x 1 , x 2 , . . . , x n } is a set of variables and F = {F 1 , F 2 , . . . , F m } is a set of 3-clauses on X . The negation of a variable x is denoted by x. We write each clause F i as F i = (l i,1 ∨ l i,2 ∨ l i,3 ), where l i, j is a literal of X , i.e., l i, j = x or x for some x ∈ X .</p><p>We reduce the instance of 3-SAT to an instance of Vertex Cover above Clique Cover with a parameter k = 0 as follows. For each variable x i ∈ X , we create two vertices v i and vi and connect them by an edge. Let f be a function that maps a literal x i to the vertex v i and a literal xi to the vertex vi . For each clause F i = (l i,1 ∨ l i,2 ∨ l i,3 ) ∈ F , we create three vertices u i,1 , u i,2 , and u i,3 , and connect them to form a triangle. Then, for each j = 1, 2, 3, we connect u i, j to f (l i, j ). Finally, we construct a clique cover C by taking a clique {v i , vi } of size two from each variable x i ∈ X , and a clique {u i,1 , u i,2 , u i,3 } of size three from each clause F i ∈ F . The number of the vertices is 2n + 3m, and the size of this clique cover is n + m. Thus, the lower bound obtained from the clique cover is n + 2m.</p><p>Finally, we prove that, if and only if the instance of 3-SAT is satisfiable, the reduced graph has a vertex cover of size n + 2m.</p><p>(⇒) We construct a vertex cover C as follows. Let π be a truth assignment that satisfies all the clauses. For each variable x i ∈ X , if π(x i ) is true, we include v i to C ; otherwise, we include vi to C . This covers an edge between v i and vi . For each clause F i ∈ F , we choose a literal l i, j such that π(l i, j ) is true. Since π is a satisfying assignment, we can always choose such a literal. Then, we include the two vertices other than u i, j from the triangle {u i,1 , u i,2 , u i,3 } to C . These cover the edges on the triangle. Moreover, for each j = 1, 2, 3, if π(l i, j ) is true, f (l i, j ) is in C ; otherwise, u i, j is in C . Therefore, the edge between u i, j and f (l i, j ) is also covered. Thus, all the edges are covered by C ; i.e., C is a vertex cover. Apparently, the size of C is n + 2m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(⇐)</head><p>We construct a satisfying assignment π as follows. Let C be a vertex cover of size n + 2m. Since the lower bound obtained from the clique cover C is also n + 2m, this implies that for each clique C i ∈ C, C contains exactly |C i | -1 vertices from C i . Therefore, for each variable x i ∈ X , C contains exactly one of v i and vi . If v i is contained in C , we assign π(x i ) to true; otherwise, we assign π(x i ) to false. Now, we show that this assignment π satisfies all the clauses. For each clause F i ∈ F , since C contains exactly two vertices from the triangle {u i,1 , u i,2 , u i,3 }, exactly one vertex u i, j of them is not contained in C . Since C is a vertex cover, its adjacent vertex f (l i, j ) is contained in C . Thus, π(l i, j ) is true, and therefore, F i is satisfied by π . 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Vertex cover above cycle cover</head><p>Let us define another parameterized problem Vertex Cover above Cycle Cover. Similar to the previous problem, we are given a graph G, a cycle cover C of G, and a parameter k, and our objective is to find a vertex cover of size at most </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.">Setup</head><p>Experiments were conducted on a machine with Intel Xeon X5670 (2.93 GHz) and 48 GB of main memory running Linux 2.6.18. C++ programs were compiled using gcc 4.8.2 with -O3 option. Java programs were executed with JRE 1.8.0. All the timing results were sequential. We set the time limit for each execution as 24 hours. Timeouts are denoted as '-' in tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.1.">Instances</head><p>As for problem instances, we focused on real large sparse networks. Computing small vertex covers on these networks is important for graph indexing methods <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b9">10]</ref>. We also used instances from DIMACS Implementation Challenge and the Odd Cycle Transversal problem. Directions of edges are ignored and self-loops were removed beforehand. The detailed description of the three sets of graphs are as follows.</p><p>Real Sparse Networks: We focused on real large sparse networks such as social networks, web graphs, computer networks and road networks. They were obtained from the Stanford Large Network Dataset Collection, <ref type="foot" target="#foot_1">4</ref> Koblenz Network Collection, <ref type="foot" target="#foot_2">5</ref>and Laboratory for Web Algorithmics<ref type="foot" target="#foot_3">6</ref>  <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b2">3]</ref>. DIMACS Instances: DIMACS Instances are those from DIMACS Implementation Challenge on the maximum clique problem <ref type="bibr" target="#b14">[15]</ref>. They consist of artificial synthetic graphs and problems reduced from other problems. We used complement graphs of them as Vertex Cover instances. Since they are originally dense graphs and have at most thousands of vertices, explicitly considering complement graphs is feasible and has been often done for benchmarking algorithms for Vertex Cover and Minimum Independent Set. Indeed, these complement graphs are also available online for these problems, and we downloaded them. <ref type="foot" target="#foot_4">7</ref>Instances from ODD CYCLE TRANSVERSAL: An odd cycle transversal of a graph G is a vertex subset S ⊆ V such that G -S becomes a bipartite graph. Odd Cycle Transversal is a problem in which a minimum odd cycle transversal of a given graph has to be found. The problem is known to be reduced to Vertex Cover in linear time as follows <ref type="bibr" target="#b16">[17]</ref>. From the input graph</p><formula xml:id="formula_23">G = (V , E), we construct a graph Ĝ = (L V ∪ R V , Ê) where L V = {l v | v ∈ V }, R V = {r v | v ∈ V }, and Ê = {l u l v | uv ∈ E} ∪ {r u r v | uv ∈ E} ∪ {l v r v | v ∈ V }.</formula><p>Let Ĉ be a minimum vertex cover of Ĝ. Then, a minimum odd cycle transversal can be computed by taking vertices v ∈ V such that both l v and r v are in Ĉ . We used real Odd Cycle Transversal instances from bioinformatics, which formulates the Minimum Site Removal problem<ref type="foot" target="#foot_5">8</ref>  <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.2.">Methods</head><p>We generally compare the three algorithms for Vertex Cover based on different approaches: B&amp;R, CPLEX and MCS <ref type="bibr" target="#b21">[22]</ref>. For instances from Odd Cycle Transversal, we also include the results of the algorithm for directly solving Odd Cycle Transversal by Hüffner <ref type="bibr" target="#b11">[12]</ref>. B&amp;R: B&amp;R is the branch-and-reduce algorithm stated above, which is implemented in Java. Unless mentioned otherwise, all the branching rules (Section 4), all the reduction rules (Section 5), and all the lower bounds (Section 6) were used. Our implementation is available online. 9 CPLEX: IBM ILOG CPLEX Optimization Studio (CPLEX) is a state-of-the-art commercial optimization software package. We used version 12.6 and formulated Vertex Cover through integer programming. To exactly obtain the minimum vertex cover, we set mip tolerances mipgap and mip tolerances absmipgap as zero and switched on emphasis numerical.</p><p>Nevertheless, CPLEX did not produce truly optimal solutions for some instances, probably because of numerical precision issues. 10 These results are presented in our tables in parentheses. <ref type="bibr" target="#b21">[22]</ref> is a state-of-the-art branch-and-bound algorithm for the Maximum Clique problem. We used this algorithm for computing minimum vertex cover by virtually considering complement graphs. The algorithm is tailored to DIMACS instances and uses the greedy coloring technique to obtain good lower bounds. The algorithm never applies any reductions. It was implemented by the authors in C++.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MCS: MCS</head><p>Hüffner: This is the state-of-the-art algorithm by Hüffner for directly solving Odd Cycle Transversal <ref type="bibr" target="#b11">[12]</ref>. This algorithm is based on an FPT algorithm by Reed, Smith and Vetta <ref type="bibr" target="#b20">[21]</ref> using the iterative compression technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.">Algorithm comparison</head><p>The experimental results on real sparse networks and DIMACS instances are shown in Tables 1, 2 and 3. For each instance, the table lists the number of vertices (|V |), the number of edges (|E|), the initial LP lower bound before applying reduction rules (LP), the size of the minimum vertex cover (VC), and results of the three methods. For each method, besides time consumption in seconds (T), the number of branches (#B) are described. For CPLEX, the number of introduced cuts (#C) is also denoted.</p><p>We first observe that B&amp;R and CPLEX clearly outperform MCS on real sparse networks. Also, except for road networks, B&amp;R is generally comparable with CPLEX. B&amp;R solves several cases that CPLEX fails to solve within the time limit, such as libimseti, hollywood-2009, and hollywood-2011. Moreover, for some of the other instances, such as petster-cat, soc-LiveJournal1, web-Google, and in-2004, B&amp;R is orders of magnitude faster than CPLEX. On the other hand, for a few web graph such as cnr-2000 and eu-2005, only CPLEX gave an answer within the time limit.</p><p>In contrast, on DIMACS instances, as it is tailored to these instances, MCS generally works better. The performances of B&amp;R and CPLEX are comparable. For example, B&amp;R solved some of the p_hat instances and sanr instances that CPLEX could not solve, but CPLEX solved some of the gen instances that B&amp;R could not solve.</p><p>Table <ref type="table" target="#tab_1">4</ref> lists the results on instances from the Odd Cycle Transversal problem. For Hüffner's algorithm, we describe the number of augmentations (#A) instead of the number of branches. We observe that B&amp;R, CPLEX and MCS strongly outperform Hüffner's algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.">Analysis</head><p>Finally, we examine the effect of branching strategies, reduction rules and lower bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.1.">Branching rules</head><p>We compared the following three branching strategies. B0 selects a vertex to branch on in a uniformly random manner, B1 branches on a vertex with the minimum degree and B2 chooses a vertex with the maximum degree.</p><p>Table <ref type="table" target="#tab_2">5</ref> lists the results, which show that selecting a vertex with the maximum degree (B2) is significantly better than other strategies. This matches the results of theoretical research. Another interesting finding here is that the minimum degree strategy (B1) performs better than the random strategy (B0). This is because our algorithm incorporates mirror branching (Section 4.2), which occurs more often when branching on vertices with small degrees. 9 https :/ /github .com /wata-orz /vertex _cover. 10 We also tested modification of the feasibility tolerance parameter in its simplex routine (simplex tolerances feasibility). Indeed, the results were quite sensitive to this parameter, which implies numerical precision issues. We observed that the best results were produced by the default value 10 -6 in almost all the cases, and thus, the default value was used for this parameter. Consequently, we switched on the numerical precision emphasis parameter (emphasis numerical). While it improved the results to some extent, in some instances the results were larger than ours, though we confirmed that our smaller solutions were, indeed, vertex covers. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>INPUT: a graph G, packing constraints P, a current solution size c, and an upper bound k 1: procedure Solve(G, P, c, k)2:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Now, we introduce</head><label></label><figDesc>the notion of alternative. Two subsets of vertices A and B are called alternatives if |A| = |B| ≥ 1 and there exists a minimum vertex cover C that satisfies C ∩ (A ∪ B) = A or B. The third and fourth rules are special cases of the alternative. Let u, v be adjacent vertices such that N(v) \ {u} induces a complete graph. Then, {u} and {v} are alternative sets (called a funnel). Let a 1 b 1 a 2 b 2 be a chordless 4-cycle such that the degree of each vertex is at least three. Let A = {a 1 , a 2 } and B = {b 1 , b 2 }. If it holds that N( A) ∩ N(B) = ∅, |N(A) \ B| ≤ 2, and |N(B) \ A| ≤ 2, then A and B are alternatives (called a desk). If there is a funnel or a desk, we can remove it by the following lemma.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>A</head><label></label><figDesc>set of disjoint cliques C 1 , . . . , C k is called clique cover if it covers all the vertices. For a clique cover C 1 , . . . , C k , the value k i=1 (|C i | -1) = |V |k gives a lower bound for the size of the minimum vertex cover. In our implementation, we compute a clique cover greedily as follows. First, we sort the vertices by ascending order of their degrees and initiate a set of cliques C to be an empty set. Then, for each vertex v, we search for a clique C ∈ C to which v can be added. If there are multiple possible cliques, we choose the one with maximum size. If there are no such cliques, we add a clique of the single vertex v to C. Since it takes only O (d(v)) time for each vertex v, the algorithm runs in linear time in total.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2 +Theorem 2 .</head><label>22</label><figDesc>k. Here, C ∈C |C| 2 is the lower bound of the optimal solution obtained from the given cycle cover. Similar to Vertex Cover above Clique Cover, Vertex Cover above Cycle Cover also becomes parameterized NP-hard. Vertex Cover above Cycle Cover is parameterized NP-hard. Proof. The proof is almost the same. The size of each clique C in the clique cover C used in the proof of Theorem 1 is two or three. Thus, the clique cover C is also a cycle cover. Moreover, when |C| = 2 or 3, |C| -1 equals to |C| 2 . Therefore, the lower bound obtained by considering C as a cycle cover exactly matches the lower bound obtained by considering C as a clique cover. Thus, we can use the same argument. 2 8. Experiments</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Performance comparison of algorithms for Vertex Cover on real sparse graphs; T denotes running time (in seconds), #B denotes the number of branches, and #C denotes the number of introduced cuts. Timeouts are denoted as '-'. Numbers in parentheses are explained in Section 8.1.2.</figDesc><table><row><cell>Instance</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 4</head><label>4</label><figDesc>Performance comparison of algorithms for Odd Cycle Transversal; T denotes running time (in seconds), #B denotes the number of branches, #C denotes the number of introduced cuts, and #A denotes the number of augmentations. B&amp;R and CPLEX are given the reduced graphs Ĝ, while Hüffner is given the original OCT instances. |V | and |E| denote the sizes of the reduced graphs.</figDesc><table><row><cell>Instance</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>B&amp;R</cell><cell></cell><cell>CPLEX</cell><cell></cell><cell></cell><cell>Hüffner [12]</cell><cell></cell></row><row><cell>Name</cell><cell>|V |</cell><cell>| E|</cell><cell>LP</cell><cell>VC</cell><cell>T</cell><cell>#B</cell><cell>T</cell><cell>#B</cell><cell>#C</cell><cell>T</cell><cell>#A</cell></row><row><cell>a f r o -1 6</cell><cell>2 6</cell><cell>4 3</cell><cell>1 3</cell><cell>1 3</cell><cell>0 . 0</cell><cell>0</cell><cell>0 . 0</cell><cell>0</cell><cell>0</cell><cell>0 . 0</cell><cell>0</cell></row><row><cell>a f r o -2 5</cell><cell>2 8</cell><cell>4 4</cell><cell>1 4</cell><cell>1 5</cell><cell>0 . 0</cell><cell>0</cell><cell>0 . 0</cell><cell>0</cell><cell>4</cell><cell>0 . 0</cell><cell>0</cell></row><row><cell>afro-31</cell><cell>60</cell><cell>132</cell><cell>30</cell><cell>32</cell><cell>0.0</cell><cell>0</cell><cell>0.0</cell><cell>0</cell><cell>0</cell><cell>0.0</cell><cell>5</cell></row><row><cell>afro-49</cell><cell>52</cell><cell>150</cell><cell>26</cell><cell>31</cell><cell>0.0</cell><cell>0</cell><cell>0.0</cell><cell>0</cell><cell>0</cell><cell>0.0</cell><cell>25</cell></row><row><cell>afro-30</cell><cell>78</cell><cell>181</cell><cell>39</cell><cell>43</cell><cell>0.0</cell><cell>6</cell><cell>0.0</cell><cell>0</cell><cell>10</cell><cell>0.0</cell><cell>38</cell></row><row><cell>afro-33</cell><cell>386</cell><cell>1179</cell><cell>193</cell><cell>197</cell><cell>0.1</cell><cell>15</cell><cell>0.0</cell><cell>0</cell><cell>0</cell><cell>0.0</cell><cell>39</cell></row><row><cell>afro-37</cell><cell>144</cell><cell>412</cell><cell>72</cell><cell>77</cell><cell>0.1</cell><cell>4</cell><cell>0.0</cell><cell>0</cell><cell>13</cell><cell>0.0</cell><cell>92</cell></row><row><cell>afro-10</cell><cell>138</cell><cell>451</cell><cell>69</cell><cell>75</cell><cell>0.1</cell><cell>16</cell><cell>0.0</cell><cell>0</cell><cell>9</cell><cell>0.0</cell><cell>97</cell></row><row><cell>afro-21</cell><cell>56</cell><cell>208</cell><cell>28</cell><cell>37</cell><cell>0.0</cell><cell>0</cell><cell>0.0</cell><cell>0</cell><cell>0</cell><cell>0.0</cell><cell>245</cell></row><row><cell>afro-15</cell><cell>132</cell><cell>424</cell><cell>66</cell><cell>73</cell><cell>0.1</cell><cell>12</cell><cell>0.0</cell><cell>0</cell><cell>9</cell><cell>0.0</cell><cell>339</cell></row><row><cell>afro-51</cell><cell>156</cell><cell>626</cell><cell>78</cell><cell>89</cell><cell>0.1</cell><cell>15</cell><cell>0.0</cell><cell>0</cell><cell>16</cell><cell>0.0</cell><cell>1112</cell></row><row><cell>afro-36</cell><cell>222</cell><cell>743</cell><cell>111</cell><cell>118</cell><cell>0.1</cell><cell>11</cell><cell>0.1</cell><cell>0</cell><cell>21</cell><cell>0.0</cell><cell>1392</cell></row><row><cell>afro-11</cell><cell>204</cell><cell>716</cell><cell>102</cell><cell>113</cell><cell>0.2</cell><cell>20</cell><cell>0.2</cell><cell>0</cell><cell>24</cell><cell>0.0</cell><cell>1945</cell></row><row><cell>afro-18</cell><cell>174</cell><cell>849</cell><cell>87</cell><cell>101</cell><cell>0.2</cell><cell>27</cell><cell>0.0</cell><cell>0</cell><cell>9</cell><cell>0.0</cell><cell>2319</cell></row><row><cell>afro-13</cell><cell>258</cell><cell>895</cell><cell>129</cell><cell>141</cell><cell>0.1</cell><cell>29</cell><cell>0.1</cell><cell>0</cell><cell>24</cell><cell>0.0</cell><cell>3081</cell></row><row><cell>afro-35</cell><cell>164</cell><cell>620</cell><cell>82</cell><cell>92</cell><cell>0.1</cell><cell>21</cell><cell>0.0</cell><cell>0</cell><cell>0</cell><cell>0.0</cell><cell>5276</cell></row><row><cell>afro-27</cell><cell>236</cell><cell>780</cell><cell>118</cell><cell>129</cell><cell>0.5</cell><cell>20</cell><cell>0.5</cell><cell>0</cell><cell>36</cell><cell>0.0</cell><cell>5796</cell></row><row><cell>afro-44</cell><cell>118</cell><cell>385</cell><cell>59</cell><cell>69</cell><cell>0.1</cell><cell>19</cell><cell>0.1</cell><cell>0</cell><cell>10</cell><cell>0.0</cell><cell>6402</cell></row><row><cell>afro-26</cell><cell>184</cell><cell>660</cell><cell>92</cell><cell>105</cell><cell>0.1</cell><cell>29</cell><cell>0.3</cell><cell>0</cell><cell>16</cell><cell>0.0</cell><cell>8481</cell></row><row><cell>afro-52</cell><cell>130</cell><cell>527</cell><cell>65</cell><cell>79</cell><cell>0.1</cell><cell>34</cell><cell>0.1</cell><cell>0</cell><cell>10</cell><cell>0.0</cell><cell>11,195</cell></row><row><cell>afro-47</cell><cell>124</cell><cell>520</cell><cell>62</cell><cell>76</cell><cell>0.1</cell><cell>20</cell><cell>0.1</cell><cell>0</cell><cell>14</cell><cell>0.0</cell><cell>13,793</cell></row><row><cell>afro-46</cell><cell>322</cell><cell>1219</cell><cell>161</cell><cell>174</cell><cell>0.3</cell><cell>86</cell><cell>0.1</cell><cell>0</cell><cell>18</cell><cell>0.0</cell><cell>14,120</cell></row><row><cell>afro-34</cell><cell>266</cell><cell>1035</cell><cell>133</cell><cell>146</cell><cell>0.2</cell><cell>22</cell><cell>0.0</cell><cell>0</cell><cell>0</cell><cell>0.0</cell><cell>16,413</cell></row><row><cell>afro-54</cell><cell>178</cell><cell>555</cell><cell>89</cell><cell>101</cell><cell>0.2</cell><cell>54</cell><cell>0.4</cell><cell>5</cell><cell>42</cell><cell>0.0</cell><cell>20,385</cell></row><row><cell>afro-53</cell><cell>176</cell><cell>552</cell><cell>88</cell><cell>100</cell><cell>0.1</cell><cell>20</cell><cell>0.2</cell><cell>27</cell><cell>20</cell><cell>0.0</cell><cell>21,728</cell></row><row><cell>afro-22</cell><cell>334</cell><cell>1449</cell><cell>167</cell><cell>183</cell><cell>0.2</cell><cell>36</cell><cell>0.2</cell><cell>0</cell><cell>88</cell><cell>0.0</cell><cell>22,607</cell></row><row><cell>afro-23</cell><cell>278</cell><cell>1155</cell><cell>139</cell><cell>157</cell><cell>0.2</cell><cell>31</cell><cell>0.5</cell><cell>0</cell><cell>34</cell><cell>0.0</cell><cell>23,322</cell></row><row><cell>afro-50</cell><cell>226</cell><cell>1049</cell><cell>113</cell><cell>131</cell><cell>0.2</cell><cell>33</cell><cell>0.3</cell><cell>4</cell><cell>12</cell><cell>0.0</cell><cell>26,711</cell></row><row><cell>afro-20</cell><cell>448</cell><cell>1756</cell><cell>224</cell><cell>243</cell><cell>0.3</cell><cell>41</cell><cell>1.0</cell><cell>3</cell><cell>41</cell><cell>0.1</cell><cell>32,049</cell></row><row><cell>afro-48</cell><cell>178</cell><cell>775</cell><cell>89</cell><cell>106</cell><cell>0.2</cell><cell>31</cell><cell>0.5</cell><cell>0</cell><cell>24</cell><cell>0.0</cell><cell>41,498</cell></row><row><cell>afro-29</cell><cell>552</cell><cell>2392</cell><cell>276</cell><cell>297</cell><cell>0.4</cell><cell>66</cell><cell>0.3</cell><cell>0</cell><cell>55</cell><cell>0.1</cell><cell>56,095</cell></row><row><cell>afro-45</cell><cell>160</cell><cell>852</cell><cell>80</cell><cell>100</cell><cell>0.2</cell><cell>55</cell><cell>0.4</cell><cell>3</cell><cell>20</cell><cell>0.1</cell><cell>99,765</cell></row><row><cell>afro-43</cell><cell>126</cell><cell>679</cell><cell>63</cell><cell>81</cell><cell>0.2</cell><cell>32</cell><cell>0.3</cell><cell>41</cell><cell>25</cell><cell>0.1</cell><cell>102,609</cell></row><row><cell>afro-39</cell><cell>288</cell><cell>1528</cell><cell>144</cell><cell>167</cell><cell>0.3</cell><cell>58</cell><cell>1.3</cell><cell>0</cell><cell>34</cell><cell>0.4</cell><cell>281,403</cell></row><row><cell>afro-40</cell><cell>272</cell><cell>1376</cell><cell>136</cell><cell>158</cell><cell>0.4</cell><cell>80</cell><cell>0.2</cell><cell>0</cell><cell>47</cell><cell>0.5</cell><cell>333,793</cell></row><row><cell>afro-28</cell><cell>334</cell><cell>1875</cell><cell>167</cell><cell>194</cell><cell>0.5</cell><cell>72</cell><cell>0.9</cell><cell>22</cell><cell>51</cell><cell>0.6</cell><cell>464,272</cell></row><row><cell>afro-38</cell><cell>342</cell><cell>1895</cell><cell>171</cell><cell>197</cell><cell>0.3</cell><cell>51</cell><cell>0.2</cell><cell>0</cell><cell>80</cell><cell>0.9</cell><cell>631,053</cell></row><row><cell>afro-14</cell><cell>250</cell><cell>1175</cell><cell>125</cell><cell>144</cell><cell>0.2</cell><cell>50</cell><cell>1.0</cell><cell>9</cell><cell>40</cell><cell>2.2</cell><cell>1,707,228</cell></row><row><cell>afro-19</cell><cell>382</cell><cell>1481</cell><cell>191</cell><cell>210</cell><cell>0.3</cell><cell>53</cell><cell>1.0</cell><cell>0</cell><cell>34</cell><cell>1.9</cell><cell>1,803,293</cell></row><row><cell>afro-24</cell><cell>516</cell><cell>2474</cell><cell>258</cell><cell>279</cell><cell>0.3</cell><cell>42</cell><cell>0.3</cell><cell>0</cell><cell>69</cell><cell>5.3</cell><cell>1,998,636</cell></row><row><cell>afro-17</cell><cell>302</cell><cell>1417</cell><cell>151</cell><cell>176</cell><cell>0.9</cell><cell>197</cell><cell>1.1</cell><cell>87</cell><cell>62</cell><cell>3.1</cell><cell>2,342,879</cell></row><row><cell>afro-42</cell><cell>472</cell><cell>2456</cell><cell>236</cell><cell>266</cell><cell>0.6</cell><cell>114</cell><cell>2.0</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 5</head><label>5</label><figDesc>Comparison of branching rules. T denotes running time (in seconds) and #B denotes the number of branches.</figDesc><table><row><cell>Instance</cell><cell>B0</cell><cell></cell><cell>B1</cell><cell></cell><cell>B2</cell><cell></cell></row><row><cell></cell><cell>T</cell><cell># B</cell><cell>T</cell><cell># B</cell><cell>T</cell><cell># B</cell></row><row><cell>petster-dog</cell><cell>6.0</cell><cell>3</cell><cell>5.8</cell><cell>14</cell><cell>5.8</cell><cell>3</cell></row><row><cell>hudong-internal</cell><cell>2.3</cell><cell>19</cell><cell>1.8</cell><cell>9</cell><cell>1.9</cell><cell>5</cell></row><row><cell>baidu-related</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>2.1</cell><cell>8</cell></row><row><cell>web-Google</cell><cell>1.3</cell><cell>5</cell><cell>1.5</cell><cell>17</cell><cell>1.4</cell><cell>10</cell></row><row><cell>soc-LiveJournal1</cell><cell>11.3</cell><cell>314</cell><cell>10.8</cell><cell>195</cell><cell>11.5</cell><cell>36</cell></row><row><cell>libimseti</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>1642.8</cell><cell>472</cell></row><row><cell>in-2004</cell><cell>37.2</cell><cell>30,344</cell><cell>28.4</cell><cell>21,377</cell><cell>3.5</cell><cell>668</cell></row><row><cell>web-NotreDame</cell><cell>-</cell><cell>-</cell><cell>687.8</cell><cell>356,138</cell><cell>13.4</cell><cell>4266</cell></row><row><cell>web-BerkStan</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>142.3</cell><cell>42,270</cell></row><row><cell>as-Skitter</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>2769.8</cell><cell>2,123,545</cell></row><row><cell>web-Stanford</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>67,270.3</cell><cell>55,865,269</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 6</head><label>6</label><figDesc>Comparison of reduction rules. T denotes running time (in seconds) and #B denotes the number of branches.</figDesc><table><row><cell>Instance</cell><cell>R0</cell><cell></cell><cell>R1</cell><cell></cell><cell>R2</cell><cell></cell><cell>R3</cell><cell></cell><cell>R4</cell><cell></cell></row><row><cell></cell><cell>T</cell><cell>#B</cell><cell>T</cell><cell>#B</cell><cell>T</cell><cell>#B</cell><cell>T</cell><cell>#B</cell><cell>T</cell><cell>#B</cell></row><row><cell>petster-dog</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>4724.6</cell><cell>5,557,005</cell><cell>8.5</cell><cell>4</cell><cell>5.8</cell><cell>3</cell></row><row><cell>hudong-internal</cell><cell>-</cell><cell>-</cell><cell>24.5</cell><cell>185</cell><cell>2.0</cell><cell>8</cell><cell>2.0</cell><cell>5</cell><cell>1.9</cell><cell>5</cell></row><row><cell>baidu-related</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>1.9</cell><cell>152</cell><cell>1.9</cell><cell>8</cell><cell>2.1</cell><cell>8</cell></row><row><cell>web-Google</cell><cell>-</cell><cell>-</cell><cell>1.5</cell><cell>602</cell><cell>1.5</cell><cell>165</cell><cell>1.0</cell><cell>10</cell><cell>1.4</cell><cell>10</cell></row><row><cell>soc-LiveJournal1</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>45.0</cell><cell>7500</cell><cell>9.6</cell><cell>33</cell><cell>11.5</cell><cell>36</cell></row><row><cell>libimseti</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>837.0</cell><cell>476</cell><cell>1371.5</cell><cell>472</cell><cell>1642.8</cell><cell>472</cell></row><row><cell>in-2004</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>28.0</cell><cell>30,824</cell><cell>4.6</cell><cell>1504</cell><cell>3.5</cell><cell>668</cell></row><row><cell>web-NotreDame</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>747.7</cell><cell>1,088,096</cell><cell>29.3</cell><cell>16,563</cell><cell>13.4</cell><cell>4266</cell></row><row><cell>web-BerkStan</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>7986.2</cell><cell>3,898,313</cell><cell>142.3</cell><cell>42,270</cell></row><row><cell>as-Skitter</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>10,507.3</cell><cell>16,422,252</cell><cell>7768.1</cell><cell>6,262,544</cell><cell>2769.8</cell><cell>2,123,545</cell></row><row><cell>web-Stanford</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>67,270.3</cell><cell>55,865,269</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 7</head><label>7</label><figDesc>Comparison of lower bounds. T denotes running time (in seconds) and #B denotes the number of branches.</figDesc><table><row><cell>Instance</cell><cell>L0</cell><cell></cell><cell>L1</cell><cell></cell><cell>L2</cell><cell></cell><cell>L3</cell><cell></cell><cell>L4</cell><cell></cell></row><row><cell></cell><cell>T</cell><cell># B</cell><cell>T</cell><cell># B</cell><cell>T</cell><cell># B</cell><cell>T</cell><cell># B</cell><cell>T</cell><cell># B</cell></row><row><cell>petster-dog</cell><cell>6.1</cell><cell>122</cell><cell>6.2</cell><cell>15</cell><cell>6.0</cell><cell>7</cell><cell>5.4</cell><cell>3</cell><cell>5.8</cell><cell>3</cell></row><row><cell>hudong-internal</cell><cell>2.0</cell><cell>16</cell><cell>1.9</cell><cell>6</cell><cell>2.0</cell><cell>6</cell><cell>1.9</cell><cell>5</cell><cell>1.9</cell><cell>5</cell></row><row><cell>baidu-related</cell><cell>74.7</cell><cell>27,047</cell><cell>1.9</cell><cell>8</cell><cell>2.7</cell><cell>77</cell><cell>2.6</cell><cell>68</cell><cell>2.1</cell><cell>8</cell></row><row><cell>web-Google</cell><cell>1.1</cell><cell>47</cell><cell>1.0</cell><cell>10</cell><cell>1.3</cell><cell>30</cell><cell>1.0</cell><cell>30</cell><cell>1.4</cell><cell>10</cell></row><row><cell>soc-LiveJournal1</cell><cell>12.6</cell><cell>180</cell><cell>10.6</cell><cell>37</cell><cell>12.0</cell><cell>122</cell><cell>11.0</cell><cell>117</cell><cell>11.5</cell><cell>36</cell></row><row><cell>libimseti</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>1747.0</cell><cell>476</cell><cell>1776.5</cell><cell>472</cell><cell>1642.8</cell><cell>472</cell></row><row><cell>in-2004</cell><cell>4.4</cell><cell>878</cell><cell>4.1</cell><cell>683</cell><cell>5.2</cell><cell>781</cell><cell>4.4</cell><cell>757</cell><cell>3.5</cell><cell>668</cell></row><row><cell>web-NotreDame</cell><cell>17.9</cell><cell>13,740</cell><cell>14.2</cell><cell>5678</cell><cell>13.7</cell><cell>5702</cell><cell>13.7</cell><cell>4447</cell><cell>13.4</cell><cell>4266</cell></row><row><cell>web-BerkStan</cell><cell>261.2</cell><cell>206,209</cell><cell>145.3</cell><cell>42,503</cell><cell>199.6</cell><cell>113,184</cell><cell>176.0</cell><cell>62,877</cell><cell>142.3</cell><cell>42,270</cell></row><row><cell>as-Skitter</cell><cell>4963.5</cell><cell>6,973,582</cell><cell>2629.6</cell><cell>2,153,280</cell><cell>4165.8</cell><cell>4,873,893</cell><cell>3968.9</cell><cell>4,083,355</cell><cell>2769.8</cell><cell>2,123,545</cell></row><row><cell>web-Stanford</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>64,757.6</cell><cell>55,912,396</cell><cell>67,270.3</cell><cell>55,865,269</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>The algorithm runs in O (4 k m) time after computing the LP lower bound, which can be computed in O (m √ n) time.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>http :/ /snap .stanford .edu /data/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>http :/ /konect .uni-koblenz .de/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>http :/ /law.di .unimi .it /datasets .php.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>http :/ /www.cs .hbg .psu .edu /txn131 /vertex _cover.html.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>http :/ /www.user.tu-berlin .de /hueffner /occ/.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"> <ref type="bibr" target="#b0">1</ref> <p>Takuya Akiba is supported by JSPS Grant-in-Aid for Research Activity Start-up (15H06828) and PRESTO, JST. <ref type="bibr" target="#b1">2</ref> Yoichi Iwata is supported by Grant-in-Aid for JSPS Fellows 256487.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2</head><p>Performance comparison of algorithms for Vertex Cover on the DIMACS instances (1/2); T denotes running time (in seconds), #B denotes the number of branches, and #C denotes the number of introduced cuts. Timeouts are denoted as '-'. Numbers in parentheses are explained in Section 8. <ref type="bibr" target="#b0">1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.2.">Reduction rules</head><p>To examine the effects of reduction rules, we compare algorithms R0-R4, which use different sets of reduction rules. R0 does not use any reduction rules other than connected component decomposition. R1 uses the first three reduction rules: degree-1, dominance, and degree-2 folding (Section 5.1). In addition to the first three reduction rules, R2 uses the LP-based reduction rule (Section 5.2). R3 also adopts unconfined, twin, funnel, and desk (Section 5.3). R4 uses all the reduction rules, including the packing rule (Section 5.4), which is newly introduced in this paper. Results are listed in Table <ref type="table">6</ref>. We can observe the significant effect of reduction rules on the search space. Indeed, without reduction rules, R0 cannot solve any problems. On the other hand, we confirm that search space gets smaller and smaller by introducing reduction rules on instances such as web-Google, web-NotreDame and as-Skitter. We can also see that the number of problems that can be solved within the time limit increases by adopting reduction rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.3.">Lower bounds</head><p>Finally, we compare algorithms L0-L4 using different lower bounds. L0 only uses the number vertices currently included to the vertex cover. L1, L2, and L3 use the clique cover (Section 6.1), LP relaxation (Section 6.2), and cycle cover (Section 6.3), respectively. L4 combines all these lower bounds.</p><p>Table <ref type="table">7</ref> describes the results. It shows that the difference of lower bounds does not drastically affect the results in comparison to the branching rules and the reduction rules. As expected, the search space of L4 is the smallest among the five methods in all the instances. Since L3 is an extension of L2, it works better than L2 in all the instances. Although L1 works better than L3 in some instances, L3 works better in the other instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusion</head><p>We investigated the practical impact of theoretical research on branching and reduction rules. <ref type="bibr">Our</ref>  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Kernelization algorithms for the vertex cover problem: theory and experiments</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Abu-Khzam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Fellows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Langston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">H</forename><surname>Suters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Symons</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>ALENEX</publisher>
			<biblScope unit="page" from="62" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Branch-and-reduce exponential/FPT algorithms in practice: a case study of vertex cover</title>
		<author>
			<persName><forename type="first">T</forename><surname>Akiba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Iwata</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>ALENEX</publisher>
			<biblScope unit="page" from="70" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Layered label propagation: a multiresolution coordinate-free ordering for compressing social networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Santini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vigna</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>WWW</publisher>
			<biblScope unit="page" from="587" to="596" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The WebGraph framework I: compression techniques</title>
		<author>
			<persName><forename type="first">P</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vigna</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>WWW</publisher>
			<biblScope unit="page" from="595" to="601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast algorithms for max independent set</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bourgeois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Escoffier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Paschos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M M</forename><surname>Van Rooij</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="382" to="415" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Improved upper bounds for vertex cover</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A</forename><surname>Kanj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">411</biblScope>
			<biblScope unit="issue">40-42</biblScope>
			<biblScope unit="page" from="3736" to="3756" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Efficient processing of distance queries in large graphs: a vertex cover approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cheng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>SIGMOD</publisher>
			<biblScope unit="page" from="457" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On multiway cut parameterized above lower bounds</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cygan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pilipczuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pilipczuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">O</forename><surname>Wojtaszczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Theory</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A measure &amp; conquer approach for the analysis of exact algorithms</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">V</forename><surname>Fomin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Grandoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kratsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">32</biblScope>
			<date type="published" when="2009-08">Aug. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On k-path covers and their applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Funke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nusser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Storandt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="893" to="902" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An n 5/2 algorithm for maximum matchings in bipartite graphs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="225" to="231" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Algorithm engineering for optimal graph bipartization</title>
		<author>
			<persName><forename type="first">F</forename><surname>Hüffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Graph Algorithms Appl</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="77" to="98" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">A faster algorithm for dominating set analyzed by the potential method</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Iwata</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>IPEC</publisher>
			<biblScope unit="page" from="41" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<author>
			<persName><forename type="first">Y</forename><surname>Iwata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Oka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Linear-time FPT algorithms via network flow</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1749" to="1761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m">Cliques, Coloring, and Satisfiability: Second DIMACS Implementation Challenge, Workshop</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Johnson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Trick</surname></persName>
		</editor>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1993">October 11-13, 1993. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A fine-grained analysis of a simple independent set algorithm</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kneis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Langer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rossmanith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>FSTTCS</publisher>
			<biblScope unit="page" from="287" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Lokshtanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Narayanaswamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ramanujan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Saurabh</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1203.0833</idno>
		<title level="m">Faster parameterized algorithms using linear programming, CoRR</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Vertex packing: structural properties and algorithms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Nemhauser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Trotter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Program</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="232" to="248" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Computing minimum directed feedback vertex set in o(1.9977 n ), in: ICTCS</title>
		<author>
			<persName><forename type="first">I</forename><surname>Razgon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="70" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Faster computation of maximum independent set and parameterized vertex cover for graphs with maximum degree 3</title>
		<author>
			<persName><forename type="first">I</forename><surname>Razgon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="191" to="212" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Finding odd cycle transversals</title>
		<author>
			<persName><forename type="first">B</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vetta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res. Lett</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="301" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">A simple and faster branch-and-bound algorithm for finding a maximum clique</title>
		<author>
			<persName><forename type="first">E</forename><surname>Tomita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sutani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Higashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Takahashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wakatsuki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>WALCOM</publisher>
			<biblScope unit="page" from="191" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Half-integrality, LP-branching and FPT algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wahlström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SODA</title>
		<imprint>
			<biblScope unit="page" from="1762" to="1781" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Confining sets and avoiding bottleneck cases: a simple maximum independent set algorithm in degree-3 graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nagamochi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">469</biblScope>
			<biblScope unit="page" from="92" to="104" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Exact algorithms for maximum independent set</title>
		<author>
			<persName><forename type="first">M</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nagamochi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>ISAAC</publisher>
			<biblScope unit="page" from="328" to="338" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
