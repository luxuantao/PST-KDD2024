<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An annotation management system for relational databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2005-10-25">25 October 2005</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">R</forename><surname>E G U L A R Pa P E R</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Deepavali</forename><surname>Bhagwat</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Laura</forename><surname>Chiticariu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wang-Chiew</forename><surname>Tan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gaurav</forename><surname>Vijayvargiya</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<postCode>95064</postCode>
									<settlement>Santa Cruz, Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An annotation management system for relational databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2005-10-25">25 October 2005</date>
						</imprint>
					</monogr>
					<idno type="MD5">FE03208605A6D52EC1B1D9BB5F9EAC55</idno>
					<idno type="DOI">10.1007/s00778-005-0156-6</idno>
					<note type="submission">Received: 30 November 2004 / Revised version: 12 April 2005 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Data provenance</term>
					<term>Lineage</term>
					<term>Annotation propagation</term>
					<term>Metadata</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present an annotation management system for relational databases. In this system, every piece of data in a relation is assumed to have zero or more annotations associated with it and annotations are propagated along, from the source to the output, as data is being transformed through a query. Such an annotation management system could be used for understanding the provenance (aka lineage) of data, who has seen or edited a piece of data or the quality of data, which are useful functionalities for applications that deal with integration of scientific and biological data.</p><p>We present an extension, pSQL, of a fragment of SQL that has three different types of annotation propagation schemes, each useful for different purposes. The default scheme propagates annotations according to where data is copied from. The default-all scheme propagates annotations according to where data is copied from among all equivalent formulations of a given query. The custom scheme allows a user to specify how annotations should propagate. We present a storage scheme for the annotations and describe algorithms for translating a pSQL query under each propagation scheme into one or more SQL queries that would correctly retrieve the relevant annotations according to the specified propagation scheme. For the default-all scheme, we also show how we generate finitely many queries that can simulate the annotation propagation behavior of the set of all equivalent queries, which is possibly infinite. The algorithms are implemented and the feasibility of the system is demonstrated by a set of experiments that we have conducted.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>For many scientific domains, new databases are often created to support the data analysis needs of domain-specific scientists. Some examples of such databases from biology include UniProt <ref type="bibr" target="#b0">[1]</ref> and SWISS-PROT <ref type="bibr" target="#b1">[2]</ref>. Data that is collected from other sources is often cleansed and reformatted before it is compiled into a new database. Furthermore, it is common for such newly created databases to contain new analysis or results that are derived by scientists. By associating old and new data together in the new database, an integrated perspective is provided to scientists and this is critical for further analysis and scientific discovery. Very often, there is information about data that is not kept in the database but one would like to propagate this information along as data is being moved around. Examples include information about the perceived accuracy or reliability of experimental results by domain experts, or information about who has seen or edited a piece of data. In fact, our initial motivation for the design of a system that can propagate additional information around is to propagate the provenance of data items along as data is being copied. With the proliferation of many such interdependent databases (see <ref type="bibr" target="#b2">[3]</ref> for a catalog of biology databases), it is natural to ask what is the provenance of a piece of data (i.e., where that piece of data is copied or created from) in a database. Understanding the provenance of data is important towards understanding the quality of data which may help, for example, a scientist to decide on the amount of trust to place on a piece of information that she encounters in a database.</p><p>We describe an annotation management system for relational databases where every column of every tuple in every relation can be annotated with zero or more annotations. We use the term annotation to mean information about data such as provenance, comments, or other types of metadata. The annotations are automatically propagated along as data is being transformed through a query. In its default behavior, our system propagates annotations based on where data is copied from. As a consequence, if every column of every tuple in a database is annotated with its address, the provenance of data is propagated along as data is being transformed. Hence, one immediate application is to use these annotations to systematically trace the provenance and flow of data. Even if the data had undergone several transformation steps, we can easily determine the origins (or the flow of data for that matter) through the transformation steps by examining the annotations. Another use of annotations is to describe information about data that would otherwise have not been kept in a database. For example, an error report or remarks about a piece of data may be attached and propagated along to other databases, thus notifying other users of the error or additional information. The quality or security level of a piece of data can also be described in annotations. Since annotations are propagated along as a query is executed, the annotations on the result of a query can be aggregated to determine the quality or degree of sensitivity of the resulting output. This idea of using annotations to describe the security level of various data items or to specify fine-grained access control policies is not new and can be found in various forms in existing literature <ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref>.</p><p>We describe three propagation schemes for propagating annotations that are motivated by different needs. They correspond to the default, default-all, and custom propagation schemes. The default scheme uses provenance as the basis for propagating annotations. If an output piece of data d is copied from an input piece of data d, then the annotations associated with d are propagated to d . A piece of output data d is copied from an input piece of data d if d is created from d according to the syntax and evaluation of the query. Although this definition corresponds intuitively to how people reason about provenance, the way annotations are propagated is dependent on the way a query is written. As shown in <ref type="bibr" target="#b6">[7]</ref>, two equivalent queries may propagate annotations differently. For instance, consider the relations R(A, B) and S(B, C). The following two equivalent queries compute the join of R and S on the B attribute.</p><formula xml:id="formula_0">Q 1 : SELECT r.B FROM R r, S s WHERE r.B = s.B Q 2 : SELECT s.B FROM R r, S s WHERE r.B = s.B</formula><p>Intuitively, it is easy to see that Q 1 propagates the annotations from the B attribute of R, while Q 2 propagates annotations from the B attribute of S. While this behavior may seem disturbing at first, in many applications including those described above, such an automatic provenancebased annotation propagation scheme which allows one to trace where data is copied from or copied to based on a given query is still very desirable. Indeed, similar ideas were proposed before in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>. We also describe an alternative method of propagating annotations, called the default-all scheme, which propagates annotations according to where data is copied from in all equivalent formulations of the given query since one may be interested in obtaining all relevant annotations of a piece of data in the output regardless of how a query may have been written. Unlike the default scheme, two equivalent queries will always propagate annotations in the same way under this scheme. In some cases, a user may only be interested in annotations provided by a certain trusted data source. Hence, we also provide a third propagation scheme, called the custom propagation scheme, where the user is free to specify how annotations should be propagated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of Results</head><p>We have implemented all three propagation schemes in our annotation management system by extending a fragment of SQL. We call this extension pSQL. A pSQL query is essentially an SQL query extended with a PROPAGATE clause that would propagate annotations according to one of the schemes described above as data is transformed. In our implementation, we assume that for every attribute of every relation, there is an additional column that stores the annotations for that attribute. A translation algorithm translates a given pSQL query into one or more SPJ queries against these underlying relations and these SPJ queries will retrieve the relevant annotations according to the specified propagation scheme. In the default-all scheme, we are required to propagate annotations according to every possible equivalent reformulations of a given query. At first sight, the default-all scheme seems impossible to implement as there are infinitely many equivalent reformulations of a given query. We show, however, that it is always possible to find a finite set of equivalent queries whose annotation propagation behavior is representative of all equivalent queries. Hence, by running every query in this finite set and taking the union of resulting tuples and annotations, we are able to obtain the annotated output of the given query under the default-all scheme. We have conducted experiments to evaluate the feasibility of such an annotation management system. Our experimental results indicate that the execution time of a query under any propagation scheme increases only slightly when the number of annotations in a database is doubled (on the average, the default and default-all queries we experimented with took about 0.71%, and respectively 0.1% more time to execute on the 100 MB database when the number of annotations was doubled from 30 to 60%). Our results also show that for the queries we executed, the performance of a query under the default-all scheme can be at worst eight times slower than the performance of the same query under the default or no propagation scheme (i.e., SQL query). At best, it runs about twice as slow. For the default scheme, however, the execution times of pSQL queries are comparable to those of SQL queries. On the average, the pSQL queries with default scheme that we experimented with on a 100 MB database took around 40% more time to execute than their corresponding SQL queries. For larger databases (500 MB and 1 GB), the pSQL queries with default scheme took only about 15%, and respectively 24% more time to execute than their corresponding SQL queries on the average. However, our empirical results indicate that the performance of pSQL queries starts to degrade on databases annotated more than 100%. This suggests that perhaps our scheme for storing annotations is not the best suited in such scenarios. We plan to investigate the trade-offs between different other annotation storage schemes in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>The problem of computing data provenance is not new. Cui, Widom, and Wiener <ref type="bibr" target="#b9">[10]</ref> first approached the problem of tracing the provenance of data that is the result of a query applied on a relational database. The solution proposed in <ref type="bibr" target="#b9">[10]</ref> was to first generate a "reverse" query Q r when asked to compute the provenance of an output tuple t in the result of a query Q applied on a database D (i.e., Q(D)). The result of applying Q r on D consists of all combinations of source tuples in D such that each combination of source tuples and Q explain why t is in the output of Q(D). The type of provenance studied by <ref type="bibr" target="#b9">[10]</ref> is called why-provenance according to Buneman, Khanna, and Tan <ref type="bibr" target="#b10">[11]</ref>. Additionally, we may also be interested in knowing where the values of a tuple t in the result of Q(D) are copied from in D. The latter type of provenance is called where-provenance in <ref type="bibr" target="#b10">[11]</ref> and it is this type of provenance that we use for determining where annotations are propagated from. In both works <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>, a "reverse" query is generated in order to answer provenance. While the reverse query approach works well in general, it requires a reverse query to be generated and evaluated every time the provenance of an output tuple is sought for. Hence, if the provenance of a large number of output tuples is required, this may not be the optimal way to compute provenance.</p><p>The reverse query approach is what we call the lazy approach for computing provenance; a query is generated and executed to compute the provenance only when needed. In this paper, we propose to trade space for time and carry along the provenance of data as data is being transformed. Hence, in this approach, the provenance of data is eagerly computed and immediately available in the output. The idea of eagerly computing provenance by forwarding annotations along data transformations is also not new and has been proposed in various forms in existing literature <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b11">12]</ref>. In fact, our annotation propagation rules which propagate annotations based on where-provenance are similar to those proposed in <ref type="bibr" target="#b8">[9]</ref>. In <ref type="bibr" target="#b8">[9]</ref>, however, only information about which source relations a value is copied from is propagated along. In contrast, our system is flexible in the amount of information that is carried along to the result (i.e., it could be the source relations, or the exact location within the source locations, or a comment on the data). An annotation is also an example of superimposed information (data "placed" over existing information), as described in <ref type="bibr" target="#b12">[13]</ref>.</p><p>Numerous annotation systems have been built to support and manage annotations on text and HTML documents <ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr">[18]</ref>. Recently, annotation systems for genomic sequences <ref type="bibr">[19]</ref><ref type="bibr" target="#b17">[20]</ref><ref type="bibr" target="#b18">[21]</ref> have also been built. Laliberte and Braverman <ref type="bibr" target="#b14">[15]</ref> discussed how to use the HTTP protocol to design a scalable annotation system for HTML pages. Schickler, Mazer, and Brooks <ref type="bibr" target="#b16">[17]</ref> discussed the use of a specialized proxy module that would merge annotations from an annotation store onto a Web page that is being retrieved before sending it to the client browser. Annotea <ref type="bibr" target="#b13">[14,</ref><ref type="bibr">18]</ref> is a W3C effort to support annotations on any Web document. Annotations are also stored on annotation servers and XPointer is used for pinpointing locations on a Web document. A specialized client browser that can understand, communicate, and merge annotations residing in the annotation servers with Web documents is used. Phelps and Wilensky <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b19">22,</ref><ref type="bibr" target="#b20">23]</ref> also discussed the use of annotations with certain desirable properties on multivalent documents <ref type="bibr" target="#b20">[23]</ref> which support documents of different media types, such as images, postscript, or HTML. DAS or Biodas <ref type="bibr">[19,</ref><ref type="bibr" target="#b17">20]</ref> and the Human Genome Browser <ref type="bibr" target="#b18">[21]</ref> are specialized annotation systems for genomic sequence data. In almost all of these systems, the design includes multiple distributed annotation servers for storing annotations and data is merged from various sources to display it graphically to an end user. The research of these systems has been focused on the scalability of design, distributed support for annotations, or other added features.</p><p>We designed and implemented an annotation management system for relational databases where annotations can be made on relational data. This idea was first proposed in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b21">24]</ref>. Unlike Web pages, the rigid structure of relations makes it easy to describe the exact position where an annotation is attached. Web pages, however, are often retrieved in part or as a whole. Hence, the issue of what annotations to propagate along when a web page is retrieved is straightforward. In contrast, an annotated relation in our system may undergo a complex transformation as a result of executing a query. We are thus concerned with how annotations should propagate when such complex transformations occur. To the best of our knowledge, this is the first implementation of an annotation management system for relational databases that would allow a user to specify how annotations should propagate.</p><p>In Sect. 2, we describe pSQL and the three different propagation schemes. In Sect. 3, we describe the algorithm for generating a finite set of queries that can simulate the annotation propagation behavior of all equivalent queries of a given pSQL query. In Sect. 4, we describe the architecture of our system and a storage scheme for annotations as well as our translation algorithm that rewrites a pSQL query into an SQL query against the underlying storage scheme. In Sect. 5, we describe our experimental results and in Sects. 6 and 7, we conclude with some possible future extensions to our system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">pSQL</head><p>In our subsequent discussions, we focus on a fragment of SQL that corresponds to conjunctive queries with union <ref type="bibr" target="#b22">[25]</ref> (also known as the Select-Project-Join-Union fragment of SQL). We extend this fragment of SQL with a PROPAGATE Fig. <ref type="figure">1</ref> Three protein databases, a mapping table and the result of three pSQL queries clause to allow users to specify how annotations should propagate.</p><formula xml:id="formula_1">Definition 1 A pSQL query is a query of the form Q 1 UNION ... UNION Q k , k &gt; 0, where each Q i , i ∈ [1, k]</formula><p>, is a pSQL query fragment of the form shown below:</p><formula xml:id="formula_2">SELECT DISTINCT selectlist FROM fromlist WHERE wherelist PROPAGATE DEFAULT | DEFAULT-ALL | r 1 .A 1 TO B 1 , . . . , r n .A n TO B n</formula><p>The fromlist of a pSQL query fragment is of the form "R 1 r 1 , . . . , R k r k " where r i is a tuple variable of the corresponding relation R i . The selectlist of a pSQL query fragment is of the form "r 1 .C 1 AS D 1 , . . . , r m .C m AS D m " where r i is a tuple variable defined in fromlist, C i is an attribute of the relation that corresponds to r i , and D i is an attribute name of the output relation. The WHERE clause is optional and the wherelist is a conjunction of one or more equalities between attributes of relations or between attributes of relations and constants. The PROPAGATE clause can be defined with DEFAULT, DEFAULT-ALL, or a list of clauses of the form "r.A TO B" definitions where r.A denotes an attribute A of the tuple that is bound to r and B is an attribute among the D j s.</p><p>The SQL query that corresponds to a pSQL query Q is the SQL query that results when all PROPAGATE clauses in Q have been removed. The meaning of a pSQL query is similar to that of its corresponding SQL query except that annotations are also propagated to each emitted tuple according to the specification given in the PROPAGATE clauses.</p><p>We note at this point that other set operators (such as intersection or set difference) and aggregate functions are not allowed to appear in a pSQL query. In Sect. 6.2, we describe how we extend pSQL queries to a larger fragment of SQL where some aggregates are also allowed.</p><p>Example 1 Consider three databases SWISS-PROT (a protein database), PIR (another protein database), and Genbank (a gene database). Each of these databases is modeled as a relation. The schemas and an instance of each relation are shown at the top of Fig. <ref type="figure">1</ref>. An annotation, shown in braces, is placed on every column of every tuple. Each annotation can be interpreted as the address of the value in the corresponding column of the tuple. An example of a pSQL query with the default propagation scheme is shown below.</p><formula xml:id="formula_3">Q 1 = SELECT DISTINCT s.ID AS ID, s.Desc AS Desc FROM SWISS-PROT s WHERE s.ID = "q229" PROPAGATE DEFAULT</formula><p>Intuitively, the default scheme specified in Q 1 propagates annotations of data according to where data is copied from. The result of Q 1 executed against the relation SWISS-PROT is shown in Fig. <ref type="figure">1</ref>. The annotation a 3 is attached to the value q229 in the output since q229 is copied from the ID attribute of the second tuple in SWISS-PROT. Likewise, a 4 in the output is propagated from the annotation of the Desc attribute of the second tuple in SWISS-PROT.</p><p>While the default scheme is a natural scheme for propagating annotations, this scheme is not robust in that two equivalent queries that return the same output may not propagate the same annotations to the output. For Q , the annotations for the ID column are from the PIR table while for Q , the annotations for the ID column are from the Mapping Table . 

While it is likely that a user will realize that Q will generate a different annotated outcome from Q in general, the situation is not so straightforward for more complex queries. The above example motivates the need for a propagation scheme that is invariant under equivalent queries. One should be able to retrieve all relevant annotations about a piece of output data regardless of how the query is written, if desired. The default-all propagation scheme propagates annotations according to where data is copied from among all equivalent formulations of the given query. Hence, the annotated outcome is the same for equivalent queries under this scheme. In case a user prefers to retrieve annotations from one source over another, the user is also free to specify how annotations should propagate in the custom scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3</head><p>The queries Q 2 and Q 3 are examples of pSQL queries with the default-all and custom propagation schemes, respectively.</p><formula xml:id="formula_4">Q 2 = SELECT DISTINCT p.ID AS ID, p.Name AS Name FROM PIR p PROPAGATE DEFAULT-ALL Q 3 = SELECT DISTINCT g.ID AS ID, g.Desc AS Desc FROM Genbank g PROPAGATE g.ID TO ID, g.Desc TO ID</formula><p>The results of Q 2 and Q 3 are shown at the bottom of Fig. <ref type="figure">1</ref>. The query Q 2 retrieves all tuples from the PIR table under the default-all propagation scheme. Since the following query is equivalent to Q 2 , SELECT DISTINCT p.ID AS ID, p.Name AS Name FROM PIR p, PIR q WHERE p.Name = q.Name annotations of proteins with the same name are combined together. As a consequence, the protein with name AB has both annotations a 8 and a 10 . Intuitively, the annotations we get in the result of a default-all pSQL query fragment Q are the combined annotations of results from all equivalent queries of Q. In the custom scheme of Q 3 , annotations are propagated according to the given user specification (i.e., g.ID TO ID, g.Desc TO ID). A clause "g.ID TO ID" states that the annotations associated with the value of the ID attribute of the tuple that is currently bound to g should propagate to the ID attribute of the output tuple. Similarly, the annotations associated to the value of the Desc attribute of the tuple that is currently bound to g should propagate to the ID attribute of the output tuple. Some Terminology A cell (or location) is a triple (r , t, i) which denotes the ith column of the tuple t in relation r . We sometimes use the attribute name at position i instead of the position i. We also write a cell simply as a pair (t, i) in the context where the relation r is clear. Let L denote the set of all strings. Each cell c in a database is associated with a set of annotations {a 1 , . . . , a k } where each a i , i ∈ <ref type="bibr">[1, k]</ref>, is an element in L. We also say each a i , i ∈ <ref type="bibr">[1, k]</ref>, is an annotation attached to c. We use the notation A(r , t, i) to denote the set of all annotations attached to the cell (r , t, i). Similarly, A(t, i) denotes the set of all annotations attached to the cell (t, i) in the context where the relation r is clear.</p><p>Example 4 Figure <ref type="figure">1</ref> shows several examples of annotated relations. The value z131 in SWISS-PROT is the value at cell (SWISS-PROT, (z131, AB), ID) which denotes the ID column of tuple (z131, AB) in the SWISS-PROT relation. Note that the attribute names in the tuple (z131, AB) have been omitted. The annotation {a 1 } is the set of annotations associated with this cell. Hence, A(SWISS-PROT, (z131, AB), ID) is {a 1 }. In the result of Q 2 , A((p332, AB), Name) is {a 8 , a 10 }.</p><p>Containment vs. Annotation-Containment. Two pSQL queries Q and Q are equivalent, denoted as</p><formula xml:id="formula_5">Q = Q , if for every database D, Q(D) = Q (D). The query Q is contained in Q , denoted as Q ⊆ Q , for every database D, Q(D) ⊆ Q (D). Two pSQL queries Q and Q are annotation-equivalent, denoted as Q = a Q , if Q and Q</formula><p>produce the same annotated output on all databases. More precisely, this means that for every database D, Q(D) is equal to Q (D) and the set of annotations The query Q 3 of Example 3 is annotation-contained in Q since they are equivalent and the annotations associated with each cell in the result of Q 3 is contained in the set of annotations associated with the corresponding cell in the result of Q. Intuitively, Q 3 is annotation-contained in Q because they are equivalent and the ID attribute in the selectlist of both queries receive the same annotations from g.ID and g.Desc. Furthermore, the Desc attribute in the selectlist of Q receives annotations from g.ID.</p><formula xml:id="formula_6">A(Q(D), t, i) is identical to A(Q (D), t, i) for every output location (t, i) in Q(D). A pSQL query Q is annotation-contained in Q , denoted as Q ⊆ a Q , if for every database D, we have Q(D) ⊆ Q (D) and for every output location (t, i) in Q(D), it is the case that A(Q(D), t, i) ⊆ A(Q (D), t, i).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The custom propagation scheme</head><p>We allow the user the flexibility to specify custom propagation schemes using a PROPAGATE clause of the form "r 1 .A 1 TO B 1 , . . . , r n .A n TO B n ". The queries Q 3 of Example 3 and Q of Example 5 are examples of pSQL queries with custom propagation scheme. The semantics of a pSQL query fragment Q with custom propagation scheme is as follows. For every binding µ of tuple variables to tuples in the respective relations according to the fromlist of Q such that the conditions in the wherelist are satisfied, emit an output tuple t according to the selectlist. For every clause "r i .A i TO B i " specified in the PROPAGATE clause, we add the set of annotations at the location (r i , A i ) to the set of annotations (initially empty) at the output location (t, B i ). Finally, duplicate output tuples are merged. Suppose t 1 , . . . , t k are the emitted tuples and s 1 , . . . , s m are the tuples that result when duplicate output tuples have been merged. Then, for every output location (s, B), we have A(s, B) = t j =s, j∈ <ref type="bibr">[1,k]</ref> A(t j , B). <ref type="bibr">Example 6</ref> To illustrate the effect of removing duplicate output tuples and merging annotations of duplicate tuples, consider the query below:</p><formula xml:id="formula_7">SELECT DISTINCT Name AS Name FROM PIR PROPAGATE DEFAULT</formula><p>The result of executing the above query will merge the annotations a 8 and a 10 of the Name values of the first and second tuple in PIR. Hence, the final output is a single tuple (AB) with annotations {a 8 , a 10 }.</p><p>As another example, the query Q 3 of Example 3 has a custom propagation scheme where annotations on both ID and Desc columns of each tuple propagate to the ID column of the output tuple. As a consequence, the ID column of every output tuple is the union of annotations associated with the ID and Desc columns of the corresponding tuple in Genbank.</p><p>Observe that the result of a pSQL fragment evaluated over a database would not contain any duplicate tuples, since we assume set semantics. We refer the reader to Sect. 6.2 for a discussion on extending pSQL to handle bag semantics as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The default propagation scheme</head><p>If PROPAGATE DEFAULT is used in a pSQL query fragment, the set of annotations of a piece of output data consists of all the annotations associated with the locations where that piece of data is copied from in the source.</p><p>The semantics of a pSQL query fragment Q with the default propagation scheme is as follows. For every binding of tuple variables to tuples in the respective relations according to the fromlist of Q such that the conditions in the wherelist are satisfied, emit an output tuple t according to the selectlist as well as the corresponding sets of annotations for every cell in t. Since every value of an output cell c in t is generated from some value of an input cell c according to the current bindings, the set of annotations attached to c is also attached to c . Finally, duplicate output tuples are merged together. Suppose t 1 , . . . , t k are the emitted tuples and s 1 , . . . , s m are the tuples that result when duplicate output tuples have been merged. That is, for every output location (s, B), we have A(s, B) = t j =s, j∈ <ref type="bibr">[1,k]</ref> A(t j , B).</p><p>Example 7 Suppose we have the following pSQL query where each fragment uses the default propagation scheme. The first subquery emits an output tuple "AB" with annotations {a 2 } and the second subquery emits the same output tuple "AB" but with annotations {a 12 }. The merged result of these two tuples is a single output tuple "AB" with annotations {a 2 , a 12 }. This explains the first output tuple in the result. A similar reasoning applies to the rest of the output tuples.</p><p>It is easy to see that a pSQL query fragment with default propagation scheme can be translated into a pSQL query fragment with custom propagation scheme. For example, the query Q 1 of Example 1 can be rewritten into a pSQL query with custom scheme where the propagate clause is replaced by "PROPAGATE s.ID TO ID, s.Desc TO Desc" since the ID value and Desc value of an output tuple are copied from s.ID and s.Desc, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The default-all propagation scheme</head><p>A pSQL query with the default propagation scheme is, essentially, an SQL query with annotations propagated based on where a value is retrieved according to the syntax of the query. We have already seen an example of two pSQL queries under the default propagation scheme (Example 2) which are equivalent but not annotation-equivalent.</p><p>This motivates us to define a third propagation scheme, called the default-all scheme, where the annotation propagation behavior of a pSQL query is invariant to the syntax of the query. A pSQL query Q with default-all propagation scheme propagates annotations according to the default propagation behavior of all equivalent formulations of Q. The resulting tuples that are generated by all equivalent queries of Q according to the default scheme are then merged together. Despite the fact that there are infinitely many equivalent formulations of Q, we describe a method that would compute the desired result by examining only a finite number of pSQL queries. We call such a finite set of queries a query basis of Q. Definition 2 Let Q denote a pSQL query with default-all propagation scheme. Let SQL(Q) denote the SQL query that corresponds to Q and let E(SQL(Q)) denote the set of all pSQL queries Q under the default propagation scheme such that SQL(Q</p><formula xml:id="formula_8">) is equivalent to SQL(Q). A query basis of Q, denoted as B(Q), is a finite set of pSQL queries such that q∈B(Q) q = a q∈E(SQL(Q)) q</formula><p>We describe next an algorithm that finds a query basis for a pSQL query with default-all propagation scheme. The size of the query basis that the algorithm returns is always polynomial in the size of Q. (The size of a query basis is the sum of sizes of each pSQL query fragment in the query basis. The size of each pSQL query fragment is the sum of the number of attributes in the selectlist, the number of relations in the fromlist and the number of attributes appearing in the wherelist.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Generating a query basis</head><p>The algorithm for computing a query basis for a pSQL query with default-all propagation scheme proceeds by first generating a representative query of Q, called Q 0 . (This is Step 1 of the algorithm Generate-Query-Basis below.) Intuitively, a representative query of Q is a query that is equivalent to Q and for every attribute B that is equal or transitively equal to an attribute A in the selectlist of Q, the annotations of B are propagated to A. More precisely, if A is among the selectlist and we have A = B and D = B in the wherelist of Q, then the propagatelist will contain the propagate clauses "A TO A", "B TO A" and "D TO A".</p><p>From Q 0 , a finite number of auxiliary queries are also generated and these queries, together with Q 0 , form a query basis of Q. (This is Step 2 of the algorithm.) Each auxiliary query is equivalent to Q but may propagate additional annotations to the output that are not propagated by Q 0 . In other words, every output value may contain additional annotations from attributes of other relations which contain identical values. Intuitively, only a finite number of auxiliary queries are needed because only one auxiliary query needs to be generated for each attribute of a relation that contributes annotations to the output. In the rest of the discussion, we restrict our language to be pSQL query fragments.</p><p>In other words, a query basis of Q, denoted as B(Q), is a finite set of pSQL query fragments such that</p><formula xml:id="formula_9">q∈B(Q) q = a q∈E(SQL(Q)) q, where E(SQL(Q)) de- notes the set of pSQL query fragments Q such that SQL(Q ) is equivalent to SQL(Q).</formula><p>We present next an algorithm for generating a query basis of a pSQL query fragment with default-all propagation scheme. The algorithm can be extended to handle pSQL queries (i.e., union of pSQL query fragments) in general and the details are described in the Appendix.</p><p>Algorithm Generate-Query-Basis Input: A pSQL query fragment Q with default-all propagation scheme. Output: A query basis of Q, B(Q). Let Q be a pSQL query fragment of the form shown in Definition 1 with PROPAGATE DEFAULT-ALL clause.</p><p>1. Generate Q 0 , the representative query of Q. Generate a query Q 0 that is identical to Q except that the propagation scheme of Q is replaced with the following propagation scheme: For every attribute "r.A AS C" in the selectlist, add "r.A TO C" to the PROPAGATE clause. For every attribute "r.A AS C" in the selectlist and every attribute s.B that is equal to r.A or transitively equal to r.A according to the wherelist, add "s.B TO C" to the PROPAGATE clause.</p><p>(The effect is that all attributes that are equal to an attribute C in the selectlist have their annotations propagated to C.) 2. Generate auxiliary queries of Q 0 .</p><p>Initialize B(Q) to the empty set. Add Q 0 to B(Q). For every attribute "r.A AS C" in the selectlist of Q 0 and every "s.B TO D" in the PROPAGATE clause of Q 0 where C=D, do the following: Create a query Q that is identical to Q 0 . Assume that s is a tuple variable for relation S. Add "S s " to the fromlist of Q where s is a tuple variable that does not occur in Q . Add "s .B=s.B" to the wherelist of Q and "s .B TO C" to the PROPAGATE clause of Q . (The auxiliary query Q is equivalent to Q but may carry additional annotations to the output.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Return B(Q).</head><p>Example 8 Consider the three databases, SWISS-PROT, PIR, and Genbank along with a Mapping table that contains the correspondences between identifiers of genes and proteins in the three databases in Fig. <ref type="figure">1</ref>. Such mapping tables commonly occur in integrating many sources with overlapping information <ref type="bibr" target="#b23">[26]</ref>. Suppose we have the following query Q that integrates information from SWISS-PROT and PIR. Note that the annotations of t.swissprot and s.ID will propagate to the output ID column according to Q 0 . The   The query Q 1 differs from Q 0 only in the additional highlighted terms shown in Q 1 . There is an extra relation, condition and propagation in the FROM, WHERE, and PROPAGATE clauses, respectively. It is easy to verify that the SQL queries of Q 0 and Q 1 are equivalent. There is a homomorphism h from the tuple variables of Q 1 to those of Q 0 such that h maps the fromlist of Q 1 to a subset of the fromlist of Q 0 and the conditions in the wherelist of Q 0 imply the conditions in the wherelist of Q 1 under h. Furthermore, h maps the selectlist of Q 1 to the selectlist of Q 0 . There is also a homomorphism in the reverse direction. Similarly, Q 2 , Q 3 , and Q 4 of Fig. <ref type="figure" target="#fig_1">2</ref> are each equivalent to Q 0 .</p><p>Intuitively, the representative query Q 0 propagates annotations according to where data is copied from and also where data could have been equivalently copied from. The reason why Q 0 is generated becomes clearer if we represent Q in conjunctive query-like notation, which we will continue to use throughout the rest of the discussion, for ease of exposition. In conjunctive query-like notation, a query Q is represented as</p><formula xml:id="formula_10">H ( x) : -S 1 ( ȳ1 ), . . . , S n ( ȳn ), equalities.</formula><p>where x, ȳi , i ∈ [1, n], denote vectors of variables and every variable in x occurs in ȳi for some i ∈ <ref type="bibr">[1, n]</ref> and equalities is a list of zero of more y=c clauses where y is a variable that occurs amongst ȳi s and c is a constant. The variables in x are called distinguished variables. Each subgoal corresponds to a relation in the fromlist of Q. The equalities between attributes in the wherelist of Q are represented by using the same variable in the respective positions of relations in the conjunctive query-like representation of Q. An equality between an attribute and constant is written out as equalities. The head of the query H ( x) represents the selectlist of Q. We use C(Q) to denote the conjunctive query-like representation of the SQL query that corresponds to Q. For example, C(Q 0 ) of Example 8 can be written as</p><formula xml:id="formula_11">H 0 (x, y, z) :-Mapping Table(w, x, u, v), SWISS-PROT(x, z), PIR(u, y).</formula><p>Similar to the semantics of pSQL queries with the default propagation scheme, annotations are propagated according to where data is copied from for such queries <ref type="bibr" target="#b6">[7]</ref> by tracing the occurrence of distinguished variables in the query. For example, by tracing the occurrence of the variable x in the query H 0 , we can conclude that the annotations in the first column of an output tuple t are obtained from the annotations of the second column of a tuple in Mapping Table <ref type="table"></ref>and<ref type="table"></ref> the first column of a tuple in SWISS-PROT that created t. A similar argument applies to the variables y and z in H 0 . Hence, the representative query Q 0 of Example 8 is annotation-equivalent to C(Q 0 ). We next focus on showing that given a query Q, the algorithm Generate-Query-Basis(Q) correctly generates B(Q), the query basis of Q. We first formally show that the representative query Q 0 generated by the algorithm is annotation-equivalent to its conjunctive query-like representation, C(Q 0 ) (Proposition 1). Using this result, we further show that the conjunctive query-like representation of each query generated by our Generate-Query-Basis algorithm is annotation-contained in q∈B(Q) q, the union of all queries in B(Q) (Proposition 2). Moreover, Lemma 1 shows that every query that is equivalent to Q is annotation-contained in q∈B(Q) q. Finally, we prove our main result (Theorem 1) which states that the algorithm Generate-Query-Basis correctly generates a query basis B(Q) for the input query Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 1</head><p>The representative query Q 0 that is generated by Generate-Query-Basis(Q) is annotation-equivalent to its conjunctive query-like representation, C(Q 0 ). Proof Obviously, the query Q 0 is equivalent to C(Q 0 ) since there is a subgoal S in C(Q 0 ) for every relation S in the fromlist of Q 0 and vice versa, there is an equality condition e in C(Q 0 ) for every equality condition e the wherelist of Q 0 and vice versa and the head of C(Q 0 ) produces the same attributes as the selectlist of Q 0 . We show next that Q 0 and C(Q 0 ) are annotation-equivalent by showing that for every database D and every output location (t, i)</p><formula xml:id="formula_12">of Q 0 (D), the set of annotations A(Q 0 (D), t, i) is equal to A(C(Q 0 )(D), t, i).</formula><p>We show that if a location l in the source D corresponds to a location l in the output of C(Q 0 )(D), then the annotations at l are part of the annotations at l according to Q 0 and D. The converse is also true.</p><p>According to the semantics of conjunctive queries with annotation propagation stated in <ref type="bibr" target="#b6">[7]</ref> (Appendix A.1), the set of annotations associated with an output location l is the union of the sets of annotations associated to each source location l that corresponds to l. A location</p><formula xml:id="formula_13">(s, i) in D cor- responds to (t, j) in C(Q 0 )(D) where C(Q 0 ) is of the form "H ( x) : -S 1 ( ȳ1 ), . . . , S n ( ȳn ), equalities" if the following holds: -for some k ∈ [1, n], ȳk [i]= x[ j],</formula><p>and there exists a valuation</p><formula xml:id="formula_14">ϕ from C(Q 0 ) into D such that H (ϕ( x)) = t, S k (ϕ( ȳk ))</formula><p>=s and the equalities are satisfied.</p><p>Suppose there is such a valuation ϕ for C(Q 0 ) as stated above. Then there is a valuation ϕ for Q 0 that produces t. The valuation ϕ is such that ϕ (r )=S(ϕ( ȳ)) where r is a tuple variable in Q 0 and S( ȳ) is the corresponding subgoal in C(Q 0 ) which represents the relation that r ranges over. So ϕ (u)=s for the tuple variable u in Q 0 which ranges over the relation S k and the output tuple is t under ϕ according to Q 0 . Since ȳk [i]= x[ j] in C(Q 0 ), it must be that the attribute at position i of S k (call it A) is equal to the attribute at position j in the selectlist of Q 0 (call it B) or transitively equal to B. Hence, there must be a clause "PROPAGATE u.A TO B" in the propagate clause of Q 0 . Therefore, under the valuation ϕ , the annotations at (s, i) are part of the annotations at (t, j) according to Q 0 and D.</p><p>For the converse, suppose there is a valuation ϕ for Q 0 and D such that the annotations at (s, i) are part of the annotations at (t, j) according to Q 0 and D with ϕ. So ϕ(u)=s for some tuple variable u in Q 0 and the output tuple is t under ϕ. Clearly, there must also be a valuation ϕ for C(Q 0 ) and D that produces t. The valuation ϕ is such that</p><formula xml:id="formula_15">S(ϕ ( ȳ))=ϕ(r ) where r is a tuple variable in Q 0 , S( ȳ) is a subgoal in C(Q 0 )</formula><p>and S is the relation that r ranges over. So there exists a subgoal S k ( ȳk</p><formula xml:id="formula_16">) in C(Q 0 ) for some k ∈ [1, n] such that S k (ϕ ( ȳk ))=s=ϕ(u).</formula><p>Let the ith attribute of s be A and the jth attribute of the output tuple t be B. Hence, there must be a "PROPAGATE u.A TO B" clause in Q 0 and "v.C AS B" is in the selectlist for some tuple variable v and attribute C. According to Generate-Query-Basis algorithm, this means that either u.A is equal to v.C or transitively equal to v.C. Hence, in C(Q 0 ), it must be that ȳk</p><formula xml:id="formula_17">[i]= x[ j]. So we have ȳk [i]= x[ j],</formula><p>H (ϕ ( x))=t, S k (ϕ ( ȳk ))=s and the equalities are satisfied under ϕ . Hence, (s, i) corresponds to (t, j) according to C(Q 0 ) and D with valuation ϕ .</p><p>In Step 2, the algorithm generates one query for every position in the body where a distinguished variable occurs in H 0 . For example, the following four auxiliary queries, in conjunctive query notation, are generated based on H 0 . They are annotation-equivalent to the pSQL query fragments Q 1 , . . . , Q 4 shown in Example 8 and Fig. <ref type="figure" target="#fig_1">2</ref>, respectively.</p><formula xml:id="formula_18">H 1 (x, y, z) :-Mapping Table(w, x, u, v), SWISS-PROT(x, z), PIR(u, y), Mapping Table(w 1 , x, w 2 , w 3 ). H 2 (x, y, z) :-Mapping Table(w, x, u, v), SWISS-PROT(x, z), PIR(u, y), SWISS-PROT(x, w 1 ). H 3 (x, y, z) :-Mapping Table(w, x, u, v), SWISS-PROT(x, z), PIR(u, y), SWISS-PROT(w 1 , z). H 4 (x, y, z) :-Mapping Table(w, x, u, v), SWISS-PROT(x, z), PIR(u, y), PIR(w 1 , y). Proposition 2 For every query Q ∈ B(Q) where B(Q) is the result of Generate-Query-Basis(Q), C(Q ) is annotation-contained in q∈B(Q) q. Proof First, C(Q 0 ) is annotation-contained in q∈B(Q) q since Q 0 ∈ B(Q) and C(Q 0 ) is annotation-equivalent to Q 0 according to Proposition 1. Let Q denote a query in B(Q) and Q is not Q 0 . That is, Q is one of the auxiliary queries. Let C(Q ) be of the form "H ( x) : -S 1 ( ȳ1 ), . . . , S n ( ȳn ), equalities". Given any database D, let (s, i) be a location in D which corresponds to a location (t, j) in C(Q )(D) on a valuation ϕ. So S k (ϕ( ȳk )) = s for some k ∈ [1, n] and H (ϕ( x)) = t and ȳk [i] = x[ j].</formula><p>There is also a valuation ϕ for Q and D which produces t. The valuation ϕ is such that ϕ (r ) = S(ϕ( ȳ)) where r is a tuple variable in Q and S( ȳ) is the corresponding subgoal in C(Q ) which represents the relation that r ranges over in Q . So ϕ (r 1 )=s for the tuple variable r 1 in Q which ranges over the relation S k and the output tuple is t under ϕ according to Q . We show next that for every annotation propagated by Q , there is a query in B(Q) that would propagate the annotation in the same way.</p><p>Suppose S k ( ȳk ) is a subgoal among the subgoals of C(Q 0 ) where Q 0 is the representative query generated by Step 1 of the algorithm Generate-Query-Basis. (Recall that C(Q ) differs from C(Q 0 ) in that it has an additional subgoal added by Step 2 of the algorithm.) Since ȳk [i]= x[ j] and S k ( ȳk ) is a subgoal among the subgoals of C(Q 0 ), it must be that the attribute at position i of S k (call it B) is equal to the attribute at position j in the selectlist of Q (call it A) or transitively equal to A. Hence, there must be a clause "PROPAGATE r 1 .B TO A" in the propagate clause of Q 0 (and hence Q ). Therefore, under the valuation ϕ , the annotations at (s, i) are part of the annotations at (t, j) according to Q and D.</p><p>Suppose S k ( ȳk ) is not a subgoal among the subgoals of C(Q 0 ). That is, S k ( ȳk ) is the subgoal that corresponds to the extra relation in the fromlist, added by Step 2 of algorithm Generate-Query-Basis. Let the attribute at the ith position of S k be B. By Step 2 of the algorithm, it must be that the condition "r 1 .B=r 2 .B" is the added condition in the wherelist for some tuple variable r 2 that ranges over a second S k relation in Q and "r 1 .B TO C" is the added propagate clause of Q for some output attribute C in the selectlist. Let the attribute at the jth position of the output be A. If C is the same as A, then the annotations at (s, i) are part of the annotations at (t, j) according to Q and D under the valuation ϕ . Suppose C is not equal to A. Since "r 1 .B=r 2 .B" and ȳk [i]= x[ j] in C(Q ), it must be that r 2 .B is equal or transitively equal to A. (Therefore, Q 0 must contain "r 2 .B TO A" in the propagate clause.) Hence, there must be a query q in B(Q) which is identical to Q except that "r 1 .B TO A" is in the propagate clause instead of "r 1 .B TO C". Therefore, under the valuation ϕ , the annotations at (s, i) are part of the annotations at (t, j) according to q and D.</p><p>Each auxiliary query carries annotations to the output that may have been missed by the representative query of Q. We shall show next that the set of pSQL query fragments in B(Q) generated by the algorithm is a query basis for Q. We first prove the following lemma.</p><p>Lemma 1 Let B(Q) denote the result produced by the algorithm Generate-Query-Basis(Q), where Q is a pSQL query fragment, and let Q denote a pSQL query fragment under the default propagation scheme.</p><formula xml:id="formula_19">If Q is equivalent to Q, then Q is annotation-contained in q∈B(Q) q.</formula><p>Proof The representative query Q 0 that is generated at Step 1 of the algorithm is annotation-equivalent to the conjunctive query representation of the SQL query that corresponds to Q, C(Q) (Proposition 1). We can also easily verify that Q ⊆ a C(Q ). Since C(Q) and C(Q ) are equivalent queries, the minimal queries of C(Q) and C(Q ) are identical up to variable renaming. For convenience, we shall assume that the minimal queries are identical in the form shown below. We also assume that there are no equalities between variables and constants, for convenience. (A minimal query is a query in which no subquery, one that has less subgoals or joins, is equivalent to it.)</p><formula xml:id="formula_20">C(Q): H ( x) :-minpart, rest1. C(Q ): H ( x) :-minpart, rest2.</formula><p>The subgoals denoted by minpart are the subgoals in the minimal query of C(Q) or C(Q ) and rest1 and rest2 denote the rest of the subgoals in C(Q) and C(Q ), respectively. Our proof makes use of an earlier result in <ref type="bibr" target="#b6">[7]</ref> extended for unions of conjunctive queries. Given a conjunctive query Q, we use the notation</p><formula xml:id="formula_21">Q[0] to denote the head of Q, the notation Q[i], i &gt; 0, to denote the ith subgoal of Q, and var(Q[i]) to denote the list of variables of the ith subgoal of Q. Fact 1 ([27], Appendix A.3) Given two unions of conjunc- tive queries Q = m i=1 Q i and Q = n j=1 Q j , Q ⊆ a Q if and</formula><p>only if for every Q r where r ∈ [1, m], every variable x, every i, and every p such that x that occurs at both the ith position of var(Q r [0]) and the jth position of var(Q r [ p]), there exists a homomorphism h from Q s (for some s ∈ <ref type="bibr">[1, n]</ref>) to Q r such that 1. h maps the body of Q s into the body of Q r and the head of Q s to the head of Q r , and 2. the variable that occurs at the jth position of the qth subgoal of Q s (i.e., var(Q s [q])[ j]) is identical to the variable at the ith position of the head of Q s (i.e., var(Q</p><formula xml:id="formula_22">s [0])[i]), where Q s [q] is a pre-image of Q r [ p] under h. That is, for some subgoal q, var(Q s [q])[ j] = var(Q s [0])[i] and h(Q s [q]) = Q r [ p].</formula><p>We shall show next that for every distinguished variable x at the ith position in the head of C(Q ) and its occurrence at the jth position of the pth subgoal S( ū) (i.e., the jth variable of ū is x) in the body of C(Q ), there is a generated query Q g in B(Q) and a homomorphism h : C(Q g ) → C(Q ) that satisfies the conditions (1) and ( <ref type="formula">2</ref>) stated in the fact. Then by the above fact, we have</p><formula xml:id="formula_23">C(Q ) ⊆ a C(Q g ). By Proposition 2, we know that C(Q g ) ⊆ a q∈B(Q) q. Therefore, C(Q ) ⊆ a q∈B(Q) q. Since Q ⊆ a C(Q ) and C(Q ) ⊆ a q∈B(Q) q, we have Q ⊆ a q∈B(Q) q</formula><p>, which was to be shown.</p><p>Let x be a distinguished variable at the ith position in the head of C(Q ) and suppose x occurs at the jth position of the pth subgoal S( ū) of C(Q ).</p><p>Case 1 If S( ū) is among the subgoals in the minpart of C(Q ), then it must also be among the subgoals in the minpart of C(Q). Hence, the algorithm Generate-Query-Basis would have generated one or more queries whose combined effect is the query C(Q g ), shown below,</p><formula xml:id="formula_24">H ( x) :-minpart, rest1, S( w1 , x, w2 ).</formula><p>The variable x occurs at the jth position in the subgoal S( w1 , x, w2 ) and w1 and w2 are vectors of distinct variables that do not occur in C(Q). This corresponds to Step 2 of the algorithm where a new relation S is added to the FROM clause. (Note that a clause "B TO A" is also added to the PROPAGATE clause to simulate the effect of x propagating annotations to the output. We assume that x occurs under the attribute A in the output and B is the attribute name of x in S in the named perspective. If x occurs under another attribute D in the output of C(Q g ), there will be another query generated by Step 2 of the algorithm that propagates the annotations of B to D. Hence, there is possibly more than one pSQL query whose combined annotation propagation effect equals that of C(Q g )). It is easy to see that there is a homomorphism from C(Q g ) to C(Q ) with the desired properties required by the fact shown above. The homomorphism is obtained by extending the homomorphism h : C(Q) → C(Q ) which we know exists since C(Q) and C(Q ) are equivalent. The homomorphism h is extended to h by mapping the ith variable in w1 to the corresponding ith variable in ū and the ith variable in w2 to the ( j + i)th variable in ū (this is possible since w1 and w2 are distinct variables). Clearly, h satisfies the conditions required by the above fact.</p><p>Case 2 If S( ū) are among the subgoals in rest2 of C(Q ), we first claim that a subgoal S( ū ), where the jth variable of u is x, must also occur among subgoals in the minpart of Q . With this, a similar argument presented before shows that there must be a homomorphism from a query C(Q g ) to C(Q ) with the desired conditions required by the above fact, which was to be shown.</p><p>We show next that if S( ū) are among the subgoals in rest2 of C(Q ), there must exist such a subgoal S( ū ) among the minpart of C(Q ) where the jth variable of ū is x. Since there is a homomorphism g from C(Q ) to the minimal query of C(Q ) and g(x)=x (since x is a distinguished variable), this implies that there must be a subgoal S(. . . x . . .) among the subgoals in the minpart of C(Q ) such that x occurs at the jth position of this subgoal. We therefore conclude that S( ū ) exists.</p><p>Theorem 1 Let Q be a pSQL query fragment with default-all propagation scheme. The algorithm Generate-Query-Basis(Q) returns a query basis of Q.</p><p>Proof Let E(Q) denote the set of pSQL query fragments q under the default propagation scheme such that the SQL query that corresponds to q is equivalent to that of Q (i.e., SQL(q)=SQL(Q)). Let B(Q) denote the result of running the algorithm Generate-Query-Basis on Q. By Lemma 1, we have that q∈E(Q) q ⊆ a q∈B(Q) q. Since B(Q) ⊆ E(Q) (the representative query and auxiliary queries are each equivalent to Q), we immediately have q∈B(Q) q ⊆ a q∈E(Q) q and hence the result.</p><p>The next proposition shows that the size of a query basis is polynomial in the size of Q. The size of a query basis is the sum of sizes of each pSQL query fragment in the query basis. The size of each pSQL query fragment is the sum of the number of attributes in the selectlist, the number of relations in the fromlist and the number of attributes appearing in the wherelist. This result shows that the result of executing a query basis is polynomial in the size of the database (data complexity).</p><p>Proposition 3 Given a pSQL query fragment Q with default-all propagation scheme, the number of queries returned by Generate-Query-Basis(Q) is polynomial in the size of Q. Furthermore, each query in Generate-Query-Basis(Q) is polynomial in the size of Q.</p><p>Proof Let s, f , and w denote the number of clauses in the selectlist, number of relations in the fromlist, and number of equalities in the wherelist of Q, respectively. The size of Q consists in the sum of the number of attributes in the selectlist, the number of relations in the fromlist and the number of attributes appearing in the wherelist, that is |Q| is at most s + f +2 * w. One representative query Q 0 is generated by the algorithm. The size of the propagate list of Q 0 is at most s + s * 2 * w. (In the worst case, every attribute in the wherelist propagates to every attribute in the selectlist.) The number of auxiliary queries generated is therefore at most s * (s +s * 2 * w) which is |selectlist| * |propagatelist|. Hence, the total number of queries in Generate-Query-Basis(Q) is at most 1 + s * (s + s * 2 * w).</p><p>The size of the selectlist, fromlist, wherelist, and propagatelist of Q 0 is s, f , w, and at most s + s * 2 * w, respectively. The size of each auxiliary query is thus at most s + ( f + 1) + (w + 2) + (s + s * 2 * w + 1) since one additional relation, one condition, and one propagate clause is added to Q 0 .</p><p>An optimization Observe that the auxiliary pSQL queries overlap significantly in the PROPAGATE clauses (e.g., see Fig. <ref type="figure" target="#fig_1">2</ref>); they differ only in the last (highlighted) propagation. In fact, we show that the non-highlighted propagations in the auxiliary queries are unnecessary (the details are omitted). Intuitively, they are unnecessary because these propagations are identical to the propagations of the representative query Q 0 . Hence, in our optimized implementation of Generate-Query-Basis, these non-highlighted propagations are not generated in the auxiliary queries. We refer to our original implementation of algorithm Generate-Query-Basis as the unoptimized implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">System architecture</head><p>The architecture of our annotation management system is illustrated in Fig. <ref type="figure">3</ref>. We have two main modules: the translator module and the postprocessor module. The translator module takes as input a pSQL query and returns as output an SQL query (i.e., a union of SPJ queries) which is sent to the relational database management system (RDBMS). The SQL query is then executed by the RDBMS. The tuples that are returned by the RDBMS are sorted in a certain order and sent to the postprocessor module which merges annotations of identical cells of duplicate tuples together in one pass through the sorted tuples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A naive storage scheme</head><p>At present, we store our annotations using a naive storage scheme: we assume that every attribute A of a relation scheme R has an extra column A a that will be used to store annotations. We denote this new relation with extra columns as R . For example, a relation R(A, B) will be represented as R (A, A a , B, B a ) in the naive storage scheme. Given a tuple t in a relation of R, if {a 1 , . . . , a k } are the annotations associated with the location (t, A), then there will be k tuples t 1 , . . . , t k in R such that t i .A a =a i for i ∈ [1, k] and the projection of t i on the attributes of R equals t, for i ∈ <ref type="bibr">[1, k]</ref>. For convenience, we sometimes use the relation name R to refer to R . As an example, the two instances of R shown below are both valid representations of the tuple </p><formula xml:id="formula_25">(a {a 1 , a 2 }, b {b 1 }). A A a B B a a a 1 b b 1 a a 2 b - A A a B B a a a 1 b - a a 2 b - a a 2 b b 1</formula><p>Observe that a query returns the same result regardless of the underlying storage instance used. Propagating Provenance To use our system to automatically propagate provenance along, we first associate each cell with a distinct annotation to denote its address. In what is shown below, R is defined as a view of an original relation R using internal row identifiers:</p><formula xml:id="formula_26">CREATE VIEW R AS SELECT A AS A, rowid||'#A' AS A a , B AS B, rowid||'#B' AS B a FROM R</formula><p>For the above view definition, rowid is an internal row identifier used in many database systems such as Oracle and Postgres. We refer the interested reader to <ref type="bibr" target="#b25">[28]</ref> for a detailed explanation of how one can automatically trace the provenance and flow of data using this naive storage scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The translator</head><p>The translator module takes as input a pSQL query Q and translates Q to an SQL query Q against the naive storage scheme. A pSQL query with default or default-all propagation scheme is first reformulated into one with a custom propagation scheme. A pSQL query with the custom propagation scheme is reformulated into an SQL query (i.e., a union of SPJ queries). The algorithm for reformulating a pSQL query fragment with default propagation scheme into a pSQL fragment with custom propagation scheme is described briefly at the end of Sect. 2.2. The algorithm for reformulating a pSQL query fragment with default-all propagation scheme into a pSQL query fragment with custom propagation scheme is described by the Generate-Query-Basis algorithm in Sect. 3. We describe next the algorithm for reformulating a pSQL query with custom propagation scheme into an SQL query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm Custom-pSQL-To-SQL</head><p>Input: A pSQL query fragment Q with custom propagation scheme.</p><p>Output: An SQL query Q s written against the naive schema.</p><p>Let Q be a pSQL query fragment of the form shown in Definition 1 with a custom-propagatelist. Observe that every tuple in SWISS-PROT will be emitted in such a way that the set of annotations associated with the Desc column of a tuple in the output is the union of annotations associated with both ID and Desc of the corresponding tuple in SWISS-PROT. Furthermore, the annotations associated with the Size column of a tuple are the same annotations associated with the Size column of the corresponding tuple in SWISS-PROT and the column ID of every tuple in the output does not carry any annotations. In Step 1 of algorithm Custom-pSQL-To-SQL, the following two intermediate SQL queries are generated since bin(ID) is empty, bin(Desc) = { s.ID a AS Desc a , s.Desc a AS Desc a } and bin(Size) = { s.Size a AS Size a }. </p><formula xml:id="formula_27">Q 1 = SELECT s.ID AS ID,</formula><formula xml:id="formula_28">Q s = SELECT DISTINCT * FROM (Q 1 UNION Q 2 ) ORDER BY ID, Desc, Size</formula><p>Observe that Q 1 and Q 2 are unioned and the result is sorted according to the attributes in the selectlist of Q. The tuples are sorted according to the selectlist of Q so that the postprocessor can merge annotations associated with identical cells in the output of Q in one pass over the result of Q s .</p><p>Observe also that the number of SQL queries in Q is equal to the maximum bin size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The postprocessor</head><p>The postprocessor scans the set of tuples returned by the RDBMS and unions together the annotations from duplicate tuples for proper display. This operation is done in linear time in the number and size of tuples retrieved, provided that the set of emitted tuples is already sorted. For example, if the postprocessor receives the first table of Sect. 4.1 as input, it returns { (a {a 1 , a 2 }, b {b 1 }) }.</p><p>Example 10 Suppose the following tuples are returned by the database system, sorted according to the attributes A and B.</p><formula xml:id="formula_29">A A a B B a a a 1 b a 2 a a 3 b - a - c a 2</formula><p>The result returned by the postprocessor is {(a {a 1 , a 3 }, b {a 2 }), (a {}, c {a 2 })}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental evaluation</head><p>We conducted several experiments to evaluate the feasibility of our annotation management system. Our main goal is to compare the performance of queries under different propagation schemes (default, default-all, or no propagation scheme (i.e., SQL queries)) and to compare the performance of queries when the number of annotations in a database is varied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Methodology</head><p>Our system is implemented with Java v1.4.2 on top of Oracle 9i Enterprise Edition Release 9.2.0.1.0. We conducted the experiments on a Pentium 4, 2.8 GHz machine with 1 GB RAM. Datasets The databases used to perform the experiments are from the TPC Benchmark H (TPCH) Standard Specification Revision 2.1.0 <ref type="bibr" target="#b26">[29]</ref>. For our experiments we used TPCH data of various sizes and we call these databases the unannotated databases. In order to create annotated datasets, we modified the TPCH schema to conform to our naive storage scheme by adding an additional attribute for every attribute of every relation in the TPCH schema. For each unannotated database, we have created three different instances of the modified TPCH database schema corresponding to 30, 60, and 100% annotated databases. A 30% annotated database means 30% of the total number of cells in every relation of the database will contain an annotation. We experimented with three datasets of sizes 100 MB, 500 MB, and 1 GB. In each dataset we have the unannotated database and the three annotated databases (30, 60, and 100%). Workload We ran queries of increasing join sizes and with varying number of output attributes to determine how well our system scales for these types of queries. As mentioned in Sect. 3, the number of joins and output attributes of a query are in fact particularly important in our Generate-Query-Basis algorithm. We did not use TPCH queries in our experiments because they include aggregates and nested queries.</p><p>The queries Q 0 , . . . , Q 4 which denote queries with zero to four joins, respectively, are shown in Fig. <ref type="figure" target="#fig_3">4(a)</ref>. For example, Q 2 denotes the query Supplier Nation Region with two joins, on the attributes Nationkey and Regionkey, respectively. The cardinality of each relation in the 100 MB dataset is shown in brackets. (For the 500 MB and 1 GB datasets, the cardinalities of relations Nation and Region are the same, while the cardinalities of relations Customer, Supplier and Partsupp are 5, and respectively, 10 times larger.) Our workload consists of queries <ref type="bibr" target="#b3">4]</ref>, which denote the queries with i joins and one, three, and five output attributes, respectively. Techniques We executed the workload queries under both the default and the default-all schemes on the annotated databases. We also executed the SQL query that corresponds to each of these queries on the unannotated databases, in order to be able to measure the overhead that the propagation of annotations introduces in the overall running time of the queries. All the experiments were performed on warm buffer and the buffer size was set to 256 MB.</p><formula xml:id="formula_30">Q i (1), Q i (3), Q i (5), i ∈ [0,</formula><p>We have implemented and tested both optimized as well as unoptimized versions of our Generate-Query-Basis algorithm. In what follows we present only our results obtained with the optimized version, as we observed that it consistently and significantly outperforms the unoptimized version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experimental results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment 1</head><p>The goal of this experiment is to compare the performance of pSQL queries under different propagation schemes (default, default-all, or no propagation scheme). We measured the performance of our system for queries under the default and default-all propagation scheme on the 100% annotated database in each of our three datasets. We executed the workload queries</p><formula xml:id="formula_31">Q i (1), Q i (3), Q i (5), i ∈ [0, 4]</formula><p>on the 100% annotated databases. We also executed the SQL query that corresponds to each of these queries on the unannotated databases. The results we obtained with the 100 MB, 500 MB, and 1 GB datasets are shown in Fig. <ref type="figure" target="#fig_3">4</ref>.</p><p>Figure <ref type="figure" target="#fig_3">4</ref>(b) illustrates the execution time (the total time taken by the translator, RDBMS, and postprocessor to emit all tuples in the result) of each query for the default and default-all propagation scheme on the 100% annotated database in the 100 MB dataset. As expected, the execution time of each query under the default scheme (respectively, the default-all scheme) increases slightly as more output attributes are emitted (see, for instance, Q 0 (1), Q 0 (3), and Q 0 (5)). The increase in time is due to longer execution time taken by Oracle as well as additional overhead incurred in postprocessing, as more attributes of different tuples need to be compared. Additionally, for the default-all scheme, the number of SPJ queries that are sent to Oracle increases (2, 4, and 6 SPJ queries, respectively) as the number of output attributes increases. Table <ref type="table">1</ref> provides the exact execution times of each query for 100% annotated database and the number of SPJ queries that are generated for the default-all scheme. We note that in the worst case, a query such as Q 4 (5) may run about eight times slower than both the query with default scheme and the actual SQL query. This is not unexpected, however, as there are 6 SPJ queries, each with four joins, that are generated and sent to Oracle for Q 4 (5), instead of 1. In the best case (see Q 4 (1)), a query with default-all scheme runs about twice as slow than the same query with default scheme. We note however that for the default scheme, the execution times of pSQL queries are comparable to those of SQL queries. On the average, the pSQL queries with default scheme that we experimented with took around 40% more time to execute than their corresponding SQL queries, and at best the execution time of a pSQL query with default scheme is the same as the execution time of its corresponding SQL query (e.g., Q 4 (1)).</p><p>For the default-all scheme there is no increase in the number of pSQL and SPJ queries that are generated when the number of joins increases, since the attributes that are selected do not participate in the joins. (The performance of default-all pSQL queries where attributes that participate in the joins are selected as well is evaluated in Experiment 3.) The number of pSQL and SPJ queries that are generated increases when the number of output attributes increases and they increase linearly. The execution times of Q 1 ( j), j ∈ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b4">5]</ref>, decreases slightly when compared with Q 0 ( j) because a join on a small relation has been made.</p><p>We observed the same trends for larger datasets as well. Figure <ref type="figure" target="#fig_3">4</ref>(c) and 4(d) illustrate the execution time of each query for the default and default-all propagation scheme on the 100% annotated databases in the 500 MB, and respectively, 1 GB datasets. However, we observed that the overhead of propagating annotations under the default scheme is smaller on larger datasets. On the average, the pSQL queries with default scheme took only about 15 and 24% more time to execute than their corresponding SQL queries Table <ref type="table">1</ref> The execution time of each query for each database in the 100 MB dataset and each propagation scheme. The columns "#pSQL" and "#SPJ" denote the size of the query basis and number of SPJ queries that are generated, respectively, for the default-all scheme. on the 500 MB, and respectively, 1 GB dataset. This is explained by the fact that on larger datasets, the postprocessing time tends to become less significant when compared to the actual time taken by the database engine to execute the queries.</p><p>Experiment 2 In this experiment we evaluate the influence of the number of annotations in a database on the execution time of pSQL queries under default or default-all schemes. We executed the workload queries <ref type="bibr" target="#b3">4]</ref> under both default and default-all schemes on the 30, 60 and 100% annotated databases. The results we obtained with the 100 MB, 500 MB, and 1 GB datasets are illustrated in Fig. <ref type="figure" target="#fig_0">5</ref> (the results obtained with the 100 MB dataset are also tabulated in Table <ref type="table">1</ref>). We observed that the execution time of each query increases only slightly across databases annotated in various degrees and this fact is not unexpected. As the number of annotations in the database increases, we expect an increase in the postprocessing time, as more annotations need to be compared and unioned together. Table <ref type="table">2</ref> shows the average percentage increases incurred in the total execution times of the default and default-all queries we experimented with. On the 100 MB dataset, for example, the total execution time for default queries increases on the average 0.71% when the number of annotations in the database is doubled from 30% annotations to 60% annotations and 1.85% when the number of annotations is varied from 60% annotations to 100% annotations. We also remark that an increase in the number of annotations in the database induces smaller increases in the total execution times of default-all queries when compared to default queries. This is intuitive because for defaultall queries, the postprocessing time is less significant when compared to the actual time taken by the engine to execute the queries. Experiment 3 In this experiment we evaluate the effect of selecting attributes that participate in join conditions on the performance of default-all pSQL queries. For this purpose, we measured the execution time of queries</p><formula xml:id="formula_32">Q i (1), Q i (3), Q i (5), i ∈ [0,</formula><formula xml:id="formula_33">Q i (1 + j), Q i (3 + j), Q i (5 + j), i ∈ [1, 3], j ∈ [1, i]</formula><p>under the default-all propagation scheme on the annotated databases in the 100 MB dataset. These queries are identical to our original workload queries</p><formula xml:id="formula_34">Q i (1), Q i (3), Q i (5), i ∈ [1, 3],</formula><p>except that their selectlist additionally contains j attributes selected among the attributes that appear in some join condition in the wherelist. For example, consider the query Q 1 (1) which computes the join of tables Supplier and Nation on the Nationkey attribute. The query Q 1 (1 + 1) is identical to Q 1 <ref type="bibr" target="#b0">(1)</ref>, except that the attribute Nationkey (which does not appear in the selectlist of Q 1 (1)) appears in the selectlist of Q 1 (1+1). The execution times of these queries are shown in Fig. <ref type="figure">6</ref> (they are also tabulated in Table <ref type="table">3</ref>). The execution times of queries Q i (1), Q i (3), Q i (5), i ∈ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref> are shown as well, for comparison purposes. Table <ref type="table">3</ref> also illustrates the number of tuples retrieved by each query before the postprocessing step. The number of output tuples retrieved by each query after postprocessing is 1,000.</p><p>As expected, the execution time of the queries under the default-all propagation scheme increases as more attributes that participate in the joins are selected. On the 30% annotated database for example, the query Q 2 (1 + 1) runs three times slower when compared to Q 2 (1) and the query Q 2 (1 + 2) takes 15% more time to run compared to Q 2 (1 + 1). This is expected, since more pSQL queries are generated by our Generate-Query-Basis algorithm (hence more SPJ queries are executed) as the number of selected attributes involved in join conditions increases. As shown in Table <ref type="table">3</ref>, there are 5, and respectively, 7 SPJ queries that are executed in order to retrieve the correct annotations under the default-all scheme for queries Q 2 (1 + 1) and Q 2 (1 + 2), while only 2 SPJ queries are executed in case of Q 2 (1). On the average, we observed that the queries we experimented with took about 5.9, 6.2, and 34.5 times more time to execute on the 30, 60%, and respectively, 100% annotated databases when one join attribute was selected compared to the same queries with no join attributes appearing in their selectlist. When two join attributes where selected, the queries</p><formula xml:id="formula_35">(Q i (1 + 2), Q i (3 + 2), Q i (5 + 2), i ∈ [2,<label>3</label></formula><p>]) run on the average about 1.03, 1.84, and 1.24 times slower on the 30, 60%, and respectively, 100% annotated databases compared to the same queries where only one join attribute was selected (i.e., <ref type="bibr">]</ref>). Finally, the queries which select three join attributes</p><formula xml:id="formula_36">Q i (1 + 1), Q i (3 + 1), Q i (5 + 1), i ∈ [2,<label>3</label></formula><formula xml:id="formula_37">(Q 3 (1 + 3), Q 3 (3 + 3), Q 3 (5 +<label>3</label></formula><p>)) run about 4, 11, and respectively, 10 times slower on the 30, 60%, and respectively, 100% annotated databases compared to the same queries where only two join attributes are selected (i.e.,</p><formula xml:id="formula_38">Q 3 (1 + 2), Q 3 (3 + 2), Q 3 (5 + 2)).</formula><p>Observe that as the number of selected join attributes increases, not only that there are more SPJ queries that are executed, but the query engine and the postprocessor Table <ref type="table">2</ref> The average percentage increases incurred in the total execution times of the queries under both default and default-all schemes when the number of annotations in the database is varied from 30 to 60% annotations and from 60 to 100% annotations</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Default</head><p>Default-all 30-60% 60-100% 30-60% 60-100% Dataset (%) increase (%) increase (%) increase (%) increase 100 MB 0.71  <ref type="table">3</ref> The execution time of each default-all query from Experiment 3 on the 30, 60, and 100% annotated databases in the 100 MB dataset. The columns "#pSQL" and "#SPJ" denote the size of the query basis, and respectively, the number of SPJ queries that are generated. The columns "#tuples" show the number of tuples retrieved by the queries before the postprocessing phase. module are given significantly more tuples to sort and respectively, merge. In the case of query Q 1 (1) for example, there are 1,000 tuples that have to be sorted and further postprocessed. However, in the case of query Q 1 (1 + 1) (which additionally selects one join attribute), there are 2,000, and respectively, 41,000 tuples that have to be sorted and postprocessed when this query is run on the 60%, and respectively, 100% annotated databases. This explains why Q 1 (1 + 1) runs about 5, and respectively, 38 times slower on the 60%, and respectively, 100% databases when compared to Q 1 <ref type="bibr" target="#b0">(1)</ref>. There is a simple explanation for the fact that as many as 41,000 tuples are retrieved (before postprocessing) when query Q 1 (1 + 1) is run on the 100% database. Recall that this query performs a join between the tables Supplier and Nation on the Nationkey attribute which is also selected in the output. There are 1,000 tuples in Supplier and 25 distinct values for the attribute Nationkey.</p><p>Since in the 100% database each value has one distinct annotation, it follows that each distinct Nationkey value in the table Supplier has about 40 distinct annotations. According to our Generate-query-basis algorithm, a query that performs a self-join of Supplier on the Nationkey attribute will be executed in order to extract the 40 distinct annotations for each Supplier tuple (these annotations are </p><formula xml:id="formula_39">Q 1 ( 1 ) Q 1 ( 1 + 1 ) Q 2 ( 1 ) Q 2 ( 1 + 1 ) Q 2 ( 1 + 2 ) Q 3 ( 1 ) Q 3 ( 1 + 1 ) Q 3 ( 1 + 2 ) Q 3 ( 1 + 3 ) Q 1 ( 3 ) Q 1 ( 3 + 1 ) Q 2 ( 3 ) Q 2 ( 3 + 1 ) Q 2 ( 3 + 2 ) Q 3 ( 3 ) Q 3 ( 3 + 1 ) Q 3 ( 3 + 2 ) Q 3 ( 3 + 3 ) Q 1 ( 5 ) Q 1 ( 5 + 1 ) Q 2 ( 5 ) Q 2 ( 5 + 1 ) Q 2 ( 5 + 2 ) Q 3 ( 5 ) Q 3 ( 5 + 1 ) Q 3 ( 5 + 2 ) Q 3 ( 5 + 3 )</formula><p>seconds (log scale)</p><p>Unannotated DB 30% Annotated DB 60% Annotated DB 100% Annotated DB Fig. <ref type="figure">6</ref> Performance comparison for default-all queries on the 100 MB dataset when the number of join attributes selected in the output is varied all needed, according to the semantics of pSQL queries with default-all propagation scheme). This query will clearly generate around 40,000 tuples. Although it seems very excessive to pull out all these 40 annotations for each tuple in Supplier, we note however that this situation arose precisely because each Nationkey value had a distinct annotation in the Supplier table . A scenario where we may have one annotation for each Nationkey value is when we are interested in tracing the provenance of data and each annotation represents an address. In this case, however, the default scheme for propagating annotations is more suitable. Our experimental results show that there may be significant overhead to the default-all scheme when annotations can be excessive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experiment 4</head><p>In this experiment we evaluate the performance of pSQL queries with default and default-all propagation schemes on databases annotated more than 100%. For this purpose, we have created three additional databases of size 100 MB with 130, 160%, and respectively, 200% annotations. In the 130% (respectively, 160%) annotated database, 30% (respectively, 60%) of the values have two annotations, while the rest of the values have only one annotation. In the 200% database, each value has two annotations.</p><p>We measured the performance of our system for the workload queries Q i (1), Q i (3), Q i <ref type="bibr" target="#b4">(5)</ref>, i ∈ [0, 4] under the default and default-all propagation scheme on the 130, 160, and 200% annotated 100 MB databases. The results we obtained are tabulated in Table <ref type="table">4</ref> (For comparison purposes, Table <ref type="table">4</ref> also shows the execution time of the corresponding SQL queries on the unannotated 100 MB database.) Figure <ref type="figure" target="#fig_6">7</ref> illustrates the execution time of each query for the default and default-all propagation scheme on the 100 MB database with 200% annotations. As expected, the execution time of each query under the default scheme (and respectively, default-all scheme) increases as more output attributes are emitted. As we previously explained (Experiment 1), this increase is due to longer execution time taken by Oracle, as well as additional overhead in postprocessing and an increase in the number of SPJ queries that are generated and executed (for the default-all scheme). On average, a pSQL default query Q i <ref type="bibr" target="#b0">(1)</ref> <ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b3">4]</ref> took between three times (e.g., queries with 0 or 1 joins) and 25 times (e.g., queries with 4 joins) more time to execute compared to their corresponding SQL queries. This is an obvious consequence of our naive scheme, since each 200% annotated relation has a double number of tuples compared to the same relation with no annotations. This leads to longer postprocessing time as well as longer execution time taken by the query engine, as a double number of tuples have to be processed from each relation. (Also note that the more joins in the query, the longer the execution time taken by the query engine.) Under the default-all scheme, a query such as Q 4 (5) may run around 13 times slower when compared to the same query with default propagation scheme, in the worst case. This is expected, since there are 6 SPJ queries that are sent to the query engine, instead of one. In the best case (see Q 1 (1)) a query with defaultall scheme runs about twice as slow then the same query Table <ref type="table">4</ref> The execution time of each query for each propagation scheme and each database annotated more than 100% in the 100 MB dataset. The columns "#pSQL" and "#SPJ" denote the size of the query basis and number of SPJ queries that are generated, respectively, for the default-all scheme.</p><formula xml:id="formula_40">, Q i (3), Q i (5), i ∈ [0,</formula><p>Query Unannotated 130% Def 130% Def-all 160% Def 160% Def-all 200% Def 200% Def-all #pSQL #SPJ Q 0 <ref type="bibr" target="#b0">(1)</ref> 0  under the default scheme. Under both default and default-all schemes, the queries with 3 joins (i.e., Q 3 (1), Q 3 (3), and Q 3 (5)) behaved unexpectedly. Under the default scheme, these queries ran about 39 times slower (on the average) compared to their corresponding SQL queries. The queries Q 3 (3) and Q 3 (5) took about 17, and respectively, 42 times longer to execute under the default-all scheme when compared to the default scheme. While investigating this issue we discovered that the anomaly arises because Oracle chose really poor execution plans for these particular queries.</p><p>Figure <ref type="figure" target="#fig_7">8</ref> shows the execution times of the queries with default and default-all schemes on the 100 MB databases with 100, 130, 160, and 200% annotations. On average, we observed that the queries with default scheme run six times slower when the number of annotations was increased from 100 to 130%. This is due to two factors. First, there are 30% more tuples in the 130% annotated database compared to the 100% annotated database. Second, Oracle chose a poorer plan for executing the queries on the 130% database, with a different join ordering as well as different join algorithms. The plan built for the 130% annotated database involved the nested loops algorithm, while hash joins were used in the plan constructed for the 100% annotated database. By tweaking the Oracle optimizer, we were able to detect that the plan built for the 100% annotated database (using hash joins only) performed much better on the 130% annotated database compared to the plan chosen by the optimizer (which involved nested loops). The queries with default scheme run on the average about 1.2 times slower when the number of annotations was increased from 130 to 160% annotations, as well as from 160 to 200% annotations. This increase in the execution time is mostly due to the fact that the number of tuples in the database increases with the number of annotations. In general, we observed that for each query, the plan the optimizer chose for the 160 to 200% annotated databases was the same as the plan chosen for the 130% annotated database. For the queries with 3 joins (i.e., Q 3 (1), Q 3 (3), and Q 3 (5)), the optimizer chose a poorer plan on the 160% annotated database when compared to the plans generated for both the 130 and 200% annotated databases. This explains why these queries (under both default and default-all propagation schemes) run slower on the 160% annotated database than on both the 130 and 200% annotated databases. On the average, the queries with default-all scheme took about 13, 1.3, and respectively, 1.8 times longer to execute when the number of annotations was increased from 100 to 130% annotations, 130 to 160% annotations, and respectively, from 160 to 200% annotations. Empirical Conclusions All our results indicate that the time required to translate the queries is insignificant when compared to the execution time of the queries and the postprocessing time of the queries is proportional to the number and size of emitted tuples. Also, the execution times of default queries on databases annotated up to 100% are comparable to the performance of SQL queries since only one SPJ is generated and the number of annotations in a database does not have a major influence in the execution time of pSQL queries in this case. The execution time of each query for both default and default-all scheme increases marginally when the number of annotations in the database is, for example, doubled from 30% annotations to 60%. However, the performance of pSQL queries starts to degrade significantly on databases with more than 100% annotations. This indicates that our naive storage scheme is perhaps not the best suited in such conditions. As future work, we plan to investigate the trade-offs between the naive storage scheme and other possible storage schemes which we briefly discuss in Sect. 6.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Other possible schemes for managing annotations</head><p>Besides our naive storage scheme, there are other possible schemes for storing and managing annotations. We briefly discuss two of them next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Annotation-Relation Storage Scheme</head><p>In this scheme, annotations of a relation R are stored in a separate relation R A, which we call the 'annotation-relation of R'. The basic schema of R A has three attributes (id, attribute, annotation) where an id value uniquely identifies a tuple in R, a name value is an attribute name in the schema of R and an annotation value is an annotation of the location (id, name). An id can either be the primary key of relation R, in which case R A may have more than three attributes, or some unique identifier used in the database system (e.g., rowid in Oracle). For example, to store the tuples { (a {a 1 , a 2 }, b, {b 1 }), (c, d) } of the relation R(A, B) with A as the key of the relation, we would have an annotation-relation R A(id, attribute, annotation) with the following tuples: (a, A, a 1 ), (a, A, a 2 ), (a, B, b 1 ).</p><p>We have yet to investigate the trade-offs between the naive scheme and annotation-relation scheme. However, we expect that the annotation-relation scheme may require less storage space than the naive scheme in general. On the other hand, one needs to pay a performance penalty in using the annotation-relation scheme as a join between R and R A is required to retrieve the relevant annotations of a location in R. Nested Sets Approach It is easy to observe that the multiplicity of a tuple in the naive storage scheme depends on the number of annotations associated with that tuple. Instead, a more natural approach would have been to store annotations associated with each location as nested sets (i.e., the relation R(A, B) would be stored as R (A, A a , B, B a ), where A a and B a are of type nested set). Unfortunately, the nested set approach is not currently feasible, since not all commercial databases support nested sets and among those who do, none offers satisfactory support for the operations we need. As an example, in Oracle 10g the annotation union operation (i.e., the operation of merging duplicate tuples and their corresponding annotations together) is not direct and has to be performed in several steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Extensions</head><p>So far, our pSQL queries do not allow aggregates and bag semantics (i.e., the DISTINCT keyword must be present). We discuss briefly next how we might extend pSQL to handle aggregates and bag queries as well. Aggregates For the default propagation scheme, if a pSQL query contains aggregates such as count, sum, and average, we assume the semantics that no annotations are associated with the result of these aggregates, since these aggregate values are not copied from any source values. However, for aggregates such as min(a) and max(a), where a is an attribute name, our semantics is that the annotations associated with the location of the resulting min (or max) value are the union of all annotations of the corresponding a-values whose value equals to the min (or max) value. It remains to investigate whether the default-all propagation scheme for pSQL queries with aggregates can be achieved. Bag Semantics It is known from <ref type="bibr" target="#b27">[30]</ref> that two conjunctive queries are equivalent under bag semantics if and only if they are isomorphic. This result of <ref type="bibr" target="#b27">[30]</ref> implies that to propagate annotations for a pSQL query under the defaultall propagation scheme and bag semantics, it suffices to generate only the representative query of that pSQL query in Algorithm Generate-Query-Basis. To handle bag queries, however, the naive storage scheme can no longer be used since the multiplicity of a tuple in this storage scheme depends on the number of annotations that are associated with that tuple. An alternative storage scheme that does not modify the original relation is needed (e.g., store every annotation and its location in a separate relation).</p><p>To propagate annotations under the default-all propagation scheme and bag semantics for unions of conjunctive queries, however, it remains to first provide a characterization of bag equivalence for unions of conjunctive queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion and future work</head><p>We have described an implementation of an annotation management system where different propagation schemes can be used. Insofar, our system only supports annotations on attributes of tuples. We would like to extend our system to handle annotations on tuples or relations and, in general, to handle annotations on hierarchical data, such as XML. In this extended framework we are interested in determining which annotations to propagate under different operators. We would also like to investigate whether our results for the default-all propagation scheme still hold.</p><p>In our current system, annotations are propagated based on where-provenance. In addition, we would like to extend our system to propagate annotations based on whyprovenance, which will provide reasons to why a tuple is in the output. The default-all propagation scheme returns the union of all annotations of an output location returned by all equivalent queries. Conceivably, there could be a complementary propagation scheme that returns the set of all annotations in an output location if it occurs in the same output location in the results of all equivalent queries. It remains to be investigated whether a query basis can be generated for such propagation scheme. The performance of our annotation management system on other storage schemes also needs to be investigated. It would also be interesting to investigate opportunities for optimizations on the generated SQL queries.</p><p>1. Generate Q i 0 , the representative query of Q i . Generate a query Q i 0 that is identical to Q i except that the propagation scheme of Q i is replaced with the following propagation scheme: For every attribute "r.A AS C" in the selectlist, add "r.A TO C" to the PROPAGATE clause. For every attribute "r.A AS C" in the selectlist and every attribute s.B that is equal to r.A or transitively equal to r.A according to the wherelist, add "s.B TO C" to the PROPAGATE clause. (The effect is that all attributes that are equal to an attribute C in the selectlist have their annotations propagated to C.) 2. Generate auxiliary queries of Q i 0 . Initialize B(Q i ) to the empty set. Add Q i 0 to B(Q i ). For every clause "s.A AS B" in the selectlist of Q i 0 , for every relation R in the database and every attribute C in the relation schema of R: Create a query Q that is identical to Q i 0 . Add "R r" to the fromlist of Q where r is a tuple variable that does not occur in Q . Add the condition "r.C = s.A" to the wherelist of Q and the propagate clause "r.C TO B" to the propagatelist of Q</p><formula xml:id="formula_41">. Add Q to B(Q i ). (The query Q is contained in Q i but may propagate additional annotations. Furthermore, q∈B(Q i ) q is equivalent to Q i .) Return B(Q 1 ) ∪ ... ∪ B(Q m ).</formula><p>Example 11 Assume that the database consists of the following relations: Emp(name, dept), Dept(did, budget), Project(proj, mgr). Consider following query Q which picks out employees who belong to some department. The highlighted parts of Q 1 and Q 2 denote the additional relation, condition and propagate clauses added to the representative query Q 0 by Step 2 of the algorithm. Observe that Q 1 and Q 2 are queries that are contained in Q (but</p><formula xml:id="formula_42">Q 0 ∪ Q 1 ∪ Q 2 is equivalent to Q). Furthermore, Q 1 prop</formula><p>agates annotations on projects to the result and Q 2 propagates annotations from the names of managers to the result. Arguably, Q 1 should not have been generated since the annotations for projects are irrelevant for names of employees. The query Q 2 , however, propagates the annotations for a manager to an employee name and this is desired since the manager and the employee have the same name (and are therefore referring to the same entity). Some observations from the above example follow. First, since our language now allows for union, the query basis for Q contains more queries than the query basis generated by Generate-Query-Basis for the same query Q. This is because in the case of Generate-Query-Basis, we consider only pSQL query fragments that are equivalent to Q. In contrast here, we consider all pSQL queries that are equivalent to Q. The above example also suggests that a more refined method of generating a query basis is needed. Namely, one should only generate an auxiliary query if it propagates relevant annotations. In the above example, Q 2 is desired but not Q 1 . To generate only auxiliary queries that propagate relevant annotations, one would require the knowledge of semantically equivalent attributes in a database to be kept in the system. Queries are then generated by adding the extra relation and equating only semantically equivalent attributes. In what follows, we shall assume that both Q 1 and Q 2 are generated.</p><p>Observe that by equating "r.C = s.A" in Step 2, we are assuming that all attributes have the same type. The algorithm Generate-Containment-Basis takes as input Q = Q 1 ∪ ... ∪ Q l and generates as output a query basis B(Q) which is B(Q 1 ) ∪ ... ∪ B(Q l ). The following proposition is similar to Proposition 2, adapted for queries generated by algorithm Generate-Containment-Basis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 4</head><p>For every query Q in the result of Generate-Containment-Basis(Q) (denoted as B(Q)), C(Q ) is annotation-contained in q∈B(Q) q.</p><p>Proof Let Q = Q 1 ∪...∪ Q l and let Q i 0 denote the representative query generated by Step 1 of the algorithm for query Q i . We have C(Q i 0 ) is annotation-contained in q∈B(Q i ) q since Q i 0 ∈ B(Q i ) and C(Q i 0 ) is annotation-equivalent to Q i 0 according to Proposition 1.</p><p>Let Q denote a query in B(Q) and Q is not Q i 0 for every i ∈ <ref type="bibr">[1, l]</ref>. That is, Q is one of the auxiliary queries, generated by Step 2 of the algorithm. Let C(Q ) be of the form "H ( x) : -S 1 ( ȳ1 ), . . . , S n ( ȳn ), equalities". Given any database D, let (s, i) be a location in D which corresponds to a location (t, j) in C(Q )(D) on a valuation ϕ. So S k (ϕ( ȳk )) = s for some k ∈ <ref type="bibr">[1, n]</ref> and H (ϕ( x)) = t and ȳk [i] = x[ j]. There is also a valuation ϕ for Q and D which produces t. The valuation ϕ is such that ϕ (r ) = S(ϕ( ȳ)) where r is a tuple variable in Q and S( ȳ) is the corresponding subgoal in C(Q ) which represents the relation that r ranges over in Q . So ϕ (r 1 ) = s for some tuple variable r 1 in Q and the output tuple is t under ϕ according to Q . We show next that for every annotation propagated by Q , there is a query in B(Q) that would propagate the annotation in the same way.</p><p>Suppose Q is in B(Q i ) for some i ∈ [1, l] and S k ( ȳk ) is a subgoal among the subgoals of C(Q i 0 ) where Q i 0 is the representative query generated by Step 1 of the algorithm Generate-Containment-Basis. (Recall that C(Q ) differs from C(Q i 0 ) in that it has an additional subgoal added by Step 2 of the algorithm.) Since ȳk [i] = x[ j] and S k ( ȳk ) is a subgoal among the subgoals of C(Q i 0 ), it must be that the attribute at position i of S k (call it B) is equal to the attribute at position j in the selectlist of Q (call it A) or transitively equal to A. Hence, there must be a clause "PROPAGATE r 1 .B TO A" in the propagate clause of Q i 0 (and hence Q ). Therefore under the valuation ϕ , the annotations at (s, i) are part of the annotations at (t, j) according to Q and D.</p><p>Suppose S k ( ȳk ) is not a subgoal among the subgoals of C(Q i 0 ). That is, S k ( ȳk ) is the subgoal that corresponds to the extra relation in the fromlist, added by Step 2 of algorithm Generate-Containment-Basis. Let the attribute at the ith position of S k be C. Since ȳk [i] = x[ j] and by Step 2 of the algorithm, it must be that the condition "r 1 .C = r 2 .A" is the added condition in the wherelist for some tuple variable r 2 that ranges over a relation in Q . The clause "r 1 .C TO B" is the added propagate clause of Q for some output attribute B in the selectlist. (Hence, "r 2 .A AS B" is among the selectlist of Q .) Let the attribute at the jth position of the output be F. If B is the same as F, then the annotations at (s, i) are part of the annotations at (t, j) according to Q and D under the valuation ϕ . Suppose B is not equal to F. Since "r 1 .C = r 2 .A" and ȳk [i] = x[ j] in C(Q ), it must be that r 2 .A is equal or transitively equal to the output attribute F (according to Q i 0 ). In other words, let "r 3 .E TO F" be the select clause for F (which is among the selectlist of Q i 0 ) where r 3 is a tuple variable in Q i 0 and E is an attribute. We have r 3 .E is either equal or transitively equal to r 2 .A according to the wherelist of Q i 0 . Hence, the following query Q from Q i 0 will be generated: Q has an extra relation "S k r 1 " in the fromlist, the added condition "r 1 .C = r 3 .E" in the wherelist and the added propagate clause "r 1 .C TO F". Since under ϕ , we have r 1 .C = r 2 .A and r 2 .A is equal or transitively equal to r 3 .E, it follows that r 1 .C = r 3 .E. Therefore the valuation ϕ is also a valuation for Q . Hence, the annotations at (s, i) are part of the annotations at (t, j) according to Q and D.</p><p>Our proof for the following Lemma 2 uses a result from <ref type="bibr" target="#b28">[31]</ref>. Fact 2 ([31]) Let Q = i∈ <ref type="bibr">[1,m]</ref> Q i and Q = i∈ <ref type="bibr">[1,n]</ref> Q i be unions of conjunctive queries. Then Q ⊆ Q if and only if for every Q i , i ∈ [1, m], there exists Q j , j ∈ <ref type="bibr">[1, n]</ref>, such that Q i ⊆ Q j .</p><p>Lemma 2 Let B(Q) denote the result produced by the algorithm Generate-Containment-Basis(Q), where Q is a pSQL query and let Q denote a pSQL query under the default propagation scheme. If Q is equivalent to Q, then Q is annotation-contained in q∈B(Q) q.</p><p>Proof Let Q = Q 1 ∪ ... ∪ Q l , q∈B(Q) q = q 1 ∪ ... ∪ q m and let</p><formula xml:id="formula_43">Q = Q 1 ∪ ... ∪ Q n .</formula><p>We shall show next that for every distinguished variable x at the ith position in the head of C(Q f ) where f in <ref type="bibr">[1, n]</ref> and its occurrence at the jth position of the kth subgoal S( ū) (i.e., the jth variable for ū is x) of C(Q f ), there is a generated query q g ∈ B(Q) such that there is a homomorphism h : C(q g ) → C(Q f ) that satisfies conditions (1) and (2) of Fact 1. Then by the Fact 1, we have C(Q 1 ) ∪ ... ∪ C(Q n ) ⊆ a q∈B(Q) C(q). For every pSQL query fragment Q, it is the case that Q ⊆ a C(Q). So we have Q ⊆ a C(Q 1 ) ∪ ... ∪ C(Q n ) and therefore Q ⊆ a q∈B(Q) C(q). By Proposition 4, q∈B(Q) C(q) ⊆ a q∈B(Q) q. Hence, we have Q ⊆ a q∈B(Q) q, which was to be shown. Pick a distinguished variable x at the ith position in the head of C(Q f ) where f ∈ <ref type="bibr">[1, n]</ref> and at the jth position of the kth subgoal S( ū) of C(Q f ). That is, x occurs at the ith position in H (. . .), S is the kth subgoal and x occurs at the jth position in S(. . .).</p><p>C(Q f ) : H (. . . x . . .) :-. . . , S( z1 , x, z2 ), . . . By Fact 2, since C(Q) is equivalent to C(Q ), there exists a query C(Q g ) for some g ∈ <ref type="bibr">[1, l]</ref> such that C(Q f ) ⊆ C(Q g ). Consequently, there is a containment mapping h : C(Q g ) → C(Q f ). Accordingly, we know that Generate-Containment-Basis would generate a query q g according to Q g such that C(q g ) is identical to C(Q g ) but has an additional subgoal S( w1 , y, w2 ) where w1 and w2 are vectors of fresh variables that do not occur elsewhere in C(q g ). That is, C(q g ) has the form shown below where y is the distinguished variable that occurs in the ith position in the head of C(Q g ) and the j position in S(...).</p><p>C(q g ) : H (. . . y . . .) :-body of C(Q g ), S( w1 , y, w2 ).</p><p>It is easy to see that there is a homomorphism h : C(q g ) → C(Q f ) that satisfies conditions (1) and ( <ref type="formula">2</ref>) of Fact 1. The homomorphism h is such that h(x) = h (x) for every x ∈ var(Q g ), h( w1 ) = z1 , and h( w2 ) = z2 . Clearly, h is consistent with h and is a homomorphism from C(q g ) to C(Q f ). Hence, by Fact 1, C(Q f ) ⊆ a C(q g ).</p><p>Theorem 2 Given a pSQL query Q, the algorithm Generate-Containment-Basis(Q) generates a query basis of Q.</p><p>Proof Let Q be a pSQL query Q 1 ∪ ... ∪ Q l . Let Q R denote the union of all queries in B(Q). That is,</p><formula xml:id="formula_44">Q R = q∈B(Q) q. Clearly, Q R is contained in Q since each B i (Q i ), i ∈ [1, l],</formula><p>contains a representative query which is equivalent to Q i and every other query in</p><formula xml:id="formula_45">B i (Q i ) is contained in Q i . The query Q is also contained in Q R since for every Q i , i ∈ [1, l], Q i is equivalent to the representative query of Q i in Q R . Let E(Q)</formula><p>denote the set of all equivalent queries of Q where each query in E(Q) propagates using the default scheme. Since Q R is equivalent to Q, we have Q R ∈ E(Q). Hence, Q R ⊆ a q∈E(Q) q. From Lemma 2, we know that for every query q ∈ E(Q), we have q ⊆ a Q R . Therefore q∈E(Q) q ⊆ a Q R and hence Q R = a q∈E(Q) q.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 5</head><label>5</label><figDesc>The queries Q and Q in Example 2 are equivalent. However, they are not annotation-equivalent since different annotations are associated with the results. Consider the following query Q: SELECT DISTINCT g.ID AS ID, g.Desc AS Desc FROM Genbank g PROPAGATE g.ID TO ID, g.Desc TO ID, g.ID TO Desc</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Some of the auxiliary queries generated by Step 2 of Generate-Query-Basis on Example 8</figDesc><graphic coords="8,48.89,62.32,492.00,126.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Q</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4</head><label>4</label><figDesc>Fig. 4 (a) Queries used in our experiments and (b)-(d) comparison in performance for default and default-all schemes on the 100 MB, 500 MB, and respectively 1 GB dataset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5</head><label>5</label><figDesc>Fig.<ref type="bibr" target="#b4">5</ref> Performance comparison for default and default-all pSQL queries on databases annotated in various degrees. (a), (b) Default and respectively, default-all queries on the 100 MB dataset, (c), (d) default, and respectively, default-all queries on the 500 MB dataset and (e), (f) default, and respectively, default-all queries on the 1 GB dataset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7</head><label>7</label><figDesc>Fig.<ref type="bibr" target="#b6">7</ref> Comparison in performance for default and default-all schemes on the 100 MB database annotated 200%</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8</head><label>8</label><figDesc>Fig. 8 Performance comparison for default (a) and default-all (b) pSQL queries on 100 MB databases with more than 100% annotations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="4,108.51,62.21,372.00,189.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>WHERE p.ID = m.pir Q = SELECT DISTINCT m.pir AS ID, p.Name AS Name FROM PIR p, Mapping Table m WHERE p.ID = m.pir The results of running Q and Q under the default propagation scheme are shown below. } AB {a 8 } p916 {a 9 } AB {a 10 } AB {a 8 } p916 {a 21 } AB {a 10 }</figDesc><table><row><cell>Result of Q : ID p332 {a 7 Result of Q : Name ID p332 {a 17 }</cell><cell>Name</cell></row></table><note><p>Example 2 Consider two equivalent SQL queries Q and Q (two queries are equivalent if they produce the same result on every database). Q = SELECT DISTINCT p.ID AS ID, p.Name AS Name FROM PIR p, Mapping Table m</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table t ,</head><label>t</label><figDesc>SWISS-PROT s, PIR p WHERE t.swissprot = s.ID AND t.pir = p.ID PROPAGATE DEFAULT-ALL After Step 1 of the above algorithm, we obtain the following representative query Q 0 :</figDesc><table /><note><p>SELECT DISTINCT t.swissprot AS ID, p.Name AS Name, s.Desc AS Desc FROM Mapping SELECT DISTINCT t.swissprot AS ID, p.Name AS Name, s.Desc AS Desc FROM Mapping Table t, SWISS-PROT s, PIR p WHERE t.swissprot = s.ID AND t.pir = p.ID PROPAGATE t.swissprot TO ID, s.ID TO ID, p.Name TO Name, s.Desc TO Desc</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Q be the empty set of SQL queries. Repeat until all bins are empty:Let Q be a query that is identical to Q 0 . For each output attribute C of Q, if bin(C) is nonempty, remove a clause "s.B a AS C a " from bin(C) and add it to the selectlist of Q . If bin(C) is empty, we add "NULL AS C a " to the selectlist of Q . Add Q to Q. 2. Generate a wrapper SQL query Q s for Q. Consider the SWISS-PROT relation of Fig.1and assume that there is an extra attribute Size. Suppose we have the following pSQL query Q with custom propagation scheme written against SWISS-PROT:</figDesc><table><row><cell cols="2">Let SELECT DISTINCT *</cell></row><row><cell>FROM</cell><cell>(Q 1 UNION • • • UNION Q n )</cell></row><row><cell>ORDER BY</cell><cell>orderbylist</cell></row><row><cell cols="2">where Q = {Q 1 , ..., Q n } and orderbylist is the list of all</cell></row><row><cell cols="2">output attributes in the selectlist of Q. The orderbylist is</cell></row><row><cell cols="2">required so that the postprocessor can merge annotations</cell></row><row><cell cols="2">of identical tuples together with one pass over the result</cell></row><row><cell>of Q s .</cell><cell></cell></row><row><cell>3. Return Q s .</cell><cell></cell></row><row><cell>Example 9</cell><cell></cell></row></table><note><p>1. Generate intermediate SQL queries. Each intermediate SQL query retrieves annotations (as much as possible) from the naive schema according to the given query Q. Let Q 0 be a query that is identical to Q except that it does not have the PROPAGATE clause of Q. For each output attribute C of Q, create an empty bin for C. Denote this bin as bin(C). For each propagate clause "s.B TO C" in the custom-propagatelist of Q, add "s.B a AS C a " to bin(C). SELECT s.ID AS ID, s.Desc AS Desc, s.Size AS Size, FROM SWISS-PROT s PROPAGATE s.ID TO Desc, s.Desc TO Desc, s.Size TO Size,</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>NULL AS ID a s.Desc AS Desc, s.ID a AS Desc a , s.Size AS Size, s.Size a AS Size a , FROM SWISS-PROT s Q 2 = SELECT s.ID AS ID, NULL AS ID a s.Desc AS Desc, s.Desc a AS Desc a , s.Size AS Size, NULL AS Size a ,</figDesc><table><row><cell>FROM</cell><cell>SWISS-PROT s</cell></row><row><cell cols="2">In Step 2, the algorithm generates the following wrapper</cell></row><row><cell>SQL query:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>pSQL Default vs. pSQL Default-All on the 200% annotated 100MB TPCH database</head><label></label><figDesc></figDesc><table><row><cell></cell><cell>.0282</cell><cell>0.0814</cell><cell>0.1846</cell><cell>0.084</cell><cell>0.1906</cell><cell>0.087</cell><cell>0.1844</cell><cell>2</cell><cell>2</cell></row><row><cell>Q 1 (1)</cell><cell>0.025</cell><cell>0.0746</cell><cell>0.122</cell><cell>0.0656</cell><cell>0.1314</cell><cell>0.072</cell><cell>0.1472</cell><cell>2</cell><cell>2</cell></row><row><cell>Q 2 (1)</cell><cell>0.019</cell><cell>0.069</cell><cell>0.1376</cell><cell>0.0782</cell><cell>0.1628</cell><cell>0.0908</cell><cell>0.2092</cell><cell>2</cell><cell>2</cell></row><row><cell>Q 3 (1)</cell><cell>0.1532</cell><cell>1.933</cell><cell>5.9284</cell><cell>2.875</cell><cell>9.2096</cell><cell>6.8282</cell><cell>37.4134</cell><cell>2</cell><cell>2</cell></row><row><cell>Q 4 (1)</cell><cell cols="2">92.4604 1644.0896</cell><cell cols="2">5029.2506 2648.0438</cell><cell cols="2">8392.7502 1682.842</cell><cell>5594.8612</cell><cell>2</cell><cell>2</cell></row><row><cell>Q 0 (3)</cell><cell>0.0252</cell><cell>0.1034</cell><cell>0.4622</cell><cell>0.1062</cell><cell>0.481</cell><cell>0.0966</cell><cell>0.5084</cell><cell>4</cell><cell>4</cell></row><row><cell>Q 1 (3)</cell><cell>0.0312</cell><cell>0.103</cell><cell>0.4968</cell><cell>0.1094</cell><cell>0.55</cell><cell>0.1062</cell><cell>0.5534</cell><cell>4</cell><cell>4</cell></row><row><cell>Q 2 (3)</cell><cell>0.0284</cell><cell>0.1128</cell><cell>0.5344</cell><cell>0.1126</cell><cell>0.6254</cell><cell>0.1312</cell><cell>0.725</cell><cell>4</cell><cell>4</cell></row><row><cell>Q 3 (3)</cell><cell>0.191</cell><cell>2.356</cell><cell>17.9904</cell><cell>3.4872</cell><cell>27.1808</cell><cell>7.569</cell><cell>135.0818</cell><cell>4</cell><cell>4</cell></row><row><cell>Q 4 (3)</cell><cell cols="7">100.0106 1973.217 16386.8308 3152.887 27529.0176 2324.8586 20096.4258</cell><cell>4</cell><cell>4</cell></row><row><cell>Q 0 (5)</cell><cell>0.0502</cell><cell>0.1438</cell><cell>0.953</cell><cell>0.1534</cell><cell>1.0408</cell><cell>0.1594</cell><cell>1.1088</cell><cell>6</cell><cell>6</cell></row><row><cell>Q 1 (5)</cell><cell>0.0438</cell><cell>0.1438</cell><cell>1.019</cell><cell>0.147</cell><cell>1.147</cell><cell>0.1498</cell><cell>1.216</cell><cell>6</cell><cell>6</cell></row><row><cell>Q 2 (5)</cell><cell>0.0406</cell><cell>0.147</cell><cell>1.1</cell><cell>0.156</cell><cell>1.443</cell><cell>0.175</cell><cell>1.5158</cell><cell>6</cell><cell>6</cell></row><row><cell>Q 3 (5)</cell><cell>0.231</cell><cell>2.7968</cell><cell>34.1068</cell><cell>4.153</cell><cell>51.9968</cell><cell>8.2562</cell><cell>346.1802</cell><cell>6</cell><cell>6</cell></row><row><cell>Q 4 (5)</cell><cell cols="2">111.8918 2347.7426</cell><cell cols="5">32228.192 3857.2314 53906.3124 3082.9914 42571.6014</cell><cell>6</cell><cell>6</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Xinyu Hua for her help during the initial implementation of this system and Ariel Fuxman for helpful suggestions. We also thank the reviewers for their helpful suggestions. Supported in part by NFS CAREER Award IIS-0347065 and NFS grant IIS-0430994.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generating a query basis for pSQL queries</head><p>To generate a query basis for a pSQL query Q = Q 1 ∪...∪ Q l where each Q i , i ∈ <ref type="bibr">[1, l]</ref>, is a pSQL query fragment with default-all propagation scheme, we modify Generate-Query-Basis algorithm described in Sect. 3 to the following algorithm, called Generate-Containment-Basis. Step 1 of Generate-Containment-Basis remains the same as in Generate-Query-Basis.</p><p>The algorithm Generate-Containment-Basis differs from Generate-Query-Basis in Step 2, where for each pSQL query fragment Q i (1 ≤ i ≤ l), the set of all queries that are contained in Q i are generated and added to the auxiliary queries of Q i . A consequence of this effect is that a query that is identical to Q i but with an additional relation R that does not occur in Q i is considered as a query contained in Q i . Annotations from R may propagate to the output. In contrast, Step 2 of Generate-Query-Basis generates a set of auxiliary pSQL query fragments that are each equivalent to Q i . Note that we are not restricting our language to be pSQL query fragments here (as opposed to algorithm Generate-Query-Basis). We are computing a query basis for the set of all pSQL queries that are each equivalent to a given pSQL query. We describe the algorithm next and then an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm Generate-Containment-Basis</head><p>, is a pSQL query fragment of the form shown in Definition 1 with PROPAGATE DEFAULT-ALL clause. For each Q i , i ∈ [1, l], we execute the following two steps.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Uniprot: the universal protein knowledgebase</title>
		<author>
			<persName><forename type="first">R</forename><surname>Apweiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bairoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Barker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Boeckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ferro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gasteiger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lopez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Magrane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Natale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>O'donovan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Redaschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="115" to="D119" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The SWISS-PROT protein sequence database and its supplement TrEMBL</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bairoch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Apweiler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="45" to="48" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The Public Catalog of Databases</title>
		<author>
			<persName><surname>Dbcat</surname></persName>
		</author>
		<ptr target="http://www.infobiogen.fr/services/dbcat/." />
		<imprint>
			<date type="published" when="2000-06-05">5 June 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The seaview security model</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Lunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Schell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Shockley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Heckman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="218" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Polyinstantiation integrity in multilevel relations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jajodia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy<address><addrLine>Oakland, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="104" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A decentralized model for information control</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the ACM Symposium on Operating Systems Principles (SOSP)<address><addrLine>Saint-Malo, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Containment of relational queries with annotation propagation</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Database and Programming Languages (DBPL)</title>
		<meeting>the International Workshop on Database and Programming Languages (DBPL)<address><addrLine>Potsdam, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="3" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Source attribution for querying against semi-structured documents</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bressan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madnick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Web Information and Data Management (WIDM)</title>
		<meeting><address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A polygen model for heterogeneous database systems: The source tagging perspective</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Madnick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Very Large Data Bases (VLDB)</title>
		<meeting>the International Conference on Very Large Data Bases (VLDB)<address><addrLine>Brisbane, Queensland, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="519" to="538" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Tracing the lineage of view data in a warehousing environment</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wiener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst. (TODS)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="227" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Database Theory (ICDT)</title>
		<meeting>the International Conference on Database Theory (ICDT)<address><addrLine>London, United Kingdom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="316" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Meta-data support for data transformations using microsoft repository</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bergstraesser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="14" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Superimposed information for the internet</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Delcambre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on the Web and Databases (WebDB)</title>
		<meeting>the International Workshop on the Web and Databases (WebDB)<address><addrLine>Philadelphia, Pennsylvania</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Annotea: An open rdf infrastructure for shared web annotations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koivunen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prud'hommeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Swick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International World Wide Web Conference(WWW10)</title>
		<meeting>the International World Wide Web Conference(WWW10)<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="623" to="632" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A protocol for scalable group and public annotations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Laliberte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Braverman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International World Wide Web Conference(WWW3)</title>
		<meeting>the International World Wide Web Conference(WWW3)<address><addrLine>Darmstadt; Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multivalent documents</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Phelps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Communications of the Association for Computing Machinery (CACM)</title>
		<meeting>the Communications of the Association for Computing Machinery (CACM)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="82" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Pan-browser support for annotations and other meta-information on the world wide web</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Schickler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Mazer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International World Wide Web Conference(WWW5)</title>
		<meeting>the International World Wide Web Conference(WWW5)<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A distributed annotation system</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dowell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Washington University in St. Louis</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The human genome browser at UCSC</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Sugnet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Furey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Roskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Pringle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Zahler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Haussler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="996" to="1006" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Multivalent annotations</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Phelps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First European Conference on Research and Advanced Technology for Digital Libraries</title>
		<meeting>the First European Conference on Research and Advanced Technology for Digital Libraries<address><addrLine>Pisa, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="287" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Robust intra-document locations</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Phelps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International World Wide Web Conference(WWW9)</title>
		<meeting>the International World Wide Web Conference(WWW9)<address><addrLine>Amsterdam; The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="105" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On propagation of deletions and annotations through views</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Database Systems (PODS)</title>
		<meeting>the ACM Symposium on Principles of Database Systems (PODS)<address><addrLine>Wisconsin, Madison</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="150" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Foundations of databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley Co</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Mapping data in peer-to-peer systems: Semantics and algorithmic issues</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kementseitsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data (SIGMOD)</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data (SIGMOD)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="325" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Containment of relational queries with annotation propagation</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>UC Santa Cruz</publisher>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">DBNotes: A postit system for relational databases based on provenance</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vijayvargiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM SIGMOD International Conference on Management of Data (SIGMOD) &apos;05</title>
		<meeting>the 2005 ACM SIGMOD International Conference on Management of Data (SIGMOD) &apos;05</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="942" to="944" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<ptr target="http://www.tpc.org" />
		<title level="m">TPC Transaction Processing Performance Council</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Optimization of real conjunctive queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Database Systems (PODS)</title>
		<meeting>the ACM Symposium on Principles of Database Systems (PODS)<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Equivalence among relational expressions with union and difference operators</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Assoc. Comput. Machine. (JACM)</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="633" to="655" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
