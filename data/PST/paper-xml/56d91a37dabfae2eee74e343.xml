<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Selective Cache Ways: On-Demand Cache Resource Allocation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">David</forename><forename type="middle">H</forename><surname>Albonesi</surname></persName>
							<email>albonesi@ece.rochester.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of Rochester Rochester</orgName>
								<address>
									<postCode>14627-0231</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Selective Cache Ways: On-Demand Cache Resource Allocation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Increasing levels of microprocessor power dissipation call for new approaches at the architectural level that save energy by better matching of on-chip resources to application requirements. Selective cache ways provides the ability to disable a subset of the ways in a set associative cache during periods of modest cache activity, while the full cache may remain operational for more cache-intensive periods. Because this approach leverages the subarray partitioning that is already present for performance reasons, only minor changes to a conventional cache are required, and therefore, full-speed cache operation can be maintained. Furthermore, the tradeoff between performance and energy is flexible, and can be dynamically tailored to meet changing application and machine environmental conditions. We show that trading off a small performance degradation for energy savings can produce a significant reduction in cache energy dissipation using this approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Continuing advances in semiconductor technology have fueled dramatic performance gains for general-purpose microprocessors. These improvements are due both to increasing clock rates as well as to the additional hardware support that can be provided for exploiting instruction-level parallelism and memory locality. However, a negative byproduct has been a significant increase in power dissipation, due to the fact that the dynamic power (which, at least currently, is the dominant contributor to power consumption in highspeed CMOS circuits) is proportional to both clock frequency and to the switching capacitance, which increases as more functionality is added. Thus, despite herculean attempts to reduce voltages and design lower power circuits, power dissipation levels have steadily increased with each new microprocessor generation.</p><p>Table <ref type="table" target="#tab_0">1</ref> summarizes the characteristics of four genera-tions of Alpha microprocessors. In the six years separating the first (21064) and most recent (21264) generations, power dissipation has doubled from 30W to 60W, despite the fact that the energy per transition (calculated in the last column by dividing the power dissipation by the clock frequency <ref type="bibr" target="#b8">[9]</ref>) has declined during this period. Thus, rapid increases in both clock frequency and chip functionality (and thus switching capacitance) are outpacing circuit design attempts to keep power dissipation to reasonable levels. Power projections for the next implementation of the Alpha line (21364 <ref type="bibr" target="#b4">[5]</ref>) indicate that this trend is expected to continue. Similarly, while the UltraSparc I microprocessor <ref type="bibr" target="#b23">[24]</ref> dissipated 28W at 167MHz, the UltraSparc III design <ref type="bibr" target="#b13">[14]</ref> is estimated to dissipate 70W at 600MHz, despite the fact that the energy per transition is comparable in both generations.</p><p>Because of the inability of circuit-level techniques to singlehandedly keep power dissipation to reasonable levels, there has been increasing interest in architectural approaches that reduce the switching capacitive power component. These techniques improve energy dissipation by reducing the number of signal transitions within the microprocessor for a given workload. One focus area for such work has been the on-chip cache hierarchy, due to the fact that an increasing percentage of die area is being devoted to cache transistors, and that on-chip L1 caches alone can comprise over 40% of the total die power budget <ref type="bibr" target="#b22">[23]</ref>.</p><p>Several approaches have been implemented in commercial microprocessors to reduce cache energy dissipation by limiting switching activity. The SA-110 embedded microprocessor <ref type="bibr" target="#b22">[23]</ref> uses 32-way associative 16KB L1 I and Dcaches, each of which is divided into 16 fully associative subarrays. With this scheme, only one-eighth of the cache is enabled for each access which considerably reduces dynamic power. With a 160MHz target clock frequency, the SA-110 designers were able to maintain a one cycle cache latency with this degree of associativity. In a high performance microprocessor with L1 caches several times larger in size and clock rates in the GHz range, such a solution would likely increase L1 cache latencies, and significantly impact the performance of many applications.</p><p>A similar approach is used to reduce power consumption in the 21164 microprocessor's 96KB, 3-way set associative L2 cache, whose data portion is split into 24 banks. The tag lookup and data access are performed in series rather than in parallel as with a conventional cache. This allows for predecoding and selection of 6 of the 24 data banks in parallel with tag access, and final access of only the 2 banks associated with the selected way <ref type="foot" target="#foot_0">1</ref> . Because only a small fraction of the total L2 cache is enabled on each access, the dynamic power savings is considerable, estimated at 10W <ref type="bibr" target="#b12">[13]</ref>. However, when applied to an L1 cache, the serial tagdata access of this technique would significantly increase cache latency as with the SA-110 approach.</p><p>Several other approaches have been proposed for reducing the switching activity in on-chip caches. The filter cache <ref type="bibr" target="#b17">[18]</ref> attempts to reduce energy dissipation by placing a small (and therefore low-energy) cache in front of the L1 cache. If many L1 cache requests can be serviced by the filter cache, then L1 cache switching activity can be greatly reduced thereby saving energy; indeed, a 65% energy savings is demonstrated with 256 byte instruction and data filter caches backed by a 32KB unified L1 cache. However, the cost is a 29% performance degradation relative to a conventional design due to an increase in the access time on a filter cache miss. The L-Cache <ref type="bibr" target="#b5">[6]</ref> similarly reduces switching activity by holding loop-nested basic blocks designated by the compiler and providing these to the pipeline in place of the larger L1 Icache. Because the compiler selectively chooses which basic blocks to include in the L-cache, a much smaller performance overhead (1-5%) is incurred compared with the filter cache. However, the benefits of the L-Cache are limited to large basic blocks within loops that are executed many times; therefore, less than a 10% savings in cache energy dissipation is realized for the four SPECint95 benchmarks that were evaluated.</p><p>Each of these techniques significantly alters the cache design in order to improve energy efficiency. An alternative approach is to start with a high performance set associative cache design and to exploit the subarray partitioning that is usually present for performance reasons. With this partitioning in place, only minor hardware modifications are necessary to provide the ability to enable all of the cache ways when required to achieve high performance, but to enable only a subset of the ways when cache demands are more modest. In the latter case, the remainder of the ways can be placed in a quiescient state, thereby reducing cache switching activity. This approach, which we call selective cache ways, provides the highest performance solution in an on-demand fashion, and opportunistically trades off a small performance penalty for significant energy savings when appropriate. Selective cache ways exploits the fact that cache requirements may vary considerably between applications, as well as during the execution of an individual application. With appropriate software support for determining sufficient L1 cache requirements and enabling the appropriate number of cache ways, a significant savings in cache energy can be realized without degrading the performance of more cache-intensive programs. The rest of this paper further explores this concept and is organized as follows. In the next section, we examine the subarray partitioning that is necessary to achieve optimal L1 cache performance, and how this partitioning can be exploited to tailor the cache organization to application requirements. We then discuss in Section 3 the selective cache ways approach, and in Section 4, we evaluate the energy savings obtained with different levels of tolerable performance degradation. Software support for selective cache ways is discussed in Section 5, and we conclude and present future work in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Partitioning Caches for Performance</head><p>Selective cache ways exploits the fact that large on-chip caches are often partitioned into multiple subarrays to reduce the long word and/or bitline delays of a single large array. This is especially true for the data array and for set associative caches for which the wordlines can be exceed-  <ref type="bibr" target="#b20">[21]</ref>. Our analysis using the Cacti cache cycle time model <ref type="bibr" target="#b24">[25]</ref> for smaller caches produces similar results. Table <ref type="table" target="#tab_1">2</ref> shows the N parameters from Cacti that produce the fastest cycle time for various caches. The parameters Ndwl and Ntwl refer to the number of times the wordlines are segmented for the data and tag arrays, respectively, while Ndbl and Ntbl are the corresponding parameters for the bitlines.</p><p>The parameters Nspd and Ntspd refer to the number of sets that are mapped to the same wordline for the data and tag arrays, respectively. Referring to Table <ref type="table" target="#tab_1">2</ref>, we see that in all cases, multiple subarrays are required for optimal performance. In particular, we note that Ndwl is at least as large as the associativity in all cases. A key insight for set associative caches is that when Ndwl is greater than or equal to the associativity, the resulting organization is already partitioned such that a subset of the data ways can operate without changing the basic cache organization or the index-tag address partitioning. Only a small amount of additional gating logic must be added. Thus, the resulting organization can run at the speed of a conventional cache, yet provide the ability to selectively turn off ways when appropriate. However, some overhead is incurred when changing the number of enabled ways, including ensuring that modified data is handled correctly. In the next section, we provide further details on this and other aspects of the selective cache ways approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Selective Cache Ways</head><p>Selective cache ways combines the following hardware and software elements:</p><p>A partitioning of the data and possibly the tag arrays into one or more subarrays for each cache way; Decision logic and gating hardware for disabling the operation of particular ways;</p><p>A software-visible register, called the Cache Way Select Register (CWSR), that signals the hardware to enable/disable particular ways; Special instructions, called WRCWSR and RDCWSR, for writing and reading, respectively, the CWSR; Software support for analyzing application cache requirements, enabling cache ways appropriately, and saving the CWSR as part of the process state; Support for sharing data in disabled ways and maintaining its proper coherency state.</p><p>In the following subsections, we describe the hardware aspects of selective cache ways; software support for this approach is discussed in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Hardware Organization</head><p>Figure <ref type="figure">1</ref> is an overall diagram of a 4-way set associative cache using selective cache ways. The wordlines of the data array are segmented four times per the Cacti results of Table 2, creating four separate data way elements. The bitlines of each data way may be segmented as well. Note that the tag portion of the cache (which includes the status bits) is identical to that of a conventional cache. Cacti-based timing estimates indicate that for the cache organizations we have studied, segmenting the tag wordlines will result in a significant cache cycle time degradation relative to the optimal tag N parameters of Table <ref type="table" target="#tab_1">2</ref>. Thus, our approach only saves energy in the data portion of the caches we have studied. However, the data portion comprises roughly 90% of the total energy dissipation for these organizations.</p><p>The Cache Way Select Register (CWSR) is written and read via the WRCWSR and RDCWSR instructions and contains four bits in this example (en way0, en way1, en way2, and en way3), each of which signals the Cache Controller to enable a particular way, and thereby allow it to operate. If a particular way enable bit is zero, the sel way signal for that way is also zero (except in limited circumstances that are discussed in Section 3.3). Therefore, the data way is not precharged, no word lines are selected, and the sense amps are prevented from firing. Thus, with this scheme, no data is selected from a disabled way and its data array dissipates essentially no dynamic power. Note that the replacement decision logic within the Cache Controller must also ensure that no data is allocated to a disabled way.</p><p>The degree to which ways are disabled is a function of two factors. The first is the relative energy dissipations of different memory hierarchy levels and how each is affected by disabling ways. The second is the amount of performance degradation that can be tolerated, which is discussed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Performance Degradation Threshold</head><p>The Performance Degradation Threshold (PDT) signifies how much performance degradation relative to a cache with all ways enabled is allowable. Thus, if the PDT is 2% for a given period of execution, and performance is projected to degrade by 1% with three ways of a 4-way cache enabled, and 4% with two ways enabled, then three ways are enabled, so long as the total energy is less than that with four ways enabled. Thus, the minimum energy dissipation is not necessarily that with only one way enabled, as the increase in L2 cache energy dissipation may override the decrease in L1 energy.</p><p>One advantage of selective cache ways over static solutions to energy reduction is that the tradeoff between per-formance and energy dissipation can be made variable via different PDT values. Thus, a different tradeoff can be made among machines that use the same microprocessor, and between different applications running on the same machine. Different PDT values can even be used for different instantiations of the same application on the same machine. For example, a server application may be invoked to run in a "low energy cache mode" during low-activity periods, and run in a "high performance cache mode" with more cache ways enabled during high-load periods. The operating system or a continuous profiling and optimization system <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b25">26]</ref> could effectively control the PDT by changing the number of ways enabled under different loading conditions. In Section 4, we evaluate the energy savings that is achievable with different PDT values. In the next subsection, we address the issue of how to properly handle access to data stored in a disabled way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Maintaining Data Accessibility</head><p>When an L1 Dcache way is disabled, modified cache blocks must be made accessible to the same process and to sharing processes (on the same processor or other processors) and to the I/O subsystem. Also, data coherency must be maintained in case the way is reenabled.</p><p>One approach to this problem is to flush all blocks from a way before it is disabled. However, although some processors provide architectural support for cache flushing, this operation may impose considerable overhead if ways are frequently disabled. In addition, frequent cache flushing can significantly impact cache miss rate <ref type="bibr" target="#b3">[4]</ref>, and considerable energy may be expended.</p><p>An alternative approach is to make all ways accessible at all times for coherency requests from the L2 cache. In this scheme, the L2 cache behaves as if the entire L1 Dcache is enabled, initiating L1 Dcache coherence transactions when appropriate. When the L1 Dcache Cache Controller receives such coherency requests, it performs operations on the tag and status array and the data array as in a conventional cache. Thus, coherency transactions are carried out for all ways, regardless of the state of the CWSR, and these infrequently occurring operations expend no more energy than in a conventional cache.</p><p>With a slight modification to the cache datapaths, we can also ensure that a CPU request for a block that resides in a disabled way in its own L1 Dcache is handled properly. This can be achieved with additional states in the Cache Controller for acting on a hit to a disabled way, and with the addition of a multiplexor connecting the writeback datapath to the fill datapath as shown in Figure <ref type="figure">2</ref>. This additional hardware allows the Cache Controller to read the block from the disabled way and send it to an enabled way via the fill datapath, to set the status bits to the appropriate coherence state, and to set the status of the block in the disabled way to Invalid. Depending on the size of a cache block and the datapath widths, it may be necessary to buffer part of the block during this transfer operation. If the CPU request was a load, this operation can be partially overlapped with sending the desired word to the CPU.</p><p>Although this approach allows for rapid changing of the enabled ways (as no flushing is required), a performance penalty on the order of 5-10 cycles (assuming the datapath widths are no less than one-quarter the width of a cache block) is incurred for each transfer of data from a disabled to an enabled way. In addition, a significant amount of energy is dissipated in transferring the cache block, offsetting the energy savings of disabling ways if these operations frequently occur. This may be the case in programs in which the CWSR is loaded many times during execution. In this case, the algorithm for changing the enabling of ways must consider the program boundaries within which vari- ables and data structures are referenced. These operations occur rarely if the CWSR is loaded at the granularity of an individual process (i.e., at context switch time), which we assume in the performance evaluation in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Evaluation of Selective Cache Ways</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Methodology</head><p>Our evaluation methodology combines detailed processor simulation for performance analysis and for gathering event counts, and analytical modeling for estimating the energy dissipation of both conventional caches and caches employing selective cache ways.</p><p>We use the SimpleScalar toolset <ref type="bibr" target="#b7">[8]</ref> to model an out-oforder speculative processor with a two-level cache hierarchy. The simulation parameters, listed in Table <ref type="table" target="#tab_2">3</ref>, roughly correspond to those in a current high-end microprocessor such as the HP PA-8000 <ref type="bibr" target="#b18">[19]</ref> and Alpha 21264 <ref type="bibr" target="#b16">[17]</ref>. We explore the performance of four different L1 Dcaches, with and without selective cache ways: 32KB and 64KB 2-way and 4-way set associative caches. All four L1 Dcache configurations are simulated as dual-ported caches, but are as- sumed to be single-ported caches which are double-pumped as in the Alpha 21264. The data array of the L2 cache is implemented as 16 partitions, only one of which is selected for each access, similar to the Alpha 21164 on-chip L2 cache <ref type="bibr" target="#b6">[7]</ref>. Because performance is not as sensitive to L2 cache latency as it is to L1 Dcache latency, this approach was used for the L2 cache instead of selective cache ways. We estimate L1 Dcache and L2 cache energy dissipations using a modified version of the analytical model of Kamble and Ghose <ref type="bibr" target="#b14">[15]</ref>. This model calculates cache energy dissipation using technology and layout parameters from Cacti and counts of various cache events as inputs. These event counts, in addition to performance results, are gathered from SimpleScalar simulations (each 400 million instructions long) of eight benchmarks which vary in their cache requirements: the SPEC95 benchmarks compress, ijpeg, li, turb3d, mgrid, fpppp, and wave5, as well as stereo, a multibaseline stereo benchmark from the CMU benchmark suite <ref type="bibr" target="#b10">[11]</ref> that operates on three 256 by 240 integer arrays of image data. Only L1 Dcache and L2 cache energy dissipations are calculated as the L1 Icache and main memory energy dissipations do not change significantly with the number of enabled L1 Dcache ways.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Performance Degradation</head><p>Figure <ref type="figure" target="#fig_2">3</ref> shows the performance degradation incurred for each benchmark as the number of enabled ways is var-ied. For the 4-way set associative caches, performance degrades by 0-2% when only three ways are enabled, and more sharply thereafter. The degradation is particularly significant (up to 15%) when moving from two ways to only one way enabled. Thus, for most of these benchmarks, a large performance degradation must be tolerated in order to disable more than one or two of the cache ways. For the 2way set associative caches, performance degrades by 2-6% when only one of the two ways is enabled.</p><p>The relative impact of conflict versus capacity misses can be assessed by observing that the 4-way caches are half the size of the corresponding 2-way caches for the same number of enabled ways. Cases where the 2-way associative curves parallel the 4-way curves between two and one enabled way, as with turb3d, indicate a high degree of conflict misses, since the percent performance change remains roughly the same even with twice the amount of cache. On the other hand, the domination of capacity misses is indicated by a faster drop-off for the 4-way curves relative to the same size 2-way curves, as with ijpeg.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Energy Impact</head><p>The impact on L1 Dcache and L2 cache energy dissipation depends on how disabling ways impacts the energy dissipations of each cache. Significant savings can be realized for benchmarks in which few additional L1 Dcache misses are generated when disabling ways. However, dis-  abling ways may increase energy dissipation if there is a significant increase in L2 cache activity. Figure <ref type="figure" target="#fig_3">4</ref> shows this tradeoff. Li, turb3d, and mgrid show significant reductions in combined L1 Dcache and L2 cache energy dissipation for all L1 Dcache organizations. For ijpeg, fpppp, and wave5, energy dissipation is reduced when one or two of the ways of a 4-way set associative cache are disabled. When additional ways are disabled, L2 cache accesses increase substantially, increasing L2 cache energy, which may override the reduction in L1 Dcache energy. The results are mixed for the 2-way caches, with improvements for both ijpeg and wave5 with one of the ways disabled, but a degradation for the 32KB 2-way cache for fpppp.</p><p>The results for compress and stereo demonstrate the critical need to accurately assess the impact of disabling ways on L1 and L2 cache energy dissipation. Although roughly a 10% energy savings is realized for these benchmarks when disabling one of the ways of a 64KB 4-way cache, energy dissipation may significantly increase when otherwise disabling ways. For compress, disabling three of the cache ways in a 32KB 4-way cache more than doubles energy dissipation with a 1MB L2 cache; with a 2MB L2 cache, the energy increases by 180%. Thus, system software must accurately determine the optimal number of ways as is discussed in Section 5. The next section discusses the overall energy savings and performance impact of selective cache ways assuming that this support is in place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Overall Energy and Performance Results</head><p>Figure <ref type="figure" target="#fig_4">5</ref> shows the energy savings realized and performance degradation incurred across all benchmarks for different PDT values. The energy savings is calculated from the average L1 Dcache and L2 cache energy dissipation of all benchmarks with all ways enabled, and the average with the best number of disabled ways for each benchmark. The best number is that which meets the PDT criterion and minimizes combined L1 Dcache and L2 cache energy dissipation. The performance degradation is similarly calculated from the corresponding IPC values. Note that the actual performance degradation incurred is significantly less than the PDT value. Observe also that for a 64KB 4-way set associative cache and a PDT of 4%, which incurs an actual performance loss of less than 2%, a 25-40% average cache energy savings can be obtained. The results are more modest, yet still significant (10-25% energy reduction), for a 32KB 4-way cache. The lesser performance degradation with a larger L2 cache is primarily due to the more limited opportunities to disable L1 Dcache ways with the larger L2 cache, due to energy dissipation constraints.</p><p>The energy savings for 2-way set associative caches is significantly less than that of 4-way caches of the same size for two reasons. First, a large jump in conflict misses often accompanies a move from two ways to only one way enabled. Second, the higher granularity of partitioning in the 4-way caches allows for the potential of disabling a greater percentage of the cache. Thus, in general, the effectiveness of selective cache ways increases with the cache associativity. Yet, the 64KB 2-way cache achieves up to a 30% energy savings, although less than a 10% energy savings is realized for the smaller 32KB 2-way cache.</p><p>Table <ref type="table" target="#tab_3">4</ref>, which displays the number of disabled ways for each benchmark as a function of PDT value, provides additional insight as to the effectiveness of selective cache ways. For the largest and most associative cache (64KB 4-way), at least one way is disabled for all benchmarks even with a PDT of only 2%. For the 32KB 4-way L1 Dcache, no ways are disabled for compress and stereo due to the resulting increase in cache energy (Figure <ref type="figure" target="#fig_3">4</ref>). Fewer ways can be disabled compared with the 64KB cache for the other benchmarks, especially for larger PDT values. This limits the effectiveness of selective cache ways for a 32KB 4-way cache under this workload. For the 2-way caches, the PDT must be at least 4% in order for one way to be disabled for most of the benchmarks. We conclude that a significant savings in combined L1 Dcache and L2 cache energy dissipation can be realized with selective cache ways, but this is primarily during periods in which applications with modest cache requirements dominate the workload. During periods when programs like compress and stereo predominate, very little energy savings may be realized for the simple reason that the full cache is needed. In addition, the change in performance and energy dissipation as the number of enabled cache ways is varied must be predictable with high accuracy; otherwise, a significant performance degradation and/or an increase in energy dissipation may result. In the next section, we describe software systems for application profiling and optimization that can be leveraged for selective cache ways.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Software Support for Selective Cache Ways</head><p>Several software profiling tools have been developed to identify portions of code that exhibit poor cache behavior, to provide insight to programmers for restructuring code to improve memory performance. Given certain high-level cache circuit characteristics, these same tools can also estimate the energy dissipation of different levels of the memory hierarchy. Cprof <ref type="bibr" target="#b19">[20]</ref> provides cache miss rate information at a fine-grain source code level, and further classifies misses as compulsory, capacity, and conflict types. More recent tools, such as the profiling tool developed by Ammons et al. <ref type="bibr" target="#b1">[2]</ref> and Compaq's ProfileMe <ref type="bibr" target="#b9">[10]</ref>, leverage the on-chip performance counters found on modern processors to provide additional insight on cache behavior. Rather than simply count events, ProfileMe gathers detailed information on a per-instruction basis, allowing for a more accurate assessment of cache performance and energy dissipation. By gathering such detailed information when all ways are enabled, it may be possible to accurately assess the appropriate number of cache ways to enable for different phases of application execution without additional profiling runs for each way configuration.</p><p>An alternative approach is to leverage more recent software systems that provide low-cost continuous profiling of the application. For example, the Digital Continuous Profiling Infrastructure (DCPI) <ref type="bibr" target="#b2">[3]</ref> periodically samples performance counters as programs normally execute and records the information in a database. This information can be later examined to identify sources of performance degradation. The Morph system <ref type="bibr" target="#b25">[26]</ref> is designed to provide automatic program optimization via similar performance sampling techniques as well as on-the-fly modification of the application, e.g., via a binary rewriting tool. With this type of software support, an application would be initially run with all ways enabled. Based on gathered cache information, estimates can be made on the performance degradation and energy dissipation with disabling ways for subsequent runs. In addition, the PDT (and thus, the number of disabled ways) could be adjusted according to machine conditions (loading, remaining battery life, etc.). The coupling of selective cache ways hardware with these emerging software techniques provides the opportunity for the tradeoff between performance and energy to be automatically made by the system without the need for extensive user involvement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and Future Work</head><p>Selective cache ways exploits the subarray partitioning of set associative caches in order to provide the capability to disable ways of the cache during periods where full cache functionality is not required to achieve good performance. Because only minor changes to a conventional cache are required to implement this technique, full-speed cache operation can be maintained. We have described the hardware and software aspects of this approach and demonstrated that a 40% reduction in overall cache energy dissipation can be achieved for 4-way set associative caches with less than a 2% overall performance degradation. This performance on-demand approach of partitioning hardware resources and tailoring them to application requirements can be applied to other processor structures as well. For example, it is well known that branch prediction performance is very application-dependent, and therefore all of the elements of a combined predictor may not be needed for every application, nor may the full tables of the enabled predictors be necessary. As with selective cache ways, these requirements can be gleaned via the compiler or continuous software-based profiling, and the precise amount of branch prediction hardware needed so as not to exceed the performance threshold can be enabled, and the rest disabled to save energy. A similar approach can be applied to the other large, RAM-based structures that constitute a large fraction of the functionality in a modern microprocessor, and are often partitioned for performance reasons.</p><p>Like complexity-adaptive processors <ref type="bibr" target="#b0">[1]</ref>, the approach described in this paper exploits the fact that applications may drastically differ in their hardware requirements. In our future work, we plan to combine these complementary approaches in order to improve both the performance and energy dissipation, and thus the energy-delay product, of future high performance microprocessors.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 . A 4 -</head><label>14</label><figDesc>Figure 1. A 4-way set associative cache using selective cache ways. The details for data ways 1-3 are identical to way 0 but are not shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 . A 4 -</head><label>24</label><figDesc>Figure 2. A 4-way set associative cache using selective cache ways showing the path for transferring data between a disabled and an enabled way.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Performance degradation as a function of the number of ways enabled with 1MB L2 cache. Note the different scale for ijpeg.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Relative change in combined L1 Dcache and L2 cache energy as a function of the number of ways enabled. Note the different scales for compress, fpppp, and stereo.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Combined L1 Dcache and L2 cache energy savings and actual performance degradation as function of performance degradation threshold.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 . Characteristics of four generations of Alpha microprocessors. Some of the data reflects projections made in the referenced papers and therefore may differ from actual characteristics at product shipment.</head><label>1</label><figDesc></figDesc><table><row><cell>Product</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 . Optimal N parameters for various caches. The block size is 32 bytes.</head><label>2</label><figDesc></figDesc><table><row><cell cols="2">Cache Org</cell><cell></cell><cell cols="3">Optimal N Parameters</cell><cell></cell><cell></cell></row><row><cell>Size</cell><cell cols="3">Assoc Ndwl Ndbl</cell><cell cols="3">Nspd Ntwl Ntbl</cell><cell>Ntspd</cell></row><row><cell>16KB</cell><cell>1</cell><cell>2</cell><cell>4</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell></cell><cell>2</cell><cell>4</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell></cell><cell>4</cell><cell>4</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>1</cell></row><row><cell>32KB</cell><cell>1</cell><cell>1</cell><cell>8</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>4</cell></row><row><cell></cell><cell>2</cell><cell>8</cell><cell>1</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell></cell><cell>4</cell><cell>4</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>1</cell></row><row><cell>64KB</cell><cell>1</cell><cell>1</cell><cell>8</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>4</cell></row><row><cell></cell><cell>2</cell><cell>4</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell></cell><cell>4</cell><cell>4</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell>2</cell><cell>1</cell></row><row><cell cols="8">ingly long. For example, each of the two 512KB data banks</cell></row><row><cell cols="8">of the 1MB 4-way set associative L1 Dcache of the HP PA-</cell></row><row><cell cols="8">8500 microprocessor is partitioned into four 128KB subar-</cell></row><row><cell>rays</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 . Simulated system parameters.</head><label>3</label><figDesc></figDesc><table><row><cell>Parameter</cell><cell>Value</cell></row><row><cell>fetch width</cell><cell>8 instrs</cell></row><row><cell>fetch queue</cell><cell>16 instrs</cell></row><row><cell>fetch speed</cell><cell>2X</cell></row><row><cell>decode width</cell><cell>8 instrs</cell></row><row><cell>branch pred</cell><cell>combined, 4K 2-bit chooser,</cell></row><row><cell></cell><cell>4K-entry bimodal,</cell></row><row><cell></cell><cell>12-bit, 4K-entry global,</cell></row><row><cell></cell><cell>2-cycle penalty</cell></row><row><cell>BTB</cell><cell>8192 entries,</cell></row><row><cell></cell><cell>4-way set assoc</cell></row><row><cell>return address</cell><cell>64 entries</cell></row><row><cell>stack</cell><cell></cell></row><row><cell>RUU size</cell><cell>64 entries</cell></row><row><cell>LSQ size</cell><cell>16 entries</cell></row><row><cell>issue width</cell><cell>4</cell></row><row><cell>integer ALUs</cell><cell>2</cell></row><row><cell>integer mult/div</cell><cell>2</cell></row><row><cell>flt. pt. ALUs</cell><cell>2</cell></row><row><cell>flt. pt. mult/div</cell><cell>2</cell></row><row><cell>commit width</cell><cell>4</cell></row><row><cell>L1 Icache</cell><cell>64KB, 4-way set assoc,</cell></row><row><cell></cell><cell>32B block, random, 1 cycle latency</cell></row><row><cell>L1 Dcache</cell><cell>32 or 64KB, 2 or 4-way</cell></row><row><cell></cell><cell>set assoc, 2 ports, 32B block,</cell></row><row><cell></cell><cell>random, 1 cycle latency</cell></row><row><cell>L2 cache</cell><cell>512KB, 1MB, or 2MB, 4-way</cell></row><row><cell></cell><cell>set assoc, 32B block, LRU,</cell></row><row><cell></cell><cell>15 cycle latency, 16 partitions</cell></row><row><cell>main memory</cell><cell>16B bus width, 75 cycle</cell></row><row><cell></cell><cell>initial latency, 2 cycles thereafter</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 . The number of disabled ways for each benchmark as a function of L1 Dcache orga- nization and PDT value with a 1MB L2 cache.</head><label>4</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="3">Performance Degradation Threshold</cell></row><row><cell>Cache Org</cell><cell>Benchmark</cell><cell>2%</cell><cell>4%</cell><cell>6%</cell></row><row><cell></cell><cell></cell><cell>Disabled</cell><cell>Disabled</cell><cell>Disabled</cell></row><row><cell></cell><cell></cell><cell>Ways</cell><cell>Ways</cell><cell>Ways</cell></row><row><cell></cell><cell>compress</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell></cell><cell>ijpeg</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell>li</cell><cell>2</cell><cell>2</cell><cell>2</cell></row><row><cell>32KB</cell><cell>turb3d</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell>4-way</cell><cell>mgrid</cell><cell>2</cell><cell>2</cell><cell>3</cell></row><row><cell></cell><cell>fpppp</cell><cell>2</cell><cell>2</cell><cell>2</cell></row><row><cell></cell><cell>wave5</cell><cell>2</cell><cell>2</cell><cell>2</cell></row><row><cell></cell><cell>stereo</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell></cell><cell>compress</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell>ijpeg</cell><cell>2</cell><cell>2</cell><cell>3</cell></row><row><cell></cell><cell>li</cell><cell>2</cell><cell>2</cell><cell>3</cell></row><row><cell>64KB</cell><cell>turb3d</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell>4-way</cell><cell>mgrid</cell><cell>2</cell><cell>3</cell><cell>3</cell></row><row><cell></cell><cell>fpppp</cell><cell>2</cell><cell>2</cell><cell>2</cell></row><row><cell></cell><cell>wave5</cell><cell>2</cell><cell>2</cell><cell>3</cell></row><row><cell></cell><cell>stereo</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell>compress</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell></cell><cell>ijpeg</cell><cell>0</cell><cell>0</cell><cell>1</cell></row><row><cell></cell><cell>li</cell><cell>0</cell><cell>1</cell><cell>1</cell></row><row><cell>32KB</cell><cell>turb3d</cell><cell>0</cell><cell>0</cell><cell>1</cell></row><row><cell>2-way</cell><cell>mgrid</cell><cell>0</cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell>fpppp</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell></cell><cell>wave5</cell><cell>0</cell><cell>0</cell><cell>1</cell></row><row><cell></cell><cell>stereo</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell></cell><cell>compress</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell></cell><cell>ijpeg</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell>li</cell><cell>0</cell><cell>1</cell><cell>1</cell></row><row><cell>64KB</cell><cell>turb3d</cell><cell>0</cell><cell>0</cell><cell>1</cell></row><row><cell>2-way</cell><cell>mgrid</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell>fpppp</cell><cell>0</cell><cell>0</cell><cell>1</cell></row><row><cell></cell><cell>wave5</cell><cell>0</cell><cell>1</cell><cell>1</cell></row><row><cell></cell><cell>stereo</cell><cell>0</cell><cell>0</cell><cell>0</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">In this paper, we use the term set to refer to the cache block(s) pointed to by the index part of the address, and the term way to refer to one of the n sections in an n-way set associative cache.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>John Strasser coded the cache energy dissipation model, and to the author's knowledge, George Cai of Intel first coined the term "performance on demand." This research is supported by the National Science Foundation under CA-REER Award CCR-9701915 and grant CCR-9811929.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Dynamic IPC/clock rate optimization</title>
		<author>
			<persName><forename type="first">D</forename><surname>Albonesi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Symposium on Computer Architecture</title>
				<meeting>the 25th International Symposium on Computer Architecture</meeting>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
			<biblScope unit="page" from="282" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Exploiting hardware performance counters with flow and context sensitive profiling</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ammons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
				<meeting>the ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Continuous profiling: Where have all the cycles gone?</title>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Symposium on Operating Systems Principles</title>
				<meeting>the 16th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Cache performance of operating system and multiprogramming workloads</title>
		<author>
			<persName><forename type="first">A</forename><surname>Argawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="393" to="431" />
			<date type="published" when="1988-11">November 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Alpha 21364: A scalable single-chip SMP. Microprocessor Forum</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bannon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-10">October 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Architectural and compiler support for energy reduction in the memory hierarchy of high performance microprocessors</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Low Power Electronics and Design</title>
				<meeting>the International Symposium on Low Power Electronics and Design</meeting>
		<imprint>
			<date type="published" when="1998-08">August 1998</date>
			<biblScope unit="page" from="70" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Circuit implementation of a 300-MHz 64-bit second-generation CMOS Alpha CPU</title>
		<author>
			<persName><forename type="first">W</forename><surname>Bowhill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Technical Journal</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="100" to="118" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note>Special Issue</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The SimpleScalar toolset, version 2.0</title>
		<author>
			<persName><forename type="first">D</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
		<idno>TR-97-1342</idno>
		<imprint>
			<date type="published" when="1997-06">June 1997</date>
		</imprint>
		<respStmt>
			<orgName>University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Low-power CMOS digital design</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chandrakasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brodersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal of Solid-State Circuits</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="473" to="484" />
			<date type="published" when="1992-04">April 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">ProfileMe: Hardware support for instructionlevel profiling in out-of-order processors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th International Symposium on Microarchitecture</title>
				<meeting>the 30th International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1997-12">December 1997</date>
			<biblScope unit="page" from="292" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The CMU task parallel program suite</title>
		<author>
			<persName><forename type="first">P</forename><surname>Dinda</surname></persName>
		</author>
		<idno>CMU-CS-94-131</idno>
		<imprint>
			<date type="published" when="1994-03">March 1994</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A 200MHz, 64-bit, dual-issue CMOS microprocessor</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dobberpuhl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Technical Journal</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="35" to="50" />
			<date type="published" when="1992">1992</date>
			<publisher>Special Issue</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Internal organization of the Alpha 21164, a 300MHz 64-bit quad-issue CMOS RISC microprocessor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Edmondson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Technical Journal</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="119" to="135" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
	<note>Special Issue</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">UltraSPARC III: Designing third-generation 64-bit performance</title>
		<author>
			<persName><forename type="first">T</forename><surname>Horel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lauterbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="73" to="85" />
			<date type="published" when="1999-06">May/June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Analytical energy dissipation models for low power caches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kamble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ghose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Low Power Electronics and Design</title>
				<meeting>the International Symposium on Low Power Electronics and Design</meeting>
		<imprint>
			<date type="published" when="1997-08">August 1997</date>
			<biblScope unit="page" from="143" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The Alpha 21264 microprocessor</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kessler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="24" to="36" />
			<date type="published" when="1999-04">March/April 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Kessler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Mclellan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Webb</surname></persName>
		</author>
		<title level="m">The Alpha 21264 microprocessor architecture. International Conference on Computer Design</title>
				<imprint>
			<date type="published" when="1998-10">October 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The filter cache: An energy efficient memory structure</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Mangione-Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Symposium on Microarchitecture</title>
				<meeting>the 29th International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1997-12">December 1997</date>
			<biblScope unit="page" from="184" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The HP PA-8000 RISC CPU</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="27" to="32" />
			<date type="published" when="1997-03">March 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Cache profiling and the SPEC benchmarks: A case study</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="15" to="26" />
			<date type="published" when="1994-10">October 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">PA-8500: The continuing evolution of the PA-8000 family</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lesartre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hunt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Compcon</title>
				<meeting>Compcon</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The Alpha AXP architecture and 21064 processor</title>
		<author>
			<persName><forename type="first">E</forename><surname>Mclellan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="36" to="47" />
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A 160-MHz, 32-b, 0.5W CMOS RISC microprocessor</title>
		<author>
			<persName><forename type="first">J</forename><surname>Montanaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Technical Journal</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="62" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">UltraSparc I: A four-issue processor supporting multimedia</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tremblay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>O'connor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="42" to="50" />
			<date type="published" when="1996-04">April 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">An enhanced access and cycle time model for on-chip caches</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wilton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jouppi</surname></persName>
		</author>
		<idno>93/5</idno>
		<imprint>
			<date type="published" when="1994-07">July 1994</date>
		</imprint>
		<respStmt>
			<orgName>Digital Western Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">System support for automatic profiling and optimization</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Symposium on Operating Systems Principles</title>
				<meeting>the 16th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
