<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Security as a New Dimension in Embedded System Design</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Paul</forename><surname>Kocher</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Cryptography Research</orgName>
								<orgName type="institution">CA ¶ Cigital</orgName>
								<address>
									<settlement>San Francisco, Dulles</settlement>
									<region>VA</region>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="laboratory">§ NEC Laboratories America</orgName>
								<address>
									<settlement>Princeton</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ruby</forename><surname>Lee</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Gary</forename><surname>Mcgraw</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Anand</forename><surname>Raghunathan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Srivaths</forename><surname>Ravi</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">‡ EE Department</orgName>
								<orgName type="institution">Princeton University</orgName>
								<address>
									<settlement>Princeton</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Security as a New Dimension in Embedded System Design</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C02FCA56E4AA84639E7BE62C1DBF1FCB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.0 [Computer Systems Organization]: General-System architectures, Instruction set design</term>
					<term>C.1.0 [Computer Systems Organization]: Processor architectures-General</term>
					<term>C.2.0 [Computer Systems Organization]: Computer-Communication Networks-General, Security and protection</term>
					<term>C.5.3 [Computer Systems Organization]: Computer System Implementation-Microcomputers, Portable devices</term>
					<term>D.0 [Software]: General</term>
					<term>E.3 [Data]: Data encryption-DES, Public key cryptosystems Security, Performance, Design, Reliability, Algorithms, Verification Embedded Systems, Security, Cryptography, Security Protocols, Security Processing, Design, Design Methodologies, Architectures, Tamper Resistance, Software Attacks, Viruses, Trusted Computing, Digital Rights Management, Performance, Battery Life</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The growing number of instances of breaches in information security in the last few years has created a compelling case for efforts towards secure electronic systems. Embedded systems, which will be ubiquitously used to capture, store, manipulate, and access data of a sensitive nature, pose several unique and interesting security challenges. Security has been the subject of intensive research in the areas of cryptography, computing, and networking. However, security is often mis-construed by embedded system designers as the addition of features, such as specific cryptographic algorithms and security protocols, to the system. In reality, it is an entirely new metric that designers should consider throughout the design process, along with other metrics such as cost, performance, and power.</p><p>This paper is intended to introduce embedded system designers and design tool developers to the challenges involved in designing secure embedded systems. We attempt to provide a unified view of embedded system security by first analyzing the typical functional security requirements for embedded systems from an end-user perspective. We then identify the implied challenges for embedded system architects, as well as hardware and software designers (e.g., tamper-resistant embedded system design, processing requirements for security, impact of security on battery life for batterypowered systems, etc.). We also survey solution techniques to address these challenges, drawing from both current practice and emerging research, and identify open research problems that will require innovations in embedded system architecture and design methodologies.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Today, security in one form or another is a requirement for an increasing number of embedded systems, ranging from low-end systems such as PDAs, wireless handsets, networked sensors, and smart cards, to high-end systems such as routers, gateways, firewalls, storage servers, and web servers. Technological advances that have spurred the development of these electronic systems have also ushered in seemingly parallel trends in the sophistication of security attacks. It has been observed that the cost of insecurity in electronic systems can be very high. For example, it was estimated that the "I Love You" virus caused nearly one billion dollars in lost revenues worldwide <ref type="bibr">[1]</ref>. With an increasing proliferation of such attacks, it is not surprising that a large number of users in the mobile commerce world (nearly 52% of cell phone users and 47% of PDA users, according to a survey by Forrester Research <ref type="bibr" target="#b1">[2]</ref>) feel that security is the single largest concern preventing the successful deployment of next-generation mobile services.</p><p>With the evolution of the Internet, information and communications security has gained significant attention. For example, various security protocols and standards such as IPSec, SSL, WEP, and WTLS <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, are used for secure communications. While security protocols and the cryptographic algorithms they contain address security considerations from a functional perspective, many embedded systems are constrained by the environments they operate in, and by the resources they possess. For such systems, there are several factors that are moving security considerations from a functioncentric perspective into a system architecture (hardware/software) design issue. For example, An ever increasing range of attack techniques for breaking security such as software, physical and side-channel attacks require that the embedded system be secure even when it can be logically or physically accessed by malicious entities. Resistance to such attacks can be ensured only if built into the system architecture and implementation.</p><p>The processing capabilities of many embedded systems are easily overwhelmed by the computational demands of security processing, leading to undesirable tradeoffs between security and cost, or security and performance.</p><p>Battery-driven systems and small form-factor devices such as PDAs, cell phones and networked sensors often operate under stringent resource constraints (limited battery, storage and computation capacities). These constraints only worsen when the device is subject to the demands of security.</p><p>Embedded system architectures need to be flexible enough to support the rapid evolution of security mechanisms and standards.</p><p>New security objectives, such as denial of service and digital content protection, require a higher degree of co-operation between security experts and embedded system architects. This paper will introduce the embedded system designer to the importance of embedded system security, review evolving trends and standards, and illustrate how the security requirements translate into system design challenges. Emerging solutions to address these challenges through a combination of advanced embedded system architectures and design methodologies will be presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>46.1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">EMBEDDED SYSTEM SECURITY REQUIREMENTS</head><p>Embedded systems often provide critical functions that could be sabotaged by malicious entities. Before discussing the common security requirements for embedded systems, it is important to note that there are many entities involved in a typical embedded system manufacturing, supply, and usage chain. Security requirements vary depending on whose perspective we consider. For example, consider a state-of-the-art cell phone that is capable of wireless voice, multimedia, and data communications. Security requirements may vary when considered from the viewpoint of the manufacturer of a component inside the cell phone (e.g., baseband processor), the cell phone manufacturer, the cellular service provider, the content provider, and the end user of the cell phone. The end user's primary concern may be the security of personal data stored and communicated by the cell phone, while the content provider's primary concern may be copy protection of the multimedia content delivered to the cell phone, and the cell phone manufacturer might additionally be concerned with the secrecy of proprietary firmware that resides within the cell phone. For each of these cases, the set of potentially malicious entities can also vary. For example, from the perspective of the content provider, the end user of the cell phone may be an untrusted entity. While this section outlines broad security requirements typical of embedded systems, the security model for each embedded system will dictate the combination of requirements that apply.</p><p>Historically, information security was first explored in the context of communications systems. When two entities send or receive sensitive information using public networks or communications channels accessible to potential attackers, they should ideally provide security functions such as data confidentiality, data integrity, and peer authentication. Data confidentiality protects sensitive information from undesired eavesdroppers. Data integrity ensures that the information has not been changed illegitimately. Peer authentication verifies that the information is sent and received by appropriate parties rather than masqueraders. These security functions are required of embedded systems used in a wide range of applications today.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Secure</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Network Access Availability</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Basic Security Functions User Identification</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Content Security</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Secure Storage</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tamper Resistance</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 1: Common security requirements of embedded systems from an end-user perspective</head><p>Fig 1 shows some of these security requirements from the perspective of an end-user, where we use the term basic security functions to denote the set of confidentiality, integrity and authentication requirements. Very often, access to the embedded system should be restricted to a selected set of authorized users (user identification), while access to a network or a service has to be provided only if the device is authorized (secure network access). These may use the user or host authentication mechanisms provided by the basic security functions, as well as other mechanisms such as biometrics and access control.</p><p>Another essential security function is the availability of the embedded system. In several scenarios, one can expect malicious entities preventing an embedded system from performing the functions it is supposed to, resulting in a degradation of performance or complete denial of service (DoS) to legitimate users.</p><p>Embedded system security often requires protecting critical or sensitive information (code or data) throughout its lifetime, including making sure that it is properly erased at the end of its lifetime. Secure storage involves securing information in the embedded system's storage devices, external or in-ternal to the system. Content security or Digital Rights Management (DRM) protects the rights of the digital content used in the system, and is an issue actively pursued by several content providers.</p><p>Finally, tamper resistance refers to the desire to maintain these security requirements even when the device falls into the hands of malicious parties, and can be physically or logically probed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SECURITY MECHANISMS</head><p>This section illustrates some existing security mechanisms for achieving desired security functions.</p><p>Basic security functions described above are often achieved using three different classes of cryptographic algorithms -symmetric ciphers, asymmetric ciphers and secure hash algorithms. (For a basic introduction to cryptography, we refer the reader to <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>).</p><p>Symmetric ciphers require the sender to use a secret key to encrypt data (the data being encrypted is often referred to as plaintext) and transmit the encrypted data (usually called the ciphertext) to the receiver. On receiving the ciphertext, the receiver then uses the same secret key to decrypt it and regenerate the plaintext. The ciphertext should have the property that it is very hard for a third party to deduce the plaintext, without having access to the secret key. Thus, confidentiality of data is ensured during transmission. Examples of symmetric ciphers include DES, 3DES, AES, and RC4.</p><p>Secure Hash algorithms such as MD5 and SHA convert arbitrary messages into unique fixed-length values, thereby providing unique "fingerprints" for messages. Hash functions are often used to construct Message Authentication Codes (MACs), such as HMAC-SHA, which additionally incorporate a key to prevent adversaries who tamper with data from avoiding detection by recomputing hashes.</p><p>Asymmetric algorithms (also called public-key algorithms), use a pair of keys: one of the keys locks the data while the other unlocks it. Encryption of a message intended for a given recipient requires only the public key known to the world, but decryption is only possible with the recipient's private key, which the recipient should keep secret. Thus, use of the private key (assuming it is kept secret) provides user or host authentication. Hence, digital signatures are often constructed using public key cryptography and secure hashes. The user can "digitally sign" a message by encrypting a hash of it with his private key; any one can verify this signature by decrypting with the public key.</p><p>Asymmetric ciphers (e.g., RSA, Diffie-Hellman, etc.) rely on the use of more computationally intensive mathematical functions such as modular exponentiation of large integers, and hence are much slower than symmetric ciphers. Because of this, a symmetric cipher is typically used to encrypt bulk data, while an asymmetric cipher is used to establish (transmit) the secret key for this symmetric cipher across a public network.</p><p>Security solutions to meet the various requirements outlined in the previous section typically rely on security mechanisms that use a combination of these cryptographic algorithms in the context of a security protocol. Various security technologies and mechanisms have been designed around these cryptographic algorithms in order to provide specific security services. For example, Secure communication protocols (popularly called security protocols) provide ways of ensuring secure communication channels to and from the embedded system. IPSec [5] and SSL <ref type="bibr" target="#b4">[6]</ref> are popular examples of security protocols, widely used for Virtual Private Networks (VPNs) and secure web transactions, respectively. Digital certificates provide ways of associating identity with an entity, while biometric technologies <ref type="bibr" target="#b5">[7]</ref> such as fingerprint recognition and voice recognition aid in end-user identification. Digital signatures, which function as the electronic equivalent of handwritten signatures, can be used to authenticate the source of data as well as verify its identity.</p><p>Digital Rights Management (DRM) protocols such as OpenIPMP <ref type="bibr">[8]</ref>, ISMA <ref type="bibr" target="#b7">[9]</ref> and MOSES <ref type="bibr" target="#b8">[10]</ref>, provide secure frameworks intended to protect application content against unauthorized use. Secure storage and secure execution require that the architecture of the system be tailored for security considerations. Simple examples include the use of dedicated hardware to block illegal accesses to protected areas in the memory <ref type="bibr" target="#b9">[11]</ref>, authentication of firmware and software that execute on the system, preserving the confidentiality and integrity of code and data associated with a given application or a process <ref type="bibr" target="#b10">[12]</ref>, hardware and software techniques to preserve the confidentiality and integrity of data throughout the memory hierarchy <ref type="bibr" target="#b11">[13]</ref>, and execution of encrypted code in processors to prevent bus probing <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b13">15]</ref> etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SECURITY ATTACKS AND COUNTERMEA-SURES</head><p>Various attacks on electronic and computing systems have shown that hackers rarely take on the theoretical strength of well-designed cryptographic algorithms. Instead, they rely on exploiting security vulnerabilities in the software and hardware components of the implementation. In this section, we show that unless security is considered throughout the design cycle, embedded system implementation vulnerabilities can easily be exploited to bypass or weaken functional security measures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Embedded Software Attacks and Countermeasures</head><p>Software in embedded systems is a major source of security vulnerabilities. Three factors, which we call the Trinity of Trouble -complexity, extensibility and connectivity -conspire to make managing security risks in software a major challenge.</p><p>Complexity: Software is complicated, and will become even more complicated in the near future. More lines of code increases the likelihood of bugs and security vulnerabilities. As embedded systems converge with the Internet and more code is added, embedded system software is clearly becoming more complex. The complexity problem is exacerbated by the use of unsafe programming languages (e.g., C or C++) that do not protect against simple kinds of attacks, such as buffer overflows. For reasons of efficiency, C and C++ are very popular languages for embedded systems. In theory, we could analyze and prove that a small program is free of problems, but this task is impossible for programs of realistic complexity today.</p><p>Extensibility: Modern software systems, such as Java and .NET, are built to be extended. An extensible host accepts updates or extensions (mobile code) to incrementally evolve system functionality. Today's operating systems support extensibility through dynamically loadable device drivers and modules. Advanced embedded systems are designed to be extensible (e.g., J2ME, Java Card). Unfortunately, the very nature of extensible systems makes it hard to prevent software vulnerabilities from slipping in as an unwanted extension.</p><p>Connectivity: More and more embedded systems are being connected to the Internet. The high degree of connectivity makes it possible for small failures to propagate and cause massive security breaches. Embedded systems with Internet connectivity will only make this problem grow. An attacker no longer needs physical access to a system to launch automated attacks to exploit vulnerable software. The ubiquity of networking means that there are more attacks, more embedded software systems to attack, and greater risks from poor software security practices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Example of a Software Attack: The Hardware Virus</head><p>Software attacks against the operating system kernel, such as those carried out by rootkits, demonstrate the kinds of attack that embedded systems are exposed to <ref type="bibr" target="#b14">[16]</ref>. A kernel has full access to the system and can communicate with any part of the address space. This means, among other things, that an attacker can read or write to the BIOS memory on the motherboard or in peripheral hardware.</p><p>In earlier times, BIOS memory was stored in ROM or in EPROM chips which could not be updated from software. These older systems require the chips to be replaced or manually erased and rewritten. Since this is not very cost effective, new systems employ EEPROM chips, otherwise known as Flash ROM. Flash ROM can be re-written from software. Modern embedded systems often include Flash ROM.</p><p>A given computer can have several megabytes of Flash ROM on various controller cards and the motherboard. These Flash ROM chips are almost never fully utilized and leave lots of room to store backdoor information and viruses. To an attacker, the compelling reason for using these memory spaces is that they are hard to audit and almost never visible to software running on a system. To access such "hardware memory" requires driver level access. Furthermore, this memory is immune to re-booting and system re-installation. If someone suspects a viral infection, restoring the system from tape or backup will not help. The hardware virus has always been, and will remain, one of the best kept secrets of the "black magic" hackers.</p><p>A simple hardware virus may be designed to impart false data to a system, or to cause the system to ignore certain events. Imagine an anti-aircraft radar that uses an embedded real-time operating system. Within the system are several Flash ROM chips. A virus is installed into one of these chips and it has trusted access to the entire bus. The virus has only one purpose -to cause the radar to ignore certain types of radar signatures.</p><p>Viruses have long since been detected "in the wild" that write themselves into the motherboard BIOS memory. In the late 90s, the so-called F00F bug was able to crash a laptop completely. Although the CIH (of Chernobyl) virus was widely popularized in the media, virus code that used the BIOS was published long before the release of CIH.</p><p>EEPROM memory is fairly common on many systems. Ethernet cards, video cards, and multimedia peripherals may all contain EEPROM memory. The hardware memory may contain flash firmware or may just be used for data storage. Non-volatile memory chips are found in a variety of hardware devices: TV tuners and remote controls, CD Players, cordless and cellular phones, fax machines, cameras, radios, automotive airbags, anti-lock brakes, odometers, keyless entry systems, printers and copiers, modems, pagers, satellite receivers, barcode readers, point of sale terminals, smart cards, lock boxes, garage door openers, and test and measurement equipment. EEPROM chips remain a prime area for storing subversive code. As more embedded devices become available, the EEPROM based virus will be more applicable and dangerous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Securing against software attacks</head><p>Software is a central and critical aspect of the computer (and embedded system) security problem. Software defects with security ramificationsincluding implementation bugs such as buffer overflows and design flaws such as inconsistent error handling -promise to be with us for years. All too often, malicious intruders can hack into systems by exploiting software defects <ref type="bibr" target="#b14">[16]</ref>. Moreover, Internet-enabled software applications present the most common security risk encountered today, with software's everexpanding complexity and extensibility adding further fuel to the fire. Software security's best practices leverage good software engineering practice and involve thinking about security early in the software design life cycle (SDLC), knowing and understanding common threats (including language-based flaws and pitfalls), designing for security, and subjecting all software artifacts to thorough objective risk analyses and testing.</p><p>Security is an emergent property of a software system. This is a subtle point often lost on development people who tend to focus on functionality. Obviously, there are security functions in the world, and most modern software includes security features, but adding features such as SSL (for cryptographically protecting communications) does not present a complete solution to the security problem. A security problem is more likely to arise because of a problem in a standard part of the system (e.g., the API to the server) than in some given security feature. This is an important reason why software security must be part of a full lifecycle approach. Just as you cannot test quality into a piece of software, you can not spray paint security features onto a design and expect it to become secure. As practitioners become aware of software security's importance, they are increasingly adopting and evolving a set of best practices to address the problem <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b16">18]</ref>. There is no substitute for working software security as deeply into the development process as possible and taking advantage of the engineering lessons software practitioners have learned over the years. Figure <ref type="figure">2</ref> specifies one set of best practices and shows how software practitioners can apply them to the various software artifacts produced during software development. Although the artifacts are shown laid out in a linear sequence, most organizations follow an iterative approach, which means that best practices will be cycled through more than once as the software evolves.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Software security in the SDLC</head><p>Software security best practices apply at various levels:</p><p>The requirements level: Security requirements must cover both overt functional security (e.g., the use of applied cryptography) and emergent characteristics.</p><p>The design and architecture level: A system must be coherent and present a unified security architecture that takes into account security principles (such as the principle of least privilege) <ref type="bibr" target="#b15">[17]</ref>.</p><p>The code level: Static analysis tools -tools that scan source code for common vulnerabilities -can discover implementation bugs at the code level.</p><p>Risks crop up during all stages of the software life cycle, so a constant risk analysis thread, with recurring risk tracking and monitoring activities, is highly recommended. Security testing must encompass two strategies: testing security functionality with standard functional testing techniques, and risk-based security testing based on attack patterns and threat models. Penetration testing is also useful, especially if an architectural risk analysis is specifically driving the tests.</p><p>Operations people should carefully monitor embedded systems being used in the field for security breaks. Attacks will happen, regardless of the strength of design and implementation, so monitoring software behavior, during deployment, is an excellent defense technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Physical and Side-channel Attacks, and Tamper-resistant Hardware</head><p>In addition to software attacks, there are physical and side-channel attacks that exploit the system implementation or its identifying properties to break the security of an embedded system <ref type="bibr" target="#b17">[19,</ref><ref type="bibr" target="#b18">20,</ref><ref type="bibr" target="#b19">21,</ref><ref type="bibr">22,</ref><ref type="bibr" target="#b20">23,</ref><ref type="bibr" target="#b21">24,</ref><ref type="bibr" target="#b22">25,</ref><ref type="bibr" target="#b23">26]</ref>. Historically, many of these attacks have been used to break the security of embedded systems such as smart cards. Physical and side-channel attacks are generally classified into invasive and non-invasive attacks. Invasive attacks involve getting access to the appliance to observe, manipulate and interfere with the system internals. Since invasive attacks against integrated circuits typically require expensive equipment, they are relatively hard to mount and repeat. Examples of invasive attacks include micro-probing and reverse engineering. Non-invasive attacks, as the name indicates, do not require the device to be opened. While these attacks may require an initial investment of time or creativity, they tend to be cheap and scalable (compared to invasive attacks). There are many forms of non-invasive attacks including timing attacks, power analysis attacks, fault induction techniques, and electromagnetic analysis attacks. In the sections that follow, we describe various physical and side-channel attacks in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Physical attacks</head><p>For an embedded system on a circuit board, physical attacks can be launched by using probes to eavesdrop on inter-component communications. However, for a system-on-chip, sophisticated micro-probing techniques become necessary <ref type="bibr" target="#b19">[21,</ref><ref type="bibr">22]</ref>. The first step in such attacks is de-packaging. Depackaging typically involves removal of the chip package by dissolving the resin covering the silicon using fuming acid. The next step involves layout reconstruction using a systematic combination of microscopy and invasive removal of covering layers. During layout reconstruction, the internals of the chip can be inferred at various granularities. While higher-level architectural structures within the chip such as data and address buses, memory and processor boundaries, etc., can be extracted with little effort, detailed views of lower-level structures such as the instruction decoder and ALU in a processor, ROM cells, etc., can also be obtained. Finally, techniques such as manual microprobing or e-beam microscopy are typically used to observe the values on the buses and interfaces of the components in a de-packaged chip.</p><p>Physical attacks at the chip level are relatively hard to use because of their expensive infrastructure requirements (relative to other attacks). However, they can be performed once and then used as precursors to the design of successful non-invasive attacks. For example, layout reconstruction is useful when performing electromagnetic radiation monitoring around selected chip areas. Likewise, the knowledge of ROM contents, such as cryptographic routines and control data, can provide an attacker with information that can assist in the design of a suitable non-invasive attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Timing analysis</head><p>For many devices, even computing the correct result does not ensure security. In 1996, Kocher <ref type="bibr" target="#b24">[27]</ref> showed how keys could be determined by analyzing small variations in the time required to perform cryptographic computations. The attack involves making predictions about secret values (such as individual key bits), and then using statistical techniques to test the prediction by determining whether the target device's behavior is correlated to the behavior expected by the prediction.</p><p>To understand the attack, consider a computation that begins with a known input and includes a sequence of steps, where each step mixes in one key bit and takes a non-constant amount of time. For example, for a given input, two operations are possible for the first step, depending on whether the key bit is zero or one.</p><p>For the attack, the adversary observes a set of inputs and notes the approximate total time required for a target device to process each. Next, the adversary measures the correlation between the measured times and the estimated time for the first step assuming the first step mixes in a zero bit. A second correlation is computed using estimates with a bit value of one. The estimates using the bit value actually used by the target device should show the strongest correlation to the observed times. The attack can then be repeated for subsequent bits.</p><p>What makes the attack interesting is that "obvious" countermeasures often do not work. For example, quantizing the total time (e.g., delaying to make the total computation take an exact multiple of 10ms) or adding random delays increases the number of measurements required, but does not prevent the attack. Obviously, making all computations take exactly the same amount of time would eliminate the attack, but few programs running on modern microprocessors operate in exactly constant time. Writing constant-time code (particularly in high-level languages) can be tricky.</p><p>Fortunately, there are techniques that can reliably prevent timing attacks in many systems. For example, message blinding can be used with RSA and other public key cryptosystems to prevent adversaries from correlating input and output values with timing measurements. For further information about timing attacks, see <ref type="bibr" target="#b24">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Power analysis</head><p>Timing channels are not the only way that devices "leak" information. For example, the operating current drawn by a hardware device is correlated to computations it is performing. In most integrated circuits, the major contributors to power consumption are the gates themselves and the parasitic capacitance of the internal wiring. Power consumption increases if more state transitions occur, or if transitions are occurring predominantly at gates with greater size or capacitive load. There are two main categories of power analysis attacks, namely, simple power analysis (SPA) and differential power analysis (DPA).</p><p>SPA attacks rely on the observation that in some systems, the power profile of cryptographic computations can be directly used to interpret the cryptographic key used. For example, SPA analysis can be used to break RSA implementations by revealing differences between the multiplication and squaring operations performed during modular exponentiation. In many cases, SPA attacks have also been used to augment or simplify brute-force attacks. For example, it has been shown in <ref type="bibr" target="#b25">[28]</ref> that the brute-force search space for one software DES implementation on an 8-bit processor with 7 bytes of key data can be reduced to 2 40 keys from 2 56 keys with the help of SPA.</p><p>DPA attacks use statistical techniques to determine secret keys from complex, noisy power consumption measurements. For a typical attack, an adversary repeatedly samples the target device's power consumption through each of several thousand cryptographic computations. These power traces are collected using high-speed analog-to-digital converters, such as those found in digital storage oscilloscopes.</p><p>After the data collection, the adversary makes a hypothesis about the key. For example, if the target algorithm is DES (see <ref type="bibr" target="#b2">[3]</ref> for a detailed description of DES), a typical prediction might be that the 6 key bits entering S-box 4 are equal to '011010'. If correct, an assertion of this form allows the adversary to compute four bits entering the second round of the DES computation. If the assertion is incorrect, however, an effort to predict any of these bits will be wrong roughly half the time.</p><p>For any of the four predicted bits, the power traces are divided into two subsets: one where the predicted bit value is 0, and one set where the predicted value is 1. Next, an average trace is computed for each subset, where the nth sample in each average trace is the average of the nth samples in all  If the original hypothesis is incorrect, the criteria used to create the subsets will be approximately random. Any randomly-chosen subset of a sufficiently-large data set will have the same average as the main set. As a result, the difference will be effectively zero at all points, and the adversary repeats the process with a new guess.</p><p>If the hypothesis is correct, however, choice of the subsets will be correlated to the actual computation. In particular, the second-round bit will have been '0' in all traces in one subset and '1' in the other. When this bit is actually being manipulated, its value will have a small effect on the power consumption, which will appear as a statistically-significant deviation from zero in the difference trace. Figure <ref type="figure" target="#fig_1">3</ref> shows an actual power consumption profile and the difference traces when both correct and incorrect keys are guessed.</p><p>DPA allows adversaries to pull extremely small "signals" from extremely noisy data, often without even knowing the design of the target system. These attacks are of particular concern for devices such as smart cards that must protect secret keys while operating in hostile environments. Countermeasures that reduce the quality of the measurements (such as running other circuits simultaneously) only increase the number of samples the adversary needs to collect, and do not prevent the attack. For further information about DPA, see <ref type="bibr" target="#b26">[29]</ref>.</p><p>Attacks such as DPA that involve many aspects of system design (hardware, software, cryptography, etc.) pose additional challenges for embedded system engineering projects because security risks may be concealed by layers of abstraction. Countermeasures used to mitigate these attacks are also frequently mathematically rigorous, non-intuitive, and require patent licensing <ref type="bibr">[30]</ref>. As a result, projects requiring effective tamper resistance, particularly when used for securing payments, audiovisual content, and other high-risk data, remain expensive and challenging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Fault induction</head><p>Hardware security devices depend on more than correct software. If the hardware ever fails to make correct computations, security can be jeopardized.</p><p>For example, almost any computation error can compromise RSA implementations using the Chinese Remainder Theorem (CRT). The computation involves two major subcomputations, one that computes the result modulo p and the other modulo q, where p and q are the factors of the RSA public modulus n. If, for example, the mod p computation result is incorrect, the final answer will be incorrect modulo p, but correct modulo q. Thus, the difference between the correct answer and the computed answer will be an exact multiple of q, allowing the adversary to find q by computing the greatest common denominator (GCD) of this difference and n.</p><p>To deter this specific attack, RSA implementations can check their answers by performing a public key operation on the result and verifying that it regenerates the original message. Unfortunately, error detection techniques for symmetric algorithms are not nearly as elegant, and there are many other kinds of error attacks. As a result, many cryptographic devices include an assortment of glitch sensors and other features designed to detect conditions likely to cause computation errors. For further discussion of this topic, see <ref type="bibr" target="#b27">[31]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.5">Electromagnetic Analysis</head><p>Electromagnetic analysis attacks (EMA) have been well documented since the eighties, when it was shown in <ref type="bibr" target="#b28">[32]</ref> that electromagnetic radiation from a video display unit can be used to reconstruct its screen contents. Since then, these attacks have only grown in sophistication <ref type="bibr" target="#b29">[33]</ref>. The basic premise of many of these attacks is that they attempt to measure the electromagnetic radiation emitted by a device to reveal sensitive information. Successful deployment of these attacks against a single chip would require intimate knowledge of its layout, so as to isolate the region around which electromagnetic radiation measurements must be performed. Like power analysis attacks, two classes of EMA attacks, namely, simple EMA (SEMA) and differential EMA (DEMA) attacks have been proposed <ref type="bibr" target="#b30">[34,</ref><ref type="bibr" target="#b31">35]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EMBEDDED PROCESSING ARCHITEC-TURES FOR SECURITY</head><p>In the past, embedded systems tended to perform one or a few fixed functions. The trend is for embedded systems to perform multiple functions and also to provide the ability to download new software to implement new or updated applications in the field, rather than only in the more controlled environment of the factory. While this certainly increases the flexibility and useful lifetime of an embedded system, it poses new challenges in terms of the increased likelihood of attacks by malicious parties. An embedded system should ideally provide required security functions, implement them efficiently and also defend against attacks by malicious parties. We discuss these below, especially in the context of the additional challenges faced by resource-constrained embedded systems in an environment of ubiquitous networking and pervasive computing.</p><p>Figure <ref type="figure">4</ref> illustrates the architectural design space for secure embedded processing systems. Different macro-architecture models are listed in the first row, and described further below. These include embedded generalpurpose processor (EP) vs. application-specific instruction set processor (ASIP) vs. EP with custom hardware accelerators connected to the processor bus, etc.). The second row details instruction-set architecture and micro-architecture choices for tuning the base processor where appropriate. The third row articulates security processing features that must be chosen or designed. For example, choosing the functionality to be implemented by custom instructions, hardware accelerators or general-purpose instruction primitives. The fourth row involves selection of attack-resistant features in the embedded processor and embedded system design. These protect against both software attacks and physical attacks, as illustrated in section 4. This may include an enhanced memory management unit to manage a secure memory space, process isolation architecture, additional redundant circuitry for thwarting power analysis attacks, and fault detection circuitry. co-processor</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ASIP (EP with SPx)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EP with GPx</head><p>Figure <ref type="figure">4</ref>: Architectural design space for secure information processing</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Security Processing Architectures</head><p>We now describe an evolution of macro-architecture models that have been proposed to provide required security functions. Basic security functions, like confidentiality, integrity and authentication, can be implemented with appropriate security protocols and cryptographic algorithms. The latter include symmetric ciphers, asymmetric ciphers and secure hashing algorithms, as discussed in section 3. However, such ciphers can be rather compute intensive and power hungry, which is a challenge for resourceconstrained embedded systems.</p><p>A hardware-only approach uses ASICs (Application Specific Integrated Circuits) to implement a given cryptography algorithm in hardware. This "hardwired algorithm" approach using fixed function ASICs can be very cost-effective when one or only a few ciphers are needed, and the ASICs are produced in large volume. However, it is much less effective in terms of cost and flexibility, when a variety of ciphers are desired to support multiple security protocols, emerging standards, and inter-operability with many devices.</p><p>A software-only approach using a typical embedded general-purpose processor (EP) core for performing security protocol and cryptography processing at network link speeds faces both a processing gap and a battery gap. The processing gap refers to the fact that the computational requirements of standard security protocols utilizing cryptography are significantly higher than the processor capabilities available in embedded systems such as wireless handheld devices <ref type="bibr" target="#b32">[36,</ref><ref type="bibr" target="#b33">37]</ref>. For example, the total processing requirements for software implementations of SSL (with 3DES used for encryption and decryption, and SHA for message authentication) executing on an iPAQ handheld (235 MIPS StrongARM processor) was shown in <ref type="bibr" target="#b32">[36]</ref> to be around 651.3 MIPS, at a link speed of 10 Mbps (current and emerging data rates for wireless LAN technologies are in the range of 2-60 Mbps). The battery gap refers to the significant additional energy consumption required by security processing on battery-powered wireless handhelds <ref type="bibr" target="#b34">[38,</ref><ref type="bibr" target="#b35">39]</ref>. For example, when a device such as Symbol PPT2800 PocketPC is encrypting transmitted data, a considerable part (nearly 21%) of the overall energy consumption is spent on security processing <ref type="bibr" target="#b34">[38]</ref>.</p><p>Several hybrid hardware-software approaches have been proposed to efficiently implement security functions. One uses a general-purpose embedded processor core with hardware accelerators (chips or cores) for the most performance critical steps. For example, since most of the time consumed in executing a public key algorithm such as RSA is in performing modular exponentiation, accelerator chips typically provide hardware speedup for modular multiplication. However, other ciphers may not be accelerated at all by this approach while still incurring the cost of the accelerator chips (or cores in System-On-Chip designs). The use of FPGAs (Field Programmable Gate Arrays) allows some reconfiguration to support different ciphers. However, this hardware flexibility may not always meet other goals in cost, energy consumption and performance simultaneously.</p><p>Another approach is to tightly integrate such acceleration hardware with the processor core itself and invoke it with custom instructions. This is denoted the ASIP (Application Specific Instruction Processor) approach. For example, embedded processors such as Xtensa <ref type="bibr" target="#b36">[40]</ref> are equipped with tools that allow a designer to extend the basic instruction set of a processor with a set of application-specific or custom instructions. A typical example is to implement one round of a symmetric cipher such as DES (Data Encryption Standard) in hardware and invoke this with a custom instruction. This can provide very significant acceleration to DES with excellent energy consumption, but no performance or energy improvement at all for other ciphers. For certain embedded systems, this is not only adequate, but often the most costeffective solution. For example, MOSES <ref type="bibr" target="#b37">[41]</ref> is an ASIP that uses a custom, low-overhead instruction set for a selected set of symmetric, asymmetric, and hashing algorithms.</p><p>In general-purpose processors, new instructions have also been proposed to accelerate a given set of existing symmetric ciphers <ref type="bibr" target="#b38">[42,</ref><ref type="bibr" target="#b39">43]</ref>. While these new instructions typically perform one or a few operations rather than an entire round of a block cipher, they are still fairly specific to the block ciphers considered. Hence, we denote these architectures "GPP with SPx", where SPx stands for Special-Purpose extensions. They are similar, in concept, to ASIPs.</p><p>The next step is to consider a general-purpose processor architecture with general-purpose extensions, denoted the "EP with GPx" approach. This allows only new instructions that are indeed "general-purpose" primitives, i.e., versatile operation primitives that could potentially be used to compose more complicated functions in many algorithms and different applications. For example, on studying the design of symmetric-key block ciphers, arbitrary bit permutations have been identified as the only fundamental operation useful in the design of block ciphers that is very slow in existing processors <ref type="bibr" target="#b40">[44,</ref><ref type="bibr" target="#b41">45]</ref>. Such bit-level permutation operations can quickly achieve diffusion in block ciphers, a technique identified by Shannon <ref type="bibr" target="#b42">[46]</ref> as fundamental to the design of block ciphers. Several different bit permutation instructions were recently proposed <ref type="bibr" target="#b40">[44,</ref><ref type="bibr" target="#b43">47,</ref><ref type="bibr" target="#b44">48,</ref><ref type="bibr" target="#b45">49]</ref> that allow any one of the n! permutations of the n bits in a register (or block to be enciphered) to be achieved in at most O(log(n)) instructions. This has been further reduced to O(1) cycles in both general-purpose <ref type="bibr" target="#b46">[50]</ref> and ASIP <ref type="bibr" target="#b41">[45]</ref> architectures. This is much faster than the O(n) instructions or cycles needed using existing instructions available in processors. The versatility of these bit permutation instruction primitives has also been demonstrated, for example, in the radical acceleration of the sorting of lists of bytes <ref type="bibr" target="#b47">[51]</ref>.</p><p>General-purpose instruction primitives for asymmetric (public-key) ciphers are very different from those used in symmetric ciphers. They tend to be focussed on accelerating a large number of modular multiplication operations on large operands, e.g., 1024 bit numbers, in order to implement the main underlying operation -modular exponentiation, in algorithms such as RSA, Diffie-Hellman and El Gamal. Newer public-key algorithms such as Elliptic Curve Cryptography (ECC) <ref type="bibr" target="#b48">[52]</ref> focus on computationally faster operations and smaller operands; ECC on binary fields perform polynomial multiplication rather than integer multiplication, using much shorter operands to achieve equivalent levels of security. For example, 163 bit ECC keys are thought to provide security equivalent to 1024 bit RSA keys. On the implementation side, the trend has been to implement dual-field multipliers <ref type="bibr" target="#b49">[53]</ref> that can efficiently perform both integer and binary multiplications on the same multiplier circuit.</p><p>Recently, new instruction-set architectures have been proposed for tiny general-purpose processors with general-purpose extensions to accelerate both symmetric ciphers and asymmetric ciphers. For example, PAX <ref type="bibr" target="#b50">[54]</ref> is a minimalist RISC (Reduced Instruction Set Computer) processor with a few additional (but simple to implement) instructions that accelerate both ECC public key operations and block cipher operations, and can achieve the link speeds of current and proposed wireless networks at low MHz rates. This approach is quite promising for embedded processors in smart cards, sensors and hand-held devices, where flexibility is required with small form factors and very low energy consumption.</p><p>The above macro architectural models often overlap and blend from one to another. The most effective and efficient custom instructions for ASIPs, or ISA primitives for "EP with GPx" architectures, are by no means resolved. More research is needed. Also, interaction between cryptography algorithm designers and processor designers is encouraged <ref type="bibr" target="#b51">[55]</ref>. The last three rows of Figure <ref type="figure">4</ref> illustrate detailed architectural decisions that must be made to fully define the secure embedded processing architecture.</p><p>Security processing also involves security protocol processing, although a large portion of this is taken by the actual cryptography processing. New work is in progress to minimize the overhead in processing, data buffering and memory round-trips incurred by secure network communications protocols, such as IPSEC and SSL. While network processors have been designed to accelerate the processing of the traditional network protocol stack, "security protocol engines" have been proposed to accelerate the security protocol processing, e.g., the IPSEC (Internet Protocol SECurity) portion of the IP network protocol processing <ref type="bibr">[56,</ref><ref type="bibr">57,</ref><ref type="bibr" target="#b52">58]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Attack-Resistant Architectures</head><p>The security processing architectures discussed in the previous section implement basic security functions like confidentiality, integrity and authentication, but do not provide protection from software or physical attacks by malicious entities. Furthermore, architectural features that accelerate cryptography and security protocols do not protect against Denial-of-Service (DoS) attacks. A secure embedded system should also incorporate appropriate attack-resistant features.</p><p>Several attempts have been made to provide protection from attacks, but because of the scope of this problem, comprehensive solutions are still elusive and an open area of research. Rather, solutions have been proposed for specific applications, e.g., Digital Rights Management (DRM) to try to mitigate software, music or movie piracy, or for specific attacks, e.g., password theft. Application-specific solutions, e.g., DRM for DVD players, may be the most widely deployed ones for embedded systems in the near future.</p><p>In Digital Rights Management, the ability to distribute essentially perfect copies of a piece of valuable software or multimedia file through the Internet or wireless networks poses a daunting challenge to large, established content owners and distributors. Here, the "attacker" may actually be the owner of the embedded system. For example, the owner or user of an entertainment device may try to extract, copy, and redistribute copies of music, movies or software. Some commercial initiatives, such as Palladium by Microsoft and TCPA (Trusted Computing Platform Alliance), may have initially been motivated by the DRM interests of large content providers. These initiatives have now grown to encompass broader security requirements and have also been renamed Next Generation Secure Computing Base (NGSCB) <ref type="bibr" target="#b53">[59,</ref><ref type="bibr" target="#b54">60]</ref> and Trusted Computing Group (TCG) <ref type="bibr" target="#b55">[61]</ref>, respectively.</p><p>These two initiatives are based on the assumption that compatibility with existing non-secure operating systems (e.g., Windows) and legacy application software must be preserved. This basic assumption may have led to the conceptual architectural model of a separate, parallel secure domain that co-exists and is protected from both non-secure applications programs and operating systems. The idea is to put a "brick wall" inside the processor, isolating both secure computations and memory, and protecting them from corruption, or even observation, by non-secure entities. This is like a mini firewall internal to the processor, and is achieved with a variety of new features in both software and hardware.</p><p>Key security objectives in NGSCB include strong process isolation, sealed memory, platform attestation, and a secure path to the user. Strong process isolation provides protected execution, implemented with mechanisms that include a new privilege domain as indicated by a new mode bit or privilege level (distinct from existing supervisor and user privilege levels). New instructions are used to enter and exit this secure mode or domain, with secure saving and restoring of contexts. Sealed memory involves tying some sensitive information to a given platform and software context, using encryption and hashing techniques. Such sealed memory can only be unsealed with the correct key in the correct software and hardware environment. Platform attestation is a method for a given computing device to try to assure a remote server that it is running appropriate software on acceptable hardware, with respect to certain security safeguards, e.g., a corporate file server might only allow connections from computers that are in approved configurations. A secure path to the user allows a user to invoke a secure program in the trusted domain, without intervention of the existing non-secure operating system. This includes a secure path from the keyboard and a secure path to the display, i.e., secure paths to certain input-output devices. LaGrande <ref type="bibr" target="#b56">[62]</ref> is Intel's codename for new hardware features (in the microprocessor, chipset, buses, memory system, and input-output devices) that implement these and similar concepts.</p><p>ARM has also recently proposed a smaller set of features for secure processor cores (called TrustZone technology <ref type="bibr" target="#b57">[63]</ref>) targeted at the embedded processor and System-On-Chip (SOC) markets. These protect against a set of attacks including password theft on login. MIPS has also proposed the security architecture SmartMIPS <ref type="bibr" target="#b58">[64]</ref> for smartcards, which includes a set of Instruction Set Architecture (ISA) extensions for accelerating cryptographic functions, and also memory management functions to support secure programming and secure operating systems. None of these proposed security features for commercial microprocessors or cores are available for widespread deployment yet.</p><p>In academic research, architectural features for computer security were investigated about thirty years ago. However, in the last decade or two, possibly coincident with the wide approval for RISC processors as the architecture for high-performance processors, very little research or education in computer architecture has been devoted to security issues. Recently, this has changed. Some recent papers propose techniques to provide memory integrity through encryption and hashing <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b11">13]</ref>, and processor techniques to prevent machine hijacking and hostile code insertion by detecting return address corruption during buffer overflow attacks <ref type="bibr" target="#b59">[65]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DESIGN METHODOLOGY AND TOOL RE-QUIREMENTS</head><p>As security emerges as a mainstream design issue, addressing some of the challenges outlined previously will require the support of appropriate design tools and methodologies. In this section, we briefly describe our vision for developments in this area.</p><p>Compared to an embedded system's functionality and other design metrics (e.g., area, performance, power), security is currently specified by system architects in a vague and imprecise manner. Security experts are often the only people in a design team who have a complete understanding of the security requirements. This is a problem, since different aspects of the embedded system design process can impact security. Hence, design methodologies for secure embedded systems will have to start with techniques to specify security requirements in a way that can be easily communicated to the design team, and evaluated throughout the design cycle. Any attempt to specify security requirements needs to address the "level" of security desired, e.g., what level of tamper resistance should be incorporated in the sys-tem. Security standards, such as the FIPS security requirements for cryptographic modules <ref type="bibr" target="#b60">[66]</ref>, and the Common Criteria for information technology security evaluation <ref type="bibr" target="#b61">[67]</ref> could provide some initial guidelines in this direction, although they tend to be quite cumbersome and difficult to understand for the average designer.</p><p>Techniques for formal or semi-formal specifications of security requirements can enable the development of tools that validate and verify whether these requirements are met, at various stages in the design process. For example, formal verification techniques have been used to detect bugs in security protocol implementations <ref type="bibr" target="#b62">[68,</ref><ref type="bibr" target="#b63">69]</ref>.</p><p>Time-to-market pressures in the semiconductor and embedded system industries lead to design processes that are increasingly based on the re-use of components from various sources. It will be particularly challenging to maintain security requirements in the face of these trends. It is very difficult, if not impossible, to guarantee the security of a system when the underlying components are untrusted. Furthermore, even the composition of individually secure components can expose unexpected security bugs due to their interaction.</p><p>During embedded system architecture design, techniques to map security requirements to alternative solutions, and to explore the associated tradeoffs in terms of cost, performance, and power consumption, would be invaluable in helping embedded system architects understand and make better design choices. For example, system architects would like to understand the performance and power impact of the processing architecture used to perform security processing, and the tamper-resistance schemes used.</p><p>During the hardware and software implementation processes, opportunities abound to improve the tamper resistance of the embedded system, as well as to mitigate the performance and power consumption impact of security features. For example, hardware synthesis (and software compilation) techniques to automatically minimize the dependence of power and execution time on sensitive data could help ensure that embedded system designs are highly tamper-resistant to side channel attacks by construction. Some initial efforts towards design methodologies to support security are described in <ref type="bibr" target="#b37">[41,</ref><ref type="bibr" target="#b64">70,</ref><ref type="bibr" target="#b65">71,</ref><ref type="bibr" target="#b66">72]</ref>.</p><p>In summary, as security becomes a requirement for a wide range of embedded systems, design tools and methodologies will play a critical role in empowering designers (who are not necessarily security experts) to address the design challenges described in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>Today, secure embedded system design remains a field in its infancy in terms of research and pervasive deployment. Although historically, various security issues have been investigated in the context of cryptography, network security and computer security, the challenges imposed by the process of securing emerging environments or networks of embedded systems compel us to take a fresh look at the problem. The good news is that unlike the problem of providing security in cyberspace (where the scope is very large), securing the application-limited world of embedded systems is more likely to succeed in the near term. However, the constrained resources of embedded devices pose significant new challenges to achieving the desired levels of security.</p><p>We believe that a combination of advances in architectures and design methodologies would enable us to scale the next frontier of embedded system design, wherein, embedded systems will be "secure" to the extent required by the application and the environment. To realize this goal, we should look beyond the basic security functions of an embedded system and provide defenses against broad classes of attacks -all without compromising performance, area, energy consumption, cost and usability.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Power consumption traces generated during a DPA attack on a DES implementation</figDesc><graphic coords="5,56.36,53.64,213.44,160.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Software security in the SDLC Requirements and use cases Design Test plans Code Test results Field feedback Abuse cases Security requirements External review Risk analysis Risk-based security tests Security breaks Static analysis (tools) Risk analysis Penetration testing Software security in the SDLC Software security in the SDLC Requirements and use cases Design Test plans Code Test results Field feedback Abuse cases Security requirements External review Risk analysis Risk-based security tests Security breaks Static analysis (tools) Risk analysis Penetration testing Figure 2: Software security best practices applied to various software artifacts in the Software Design Life Cycle (SDLC)</head><label></label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Prof. Lee's work is supported in part by NSF CCR-0326372 "ITR: Architectures and Design Methodologies for Secure Low-Power Embedded Systems.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.epaynews.com/statistics/mcommstats.html" />
		<title level="m">ePaynews -Mobile Commerce Statistics</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Cryptography and Network Security: Principles and Practice</title>
		<author>
			<persName><forename type="first">W</forename><surname>Stallings</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Applied Cryptography: Protocols, Algorithms and Source Code in C</title>
		<author>
			<persName><forename type="first">B</forename><surname>Schneier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>John Wiley and Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://wp.netscape.com/eng/ssl3/" />
		<title level="m">SSL 3.0 Specification</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Biometrics and Network Security</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Prentice Hall PTR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="http://www.openipmp.org" />
		<title level="m">OpenIPMP</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<ptr target="http:/www.isma.tv/home" />
		<title level="m">Internet Streaming Media Alliance</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://www.crl.co.uk/projects/moses/" />
		<title level="m">MPEG Open Security for Embedded Systems (MOSES)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="http://www.discretix.com" />
		<title level="m">Discretix Technologies Ltd</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Architectural support for copy and tamper resistant software</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>ACM Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="168" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">AEGIS: Architecture for Tamper-Evident and Tamper-Resistant Processing</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gassend</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Intl Conf. Supercomputing (ICS &apos;03)</title>
		<meeting>Intl Conf. Supercomputing (ICS &apos;03)</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="160" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Best</surname></persName>
		</author>
		<title level="m">Crypto Microprocessor for Executing Enciphered Programs. U.S. patent 4,278</title>
		<imprint>
			<date type="published" when="1981-07">July 1981</date>
			<biblScope unit="volume">837</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The TrustNo 1 Cryptoprocessor Concept</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhn</surname></persName>
		</author>
		<ptr target="http://www.cl.cam.ac.uk/˜mgk25/" />
	</analytic>
	<monogr>
		<title level="j">CS</title>
		<imprint>
			<biblScope unit="volume">555</biblScope>
			<date type="published" when="1997-04">Apr. 1997</date>
		</imprint>
		<respStmt>
			<orgName>Purdue University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Hoglund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mcgraw</surname></persName>
		</author>
		<ptr target="http://www.exploitingsoftware.com" />
		<title level="m">Exploiting Software: How to Break Code</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Viega</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mcgraw</surname></persName>
		</author>
		<ptr target="http://www.buildingsecuresoftware.com" />
		<title level="m">Building Secure Software</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Software Security</title>
		<author>
			<persName><forename type="first">G</forename><surname>Mcgraw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security &amp; Privacy</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="80" to="83" />
			<date type="published" when="2004-04">March-April 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Tamper resistance -a cautionary note</title>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Low cost attacks on tamper resistant devices</title>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IWSP: Intl. Wkshp. on Security Protocols</title>
		<imprint>
			<biblScope unit="page" from="125" to="136" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Design principles for tamper-resistant smartcard processors</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kommerling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Wkshp. on Smartcard Technology (Smartcard &apos;99)</title>
		<meeting>USENIX Wkshp. on Smartcard Technology (Smartcard &apos;99)</meeting>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
			<biblScope unit="page" from="9" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Information Leakage Attacks Against Smart Card Implementations of Cryptographic Algorithms and Countermeasures</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Janssen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schutze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROSMART Security Conference</title>
		<meeting>EUROSMART Security Conference</meeting>
		<imprint>
			<date type="published" when="2000-06">June 2000</date>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Side channel cryptanalysis</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Quisquater</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Samyde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the SECI</title>
		<meeting>of the SECI</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="179" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Side Channel Cryptanalysis of Product Ciphers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kelsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schneier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESORICS&apos;98</title>
		<meeting>ESORICS&apos;98</meeting>
		<imprint>
			<date type="published" when="1998-09">Sept. 1998</date>
			<biblScope unit="page" from="97" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Tamper Resistance Mechanisms for Secure Embedded Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakradhar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. VLSI Design</title>
		<meeting>Int. Conf. VLSI Design</meeting>
		<imprint>
			<date type="published" when="2004-01">Jan. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Timing attacks on implementations of Diffie-Hellman, RSA, DSS, and other systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Kocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO&apos;96</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1109</biblScope>
			<biblScope unit="page" from="104" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Examining Smart-Card Security under the Threat of Power Analysis Attacks</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Messerges</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Dabbish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Sloan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="541" to="552" />
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Differential Power Analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jaffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO&apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1666</biblScope>
			<biblScope unit="page" from="388" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On the importance of eliminating errors in cryptographic computations</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Demillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lipton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="101" to="119" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Electromagnetic radiation from video display units: an eavesdropping risk?</title>
		<author>
			<persName><forename type="first">W</forename><surname>Van Eck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Security</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="269" to="286" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Soft Tempest: Hidden Data Transmission Using Electromagnetic Emanations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Wkshp. on Information Hiding (IH &apos;98)</title>
		<meeting>Int. Wkshp. on Information Hiding (IH &apos;98)</meeting>
		<imprint>
			<date type="published" when="1998-04">Apr. 1998</date>
			<biblScope unit="page" from="124" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">ElectroMagnetic Analysis (EMA): Measures and Counter-Measures for Smart Cards</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Quisquater</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Samyde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science (Smartcard Programming and Security)</title>
		<imprint>
			<biblScope unit="volume">2140</biblScope>
			<biblScope unit="page" from="200" to="210" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Electromagnetic analysis: Concrete results</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gandolfi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mourtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Olivier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="251" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Securing wireless data: System architecture challenges</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Potlapally</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Intl. Symp. System Synthesis</title>
		<meeting>Intl. Symp. System Synthesis</meeting>
		<imprint>
			<date type="published" when="2002-10">October 2002</date>
			<biblScope unit="page" from="195" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Experimenting with electronic commerce on the PalmPilot</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Daswani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Financial Cryptography</title>
		<meeting>Financial Cryptography</meeting>
		<imprint>
			<date type="published" when="1999-02">Feb. 1999</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Minimizing Energy Consumption of Secure Wireless Session with QOS constraints</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Communications</title>
		<meeting>Int. Conf. Communications</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="2053" to="2057" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Analyzing the energy consumption of security protocols</title>
		<author>
			<persName><forename type="first">N</forename><surname>Potlapally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Low Power Electronics &amp; Design</title>
		<meeting>Int. Symp. Low Power Electronics &amp; Design</meeting>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
			<biblScope unit="page" from="30" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Xtensa application specific microprocessor solutions -Overview handbook</title>
		<ptr target="http://www.tensilica.com" />
	</analytic>
	<monogr>
		<title level="j">Tensilica Inc</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">System design methodologies for a wireless security processing platform</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Potlapally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sankaradass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM/IEEE Design Automation Conf</title>
		<meeting>ACM/IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2002-06">June 2002</date>
			<biblScope unit="page" from="777" to="782" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Architectural support for fast symmetric-key cryptography</title>
		<author>
			<persName><forename type="first">J</forename><surname>Burke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Intl. Conf. ASPLOS</title>
		<meeting>Intl. Conf. ASPLOS</meeting>
		<imprint>
			<date type="published" when="2000-11">Nov. 2000</date>
			<biblScope unit="page" from="178" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Cryptomaniac: A Fast Flexible Architecture for Secure Communication</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Austin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Computer Architecture</title>
		<meeting>Int. Symp. Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="110" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Efficient permutations for fast software cryptography</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="56" to="69" />
			<date type="published" when="2001-12">Dec. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Arbitrary bit permutations in one or two cycles</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf on Application-Specific Systems, Architectures and Processors</title>
		<meeting>Int. Conf on Application-Specific Systems, Architectures and essors</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="237" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Communication theory of secrecy systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Tech. Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="656" to="715" />
			<date type="published" when="1949-10">October 1949</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Bit Permutation Instructions for Accelerating Software Cryptography</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Intl. Conf. Application-specific Systems, Architectures and Processors</title>
		<meeting>IEEE Intl. Conf. Application-specific Systems, Architectures and essors</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="138" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Fast subword permutation instructions using omega and flip network stages</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Computer Design</title>
		<meeting>Int. Conf. Computer Design</meeting>
		<imprint>
			<date type="published" when="2000-09">Sept. 2000</date>
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Architectural enhancements for fast subword permutations with repetitions in cryptographic applications</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Mcgregor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Computer Design</title>
		<meeting>Int. Conf. Computer Design</meeting>
		<imprint>
			<date type="published" when="2001-09">Sept. 2001</date>
			<biblScope unit="page" from="453" to="461" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">How a processor can permute n bits in O(1) cycles</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Hot Chips 14 -A Symposium on High Performance Chips</title>
		<meeting>Hot Chips 14 -A Symposium on High Performance Chips</meeting>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Bit Permutation Instructions: Architecture, Implementation and Cryptographic Properties</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>Princeton University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Overview of Elliptic Curve Cryptography</title>
		<author>
			<persName><forename type="first">K</forename><surname>Araki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Satoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Miura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1431</biblScope>
			<biblScope unit="page" from="29" to="48" />
			<date type="published" when="1998">1998</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">A Scalable and Unified Multiplier Architecture for Finite Fields GF(p) and GF(2n)</title>
		<author>
			<persName><forename type="first">E</forename><surname>Savas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Tenca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Koc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Springer-Verlag Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1965</biblScope>
			<biblScope unit="page" from="277" to="292" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">PAX: A Datapath-Scalable Minimalist Cryptographic Processor for Mobile Environments (in Embedded Cryptographic Hardware: Design and Security)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Fiskiran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Nova Science Publishers</publisher>
		</imprint>
	</monogr>
	<note>to be published</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Permutation operations in cipher design</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J B</forename><surname>Robshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">J</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">L</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Intl. Conf. on Information Technology (ITCC)s</title>
		<meeting>Intl. Conf. on Information Technology (ITCC)s</meeting>
		<imprint>
			<date type="published" when="2004-04">Apr. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<ptr target="http://www.broadcom.com" />
		<title level="m">BCM5840 Gigabit Security Processor</title>
		<imprint/>
		<respStmt>
			<orgName>Broadcom Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Next-Generation Secure Computing Base (NGSCB)</title>
		<ptr target="http://www.microsoft.com/resources/ngscb/productinfo.mspx" />
		<imprint>
			<publisher>Microsoft Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Glaskowsky</surname></persName>
		</author>
		<title level="m">Microsoft Details Secure PC Plans. Microprocessor Report, In-stat/MDR</title>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">Trusted Computing Group</orgName>
		</author>
		<ptr target="https://www.trustedcomputinggroup.org/home" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<ptr target="http://www.intel.com/technology/security" />
		<title level="m">LaGrande Technology for Safer Computing. Intel Inc</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>York</surname></persName>
		</author>
		<ptr target="http://www.arm.com/armtech/TrustZone?OpenDocument)" />
		<title level="m">A New Foundation for CPU Systems Security. ARM Limited</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<ptr target="http://www.mips.com" />
		<title level="m">SmartMIPS</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A Processor Architecture Defense against Buffer Overflow Attacks</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Mcgregor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Karig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. on Information Technology: Research and Education (ITRE)</title>
		<meeting>Int. Conf. on Information Technology: Research and Education (ITRE)</meeting>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
			<biblScope unit="page" from="243" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<ptr target="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf" />
		<title level="m">Security Requirements for Cryptographic Modules (FIPS PUB 140-2)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<ptr target="http://csrc.nist.gov/cc" />
		<title level="m">Common Criteria for Information Technology Security</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Using state space exploration and a natural deduction style message derivation engine to verify security protocols</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Marrero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP Working Conf. on Programming Concepts and Methods</title>
		<meeting>IFIP Working Conf. on Programming Concepts and Methods</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Towards a completeness result for model checking of security protocols</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Computer Security Foundations Wkshp</title>
		<meeting>11th Computer Security Foundations Wkshp</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Algorithm exploration for efficient public-key security processing on wireless handsets</title>
		<author>
			<persName><forename type="first">N</forename><surname>Potlapally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Raghunathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lakshminarayana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design, Automation, and Test in Europe (DATE) Designers Forum</title>
		<meeting>Design, Automation, and Test in Europe (DATE) Designers Forum</meeting>
		<imprint>
			<date type="published" when="2002-03">Mar. 2002</date>
			<biblScope unit="page" from="42" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Energy-aware design techniques for differential power analysis protection</title>
		<author>
			<persName><forename type="first">L</forename><surname>Benini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Macii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Macii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Omerbegovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Poncino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
			<biblScope unit="page" from="36" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title level="m" type="main">Masking the Energy Behavior of DES Encryption</title>
		<author>
			<persName><forename type="first">H</forename><surname>Saputra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vijaykrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kandemir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Irwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-03">Mar. 2003</date>
			<biblScope unit="page" from="84" to="89" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
