<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Structure of Polynomial Time Reducibility</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Richard</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Umvers~ty of Wash~r~g~on</orgName>
								<address>
									<settlement>Seattle</settlement>
									<region>Washington</region>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Semnce</orgName>
								<orgName type="institution">University of Washington</orgName>
								<address>
									<postCode>98195</postCode>
									<settlement>Seattle</settlement>
									<region>WA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Structure of Polynomial Time Reducibility</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C2574378BD59C21E23D68643DD73469B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:09+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Two notions of polynomml time reduclbihty, denoted here by ~ T e and &lt;.~P, were defined by Cook and Karp, respectively The abstract propertms of these two relatmns on the domain of computable sets are investigated. Both relations prove to be dense and to have minimal pairs. Further, there is a strictly ascending sequence with a minimal pair of upper bounds to the sequence. Our method of showing density ymlds the result that if P ~ NP then there are members of NP --P that are not polynomml complete KEY WORDS AND PHRASES polynomial time computation, Turing reduc~billty, many-one reducibility CR CATEGORIES 5 25</p><p>Copyright O 1975, Association for Computing Machinery, Inc. General permission to republish, but not for profit, all or part of thin material is granted provided that ACM's copyright notice is given and that reference is made to the pubhcatlon, to its date of msue, and to the fact that reprinting privileges were granted by permission of the Association for Computing Machinery Thin research was supported m part by the National Scmnce Foundatmn under Grant GJ-34745x. Many of the results presented here are found In a different form in "Polynomml time reduclbihty,"</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Cook <ref type="bibr" target="#b2">[3]</ref> and Karp <ref type="bibr" target="#b5">[6]</ref> have introduced two notions of polynomial time reducibility. They show quite effectively that the notion of reducibility is a useful tool in classifying the complexity of problems. They show that a wide class of important problems all have the same time complexity (modulo a polynomial) by showing that all the problems are reducible to each other in polynomial time We propose to study the abstract properties of their two reducibilities thought of just as relations between problems. We pay particular attention to properties that might shed some light on the question of whether or not every problem computable in nondeterministic polynomial time is also computable in deterministic polynomial time. We notice further that the properties we show are true of polynomial time reducibility hold true also of a wide variety of subrecursive reducibilities, including log space, elementary, and primitive recursive. We fix the alphabet 2~ = {0, 1} as the alphabet in which all problems are encoded, so that a problem is simply a subset of Z*. We let &lt; be the natural order on Z* (k&lt;0&lt;l &lt;00&lt;01 &lt; -â€¢ -), where ), represents the empty string. In general we consider only solvable problems, that is, computable subsets of Z*. If x E Z* we let Ix I denote the length of x When confusion will not arise we adopt the habit of identifying a problem with its characteristic function, namely, if A C Z* then A(x) = 1 if x E A and A(x) = 0 if x ~ A. Our basic model of computation is the multitape Turing machine. All such machines are assumed to be deterministic unless otherwise specified. A Turing machine T (determimstic or nondetermimstic) runs ~n polynomial time if there is a polynomial function q such that for every input of length n any computation sequence of T halts in q(n) or fewer moves. Define P (NP) to be the class of problems recognized by deterministic (nondeterministic) Turmg machines which run in polynomial time.</p><p>The two definitions of polynomial time reducibility of Karp and Cook are just time bounded versions of many-one reducibility ( &lt; ,~) and Turing reducibility ( _&lt; r) defined by Post <ref type="bibr" target="#b17">[18]</ref>. A set A is many-one reducible to a set B if there is a computable function f such that x E A if and only if f(x) E B. To obtain Karp's notion of polynomial time reducibility we simply require f to be computable in polynomial time. To be more precise A is many-one reducible to B m polynomial tzme (A &lt; ~P B) if there is a function f which is computable by a Turing machine running in polynomial time such that x E A if and only if f(x) E B. The notion of Turing reducibihty can be obtained by considering oracle Turing machines. An oracle Turing machine is a multitape Turing machine with an oracle tape. There are special states Q, YES, and NO such that if the machine enters state Q then the machine enters state YES if the current contents of the oracle tape is in the oracle set and enters state NO otherwise. Strictly speaking, an oracle Turing machine has two "inputs"--the input written on the input tape and the oracle set (which is not written anywhere). Such a machine runs in polynomial time if there exists a polynomial q such thai, for any input of length n and any oracle set X the machine halts within q(n) steps. A set A is Turing reducible to B if and only if there is an oracle Turing machine which recognizes A when presented with the set B as its oracle. To obtain Cook's notion of polynomial time reducibility we just require that the oracle Turing machine run in polynomial time. Hence A zs Turing reducible to B in polynomial time ( A &lt; r e B) if and only if there is aa oracle Turing machine M which runs in polynomial time such that x is in A exactly when M halts in an accepting state with input x and oracle B.</p><p>The work of Post and others in recursive function theory has demonstrated that the notions of many-one reducibility and Turing reducibility are effective tools in classifying unsolvable problems. If we think of the problems in P as the "realistically computable problems," then the polynomial time bounded versions of these reducibilities may serve as useful tools in classifying the computable yet not realistically computable problems. Indeed Cook <ref type="bibr" target="#b2">[3]</ref> has shown that the set, S, of satisfiable formulas has the property that S E NP and if A E NP then A ~ ~P S. Karp <ref type="bibr" target="#b5">[6]</ref> noticed that Cook's proof actually yields the fact that every member of NP is &lt;,e S. In some sense S is as hard to compute (modulo polynomial time) as any member of NP, albeit if P = NP then S is realistically computable. Karp <ref type="bibr" target="#b5">[6]</ref> calls sets with the properties of S polynomial complete. Calling such sets polynomial complete is quite fitting because it parallels the definition of complete set in recursive function theory (see Rogers <ref type="bibr" target="#b20">[21]</ref>). A set B is m-complete (T-complete) if it is recursively enumerable and if A is any recursively enumerable set then A ~ m B (A &lt; r B). This analogy is strengthened if we notice that the characterization of NP as the class of all sets A such that there is a polynomial time computable relation R and a polynomial q where A = {x : 3y of length _&lt; q(l x l) where (x, y) E R} (see Cook <ref type="bibr" target="#b2">[3]</ref> or Karp <ref type="bibr" target="#b5">[6]</ref>) parallels the characterization of the recursively enumerable sets as the class of all sets A such that there is a computable relation R where A = {x : 3y where (x, y) E R} (see Rogers <ref type="bibr" target="#b20">[21]</ref>). We say that a set B is polynomial m-complete (T-complete) if B E NP and if A E NP then A &lt; m e B (A _&lt; r P B). Cook <ref type="bibr" target="#b2">[3]</ref>, Karp <ref type="bibr" target="#b5">[6]</ref>, Sethi <ref type="bibr" target="#b21">[22]</ref>, Stockmeyer <ref type="bibr" target="#b22">[23]</ref>, Ullman <ref type="bibr" target="#b24">[25]</ref>, and others have exhibited a wide variety of polynomial m-complete problems including satisfiability, 0-1 integer programming, register allocation, planar 3-colorability, and scheduling problems. In Section 2 we discuss the basic facts about m and T reducibility in polynomial time and examine the work of others that exposes properties of these relations. In Section 3 we show that the polynomial m-degrees and T-degrees are dense. Our method shows that if P # NP then there must exist members of NP that are neither in P nor polynomial T-complete. Indeed, it turns out that if P # NP then there exist &lt; re-incomparable members of NP, that is, problems A and B both in NP such that A $ r P B and B ~ r e A.</p><p>In Section 4 we construct computable sets A and B neither of which is computable in polynomial time but if C _&lt; r P A and C _&lt; re B then C is computable in polynomial time.</p><p>Hence the polynomial T-degrees of A and B form a minimal pair. In Section 5 we show that neither the polynomial m-degrees nor polynomial T-degrees form a lattice by constructing a sequence Co, C1, â€¢ â€¢ â€¢ of computable sets and a pair A, B of computable sets such that:</p><p>(i) C, &lt;_~P C,+t for all,, (ii) C,+1 ~TPc, for ally, (iii) C, ~_m P A and C, &lt;mPB for all i, (iv) if D &lt; r P A and D _&lt; r P B then D &lt;,,P C, for some ~. As a consequence neither the polynomial m-degrees nor T-degrees of A and B can have a greatest lower bound. In Section 6 we show how to conclude these same sorts of results for other subrecursive reducibilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Basics</head><p>From this point on we restrict our attention to just the computable sets. When we speak of the polynomial m-or T-degrees we speak only of the polynomial m-or T-degrees of computable sets. We should first notice that Turing reducibility in polynomial time is a generalization of many-one reducibility in polynomial time; that is, if A _&lt;m P B then A &lt; r P B. Except for a certain pathology, neither kind of reducibility can distingmsh members of P; namely, if A, B E P then A ~re B and if A, B E P -{~2~, ~*} then A ~-u P B. The polynomial m-degrees of ~ and 2~* are _&lt; raP-incomparable. Because of this pathology we shall systematically ignore the existence of the sets ~2~ and Z* when we speak of polynomiM m-degrees. Hence we can say without hesitation that there is a least polynomial m-degree and, in fact, that its ~-raP-equivalence class is exactly P -{~Gf, Z*}. The set P is the least polynomial T-degree. Every two polynomial m-degrees or T-degrees have a least upper bound in their respective orderings. Indeed, if A and B are problems then we can code both into a single problem A @ B =-{0x :x E A} U {lx :x E B} so that the polynomial m-degree (Tdegree) of A @ B is the least upper bound of the polynomial m-degrees (T-degrees) of A and B. We call the least upper bound of two polynomial m-or T-degrees their 3tin.</p><p>Hence the partial ordering of m-degrees and T-degrees are upper sermlattices. The class NP is closed under many-one reducibility in polynomial time in the sense that if B E NP and A &lt; m P B then A E NP. This result seems to fail for _&lt; r P. On the other hand A &lt;r e A for all A, which fads for &lt;,~P (Ladner et al. <ref type="bibr" target="#b8">[9]</ref>).</p><p>Let P0, P1, "" , To, T1, -.. , and M0, M1, -.-be, respectively, effective enumerations of the Turing machine recognizers that run in polynomial time, the Turing machine transducers that run in polynomial time, and the oracle Turing machines that run in polynomial time. Such enumerations exist by attaching for each k to each appropriate kind of Turing machine a (k + nk)-counter which will not allow the Turing machine to exceed making k + n k moves on any input of length n. Let P, denote the set recognized by P, as well as the Turing machine P,. Similarly, let T, denote the function computed by T, and M,(A) the set recognized by M, with oracle A. We are not specific about the number of tapes, heads, and alphabet symbols we allow in our Turing machines because polynomial time computation is independent of these kinds of Turing machine specifications.</p><p>Define ~ (A) = { 1' : 1' ~ M,(A) }. The set ~ (A) represents sort of a diagonal set. Clearly ~f(A) is computable if A is. Furthermore, 5(A) Sr P A for if ~(A) = M,(A) then 1 ~ E ~(A) if and only if 1 ~ ~ ~(A) We conclude that there is no maximum polynomial m-degree or T-degree, since A &lt;_,P A @ ~(A) and A @ ~(A) Sre A.</p><p>Some of the work of Axt <ref type="bibr" target="#b0">[1]</ref> concerning primitive recursive reducibility can be general-ized to yield the result that for any n there are n computable sets such that no one is polynomial T-reducible to the ioin of the remaining n -1. More significantly, Machtey <ref type="bibr" target="#b11">[12]</ref> shows that any countable partial ordering is embeddable in the primitive recursive degrees of recursive sets. His method can be applied to get the result that any countable partial ordering is embeddable in both the polynomial m-degrees and T-degrees of computable sets.</p><p>The work of Machtey <ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref> and Meyer and Ritchie <ref type="bibr" target="#b14">[15]</ref> on honest primitive recursive or elementary recursive classes ~s related to the work here.</p><p>Machtey's method for showing that the honest subrecursive classes are dense is similar to our method of showing that the polynomial m-or T-degrees of computable sets are dense.</p><p>The existence of minimal pairs of subrecursive degrees of computable sets was first noticed by Machtey; in particular <ref type="bibr" target="#b10">[11,</ref><ref type="bibr">Ths. 4.4,</ref><ref type="bibr">4.7]</ref> directly imply that there exist mini~ mal pairs of primitive recursive degrees of computable sets. These theorems are proved in detail as <ref type="bibr" target="#b11">[12,</ref><ref type="bibr">Cor. 4.7]</ref> and <ref type="bibr" target="#b12">[13,</ref><ref type="bibr">Th. 3.7]</ref>. Our method of constructing minimal pairs of polynomial T-degrees seems to be different from Machtey's method of constructing minimal pairs.</p><p>Lynch <ref type="bibr" target="#b9">[10]</ref> defines and proves several interesting properties about an extremely general notion, "complexity determined reducibility," of which polynomial T-reducibility is a special case.</p><p>Let N = 10, 1, 2, .. '1 and let (., -} be a standard pairing function mapping N X N one-to-one onto N. For instance let (z, y} = Â½[(x + y) (x + y + 1)] + x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Density Results</head><p>Rather than going directly to the most general density result we prove a special ease which illustrates the central ideas of these kinds of arguments. The method of proof in this section was inspired by the proof of Borodin et al. <ref type="bibr" target="#b1">[2]</ref> of the fact that the Turing machine space complexity classes are dense. THEOREM 1. If B is computable and not zn P then there exists a computable A such that A ~ P, A ~_m eB,andB ~r v A.</p><p>PROOF. We construct a polynomial time bounded transducer T with range ~ {11" in such a way that if we let A = {x E B :] T(x) I is even} then A ~ P and B ~reA.</p><p>Since B cannot equal E* we let x0 E Z* -B. The fact that A &lt; ~P B is witnessed by the transducer that prints x if ] T(x) I is even and x0 if I T(x) ] is odd.</p><p>In some sense tile machine T is "trying to satisfy" the following list of conditions:</p><formula xml:id="formula_0">(O) A ~ Po, (1) B ~ Mo(A), (2) A ~ P1, (3) B ~ M~(A),</formula><p>. Forthosexforwhich T(x) = F, T is trying to satisfy the zth condition listed above. Think of T as processing successive inputs in the natural ordering of 2~* To satisfy A ~ P,, after some point T begins to output 1 ~'. Hence A begins to look like B. Since B ~ P, then eventually some z must witness A ~ P,, that is, eventually some z must exist such that A(z) ~ P,(z). In polynomial time, T tries to find that z and when it does T goes on to another task by printing 12~+1. In printing 12'+~, T is trying to satisfy the condition B ~ M,(A) by forcing A to look empty beyond a certain point. Eventually some z must witness that B ~ M,(A) ; otherwise we could conclude that B E P, which is not the case. In polynomial time, T tries to find that z and when it does, T may go on to another task by printing 12'+2. Thus, A in the end may be described as in Figure <ref type="figure">1</ref>, where the entire line represents the natural ordering of Z*, beginning at the left with ~,, and where the wavy lines represent A looking like B and the straight lines represent A looking like ~.</p><p>We now give an informal description of T and rely on the reader's intuition to verify that T could be programmed on a Turing machine that runs in polynomial time. On input X, T prints ~. On an input x of length n where x ~ 0 '~, T prints T(0~). It remains to say what T does on inputs of the form 0 ~ where n &gt; 1. Fin. 1</p><p>On input 0" where n ~_ 1, T does the following:</p><p>1. For n moves, try to reconstruct the sequence T(X), T(O), T(O~), .... Let T(0 m) be the last number of this sequence that is computed.</p><p>2. Case (i) : I T(0m) I is even. Let i = ] T(0 ~) I/2. For n moves, try to find a z such that A(z) ~ P,(z). Do this by successively simulating T (to see what A is) and P, on Case (ii): IT(0m) ]isodd. Leti = (IT( 0m) l --1)/2â€¢ For n moves try to findaz such that B(z) ~ M,(A)(z). Do this by simulating an algorithm for B and the procedure M, successively on inputs X, 0, 1, 00, 01, â€¢ . In simulating M, on some input, should M, enter state Q then T must be simulated with the contents of the oracle tape of M, as its input to see if the string on the oracle tape is in A or not. The moves in this side calculation are counted among the n. If no such z is found, print 12'+1; otherwise, print 12z+2.</p><p>It should be noticed that I T(0") I -&lt; I T(0~+~) I -&lt; I T(0n) I + 1 for all n. Furthermore, if I T(0~) [ = z + 1 for some n then the ith condition in the sequence above is satisfied as witnessed by the z found when computing T(0 ~) where m is the least number such that I T(0m) I = i + 1. Hence the theorem is proved if {1}* = Range T. This we show by induction on the length of elements of {1}*. Clearly X E Range T. Assume 1 ~ E Range T. Let q be the least number such that T(0 q) = 1 ~. Either T(0 ") = T(0 q) for all n &gt;. q or 1 ~+~ E Range T. We ehnfinate the former possibility. Assume T(0 ~) = T(0 q) for alln &gt; q.</p><p>Case 1. 3 is even. Let i = .7/2. In this case A(x) = B(x) for all x of length greater than or equal to q. Since B ~ P then A ~ P,. Let z be the least string in the natural ordering of Z* that witnesses this inequahty. Let n be large enough so that on input 0 n, T can recompute the sequence T(X), T(0), ... , T(0 q) in n or fewer moves and T can also run its simulations of T and P, through the input z in n or fewer moves. We must then have T(0 ~) = 12~+1 = 1 j+l, which was supposedly impossible.</p><p>Case 2. j is odd. Let ~ = (3 -1)/2. In this case, x C A for allx of length greater than or equal to q. Hence M,(A) E P. Since B ~ P then B # M,(A) and again there is a smallest z that witnesses this difference. By an argument similar to that of case 1 there is some n k q such that T outputs 1 ~+1 on input 0 ". [] We can conclude immediately: COROLLARY 1.1. If P # NP then there exist members of NP -P that are not polynomml T-complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PRoof. Let B E NP --P and let A be as in the theorem. Since A &lt;_ m P B then A E NP and since B ~ r P A then A is not polynomial T-complete. []</head><p>Corollary 1.1 is analogous to the solution to "Post's problem" in recursive function theory. Post <ref type="bibr" target="#b17">[18]</ref> posed the problem: Is every nonrecurswe, recursively enumerable set Turing complete? A negative solution was discovered independently by Friedberg [4l and Muchnik <ref type="bibr" target="#b16">[17]</ref>. A polynomial time bounded version of Post's problem would be: Is every member of NP -P polynomial T-complete? In a way the problem only makes sense if P ~ NP.</p><p>Karp <ref type="bibr" target="#b5">[6]</ref> mentions three problems in NP which are not known to be in P or to be polynomial m-complete; namely GRAPH ISOMORPHISM (the problem of whether two graphs are isomorphic), NONPRIMES (the problem of whether a binary string is a nonprime), and LINEAR INEQUALITIES (given an integer matrix M and integer vector d, whether there is a rational vector x such that Mx &gt;_ d.) Corollary 1.1 allows the possibility that these problems may indeed be nonpolynomial T-complete problems in NP --P. Assuming these three problems are not in P there is some evidence that the latter two problems are not polynomial m-complete. Pratt <ref type="bibr" target="#b18">[19]</ref> has noticed that the complement of NONPRIMES is also in NP. Likewise, Karp [71 has noticed that the complement of LINEAR INEQUALITIES is in NP. On the other hand, Meyer <ref type="bibr" target="#b15">[16]</ref> noticed that NP is closed under complement if and only if some polynomial m-complete problem has its complement in NP. Now, no complement of a known polynomial m-complete problem has yet been shown to be in NP. Thus it is not unlikely that both NONPRIMES and LIN-EAR INEQUALITIES are nonpolynomial m-complete members of NP -P.</p><p>One interesting property of the set A constructed in Theorem 1 is that it is the intersection of B with a set which can be computed in polynomial time, namely the set {x :1 T(x) I is even]. So if P # NP then we could consider a polynomial T-complete problem like HAMILTON CIRCUIT (the problem of whether or not a graph has a cycle which includes each node exactly once; see Karp <ref type="bibr" target="#b5">[6]</ref>). By our remarks there must be a set of graphs which can be determined in polynomial time such that the HAMILTON CIR-CUIT problem restricted to that set would be in NP -P yet not be polynomial Tcomplete. As we shall see from the next theorem, we are able to partition any problem not in P into two 5 rP-incomparable problems. As before, imagine that T processes inputs in the naturM ordering of Z*. When T(x) = 1' then T is trying to satisfy the ,th condition in the above sequence. To satisfy an even numbered condition we make Bo look like B and B1 look like ~, while to satisfy an odd numbered condition we make B1 look like B and Bo hke ~2~. Using algorithms for computing A and B, the construction of T follows lines exactly as in the construction of T in the proof of Theorem 1. The proof hinges on showing that T does not eventually get "stuck" generating some word in {1}*. Should T get stuck generating 14~ then for x sufficiently long Bo(x) = B(x) and Ba(x) = O. Since B ~ r e A then B0 ~ r P A @ B~ and in particular B0 ~ M,(A @ B~). Eventually T must realize this difference and try to satisfy the next condition on the list. Should T get stuck generating 14'+2 then for all x sufficiently long Bo(x) = B(x) and B~(x) = O. Since B Sr e A then B0 Sr F A and in particular B0 M,(A). Again, T must eventually realize this difference. The other two cases are symmetric. [] Instead of &amp;agonalizing over the Turing reduction procedures that run in polynomial time we could have diagonalized over the many-one reduction procedures that run in polynomial time to obtain the following. Since D is computable in polynomial time then certainly B, &lt; ~' B. Because A &lt; e B then A @ B, &lt; r e B. Of course condition (i) of the theorem guarantees that B ~ge A @ B,. It is a simple matter to check that Co @ C1 ~ r B because Bo (J BI = B. [] Using Corollary 2.1 we can conclude that Corollary 2.2 also holds for many-one reducibility in polynomial time. The only question is showing B &lt;,f C~ @ C1. It would suffice to show that B _&lt; m e B0 @ Ba. This does not directly follow from the fact that Bo U B~ = B. However, B _&lt; m e B0 @ B1 via the following many-one reduction procedure. Let Q be the set of rational numbers in the closed interval [0, 1]. COROLLARY 2.5. If P # NP then there is a family of problems {At : r E Q} c NP such that (~) Ao = ~2~ and A1 is a polynomial m-complete problem, (ii) p &lt; q implies Ap &lt;m P A~, (id) p ~g q imphes Ap $T P A~.</p><p>PROOF. Suppose P # NP. Let A0 = ~2f and A1 = any polynomial m-complete set. Let r0, r~, -â€¢ â€¢ be an effective one-to-one enumeration of the rationals in Q -{0, 1}. Let R, = {rj :3 &lt; z} [3 {0, 1/. We define by induction on, a family {A~ : r E R,t in such a way that (i)-(iii) hold of the family when the p and q are restricted to R,. The family {A0, A~} = {A, : r E R0} satisfies (i)-(fii). Assume {A, : r E R,} satisfies (i)-(iii). Let p and q be the unique members of R, such that p &lt; r, &lt; q and no other pair p', q' from R, satisfies the inequality, p' &lt; r, &lt; q', unless p' &lt; p and q &lt; q'. Apply Theorem 2 to the sets A~ and Aq to get the polynomial time computable set D. Let A,, = (Aq I"1 D) @ A~. []</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">A Minimal Pa~r</head><p>Because of density we know that there can be no computable set B ~ P such that if A _&lt; r e B then either A E P or B _&lt; r e A. To put it another way, there can be no mimmal polynomial T-degree of a computable set. For the same reason there can be no minimal polynomial m-degree of a computable set. The next question one might ask is whether or not there is a pair of computable sets neither of which are computable in polynomial time, but with the property that any set T-reducible to both of them in polynomial time is itself in P. The polynomial T-degrees of two such sets are called a minimal pa~r. As we noted in Section 2, M. Machtey has observed already that other subrccursive degrees do have minimal pairs. Machtey has announced (unpublished) an independent proof of Theorem 3 based on his "honesty" methods. Of course any pair of sets whose polynomial T-degrees form a minimal pair must also have the property that their polynomial mdegrees form a minimal pair. TheOReM 3. There exist computable problems A and B neither of whwh is computable in polynomml time, but if D _&lt; r P A and D &lt; r P B then D is computable in polynomial time.</p><p>PROOF. We would like to construct sets A and B satisfying the following: (i) A ~ P, for all z, (ii) B ~ P, for all i, (iii) if M,(A) = Me(B) then M,(A) is computable in polynomial time, for all z and2 (minimal pair conditions).</p><p>If we are not interested in making A and B computable then the theorem is quite easy to prove using methods found in <ref type="bibr" target="#b7">[8]</ref>. We satisfy conditions (i) and (ii) by diagonalizing. To satisfy the (i, j&gt;-th minimal pair condition we assume that, A and B are permanently defined at all arguments of length less than l. See if there exist an input x and a finite set F c {y :1Y I &gt;-l} such that M,(A U F)(x) ~ M~(B)(x). If no such x and F exist then do nothing about the (i, 3&gt;-th minimal pair condition. Otherwise, choose x and F to be minimal. Set A = A U F and 1 = l --J-sum of run times of M, and Mj on input x. If M,(A ) = Me(B) then M,(A) = M,(C) for some finite set C, namely, C = {y E A : ] y ] &lt; l'} where l' is the value of l after considering the (i, j)-th minimal pair condition. Hence M,(A) E P. It is clear that A and B are highly noncomputable, for in the construction of A and B we are able to satisfy a minimal pair condition in one large nonrecursive step. If we are to make A and B computable we must forsake the luxury of nonrecursive steps.</p><p>Let t be a strictly increasing recursive function such that for each i, if n &gt; , then M, runs in time less than t(n) on all input of length less than or equal to n. We construct A and B in stages with A' and B" being the respective values of A and B at the end of stage s. Together with A and B we construct a sequence 10, ll, ---of integers and a polynomial time computable function T : 10, 1}* ~ {0, 1, c}*. At stage s + 1 of the construction we determine A(x) and B(x) for all x where I, &lt; I x [ &lt; I,+1. For convenience define fi to be 1 ". The construction may be visualized partially as in Figure <ref type="figure" target="#fig_2">2</ref>. In Figure <ref type="figure" target="#fig_2">2</ref>  Case 1. e = 0. Run M, on input x. Should M, enter state Q with y on the oracle tape then take the YES branch if I Y [ &lt; l and y = x, for some i &lt; k and take the NO branch otherwise. Accept if and only if M, does.</p><p>Case 2. e = 1. In this case run Me on input x with exactly the same restrictions as described in case 1.</p><p>This algorithm does indeed compute D(x) on all inputs x with Ix[ &gt; l,~. Should T(x) = Odcxlc ... cxkc for some l, xl, ... , xk then 1 = l~v+l and ] x I &lt; /4p+4 for some p. Define A' by A'(y) = A(y) for all y of length less than 14~+1 and A'(y) = 0 otherwise. By (a), A(y) = 0 for 14p+l _&lt; y &lt; /4~+4 whence A'(y) = A(y) for all y of length less than 14p+4. Now 4p + 4 &gt; So and so by (d), M,(A'</p><formula xml:id="formula_1">)(x) = M,(A)(x). But M,(A')(x)</formula><p>is what is actually computed by the algorithm on input x. If T(x) = ldcx~c â€¢. â€¢ cxkc then l = 14p+3 and Ix [ &lt; 14p+6 for some p. In this case the algorithm computes Mj(BP)(x) where B' is defined by B'(y) = B(y) if y &lt; 14p+3 and B'(y) = 0 otherwise. Again by (d) this is a computation of D(x). Thus D is computable in polynomial time.</p><p>Roughly speaking, we can construct A, B, T, and 10, l~, ... satisyfing (a)-(d) as follows. If s -~ 1 or 3 (mod 4) then in 1,+1 moves of a Turing machine that simulates the construction we can recover the entire construction on arguments of length less than 1,. This enables T to be computed in polynomial time. At each even numbered stage we try to force M,(A)(x) ~ M,(B)(x) for somex with max {i,j} _&lt; Ix[ &lt;/8 provided we have not already done so. There are two ways we do this: if s -= 0 (mod 4) then we try to extend A in such a way as to force M,(A)(x) ~ M~(B) (x) for some x with max/i,3} _&lt; I x I &lt; l~, while if s ------2 (mod 4) then we try to extend B to do the same. Such extensions would amount to putting a subset of {y : 18 &lt; ] y I &lt; /,+~} into A or B. If no such extensions exist then we know the conditions of (d) must hold for i, .7, and s. If we do force M,(A) ~ Mj(B) then the number (i, j) is canceled. Suppose M,(A) ~-Me(B) in the limit. Let s be large enough so that l~ &gt; t(max {z, 3}) (recall that Mk runs in time t(n) on inputs of length less than or equal to n whenever n &gt;_ k) and all numbers less than (i, 2} that are ever canceled are canceled before stage s. Since l, &gt; t(max {i, 3} ) then any changes in A or B at stage s do not alter the computations of M, or M~ on inputs of length less than max {~, 3}. The conditmns of (d) must hold for i, 3, and s, or else we would have been able to force Ms(A) ~ Mj(B) and would have canceled (~, 9} at stage s. Finally, we use the strings 1~+1 --1 to diagonahze over the polynomial time computable sets. We now proceed with the construction of A, B, T, and 10, 11, '--satisfying (a)-(d). Let U be a Turing machine that simulates the construction in the following way. On an input of length n &gt; l~, U (by simulating the Construetior~ below) eventually writes down a string of the form eclcxlc .. cxkc and halts, where: (1) 1 is the largest number less than or equal to n such that 1 = I, for some s and s -~ 1 or 3 (mod 4) ; (2) if l -~ l, then e = 0if s ~= 1 (mod4) and e = 1 ifs ~ 3 (rood 4); (3) if e--0then x~ &lt; ... &lt; xk are the members of A of length less thanl and if e = 1 then x~ &lt; â€¢ " &lt; xk are the members of B of length less than 1. If ~ &lt; l~ the U writes 0 on any input of length n. The computation of U on input x really only depends on the length of x. We may presume that if I x [ &lt; I Y [ then U runs in less time on input x than it does on input y. Let u be the function such that on each input of length n, U makes exactly u(n) moves. We may define the sequence 10, l~, ... as follows:</p><formula xml:id="formula_2">lo = 0, ft(l,) + 1 if siseven, l~+1 = (u(l~)</formula><p>if s is odd.</p><p>' THE CONSTRUCTION Sta|le s. [We define A and B at all x where l, _~ [ x I &lt; l,+1]. There are three cases to consider Case 1. s = 4k. There are two steps Step 1. Fred the least uncanceled d &lt;: k, if any, such that there exist a string x with max{z, j} _~ Ixl &lt;loandafinitesetF~{Y: 1,_~ lYl &lt;L+~-1} such that M, (A UF)(x) ~ Mj(B)(x) where d = (~. j). If no such d exists, go to step 2. Otherwise, choose x and F to be ramlmal, set A = A U F, and cancel d.</p><p>Step2 If1 ~Â¢ P~wherel=l,+~-lthensetA =A (J{ltl. Case 2. s = 4'k -~ 2 Do exactly as in ease 1, except reversing the roles of A and B. Case 3. s = 4k ~ lor4k~3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Donothmg. End of the Construction</head><p>There is a seeming circularity to the simultaneous definition of {/,}, A, and B in that A and B are defined in the Construction from {l,} and {l,} is defined from U which "is" the Construction. What we have done really is make implicit use of the recursion theorem.</p><p>We define T as follows: T(x) = U(1 m) where m is the largest number such that t x ] :_&gt; u(m) if there is such an m; otherwise T(x) = O. By successively trying to compute U(k), U(1), U(12), ... , each within time bound Ix 1, we can certainly compute T(x) in time bounded by c I x 12 for some constant c.</p><p>The theorem is proved once we verify (a)-(d). The condition (a) is easily checked since we add nothing to A at stages s ~ 1, 2, and 3 (rood 4) and nothing to B at stages s -~ 0, 1, and 3 (rood 4). Condition (b) follows directly from the Construction. To check condition (c) we just examine the definition of T. Clearly T(x) = 0 for all x of length less than 12 since U(x) = 0 for all x of length less than 11 and l~ = U(ll). If 1~,+2 ~ I x I &lt; /4,+4 then T(x) = U(14,+l) since u(14~+l) = 14,+2 and Ix[ &lt; u(14,+3), and U(1 TM) = U(14,+x) for all m such that 14,+1 _~ m &lt; 14,+3. Hence T(x) = Od4~+tcx~c ... cxkc where Xx &lt; â€¢ â€¢ â€¢ &lt; xk are the members of A of length less than 14~+1. If 14,+4 &lt; ] x [ &lt; 14,+~ then we must have T(x) = U(l~,+~) and hence T(x) = lcl~+acx~c ... cx~c where Xl &lt; --" &lt; x~ are the members of B of length less than l~,+~.</p><p>Finally we verify (d). Suppose M,(A) = My(B). To begin with, (i, 2) is never canceled. If it were, say at stage s, then there is an x with max {i,j} &lt; I x I ~ l, such that M~(A') (x) M,(B')(x). Smce I x I &gt; max {~, 2} then M, and M~ run in time less than t( I x I) on input x. Now, t( I x I) -&lt; t(l,) ~ 1,+t. After stage s, strings added to A or B must be greater than or equal to l~+x so that M,(A')(x) = M,(A")'(x) and M~(B~)(x) = M~(B")(x) for all s' &gt; s. Whence M,(A)(x) ~ M~(B)(x), which is a contradiction. Let so be a stage such that 1,0 &gt; t(max {i, 3} ) and no number less than or equal to (~,)) is canceled at a stage greater than or equal to so. Suppose (d) fails at some stage s &gt; So. We examine the case when s ~-0 (rood 4). The other case is analogous. Let A' and x be such that A'(y) = A(y) if I Y l &lt; l, and M,(A')(x) ~ M,(A)(x) with Ix { &lt; 1,. If t x I ~ max {i, ~} then by the definition of t, M, runs in time less than t(max {~,3}) &lt; l~ 0 &lt;: l~ on input x. Since no word written on the oracle tape by M, on input x can have length exceeding its run time, we must have M,(A')(x) = M,(A)(x).Hence I x I ~-max li,3l. Let F = {y:l~ ~ lYl &lt; l,+~ -1 and y ~ A'}. We must have M.(A')(x) --M,(A '-~ [J F)(x) since Mr runs in time less than t(I x I) &lt; l,+~ -I on input x. Now M~(B'-I)(x) = Me(B)(x)since B(y) = 0 for all y where l, &lt; y &lt; 1,+l. Hence, M,(A '-~ [J F)(x) ~ M~(B'-~)(x) which means that (~, 3) should be canceled at stage s, which is again a contradiction. []</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">An Ascending Sequence w~th a Mimmal Pair of Upper Bounds</head><p>In this section we show that neither the polynomial m-degrees nor the polynomial Tdegrees form a lattice. The method of proof is inspired by the imtial segments arguments of Kleene and Post <ref type="bibr" target="#b7">[8]</ref>.</p><p>' If s = (e, f, g) then stage s + 1 of the construction is primarily devoted to dmgonalizing to make R2~+i(A) ~ Mi(S2oÃ·~(A)). Th~s diagonalization will succeed unless there is some d _&lt; e such that we can force M,(A) ~ Me(B) where d = (,, ~). The parameter g allows us infinitely many attempts at diagonalizing to make R~+~(A) ~ M](S~,+i(A)). At least one of these attempts is successful because for each pair (i, 2) there is at most one stage at which we forsake diagonalizing to force M,(A) ~ Me(B). Should we force M,(A) ~ Me(B) at stage s + 1 then the number (i, 3) is canceled at stage s + 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I'HEOREM 4. There exist computable sets Co, C1, â€¢ -. , A and B such that ( ~ ) C, _~ m P C,+i for all 2, ( ~ ) C,+1 ~ ~ C, for all ~, ( ~ ) C, _~ mP A and C~ &lt; M e B for all i, (iv) if D &lt; ~</head><p>From stage to stage we maintain a list 10, l~, .... Let l~" be the value of l~ at the end of stage s. We shall have l~" _&lt; l~ +~ and lim, l~" = ~. The value of l~ marks the amount of the kth row of A and B that is currently determined, that is,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>if I x I ~ l~' then R~(A ~) (x) = R~(A')(x) and R~(B~)(x) = R~(B')(x) for all t &gt; s.</head><p>Let s = (e, f, g) and d = (~, 3). If d &lt; e and no number less than or equal to d is canceled at stage s ~ 1 then we can "embed" a piece of M,(A) into the 2dth row of A and B by putting l~0x into A and B at stage s ~ 1 provided x ~ M,(A) and lid &lt; Ix I l.+~ . /.+1 _&lt; 2~ â€¢ If d &gt; e then l~ = ~d unless some number less than or equal to e is canceled at stage s + 1. Since each number is canceled at most once we conclude that if we never cancel the number d then M,(A) is embedded into the 2dth row of both A and B, that is, R2d(A) (x) = R~d(B)(x) = M,(A) (x) for all but finitely many x. (The exceptions would occur at stages when numbers less than d were canceled.) The construction works because, if we cannot extend A in such a way at stage s --~ 1 as to force M,(A)(x) # s--~-I Me(B) (x) for some x of length less than or equal to l:~ , then the value of M,(A)(x) for x of length less than or equal to l~ -~ does not really depend on what is added to A or B at stage s + 1; m partmular, we can safely add to A and B all l:~0x such that x ~ M,(A) 1 can occur at stage (e, f, g) + 1. We must have hm, lk = ~ for each k because k &gt; lk* whenever s = (k, f, g) for some f and g and no number less than or equal to k is canceled at stage 8 + 1. The sets A and B are recursive, for to determine if l'0x is in A or B we wait for the least stage s such that Ix I -&lt; 1,'. Now FOx E A if and only if FOx E A', and similarly for B.</p><p>The theorem is proved if we can verify (a)-(c) mentioned above.</p><p>Claim (a) For each i, R,(A)(x) = R,(B)(x) for all but finitely many x.</p><p>We always add the same strings to A and B except in step 2 of the construction. In step 2 of stage s + 1 a string of the form l'0x is put into A only if l, &lt; I x I -&lt; t(m2d</p><formula xml:id="formula_3">)</formula><p>where d is canceled at stage s W 1. In the d iterations of step 1 before proceeding to step 2, the value of l~ for 2 &lt; 2d was increased to mj. By the definition of m~ we must have m~ _&gt; t(m2~) for all 3 &lt; 2d. Hence l'0z enters A only if ~ &gt; 2d (since Ij &gt;_ t(m2~) for j &lt; 2d). We conclude that R,(A)(x) = R,(B)(x) for all x of length &gt; l, t, where t is the least stage such that no number less than or equal to ~/2 is canceled at a stage greater than or equal to t.</p><formula xml:id="formula_4">Claim (b) R2~+i(A) ~ Ms(S2,+i(A)) for all ~ andj.</formula><p>Let 8 be a number of the form (~, 3, k) such that no number less than or equal to i is canceled after stage s and l~,+~ &gt; 3. At stage 8 ~ 1 we execute step 3 since no number less than or equal to ~ is canceled at stage s ~ 1. Let m be as in step 3. We certainly have Let d = (~, 2} and let u be a stage such that no number less than or equal to d is cance]ed at a stage greater than or equal to u. Should d ever be canceled, say at stage s -t-1, then we can show that M,(A) ~ Me(B). We certainly have M,(A "+1) (x) ~ M ~(B ~+1) (x) lS+l for the x selected in step 2. We have ~ &gt; t(] x ]) for all k _&lt; t(I x I) since lk is already that large for k &lt; 2d and Ik is set that large for k with 2d &lt; k &lt; t(I x I). Now, I x I d &gt; max {z, 31 so that both M, and Mj run in time bounded by t(I x I) on input x. Since no question of M, or M 3 can have length exceeding t([ x I) on input x then we must have</p><formula xml:id="formula_5">s' 8! M,(A")(x) ~M,(B )(x)forall</formula><p>&gt;_8+1. Assume then that d is never canceled and that D = M,(A) = Ms(B). We show that D(x) = R2~(A)(x) for all x of length greater than l~. Let s be the unique stage greater lsW1 than or equal to u such that l~ &lt; [ x I -&lt; ~ â€¢ At stage s + 1, step 1 is iterated at least d + 1 times. Let A' and A" be the values of A at the beginning and at the end of the (d + 1)-st iteration respectively. Adding the set G to A guarantees that A"(l:a0x) = </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Generalizatwns</head><p>The results of the previous sections can be generalized to a wide variety of subrecursive reducibilities. We shall restrict ourselves to subrecursive reducibilities definable by space and time bounded Turing machines.</p><p>Let us first consider time definable reduc~b~lities. Let C be any class of total functions from the natural numbers into itself. We say that A is Turmg reducible to B in C-time (A &lt;crt B) if there is an oracle Turing machine M and a function f E C such that M runs m time f and x E A if and only if M accepts x when presented with B as its oracle.</p><p>A is many-one reducible to B in C-time (A &lt;c~ B) if there is a Turing machine transducer T and a function f E C such that T runs in time f and x E A if and only if T(x) E B.</p><p>Turmg machine acceptors and transducers and oracle Turing machines may have any finite number of tapes and tape symbols.</p><p>To obtain a reasonable notion of time definable reducibility there are several restrictions we should put on C. To begin with if &lt;~' and _&lt;cr* are to be reflexive relations then there should be a function f E C such that f(n) ~_ n so that the oracle Turing machine C t can at least copy the input onto the oracle tape. For &lt;ct and _~r to be transitive C should have the property that if f and g E C then there exist h E C such that While K is simulating N on the contents of M's oracle tape should N enter state Q then so does K and K's oracle tape is actually N's. To avoid confusion, after simulating N and getting an answer, K should erase any trace of this side computation. On an input of length n, M cannot ask a question of the oracle of length greater thanf(n) so that K cannot make more than max {g(m) :m _~ f(n)} moves in a single simulation of 1N on M's oracle tape. The erasing of such a side computation requires no more than max {g(m) : m _~ f(n)} moves. Finally no more than f(n) simulations of N on M's oracle tape are made by K. Hence K runs in time bounded by f(n) + 2f(n) max {g(m) :m &lt;_ f(n)}. These restrictions on C which allow _&lt;cr~ to be reflexive and transitive force C to have the property that for every polynomial function p there is an f E C such that f(n) &gt;_ p(n) for all n. It would seem then that any reasonable notion of time definable reducibility must be at least as powerful as polynomial time reducibility. If we are only interested in many-one reducibility then the restrictions on C to make ~* reflexive and transitive can be lessened. If C equals the set of linear functions then &lt;c' is certainly transitive. Let C t be the (:-time computable sets, that is, the class of sets computable in time f for somef E C. A function q is t, me measurable if there is a multitape Turing machine T such that on each input of length n, T halts in exactly q(n) nmves. One thing that seemed to help make our earlier constructions work was that for each h we could "attach" a (k -tnk)-counter to each Turing machine in order to make effective enumerations of the polynomial time bounded Turing machine recognizers, Turing machine transducers, and oracle Turing machine recognizers. If C has the property that C is cofinal with a recursively enumerable class {q,} of time measurable functions (that is, there is an effective enumeration q0, ql, " â€¢ â€¢ of time measurable functions such that for all f E C there is an such that q,(n) &gt; f(n) for all n and for all z there is anf E C such that f(n) &gt;_ q,(n)), then we see for each ~ we could "attach" a q,(n)-counter to each appropriate kind of Turing machine in order to obtain effective enumerations of the C-time bounded recog-nizers, transducers, and oracle machines. If C contains enough functions to force &lt;c~ and _~cr~ to be reflexive and transitive and there is a recursively enumerable sequence Iq,/ of time measurable functions cofinM with C then Theorems 1-4 hold where P is replaced by C t, The proofs of these "new" theorems would be essentially the same as already given for P. If we modify the proofs of Theorem 1-4 sufficiently we can remove the requirement that C be cofinal with a recursively enumerable class of time measurable functions and simply require C to be co final vath a recursively enumerable class of total recursive functions.</p><formula xml:id="formula_6">h(n) ~_ f(n)[1 + 2 max Ig(m) .m ~ f(n)}].</formula><p>Define C to be a time class if C is cofinal with a recursively enumerable set of total recursive functions, there is some f E C such that f(n) ~_ n for all n, and for all f and g in C there is an h E C such that h(n) ~_ f(n) <ref type="bibr">[</ref> PROOf. We shall examine the modifications needed to obtain Theorem 1. Similar modifications can be made to get the other three theorems. Let go, gl, â€¢ â€¢ â€¢ be an effective enumeration of total recursive functions cofinal with C. Let R0, R1, â€¢ " be an effective enumeration of all Turing machine recognizers and let R0, R1 be an effective enumeration of all oracle Turing machines.</p><p>Just as in the original proof we construct a polynomial time bounded transducer T and A = {x : x C B and [ T(x) I is evenJ. Since C is a time class then m-time reducibility includes polynomial time reducibility. Hence the reduction procedure that witnesses A _~,~P B also witnesses A ~C*B. In this case T is "trying to satisfy" the following conditions for each pair (i, j) :</p><p>(a) A ~ R, or on some input x, R, runs in time greater than g~(I x I), (b) B ~ R,(A) or on some input x and with oracle X, R, runs in time greater than g~(Ixl). We leave it to the reader to supply modified proofs of Theorems 2-4. We now consider space definable reducib~httes. To allow the possibility of space bounds less than linear we modify our Turing machines as follows. All Turing machines have a read only input tape and one work tape. Recognizers need no additional tapes. Transducers have a write only output tape. Oracle Turing machines have a write only oracle tape. Output tapes and oracle tapes do not move right. We adopt the convention that the oracle tape is erased after each question of the oracle. When we speak of a machine that runs in q(n) space then we mean that on any input of length n the machine halts without scanning more than q(n) different tape cells on the work tape. More than q(n) different tape cells can be scanned on the input tape, output tape, or oracle tape.</p><p>Let C be a class of total functions. The class C" is the class of sets computable in space bounded by a function in C. We say that A is Taring reducible to B in C-space (A ~Cr'B) if there is an oracle Turing machine M and a function f E C such that M runs in f(n)space and x E A if and only if M accepts x when presented with the oracle B. Further, A is many-one reducible to B in E-space (A _&lt;~'B) if there is a Turing machine transducer T and a function f E C such that T runs in f(n)-space and x E A if and only if T(x) E B.</p><p>In order to make _&lt; ~' and _&lt; cv' reflexive and transitive there are some restrictions we should make on C. To make each reflexive E should contain a function f such that f(n) &gt; 1 for all n. Before specifying any restrictions on C let us imagine how we might reduce A to C in C-space if we already have A &lt;Cr'B and B _&lt;CrSC. Letf and g E C and let M be an f(n)-space bounded oracle machine and N be a g(n)-space bounded oracle machine such that M reduces A to B and N reduces B to C. The obvious reduction procedure reduc-</p><formula xml:id="formula_7">ing A to C is max ({cnf(n)c s('~)} U {g(m) : m ~ cnf(n)cS(n)}) space bounded for some c.</formula><p>The procedure would simulate M using a track of its work tape to simulate M's oracle tape. Should M enter state Q then the machine begins simulating N on the contents of the track which simulates M's oracle tape returning to the simulation of M when N halts. Unfortunately there is a constant c (dependent on M) such that a word of length cnf(n)c s(') could be written by M on its oracle tape. Since M's oracle tape is one-way read only there is no real need to write down all of M's oracle tape onto the work tape. All logs are base 2. LEMMA 6. If M ~s f(n)-space bounded and reduces A to B and N is g(n)-space bounded and reduces B to C then there is an oracle Turing machine K reducing A to C that zs max (If(n), log n} U Ig(m) : m _&lt; enf(n)J(~)} )-space bounded for some constant c. Mode 2. Simulate N by updating tracks 5 and 6 and using K's oracle tape to simulate N's. Since M's oracle tape is unavailable for scanning we must do a side computation to discover what the ~th letter of M's oracle tape is where ~ is the binary count on track 5. This is done by copying track 3 onto track 7, resetting the input head of K to the count on track 4, and simulating M until it has outputed i symbols (which would have normally been written on M's oracle tape). Track 8 is used to keep count of how many symbols have been outputed so far. Once the ~th output symbol is known then tracks 5 and 6 can be accurately updated. Should this simulation of N halt then K returns to mode 1, updating tracks 3 and 4 and remembering in fimte control whether M entered state YES or state NO.</p><p>On an input of length n tracks 1, 3,  PROOF. We leave the proof to the reader. We only note that the function T defined in each of the proofs of Theorems 1, 2, and 3 will be log n-space bounded rather than polynomial time bounded.</p><p>Other space and time definable reducibility notions are possible. Stockmeyer and Meyer <ref type="bibr" target="#b23">[24]</ref> define an interesting notion of reducibility. They define A &lt; log-h. B if there is a log nspace bounded transducer T and constant c such that x E A iff T(x) E B and IT(x)I _&lt; c Ix I. Their notion could be generalized to Turing reducibility by requiring log space bound on the work tape and linear space bound on the oracle tape. In general there seem to be three basic complexity parameters m reduction procedures: (i) time of the procedure, (ii) storage space used by the procedure, and (iii) space used by the procedure in writing its questions. It would be interesting to make a comparison of different notions of reducibility obtained by varying the bounds on (i)-(iil).</p><p>It appears to us that our Theorems 1-4 are true of almost any reasonable notion of space and time definable reducibility obtained by varying the bounds on (i)-(in).</p><p>There is also the possibihty of abstractly defining notions of subrecursive reducibility. For instance, we could define primitive recursive reducibihty by A is przmitive recurswe in B if the characteristic function of A is in the smallest class of functions containing the constant zero function, the successor functxon, the projection functions, and the characteristic function of B, and closed under composition and recursion. (We are identifying ~* with numbers written in dmtic notation, that is, k represents 0 and a~a2...a~ E Z* represents z-1 2" --1 + ~a,2</p><p>). This is really a Turing reducibility. Define primitive recursive manyone reducibility by A is many-one primztwe recursive m B if there is a primitive recursive function f such that x E A if and only if f(x) E B.</p><p>The work of Ritchie <ref type="bibr" target="#b19">[20]</ref> and others in showing that many abstractly definable classes of recursive functions are just Turing machine complexity classes can be extended to show that, many interesting abstractly definable subrecursive reducibility notions are just space and/or time definable reducibilities. From the schemata for defining Grzegorczyk classes ~'(n &gt; 0) <ref type="bibr" target="#b4">[5]</ref> we could define abstractly, as we did for primitive recursive reducibility, ~%reducibility (both Turing and many-one). Both ~0 and ~ seem somewhat pathological. The notion of ~%reducibility is equivalent to reducibility with a linear space bound both on (.he work tape and oracle tape (output tape in the case of many-one reducibility). The notion of ~%reducibility for n &gt; 3 is equivalent to reducibility in ~"-space. Likewise the notion of primitive recursive reducxbility is equivalent to reducibility in primitive recur-</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Define A &lt;me B (A &lt;r e B) if A &lt;~P B and B Sme A (A &lt;r e B and B ~r e A). Further A ~,neB (A ~-TPB) ifA ~PB andB &lt;,~PA (A &lt;feB and B _&lt;rFA). Since both &lt;,~P and &lt; ~P are reflexive and transitive relations, the relations ~,~P and e ~r are equivalence relations. The equivalence classes are called the polynomial mdegrees and polynomial T-degrees respectively. The polynomial m-degrees (T-degrees) are partially ordered by the order induced by &lt; m P (&lt; r e) on sets. Structural questions about the relations &lt;,~ and &lt; r e reduce to structural questions about the respective induced ordering on the polynomial m-degrees and polynomial T-degrees.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>T~mOREM 2 .</head><label>2</label><figDesc>If A and B are computable with B ~ r P A then there exists a set D E P such that if Bo = B N D and Bi = B N b then (~) B P $r A @ B, for,= 0,1, (,i) B, SreA fort = O, 1. PROOF. Let A and B be computable with B $ r P A. As in the proof of Theorem 1 we shall define a polynomial time computable function T with range ~ {1}*. We set D = {x : I T(x) Its even}. With B0 = B D D and B1 = B N b the machine T is "trying to satisfy" the following list of conditions: (0) B # Mo(A @ B1), (1) B # Mo(A $ B0), (2) Bo # Mo(A), (3) B1 # M0(A), (4) B # Mi(A @ B1), (5) B # Mi(A ~ Bo), (6) B0 ~ Ma(A), .-..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>COROLLARY 2 . 1 .</head><label>21</label><figDesc>If A and B are computable with A ~ ~, A ~ ~*, and B $m P A then there exists a set D E P such that ~f Bo = B I1 D and B1 = B N 1) then (~) B ~ ~P A B, for z = O, 1, (it) B, ~ mP A for ~ = O, 1. PROOF. From the remarks above. [] Theorem 2 enables us to conclude that any polynomial T-degree "splits" over all smaller ones" COROLLAnY 2.2. I] A ~ rP B and A and B are computable then there exist computable sets Co and Cl such that A &lt; r PC, &lt; r P B for i = O, l and B ~ r Co @ C1. PROOF. We have A ~ rP B and B I' _ ~r A. Leti= 0 or l and let C, = A @B, where B, is as in Theorem 2. Obviously A &lt; r P A @ B,. Since B, ~ r P A then A ~ B, ~ r A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>2 ,Fie. 2 of</head><label>22</label><figDesc>the two lines represent A and B as presented in the natural ordering of Z*. Segments that are straight lines are empty while segments that are wavy lines are possibly nonempty. The sets A and B, the Turing machine T, and the sequence l0 &lt; l~ &lt; â€¢ â€¢ â€¢ have the following properties: (a) x ~ A whenever 14~+1 &lt; I x I &lt; 14~+4 and x ~ B whenever 14,+a ~ I x I &lt; I4,+6 or ix[ &lt; l~, (b) A(I') ~ P,(1 ~) ifn = 14,+~ --1, B(1 ~) ~ P,(I') ifn = /4,+~ --1, Ocl4,+,cxlc "." cxkc "." if 14~+2 &lt; Ix I &lt; 14,+4 and Xl &lt; x~ &lt; .-. &lt; x, are the members of A of length less than T(x) = l~,+l, lcZ4~+3CXlC â€¢ ." cxkc .. â€¢ if 14,+4 _~ I x [ &lt; 1~,+6 and xl &lt; x2 &lt; " â€¢ â€¢ &lt; xk are the members of B of length less than (d) ifM,(A) = Me(B) then there exists So such that ifs &gt; So then.(1) if s-= 0 (mod 4) and A' is any set with A'(x) = A(x) for all x with Ix I &lt; 1, then M,(A')(x) = M,(A)(x) for all x of length Jess than 1,, (2) if s ~ 2 (rood 4) and B' is any set with B'(x) = B(x) for all x with I xl &lt; l, then Mj(B')(x) = M~(B)(x) for all x of length less than L.Assuming we can construct A, B, T, and {/,} as described in (a)-(d), we explain why A and B satisfy the theorem. First, A and B are not polynomial time computable because (b). Suppose D &lt;r e A and D &lt;_r P B. There arc z andj such that D = Mr(A) = NI~(B). Using T with the property described in (c) and properties (a) and (d) we can compute D in polynomial time. Consider the following algorithm. Let I x I ~-l~0. On input x: Compute T(x). Now, T(x) = ecZczlc ... cxkc for some e, l, xl, ".. , xk. There are two cases:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>A and D &lt; r P B then D &lt;, e C, for some ~. PROOF. If E C Z* we define the ith row of E to be R,(E) = Ix : FOx C El and the ith section of E to be S,(E) = {y E E â€¢ y = l'0x for some x andj &lt; i}. It is quite easy to see that R,(E) _&lt; u P S,+i(E), S,(E) _&lt;,~P S,+i(E), and S,(E) &lt; ~P E for all z We shall construct computable sets A and B with the following properties. (a) for each i, R,(A) (x) = R,(B) (x) for all but finitely many x E ~*, (b) R2,+i(A) ~ M~(S2,+i(A)) for all , and j, (c) if D = M,(A) = M,(B) then D(x) = R2(,.3&gt;(A)(x) for all but finitely many x. If we set C, = S2,(A) then Co, C1, â€¢ â€¢ â€¢ , A and B satisfy the theorem. (i) Clearly S~,(A) &lt;_m P $2,+2(A). (ii) $2,+2(A) ST P S2,(A); otherwise R~,+i(A) ~T P $2,+1(A), contrary to (b). (iil) By (a), S2,(A) &lt;m P B as well as &lt;m P A. (iv) Condition (c) guarantees that if D _&lt;r P A and D __&lt;T P B then D _&lt;~P S2,(A) for some i.We construct A and B in stages. Let A ~ and B' be the values of A and B at the end of stage s. Each member of A or B will have the form FOx where z ~ 0 and x E {0, 1}*. Let (x, y, z) = ((x, g), z).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Ix] _&lt; ~ . Let t be an increasing recursive function such that for all i, M, runs in time bounded by t(n) on all inputs of length n &gt;_ i. THE CONSTRUCTION Stage0. SetA = B = ~andl, = 0for alll. Stage s ~ 1. The number s equals (e, f, g) for some e, f, and g. Set m2~+1 = 12~+~ --Jr 1 and mk = lk ~ t(mk+l) for0 &lt; k &lt; 2e + 1. Set d = 0. 1. [Can d be canceled~] If d &gt; e go to 3. If d is uncanceled and there exist an x with d _&lt; I x [ &lt; m2d and afimteset F..C.. {y : yhas the form lk0zwherek _&lt; t(m2d) and lk &lt; [ z I --&lt; t(m2d)} such that M, (A [J F) (x) ~ M~ (B) (x) where d = (z, j), then go to 2 If d is already canceled or there is no such x and F then let G = {12d0y: 12d &lt; lY [ -~ m2~andy E M,(A)}.SetA = AUG, B = B (JG, l~d = m2d, 12d-el = ~7~2d+1, and d = d ~ 1 Return to 1 2. [d is canceled] In this case select x and F satisfying the conditions in 1. Set A = A [J F and l~ = lk + t(m~d) for 2d &lt; k &lt; t(m2d). Cancel d and go to the next stage 3. [Dlagonahzatmn] Let m = m2~+~. If 1" Â¢ Ms(S~,+~(A)) then set A = A U {1~+101 ~} and B = B O {1',+~01~}. Go to the next stage End of the Constructwn Each construction stage ends in a finite amount of time because at most e iterations of â€¢ ~ l â€¢ ..t-1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>+l(A'+l)(1 m) ~ M~(S:,+i(A'+X))(I~). Now, m &lt; ~2,+1 so that _ R:.+~(A )(1 TM) = R2,+l(A'+~)(1 ~) for all s' &gt;_ s + 1. By cycling through step 1 ~ times we succeed in 7s~l making ~h &gt; t(m) for all h 4 2z ~ 1. Since m &gt; i then Mj runs in time bounded by t(m) on input I m. Hence no question of the oracle can have length exceeding t(m). Thus the computation on the right hand is fixed. That is, Mj(S2,+~(A ))(1 m) = M,(S2,+i(A"))(1 m) for all s' &gt;_ 8 + 1. Claim (c) If D = M,(A) = Ms(B) then D(x) = R2&lt;,.,)(A)(x) for all but finitely many x.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>COROLLARY 4 . 1 .</head><label>41</label><figDesc>A )(x). The left side of this equation equals R;~(A)(x) since I x [ &lt; ~;~ . It suffices to show that M~(A')(x) = M,(A)(x). Suppose not. Let lo', l~', ... be the values of 10, l~, â€¢ â€¢ â€¢ , respectively, at the beginning of the (d + 1)-st iteration of step 1. Since A (l~0z) is determined for z of length less than or equal to 1S and {1}* ~ A = ~ then there exists a finite set F ~ {y . I y l _&lt; t(I x I) and y has the form l~0z with I z I &gt; l~'l such that M,(A' U F) (x) ~ M,(A') (x). Let B' be the value of B at the beginning of the (d --F 1)-st iteration of step 1. Either M,(A' U F)(x) ~ M~(B')(x) or M,(A')(x) ~ M~(B')(x) so that x and either F or ~ satisfy the condition of step 1, which forces d to be canceled at stages+ 1. [] The theorem directly implies" Neither the polynomial m-nor T-degrees of computable sets are a lattice. PROOF. The m-or T-degrees of A and B do not have a greatest lower bound in their respective orderings. []</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>If A _&lt;Cr'B via an f(n)-time bounded oracle Turing machine M and B _&lt;Cr'C via a g(n)time bounded oracle Turing machine N then A &lt;rOtE via the f(n)[1 + 2 max {g(m) : m ~ f(n)}]-tlme bounded oracle Turing machine K. The machine K simulates M until M would enter state Q, then it simulates iN or the contents of M's oracle tape and when N would halt K returns to the simulahon of M knowing which of YES or NO it should enter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>1 + 2 max {g(m) :m ~_ f(n)l] for all n. THEOREM 5. If C *s a t,me class then ~c~ ~ and ~cr* are reflexive and transittve relations and Theorems 1-4 hold with P replaced by C t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>If T(x) = I k where k = 2(i, j} then T is trying to satisfy condition (a) for the pair (i, j) by trying to find in I x I or fewer moves the least z in the natural ordering of X* such that A(z) ~ R,(z) or R, runs in time greater than g~( I z I ) on input z. If T(x) = 1 k where k = 2(i, 2} + 1, then T is trying to satisfy condition (b) for the pair (i, 2) by trying to find in I x I or fewer moves the least z in the natural ordering of 2~* such that B(z) R~(A )(z) or there is a finite set F c lY : I Y ] -~ g~( [ z I )} such that R, runs in time greater than g~( ] z I ) on input z and with oracle F. From this intuitive description of what T is trying to do we could piece together an actual definition of the action of T so that A = {x :x E B and I T(x) ] is even} satisfies (a) and (b) for all ~ andj. Now, A ~ C t since otherwise for some, and 2, A = R, and R, runs in time bounded C t by g, which implies condition (a) is not satisfied for, and3. Further B $ T A; otherwise for some ~ and 2, B = R,(A) and R, runs in time bounded by g~, which implies condition (b) fails for i and j.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>and 7 are](n)-space bounded while tracks 2 and 4 are log n-space bounded. There is a constant c such that no word longer than cnf(,~)c s(~) can be written on M's oracle tape so that track 6 is max {g(m) : m &lt; cnf(n)cS(")l-space bounded and tracks 5 and 8 are log (cnf(n)c s(~)) space bounded. Hence the bound of K holds. [t can be easily verified that K reduces A to C. [] log An important application of this lemma is in log space reducibility. Define ~ T to be c. where C contains the single function log n. Hence &lt; ~r Â°~ is the relation of Turing reduci---log â€¢ bility in log n space. Clearly &lt; r is reflexive and Lemma 6 shows that it is transitive. By the lemma if A &lt; ~Â°~B and B &lt; lrÂ°gC then A is Turing reducible to C in space bounded by max ({log n} U [log m :m &lt; cn log nc~Â°g~ I ) for some constant c. But this amounts to a log n space bound.In general if C is a class of total functions and &lt;_ or' is to be reflexive and transitive then C should contain a function f such that f(n) &gt; log n for all n and if f and g are in C then for each constant c there is a function h E C and constant d such that dh(n) &gt; max ({f(n)} O {g(m)} : m &lt; cnf(n)c s(~)} ) for all n. We allow the constant d because any work tape can be compressed by a constant factor.Define C to be a space class if C is eofinal with a reeursively enumerable set of total recursive function, C contains a functionfwithf(n) &gt; log n, and if f, g E C and c is a constant then there exists h E C and a constant d such that dh(n) _&gt; max ({f(n)} O {g(m) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>. Y(n)~ m &lt; cnf(n)e ,) for alln. THEOREM 7. If C zs a space class then _&lt;~" and c, _~ r are reflexwe a~d transitwe relations and Theorems 1-4 hold with P replaced by C'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>On input x see if x E D. If x E D print 0x and if x E /) print Ix. The density of the polynomial m-and T-degrees follows immediately: COROLLARY 2.3. The polynomial m-and T-degrees of computable sets are dense. PROOF. By the above. [] Under the assumption that P # NP we can show that not only does NP contain _&lt; re-incomparable problems but that there is an infinite dense hierarchy of problems in NP based on Turing reducibility in polynomial time: COROLLARY 2.4. If P # NP then there exist &lt; re-incomparable members of NP; that is, there exist problems Bo and B1 in NP such that Bo :~ r e B1 and B1 ~ r e Bo. PROOF. Let B E NP --P and apply Theorem 2 to ~ and B to obtain the polynomial time computable set D and the sets B0 = B n D and B1 = B N D. The sets Bo and B1 are _&lt; re-incomparable because B is not Turing reducible to either set in polynomial time yet B is Turing reducible to B0 @ B~ in polynomial time. Both B0 and B1 are in NP since B ENPandB,&lt; l, Bfori= 0,1. [] It is interesting to note that no one has yet shown NONPRIMES and LINEAR IN-EQUALITIES to be &lt; re-comparable problems. Perhaps they satisfy Corollary 2.4.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>PRoof. This proof generalizes a proof ofStockmeyer and Meyer [24, Lem. 2.1]. The machine K has two modes: mode 1 where K is directly simulating M and mode 2 where K is simulating N. When K is in mode 2 it may need to do an aside simulation of M as well. The machine K has 8 tracks.Track 1 holds the current contents of M's work tape. Track 2 holds the binary count of the current read head position of M. Track 3 holds the contents of M's work tape as it was immediately after the last time M entered state Q.</figDesc><table><row><cell>Track 4 holds a binary count of M's input head position as it was after the last time M</cell></row><row><cell>entered state Q.</cell></row><row><cell>Track 5 holds M's oracle head position when K is in mode 2.</cell></row><row><cell>Track 6 holds the contents of N's work tape when K is in mode 2.</cell></row><row><cell>Track 7 holds an aside work space.</cell></row><row><cell>Track 8 holds an aside count.</cell></row><row><cell>In finite control K remembers whether M entered state YES or NO after the last time</cell></row><row><cell>it entered state Q.</cell></row><row><cell>On input x, K operates as follows:</cell></row><row><cell>Begin in mode 1.</cell></row><row><cell>Mode 1. Simulate M directly updating tracks 1 and 2 but writing nothing on what</cell></row><row><cell>would be M's oracle tape. Should M enter state Q, K enters mode 2. K accepts if and</cell></row><row><cell>only if M does.</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ACKNO'WLEDGMENTS. We would like to thank A. H. Lachlan, M. Maehtey, and R. W. Ritehie for several enlightening conversations concerning this research. We also appreciate the careful reading of the manuscript by Paul Frank.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>sive space. By our observations above Theorems 1-4 (interpreted correctly) hold for inreducibility for (n &gt; 2) and primitive recurslve reducibility.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On a subrecursive hierarchy and primitive recurslve degrees Trans</title>
		<author>
			<persName><forename type="first">P</forename><surname>Axt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AMS</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="85" to="105" />
			<date type="published" when="1959">1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Borodin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Constable</surname></persName>
		</author>
		<author>
			<persName><forename type="first">~nd</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename></persName>
		</author>
		<title level="m">Dense and nondense famihes of complexity classes IEEE Conf Record Tenth Annual Syrup on Switching and Automata Theory</title>
		<imprint>
			<date type="published" when="1969">1969</date>
			<biblScope unit="page" from="7" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The complexity of theorem proving procedures</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc Third Annual ACM Syrup on Theory of Computing</title>
		<imprint>
			<biblScope unit="page" from="151" to="158" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Two recurmvely enumerable sets of incomparable degrees of unsolvablhty</title>
		<author>
			<persName><surname>Friedbi~</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc Nat Acad Sc~ USA. $</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="236" to="238" />
			<date type="published" when="1957">1957</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Some Classes of Rccarswe Fancl~onns Rozprawy Matematyczhe</title>
		<author>
			<persName><forename type="first">'</forename><surname>Grzegoi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>~czyk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1953">1953</date>
			<pubPlace>Warsaw</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Reducibility among combinatorial problems In Complexity of Computer Compulatwns</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<editor>R. E Miller and J. W Thatcher</editor>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Plenum</publisher>
			<biblScope unit="page" from="85" to="103" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">R M Private</forename><surname>Kxrp</surname></persName>
		</author>
		<author>
			<persName><surname>Commumcatmn</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Theupperseml-latOce of degrees of unsolvabihty Ann</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Kleene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Andpost</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math., Ser</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="379" to="407" />
			<date type="published" when="1954">1954</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Comparison of polynomial-time reducibilities</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladnea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc Sixth Annual ACM Syrup on Theory of Computing</title>
		<imprint>
			<biblScope unit="page" from="110" to="121" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Relat~vizatmn of %he theory of computatmnal complexity Tech Rep</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<idno>TR-99</idno>
		<imprint>
			<date type="published" when="1972">1972</date>
			<pubPlace>Proiect MAC, Ph D. Th , M I.T , Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Classification of computable functmns by primitive recurslve classes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Machtey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc Third Annual ACM Symp on Theory of Computing</title>
		<imprint>
			<biblScope unit="page" from="251" to="257" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Augmented loop languages and classes of computable functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>M~chtey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Comput. Syst Sc~</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="603" to="624" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">The honest subrecurmve classes are a lattice. I2~form and Contr</title>
		<author>
			<persName><forename type="first">M</forename><surname>Machtey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="247" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On the density of honest subrecurstve classes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Machti~</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Scl. Dep, Purdue U</title>
		<imprint>
			<date type="published" when="1973">1973</date>
			<pubPlace>Lafayette, Ind</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech Rep. CSD TR 92</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A classification of the recurmve functions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>I~itchie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Z Math Log*k Grul,dlagen Math</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="71" to="82" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Meyer</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Private communication</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the unsolvabihty of the problem of reducibfi~tyln the theory of algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Muchnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Doklady Akadcmzz Navk SSSR</title>
		<imprint>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="194" to="197" />
			<date type="published" when="1956">1956</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Recurmvely enumerable sets of positive integers and their decision problems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Post</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. AMS</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="284" to="316" />
			<date type="published" when="1944">1944</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">V Every prime has a succinct certificate</title>
		<author>
			<persName><surname>Prttt</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In preparation</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Ritchie</surname></persName>
		</author>
		<title level="m">Classes of predictably computable functmns Trans AMS</title>
		<imprint>
			<date type="published" when="1963">1963</date>
			<biblScope unit="volume">106</biblScope>
			<biblScope unit="page" from="139" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">JiÂ¢</forename><surname>Roge~rs</surname></persName>
		</author>
		<title level="m">H Theory of Reeurswe Funchons and Effective Computabd*ty McGraw-Hill</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><surname>S~</surname></persName>
		</author>
		<author>
			<persName><surname>T~i</surname></persName>
		</author>
		<title level="m">II Complete register allocation problems Proc Fifth Annual ACM Symp on Theory of Computing</title>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="183" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Planar 3-colorabihty is polynomial complete</title>
		<author>
			<persName><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="19" to="25" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Stockmeyer</surname></persName>
		</author>
		<author>
			<persName><surname>Meyer</surname></persName>
		</author>
		<title level="m">A R Word problems requiring exponential time preliminary report Proc Fifth Annual ACM Symp on Theory of Computing</title>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Polynomial complete scheduling problems ACM</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ullm In</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth Symposmm on Operating System Principles</title>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="96" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">RECEIVED JANUARY 1974, REVISED JULY</title>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1974-01">1974. January 1975</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
