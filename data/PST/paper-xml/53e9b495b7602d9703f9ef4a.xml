<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The java.util.concurrent synchronizer framework</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2005-06-13">13 June 2005</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Doug</forename><surname>Lea</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">State University of New York at Oswego</orgName>
								<address>
									<postCode>13126</postCode>
									<settlement>Oswego</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The java.util.concurrent synchronizer framework</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2005-06-13">13 June 2005</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1016/j.scico.2005.03.007</idno>
					<note type="submission">Received 1 November 2004; received in revised form 15 January 2005; accepted 1 March 2005</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T13:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Most synchronizers (locks, barriers, etc.)  in the J2SE 5.0 java.util.concurrent package are constructed using a small framework based on class AbstractQueuedSynchronizer. This framework provides common mechanics for atomically managing synchronization state, blocking and unblocking threads, and queuing. The paper describes the rationale, design, implementation, usage, and performance of this framework.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Java tm release J2SE 5.0 introduces package java.util.concurrent, a collection of medium-level concurrency support classes created via Java Community Process (JCP) Java Specification Request (JSR) 166. Among these components are a set of synchronizers -abstract data type (ADT) classes that maintain an internal synchronization state (for example, representing whether a lock is locked or unlocked), operations to update and inspect that state, and at least one method that will cause a calling thread to block if the state requires it, resuming when some other thread changes the synchronization state to permit passage. Examples include various forms of mutual exclusion locks, read-write locks, semaphores, barriers, futures, event indicators, and handoff queues.</p><p>As is well-known (see e.g., <ref type="bibr" target="#b1">[2]</ref>) nearly any synchronizer can be used to implement nearly any other. For example, it is possible to build semaphores from re-entrant locks, and E-mail address: dl@oswego.edu. 0167-6423/$ -see front matter © 2005 Elsevier B.V. All rights reserved. doi:10.1016/j.scico.2005.03.007 vice versa. However, doing so often entails enough complexity, overhead, and inflexibility to be at best a second-rate engineering option. Further, it is conceptually unattractive. If none of these constructs are intrinsically more primitive than the others, developers should not be compelled to arbitrarily choose one of them as a basis for building others. Instead, JSR166 establishes a small framework centered on class AbstractQueuedSynchronizer, that provides common mechanics that are used by most of the provided synchronizers in the package, as well as other classes that users may define themselves.</p><p>The remainder of this paper discusses the requirements for this framework, the main ideas behind its design and implementation, sample usages, and some measurements showing its performance characteristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Requirements</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Functionality</head><p>Synchronizers possess two kinds of methods (see <ref type="bibr" target="#b6">[7]</ref>): at least one acquire operation that blocks the calling thread unless/until the synchronization state allows it to proceed, and at least one release operation that changes synchronization state in a way that may allow one or more blocked threads to unblock.</p><p>The java.util.concurrent package does not define a single unified API for synchronizers. Some are defined via common interfaces (e.g., Lock), but others contain only specialized versions. So, acquire and release operations take a range of names and forms across different classes. For example, methods Lock.lock, Semaphore.acquire, CountDownLatch.await, and FutureTask.get all map to acquire operations in the framework. However, the package does maintain consistent conventions across classes to support a range of common usage options. When meaningful, each synchronizer supports:</p><p>• Nonblocking synchronization attempts (for example, tryLock) as well as blocking versions.</p><p>• Optional timeouts, so applications can give up waiting.</p><p>• Cancellability via interruption, usually separated into one version of acquire that is cancellable, and one that is not.</p><p>Synchronizers may vary according to whether they manage only exclusive states -those in which only one thread at a time may continue past a possible blocking point -versus possible shared states in which multiple threads can at least sometimes proceed. Regular lock classes of course maintain only exclusive state, but counting semaphores, for example, may be acquired by as many threads as the count permits. To be widely useful, the framework must support both modes of operation.</p><p>The java.util.concurrent package also defines interface Condition, supporting monitor-style await/signal operations that may be associated with exclusive Lock classes, and whose implementations are intrinsically intertwined with their associated Lock classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Performance goals</head><p>Java built-in locks (accessed using synchronized methods and blocks) have long been a performance concern, and there is a sizable literature on their construction (e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>).</p><p>However, the main focus of such work has been on minimizing space overhead (because any Java object can serve as a lock) and on minimizing time overhead when used in mostly single-threaded contexts on uniprocessors. Neither of these are especially important concerns for synchronizers: Programmers construct synchronizers only when needed, so there is no need to compact space that would otherwise be wasted. And synchronizers are used almost exclusively in multithreaded designs (increasingly often on multiprocessors) under which at least occasional contention is to be expected. So the usual JVM strategy of optimizing locks primarily for the zero-contention case, leaving other cases to less predictable slow paths <ref type="bibr" target="#b13">[14]</ref> is not the right tactic for typical multithreaded server applications that rely heavily on java.util.concurrent.</p><p>Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended. Ideally, the overhead required to pass a synchronization point should be constant no matter how many threads are trying to do so. Among the main goals is to minimize the total amount of time during which some thread is permitted to pass a synchronization point but has not done so. However, this must be balanced against resource considerations, including total CPU time requirements, memory traffic, and thread scheduling overhead. For example, spinlocks usually provide shorter acquisition times than blocking locks, but usually waste cycles and generate memory contention, so are not often applicable in the contexts in which synchronizers are most typically used.</p><p>These goals carry across two general styles of use. Most applications should maximize aggregate throughput, tolerating, at best, probabilistic guarantees about lack of starvation. However in applications such as resource control, it is far more important to maintain fairness of access across threads, tolerating poor aggregate throughput. No framework can decide between these conflicting goals on behalf of users; instead different fairness policies must be accommodated.</p><p>No matter how well-crafted they are internally, synchronizers will create performance bottlenecks in some applications. Thus, the framework must make it possible to monitor and inspect basic operations to allow users to discover and alleviate bottlenecks. This minimally (and most usefully) entails providing a way to determine how many threads are blocked.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Design and implementation</head><p>The basic ideas behind a synchronizer are quite straightforward. An acquire operation proceeds as: Support for these operations requires the coordination of three basic components: (1) Atomically managing synchronization state; (2) Blocking and unblocking threads; and (3) Maintaining queues. It might be possible to create a framework that allows each of these three pieces to vary independently. However, this would neither be very efficient nor usable. For example, the information kept in queue nodes must mesh with that needed for unblocking, and the signatures of exported methods depend on the nature of synchronization state.</p><p>The central design decision in the synchronizer framework was to choose a concrete implementation of each of these three components, while still permitting a wide range of options in how they are used. This intentionally limits the range of applicability, but provides efficient enough support that there is practically never a reason not to use the framework (and instead build synchronizers from scratch) in those cases where it does apply.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Synchronization state</head><p>Class AbstractQueuedSynchronizer maintains synchronization state using only a single (32-bit) int, and exports getState, setState, and compareAndSetState operations to access and update this state. These methods in turn rely on java.util.concurrent.atomic support providing JSR133 (Java Memory Model <ref type="bibr" target="#b9">[10]</ref>) compliant volatile semantics on reads and writes, and access to native compare-and-swap or load-linked/store-conditional instructions to implement compareAndSetState, that atomically sets state to a given new value only if it holds a given expected value.</p><p>Restricting synchronization state to a 32-bit int was a pragmatic decision. While JSR166 also provides atomic operations on 64-bit long fields, these must still be emulated using internal locks on enough platforms that the resulting synchronizers would not perform well. In the future, it seems likely that a second base class, specialized for use with 64-bit state (i.e., with long control arguments), will be added. However, there is not now a compelling reason to include it in the package. Currently, 32 bits suffice for most applications. Only one java.util.concurrent synchronizer class, CyclicBarrier, would require more bits to maintain state, so instead uses locks (as do most higher-level utilities in the package).</p><p>Concrete classes based on AbstractQueuedSynchronizer must define methods tryAcquire and tryRelease in terms of these exported state methods in order to control the acquire and release operations. The tryAcquire method must return true if synchronization was acquired, and the tryRelease method must return true if the new synchronization state may allow future acquires. These methods accept a single int argument that can be used to communicate desired state; for example in a re-entrant lock, to re-establish the recursion count when re-acquiring the lock after returning from a condition wait. Many synchronizers do not need such an argument, and so just ignore it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Blocking</head><p>Until JSR166, there was no Java API available to block and unblock threads for purposes of creating synchronizers that are not based on built-in monitors. The only candidates were Thread.suspend and Thread.resume, which are unusable because they encounter an unsolvable race problem: If an unblocking thread invokes resume before the blocking thread has executed suspend, the resume operation will have no effect.</p><p>The java.util.concurrent.locks package includes a LockSupport class with methods that address this problem. Method LockSupport.park blocks the current thread unless or until a LockSupport.unpark has been issued. (Spurious wakeups are also permitted.) Calls to unpark are not counted, so multiple unparks before a park only unblock a single park. Additionally, this applies per thread, not per synchronizer. A thread invoking park on a new synchronizer might return immediately because of a leftover unpark from a previous usage. However, in the absence of an unpark, its next invocation will block. While it would be possible to explicitly clear this state, it is not worth doing so. It is more efficient to invoke park multiple times when it happens to be necessary.</p><p>This simple mechanism is similar to those used, at some level, in the Solaris-9 thread library <ref type="bibr" target="#b12">[13]</ref>, in WIN32 consumable events, and in the Linux NPTL thread library, and so maps efficiently to each of these on the most common platforms Java runs on. (However, the current Sun Hotspot JVM reference implementation on Solaris and Linux actually uses a pthread condvar in order to fit into the existing runtime design.) The park method also supports optional relative and absolute timeouts, and is integrated with JVM Thread.interrupt support -interrupting a thread unparks it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Queues</head><p>The heart of the framework is maintenance of queues of blocked threads, which are restricted here to FIFO queues. Thus, the framework does not support priority-based synchronization.</p><p>These days, there is little controversy that the most appropriate choices for synchronization queues are non-blocking data structures that do not themselves need to be constructed using lower-level locks. And of these, there are two main candidates: variants of Mellor-Crummey and Scott (MCS) locks <ref type="bibr" target="#b10">[11]</ref>, and variants of Craig, Landin, and Hagersten (CLH) locks <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b11">12]</ref>. Historically, CLH locks have been used only in spinlocks. However, they appeared more amenable than MCS for use in the synchronizer framework because they are more easily adapted to handle cancellation and timeouts, so were chosen as a basis. The resulting design is far enough removed from the original CLH structure to require explanation.</p><p>A CLH queue is not very queue-like, because its enqueuing and dequeuing operations are intimately tied to its uses as a lock (see Fig. <ref type="figure" target="#fig_0">1</ref>). It is a linked queue accessed via two atomically updatable fields, head and tail, both initially pointing to a dummy node. A new node, node, is enqueued using an atomic operation:</p><p>do { pred = tail; } while(!tail.compareAndSet(pred, node)); The release status for each node is kept in its predecessor node. So, the spin of a spinlock looks like: while (pred.status != RELEASED) ; // spin A dequeue operation after this spin simply entails setting the head field to the node that just got the lock: head = node; Among the advantages of CLH locks are that enqueuing and dequeuing are fast, lockfree, and obstruction-free (even under contention, one thread will always win an insertion race so will make progress); that detecting whether any threads are waiting is also fast (just check if head is the same as tail); and that release status is decentralized, avoiding some memory contention.</p><p>In the original versions of CLH locks, there were not even links connecting nodes. In a spinlock, the pred variable can be held as a local. However, Scott and Scherer <ref type="bibr" target="#b11">[12]</ref> showed that by explicitly maintaining predecessor fields within nodes, CLH locks can deal with timeouts and other forms of cancellation: If a node's predecessor cancels, the node can slide up to use the previous node's status field.</p><p>The main additional modification needed to use CLH queues for blocking synchronizers is to provide an efficient way for one node to locate its successor. In spinlocks, a node need only change its status, which will be noticed on next spin by its successor, so links are unnecessary. But in a blocking synchronizer, a node needs to explicitly wake up (unpark) its successor. An AbstractQueuedSynchronizer queue node contains a next link to its successor. But because there are no applicable techniques for lock-free atomic insertion of double-linked list nodes using compareAndSet, this link is not atomically set as part of insertion; it is simply assigned:</p><p>pred.next = node; after the insertion. The non-atomicity of assignment is accommodated in all usages. The next link is treated only as an optimized path. If a node's successor does not appear to exist (or appears to be cancelled) via its next field, it is always possible to start at the tail of the list and traverse backwards using the pred field to accurately check if there really is one. This is a variant of the technique used in the optimistic non-blocking queue algorithm of Ladan-Mozes and Shavit <ref type="bibr" target="#b7">[8]</ref>.</p><p>A second set of modifications is to use the status field kept in each node for purposes of controlling blocking, not spinning. In the synchronizer framework, a queued thread can only return from an acquire operation if it returns true from the tryAcquire method defined in a concrete subclass; a single released bit does not suffice. But control is still needed to ensure that an active thread is only allowed to invoke tryAcquire when it is at the head of the queue; in which case it may fail to acquire, and (re)block. This does not require a pernode status flag because permission can be determined by checking that the current node's predecessor is the head. And unlike the case of spinlocks, there is not enough memory contention reading head to warrant replication. However, cancellation status must still be present in the status field.</p><p>The queue node status field is also used to avoid needless calls to park and unpark. While these methods are relatively fast as blocking primitives go, they encounter avoidable overhead in the boundary crossing between Java and the JVM runtime and/or OS. Before invoking park, a thread sets a signal me bit, and then rechecks synchronization and node status once more before invoking park. A releasing thread clears status. This saves threads from needlessly attempting to block often enough to be worthwhile, especially for lock classes in which lost time waiting for the next eligible thread to acquire a lock accentuates other contention effects. This also avoids requiring a releasing thread to determine its successor unless the successor has set the signal bit, which in turn eliminates those cases where it must traverse multiple nodes to cope with an apparently null next field unless signalling occurs in conjunction with cancellation.</p><p>Perhaps the main difference between the variant of CLH locks used in the synchronizer framework and those employed in other languages is that garbage collection is relied on for managing storage reclamation of nodes, which avoids complexity and overhead. However, reliance on GC does still entail nulling of link fields when they are sure to never to be needed. This can normally be done when dequeuing. Otherwise, unused nodes would still be reachable, causing them to be uncollectable. Some further minor tunings, including lazy initialization of the initial dummy node required by CLH queues upon first contention, are described in the source code documentation in the J2SE release. Omitting such details, the general form of the resulting implementation of the basic acquire operation (exclusive, noninterruptible, untimed case only) is: The number of iterations of the main acquire loop depends, of course, on the nature of tryAcquire. Otherwise, in the absence of cancellation, each component of acquire and release is a constant-time O(1) operation, amortized across threads, disregarding any OS thread scheduling occurring within park.</p><formula xml:id="formula_0">if (!tryAcquire(arg)) { node =</formula><p>Cancellation support mainly entails checking for interrupt or timeout upon each return from park inside the acquire loop. A cancelled thread due to timeout or interrupt sets its node status and unparks its successor so it may reset links. With cancellation, determining predecessors and successors and resetting status may include O(n) traversals (where n is the length of the queue). Because a thread never again blocks for a cancelled operation, links and status fields tend to restabilize quickly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Condition queues</head><p>The synchronizer framework provides a ConditionObject class for use by synchronizers that maintain exclusive synchronization and conform to the Lock interface. Any number of condition objects may be attached to a lock object, providing classic monitor-style await, signal, and signalAll operations, including those with timeouts, along with some inspection and monitoring methods.</p><p>The ConditionObject class enables conditions to be efficiently integrated with other synchronization operations, again by fixing some design decisions. This class supports only Java-style monitor access rules in which condition operations are legal only when the lock owning the condition is held by the current thread (See <ref type="bibr" target="#b3">[4]</ref> for discussion of alternatives). Thus, a ConditionObject attached to a ReentrantLock acts in the same way as do built-in monitors (via Object.wait etc.), differing only in method names, extra functionality, and the fact that users can declare multiple conditions per lock.</p><p>A ConditionObject uses the same internal queue nodes as synchronizers, but maintains them on a separate condition queue. The signal operation is implemented as a queue transfer from the condition queue to the lock queue, without necessarily waking up the signalled thread before it has re-acquired its lock: await:</p><p>create and add new node to condition queue; release lock; block until node is on lock queue; re-acquire lock;</p><p>signal: transfer the first node from condition queue to lock queue;</p><p>Because these operations are performed only when the lock is held, they can use sequential linked queue operations (using a nextWaiter field in nodes) to maintain the condition queue. The transfer operation simply unlinks the first node from the condition queue, and then uses CLH insertion to attach it to the lock queue.</p><p>The main complication in implementing these operations is dealing with cancellation of condition waits due to timeouts or Thread.interrupt. A cancellation and signal occurring at approximately the same time encounter a race whose outcome conforms to the specifications for built-in monitors. As revised in JSR133, these require that if an interrupt occurs before a signal, then the await method must, after re-acquiring the lock, throw InterruptedException. But if it is interrupted after a signal, then the method must return without throwing an exception, but with its thread interrupt status set.</p><p>To maintain proper ordering, a bit in the queue node status records whether the node has been (or is in the process of being) transferred. Both the signalling code and the cancelling code try to compareAndSet this status. If a signal operation loses this race, it instead transfers the next node on the queue, if one exists. If a cancellation loses, it must abort the transfer, and then await lock re-acquisition. This latter case introduces a potentially unbounded spin. A cancelled wait cannot commence lock re-acquisition until the node has been successfully inserted on the lock queue, so must spin waiting for the CLH queue insertion compareAndSet being performed by the signalling thread to succeed. The need to spin here is rare, and employs a Thread.yield to provide a scheduling hint that some other thread, ideally the one doing the signal, should instead run. While it would be possible to implement here a helping strategy for the cancellation to insert the node, the case is much too rare to justify the added overhead that this would entail. In all other cases, the basic mechanics here and elsewhere use no spins or yields, which maintains reasonable performance on uniprocessors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">USAGE</head><p>Class AbstractQueuedSynchronizer ties together the above functionality and serves as a template method pattern <ref type="bibr" target="#b5">[6]</ref> base class for synchronizers. Subclasses define only the methods that implement the state inspections and updates that control acquire and release. However, subclasses of AbstractQueuedSynchronizer are not themselves usable as synchronizer ADTs, because the class necessarily exports the methods needed to internally control acquire and release policies, which should not be made visible to users of these classes. All java.util.concurrent synchronizer classes declare a private inner AbstractQueuedSynchronizer subclass and delegate all synchronization methods to it. This also allows public methods to be given names appropriate to the synchronizer.</p><p>For example, here is a minimal Mutex class, that uses synchronization state zero to mean unlocked, and one to mean locked. This class does not need the value arguments supported for synchronization methods, so uses zero, and otherwise ignores them.</p><p>class Mutex { class Sync extends AbstractQueuedSynchronizer { public boolean tryAcquire(int ignore) { return compareAndSetState(0, 1); } public boolean tryRelease(int ignore) { setState(0); return true; } } private final Sync sync = new Sync(); public void lock() { sync.acquire(0); } public void unlock() { sync.release(0); } } A fuller version of this example, along with other usage guidance may be found in the J2SE documentation. Many variants are of course possible. For example, tryAcquire could employ "test-and-test-and-set", i.e., checking the state value before trying to change it. It may be surprising that a construct as performance-sensitive as a mutual exclusion lock is intended to be defined using a combination of delegation and virtual methods. However, these are the sorts of OO design constructions that modern dynamic compilers have long focussed on. They tend to be good at optimizing away this overhead, at least in code in which synchronizers are invoked frequently.</p><p>Class AbstractQueuedSynchronizer also supplies a number of methods that assist synchronizer classes in policy control. For example, it includes timeout and interruptible versions of the basic acquire method. And while discussion so far has focussed on exclusive-mode synchronizers such as locks, the AbstractQueuedSynchronizer class also contains a parallel set of methods (such as acquireShared) that differ in that the tryAcquireShared and tryReleaseShared methods can inform the framework (via their return values) that further acquires may be possible, ultimately causing it to wake up multiple threads by cascading signals.</p><p>Although it is not usually sensible to serialize (persistently store or transmit) a synchronizer, these classes are often used in turn to construct other classes, such as threadsafe collections, that are commonly serialized. The AbstractQueuedSynchronizer and ConditionObject classes provide methods to serialize synchronization state, but not the underlying blocked threads or other intrinsically transient bookkeeping. Even so, most synchronizer classes merely reset synchronization state to initial values on deserialization, in keeping with the implicit policy of built-in locks of always deserializing to an unlocked state. This amounts to a no-op, but must still be explicitly supported to enable deserialization of final fields. Otherwise, since these private final fields cannot be reset during deserialization, classes using synchronizers would not be able to set their values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Controlling fairness</head><p>Even though they are based on FIFO queues, synchronizers are not necessarily fair. Notice that in the basic acquire algorithm (Section 3.3), tryAcquire checks are performed before queuing. Thus a newly acquiring (barging) thread can "steal" access that is intended for the first thread at the head of the queue (see Fig. <ref type="figure" target="#fig_1">2</ref>).</p><p>This barging FIFO strategy generally provides higher aggregate throughput than other techniques. It reduces the time during which a contended lock is available but no thread has it because the intended next thread is in the process of unblocking. At the same time, it avoids excessive, unproductive contention by only allowing one (the first) queued thread to wake up and try to acquire upon any release. Developers creating synchronizers may further accentuate barging effects in cases where synchronizers are expected to be held only briefly by defining tryAcquire to itself retry a few times before passing back control.</p><p>Barging FIFO synchronizers have only probabilistic fairness properties. An unparked thread at the head of the lock queue has an unbiased chance of winning a race with any incoming barging thread, reblocking and retrying if it loses. However, if incoming threads arrive faster than it takes an unparked thread to unblock, the first thread in the queue will only rarely win the race, so will almost always reblock, and its successors will remain blocked. With briefly held synchronizers, it is common for multiple bargings and releases to occur on multiprocessors during the time the first thread takes to unblock. As seen below, the net effect is to maintain high rates of progress of one or more threads while still at least probabilistically avoiding starvation.</p><p>When greater fairness is required, it is a relatively simple matter to arrange it. Programmers requiring strict fairness can define tryAcquire to fail (return false) if the current thread is not at the head of the queue, checking for this using method getFirstQueuedThread, one of a handful of supplied inspection methods. A faster, less strict variant is to also allow tryAcquire to succeed if the the queue is (momentarily) empty. In this case, multiple threads encountering an empty queue may race to be the first to acquire, normally without enqueuing at least one of them. This strategy is adopted in all java.util.concurrent synchronizers supporting a fair mode.</p><p>While they may be useful in practice, fairness settings have no guarantees, because the Java Language Specification does not provide scheduling guarantees. For example, even with a strictly fair synchronizer, a JVM could decide to run a set of threads purely sequentially if they never otherwise need to block waiting for each other. In practice, on a uniprocessor, such threads are likely to each run for a time quantum before being preemptively context-switched. If such a thread is holding an exclusive lock, it will soon be momentarily switched back, only to release the lock and block now that it is known that another thread needs the lock, thus further increasing the periods during which a synchronizer is available but not acquired. Synchronizer fairness settings tend to have even greater impact on multiprocessors, which generate more interleavings, and hence more opportunities for one thread to discover that a lock is needed by another thread.</p><p>Even though they may perform poorly under high contention when protecting briefly held code bodies, fair locks work well, for example, when they protect relatively long code bodies and/or with relatively long inter-lock intervals, in which case barging provides little performance advantage but greater variability and risk of indefinite postponement. The synchronizer framework leaves such engineering decisions to its users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Synchronizers</head><p>Here are sketches of how java.util.concurrent synchronizer classes are defined using this framework:</p><p>The ReentrantLock class uses synchronization state to hold the (recursive) lock count. When a lock is acquired, it also records the identity of the current thread to check recursions and detect illegal state exceptions when the wrong thread tries to unlock. The class also uses the provided ConditionObject, and exports other monitoring and inspection methods. The class supports an optional fair mode by internally declaring two different AbstractQueuedSynchronizer subclasses (the fair one disabling barging) and setting each ReentrantLock instance to use the appropriate one upon construction.</p><p>The ReentrantReadWriteLock class uses 16 bits of the synchronization state to hold the write lock count, and the remaining 16 bits to hold the read lock count. The WriteLock is otherwise structured in the same way as ReentrantLock. The ReadLock uses the acquireShared methods to enable multiple readers.</p><p>The Semaphore class (a counting semaphore) uses the synchronization state to hold the current count. It defines acquireShared to decrement the count or block if nonpositive, and tryRelease to increment the count, possibly unblocking threads if it is now positive.</p><p>The CountDownLatch class uses the synchronization state to represent the count. All acquires pass when it reaches zero.</p><p>The FutureTask class uses the synchronization state to represent the run-state of a future (initial, running, cancelled, done). Setting or cancelling a future invokes release, unblocking threads waiting for its computed value via acquire.</p><p>The SynchronousQueue class (a CSP-style handoff) uses internal wait-nodes that match up producers and consumers. It uses the synchronization state to allow a producer to proceed when a consumer takes the item, and vice versa.</p><p>Users of the java.util.concurrent package may of course define their own synchronizers for custom applications. For example, among those that were considered but not adopted in the package are classes providing the semantics of various flavors of WIN32 events, binary latches, centrally managed locks, and tree-based barriers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Performance</head><p>While the synchronizer framework supports many other styles of synchronization in addition to mutual exclusion locks, lock performance is simplest to measure and compare. Even so, there are many different approaches to measurement. The experiments here are designed to reveal overhead and throughput.</p><p>In each test, each thread repeatedly updates a pseudo-random number computed using a simple linear congruential generator function. On each iteration a thread updates, with probability S, a shared generator under a mutual exclusion lock, else it updates its own local generator, without a lock. This results in short-duration locked regions, minimizing extraneous effects when threads are pre-empted while holding locks. The randomness of the function serves two purposes: it is used in deciding whether to lock or not (it is a good enough generator for current purposes), and also makes code within loops impossible to trivially optimize away.</p><p>Four kinds of locks were compared: Builtin, using synchronized blocks; Mutex, using a simple Mutex class like that illustrated in Section 4; Reentrant, using ReentrantLock; and Fair, using ReentrantLock set in its fair mode. All tests used build 46 (which has the same overall performance as final release) of the Sun J2SE 5.0 JDK in server mode. Test programs performed 20 uncontended runs before collecting measurements, to eliminate warm-up effects. Tests ran for ten million iterations per thread, except that Fair mode tests were run only one million iterations.</p><p>Tests were performed on four x86-based machines and four UltraSparc-based machines: 1P (1 × 900 MHz Pentium 3), 2P (2 × 1400 MHz Pentium 3), 2A (2 × 2000 MHz Athlon), 4P (2 × 2400 MHz hyperthreaded Xeon), 1U (1 × 650 MHz Ultrasparc2), 4U (4 × 450 MHz Ultrasparc2), 8U (8 × 750 MHz Ultrasparc3) and 24U (24 × 750 MHz Ultrasparc3). All x86 machines were running Linux using a RedHat NPTL-based 2.4 kernel and libraries. All Ultrasparc machines were running Solaris-9. All systems were at most lightly loaded while testing. The nature of the tests did not demand that they be otherwise completely idle. The 4P name reflects the fact a dual hyperthreaded (HT) Xeon acts more like a four-way than a two-way machine. No attempt was made to normalize across the differences here. As seen below, the relative costs of synchronization do not bear a simple relationship to numbers of processors, their types, or speeds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Overhead</head><p>Uncontended overhead was measured by running only one thread, subtracting the time per iteration taken with a version setting S = 0 (zero probability of accessing shared random) from a run with S = 1. The left side of Table <ref type="table" target="#tab_2">1</ref> displays these estimates of the per-lock overhead of synchronized code over unsynchronized code, in nanoseconds. The Mutex class comes closest to testing the basic cost of the framework. The additional overhead for Reentrant locks indicates the cost of recording the current owner thread and of error-checking, and for Fair locks the additional cost of first checking whether the queue is empty.</p><p>Table <ref type="table" target="#tab_2">1</ref> also shows the cost of tryAcquire versus the fast path of a built-in lock. Neither is faster than the other on all platforms. Differences here mostly reflect the costs of using different atomic instructions and memory barriers across locks and machines. On multiprocessors, these instructions tend to completely overwhelm all others. The main differences between Builtin and synchronizer classes are apparently due to Hotspot locks using a compareAndSet for both locking and unlocking, while these synchronizers use a compareAndSet for acquire and a volatile write (i.e., with a memory barrier on multiprocessors, and reordering constraints on all processors) on release. The absolute and relative costs of each vary across machines.</p><p>At the other extreme, the right hand side of Table <ref type="table" target="#tab_2">1</ref> shows per-lock overheads with S = 1 and running 256 concurrent threads, creating massive lock contention. Under complete saturation, barging-FIFO locks have about an order of magnitude less overhead (and equivalently greater throughput) than Builtin locks, and often two orders of magnitude less than Fair locks. This demonstrates the effectiveness of the barging-FIFO policy in maintaining thread progress even under extreme contention.</p><p>Table <ref type="table" target="#tab_2">1</ref> also illustrates that even with low internal overhead, context switching time completely determines performance for Fair locks. The listed times are roughly proportional to those for blocking and unblocking threads on the various platforms. A follow-up experiment shows that with the very briefly held locks used here, fairness settings had only a small impact on overall variance. Differences in termination times of threads were recorded as a coarse-grained measure of variability. Times on machine 4P (which are representative of other machines as well) had standard deviation of 0.7% of mean for Fair, and 6.0% for Reentrant. As a contrast, to simulate long-held locks, a version of the test was run in which each thread computed 16K random numbers while holding each lock. Here, total run times were nearly identical (9.79 s for Fair, 9.72 s for Reentrant). Fair mode variability remained small, with standard deviation of 0.1% of mean, while Reentrant rose to 29.5% of mean, indicating the effect of waiting threads repeatedly losing races to barging threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Throughput</head><p>Usage of most synchronizers will range between the extremes of no contention and saturation. This can be experimentally examined along two dimensions, by altering the contention probability of a fixed set of threads, and/or by adding more threads to a set with a fixed contention probability. To illustrate these effects, tests were run with different contention probabilities and numbers of threads, all using Reentrant locks. Results are expressed using a slowdown metric representing the ratio of ideal to observed execution times:</p><formula xml:id="formula_1">slowdown = t S • b • n + (1 − S) • b • max(1, n p )</formula><p>.</p><p>Here, t is the total observed execution time, b is the baseline time for one thread with no contention or synchronization, and n is the number of threads, p is the number of processors. S remains the proportion of shared accesses; thus S • b • n represents the time the benchmark spends in inherently sequential code. The resulting metric is the ratio of observed time to a conservative approximation of ideal execution time, computed using Amdahl's law for a mix of sequential and parallel tasks. This time models an execution in which, without any synchronization overhead, no CPU blocks due to conflicts with any other. However it ignores some rescheduling opportunities and conservatively assumes that sequential processing blocks CPUs, not just threads. Under low contention, a few test results displayed very small speedups compared to this approximation of ideal time.</p><p>Figs. 3 and 4 use a base 2 log scale. For example, a value of 1.0 means that a measured time was twice as long as ideally possible, and a value of 4.0 means 16 times slower. The base computation (i.e., to compute random numbers) takes different times on different platforms, so to focus on trends and not be distracted by fixed overheads, a log-log scale is used. Results with different base computations should show similar trends. The tests used contention probabilities from 1/128 (labelled as 0.008) to 1, stepping in powers of 2, and numbers of threads from 1 to 1024, stepping in half-powers of 2. On uniprocessors (1P and 1U) performance degrades with increasing contention, but generally not with increasing numbers of threads. Multiprocessors generally encounter much worse slowdowns under contention. The graphs for multiprocessors show an early peak in which contention involving only a few threads usually produces the worst relative performance. This reflects a transitional region of performance, in which barging and signalled threads are about equally likely to obtain locks, thus frequently forcing each other to block. In most cases, this is followed by a smoother region, as the locks are almost never available, causing access to resemble the near-sequential pattern of uniprocessors; approaching this sooner on machines with more processors.</p><p>On the basis of these results, it appears likely that further tuning of blocking (park/unpark) support to reduce context switching and related overhead could provide small but noticeable improvements in this framework. Additionally, it may pay off for synchronizer classes to employ some form of adaptive spinning for briefly held highly contended locks on multiprocessors, to avoid some of the flailing seen here. While adaptive spins tend to be very difficult to make work well across different contexts, it is possible to build custom forms of locks using this framework, targeted for specific applications that encounter these kinds of usage profiles. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>As of this writing, the java.util.concurrent synchronizer framework is too new to evaluate in practice. There will surely be unexpected consequences of its design, API, implementation, and performance. However, at this point, the framework appears successful in meeting the goals of providing an efficient basis for creating new synchronizers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. CLH queue nodes.</figDesc><graphic url="image-4.png" coords="6,189.24,106.75,182.70,82.79" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Barging.</figDesc><graphic url="image-5.png" coords="10,195.72,106.93,169.19,53.57" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Relative throughput on x86.</figDesc><graphic url="image-6.png" coords="15,89.88,106.79,349.50,287.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Relative throughput on Sparc.</figDesc><graphic url="image-7.png" coords="16,105.72,106.05,349.50,304.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell cols="3">Lock times in nanoseconds</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">Uncontended</cell><cell></cell><cell></cell><cell cols="2">Saturated</cell><cell></cell></row><row><cell cols="2">Name builtin</cell><cell>mutex</cell><cell>reentr</cell><cell>fair</cell><cell>builtin</cell><cell>mutex</cell><cell>reentr</cell><cell>fair</cell></row><row><cell>1P</cell><cell>18</cell><cell>9</cell><cell>31</cell><cell>37</cell><cell>521</cell><cell>46</cell><cell>67</cell><cell>8327</cell></row><row><cell>2P</cell><cell>58</cell><cell>71</cell><cell>77</cell><cell>81</cell><cell>930</cell><cell>108</cell><cell>132</cell><cell>14967</cell></row><row><cell>2A</cell><cell>13</cell><cell>21</cell><cell>31</cell><cell>30</cell><cell>748</cell><cell>79</cell><cell>84</cell><cell>33910</cell></row><row><cell>4P</cell><cell>116</cell><cell>95</cell><cell>109</cell><cell>117</cell><cell>1146</cell><cell>188</cell><cell>247</cell><cell>15328</cell></row><row><cell>1U</cell><cell>90</cell><cell>40</cell><cell>58</cell><cell>67</cell><cell>879</cell><cell>153</cell><cell>177</cell><cell>41394</cell></row><row><cell>4U</cell><cell>122</cell><cell>82</cell><cell>100</cell><cell>115</cell><cell>2590</cell><cell>347</cell><cell>368</cell><cell>30004</cell></row><row><cell>8U</cell><cell>160</cell><cell>83</cell><cell>103</cell><cell>123</cell><cell>1274</cell><cell>157</cell><cell>174</cell><cell>31084</cell></row><row><cell>24U</cell><cell>161</cell><cell>84</cell><cell>108</cell><cell>119</cell><cell>1983</cell><cell>160</cell><cell>182</cell><cell>32291</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Thanks to Dave Dice for countless ideas and advice during the development of this framework, to Mark Moir and Michael Scott for urging consideration of CLH queues, to David Holmes for critiquing early versions of the code and API, to Victor Luchangco and Bill Scherer for reviewing previous incarnations of the source code, and to the other members of the JSR166 Expert Group (Joe Bowbeer, Josh Bloch, Brian Goetz, David Holmes, and Tim Peierls) as well as Bill Pugh, for helping with design and specifications and commenting on drafts of this paper. Portions of this work were made possible by a DARPA PCES grant, NSF grant EIA-0080206 (for access to the 24-way Sparc) and a Sun Collaborative Research Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">An efficient meta-lock for implementing ubiquitous synchronization</title>
		<author>
			<persName><forename type="first">O</forename><surname>Agesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Garthwaite</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Knippel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">S</forename><surname>Ramakrishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>White</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>ACM OOPSLA Proceedings</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Andrews</surname></persName>
		</author>
		<title level="m">Concurrent Programming</title>
				<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Thin locks: Featherweight synchronization for Java</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bacon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM PLDI Proceedings</title>
				<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Monitor classification</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buhr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fortier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Coffin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Building FIFO and priority-queueing spin locks from atomic swap</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Craig</surname></persName>
		</author>
		<idno>TR 93-02- 02</idno>
		<imprint>
			<date type="published" when="1993-02">February 1993</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Washington</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<title level="m">Design Patterns</title>
				<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Holmes</surname></persName>
		</author>
		<title level="m">Synchronisation rings</title>
				<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Macquarie University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An optimistic approach to lock-free FIFO queues</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ladan-Mozes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shavit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th Annual Conference on Distributed Computing, DISC 2004</title>
				<meeting>the 18th Annual Conference on Distributed Computing, DISC 2004<address><addrLine>Amsterdam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-10">October 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Queue locks on cache coherent multiprocessors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Magnussen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Landin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hagersten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th Intl. Parallel Processing Symposium</title>
				<meeting><address><addrLine>Cancun, Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-04">April 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Java memory model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Manson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Programming Languages</title>
				<meeting><address><addrLine>Long Beach CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-01">January 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Algorithms for scalable synchronization on shared memory multiprocessors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<date type="published" when="1991-02">February. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable queue-based spin locks with timeout</title>
		<author>
			<persName><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th ACM Symp. on Principles and Practice of Parallel Programming</title>
				<meeting><address><addrLine>Snowbird, UT</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Multithreading in the solaris operating environment</title>
		<ptr target="http://wwws.sun.com/software/solaris/whitepapers.html" />
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>Sun Microsystems</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Monitor conversion in a multithreaded computer system, United States Patent 6</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bak</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">691</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
