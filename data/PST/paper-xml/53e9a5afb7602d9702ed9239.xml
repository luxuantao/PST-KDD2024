<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algebraic approach to singlepushout graph transformation*</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<title level="a" type="main">Algebraic approach to singlepushout graph transformation*</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FCAD1A022F2360398F255CC55E7ED20A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Liiwc. M., Algebraic approach to single-pushout graph transformation, Theoretical Computer Science 109 (1993) 181-224. The single-pushout approach to graph transformation interprets a double-pushout transformation rule of the classical algebraic approach which consists of two rotul graph morphisms as a single particll morphism from the left-to the right-hand side. The notion of a double-pushout diagram for the transformation process can then be substituted by a single-pushout diagram in an appropriate category of partial morphisms.</p><p>It can be shown that this kind of transformation generalizes the double-pushout framework. Hence. the classical approach can be seen as a special (and very important) case of the new concept. It can be reobtained from the single-pushout approach by imposing an application condition on the redices which formulates the gluing conditions in the new setting. On the other hand, singlepushout transformations are always possible even if the gluing conditions for the redex are violated. The simpler structure of a direct transformation (one pushout diagram instead of two) simplifies many proofs. Hence, the whole theory for double-pushout transformations including sequential composition, parallel composition, and amalgamation can be reformulated and generalized in the new framework. Some constructions provide new effects and properties which are discussed in detail.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Graph grammars provide an intuitive description for the manipulation of complex graph-like structures as they occur in databases, operating systems, and complex applicative software. Besides that all approaches to graph transformation systems offer theoretical results which help in the analysis of such systems. Especially the algebraic approach [S, 9, 121 has been worked out for several years now and provides results for parallelism analysis <ref type="bibr" target="#b14">[25,</ref><ref type="bibr">271</ref>, efficient evaluation of the rule is applicable. K, in most cases a subgraph of L and R, describes the part of the left-hand side which is going to be preserved by rule application. Thus, L-K is the part which a rule application is going to delete and R-K is added. Here, the intermediate graph K gets a second role: It describes the context into which added components are going to be integrated. (K is called "gluing graph".) A rule is applicable to a graph G if G contains a homomorphic image of L. The application of a rule (L, K, R) deletes all items in G which correspond to objects in L-K in the first step. It results in the so-called context graph D. Second, it adds all items in R -K to D. The connection between "new" items in R-K and "old" objects in D is described by the relation of the "new" items in R-K to objects in K. Thus, application of a rule r = (L, K, R) to a graph G consists of four steps: (1) Try to find L in G. If there are some images of L in G choose one and continue. Otherwise, r is not applicable to G. [In some approaches, the matching phase includes the check of additional application conditions (see below).] (2) Remove the part of G which corresponds to L-K.</p><p>(3) Alld R-K to the result of the last step. (4) Embed R-K into G-(L-K) as it is given by the corresponding relation between R-K and K. This series of four steps seems to be common to all approaches to graph transformation; cf. 1261.' The algebraic approach to graph transformation (cf. Appendix A for basic notions) summarizes these four steps in a single categorical construction of a double-pushout diagram which facilitates many proofs that would be very hard to obtain on the more concrete, operational level: A rule is a pair (/ : K + L, Y : K -+ R) of total graph morphisms and a direct transformation with the rule (1: K+L, r: K-R) from a graph G to a graph H is possible if there is a context graph D together with a gluing morphism k : K +D such that G is the pushout of I and k and the graph H is the pushout of r and k (for more details compare Appendix A). With these definitions, all operational effects of a direct transformation are encapsulated in a single categorical colimit construction and, therefore, all universal properties known for this construction within category theory are inherited [l, 211. Thus, many proofs do not bother about operational details but only rely on abstract arguments about colimits. Since all results about algebraic graph transformation require the rules' left-hand sides to be injective,2 the rule concept can be simplified when the pair I However, there are individual differences in each phase and the formulation of the embedding area by a subgraph K of L and R is an idealization.</p><p>'With noninjective left-hand sides, the context graph in a transformation from G to H need not be unique.</p><p>(I: K-+L, r: K +R) of total morphisms is seen as a partial morphism (r' : L-+R) which is defined on I(K) only and coincides with r on its domain. Now the concept of direct transformation reduces to a single-pushout construction: G transforms to H using the rule (r': L-R) if there is a total matching morphism (or redex) nz: L+G such that H is the pushout of r' and ??I (here in the category of graphs and partial morphisms). It is this single-pushout concept which is comprehensively elaborated below. It turns out to be more general than the double-pushout framework and that all corresponding proofs are less complex due to the simpler underlying notion of direct transformation. Single-pushout transformations in a setting of some sort of partial morphisms have been investigated in <ref type="bibr" target="#b26">[36,</ref><ref type="bibr">231</ref>. Raoult <ref type="bibr" target="#b26">[36]</ref> introduces two conceptually very different approaches. The first one is described in the category of sets and partial mappings. A rule is a partial morphism r : L-tR, i.e. a partial map which respects the graph structure3 on all objects of L it is defined for.4 A redex 111: L+G in some graph G is a total morphism of this type. The result of applying r at VI is constructed by two steps. First, the pushout (H, r,,, : G-+H, m,: R+H) of r and m in the category of sets and partial maps is built. In the second step, a graph structure is established on H such that the pushout mappings r, and m, become morphisms.</p><p>He characterizes the situations in which this graph structure uniquely exists; double-pushout transformations with their application conditions (cf. Appendix A) are special cases of these situations.</p><p>The second model of graph transformation in <ref type="bibr" target="#b26">[36]</ref> uses another kind of partiality for the morphisms: a rule is a total map r: L +R, which is only partially compatible with the graph structure.</p><p>Let rewrite(r) denote the set of objects which are not homomorphically mapped by r. A redex m: L+G is total which means now rewrite(m)=@ Application of r at m is again defined by two steps. First construct the pushout (H, r,: G+H, m,:R-+H) of r and m in the category of sets and total mappings and second impose a graph structure on H such that the pushout mappings become as compatible as possible, i.e. such that rewrite(r,)=m(rewrite(r)) and rewrite(m,)=r(rewrite(nz)).</p><p>Raoult <ref type="bibr" target="#b26">[36]</ref> gives sufficient conditions for the unique existence of this structure. This approach has the major disadvantage that objects cannot be deleted at all (compare the intuitive graph transformation model above). <ref type="bibr">Kennaway [23]</ref> provides a categorical description for the second approach of <ref type="bibr" target="#b26">[36]</ref>. Graphs are represented the same way. The idea which is elaborated below is to resume the first approach in <ref type="bibr" target="#b26">[36]</ref>. His concept of partial mappings which are compatible with the graph structure on their domain can be generalized to a concept of partial homomorphisms on special categories of algebras such that pushout construction in these categories is always possible. Hence, we get rid of any application conditions. If, however, the necessary and sufficient conditions of <ref type="bibr" target="#b26">[36]</ref> are satisfied, the construction of pushout objects coincides with his two-step construction.5</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Recently, Kennaway</head><p>[24] independently started to study graph transformation in some categories of partial morphisms of this type. His work is based on the categorical formulation of a partial morphism provided by <ref type="bibr" target="#b27">[37]</ref>. While we consider concrete algebraic categories, 1241 stays in a purely categorical framework. Future research has to show how both approaches can benefit from each other.</p><p>Van den Broek [S] introduces another kind of single-pushout transformations based on "partial" morphisms.</p><p>Partiality in this framework is described by total morphisms which map objects "outside their domain" to marked objects in their codomain.(' Single pushout transformations with this type of morphisms corresponds to transformations in junkor sink-completed structures described in Appendix B. The article is organized as follows.' Section 2 provides the algebraic foundations for colimit constructions with partial morphisms. Especially we characterize the class of algebraic structures which has all finite colimits, so-called yraph struc'tures. Section 3 models graphs, hypergraphs, and other similar structures as graph structures and introduces the single-pushout transformation concept for all of these objects. It is shown that the single-pushout approach generalizes the double-pushout framework.</p><p>A running example demonstrates the expressive power of the new concept. Sections 4, 5, and 6 are devoted to sequential composition, parallel composition, and amalgamation of single-pushout rules and transformations, respectively. They provide a comprehensive theory of rule composition. All properties that differ from the double-pushout case are discussed. The conclusion (Section 7) addresses some issues of further research.</p><p>'Actually, the whole theory presented in the following has been very much motivated and stimulated by the pushout constructions in the category of sets and partial mappings the author learned about by 1361. In this paper. these constructions arc generalized to the level of algebras and partial homomorphisms. 'Marked objects indicate deleted or garbage Items. 'The results presented in the following have been presented in <ref type="bibr">[IS]</ref> for the first time. The basic ideas of the single-pushout approach used here have been published in 1301. All Sig-algebras and all partial Sig-homomorphisms~form</p><p>(1 category AlgP(Sig).</p><p>Proof. The compositionf'= q of two homomorphisms g: A+B andf: B-+C is given by the componentwise composition of the underlying partial mappings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Its scope is A , y =y-' (Bfng(A,)).</head><p>It is a subalgebra of A since B, and A, are subalgebras of B and A, respectively and g(A,) and B,ng <ref type="bibr">(A,)</ref> are subalgebras of B. That fog is homomorphic on its scope is implied by the fact that (f'o g)iAl s =,fi~, 0 glAf 9 which are total Sig-homomorphisms."</p><p>Composition of partial mappings is associative. The identities idA : A+ A for each algebra A in AlgP(Sig) are provided by the corresponding total identity homomorphisms of Alg(Sig)." They satisfy for all partial homomorphisms g : A-+ B and ,f: B-t A, idA cjf=,f and g 0 idA = g. 0</p><p>Note that this definition of partial Sig-homomorphisms coincides with the usual category-theoretic definition in terms of subobjects and pullbacks as it can be found e.g. in <ref type="bibr" target="#b27">[37]</ref>.   for sfcs, and opTwO(xl,...,x,)=* for all operators op:sI ,..., s,+s,,+lEOP;</p><p>(3) y: Two-t Tric is the unique total homomorphism from Two to Triv; and (4) f: Two-t Tric is undefined for a and ,f'( *) = * otherwise. If there was an algebra X and partial homomorphisms&amp; : Triu-+X and gs: Triv-+X such that gs ~.f=f, t&gt; g, firstly X,,#@ because it must contain cx and secondlyf,(*)= ,fg(cTri~~)=CX=gf(C~ri~~ )=gs(*) due to.6 and gr being homomomorphic. This implies f, 0 g(a)= cx. On the other hand, gJ c~f is undefined for a since f is. The arguments above lead to a contradiction to the assumption that there is a completion of Diagram 1 making it commute. Hence, there is no X, ,f,: Triv-tX, and gf: Triu-+X with gf of=&amp; c g which implies that there is no pushout object for f and g.</p><p>Second, suppose Sig =(S, OP) contains no constants and at least one operator symbol f:fsl,...,fsn-tfs,+l with n&gt;2.</p><p>We construct a situation, depicted in Diagram 2, which cannot have a pushout completion. The participating algebras and homomorphisms are defined by: (1) Triv is again the terminal algebra having Trin, = {*} for all SES; I3 Trir is the terminal object in Alg(Sig).</p><p>(2) since there are no constants, the empty algebra Empty is in AlgP(Sig): Empty,=@ for all SES and opEmptY=@ for all op~0P;'~</p><p>(3) Three is constructed as follows: for all SES, (4) i: Triti+Three is the inclusion of Triv in Three; (5) 8 : Triu-t Empty denotes the empty, everywhere undefined homomorphism.</p><p>The absence of constants guarantees that Three is well-defined.15 If all carriers of Three are restricted to {a) or to (b], we obtain two subalgebras</p><p>Triu-one and Triu-two and two partial homomorphisms ,fi : Three+ Trio-one and ,fi : Three-r Triv-two such that the scopes are given by ThreefI = Tric-one and Threes2= Triv-two, respectively, and,f, and,/; are the identities on their scopes. Obviously, there are the unique partial homomorphisms 8 : Empty + Trio-one and 0 : EmptJ'+ Trio-two such that (1) and (2) in Diagram 3 commute. Now assume the existence of pushouts and let (X, io: Empty-+X, @i : Three-+X) be the pushout of 0 and i. Note that ie=8 since it is the only partial homomorphism from Empty' into some other algebra. Since (1) and (2) in Diagram 3 commute, there must be u1 :X-+Trbo~e and u,:X-+Triz~-two such that (i) u1 c&amp;=f; and (ii) u20&amp;=fz. (i) requires that the element a in each carrier of Three is contained in Three@, and (ii) requires that the element h in each carrier of Three is an element of Threefit. Since the scope of &amp;, i.e. Three@,, must be a subalgebra of Three (cf. Definition 2.1), ,fThrfp( u, h, a,</p><p>, u) = * E TI Ireegl. This results in 8, oi(*) to be defined on the carriers for sort fs,, I while io ) 0 = 0 T @ = 0 is undefined everywhere. Hence, io d 0 # 8, c i which is a contradiction to the assumption that (X, io : Empty+X, &amp; : Three-+X) is the pushout object. Due to the fact that the contradiction occurs for each choice of possible pushout objects, there cannot be any. 0</p><p>The negative result of Proposition 2.3 motivates the following definition. We distinguish signatures which contain monadic operator symbols only. The theory presented in the following is the theory of these so-called graph structures. I5 Note that op 7 h"""(.x,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Triv LL-Empty Triv"-Empty</head><p>. x,,) provides * if some arguments are a and some arguments are h.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.4 (Graph S~YUC~UWS).</head><p>A signature is a graph structure if it contains unary operator symbols only.</p><p>All terms w.r.t. a graph structure have a very special form:</p><p>(1) there are no ground terms due to the absence of constants;</p><p>(2) each term contains exactly one variable due to the absence of operators with more than one argument. Thus, all terms represent derived unary operators. They can be sorted w.r.t. their value sort and the sort of the unique variable in them. Hence, we write T:$$ for the following set of terms {tltETs,s.s,( (x)), x~X,j.</p><p>If t~T"z,', XEX, is the variable in t, A is a Sig-algebra, and UEA,, we write Y'(U) for the evaluation oft in A using the variable assignment x k+ a.   Due to Construction 2.6, the scope of&amp; 2 g is f D g which is also the scope of gf sf)</p><p>and by the identification of f(z) and g(z) for each z~f V g in the third and fourth step of the construction, f, 0 g = gf 2.f: Hence, (1) holds.</p><p>In order to prove (2), suppose that there exist With the third and fourth step of the construction,f,(x)=f,(y) implies that there sequence z1, f..) z,,Ef V g with n = 2m+ 1 for some rnEN such that g(zI)=x, g(z,)=y, f tz2i-l)=f( ~2, , '1 and g(z,i)=g(Zzi+l) for i= 1, . , m. Thus, if XECJ,, g(Zi)EC,'</p><p>for i= 1, . . . , n since ,f' 0 g = g' of: Hence, YEC~ I and .f'(x) =f'(y). Similarly, gs(x)=gs(y) and XEB,, implies YEI?,, and g'(x)=g'(y). With these preliminaries, The morphism u is well-defined since x=gs(yl), x=gs(y2) and yr~B,, implies y,eB,, and g'(yl)=g'(y2) by the remarks above. Similarly, x=f,(yr), x=,fg(y2), and yl~CS, implies y2~CSZ andf'(yI)=f'(y,).</p><p>Furthermore, x=gs(y), MEL?,,, x=fy(z), and ZEC,(, implies that there exists ac.f V g such that .f(a)= y and f, 0 g(a)=x.</p><p>Hence, by g' of=f' 1 g, g'(y) 'f'(z).</p><p>Since B,, is closed w.r.t. the equivalence induced by gf on B and, vice versa, C, is closed w.r.t. the equivalence induced by f, on C, u 0 gs = g' and u of,=f' by definition of IL Uniqueness of u follows from the observation that each morphism v : D-+E with L' 0 gs = g' and v of, =f' requires the same definition on objects as u. 0 Construction 2.6 has some properties which are used intensively in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 2.8 (Pushout properties). If (D, gf : B+D, f, : C+D) is the pushout object of f: A-+B and g: A+C in some category AlgP(Sig) of graph structures,</head><p>(1) f, und gs are jointly sut-jective.ls (2) ker(&amp;)cg(ker(f))</p><p>and ker(g/)sf (ker(g)).'" (4) f, and gf are total if g and f are total. (Thus, each pushout in the category of total homomorphisms is also a pushout in the category of partial homomorphisms.)</p><formula xml:id="formula_0">(3) f,(gf) is injective iff (g) is injective." I8 A partial homomorphismf: A+B is surjective if,f(A)= B.</formula><p>(5) gs is total if und only if (1) A, 5 A, and (2) g(x) = g( y) implies either x, YEA, or</p><p>x, &amp;A,.</p><p>Proof.</p><p>(1) and ( <ref type="formula" target="#formula_1">2</ref> Proof. Let Sig =(S, OP) and define @sis by &amp;,a,., =@ for all SES and oposig =@ for all op~0P.</p><p>The so-defined empty Sig-algebra is both initial and final in AlgP(Sig). For initiality, we need a unique partial homomorphism ,f: fl~,~--+A for each A EAlgP(Sig). There is exactly one, i.e.f= 8. Conversely, there is exactly one partial homomorphism, namely 8: A--+&amp;+, for each AEAlgP(Sig). U</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 2.10 (Co-completeness).</head><p>AlgP(Sig) is$nitely co-complete if and only ifSig is a graph structure.</p><p>Proof. Direct consequence of Propositions 2.3 and 2.9, Theorem 2.7, and the fact that categories which have all pushouts and an initial object are finitely co-complete; cf. <ref type="bibr" target="#b10">[21]</ref>. q</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Single-pushout transformations</head><p>This section introduces the basic notions for single-pushout transformations on arbitrary graph structures. We first show (in Section 3.1) that all graph-like structures like graphs, labeled graphs, and hypergraphs and many more complex objects can be seen as algebras w.r.t. a suitable graph structure. Section 3.2 introduces the fundamental notions rule, redex, direct transformation, transformation, and language.</p><p>Section 3.3 is dedicated to the comparison of single-and double-pushout transformations on labeled graphs. It turns out that single-pushout transformations generalize the classical framework since no application condition is required for redices of single-pushout rules. The effects which rule application at these unrestricted redices can produce are investigated by a small database example in Section 3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Sample graph structures</head><p>Graph structures are special signatures with the property that the associated category of algebras and partial homomorphisms is finitely co-complete (cf. Section 2).</p><p>For single-pushout constructions in these categories to provide a reasonable transformation concept, it is to show that objects like graphs or hypergraphs can be seen as graph structures. This is done by presenting the suitable signatures. The family of edges (E,)I,L and the corresponding family of operators can be infinite if L is. The theory of Section 2, however, is also applicable to these infinite structures since all operators are monadic.</p><p>Note that the Edge-Labeled-Graph-homomorphisms are label-preserving. The structure of the operator symbols must be so complex since the associated homomorphisms shall preserve the labels of the graph elements. Hence, every edge is not only distinguished by its own label but also by the labels of its source and target vertex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 3.4 (Unlabeled hypergruphs).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hypergraphs</head><p>allow their edges to be connected to more than one source and more than one target. Therefore, the set of hyperedges H = W,. A. ,nE pi ", is a family of edge sets and each hEH,,, has n sources and m targets. The aim is to provide a method for rulebased software design. If signatures, i.e. Sig = (S, OP = (OP,,, Jwes*. ,,s), are considered as a special type of hypergraphs (see below), single-pushout transformations can also be applied to these structures. The implementation of algebraic graph transformation currently being developed at the Technical University of Berlin uses so-called ALR-graphs as the fundamental data structure [2]. ALR-graphs not only allow to represent arbitrary labeled graphs but also morphisms between graphs. Since morphisms map vertices to vertices and edges to edges, they are represented by pairs of vertex assignments and edge assignments. <ref type="bibr" target="#b11">22</ref> In order to keep track of which assignment belongs to which morphism, an abstraction operator is introduced in ALR-graphs which allows to group vertices and edges into graphs and vertex and edge assignments into morphisms. Thus, ALR-graphs as algebras w.r. Although these conditions are equations in most cases, the graph transformation approach with partial morphisms cannot be adapted to the full subcategory of all ALR-graphs which satisfy the requirements. This is due to the fact that every nontrivial generated congruencez3 on objects cannot be extended to a free construction in the context of partial morphisms. Thus, the intuitive consistence requirements above can only be used as correctness criteria for transformations performed in AlgP(ALR-Graph). Application of graph transformation rules in such a system means building of some pushout squares of appropriate morphisms. This is due to the fact that the data structure of ALR-graphs allows to represent all features of algebraic graph transformation, i.e. graphs, morphisms, and redices.</p><p>On the other hand, ALR-graphs are graph structures themselves. Thus, the implementation of graph transformation on the basis of ALR-graphs can be seen as a graph transformation system manipulating graph transformation systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Basic notions</head><p>Section 3.1 has presented a variety of graph-like structures as graph structures. Hence, it is worthwhile to formulate the single-pushout transformation concept for arbitrary graph structures.</p><p>General assumption 3.8. In the following definitions and propositions, it is assumed that all objects and homomorphisms are taken from a fixed category AlgP(Sig) for some graph structure Sig. which is also called direct transformation morphism below. We distinguish the following types of redices. Redices with these additional features will turn out to impose special properties on direct transformations which make the whole transformation process more transparent. But also from the intuitive point of view, these application conditions are natural. If we reconsider the basic ideas about graph transformation of Section 1 in this framework of graph structures and partial morphisms, we can again single out three components of a rule: the part meant to be deleted, i.e. L-L,., the subobject of L which shall be preserved, i.e. L,, and the added structure R-r(L)</p><p>(forget about identification of r for the moment). With these interpretations, conflict-freeness of a redex guarantees that an element of G is either meant to be preserved or meant to be deleted. The general concept of redices allows conflicts in this respect and the transformation process has to solve the conflict by defining deletion or preservation to be dominant (compare Section 3.4). The notion of d-injectivity implies conflict-freeness and additionally requires oneto-one correspondence between candidates for deletion in G and L. Thus, in order to apply a rule which deletes n items, we have to find n suitable elements in G if d-injective redices are required. D-complete redices, on the other hand, make sure that the whole structural context of the elements of G which are going to be deleted is described in L. Here x is in the structural context of y if op(u)= y for some operator symbol op in the underlying graph structure. For example, the structural context of a vertex is given by all incident edges in the category of directed graphs. (</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) !f m is d-injective and d-complete, G-G,," = m(L-L,).</head><p>Proof. Direct consequence of the pushout Construction 2.6 and Corollary 2.8. U</p><p>On the basis of the notion for direct transformations, we can give precise meaning to the notions "rule system", " transformation", and "generated language". Definition 3.12 (Rule system, transformation, language).</p><p>A rule system RS is a finite set of transformation</p><p>rules. An object G can be transformed to H with a rule system RS if there is a sequence of direct transformations  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conversely, if G can be transformed to H with rule r at redex m by a single-pushout transformation, the translation of r to a double-pushout rule, i.e. D(r), is applicable to G at m in the double-pushout framework if and only ifm is d-injective and d-complete. In this case, the double-pushout transformation of G with D(r) at m results in the same object H.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Example: (1 small police database system</head><p>The power of the new concept lies in its ability to perform transformations even if the redices are not d-complete and d-injective. Thus, the single-pushout approach is free from any other precondition for rule application than finding a homomorphic image of the rule's left-hand side in the actual object that shall be manipulated.</p><p>The following small police database example demonstrates the usefulness of this property. It has been inspired by the information processing system of (W-) Germany's police <ref type="bibr">INPOL [31]</ref>. This database mainly consists of two types of data, namely personal data and case data. Therefore, the initial state (i.e. the empty database) is characterized by the number of personal and case databases in the system. Having just one of each sort, we obtain the graph in Fig. <ref type="figure" target="#fig_13">1</ref>   The graph transformation model for the operations of type l-3 is given by the rules in Fig. <ref type="figure">2</ref>.27</p><p>Operations of type 4 and 5 have the same scheme as the rule (3) in Fig. <ref type="figure">2</ref> but they work on personal or case data exclusively. The erasure operations of type 6 and 7 are modeled by the corresponding inverse rules of type l-5. Inverse rules can be constructed as long as the rule morphism is injective since the inverse of an injective partial morphism is itself an (injective) partial morphism. Figure <ref type="figure" target="#fig_24">3</ref> visualizes the rules for database entry deletion. More complex operations (type 8) can be built from the basic ones (type l--7) using sequential composition, parallel composition, and amalgamation formally investigated in Sections 4, 5, and 6, respectively. The rule in Fig. <ref type="figure" target="#fig_28">4</ref>, for example, is a parallel composition constructed from the rules "erase person p" and "relate person q in kind "father of" to person Y". Figures <ref type="figure" target="#fig_25">5</ref> and<ref type="figure">7</ref> show sorne direct transformations with these rules. Figure <ref type="figure" target="#fig_25">5</ref> demonstrates that single-pushout transformations are able to express "deletion in unknown contexts". Due to Construction 2.6(2), the erasure of the q-labeled vertex (representing a person in the database) by the corresponding "person data deletion rule" triggers the "Partial morphisms are drawn as double arrows. The mapping of the objects is indicated by the graphical arrangement:</p><p>The morphism maps all objects of its domain which occur at the same relative position in the codomain. This works as long as the morphisms are injective. Noninjective morphisms will be indicated by corresponding natural numbers which are used as object identifiers in these cases.  erasure of all incident edges of this vertex from the domain of the transformation morphism ym.28 This operational behavior of the transformation process enables to describe a complete reset of a personal database in the system by the rule which is given as the empty morphism in Fig. <ref type="figure" target="#fig_29">6</ref>. Its application erases all connections of the persons in the database to the database root. Hence, no rules for these persons are applicable afterwards.</p><p>Figure <ref type="figure">7</ref> visualizes a rule application at a redex which is not conflict-free. The parallel rule of Fig. <ref type="figure" target="#fig_28">4</ref> is used with both subactions manipulating data concerned with person q: delete q's data and insert the information that q is father of Y. As it is described in Construction 2.6(l), deletion is dominant w.r.t. preservation.2g Due to '*Note that the double-pushout translation of this rule is not applicable in the situation of Fig. <ref type="figure" target="#fig_25">5</ref> due to a violation of the dangling condition (cf. Section 3.3). Hence, complete person data deletion in our example is not directly expressible in the double-pushout framework. But it seems to be mere accident that exactly this operation is most problematic in the real INPOL System of the German police. First of all, the police tried to prevent this operation from being implemented at all since they always fear that deletion ofdata can make "their knowledge of the world" incomplete; a conception they simply hate. Secondly, after they were forced to implement it by data protection laws, they persistently refused to apply it or managed to produce a new copy before the actual deletion. This behavior and the redundant architecture of the system led to a data structure that, thirdly, prohibits any complete deletion of all data concerned with a single person even if the official in charge actually wants to erase it (compare 1313 for a detailed discussion).</p><p>29 From the data protection point of view, it is the way it should be in this example.</p><p>vertex 7 being in the scope of the rule and vertex 6 outside, the identification of these vertices by the redex forces vertex (6,7) to be outside the scope of the transformation morphism. A side effect is that vertex 7 of the rule's right-hand side cannot be mapped to the transformation result by the corresponding pushout morphism. Hence, the embedding of the right-hand side into the transformation result is partial for conflicting redices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Sequential composition</head><p>The easiest way to construct new rules from a given rule system RS is to consider direct transformations rm : G+H as rules themselves, so-called rule-derived rules. Since rules are only required to be (partial) morphisms, direct transformations possess the right structure.</p><p>Within the single-pushout approach, we can even do more: If there is a transformation of G to H according to Definition 3.12 by a sequence of rules R =I-', . . . , r" at a sequence of redices M =m', . . . , m", G and H are again connected by a partial morphism, i.e. the transformation morphism R,. Thus, all transformations in AlgP(Sig) have the same structure, the structure of a transformation rule. This allows to interpret all transformations with a rule system RS as deriued rules. The language generated by a rule system RS coincides with the language generated by the closure RSD for all start objects G, i.e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RS(G) = RSD(G).</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. RS(G)zRSD(G) follows directly from RSC RSD. RSD(G)sRS(G)</head><p>is a direct consequence of Theorem 4.2. 0</p><p>General derived rules are more complicated. Using arbitrary transformations as derived rules, we loose the properties of Corollary 4.3.</p><p>Example 4.5 (Derived rule). Consider Section 3.4, especially the rule of Fig. <ref type="figure" target="#fig_29">6</ref>. Applying this rule twice to a graph containing two personal databases provides us with the derived rule rd in Fig. <ref type="figure" target="#fig_30">8</ref>.</p><p>The derived rule rd can now be applied to a graph with only one person database at a noninjective redex. Thus, a system state containing a single personal database can be transformed to a graph with two of these databases if all derived rules are allowed for transformations.</p><p>This cannot be done with the original rule system: it is easy to check that all rules preserve the number of vertices representing databases.  Proof. If rd represents a sequence of length 0, it is the identity by definition. Applying rd to G in this case results in G which is also the result using the empty sequence of rules in RS.</p><p>If rd represents a transformation sequence of length 1, the proposition specializes to the case of Theorem 4.2. Thus, it remains to consider the case that rd represents a transformation sequence whose length is greater or equal 2. If we manage to prove the statement of the theorem for derived rules whose corresponding transformation sequence has exactly length 2, we are done. All other cases follow by a simple induction on the length of the transformation sequence which rd represents. The situation that rd has been derived from a transformation of length 2 is depicted in Diagram 10. The rules r and s are contained in the rule system RX The derived rule rd is given by rd = s, 0 r, : Go +G2. The subdiagrams (1) and ( <ref type="formula" target="#formula_1">2</ref>) are the corresponding direct transformations.</p><p>The rectangle (3) + (4) represents the direct transformation of G with rd at the redex p.</p><p>Since rd = s, 0 r,, we can decompose (3) + (4) into two pushouts (3) and (4). The proof is completed if it can be shown that w 0 n is a redex for s. Under this premise (l)+(3) depicts a direct transformation with the rule r, (2) + (4) visualizes a direct transformation with the rule s, and, therefore, G can be transformed to H using rules in RS only.</p><p>The redex p is d-injective w.r.t. s, 0 r, by assumption. Since Gt,nC,m, c G,,, p is conflict-free w.r.t. r,,,, which provides by Proposition 3.11 that the morphism w is total. Since n is a redex, w 0 n is total and a redex for s in K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Uniqueness of colimits guarantees rd,(G)= H = sC,V_n)(rC,C ,,(G)). 0</head><p>A direct consequence of Theorem 4.6 is that each transformation r:" 0 . . . or,!,,: G+H can be replayed in bigger contexts K. That is, if there is an inclusion i: G+K, there is a transformation rTn,mn 0 ... 0 r:i?,,,t : K+M such that i' = i and for j= 1, . . , n, ij is an inclusion. The final result M of this replay is given by applying the corresponding derived rule rLn 0 ... 0 r$ : G-H at the redex i.</p><p>Corollary 4.7 (Generated language). Let RS be a rule system, RST its closure w.r.t. derived rules, and G an arbitrary start object.</p><p>(</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) RS(G)c RST(G).</head><p>(2) For some systems, RS(G)# RST(G). Corollary 2.8(2) provides that x#y and w(x)= w(y) implies x, yEr,(ker(p)). Since m is d-injective, this means that x, yErm(G$m.rm)) and, therefore, x, y~Gt". But this exactly states d-injectivity of w w.r.t. s,. Thus, n is d-injective w.r.t. s and w is d-injective w.r.t. s, and the same argument given for m and p above provides that w 0 n is d-injective for s. 0 Among the derived rules of a rule system, a special set of so-called sequential compositions can be distinguished which allows to simulate all transformations in the system by appropriate direct transformations.  For direct transformations rm : G+H and s, : H+ K, there is a sequential composition t : N + T of r and s and a redex i : N-tG such that t transforms G to K at i, i.e. K = t,(G).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Consider Diagram 11. Construct N =m(L)u(rJ'(n(M)).</head><p>This By definition of N, we get n(M)~r,oi(N)um,(R).</p><p>The square (3) is commutative and m,=x opI which implies n(M) LX 0 r,(N) u x op,(R) = x(r,(N) u p,(R)) = x( Y). Hence, n factors through Y, i.e. there is a morphism q such that x 0 q = n. Construct square (2) as the pushout of q and s which turns subdiagram (4) into a pushout as well.</p><p>The last thing to be shown is that p,. and q are jointly surjective. Since Y is the pushout of r and p, pr and rg are jointly surjective, i.e. Y= p,(R) u rp(N). Thus, it is to be shown that r,(N) c p,(R) u q(M). We know that x 0 rP(N) = r,,, 0 i But, obviously, we have that:</p><p>-__</p><p>(1) Cn(M)nm(L)lnCm(L)nn(M)l=~.</p><p>( [7], who first introduced the idea of rule gluing and gave an explicit operational description. This section reflects the theory presented in [4] for the single-pushout approach. We focus on theoretical aspects and refer to <ref type="bibr" target="#b1">[14]</ref> for examples. All theorems of this section require redices to be d-injective.35</p><p>General assumption 6.1 (Redices). All redices in this section are d-injective.</p><p>The key to amalgamation is the notion of subrule and remainder.</p><p>3s D-injectivity is a sufficient condition for the theorems. It is not necessary in most cases. It is left to future research to investigate amalgamations at arbitrary redices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6.2 (Subrule and remainder).</head><p>A rule t : N-, T is a subrule of a rule r : L+R if there are two total morphisms i : N+ L and j : T-+ R such that (1) j 0 t = r 0 i and (2) i is a d-injective redex for t. The (i, j)-remainder of r w.r.t. t is the rule r -(i, j)t: P-R which is defined in Diagram 14 as the unique morphism for the pushout (1) of t and i such that (r -(i, j) t) 0 i, = j and (r -(i, j) t) 0 ti = r.</p><p>We write r-t for the remainder if the embeddings are obvious from the context.</p><p>The subrule structure of a rule enables the decomposition of direct transformations.</p><p>Theorem 6.3 (Subrule). If t : N--t T is a subrule of r : L+ R with the embeddings i : N -+ L and j: T-+R and m : L-+G is a redex for r, there are redices p and q for t and r -t, respectively, such that the direct transformation of G with r at m can be decomposed into two direct transformations with t at p and with r-t at q.</p><p>Proof. Consider Diagram 15. The square (1) is the pushout constructed for the remainder in Definition 6. 3.1 l(1) guarantees that q is total. Moreover, q is d-injective w.r.t. r-t. Square (2) is pushout and Corollary 2.8(2) states that ker(q)E ti(ker(m)). But ti(ker(m)) z t,(L,) since m is d-injective. The remainder r-t is constructed as a universal morphism such that PCl_r) = i,(Tj)u ti(L,j; cf. proof of Theorem 2.7. Thus, ker(q)c PCrmt) stating d-injectivity of q w.r. The rest of the section considers the synchronized behavior of two rules which share a common subrule t. In a synchronized behavior, the effect of the shared rule t is produced only once, which models a handshake at t. Application of the subrule t at m 0 i = n 0 e produces an object X and induced redices p and q in X for the remainders r-t and s-t, respectively; cf. Theorem 6.3. The t-synchronized efSect r,,, Ilf s, : G-+H is defined to be the transformation from G via X to H given by t,.i:G+X and ((r-t)+(s-t)),+,:X-+H.</p><p>Proposition 6.5 (Synchronized effect). Let r and s be t-related and m and n be tamalgamable redices for them, the induced redices p and q for the remainders as defined in Dejinition 6.4 are parallel-independent. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>The single-pushout approach to graph transformation presented in this article emerged from the observation that a transformation rule in the double-pushout framework [S] can be interpreted as a partial morphism in an appropriate category. The rigorous investigations of algebraic categories with partial homomorphisms in Section 2 led to the notion of graph structures. It is exactly these yraph-like structures which are closed w.r.t. finite colimits. These results seem to be analogous to the results in [ 131, where a detailed analysis of graph pushouts in the total case is provided. Ehrig and Kreowski [ 131 show that pushouts of graphs have certain properties which do not hold in arbitrary categories. These special properties are reflected in the partial case by the incompleteness w.r.t. colimits if the objects considered do not resemble graphs. Some hints that there is a tied connection between categories of total and partial homomorphisms are also given by <ref type="bibr" target="#b27">[37,</ref><ref type="bibr">24]</ref>. Future research shall focus on the details of this connection for algebraic categories. Many results known from the double-pushout framework can be generalized if the transformation process is based on partial pushouts. A typical example is the embedding of transformation sequences. In the new approach, it is always possible to replay a transformation sequence in bigger contexts. On the other hand, the more general applicability of single-pushout rules produces new effects w.r.t. composition. For example, a transformation with parallel rules cannot always be decomposed into transformations with the components of the parallel rule as it is possible in the double-pushout setting; compare Section 5. Analogous results hold for amalgamated rules (Section 6). The one-to-one correspondence between composition of rules and composition of transformations can only be reobtained if the redices for the rules are properly restricted. The central properties in this respect are confict-freeness and d-injectivity.</p><p>With d-injective redices, all results of the algebraic approach carry over to the new framework. D-injectivity is the analog of the identljkation condition known from double-pushout transformations. These results disclose an asymmetry of the gluing conditions dangling and identijication in the double-pushout approach. While the identification condition is cruicial for almost all results about composition of rules and transformations, the dangling condition can easily be dropped in the operational semantics without changing the statements of the central results.</p><p>Not only many results can be generalized for single-pushout transformations, but the proofs are also shorter, the constructions simpler, and there are less technical side conditions. A typical example is the notion of a subrule which needs no technical extra requirements at all in the approach presented above. The technical easiness on the level of direct transformation and rule composition, however, has been purchased by more complex constructions on the fundamental categorical level of morphisms and pushouts. Some of the aspects which have to be handled explicitly on the level of rules and transformations in the double-pushout approach have been hidden in the basic constructions of the new framework. Future research must show if the new level of abstraction is sound w.r.t. further extensions of the theory, for example w.r.t. distributed transformations.</p><p>Many of the new effects which can be observed in the general single-pushout approach are due to redices which are not d-injective or conflict-free. These redices are able to model certain aspects of amalgamation. Amalgamation and redices which are not d-injective are both models for rule applications overlapping in nongluing items. The precise relationship between these two concepts needs further theoretical investigations. An important question in this respect is whether redices can be restricted to injective ones if arbitrary amalgamation of rules is admitted, i.e. can noninjective redices or all interesting noninjective redices be modeled by amalgamation? A positive answer to this question would be very valuable. It would reduce all concepts which model aspects of parallelism to a single, central one, i.e. amalgamation.</p><p>From the practical point of view, implementations of graph transformation systems should be available in order to prove the usefulness of graph-rewriting methods in system design. We are currently developing a prototype system based on singlepushout transformations at the Technical University of Berlin; cf. [Z]. Experiments with this system shall show which extensions of the pure single-pushout approach presented in this article are necessary for practical applications and software engineering (for example, a concept for variables or attributes). Note that all examples in Section 3.1 are hierarchical.</p><p>f* is the extension of ,f* to vectors and opns(.s)B(x) is the vector such that for all igl,, opns(s)B(x)i= opns(s)"(x).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Corrrspondmcr fo: M. Liiwe. FR 6-1, Technische Universitgt Berlin, Franklinstrasse 28/29, W-1000 Berlin 10. Germany. *This work has been partly supported by the ESPRIT Basic Research Workmg Group No. 3299 "Computing by Graph Transformation". functional expressions [33, 221, synchronization mechanisms [4], distributed systems [3, 10, 381, implementation of abstract data types [29], and context-free hyperedge replacement [ 18, 193. A graph transformation rule (L, K, R) conceptually consists of three graphs L, K, and R. L is the left-hand side of the rule. It formulates the precondition under which</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Morphismsf': A-+B are pairs (.f; horn). The first component is a total mapping from A to B. The second component provides a subset of A on whichf'respects the graph structure. A rule r: L-+R is any morphism in this sense and a redex nr : L-G is a total morphism which now means ~OWI, = L. He shows that under certain conditions the two-step construction of 1361 coincides with the pushout construction in the category of graphs and the so-defined morphisms. Unfortunately, only sufficient conditions for the existence of pushouts are given. Besides that, object deletion remains impossible. The concept in [23] has been further developed in [17]. They introduce "generalized graph rewriting" which uses the same kind of graph morphism. The corresponding transformation concept not only involves a pushout construction but also a coequalizer. Since both construction are carried out in different categories (of total resp. partial morphisms), theoretical results are difficult to obtain.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>morphisms and graph structures This section provides a general introduction to colimit constructions in algebraic categories with partial homomorphisms.* The first central result provides necessary conditions for those categories to be closed w.r.t. colimits, namely that the signature contains unary operator symbols only. Signatures of this kind are called graph strucrures. The second main result shows that categories of graph structures and partial homomorphisms have all finite colimits. Both results characterize the structures which can be transformed by single-pushout constructions.' Some examples, how graphs, labeled graphs, hypergraphs, and more complex graph-like structures can be seen as graph structures, are given at the beginning of Section 3. Definition 2.1 (Partial homomorphism). If Sig is signature and A, B are Sig-algebras, a partial Sig-homomorphism h : A +B is a total homomorphism from some subalgebra Ah of A to B. A is the domain, B the codomain, and A,, the scope of h. Since the scope A,, of a partial homomorphism !I : A+ B is a subalgebra of A, we get h(C)cB for each CGA and, for each DcB, h-'(D)GA." Proposition 2.2 (Category of partial homomorphisms).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>"</head><label></label><figDesc>For basic notions and constructions of universal algebra compare 1151. "Recently, Ehrig et al. [1 I] have provided some results in this direction for the double-pushout approach. I0 E denotes the subalgebra relation, h(C)= (h(u)luEC:, and h-'(D)={.YJ~(.x)ED}. 1 I If f : A + B is a partial homomorphism, C a subalgebra of A, and D a subalgebra of B, f;c denotes the domain restriction off to C and f w denotes the codomain restriction offto D, i.e. the scope of.flD is given by f-I(D) and the definition off ID coincides with the definition of fon its scope. " Alg(Sig) denotes the category of all Sig-algebras together with all total Slg-homomorphisms. Pushout situation for Two and Trir.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Proof.</head><label></label><figDesc>First, suppose Sig =(S, OP) contains a constant c:-+cs. Consider Diagram 1 in which the Sig-algebras and homomorphisms are defined by: (1) Trio ::= Trio,= { * &gt; for all SES and opTria(*, . . . , *)= * for all operators 0p:S1,...,Sn+Sn+1EOP;13 (2) Two ::= TwoCS=(*,aJ, Two,={*)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Commuting diagrams for Trir, Three, and Empty "'Note that due to the absence of constants, EntptJ is a subalgebra of each algebra in AlgP(Sig).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Lemma 2.5 (Subalgebras). !fSig =(S, OP) is a graph structure and A is a Sig-algebra, then the set of subalgebras of' A is closed w.r.t. intersection and union. Proof. Closure w.r.t. intersection is a general property for all signatures; cf. [15]. If V is a set of subalgebras of A, U% is also a subalgebra of A if we define UK= UC&amp; C, for all SES and op"" = u cEs opt for all 0peOP. Since all operators are unary, op "" : uVs-(,j%sr is defined for all XE~%~. It is well-defined because all CE% are subalgebras of A. Hence, UY?G A. 0 With Lemma 2.5, we immediately obtain the following result for arbitrary graph structures Sig =(S, OP): If A is a Sig-algebra and B=(BS)SES is a family of subsets of A, i.e. (B,G AJSES, then there is a greatest subalgebra of A whose carriers are contained in B, namely U {CG AIC,c B, for all SES}. This implication of Lemma 2.5 is crucial for the following construction of pushouts in AlgP(Sig). Construction 2.6 (Pushouts in graph structures). If Sig=(S, OP) is a graph structure and ,f: A+B and g: A-tC is a pair of (partial) Sig-homomorphisms, the pushout (O,f,: C-+D, gf: B-+D) off'and g in AlgP(Sig) can be constructed in four steps. (The pushout situation is depicted in Diagram 4.) (1) Construction of the gluing object f'0 g which is a subobject of A: f V g is the largest subalgebra of A which satisfies (a) _fVgz A,.nAg and (b) for all .uE,fVg and y~A,f'(x)=f(y) or g(x)=g(y) implies y~fDg. f A-B Diagram 4. Pushout situation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>of the scopes of,f, and gs: (a) The scope off,, i.e. Cfp, is the largest subalgebra of C whose carriers are contained in (C-g(A))ug(fV g). (h) Similarly, B,, is the largest subalgebra of B whose carriers are contained in (B-f(A))uS(f'vg).'6 (3) Gluing construction of D: D =(B,, + Cfp), _, where x w y if there is an item z~.fVg such that .u=f(z) and y=g(z)." (4) Construction of the pushout homornorplzisms: ,f, : C-+D has the scope CJg and is defined for all XEC~, by&amp;(x) = [x] _ Similarly, gs : B-+D is defined on its scope Bgf. Note that Construction 2.6 includes a pushout construction for total homomorphisms. The first two steps construct subalgebras of A, B, and C, i.e. f V g, B,,, and C,rx, respectively, such that the domain restrictions off and g w.r.t. f0 g are total homomorphismsfi, '.-,:(f'V g)+B,, and gIfTs:(fV g)-+C,,, respectively. The object D, constructed in the third step, coincides with the pushout object offifTY and glfcy in the category of Sig-algebras and total homorphisms. Also,f, and g,r coincide with the corresponding total pushout homomorphisms if they are restricted to their scopes. The whole situation is drawn in Diagram 5. Theorem 2.7 (Pushouts of graph structures). If f: A-+B and g: A+C is a pair of morphisms in a category of' graph structures AlgP(Sig), the object D together with the morphisms fg: C+D and g,: B-+D as they are constructed in Construction 2.6 is the pushout of,f and g in AlgP(Sig). Proof. Due to Lemma 2.5, D, f,, and gf are uniquely defined. Thus, the two pushout properties have to be shown, i.e. (1) ,f, J g = gf sf and (2) for each pair of morphisms "The construction provides that ~J~'(C,~)=~OS=~'~'(B,,). "Here, + denotes the coproduct operator for arbitrary graph structures: if Sig=(S, OP) is a graph structure and A and B are Sig-algebras, (A+B),=A,ti&amp; for all SES and for all op:s+s'~OP, oP A+B(.x)=~pR(~) if -YEA, and opA+' (x) = op"(x) if XEB,. The operator / k constructs the quotient of its argument w.r.t. the least congruence which contains the family of relations _ = (-.),sEs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>f': C-+E and g':B+E in AlgP(Sig) such thatf'og=g'cf, there is a unique morphism u:D+E with uogs=g' and uofg=,fl.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>f': C-+ E and g' : B+E satisfying f'o g=g'of: Then B,, must be a subalgebra of B whose carriers are contained in (B-f (A)) u f (f D g) and C, I must be a subalgebra of C whose carriers are contained in (C-g(A)) u g(f V g). Since B,, and Cfp are the largest of those algebras, B,, c B,, and CJ9cC, . is'a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>define u : D--+ E by d(Y) if x=gf(y) and DEB,, , 4x) = ,f'(Y) if x=&amp;(y) and ygCs, , undefined otherwise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Two homomorphismsf: A-+B and y : C-B are jointly surjective iff(A)uy(C)= B. 19For a partial homomorphism 1: A-B, the kernel of S is a subset of its scope defined by ker(f)= (xEA/I there exists YEA/ such that xfy andf(y)=S(u)]. "A partial homomorphism f: A-+B is injective if.f(x) =-f(y) implies I =J for all x, YEA,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>) are direct consequences of Construction 2.6. (3) is implied by (2). If fand g are total A, = A = A, =,f V g and, therefore, B,, = B and CfR = C which implies (4). In (5), A,cA, and g(x)=g(y) * x, YEA,. or s, y$Af implies f V g= A,, which immediately provides B,, = B. Conversely, if A, $ A,, Bqf # B and g, is partial. Also, if there exist x, y with g(x)=&lt;g(j'), XEA~, and y$ A,, we obtainf V g #A,. This implies, by Construction 2.6, that B,, #B. Hence, gr is partial. 0The existence of pushouts in AlgP(Sig) for each graph structure Sig guarantees that AlgP(Sig) is complete w.r.t. arbitrary finite colimits. Proposition 2.9 (Initial and final graph structure). If Sig is a graph structure, AlgP(Sig) has an initial undjinal object.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Example 3. 1 (</head><label>1</label><figDesc>Unlabeled graphs). Unlabeled graphs consist of a set of vertices V and a set of edges E. Each edge is connected to its source and target vertex by a monadic operation. Hence, the associated graph structure is: Unlabeled Graphs= Sorts V, E Operations source, target : E-tV Example 3.2 (Edge-labeled graphs). If the edges of a graph are labeled by elements of a label set L, we obtain a natural decomposition of the edge set into sets of edges with the same label. Hence, the edge set of edge-labeled graphs is an L-indexed family: Edge-Labeled Graphs = Sorts V, (EA,, Operations (source, target: E,+V),,,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Example 3.3 (Labeled graphs). Labeled graphs are constructed from edge-labeled graphs by sorting the vertices w.r.t. their labels taken from a vertex label set M: Labeled Graphs= Sorts (VJmGM, (Esm,rm,l)sm.tmtM,~t~ Operations ( source : E,,,,,, ,-+Vsm target : 6,. tm, eVtm &gt; sm,tmsM.I6L</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>(H,,,),.,,~ Operations (source,,..., source,,, target,, . . . . target,: H,,,+V),,,,w Note that the Unlabeled-Hypergraph-homomorphisms must respect the type of the edges, i.e. edges can only be mapped to edges with the same number of source and target connection. Labeled hypergraphs can be obtained from hypergraphs in the same way we have constructed labeled graphs from unlabeled graphs. If the distinction between source and target connections is dropped, we obtain undirected hypergraphs. If more than two different connection types are used, multidimensional objects as they are applied, for example, in [38] can be represented. Example 3.5 (Signatwes) Parisi-Presicce [34] applies graph transformation techniques to specify signature manipulations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>Signature = Sorts Sorts, (Operators,,),,~ Operations (arg,, . . . , arg,, value: Operators,+Sorts),,w Example 3.6 (Functionul expressions). Functional expressions over a signature Sig are hyperpaths w.r.t Sig. Sets of these hyperpaths can also be modeled as graph structures. The graph structure Signature above has to be slightly changed: substitute for each sort symbol a set of instances of the sort and for each operator symbol a set of instances of the operator. The signature Sig prescribes which sort instances are allowed as arguments or values for an operator instance. This relation is expressed by the graph structure Expressions(Sig) below which can be defined for each signature Sig =(S, OP): the set of natural numbers with zero. Jungles as they are used in [35, 20, 221 are special expressions. They do not admit cyclic structures and sort instances which are value of two different operator instances. Each jungle can be interpreted as a set of finite Sig-terms with variables: The variables are exactly the sort instances which are not value of any operator instance in the jungle. If we interpret the value connection of operator instances as the source of a hyperedge and the argument connections as targets, each sort instance Si in a jungle represents the term which corresponds to the hyperpath from Si to variables. The term interpretation of a jungle is the set of these terms. Note that due to different degree of "sharing" for common subterms, different jungles (and expressions) can represent the same set of terms. The same interpretation leads to infinite terms for cyclic expressions. And the situation that a sort instance Si is value of two different operator instances can be interpreted as an equation: Take all hyperpaths from Si to variables and interpret them as possibly infinite terms. The set of equations encoded in the expression at si consists of all pairs of these terms. The set of equations encoded in an expression is the union of the equations which are encoded at the sort instances of the expression. Hence, the interpretation of jungles as sets of terms corresponds to the interpretation of expressions as sets of equations, i.e. the jungle interpretation is a special case of the expression interpretation. With these ideas, each expression w.r.t. a signature Sig is an equational specification w.r.t. Sig (cf. 1341). Example 3.7 demonstrates that graph structures are flexible enough to represent very complex objects: Example 3.7 (Structure of graph transformation implementations).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>t. the graph structure below are able to represent the diagram level (graphs and morphisms) and the object level (vertices, edges, and assignments) in a single structure. ALR-Graph = Sorts V, E, V-Ass, E-Ass, Graph, Morphism Operations s, t: E-+V s, t : V-Ass-*V s, t: E-Ass-E s, t : for all eEE, abstract(e)=abstract(s(e))=abstract(t(e)), (2) for each SE-ASS, there exist t', weV-Ass such that abstract(e)=abstract(u)=abstract(w) and s(s(e))=s(c), s(t(e))=t(v), t(s(e))=s(w), and t(t(e))=t(w), (3) and some more; cf. [2].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>transformation in the single-pushout approach Definition 3.9 (Rules, redices, und direct transformation). A transformation rule r: L+R is a partial morphism from the left-hand side of the rule L to the right-hand side R. A redex for r in some object G is a total morphism m : L+G from the left-hand side of the rule to G. The application of a rule r : L+R to an object G at a redex 111: L+G transforms G to r,(G) which is the pushout object in Diagram 6. Note that the graph G and the direct derivation r,,,(G) are connected by the pushout morphism r,,,: G+r,(G)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>Definition 3.10 (Application conditions). Let r: L+R be a transformation rule and m: L-+G a redex for r in G. (1) The redex M is co@ict$ree if m(x)=m(y) implies x, YEL, or x, y$L,. (2) If m(.~)=m(y) implies x = y or x, MEL,, m is called d-injectiue. (3) The redex nz is d-complete if for each object OEG with op"(o)~m(L-L,) for some operator opcSig, we have o~m(L-L,).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>These properties of d-injective or d-complete redices can be summarized as follows: if L -L,, i.e. the part of the rule's left-hand side which describes the elements that are deleted by rule application, has y1 elements, d-injectivity of redices guarantees that at least n items are deleted in each direct transformation and d-completeness makes sure that at most n elements are deleted.24In Definition 3.9 of direct transformation, this intuition is exactly captured as the following propositions show.Proposition 3.11 (Direct transformation).Let a direct transformation rm: G-+H be given us it is dejined by Dejnition 3.9.(1)[fm is conJict:free, then r V m = L,, the embedding ofthe rule's right-hund side in the transformation result m,: R-H is total, m(L,)zG,m, and m(L-L,.)EG-G,_.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head></head><label></label><figDesc>(r'),$ : G'-'+G'for i=l,...,n such that G=G', H=G", and for i= 1, . . . , n, (r':L'-+R')cRS and mi: L'-+G'-' is a redex for ri in G'-'. The language generated by a rule system RS with shart object G is denoted by RS(G) and defined by RS(G)= jH 1 G can be transformed to H with RS). R&amp;,(G), RSi(G), and RSi+,(G) denote the sublanguages of RS(G) which are generated by RS using conflict-free, d-injective, respectively d-injective and d-complete redices in each direct transformation only. If G transforms to H with rules in RS, G and H are connected by the partial morphism Rw = ri,, 0 .. . 3 r,!,l: G+H which is called transformation morphism in the following. 3.3. Single-versus double-pushout transformations For the comparison of single-and double-pushout transformations assume that all constructions in this paragraph are performed in the category of Labeled Graphsalgebras; cf. Example 3.3. See Appendix A for basic notions of the double-pushout approach. Definition 3.13 (Translation of single-and double-pushout rules). If r : L-+R is a transformation rule according to Definition 3.9, D(r)= (1: L,+L, r' : L,+R) denotes its translation to a double-pushout rule, where 1 is the inclusion of L, in L and r' is the domain restriction of r to L,. Conversely, for a double-pushout rule p = (1: K--f L, r : K+R), S(p) : L-t R denotes its translation to single-pushout rules, where LscpI= l(K) and S(p) = r 0 1-'. 25 Theorem 3.14 (Embedding of the classical approach). If the object H is the result of transforming an object G with rule p at redex m in the dobule-pushout framework, the translation of p to a single-pushout rule, i.e. S(p), transforms G to H at the same redex m in the single-pushout setting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Proof.</head><label></label><figDesc>For the first part, consider Diagram 7, where (1) + (2) depicts a direct transformation in the double-pushout setting and s and s* are the translations of (1, r) and of (I*, r*) to single-pushout rules, i.e. s= S(1, r) and s* = S(l*, r*). We have to show that (3) is a pushout in the framework of partial morphisms. By Theorem AS, m satisfies the gluing conditions. Thus, it is d-injective and d-complete w.r.t. s. Thereby, it is conflict-free providing s D m = L, = l(K) by Proposition 3.11. Furthermore, the pushout morphisms s, and m, satisfy RmS = R and Gsm = G -m(L -L,) = D by the same proposition. Therefore, SI(, TV) = r and ml(s c m) = k. Since (2) is the pushout of r and k, H is the pushout of sl, V: m and m/ss m and thereby coincides with the pushout object of s and m in the framework of partial homomorphisms; cf. Construction 2.6 and Diagram 5. Since 1 * : D-PC is the inclusion of G,$. = D into G and R,. = R, s* and m* are the pushout morphisms for s and m. For the second part, consider Diagram 8, where (1) is a direct single-pushout transformation and (1, r) and (I*, r*) are the translations of s and s, to doublep) is well-defined since I is supposed to be injective in the double pushout setting. rules, respectively, i.e. (I, Y)= D(s) and (1*, r*)=o(s,,,). The rule (1, r) is applicable to G at m if and only if m satisfies the gluing conditions identification 2 and dangling of Theorem A.5. These conditions are satisfied if and only if m is d-injective and d-complete w.r.t. s. If m is d-injective and d-complete, Proposition 3.11 provides m(L,) 5 G,_. Thus, we can define k = (I *)-' 0 m 0 I as a total homomorphism. Since the so-defined morphism satisfies k = ml L, = ml7 7 m and we have Y=s~~,=s~~~~ by Definition 3.13 and Proposition 3.11, (3) is a pushout diagram of total homomorphisms by Construction 2.6; compare also Diagram 5. Square (2) commutes by definition of k, 1 and I* are injective, and m is injective outside of I(&amp;). This implies that (2) is a pushout of graph structures as well; cf. Construction 2.6. 0 Theorem 3.14 shows that each transformation of graphs in a double-pushout framework corresponds to a single-pushout transformation with the translated rule. Vice versa, the whole theory for double-pushout transformations can be reobtained by restricting the single-pushout approach to d-injective and d-complete redices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Initial state.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>FigFig. 3 .</head><label>3</label><figDesc>Fig. 2. Object and relation creation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 4. Derived rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Fig</head><label></label><figDesc>Fig. 7. Noninjective redices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Definition 4. 1</head><label>1</label><figDesc>(Rule-derived rule). A rule rd: G+H is a rule-derived rule w.r.t. a rule system RS if there is a rule rERS and a redex m for r in G such that rd coincides with the direct transformation rm: G-r,(G), i.e. H =r,(G) and rd=r,. The closure w.r.t. rule-derived rules RSD is the least rule system which satisfies (1) RS c RSD and (2) if r is rule-derived from RSD, rE RSD. Theorem 4.2 (Rule-derived rule). If K is directly transformed to M with a rule-derived rule rd, there is a direct transformation of K to M with the original rule from which rd is derived. Proof. Consider Diagram 9. The existence of a direct transformation from K to M with the rule-derived rule rd implies that there is a redex n such that (2) is a pushout square. The property of rd being rule-derived ensures that there is a rule r and a redex m I lli I 4 G rd=rm -H Diagram 9. Application of rule-derived rule. m for r in G such that (1) is a pushout diagram. Since pushouts compose, (1) +(2) is a pushout. It is the diagram for the application of r at the redex n 0 m which is total because both components are. Thus, K can be transformed to M using r at n 0 m and rd, = r@l I m) due to the uniqueness of pushouts. 0 Corollary 4.3 (Generated language).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Definition 4. 4 (</head><label>4</label><figDesc>Derived rule). A rule rd : G-H is a derived rule w.r.t. a rule system RS if rd = Rw : G-+H for a sequence of rules R = r', . . . , r"E RS and a sequence of redices M=m', . . . . m" for these rules. The closure w.r.t. derived rules RST is the least rule system satisfying (1) RS c RST and (2) if r is derived from RST, rERST.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Theorem 4. 6 (</head><label>6</label><figDesc>Derived rule). If rd is a derived rule w.r.t. a rule system RS, p is a dinjective redex for rd in G, and rd,: G-+H is the corresponding direct transformation,then G can be transformed to H using the rules in RS only.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Example of a derived rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head></head><label></label><figDesc>Diagram 10. Direct transformation with derived rule (3) If the redices for the construction of derived rules and the redices for direct transformations with rules and derived rules are restricted to d-injective ones, RS generates the same language as RSr, i.e. RS,(G)= RS:(G). Proof. (1) is obvious since RS E RST. (2) is shown by Example 4.5. RS,(G) E RS'(G) in (3) is trivial since RSG RST. For the reverse inclusion, we must show that the redices p 0 m : L-+ G and w 0 n: M + K constructed in the proof of Theorem 4.6 are d-injective (cf. Diagram 10). By the assumption that redices are restricted to d-injective ones, m, n, and p in Diagram 10 are d-injective. Suppose that x#y and p@m(x)=pom(y). Ifm(x)=m(y), x, YEL, and we are done. If m(x)#m(y), m(X), m(y)EG&amp; 1r,) E G,,, since p is d-injective, and Proposition 3.11(l) provides x, ycL,. Thus, p 0 m is d-injective.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>Definition 4. 8 (</head><label>8</label><figDesc>Sequential composition). The derived rule s, 0 Y, in Diagram 10 is a sequential composition of r and s if m, and n are jointly surjective.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_34"><head></head><label></label><figDesc>construction provides a subalgebra of G. Let p = m IN be the codomain restriction of m w.r.t. N and i the inclusion of N in G. Construct Y as the pushout of p and r. Thereby, square (3) is a pushout diagram and x is the unique morphism such that x 0 pI = m,; it is injective LL-R M'S G Diagram 11. Short cut by sequential composition. since i is [cf. Corollary 2.8(3)] and it is total since i is conflict-free [cf. Proposition 3.11(l)]. Since H is the pushout of r and m, Y, and m, are jointly surjective such that n(M)cr,(G)um,(R).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head></head><label></label><figDesc>(N) and by definition of N, r,oi(N)=r,(m(l)u(r,)-'(n(M)))cr, ~m(L)un(M)=x~p,~r(L)ux~q(M)~ x(p,(R)uq(M)). Hence, xor,(N)cx(p,(R)uq(M))which implies r,(N)cp,(R)u q(M) since x is total and injective. Now take t =sqorp, which is a sequential composition of r and s. The diagram (3)+(4) depicts the direct transformation of G to K with t at i as desired. 0In the general case, there are many compositions of rules; in fact, there are several different compositions even if we fix the jointly surjective pair of morphisms m, and n (cf. Definition 4.8). Nevertheless, the set of compositions for r and s is always finite if r and s are finite. But it depends on the actual transformation situation which one is to choose in order to simulate a concrete transformation sequence.Corollary 4.10 (Abstracting from transformations). For a rule system RS which is closed under sequential composition, every transformation in RS coincides with a direct transformation in RX Proof. Direct consequence of Theorem 4.9. I75. Parallel CompositionParallel composition of rules provides a model for simultaneous application of two or more rules. The simultaneous application is represented by the application of the parallel rule which is given by the disjoint union of some rules. The main question is: can the effect of parallel rule transformations be simulated by sequential transformations with the components of the parallel rule? The answer in the classical framework is an unrestricted "yes" [S]. We show that the answer is positive in the new approach only if redices are restricted to d-injective ones. Parallel rule application at arbitrary redices, however, produces effects which cannot be captured by sequential transformations.303" In [ZS], a typical example is presented which shows that these effects model properties of "truly parallel systems" in a natural way. the pushout of rm and s,. Now (l)+(3) is the pushout diagram reflecting the direct transformation of s,(G) with r at p and (2)+(3) reflects the direct transformation of r,,,(G) with s at q. The uniqueness of the pushout construction provides that the pushout objects of (3) (1) + (3), and (2) + (3) are isomorphic which completes this part of the proof. Conversely, suppose p = s, 0 m and q = rm 0 n are redices, i.e. total morphisms. Then, n(M)s GVm and m(L)s G,,. By Construction 2.6, we conclude n(M)c m(L-r V m) and m(L) E n(M --s V n). By construction of r V m and s V n, this results in (*) n(M)nm(L)~[m(L)um(rVm)]n[n(M)un(sVn)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_36"><head></head><label></label><figDesc>) [n(M)nm(L)]n[m(L)nn(sVn)]=O. (3) [n(M)nm(L)]n[m(rVm)nn(M)]=8. Thus, (*) implies n(M)nm(L)cm(rVm)nn(sVn). 0Hence, parallel independence of two rules implies local confluency. Moreover, the effect of applying two parallel-independent rules in any order can be obtained by a single direct transformation if the parallel composition of the two rules is used. Definition 5.3 (Parallel rule and parallel redex). If r: L+R and s: M+S are two transformation rules, the parallel rule r + s is defined as the disjoint union of r and s, i.e. r+s=rds:L&amp;M+R&amp;S. If RS is a rule system, RS is the parallel closure of RS which exactly contains RS and all parallel rules which can be built within RSP. The parallel redex m+n for two redices m: L+G and n: M-G is defined by: m+n:LtiM-+G such that m+n(x)=m(x) if xEL and m+n(x)=n(x) if xEM. Theorem 5.4 (Parallel independence and parallel rule). 1f redices m : L+G and n : M -+G for the transformation rules r : L +R and s : M-S, respectively, are parallelindependent, the application of the parallel rule r+s at the parallel redex m+n to G results in the same object as any sequential application of r and s, i.e. s~,~ 3,)(r,(G)) = r(,.C,&amp;n(G))=(r+s)(,+.)(G). Proof. Consider again Diagram 12. Note that the result of the sequential application of r and s, i.e. the object H, has been constructed as the colimit of s, n, m, and r.33 These morphisms make up the boldface part of Diagram 13. L+ M and R +S are the colimits (coproducts) of L and M and of R and S, respectively. The morphisms il-i, 33 The colimit of a diagram is unique up to isomorphism; cf. [21]. Since we do not distinguish objects if they are isomorphic, the colimit of a diagram is unique in our framework. Note that due to Corollary 2.10, the underlying category of graph structures and partial homomorphisms is finitely co-complete. Diagram 13. Parallel rule and parallel-independent redices. are the universal embeddings. The parallel rule Y + s, as it is constructed in Definition 5.3, coincides with the universal morphism for coproducts such that the subdiagrams (3) and (4) commute. 34 Analogously, the parallel redex m + n is the universal completion such that subdiagrams (1) and (2) commute. (5) is the pushout diagram reflecting the direct transformation of G with r + s at m + n. Thus, Diagram 13 commutes and is thereby a cocone for the boldface part. Since it has been constructed as a composition of partial colimits, it is also a colimit of the boldface part. Uniqueness of colimits immediately provides that K coincides with H which is the colimit of the boldface diagram constructed in the proof of Theorem 5.2; compare Diagram 12. 0The converse of Theorem 5.4 is not true: Applicability of the parallel rule at an arbitrary redex p does not imply that p can be decomposed into parallel-independent redices for the components of the parallel rule.Example 5.5 (Parallel rule and dependent redices). Consider again the rule in Fig.4. It is a parallel rule which is applied in Fig.7at a redex which is not d-injective. Obviously, the redices for the component rules (i.e. deletion of q and addition of father relation) are not independent; cf. Definition 5.1.Example 5.5 demonstrates that the addition of parallel rules to a given rule system can increase the possible transformations and the set of objects which can be generated from some start object. The results of the classical approach can be generalized to the single-pushout framework if redices are restricted to d-injective ones.Proposition 5.6 (Parallel rule and parallel independence). Zf the parallel rule r SS: L+ M-R + S is applicable to G at a d-injective redex p: L+ M-G, itsj"The coproduct A+B in AlgP(Sig) can be constructed as the pushout of 8:0-A and 8:0-B. The universal morphisms are then given by Construction 2.6. decomposition to the components, i.e. m=plL:L-tG and n=pIM:M+G, is a pair of parallel-independent redices for the rule r : L +R and s : M+S, respectively; therefore, s(Y,zn)(rm(G))= r(.Y,l&amp;,(G)) =(r + s),(G). Proof. If p is d-injective, p(x) =p(y) implies x = y or x, yE(r + s) V p and by Proposi-tion3.11,(r+s)Vp=(L+M)(,+,,= Lr+M,.Thus,x~L, yeM,andm(x)=n(y)implies XEL, and REM, which, again by Proposition 3.11, means XET V m and YES V n. Bence, parallel independence of m and n is guaranteed which, by Theorem 5.4, immediately proves the second part of the proposition. 0 Corollary 5.7 (Generated language). Zf RS is a rule system, RSP its closure w.r.t. parallel rules, and G an arbitrary start object, (1) RS(G)z RSP(G), (2) RS(G) # RSP(G) for some rule systems, and (3) RS generates the same language as RSP ifredices are restricted to d-injective ones, i.e. RSi(G)= RS'(G). Proof. (1) is obvious since RS G RSP. (2) can easily be shown by e.g. Example 5.5. (3) is an immediate consequence of Proposition 5.6 and of the facts that d-injectivity of m + n w.r.t. r + s implies d-injectivity of m and s, 0 m w.r.t. r or of n and r, 0 n w.r.t. s. The proof is straightforward. 0 6. Amalgamation Sequential and parallel composition of rules is a device to integrate the effects of several rules into a single one. Therefore, all results concerning this kind of composition are statements of equivalence expressing that there is a one-to-one correspondence between transformations with or without composed rules. The situation is different if we consider gluing of rules, called amalgamation. This concept has been introduced in [4] as a synchronization device for graph transformation systems which model the behavior of distributed systems. The work in [4] has been motivated by Degano and Montanari</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head></head><label></label><figDesc>2; (2) + (3) is the pushout reflecting the direct transformation ofGtoHwithratm.Sincer=(r-t)oti,(2)+(3) can be decomposed into two pushout diagrams (2) and (3). Compositionality of pushouts guarantees that the diagram (1) + (2) reflects a direct transformation of G to K with t at p = m 0 i. The morphism p is total and d-injective since m and i are (cf. General assumption 6.1). If q: P+K is total and d-injective, (3) is the required direct transformation from K to H with r-t. D-injectivity of m means: m(x)=m(y) implies x=y or x, YEL,. Since r=(r-t)Oti,L,zLt andm(x)=m(y)impliesx=yorx,y~L,~.Hence,misd-injective w.r.t. ti and Proposition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_38"><head>Definition 6. 4 (</head><label>4</label><figDesc>Related rules, amalgamable redices, synchronized e&amp;x?). Two rules r : L-t R and s : M -+S are related w.r.t. a third rule r : N+ T if t is a subrule of r and s. In this case, we say that r and s are t-related. Let (i, j): t+r and (e,f): t-+s be the corresponding embeddings. Two redices m : L-+G and n : M +G for r and s, respectively, are t-amalgamable if m 0 i = n 0 e and m(L)nn(M)~m~i(N)u[m(rDm)nn(sVn)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_39"><head>Proof.</head><label></label><figDesc>The whole situation is depicted in Diagram 16. Diagram (2)+(3) is the direct transformation of G with the rule t at the redex n 0 e. Diagram (5)-t(4) reflects the direct transformation of G with t at m 0 i. The redices m and n are amalgamable such that m 0 i = n 0 e. Therefore, the diagrams (2) + (3) and (5) + (4) depict the same pushout which is indicated in the diagram by the fact that the diagrams (2)+(3) and (5)+(4) overlap in the morphism a. (2) is the transformation of M with t at e and (5) the transformation of L with t at i according to Definition 6.2. Diagram 16. Remainder redices in synchronized effect. Diagram 18. Amalgamation is colimit construction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_40"><head>Diagram 20 .</head><label>20</label><figDesc>Definition of direct transformation. Diagram 21. Construction of a direct transformation Theorem A.5 (Direct transformation). The definition and the construction of direct transformations are related as follows: (1) Let Diagram 20 represent a direct transformation of G to H with rule p = (1: K + L, r: K+R) at redex m: L-+G as defined in Definition A.2. (a) H is uniquely determined by G, p, and m. (b) m satisfies the gluing conditions dangling and identification 2. (c) D and H coincide with the graphs constructed in Construction A.4. (2) Let Diagram 21 depict a construction as in Construction A.4. (a) k = (In) ' 0 m 0 1: K +D is total tf the gluing condition identification 1 is satisfied. In this case, subdiagram (2) is u pushout. (b) [f m satisfies dangling and identification 2, also diagram (1) is a pushout. Identijication 1: m(x)=m(y) implies x, y~l(K) or x, y$l(K). Identification 2: m(x)=m(y) implies x, ye/(K) or x= y. Dangling: si(e) or tj(e)Em,,(Lv-lv(Kv))for some eEGE implies eem,(L,). Appendix B. Completion of partial morphisms For a big class of graph structures, so-called hierarchical graph structures, partiality of a homomorphism can be modeled by a total homomorphism which maps undefined objects to some special I-items. The corresponding completion with the necessary I-structure is presented below. It relates the approach to single-pushout transformations presented above to the one in [S]. Definition B.1 (Hierarchical graph structures). A graph structure (S, OP) is hierarchical ifthereisnoinfinitesequenceop,:~,js,,op~:~~~~3,...,Op~:S~~Si+~,Op~+~:Si+~-t si+z, ... of operator symbols. If Sig=(S, OP) is a hierarchical graph structure, the relation 5 on S defined by s' 5 s if Tz!&amp;, #8 is a well-f ounded partial order. Thus, noetherian induction can be used if statements have to be proven for all sorts.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>" Note that edge assignments are objects on a third level if we think of vertices being primary objects and edges being secondary items.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="23" xml:id="foot_1"><p>The generated congruence is not trivial, if it differs from dG (the least reflexive relation) for at least one object G.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="24" xml:id="foot_2"><p>The application conditions d-injectivity and d-completenessreformulate the gluing conditions of the double-pushout framework for single-pushout transformations.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The investigations begin with a notion of parallel independence for two direct transformations.</p><p>The Commutativity theorem proves that parallel independence implies that the result of the transformation is independent of the sequential order in which the two participating rules are applied. Proof. First suppose m and n are parallel-independent.</p><p>Consider Diagram 12. Square (1) depicts the direct transformation of G with r at m and square (2) the direct transformation of G with s at n. For p = s, 0 m and q = r,,, 0 n to be redices, it is to show that they are total morphisms which means to show (i) m(L) E G,_ and (ii) n(M) c G,_. We explicitly show (i); the argument for (ii) is symmetrical.</p><p>Suppose o$G,~. By Construction 2.6, it implies either oEn(s V n)31 or there is a term tETSig(x) such that (*)t'(o)En(s V n).32 The first case implies o$m(L) because m and n parallel-independent.</p><p>The second case implies o$m(L), too: Since m is a redex, it is a total morphism and its image in G is a subalgebra of G. Thus, the assumption oem(L) implies t'(o)Em(L) which is a contradiction to the parallel independence of m and n [compare (*)I$. Therefore, if o$G,~, o$m(L), which immediately provides that s, 0 m is total.</p><p>Hence, the existence of the redices p and q is guaranteed and we must prove rp(sn(G))=sq(r,,,(G)). For this purpose, let square (3) in Diagram 12 be constructed as Parallel independence of p and q, i.e. p(P) n q(Q) c p(u V p) n q(u Q q), remains to be shown. Since p and q are d-injective, we must prove that p(x)=q(y) implies XEP,, and YEQ". Since P and Q are pushout objects, i, and ti and e, and t, are jointly surjective, respectively, such that there are four cases to be considered: Case I: x~i,(T) and y&amp;T):(x) immediately implies that x and y are gluing points. Case 2: x~i,(T) and y~tJA4): x~i,(T) means that there exists ZET such that i,(z)=x. Since diagram (2)+(3) coincides with diagram (5) +(4), poi,=qoe,.</p><p>Thus, q 0 e,(z)=q(y).</p><p>If et(z)=y, y has a preimage w.r.t. e, and is gluing item by (*). If e,(z) #y, q identifies y and e,(z) which implies that y is gluing item since q is d-injective.</p><p>Case 3: x~ti(L) and yEe,(T): Follows from an argument similar to case 2. Then m(c), n(d)Eker(a). This implies that both c and d have preimages w.r.t. both morphisms n and m because (3) and (4) are pushouts [cf. Corollary 2.8(2)]. These preimages must be elements of the kernel oft, and ti. Thus, they must have preimages w.r.t. n 0 e and rno i and we are back to the arguments in cases l-3, which completes the proof. 0 Proposition 6.5 shows that the synchronized effect of two rules as defined in Definition 6.4 models shared behavior exactly on the part affected by the shared rule. The local operational effects of both rules, i.e. those parts not in the subrule, are independent.</p><p>The synchronized effect of two rules can be obtained by simple direct transformations if amalgamated rules are constructed and applied.</p><p>Definition 6.6 (Amalgamated rule). If r : L-+ R and s : M-S are (t : N-r T)-related via embeddings (i, j) : t-r and (e, f) : t-s, respectively, the amalgamated rule r 0, s : U-t V is constructed in Diagram 17. U and V are pushouts of i and e and of j and f; respectively. r 0, s is the unique morphism such that (r 0, s) 0 ei=Jo r and (r 0, s) "i,=jfos.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M. L&amp;e</head><p>Diagram 17. Construction of the amalgamated rule Note that r Ots is the colimit of (i,j) and (e, f) in the category of arrows over AlgP(Sig). The short notation Y Ors for the amalgamated rule is not precise because the result of the amalgamation construction depends on the actual embeddings. Thus, we assume in the sequel that the involved embeddings are obvious from the context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 6.7 (Amalgamation).</head><p>There are amalgamable redices m and n for the rules r : L-+R and s : M-+S such that the corresponding synchronized effect transforms G to H, i.e. r, lIf s, : G+H if and only if there is a redex o for the amalgamated rule r 0, s such that (r 0, s)~: G-H is a direct transformation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Therefore, m(x)Em(L,) u n(M,) = m(r V m) u n(s V n).</head><p>For the implication in the reverse direction, amalgamable, d-injective redices m and n are given. We have to show that o : U-+G constructed as the unique morphism such that o 0 ei = m and o 0 i, = n is d-injective. The proof is routine. It can be achieved straightforward by a complete case analysis for x and y if 0(x)=0(y) is given. That the synchronized effect r,,, (If s, : G+ H coincides with the direct transformation (r 0, s), : G+ H is a direct consequence of the fact that the synchronized effect of r and s is the colimit of the left part in Diagram 18 (cf. Definition 6.4 and Proposition 6.5) and direct transformations with amalgamated rules are defined to be colimits of the right part in Diagram 18. Since o 0 ei = m and o 0 i,= n and U is a colimit itself, both colimits coincide up to isomorphism;</p><p>cf. <ref type="bibr" target="#b10">[21]</ref>. 0</p><p>Note that Proposition 5.6 and Theorem 5.4 are special cases of Theorem 6.7 since parallel rules are amalgamations w.r.t. the empty shared subrule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Basic notions of the double-pusbout approach</head><p>The algebraic graph grammar approach of [S] is based on the category of Labeled Graphs, compare Example 3.3, and total morphisms, i.e. Alg(Labeled Graphs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition A.1 (Graph transformation rule). A graph transformation rule p = (1: K +L, r: K+R)</head><p>consists of two graph morphisms 1 and r from the gluing graph K to the left-hand side L and to the right-hand side R, respectively. The left-hand morphism 1 is required to be injective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alyehraic approach to single-pushout yruph transjbmation 217</head><p>Diagram 19. Direct transformation (classical approach).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition A.2 (Direct tran.yformation).</head><p>A graph G can be directly transformed to another graph H using rule p = (I : K -+ L, r : K +R) if there are two diagrams (1) and ( <ref type="formula">2</ref> we need some operations on graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition A.3 (Operations on graphs).</head><p>For graphs G and H, G+H denotes the disjoint union of G and H, i.e. the disjoint union of the vertex and edge sets with the operations sG+H given by s~+~(.x)=s~(.x) if XEG and sGfW(x)=sH(x) otherwise and tG+H, defined by the same scheme.</p><p>If H is a graph and (V, E) a pair of subsets of its vertices and its edges, H -( V, E) denotes the largest subgraph of H whose vertex and edge sets are contained in HV -V and HE -E, respectively, i.e. Let lD:D+G denote the obvious inclusion morphism.</p><p>(2) Add: E:= D + R. Let iD : D+ E and iR : R+ E denote the obvious inclusions.</p><p>(3) Emhed: H:=E _, where N-Y if .x=iRcr(z) and y=iDa(lD)-'</p><p>om"l(z).</p><p>3h The rtlyrhrnic rrpprouch to graph trumfiwmation [S. 9, 161 is based on this notion for direct transformations. Due to its form. it is called the double-pushout approuc,h.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition B.2 (Junk completion). If Sig =(S, OP) is a hierarchical graph structure,</head><p>(1) opns(s)=(opns(s)i)iElc denotes the vector of operator symbols in OP which take arguments of sort s, i.e. for all iel,, opns(s),=opi:s-+si.</p><p>(2) sorts(s) = (sorts(s)i)iEr, is the corresponding list of sort symbols such that sorts( is the value sort of opns(s)i for all iEl,.</p><p>(3) the junk completion Junk(Sig) is the following equational specification, where 2 is a vector of variables such that ~i~Xsorts(s), for all iEZS:37 Note that in case of an infinite vector opns(s) for some sort s, we have to handle signatures and algebras with operators which take infinitely many arguments. Hierarchical signatures, however, guarantee that we do not run into trouble with "infinitely deep" terms, i.e. each term w.r.t. the signature Junk(Sig) is of possibly infinite width but of finite height.</p><p>Junk(Sig)-algebras help in the analysis of AlgP(Sig). First, consider the relation of Alg(Sig) and AlgP(Sig). Obviously, they coincide on objects and each total homomorphism is a special partial one. Hence, Alg(Sig)sAlgP(Sig), and with the aid of Junk(Sig), the inclusion G : Alg(Sig)+Alg'(Sig) turns out to be a left adjoint functor. Proof. We construct a mapping PH(F(P), up : F(P)-+P) which assigns to each object PEAlgP(Sig) another object F(P)EAlg(Sig) and a partial homomorphism up, and show that the so-defined mapping is a co-free construction, i.e. for each partial homomorphism f: B-+P, there is a unique total homomorphism f* : B+F(P) such that up l,f* =f: The situation is depicted in Diagram The assignment on objects P-F(P) can be canonically extended to a functor F: Alg'(Sig)-+Alg(Sig)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition B.3 (Inclusion functor). If Sig</head><p>which is right adjoint to E : Alg(Sig)-+AlgP(Sig). 0</p><p>For hierarchical graph structures, the junk completion of Definition B.2 provides some further information about colimits and how they can be constructed if the following uniqueness constraint is additionally required in the completion process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition B.4 (Sink completion).</head><p>If Sig is a hierarchical graph structure, its sink completion Sink(Sig) is the following specification with conditional equations:</p><p>Use Junk(Sig) Equations can be defined as follows:</p><p>(1) On objects. T(A)=Free(A), where Free(A) is the free Sink(Sig)-algebra over A39 Since Free: Alg(Sig)-Alg(Sink(Sig)) is consistent, T can be chosen such that for all SES, A,ET(A),.</p><p>(2) On morphisms, T(f: A+B)=fT:</p><p>T(A)+T(B) is given for all SES by if x~.4~, IT'"'(,TT(opns(s)T'A'(x))) otherwise.</p><p>Proof. Noetherian induction on the sort relation 5 shows thatfT is a family of total mappings; compare proof of Proposition B.3. ForfT to be homomorphic, it is to be shown that</p><p>(1) ,fT(opT'"'(x))=opT@'(,fT(x)) for all opeOP and</p><p>(2) _fT(_LT'"'(.?))= IT"'(~(5J)) for all i-operators.</p><p>In the first case, two subcases can be distinguished, i.e. either XGA~ or x$As. If the former is true,jT is homomorphic since fis. If the latter is true, the definition offT provides:</p><p>~p"~'(fT(.u)) = opTtB'( _Lf'B'(jT(opns(s)T'"'(x)))).</p><p>Since op = opns(s)j for some FEZ,, the equations in Junk(Sig) make sure that opT'B)(I~'B'(,~T(opns(s)T'A' (x))))= opns(s)j""( I~'B'(Q'(opns(s)T'"'(x))))</p><p>=fT(opns(s)T'A'(x))=fT(opT'A'(x)).</p><p>In the second case, we have by construction of T(A) that IT'A'(?)#A. Therefore, we obtain by definition off' :fT( _LTCA'(?)) = I~'B'(~(opns(s)T'"'(IT'A'(~)))).</p><p>The equations of Junk(Sig) guarantee, for all jEZ,, that: opns(S)jT'A'(_LT'A'(Z))=?j. Hence, it can be concluded: _LJ'B'(~T(opns(s)T'"'( IT'A'(Z))))= I,'@'(fT(?)), which completes the proof that ,fT:T(A)-+T(B) is a total homomorphism. By definition, the functor T preserves identities and respects morphism composition. 0</p><p>Definition and Proposition B.6 (Restrictionfunctor). If Sig =(S, OP) is a hierarchical graph structure and Sink(Sig) its sink completion, the restriction jiinctor P: Alg(Sink(Sig))-+AlgP(Sig) can be defined as follows:</p><p>(1) On objects, P(A),={y~A,1~#19(2)} for SES and for OPEOP, ~p~(~'=opf~(~).</p><p>(2) On morphisms, P(J': A+B)=fP:</p><p>Proof. The conditional equations of Sink(Sig) guarantee that P(A) is a Sig-algebra for each A~Alg(Sink(Sig))</p><p>as the following argument demonstrates:</p><p>The assumption 39 Free constructions for specifications with conditional equations always exist; cf. <ref type="bibr">[32,</ref><ref type="bibr">6]</ref>. The constructions of [6] can be easily extended to handle operators with infinitely many arguments. By induction hypothesis, i: is injective for all sorts s' 5 s. Hence, for all kgl,, i$ = GJ~ and, therefore, x= lFree(P(A)J(ij)= ~Free(P(A))($)=y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IFreelP(AIIl FreelPIAll</head><p>Diagram 23. Extension of restriction inclusion. an analysis of gluing constructions for graphs,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algehruic approal,h to single-pushout graph transformation</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Math. Nachr</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page">1355149</biblScope>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Parallel and distributed derivations in the single pushout approach</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lowe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Technical University of Berlin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report 91</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fundamentals of AIgehraic Specijications 1</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mahr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Monographs in Computer Science</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Graph grammars: an algebraic approach</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pfender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Ann. IEEE Symp. on SnYtching and Automuta Theory</title>
		<meeting>14th Ann. IEEE Symp. on SnYtching and Automuta Theory</meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page">1677180</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A categorical construction for generalised graph rewriting</title>
		<author>
			<persName><forename type="first">J</forename><surname>Glauert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kennaway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sleep</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName><surname>Tech</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Norwich NR</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1989">1989</date>
			<pubPlace>UK</pubPlace>
		</imprint>
		<respStmt>
			<orgName>School of Information Systems, University of East Anglia</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
	<note>TJ</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<title level="m">Hyperedge replacement: grammars and languages</title>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>University of Bremen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<title level="m">Proc. 3rd</title>
		<meeting>3rd</meeting>
		<imprint>
			<date>May</date>
		</imprint>
	</monogr>
	<note>we introduce to you: hyperedge replacement</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Workshop on Graph Grammars and Their Application to Computer Science</title>
		<author>
			<persName><surname>Internat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">291</biblScope>
			<biblScope unit="page" from="15" to="26" />
			<date type="published" when="1987">1987</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Jungle evaluation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th Workshop on Specification of Abstract Data rvprs</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th Workshop on Specification of Abstract Data rvprs<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">332</biblScope>
			<biblScope unit="page">922112</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Category Theory (Allyn and Bacon</title>
		<author>
			<persName><forename type="first">H</forename><surname>Herrlich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Strecker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
			<pubPlace>Rockleigh, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Jungle evaluation for efficient term rewriting</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Internat. Workshop on Algebraic and Logic Programming</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Grabowski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Lescanne</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Wechler</surname></persName>
		</editor>
		<meeting>1st Internat. Workshop on Algebraic and Logic Programming<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Akademie-Verlag</publisher>
			<date type="published" when="1988">1988. 191l203</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On &quot;on graph rewriting</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kennaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page">37758</biblScope>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Graph rewriting in some categories of partial maps</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kennaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Workshop on Graph Grammars and Their Application to Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>4th Workshop on Graph Grammars and Their Application to Computer Science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990. 1991</date>
			<biblScope unit="volume">532</biblScope>
			<biblScope unit="page" from="490" to="504" />
		</imprint>
		<respStmt>
			<orgName>University of East Anglia</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Is parallelism already concurrency? part 1: derivations in graph grammars</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowksi</surname></persName>
		</author>
		<imprint>
			<publisher>Proc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Workshop on Gruph Grammars and Their Applicution to Computer Science</title>
		<author>
			<persName><surname>Internat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">291</biblScope>
			<biblScope unit="page" from="343" to="360" />
			<date type="published" when="1987">1987</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">On structured graph grammars: Parts I and II</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</author>
		<idno>3/88</idno>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
		<respStmt>
			<orgName>Universitat Bremen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Is parallelism already concurrency? part 2: non-sequential processes in graph grammars</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wilharm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Internat</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>3rd Internat<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">291</biblScope>
			<biblScope unit="page" from="361" to="377" />
		</imprint>
	</monogr>
	<note>Workshop on Graph Grammars and Their Application to Computer Science</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Algebraic approach to graph transformation based on single pushout derivations with partial morphisms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lowe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Technical University of Berlin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report 9015</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Implementing algebraic specifications by graph transformations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. rnjbrm. Process</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<idno>TU Berlin 89/26</idno>
	</analytic>
	<monogr>
		<title level="j">Cybernet. (EIK)</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">11,112</biblScope>
			<biblScope unit="page" from="615" to="641" />
			<date type="published" when="1989">1990. 1989</date>
			<pubPlace>Berlin</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Technical University of Berlin</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Algebraic approach to graph transformation based on single pushout transformations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ehrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Internat. Workshop on Graph-theoretic Concepts in Computer Science</title>
		<title level="s">Lecture Note in Computer Science</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Mohring</surname></persName>
		</editor>
		<meeting>16th Internat. Workshop on Graph-theoretic Concepts in Computer Science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">484</biblScope>
			<biblScope unit="page" from="338" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Lowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
		<title level="m">Schiine neue Computerweh (Verlag fur Ausbildung und Studium (VAS) in der</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Kitzing</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">U</forename><surname>Linder</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Obermaier</surname></persName>
		</editor>
		<imprint/>
	</monogr>
	<note>Risiken polizeilicher Datenverarbeitung</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Berlin</forename><surname>Elefantenpress</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="216" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Characterizing specification languages which admit initial semantics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mahr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Makowski</surname></persName>
		</author>
		<idno>1331 P. Padawitz</idno>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">232</biblScope>
			<biblScope unit="page" from="37" to="58" />
			<date type="published" when="1982">1982. 1984. 1982</date>
		</imprint>
	</monogr>
	<note type="report_type">Technion Haifa</note>
	<note>Theoret. Comput. Sci.</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<author>
			<persName><forename type="first">F</forename><surname>Parisi-Presicce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1351 D. Plump, Im Dschungel: Ein neuer Graph-Grammatik-Ansatz zur effizienten Auswertung rekursiv definierter Funktionen</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1341">1341. 1989. 1986</date>
			<biblScope unit="volume">372</biblScope>
			<biblScope unit="page" from="621" to="636" />
		</imprint>
		<respStmt>
			<orgName>Diplomarbeit, University of Bremen</orgName>
		</respStmt>
	</monogr>
	<note>Modular system design applying graph grammar techniques. in: ICALP&apos;89</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On graph rewriting</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Raoult</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page">24</biblScope>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Categories of partial maps</title>
		<author>
			<persName><forename type="first">E</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosolino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="95" to="130" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Describing distributed systems by categorial graph grammars</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ISth Internat. Workshop on Gruplz-theoretic Concepts in Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>ISth Internat. Workshop on Gruplz-theoretic Concepts in Computer Science<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">411</biblScope>
			<biblScope unit="page" from="121" to="135" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
