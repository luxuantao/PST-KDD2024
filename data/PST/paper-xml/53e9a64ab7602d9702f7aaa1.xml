<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Abstract Interpretation, Logical Relations, and Kan Extensions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Samson</forename><surname>Abramsky</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Imperial College</orgName>
								<address>
									<settlement>London</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Abstract Interpretation, Logical Relations, and Kan Extensions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">810DF7B5512D6C4FDBB9E09080ABC55E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Abstract interpretation</term>
					<term>strictness analysis</term>
					<term>A-calculus</term>
					<term>logical relations</term>
					<term>safety</term>
					<term>liveness</term>
					<term>powerdomains</term>
					<term>Kan extensions</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We develop a formalism for abstract interpretation based on logical relations. As a case study, we use this formalism to give new proofs of correctness for strictness analysis on the typed A-calculus, and also for termination analysis. We then go on to a deeper study of the duality between safety and liveness properties, and the construction of abstraction functions which can be used to give the best possible interpretations of higher-type constants. This turns out to be a special case of the construction of Kan extensions in category theory. Necessary and sufficient conditions are given for abstraction functions to be definable over continuous type structures and for the abstraction functions themselves to be continuous.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A technique of growing importance in static program analysis (as applied, for example, in advanced compiler technology) is the use of non-standard interpretations (or semantics) of programming languages to yield partial information on selected aspects of program behaviour. The task of a theoretical framework for this technique is to provide appropriate concepts to formalize the notion of correctness of an analysis, and mathematical tools and theories to support proofs of correctness of particular analyses. In addition, such theories may provide guide-lines for obtaining suitable analyses in the first place, and criteria for establishing that a given analysis is the best possible under some initial assumptions. Following the pioneering work of the Cousot's in establishing such a framework for flowchart programs <ref type="bibr" target="#b1">[2]</ref>, Mycroft applied similar ideas to functional programming languages <ref type="bibr" target="#b12">[13]</ref>, and introduced a number of new analyses, one of which, strictness analysis <ref type="bibr" target="#b11">[12]</ref>, has become of increasing importance in the implementation of functional programming languages and the design of new architectures to support such languages <ref type="bibr" target="#b2">[3]</ref>. Subsequently, Nielson has developed a very general and sophisticated framework for abstract interpretation based on denotational language definitions <ref type="bibr" target="#b16">[17]</ref>.</p><p>The question of extending Mycroft's original form of strictness analysis to richer programming languages has concerned a number of researchers <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. In <ref type="bibr" target="#b0">[1]</ref> a theoretical framework for strictness analysis in the typed A-calculus is developed. All the work in <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b0">[1]</ref> is based on the use of power domains and continuous functions to relate 'standard' and 'non-standard' interpretations of a given programming language. By contrast, <ref type="bibr" target="#b14">[15]</ref>, see also <ref type="bibr" target="#b15">[16]</ref>, proposes a relational formalism, in a very general setting. In this paper, we take up Mycroft's suggestion, but with a number of differences. Our notion of interpretation is less general than his, we consider typed rather than untyped A-calculus, and we use the standard notion of logical relation <ref type="bibr" target="#b18">[19]</ref>, which is an important tool in the study of the A-calculus <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b10">[11]</ref>. Our motivation for these choices is that we wish to expose latent mathematical structure as clearly as possible, rather than to strive for maximum generality. Nevertheless, we are able to offer a striking and non-trivial case study, namely strictness analysis itself.</p><p>We develop a new approach to proving the correctness of strictness analysis using logical relations. We are able to give simple, structured proofs of correctness both for strictness analysis for higher-order functions in the typed A-calculus-i.e. the main result in <ref type="bibr" target="#b0">[1]</ref>-and also for the dual termination analysis of <ref type="bibr" target="#b11">[12]</ref>.</p><p>The only previous correctness proofs for the latter analysis appeared in <ref type="bibr" target="#b13">[14]</ref> and <ref type="bibr" target="#b16">[17]</ref> and %ere technically very heavy, using 'generalized domain theory' (limits of transfinite chains, etc.) and non-standard powerdomain constructions. While the development in <ref type="bibr" target="#b0">[1]</ref> stays within standard domain theory it also involves quite complex calculations with powerdomains. By contrast, our definitions are simple and regular, and our correctness proofs are trivialities once we have established a few general results on logical relations.</p><p>We then go on to study abstraction functions which pick out 'best' representatives from the abstract values related to a given concrete value. Such functions can be used, for example, to find best possible interpretations of higher-type constants. We develop a rather general theory, based on the duality between safety and liveness properties (strictness and termination being an instance of this duality). Some illuminating connections are found with logical relations, on the one hand, and Kan extensions <ref type="bibr" target="#b9">[10]</ref>, a fundamental notion from category theory on the other. We also develop necessary and sufficient conditions for continuity of these abstraction functions; these conditions being the role of powerdomains in abstract interpretation into sharper focus. Finally, we describe a new analysis, totality analysis and prove its soundness.</p><p>We shall assume some familiarity with domain theory throughout this paper: see, for example, <ref type="bibr" target="#b5">[6]</ref>. We shall use the following notation for step functions: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Syntax and semantics of typed A-calculus</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntax of types</head><p>Base types A, B,. . . Type expressions a, T, ...</p><formula xml:id="formula_0">T. ::= A | T,-» T 2 .</formula><p>A language L is specified by giving a set of base types and a set of typed constants c r .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syntax of typed terms</head><p>For each type a, we have an infinite set of typed variables Now A r (L), the typed A-calculus over a language L, comprises typed terms e: a formed according to the following rules: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Logical relations</head><p>Given a language L, there will be a standard interpretation inducing a standard semantics-i.e. the intended denotational semantics of the language. Other interpretations will induce non-standard semantics, which may be used in static analysis of programs. This suggests that it may be useful to relate interpretations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on types, with the base case given (since we are proving inheritance). We give the argument for (3) as illustration. Suppose fR^x ±i-.*, and let a e D' o . Since R is total, for some b e D J O , aR a b and hence</p><formula xml:id="formula_1">faR z ±.U.b = L J X .</formula><p>By induction hypothesis, this implies fa = l' z . We have shown that</p><p>VxeD' a -fa = L' r) i.e. / = lUr •</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Open problem</head><p>Give syntactic conditions on properties of relations (e.g. as second-order formulae) which guarantee inheritance by logical relations. I We now apply some of the above concepts to the interpretation of the recursion combinators. From now on, we assume that languages always contain constants Y (a ^.ay _ a for each a. I is a least fixed point interpretation if n-0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Proposition</head><p>Let #:/-•/ be a strict, inductive logical relation. Then</p><formula xml:id="formula_2">Proof ±' a R a ± J a , since R is strict. Now assume f n (±' o )R a g-(± J a ). Then fR^^ and R logical imply that/" +1 (±' w ) =f(J"(± l a ))R a g(g"(± J a )) =g n+ \L J a ). Thus Vn •/"( ± ' o )R a g"(± J a ), which implies fixif) = U/"(1X LJ g n (-L'*) =fix(g) n-0 n-0</formula><p>since R is inductive. I </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Safety and liveness</head><p>The inheritance properties of logical relations suggest that it may be profitable to look for systematic ways of deriving properties at base types. Let f:D-*E be a continuous function between domains. We shall derive two relations from /which will be basic to all our subsequent work. We record some basic properties of these relations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Proposition</head><formula xml:id="formula_3">1. R f is inductive and S-monotone. If E has a top element, it is T-universal. It is strict iff f is (i.e. f ± D = ± E ) and X-reflecting iff f is (i.e. fa = ± E ^&gt;a = 1 D ). 2. R f is strict, inductive and L-monotone.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>For illustration, we prove inductiveness of R f . Suppose ^nd n Rfe n , i. A has a top. It is strict iff each f A is, and 1-reflecting if each f A is and R s is total. 2. Now let R L be induced from R^ = R fA . Then R L is strict, inductive and L-monotone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Combine 3.4 and 4.2. I We shall now investigate the provenance of Definition 4.1 a little more deeply. The reader should be aware that the material in the remainder of this section is not a prerequisite for the treatment of strictness and termination analysis in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Safety and liveness: a categorical view</head><p>For the remainder of this section, and also in Section 6, we shall assume familiarity with elementary category theory <ref type="bibr" target="#b9">[10]</ref> and lattice theory <ref type="bibr" target="#b23">[24]</ref>.</p><p>12/ Abstract Interpretation, Logical Relations, and Kan Extensions We return to our basic situation f-.D^E.</p><p>We shall associate two adjunctions with the continuous map f; they are both instances of Lawvere's adjunction between existential quantification and substitution. This is well-defined because f is continuous. This cuts down to an adjunction</p><formula xml:id="formula_4">P H D*=&gt;P H E,</formula><p>where P H is the Hoare powerdomain functor (see, for example, <ref type="bibr" target="#b20">[21]</ref>), iff f is strict.</p><p>The Abs and Cone maps in <ref type="bibr" target="#b0">[1]</ref> are obtained from the abs maps denned there precisely as the components of this adjunction. Our terminology arises from Plotkin's proposal to identify safety properties with closed sets. Note that </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">3jr(U) = ]{f(u)\ueU}</head><p>where \X = {y \ 3x eX -x^y).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">f~\V).</head><p>= {u e D |/(M) 6 V). This is well-defined because f is monotone (continuity is not needed here).</p><p>Note that this adjunction would fail if we replaced the Alexandrov-open by the Scott-open subsets. Indeed, by the Adjoint Functor Theorem, we know that f~l has a left adjoint iff it preserves meets; but inverse images of continuous maps do not in general preserve meets in the lattice of Scott-opens (in the language of topos theory, they are geometric but not logical morphisms).</p><p>If D, E are bounded-complete algebraic cpo's with bases K(D), K(E), then</p><formula xml:id="formula_5">R f \ (K(D) x K(E))</formula><p>is the approximate mapping associated with / in the sense of Scott <ref type="bibr" target="#b22">[23]</ref>.</p><p>We have:</p><formula xml:id="formula_6">1. L D R f L E 2. d^d'R f e'^ed&gt;dR f e. 3.</formula><p>dR f e u dR f e 2 ^&gt;Con(e u e 2 ) and dR f (e x Ue 2 ).</p><p>Our terminology arises from Plotkins's proposal to identify liveness properties with upper-closed sets (= intersections of Scott-open sets). Note that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Strictness and termination</head><p>We now turn to our specific analyses. For the remainder of this section, we fix a language L and a standard interpretation I, subject to the following assumptions:</p><p>1. The base types include bool. </p><formula xml:id="formula_7">A ^A = kx 2 • ky 2 • kz 2 • x A (y v z) ji^ = kx 2 • Xy 2 • kz 2 • x A y A Z.</formula><p>The intention is that we use S to infer that certain programs do not terminate (a safety property), and T to infer that certain programs do terminate (a liveness property). In order to formulate these notions precisely, we need to relate S and T to I. For each base type A, we define <ref type="bibr" target="#b11">[12]</ref> Now let R S A = R HALTA&gt; R T A = R™ LT \ are the logical relations induced from {R A }, {RA}- ft.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>JlOa</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Immediate from the definitions. I</p><p>We shall now check that the interpretations of constants in S and T are correctly related to those in I. It will be convenient to use the following observation: for any logical relation R:J-*K (•) fR ar ^...^OVa,,.</p><p>. ., a n • V6,, . . . , b H .</p><formula xml:id="formula_8">A?-i a^b, =&gt; (/fli • • • a n )R x (gb x • • • ^n),</formula><p>which is just a trivial manipulation of the definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Lemma</head><p>For each first-order constant c:a, with a = A x ^*. . . A H ^*B: </p><formula xml:id="formula_9">1. c'Rlc 3 . 2. c*R T o c T . Proof<label>1</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">similar I</head><p>Collecting these results together, we obtain:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Proposition</head><p>For all constants c: a of L:</p><p>1. c'Rlc 5 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">c'R T a c T .</head><p>Proof Combine 3.6, 5.3, and 5.4. I</p><p>We can now formulate our correctness criterion for strictness analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Correctness of S</head><p>V&lt;»: a-* x • Vp e Env', p' e Env s :pR s p'.</p><p>E s Mp'L%= ± s T =&gt;E'lelp±' a = ±' T . This says that, if e is strict under S, it denotes a strict function under the standard semantics. Thus we can soundly infer that a function is strict by testing for strictness in the non-standard finite domain D£_ T . This is the main result in <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.">Theorem</head><p>S is, correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof.</head><p>Let e, p, p' be given as in the statement of correctness. Now by 3.2 and 5.5, and ±' a Rl±l since R s is strict. Since R s is logical, this implies (Eie]p± l o )R s z (E s lelp'±%. But E s le}p'±l= ±$ by hypothesis, and since is R s 1 -reflecting, this implies E'MpL&gt; o =±.' x as required. I</p><p>We now turn to the correctness of T. What this means at higher types is less clear than for S, so we will only formulate it for first-order types. This says that if termination of the first argument of the function denoted by T guarantees termination of the result in T, then we may soundly infer that this property holds in the standard interpretation. This can obviously be generalized to combinations of arguments, but for notational simplicity, we shall use the above formulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7.">Theorem</head><p>T is correct.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Let e, p, p', a lt ..., a H be given as in the statement of correctness, and write o = A l -&gt;. ..A n -*B. Nowfl 1 #±i,^o 1 /ljf 1 l by 5.2 (ii), and a,R^0, l&lt;/:£ n, by 5.2 (i). Also, by 3. The reader is invited to compare the proofs in <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b0">[1]</ref> with the above arguments.</p><p>As a corollary of theorems 5.6 and 5.7, we obtain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.8.">The sandwich lemma</head><p>Vc :A, Vp e Env', p x e Env T , p 2 e Env s • pR T </p><formula xml:id="formula_10">p x A pR s p 2 =&gt; c E s le\p 2 .</formula><p>A program is a closed term of ground type. As an instructive and amusing consequence of 5.8, we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.9.">Theorem</head><p>The halting problem for programs with no occurrences of the conditional is decidable. As all domains are finite and the constants are explicitly tabulated, the fixpoints can be computed by successive approximations in the standard way. Thus, l HALT A (E'{ej) = V is recursive, since both E T and E s are. I</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Abstraction functions and Kan extensions</head><p>Our treatment of strictness and termination analysis exemplifies the following schematic approach. Let I be the 'standard' interpretation, and J the 'non-standard' or 'abstract' interpretation. First, we define abstraction functions for each base type A; then derive relations R A from f A ; and finally induce a logical relation R from the R A . In this section, we shall consider the possibility of defining abstraction functions at all types, starting from abs A =f A .</p><p>Intuitively, the idea is to pick out, from those abstract values related to a given concrete value, the 'best' one. One important application of such functions is to the interpretation of constants. Given a constant c a , with standard interpretation c' a , we want to define ci as the 'best possible' abstraction of c' a with respect to our relation R. If we have abstraction functions at all types, we can just set d a = abs a (c' o ).</p><p>We shall begin by developing a theory of abstraction functions in a rather general setting. Our theory will be based on the safety/liveness duality.</p><p>First, we need to consider a modified notion of interpretation. Given / = {{D' A }, {c' a }), our definition of {D' o } builds the continuous type structure over the {D' A }. We shall now consider the monotone type structure over I, MD' a , defined by is the poset of monotone maps from D to E, ordered pointwise. We also drop the stipulation that the base domains D' A are cpo's; they may be arbitrary posets.</p><p>Note that the notion of a relation, and the process of uniquely extending a relation on the base types to a logical relation, still make sense for monotone type structures (indeed in a very much greater generality-see, for example, <ref type="bibr" target="#b10">[11]</ref>), and Proposition 3.2 still holds good in this setting.</p><p>For the remainder of this section, we will make the following assumptions:</p><p>(Al) We are given interpretations I, J such that each iy A (hence each MD J a ) is a complete lattice. (A2) We are given monotone maps abs A :D' A ^DA for each base type A. On this basis, we shall define safety abstraction maps and liveness abstraction maps abs L a :MD l a -+MD J a for all a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Definition (i) abs s A = abs A absUJd = U {(abs T °f)a" \ abs a d' c d). (ii) abs^ = abs A</head><p>= II {{abs x »/)&lt;/' \ abs a d' 3 d).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Proposition</head><p>abs s m abSg are well-defined monotone maps for all a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction of a. The base case is given by our definitions. For the inductive step, we must show that abs^Jd, abs^-jd are monotone in both arguments-monotonicity in d is required for these functions to be well defined. We shall now establish a fundamental property of abstraction functions with respect to application. In order to interpret this result, note that as a Corollary we have that Thus abs s a uniformizes the relation Rl and, moreover, is the best possible function which does so, in the sense that, for each deD' o , abs%d) is the least element of the set {d' e D J a \ dRld'}. The situation for abs% is dual. The generality of our definitions and arguments to date will perhaps have made the reader suspect that what we are really doing is category theory. This suspicion is fully justified; what we have been doing is exactly the construction of Kan extensions for poset categories, albeit in an 'iterated' fashion which may be novel.</p><p>We shall now spell out the correspondence explicitly, since Kan extensions do not seem to have found their way into the Computer Science literature to date. Our reference for Kan extensions will be <ref type="bibr" target="#b9">[10]</ref>, pp. 232-34. We begin by stating the definitions for the special case where the categories are posets and the functors monotone maps. Lc=\J{Ta\KaQc}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition</head><p>Note that the problem of constructing a right Kan extension of T along K specializes to the problem of constructing a left adjoint of K when T = id. In this case, the formula (*) above specializes to the Adjoint Functor Theorem.</p><p>Dually, left Kan extensions specialize to right adjoints. Thus as MacLane remarks <ref type="bibr" target="#b9">[10]</ref>, pV): 'the notion of Kan extensions... is the deeper form of the basic construction of adjoints'.</p><p>We are now ready to spell out the correspondence with our construction of abstraction functions. The situation is</p><formula xml:id="formula_11">MD J a MDi</formula><p>The correspondence with the previous diagram is between abs a and K and (abs x °f) and T. The condition (LKE) for absi^^f) to be the left Kan extension of abs s a along aZw*°/then becomes Vg e MD J ^X -goabsl^abslof^g^absUJJ)-This is exactly the formula (t) which emerged in the proof of the Uniformization Theorem. The formula (**) for the pointwise construction of absi^j/fj) becomes abs%^Jc = \J{(abs s x °f)a | abs s x a^c} which is exactly our definition of a6s£_ T . The correspondence between abs^-, x and the right Kan extension goes through in the same way.</p><p>We have shown The connection with Kan extensions made by 6.5 is 'local' in character; it concerns the pointwise construction of abstraction maps.</p><p>From a more global point of view, we have the following situation:</p><p>T m {L) -?-* J I a diagram of Cartesian closed categories (CCC's) and CCC-morphisms. <ref type="foot" target="#foot_4">1</ref>Here T CCC (L) is the initial CCC over the language L, and E', E J are the (suitably factored) semantic functions induced by our interpretations I and J, viewed now as CCC's. We can consider the construction of Kan extensions for this situation; and we might hope that abs L = {absa}, abs s ={abs s }, viewed globally as putative CCC-morphisms, would provide such constructions. However, this is not the case; abs s and abs L are not functorial, but only 'semi-functorial', {lax in the two-categorical sense, cf. <ref type="bibr" target="#b8">[9]</ref>) in the sense of 6.3 and for the same reasons.</p><p>We shall now record the little we presently know about these global structures.</p><p>We </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>We prove (i) only. Necessity is obvious. For sufficiency, let R s be the logical relation induced from R S A = Rat, A . By the Uniformization theorem, R s a = R^s for all a. Hence by the hypothesis c^Rlci for all c a e L. Again, abs s °p'^p J iff p'RSp 1 . The result now follows from 3.2. I Note that the Sandwich Lemma (5.8) and Lemma 5.2 of <ref type="bibr" target="#b0">[1]</ref> are special cases of this result.</p><p>As a final remark on the global aspects of the abstraction maps, say that F = {F a } has the safety semi-homomorphism property if for all a, x and similarly the liveness semi-homomorphism property is F^JJ)F a (a)QF f (Ja). Now it is easy to see that, if F has the safety semi-homomorphism property, </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Continuous Kan extensions</head><p>We have developed a general theory of abstraction functions. However, for applications in abstract interpretation we are usually interested in the continuous rather than the monotone type structures; while for various reasons we may also wish the abstraction functions themselves to be continuous. This suggests two progressive requirements: We shall now investigate conditions for these requirements to be satisfied. For the rest of this section, we shall operate under the following additional assumptions:</p><p>(A3) Each D A , hence D' a is a bounded-complete algebraic cpo (i.e. a domain in the sense of <ref type="bibr" target="#b22">[23]</ref>). (A4) Each D^, hence each D J m is an algebraic lattice. (A5) Each abs A :D' A -+D A is continuous.</p><p>Based on these assumptions, we shall develop a rather complete theory of conditions under which (Cl.S) and (C2.S), or (Cl.L) and (C2.L) are satisfied. This theory maintains the duality between safety and liveness; and shows how power-domains arise inevitably when continuous abstraction maps are required.</p><p>We begin with safety.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7.">Definition</head><p>Let f-.D^E be a continuous map of algebraic cpo's. Then / satisfies property (F) iff it maps finite elements of D to finite elements of E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.8.">Proposition</head><p>Suppose each abs A satisfies (F). Then for all a, abs s a satisfies (F), (Cl.S), and (C2.S).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on a. The base case is given. For the inductive step, we must show:</p><p>(i) absl^Jd is continuous in d (this gives (Cl.S)), (ii) absi^Jd is continuous in f (this gives (C2.S)), (iii) /finite =&gt;absl^jfinite (this gives (F)). T (e n )]})d. I Note that the proof of (ii) did not use property (F). Thus we can draw the following:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.9.">Corollary</head><p>If abs s a satisfies (Cl.S) for all a, then abs s a satisfies (C2.S) for all a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.10.">Proposition</head><p>A necessary condition for abs s to satisfy (Cl.S) is that abs A satisfies (F) for all base types A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Suppose for some A, A necessary and sufficient condition for abs s to satisfy Cl.S and C2.S is that all abs A satisfy (F).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Notation.</head><label></label><figDesc>We write K(D) for the set of compact or finite elements of an algebraic cpo D. Given algebraic domains D, E and finite elements b e D,eeE, we write [b,e]:D-* c E for the step function defined by [b, e]x = {* otherwise If D, E are Scott domains, the finite elements of [D-&gt; C E] are the lubs of consistent (i.e. bounded) finite sets of step functions. Note. The present paper was completed in manuscript in October 1985, and circulated to a few researchers. An incomplete version (Sections 1-5 only) had previously (September 1985) been circulated under the title 'Strictness Analysis via Logical Relations'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>•</head><label></label><figDesc>D' A is a cpo (complete partial order) for each base type A. This is extended to D' a for all types a by D'^T=[D' O ^CD[] where [D-&gt; C E] is the cpo of all continuous functions from D to E, ordered pointwise. An interpretation I induces a semantic function E': A T (L) -&gt; Env'-* UD' O where Env' = {Env' a }, Env' a = E'lc T jp = c' x • e]p = A£ e D' o • E' E'\e x e^p = (£'[e 1 lp)( (Here p[x°&gt;-+d], for d e D' a is the environment in Env' such that Note that E'\e\p is in D' a if e has type a.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>4. 1 . Definition 1 .</head><label>11</label><figDesc>R f the safety relation derived from /: dRje O/d E e. 2. R f , the liveness relation derived from/: dR f e&lt;$fd^e.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>e. Vn/(d B )ge n . Then /(U d n ) = \Jf(d n )^\J e n . (This is the only part of the proposition which requires continuity of /.) I 4.3. Corollary 1. If f A :D' A -* iy A is a continuous map for each base type A, and R s is the logical relation induced from R A = R u , then: R s is inductive and S-monotone. It is T-universal (and hence total) if each D J</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>4. 4 .</head><label>4</label><figDesc>The safety adjunction CD s=5 CE. 1. CD, CE are the lattices (hence, categories) of Scott-closed subsets of D, E respectively. 2. 3f(B) = \f(b) | b 6 B}*, where X* is the Scott-closure of X. 3. f-\C) = {deD \f(d)eC}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>4. 5 .</head><label>5</label><figDesc>The liveness adjunction AD *=? AE. 1. AD, AE are the lattices of upper-closed (or 'Alexandrov-open') subsets of D, E respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>2 .</head><label>2</label><figDesc>The constants comprise: (a) recursion combinators Y (a _ a) _ CT , (b) conditionals cond bool ^A_ A ^A, (c) first-order functions c A ,... Am -. B ( n ^0). 3. D'too, is the three-point flat domain tt--ff. ± 4. I is a normal interpretation. 5. Conditionals are interpreted as usual: cond tt x y = x cond ff x y = y cond 1 x y = J. 6. First-order constants are interpreted as strict, total functions, i.e. for c: A,-*...A n ^B, c'a x . . . a n = ±' fl iff 3/: 1 &lt;/&lt;«• a, = ±' Al . (The assumption of totality-i.e. the left-to-right implication above^-is not used in the proof of correctness of strictness analysis. It is made to simplify the exposition.) We have two non-standard interpretations, S (for strictness) and T (for at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from 14/ Abstract Interpretation, Logical Relations, and Kan Extensions termination). For each base type A S and T are both least fixed point interpretations. For first-order constants c:Aj-*•.. . A n -*B, c s = c T = kx\... Xx 2 n • f\"-\Xi. S and T differ only (for our particular choice of constants) in their interpretations of conditionals</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>2 .Proof 1 .</head><label>21</label><figDesc>. Let a u ... a n , b x ,... b n be given as in (*), with Ai fl i^5A-We consider two cases: I. 3i:l^i^n-b, = 0. In this case, A/^ = 0» but since R s is J.reflecting, a ( = ±' Ah hence c'a x . .. a n = J-^iO since R s is strict. II. Vi:l ^i ^n • b ( = 1 in this case, /\ib, = \ and since R s is Tuniversal, c'a x . . . a n R%l. Again, let a u ..., a n , b u ... b n be given with /\, a^b, I. 3i: 1 =£ i =£ n • 6, = 0 In this case /\, b, = 0, and by 5.2 (i), c'a x . . . a n Rl0. II. VJ : 1 &lt; i &lt; n • b, = 1. In this case, A&lt; *&gt;/ = !&gt; but by 5.2 (ii), Vi: 1 &lt; il&lt;, n • a,^ Lit, and hence c'a x . . . a n =/ = ±' B (this is where totality of the first-order functions is used), and so c'a,.. . a H R T B \ by 5.2 (2) again. I 5.4. Lemma For each conditional cond: a, with a = bool-*A-*A-* A. 1. cond'R s a cond s . 2. cond'R T a cond T . Again let a u a 2 , a 3 , b x , b 2 , b 3 be given as in (*). We consider two cases: • /. b x = 0. Since R s is 1-reflecting , a, = li^, and cond'a x a 2 a 3 = • II. b x = 1. By T-universality of R s , we need only consider the case at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from 16/ Abstract Interpretation, Logical Relations, and Kan Extensions where b 2 = b 3 = 0. In this case, by J.-reflection a 2 = a 3 = ±.' A , and cond'a 1 a 2 a 3 = ±' A R A 0 = cond s b 1 b 2 b 3 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>at</head><label></label><figDesc>Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from Abstract Interpretation, Logical Relations, and Kan Extensions /17 Correctness of T V« :/!,-••• • A,-&gt; T • Vp e £m;', p' e Env T :pR T p'. E T le\p'10...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>lt ..., a H )Rl(E T lelp'10. . . 0) since\R T is logical. By hypothesis, EleJp'lO... 0 = 1, and so by 5.2 (ii) E l {e]pa l ...a n *±' B as required. I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>at</head><label></label><figDesc>Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from 18/ Abstract Interpretation, Logical Relations, and Kan Extensions Proof It is only in the interpretation of the conditional that S and T differ. Hence for a program e with no occurrences of the conditional E T le] = E s M and by the Sandwich Lemma HALT A (E'lel) = E T \e\ = E s le\.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>(</head><label></label><figDesc>I) absUjd Let X f , " = {(abs s z of)d' \ absW ^ d) which proves monotonicity in f. Again, d l c.d 2 ^Xf&gt;dt ^Xfd2 ^\_JX fidt ^\_\X fdw which proves monotonicity in d. at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from 20/ Abstract Interpretation, Logical Relations, and Kan Extensions (II) abs^Jd. Let Y f , d = {(abs L T °f)d' \ Then/cg=&gt;Vy e Y g , d • 3* 6 Y fd • xŵ hich proves monotonicity in f. Again, d x c d 2 =&gt; Y fw d , 2 Y fi dl which gives monotonicity in d. I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>6. 3 . 21 6. 4 .</head><label>3214</label><figDesc>The seml-homomorphlsfn property (i) (abs( ii) {abs L Diagrammatically AfD^r x MD' O " wV °"&gt; MD' t with (R) = 3 for safety, and (R) = c for liveness. Proof 1. (absUrfXabs^^UX, where X = {(afo?°/)a' | oZ»4a' c abs s x a). But (ofefo/)a e^r, so (a 2. Dual to (i). I We can now state a striking result which connects abstraction functions to logical relations in a very strong way. Let R s be the logical relation induced from Similarly, define R L as the logical relation induced from RT hen we have at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from Abstract Interpretation, Logical Relations, and Kan Extensions / The uniformlzatlon theorem For all a (i) R S o = (ii) R L o = Proof (i) By induction on a. The base case is given from the definitions. At the inductive step, we must show i.e. [Va, b • aR s o b =&gt; faR s x gb] O absU or equivalently, using the inductive hypothesis [Va, b • absUQ b =&gt;(abs s T °f)ag The left-hand side of this equivalence reduces to (*)Vfl • (abs s T °f)a^(g ° abs%)a. To see that it implies (*), take b = abs a a, while the converse follows from the monotonicity of g. So what we must prove is (t) abs s r of&lt;zgoabs s a &amp;absUJJ)^gabsi(fa) Q {abs%^. x f)(abs s a a) by the semi-homomorphism property, by hypothesis. where A' = {(afeifo/)6 | abs a b By hypothesis, \/b • absib&lt;Za^&gt;(abs s x o f)b^(jg°abs^)b^ga, so go is an upper bound for X. Hence absi^Ja c ga. (ii) Dual to (i). I</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>LetM</head><label></label><figDesc>--&gt;A be a diagram of posets and monotone maps. A right Kan extension of T along K is a monotone map R:C^mA satisfying 1. R°KQT. 2. VS:C-» m A. S°KQT^&gt;SQR. Dually, a left Kan extension of T along K is a monotone map L:C^mA satisfying. 3. L°K^T. 4. V5:C-» m A. S°K^T^&gt;S^L. Conditions (1) and (2) are easily seen to be equivalent to (RKE) VS:C-+ m A. S and similarly (3) and (4) are equivalent to (LKE) VS:C-&gt; m A S Now suppose that A is a complete lattice. The formula for computing the right Kan extension as a pointwise limit-MacLane's equation (3) on p. 234 becomes Dually, the left formula for the left Kan extension reads (**)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>6. 5 . Observation 1 .</head><label>51</label><figDesc>abs^iij) is the left Kan extension of abs s x °f along abs s a . 2. abs^-Xf) is the right Kan extension of abs x °f along abs%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>at</head><label></label><figDesc>Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from Abstract Interpretation, Logical Relations, and Kan Extensions / 25 then while if F has the liveness semi-homomorphism property then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>(</head><label></label><figDesc>Cl.S) The functions abs s a :D' o ^&gt;D J a are well-defined on the continuous type structure. (C2.S) The functions abs s a from (Cl.S) are continuous. Similarly we have (Cl.L) The functions are well-defined. (C2.L) The functions of (Cl.L) are continuous.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>(i) Continuity in d. As we have already shown that absi^T is monotonic in f and d, we need to show that rt-0 n-0 i.e. L where X = {(abs s x °f)d' \ abs s a d' e U d n ) Now it is sufficient to show that for every finite b^\_\X, 3n • bQ\_JX H . Given such a b, note that bt(abs s x °f)d' =&gt;Bfinite b' -b'^d' &amp;b^{abs s x °f)b' since abs s x is continuous by inductive hypothesis. Now abs s a b' ^abs s a d' Q LJd n , and since by inductive hypothesis abs s a satisfies (F), abs s a b' is finite. Hence 3n • abs s a b' (= d n and b c|j X n , as required, (ii) Continuity in f. Again, we only need to show f Once again we consider any finite b Q LJ Y. Note that $° LJ f n )d' = LJ iflbs s t °fn )d' since abs s x is continuous by IH absi^z satisfies (F). Let / = \J{[b u e x ],..., [b n , e n ]}, for step functions [b,, e,]. We claim that absUj = U {[absUbJ, abs^e,)],. . ., [abs%b m ), abs%e H )]}. First, by inductive hypothesis abs s a and abs s x both satisfy (F), so abs s jjo,), absr(e,) are finite, i = 1,.. ., n. Now absUrfd = U {(abs s x °f)d' \ absW £ d) = U{abs x (e l )\abs s a b l ^d} = (U {[absfibr), absfa)], . . ., [abs%b n ,)abs s</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>abs A does not satisfy (F). Then for some finite b eD' A abs A (b) = d = |_| d n an infinite lub of finite elements. Now we consider two cases. Case 1. abs A is a constant function. Then abs A ^Aid DU d = U {d} = d while for all n so abs A ^.A does not satisfy (Cl.S). Case 1 If abs A is not a constant function, for some finite eeD^we must have abs A (e) ¥= abs A (±). Now abs s A ^A[b, e]d = abs A (e) while for all n abs s A ^A[b, e]d n &lt;z\J {abs A ( 1)} = abs A (±). Thus abs A ^,A does not satisfy (Cl.S) in this case either. I We summarize our progress so far in 6.11. Theorem</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>3.2. Proposition Let</head><label></label><figDesc>#:/-•/ be a logical relation. Suppose that c' a R a c J o for all constants c a . Then: Ve: oVp e Env', p' e Enxr 1 (Here pRp' means Vx T • px T R x p'x z .)</figDesc><table><row><cell>Abstract Interpretation, Logical Relations, and Kan Extensions / 9 10/ Abstract Interpretation, Logical Relations,</cell><cell></cell></row><row><cell>Proof</cell><cell></cell></row><row><cell>By induction on e. The cases for variables and constants are immediate from</cell><cell></cell></row><row><cell>the hypothesis. For e = e 1 e 2 . e x :o-+ x, e 2 :a by induction hypothesis J Mp') and {E\e^p)R a {E J le^p'), so since R is logical For e = kx a e 1 :a^x let d x e D' a , d 2 eDi with d^R a d 2 . Then pRp' so by induction hypothesis</cell><cell>Downloaded from Downloaded from</cell></row><row><cell>Since R is logical, this implies 3.3. Definition R inherits P if R A satisfies P A for all base types A, implies that R a satisfies P a for all types a. We now list some properties of relations R:/-*J 1. Strictness: 2. Inductiveness: For all chains {x n } in D' a , {y n } in Z&gt;i:[Vn • x n R a y n ]^\Jx n R a Uy n . 3. X-reflection: 4. T-universality: Let P = {P a } be a property of relations.</cell><cell>at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/</cell></row><row><cell>3.1. Definition Each D^, has a top element T^, (and thus each iy a has a T^) and</cell><cell></cell></row><row><cell>xR a Tl A relation R.I-+J is a family {R a }, with fi o cD',x Di. 5. S-monotonicity: A relation is logical [PLO73] if for all a, x: x^x'R a y'zyd&gt;</cell><cell></cell></row><row><cell>( * )fR^£ O [Va 6 D' a , beDi-aR a b z&gt; faR z gb]. 6. L-monotonicity:</cell><cell></cell></row><row><cell>Clearly, any family R A of relations on the base types can be extended x?x'R a y'^y^&gt;</cell><cell></cell></row><row><cell>uniquely to a logical relation by using (*) as a definition. We say that a relation fl c AT x Y is total if VJC e JT • 3y e Y • xRy</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>and Kan Extensions 3.4. Proposition Every</head><label></label><figDesc>logical relation inherits 1, 2 and 4-6. Every total logical relation inherits 3.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>shall say that F = {F o }</figDesc><table><row><cell>is a safety morphism if</cell></row><row><cell>Ve: a e A r (L) • Vp' e Env' • Vp 7 € Em/</cell></row><row><cell>Fop&gt;&lt;zp'd&gt; F a (E'lelp') c E J \e\p J .</cell></row><row><cell>Dually, G is a liveness morphism if</cell></row><row><cell>Ve: a e A r (L) • Vp 7 e Env 1 • Vp 7 e Env 1</cell></row><row><cell>Gop'op'=&gt; G</cell></row></table><note><p><p>a (E'lelp') =! E J \e\p'.</p>Note that, if every d e U D' a is denoted by some closed term (or if the domains D' o are algebraic and every compact element is denoted by some closed term) then every safety morphism approximates every liveness morphism (where F^G = \/ a F a QG a ). Now we have: 6.6. Theorem 1. abs s is a safety morphism iff for all constants c a e L, absKci) cc£. 2. abs L is a liveness morphism iff for all c o e L, abs%(c' a ) 3 c\.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_0"><p>© Oxford University Press at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>g ,:a-&gt;Te 2 :g e,e 7 : x Semantics of typed A-calculus: interpretation An interpretation I of a language L is specified by at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>where for posets D, E at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_4"><p>Actually, this is somewhat imprecise, as we have not introduced product types. However, our remarks in this paragraph should be sufficiently dear, at least at a heuristic level.at Freie Universitaet Berlin onMay 15,  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2014" xml:id="foot_5"><p>http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>This immediately yields b Q Y n as required. at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_7"><p>f (e) = {de where CU(D) is the set of compact, upper-closed subsets of D, is well defined. Note that in terms of the liveness adjunction of Section 4. Once again, we recall a few definitions and facts about powerdomains. at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_8"><p>A (d)c }C and for all finite FcC, 6 A (d)£ \F. We now define a sequence of functions f n :D' A -*D' A at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_9"><p>Received 1 September 1989 at Freie Universitaet Berlin on May 15, 2014 http://logcom.oxfordjournals.org/ Downloaded from</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The idea of using a formalism based on logical relations for abstract interpretation was inspired by a suggestion of Alan Mycroft's <ref type="bibr" target="#b14">[15]</ref>. The theory of abstraction maps developed in Section 6 grew from my joint work with Geoffrey Burn and Chris Hankin on the specific case of strictness analysis <ref type="bibr" target="#b0">[1]</ref>. In particular, Geoff deserves credit for having originally proposed the formulas for the abstraction maps. The connection with Kan extensions emerged from one of uncountably many conversations with Axel Poign6 on matters categorical.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>28/ Abstract Interpretation, Logical Relations, and Kan Extensions</head><p>We shall now connect our discussion of continuity of abs s with the use of powerdomains in abstract interpretation. We begin by recalling some basic facts and definitions. Now suppose we are given a continuous map f:D-*E between algebraic domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.13.">Definition</head><p>The concretization map associated with f is</p><p>This map is always well-defined (this requires the presence of the empty set in the powerdomain) and monotonic. Note thaf</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Yf(e)=r\{e}*)</head><p>in terms of the safety adjunction of Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.14.">Proposition</head><p>Y/ is continuous iff f satisfies (F). Now suppose that f does not satisfy (F). Then for some finite b e D, fb = \_\e n , an infinite lub of finite elements. Now b e yyflj e n ), but for all n, b$Yf( e n), so for all n, {b}* &lt;£y f (e n ). Since {b}* is a finite element of P°H(D), this implies {b}* £ LC-o y/(««), and so y r is not continuous. I Note that if absl, abs$, Yatai are continuous, and if / is a continuous map from D' a to D y a we can define (PDS)&lt;p(f) = U -P°H(abs x of)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L</head><p>We have</p><p>Moreover, in this case absl^x is clearly continuous. Thus we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.15.">Theorem</head><p>A necessary and sufficient condition for abs s to satisfy Cl.S and C2.S is that it can be defined by (PDS) via the Hoare powerdomain. We now turn to liveness, our treatment of which will parallel that for safety. Once again, we consider the basic situation f:D-&gt;E, /a continuous map of algebraic domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.16.">Definition</head><p>/satisfies property (C) iff, for all e e E, {deD\fd^e} is Scott compact; i.e. there is a finite set {b u ..., b k ) of finite elements of D such that every d e D with fd^e is above one of the b t .</p><p>Note that the above set is always upper-closed. Thus property (C) is equivalent to saying that the map 6.17. Definition (i) PI is the Smyth powerdomain functor (with empty set)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P°s(f)X=\{fx\xeX).</head><p>(ii) For any algebraic lattice L, the greatest lower bound operation, viewed as a function is continuous and \~\ L (\X) = \~\X. (iii) For any Scott domain (and more generally, any coherent algebraic cpo <ref type="bibr" target="#b23">[24]</ref>) P%(D) is closed under finite intersections and unions, and intersections of 3-chains. Now suppose that/:£&gt;-•£ satisfies property (C). Then 6 f :E-*P°s(D) is well defined. Moreover, we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.19.">Proposition</head><p>Suppose that abs A satisfies (C) for all base types A. Then for all a, absŝ atisfies (Cl.L), (C2.L), and (C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on a. The base case is given. For the inductive step, assume g, abs!; are continuous and satisfy (C). Then S^L is well-defined and continuous, and we have so abs^T satisfies (Cl.L) and (C2.L). Moreover, from 6.18 and 6.17 which is Scott-compact using 6.17 (iii) again. I</p><p>We now turn to the necessity of (C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.20.">Proposition</head><p>A necessary condition for abs L to satisfy (Cl.L) and (C2.L) is that all the base maps abs A satisfy (C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Suppose some abs A has a point d e D J A such that 6 A (d) is not Scott-compact. Note that in this case abs A cannot be a constant function, so for some finite eeD' A ,abs A (e)^abs A (±). Now failure of Scott-compactness for 6 A (d) means there is an infinite set of finite elements C= {c 0 , c u . . .} such that by</p><p>(the lubs being taken here are easily seen to be consistent, so this is well-defined).</p><p>Then</p><p>while for all n</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>abs^Af n d, n {abs A (e) = abs A (±)} = abs A (±)</head><p>so abs A -. A does not satisfy (C2.L). I We can summarize our results on liveness in two theorems parallel to 6.11 and 6.15.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.21.">Theorem</head><p>A necessary and sufficient condition for abs L to satisfy Cl.L and C2.L is that all base maps satisfy (C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.22.">Theorem</head><p>A necessary and sufficient condition for abs L to satisfy Cl.L and C2.L is that it can be defined by (PDL) via the Smyth powerdomain.</p><p>We have been at pains throughout our exposition to emphasize the thoroughgoing duality between safety and liveness. We now record an important difference between them. Recall that in Corollary 6.9 we observed that if abs s is well-defined over the continuous type structure, it is continuous. Thus properties (Cl.S) and (C2.S) are in fact not separable. However, for liveness this is not the case. As a counter-example, we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.23.">Theorem</head><p>The HALT A maps of Section 5 do not satisfy (C) unless D' A is finite. However, because each D J A is finite, MDi = Di for all a, and abs L satisfies (Cl.L).</p><p>Note that the HALT A maps trivially satisfy property (F).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.24.">Proposition</head><p>If each abs A has finite image, then for all oabSg satisfies (Cl.L) and has finite image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>By induction on a. The base case is given. For the inductive step, we show:</p><p>(i) abs^Tf is continuous, for all / € D^x. </p><p>Note that /m abs^xf c Z for all / e D^T Thus for all / e factors as where s is the canonical surjection and i the inclusion. This gives a map which is injective, since s and i are defined uniformly over all f. Thus card(Im abs^) &lt; cardiZ^-').</p><p>But D J J ~o is finite since Im abs^ is finite by inductive hypothesis, and l ({x}) \xeImabs L o &amp;x^d) and so the size of Im 5 a is bounded by the number of subsets of Im absg. Similarly, Z is finite. Thus Z 01 '* 0 is finite and so Im abs^, x is. I</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.25.">Proposition</head><p>If abs^ has infinite image on a chain in D' a , and abs x is not continuous, then ^,T does not satisfy (Cl.L).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>We are given {b n } in D' a such that {abs^(b n )} is infinite, and {d n } in D' x such that abs^U:.o d n ) t l_i:«o abs L x (d n ). For all n, Thus afc^t/ U c = ateJ(U rf.) S U:-o abs^{d n ) 5 U:_o abs L ^Jc n and so tfis not continuous and abs^. z does not satisfy (Cl.L). I</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.26.">Proposition</head><p>If abs A has infinite image, and finite image on all chains, then either 1. abs^A has infinite image on a chain in D' A ^.A , or 2. abs A ^A does not satisfy (Cl.L).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof</head><p>Since abs A has finite image on all chains and is continuous, Then {d n } will be the infinite chain in Imabs A . Let Z 0 ={zg, ..., z°, . . .} c/mafos,, be some infinite sequence. By (ft), 3&amp;{z°|z°cz°} is infinite. Let d 0 = z». Z x = {z°e \ z\ c z°} -{z2}.</p><p>At the (n + l)-th stage, apply (ft) to Z n similarly to produce d n+1 , Z n+l . I</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now let A = {abs^YW Ud n ) and take a e D A with abs{a)±abs A (±.) and define f:D A ^D' A by</head><p>Since A is open, f is continuous. Now</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vn°abs A ^Afd n = abs A (±) while abs^AfUd n =abs A (a)</head><p>and so abs A ^A does not satisfy (Cl.L), establishing (2). I</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.27.">Theorem</head><p>Suppose some abs B does not satisfy (C). Then a necessary and sufficient condition for abs L to satisfy (Cl.L) is that all abs A have finite image. Sufficiency is Proposition 6.24. For necessity, we suppose abs A has infinite image and consider a number of cases. By the proof of Proposition 6.20, the map abs B ^*B is not continuous. Case 1 abs A has infinite image on a chain. In this case we can apply Proposition 6.25 with a = A, x = B-^B. Case 2 abs A is finite on all chains. There are the two subcases according to Proposition 6.26. Subcase 2.1 abs A ^,A has infinite image on a chain. In this case, apply proposition 6.25 with o = A -*A, r = B^*B. Subcase 2.2 abs A ^,A does not satisfy (Cl.L) hence abs L does not. I</p><p>We can summarize out results as follows:</p><p>Tl abs s satisfies (Cl.S) and (C2.S) iff all abs A satisfy (F). Moreover, if abs s satisfies (Cl.S), it satisfies (C2.S). T2 abs L satisfies (Cl.L) and (C2.L) iff all abs A satisfy (C). T3 Suppose some abs B does not satisfy (C). Then abs L satisfies (Cl.L) iff all abs A have finite image. T4(i) abs s satisfies (Cl.S) and (C2.S) iff it is definable via the Hoare powerdomain. T4(ii) abs L satisfies (Cl.L) and (C2.L) iff it is definable via the Smyth powerdomain.</p><p>We now list some open problems and directions arising from the work of this section:</p><p>1. Extend the continuity theory by weakening the assumptions, particularly (A3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conjecture. All the results go through with (A3'). Each D' A is SFP.</head><p>There is perhaps some mathematical interest in developing a theory of continuous Kan extensions. 2. Characterize the conditions under which the situation of 6.23 arises, i.e. abs L defined on the continuous type structure but not itself continuous.</p><p>Question. Can this happen if J is an infinite interpretation? 3. Extend the framework to richer type structures (sums, products, recursive types, etc). (Much of this has already been done, at least as regards safety analysis, by Neilson <ref type="bibr" target="#b17">[18]</ref>.) 4. Generalize the framework, e.g. to arbitrary ccc's. 5. Develop the ideas discussed at 6.6.</p><p>We shall conclude with an example of the application of our theory. We return to the analyses of Section 5, and show that the abstract interpreta- tions of the constants are not merely correctly related to the standard interpretations (as shown in 5.3 and 5.4) but best possible.</p><p>Let abs s , abs L be the safety and liveness abstraction maps induced from the HALT A . (Note that abs s is exactly the family of maps defined in <ref type="bibr" target="#b0">[1]</ref>, the definitions used there being an instance of the (PDS) scheme at 6.15 above.)</p><p>The following lemma will be useful in our calculations. It is analogous to the formula (*) preceding 5.3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Totality analysis</head><p>The termination analysis presented in Section 5 is of rather questionable In this section we consider a more natural, and indeed very canonical notion of totality, and use our framework to derive an effective, finite approximation to ti.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition</head><p>We define a unary logical relation Tot on the standard interpretation D' by JJ) O Vd € D a • Tot^d) z&gt; Tot t (/H). This is the property of (hereditary) totality; cf. <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>.</p><p>It is well known that the logical complexity of Tot, even on the computable elements of /, is unbounded in the analytical hierarchy <ref type="bibr" target="#b21">[22]</ref>. This makes it somewhat remarkable that complete information on Tot can be obtained from our abstraction maps abs L , and finite abstract domains D L . (To avoid confusion, note that we are not claiming that complete information can be obtained by the abstract interpretation; rather, that taking the standard interpretation and then applying the abstraction map-which by this very result is shown to be highly non-computable-does not lose any information.)</p><p>We define i a e D% by induction on a We can now define totality analysis: for any (closed) term M:a, we infer that M is total if</p><p>The following proposition establishes the soundness of this analysis:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Proposition</head><p>Proof Combine Proposition 7.1 and Theorem 6.6. I</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Strictness analysis for higher order functions</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Burn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Hankin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="249" to="278" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Abstract Interpretation: A unified lattice model for static analysis of programs by construction of approximation of fkpoints, 4th POPL</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cousot</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Strictness analysis-a practical approach</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Clack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Peyton</surname></persName>
		</author>
		<author>
			<persName><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IFIP Symposium on Functional Programming Languages and Computer Architecture</title>
		<meeting>IFIP Symposium on Functional Programming Languages and Computer Architecture</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="middle">L</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><surname>Ershov</surname></persName>
		</author>
		<title level="m">Model C of the Partial Continuous Functionals</title>
		<imprint>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">System F of variable types, fifteen years later</title>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical computer Science</title>
		<imprint>
			<biblScope unit="page" from="159" to="192" />
			<date type="published" when="1986">1986</date>
			<pubPlace>North Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Semantic domains. To appear in Handbook of Theoretical Computer Science</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>North Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Higher-order strictness analysis in untyped lambda calculus</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th POPL</title>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Strictness detection in non-flat domains</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the DIKU Workshop on Programs as Data Objects</title>
		<meeting>the DIKU Workshop on Programs as Data Objects</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">217</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Review of the elements of 2-categories</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Street</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Category Seminar</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Dold</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Eckmann</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">420</biblScope>
			<date type="published" when="1974">1974</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Categories for the Working Mathematician</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Mac</forename><surname>Lane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971">1971</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Semantics of types. To appear in Handbook of Theoretical Computer Science</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>North Holland</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The theory and practice of transforming call-by-need into call-byvalue</title>
		<author>
			<persName><surname>Mycroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International symposium on Programming</title>
		<meeting>the 4th International symposium on Programming</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Abstract Interpretation and Optimising Transformations for Applicative Programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mycroft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Strong abstract interpretation using power domains</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mycroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 1983</title>
		<title level="s">LNCS</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="volume">154</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A relational framework for abstract interpretation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mycroft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
	<note>Unpublished, handwritten notes</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A relational framework for abstract interpretation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mycroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the DIKU Workshop on Programs as Data Objects</title>
		<meeting>the DIKU Workshop on Programs as Data Objects</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">217</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">A Denotational Framework for Data Flow Analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Strictness analysis and denotational abstract interpretation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Information and Computation</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="92" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Lambda Definability and Logical Relations</title>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973">1973</date>
		</imprint>
		<respStmt>
			<orgName>Department of AI, University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Seldin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hindley</surname></persName>
		</author>
		<title level="m">To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism</title>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Lecture Notes on Domain Theory</title>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Data types as Lattices</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="522" to="587" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Domains for Denotational Semantics</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 1982</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">140</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Topology via Logic. Cambridge Tracts in Theoretical</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vickers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<date type="published" when="1989">1989</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A new strictness detection algorithm</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Implementation of Functional Languages</title>
		<meeting>the Workshop on Implementation of Functional Languages<address><addrLine>Aspenaes, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
