<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Deriving Metric Thresholds from Benchmark Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Tiago</forename><forename type="middle">L</forename><surname>Alves</surname></persName>
							<email>t.alves@sig.eu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Software Improvement Group Amsterdam</orgName>
								<orgName type="institution">University of Minho</orgName>
								<address>
									<settlement>Braga</settlement>
									<country>The Netherlands, Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christiaan</forename><surname>Ypma</surname></persName>
							<email>c.ypma@sig.eu</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Software Improvement Group Amsterdam</orgName>
								<orgName type="institution">Utrecht University Utrecht</orgName>
								<address>
									<country>The Netherlands, The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joost</forename><surname>Visser</surname></persName>
							<email>j.visser@sig.eu</email>
							<affiliation key="aff2">
								<orgName type="laboratory">Software Improvement Group Amsterdam</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Deriving Metric Thresholds from Benchmark Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0EDF7A87E944A2531B6329BDE8EA9F67</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A wide variety of software metrics have been proposed and a broad range of tools is available to measure them. However, the effective use of software metrics is hindered by the lack of meaningful thresholds. Thresholds have been proposed for a few metrics only, mostly based on expert opinion and a small number of observations.</p><p>Previously proposed methodologies for systematically deriving metric thresholds have made unjustified assumptions about the statistical properties of source code metrics. As a result, the general applicability of the derived thresholds is jeopardized.</p><p>We designed a method that determines metric thresholds empirically from measurement data. The measurement data for different software systems are pooled and aggregated after which thresholds are selected that (i) bring out the metric's variability between systems and (ii) help focus on a reasonable percentage of the source code volume. Our method respects the distributions and scales of source code metrics, and it is resilient against outliers in metric values or system size.</p><p>We applied our method to a benchmark of 100 object-oriented software systems, both proprietary and open-source, to derive thresholds for metrics included in the SIG maintainability model.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Software metrics have been around since the dawn of software engineering. Well-known source code metrics include lines of code, the McCabe complexity metric <ref type="bibr" target="#b0">[1]</ref>, and the Chidamber-Kemerer suite of object-oriented metrics <ref type="bibr" target="#b1">[2]</ref>. Metrics are intended as a control instrument in the software development and maintenance process. For example, metrics have been proposed to identify problematic locations in source code to allow effective allocation of maintenance resources. Tracking metric values over time can be used to assess progress in development or to detect quality erosion during maintenance. Metrics can also be used to compare or rate the quality of software products, and thus form the basis of acceptance criteria or service-level agreements between software producer and client.</p><p>In spite of the potential benefits of metrics, their effective use has proven elusive. Metrics have been used successfully for quantification, but have generally failed to adequately support subsequent decision-making <ref type="bibr" target="#b2">[3]</ref>.</p><p>To elevate the use of metrics from measurement to decisionmaking, it is essential to define meaningful threshold values. These have been defined for some metrics. For example, McCabe proposed a threshold value of 10 for his complexity metrics, beyond which a subroutine was deemed unmaintainable and untestable <ref type="bibr" target="#b0">[1]</ref>. This threshold was inspired by experience in a particular context and not intended as universally applicable. For most metrics, thresholds are lacking or do not generalize beyond the context of their inception.</p><p>In this paper, we present a method to derive metric threshold values empirically from the measurement data of a benchmark of software systems. The measurement data for different software systems are first pooled and aggregated. Then thresholds are determined that (i) bring out the metric's variability between systems and (ii) help focus on a reasonable percentage of the source code volume.</p><p>We designed our method with several requirements in mind to avoid the problems of thresholds based on expert opinion and of earlier approaches to systematic derivation of thresholds.</p><p>1) The method should not be driven by expert opinion but by measurement data from a representative set of systems (data-driven); 2) The method should respect the statistical properties of the metric, such as metric scale and distribution and should be resilient against outliers in metric values and system size (robust); 3) The method should be repeatable, transparent and straightforward to carry out (pragmatic).</p><p>In our explanation of the method the satisfaction of these requirements is addressed in detail. This paper is structured as follows. Section II presents an overview of earlier attempts to determine thresholds. Section III demonstrates the use of thresholds derived through our method, taking the McCabe complexity metric as example. In fact, this metric is used as a vehicle throughout the paper for explaining and justifying our method. Section IV provides an overview of the method itself. Section V describes our benchmark data. Section VI provides a detailed explanation of key steps of the method. Section VII discusses variants of the method and possible threats. Section VIII provides evidence of the wider applicability of the methodology by generalization to other metrics included in the quality model <ref type="bibr" target="#b3">[4]</ref> of the Software Improvement Group (SIG). Finally, Section IX provides conclusions and directions of future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>In this section we review previous attempts to define metric thresholds. We start by describing works where thresholds are defined by experience. Then, we analyze in detail methodologies that derive thresholds based on data analysis, which are directly related to our methodology. We provide an overview about methodologies that derive thresholds based on error information and from cluster analysis. Finally, we discuss techniques to analyze and summarize metric distributions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Thresholds derived from experience</head><p>Many authors defined metric thresholds according to their experience. For example, for the McCabe metric 10 was defined as the threshold <ref type="bibr" target="#b0">[1]</ref>, and for the NPATH metric 200 was defined as the threshold <ref type="bibr" target="#b4">[5]</ref>. Above these values, methods should be refactored. For the Maintainability Index metric, 65 and 85 are defined as thresholds <ref type="bibr" target="#b5">[6]</ref>. Methods whose metric values are higher than 85 are highly-maintainable, between 85 and 65 are moderately maintainable and, smaller than 65 are difficult to maintain. Since these values rely on experience, it is difficult to reproduce or generalize these results. Also, the lack of scientific support can lead to dispute about the values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Thresholds from metric analysis</head><p>Erni et al. <ref type="bibr" target="#b6">[7]</ref> propose the use of mean (µ) and standard deviation (σ) to derive a threshold T from project data. A threshold T is calculated as T = µ + σ or T = µσ when high or low values of a metric indicate potential problems, respectively. This methodology is a common statistical technique which, when data is normally distributed, identifies 16% of the observations. However, Erni et al. do not analyze the underlying distribution, and only apply it to one system (albeit using three releases). The problem with this methodology is that the assumption of metrics that are normally distributed is not justified, invalidating the use of this methodology. Consequently, there is no guarantee that 16% of observations will be identified as problematic code. For metrics with high values and high variability, this methodology will identify less than 16% of code, while for metrics with low values or low variability, this methodology will identify more than 16% of code. In contrast, our approach does not make assumption about data normality. Moreover, we apply our methodology to 100 projects, both proprietary and open-source.</p><p>French <ref type="bibr" target="#b7">[8]</ref> also proposes a methodology based on the mean (µ) and standard deviation (σ) but using additionally the Chebyshev's inequality theorem (whose validity is not restricted to normal distributions). A metric threshold T can be calculated by T = µ + k × σ, where k is the number of standard deviations. According to Chebyshev's theorem, for any distribution 1/k 2 is the maximal portion of observations outside k standard deviations. As example, to identify a 10% maximum of code, we determine the value of k by resolving 0.1 = 1/k 2 . However, French proposes to divide the Chebyshev formula by two which is only valid for two-tailed symmetric distributions. The assumption of two-tailed symmetric distributions is not justified. For one tailed distributions, the Cantelli's formula, 1/(1 + k 2 ), should have been used instead. Additionally, this methodology is sensitive to large numbers or outliers. For metrics with high range or high variation, this technique will identify a smaller percentage of observations than its theoretical maximum. In contrast, our methodology was designed to derive thresholds from benchmark data and such is resilient to high variation of data our outliers. Also, while French applies the technique to eight Ada95 and C + + systems, we use 100 Java and C# systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Thresholds using error models</head><p>Shatnawi et al. <ref type="bibr" target="#b8">[9]</ref> investigate the use of Receiver-Operating Characteristic (ROC) method to identify thresholds to predict the existence of bugs in different error categories. They perform an experiment using the Chidamber and Kemerer (CKD) metrics <ref type="bibr" target="#b1">[2]</ref> and apply the technique to three releases of Eclipse. Although <ref type="bibr">Shatnawi et al.</ref> were able to derive thresholds to predict errors, there are two drawbacks in their results. First, the methodology does not succeed in deriving monotonic thresholds. Second, for different releases of Eclipse, different thresholds were derived. In comparison, our methodology is based only in metric distribution analysis, it guarantees monotonic thresholds and the addition of more systems causes only negligible deviations.</p><p>Benlarbi et al. <ref type="bibr" target="#b9">[10]</ref> investigate the relation of metric thresholds and software failures for a subset of the CDK metrics using linear regression. Two error probability models are compared, one with threshold and one without. For the model with threshold, zero probability of error exists for metric values below the threshold. The authors conclude that there is no empirical evidence supporting the model with threshold as there is no significant difference between the models. El Eman et al. <ref type="bibr" target="#b10">[11]</ref> argue that there is no optimal class size based on a study comparing class size and faults. The existence of an optimal size is based on the Goldilocks conjecture which states that the error probability of a class increases for a metric values higher or lower a specific threshold (resembling a U-shape). The studies of Benlarbi et al. <ref type="bibr" target="#b9">[10]</ref> and El Eman et al. <ref type="bibr" target="#b10">[11]</ref> show that there is no empirical evidence for the threshold model used to predict faults. However, these results are only valid for the specific error prediction model and for the metrics the authors used. Other models can, potentially, give different results. In contrast to using errors to derive thresholds, our methodology derives meaningful thresholds which represent overall volume of code from a benchmark of systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Thresholds using cluster techniques</head><p>Yoon et al. <ref type="bibr" target="#b11">[12]</ref> investigate the use of the K-means Cluster algorithm to identify outliers in the data measurements. Outliers can be identified by observations that appear either in isolated clusters (external outliers), or by observations that appear far away from other observations within the same cluster (internal outliers). However, this algorithm suffers from several shortcomings: it requires an input parameter that affects both the performance and the accuracy of the results, the process of identifying the outliers is manual, after identifying outliers the algorithm should be executed again, and if new systems are added to the sample the thresholds might change significantly. In contrast, our methodology accuracy is not influenced by input parameters, it is automatic, and stable (the addition of more systems results only in small variation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Methodologies for characterizing metric distribution</head><p>Chidamber and Kemerer <ref type="bibr" target="#b1">[2]</ref> use histograms to characterize and analyze data. For each of their 6 metrics, they plotted histograms per programming language to discuss metric distribution and spot outliers in two C++ projects and one Smaltalk project. Spinellis <ref type="bibr" target="#b12">[13]</ref> compares metrics of four operating system kernels: Windows, Linux, FreeBSD and OpenSolaris. For each metric, box plots of the four kernels are put side-byside showing the smallest observation, lower quantile, median, mean, higher quantile, highest observation and identify outliers. The box-plots are then analyzed by the author and used to give ranks, + or -, to each kernel. However, as the author states, ranks are given subjectively. Vasa et al. <ref type="bibr" target="#b13">[14]</ref> proposes the use of Gini coefficients to summarize a metric distribution across a system. The analysis of the Gini coefficient for 10 class-level metrics using 50 Java and C# system revealed that most of the systems have common values. More, higher Gini values indicate problems and, when analyzing subsequent releases of source code, a difference higher than 0.04 indicates significant changes in the code.</p><p>Finally, several studies show that different software metrics follow power law distributions <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>. Concast et al. <ref type="bibr" target="#b14">[15]</ref> show that for a large Smalltalk system most Chidamber and Kemerer metrics <ref type="bibr" target="#b1">[2]</ref> follow power laws. Louridas et al. <ref type="bibr" target="#b15">[16]</ref> show that the dependencies of different software artifacts also follow power laws. Wheeldon et al. <ref type="bibr" target="#b16">[17]</ref> show that different class relationships follow power laws distributions.</p><p>All the data analysis studies clearly demonstrate that metrics do not follow normal distributions, invalidating the use of any statistical technique assuming a normal distribution. However all the studies fall short in concluding how to use these distributions, and the coefficients of the distributions, to establish baseline values to judge systems. Moreover, even if such baseline values were established it would not be possible to identify the code responsible for deviations (there is no traceability of results). In contrast, our research is focused on defining thresholds with direct applicability to differentiate software systems, judge quality and pinpoint problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MOTIVATING EXAMPLE</head><p>Suppose we want to compare the technical quality of four peer-to-peer (P2P) systems. Using the SIG quality model <ref type="bibr" target="#b3">[4]</ref> we can arrive to a judgment of technical quality. One of the used metrics is the McCabe metric. Using our method to derive thresholds for the McCabe metric, we obtain 6, 8 and 15 which represent 70%, 80% and 90% of all code in the benchmark. Using these values, quality profiles <ref type="bibr" target="#b3">[4]</ref> can be derived by computing the percentage of source lines of code of the methods that fall in each of the following risk categories: ≤ 6 for low risk, ]6, 8] for moderate risk, ]8, 15] for high  risk, and &gt; 15 for very-high risk. Figure <ref type="figure" target="#fig_0">1</ref> and Table <ref type="table" target="#tab_0">I</ref> show the quality profiles of four P2P systems: JMule, LimeWire, FrostWire and Vuze<ref type="foot" target="#foot_1">1</ref> . Pinpointing potential problems can be done by looking at the methods that fall in the very-high risk category. Looking at the percentages of the quality profiles we can have an overview about overall complexity. For instance, the Vuze system contains 48% of code in medium or higher risk categories, of which 25% is in the very-high risk category. Finally, quality comparisons can be performed: LimeWire is the least complex of the four systems, with 22% of its code in medium or higher risk categories, followed by FrostWire (25%), then by JMule (30%) and, finally, Vuze (48%).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. BENCHMARK-BASED THRESHOLD DERIVATION</head><p>The methodology proposed in this section was designed according to the following requirements: i) it should respect the statistical properties of the metric, such as scale and distribution; ii) it should be based on data analysis from a representative set of systems (benchmark); iii) it should be repeatable, transparent and straightforward to execute.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> summarizes the six steps of the methodology.</p><p>1. metrics extraction: metrics are extracted from a benchmark of software systems. For each system System, and for each entity Entity belonging to System (e.g. method), we record a metric value, M etric, and weight metric, W eight for that system's entity. As weight we will consider the source lines of code (LOC) of the entity. As example, for the Vuze system, there is method (entity) called MyTorrentsView.createTabs() with a McCabe metric value of 17 and weight value of 119 LOC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">weight ratio calculation:</head><p>for each entity, we compute the weight percentage within its system, i.e., we divide the entity weight by the sum of all weights of the same system. For each system, the sum of all entities W eightRatio must be 100%. As example, for the MyTorrentsView.createTabs() method entity, we divide 119 by 329, 765 (total LOC for Vuze) which represents 0.036% of the overall Vuze system.</p><p>3. entity aggregation: we aggregate the weights of all entities per metric value, which is equivalent to computing a weighted histogram (the sum of all bins must be 100%). Hence, for each system we have a histogram describing the distribution of weight per metric value. As example, all entities with a McCabe value of 17 represent 1.458% of the overall LOC of the Vuze system.</p><p>4. system aggregation: we normalize the weights for the number of systems and then aggregate the weight for all systems. Normalization ensures that the sum of all bins remains 100%, and then the aggregation is just a sum of the weight ratio per metric value. Hence, we have a histogram describing a weighted metric distribution. As example, a McCabe value of 17 corresponds to 0.658% of all code.</p><p>5. weight ratio aggregation: we order the metric values in ascending way and take the maximal metric value that represents 1%, 2%, ..., 100% of the weight. This is equivalent to computing a density function, in which the x-axis represents the weight ratio (0-100%), and the y-axis the metric scale. As example, according to the benchmark used for this paper, for 60% of the overall code the maximal McCabe value is 2.</p><p>6. thresholds derivaton: thresholds are derived by choosing the percentage of the overall code we want to represent. For instance, to represent 90% of the overall code for the McCabe metric, the derived threshold is 14. This threshold is meaningful, since not only it means that it represents 90% of the code of a benchmark of systems, but it also can be used to identify 10% of the worst code.</p><p>As a final example, the SIG uses thresholds derived by choosing 70%, 80% and 90% of the overall code, which derive  thresholds 6, 8 and 14, respectively. This allows to identify code to be fixed in long-term, medium-term and short-term, respectively. Furthermore, these percentiles are used in quality profiles to characterize code according to four categories: low risk (between 0 -70%), moderate risk (70 -80%), high risk (80 -90%) and very-high risk (&gt; 90%).</p><p>We present an analysis of these steps in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. BENCHMARKING DATA</head><p>We applied our methodology for deriving thresholds to a fairly representative set of available software systems. This set includes 100 systems in modern object-oriented technologies (Java and C#), both proprietary from SIG customers and opensource, developed by different organizations, from a broad range of domains. All the 100 systems were used (additional systems considered as outliers were removed from the initial set of systems). The system sizes range from over 3K LOC to near 800K LOC, with a total of near 12 million LOC. Table <ref type="table" target="#tab_1">II</ref> specifies the number of systems per technology (Java or C#) and license type (proprietary or open-source). Table III characterizes the used software systems according to their functionality using the taxonomy defined by ISBSG in <ref type="bibr" target="#b17">[18]</ref>.</p><p>For each system we derived metrics at two levels. At method level, LOC (unit size), McCabe (unit complexity) and number of parameters (unit interfacing) were derived. At file level, fan-in (module inward coupling) and number of methods (module interface size) were derived. The choice of these metrics was motivated by their use in the quality model used by SIG and T ÜV Informationstechnik (T ÜViT) for software certification <ref type="bibr" target="#b18">[19]</ref> which is an extension of the quality model proposed by Heitlager et al. <ref type="bibr" target="#b3">[4]</ref>. All metrics were calculated with the SIG Software Analysis Toolkit (SAT) version 3.2.0.</p><p>Outlier systems were removed by first inspecting the distribution of metrics. Systems whose distributions are radically different from other system's distributions were considered outliers. The identified systems were only removed after the outlier suspicion was validated by experts with knowledge about the systems. As rule-of-thumb, we found useful to apply the outlier-detection technique used for box-plots on the 50% quantile: all systems whose value is higher than the upper quantile plus 1.5 IQR is considered a possible outlier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. ANALYSIS OF THE METHODOLOGY STEPS</head><p>The methodology introduced in Section IV makes two major decisions: weighting by size, and using relative size as weight. In this section, based on data analysis we provide thorough explanation about these decisions that are the fundamental part of our methodology. Also, we investigate the representativeness of the derived thresholds.</p><p>Section VI-A, introduces the statistical analysis and plots used throughout the paper. Section VI-B, provides a detailed explanation about the effect of weighting by size. Section VI-C shows the importance of the use of relative size when aggregating measurements from different systems. Finally, in Section VI-D we provide evidence of the representativeness of the derived thresholds by applying the thresholds to the benchmark data and checking the results.</p><p>We discuss variants and threats in Section VII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Background</head><p>A common technique to visualize a distribution is to plot a histogram. Figure <ref type="figure" target="#fig_2">3a</ref>   Histograms, however, have several shortcomings. The choice of the bins affects the shape of the histogram possibly causing misinterpretation of data. Also, it is difficult to compare the distributions of two systems when they have different sizes since the y-axis can have significantly different values. Finally, histograms are not very good to represent the bins with lower frequency.</p><p>To overcome these problems, an alternative way to examine a distribution of values is to plot its Cumulative Density Function (CDF) or the CDF inverse, the Quantile function. Figure <ref type="figure" target="#fig_2">3b</ref> depicts the distribution of the McCabe values for the Vuze system using a Quantile plot. The x-axis represents the percentage of observations (percentage of methods) and the y-axis represents the McCabe values. The use of the quantile function is justifiable, because we want to determine thresholds (the dependent variable, in this case the McCabe values) as a function of the percentage of observations (independent variable). Also, by using the percentage of observations instead of the frequency, the scale becomes independent of size of the system making it possible to compare different distributions. In Figure <ref type="figure" target="#fig_2">3b</ref> we can observe that 96% of methods have a McCabe value ≤ 10.</p><p>Despite that histograms and quantile plots represent the same information, the quantile plot allows better visualization of the full metric distribution. Therefore, in this paper all distributions will be depicted with quantile plots.</p><p>All the statistical analysis and charts were done with R <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Weighting by size</head><p>Figure <ref type="figure" target="#fig_5">4a</ref> depicts the McCabe distribution for the Vuze system already presented in Figure <ref type="figure" target="#fig_2">3b</ref> in which we annotated the quantiles for the first three changes of the McCabe value. We can observe that up to the 66% quantile the McCabe value is 1, i.e. 66% of all methods have a metric value of 1. Up to the 77% quantile, the McCabe values are smaller than or equal to 2 (77-66 = 11% of the methods have a metric value of 2), and up to the 84% quantile have a metric value smaller than or equal to 3. Only 16% of methods have a McCabe value higher than 3. Hence, Figure <ref type="figure" target="#fig_5">4a</ref> shows that the metric variation is concentrated in just a small percentage of the overall methods.</p><p>Instead of considering every method equally (every method has a weight of 1), we will use the method's LOC as its weight.  In sum, for the Vuze system, both weighted and nonweighted plots show that large McCabe values are concentrated in just a small percentage of code. However, while in the non-weighted distribution the variation of McCabe values happen in the tail of the distribution (66% quantile), for the weighted distribution the variation starts much earlier, at the 18% quantile. When comparing Figure <ref type="figure" target="#fig_5">4</ref> to Figure <ref type="figure" target="#fig_6">5</ref> we observe that, as seen for the Vuze system, weighting by LOC emphasizes the metric variability.</p><p>Hence, weighting by LOC not only emphasizes the difference between methods in a single system, but also make the differences between systems more evident. A discussion about the correlation of the LOC metric with other metrics and the impact of it on our methodology is presented in Section VII-A. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Using relative size</head><p>To derive thresholds we need to summarize the metric, i.e., we need to aggregate the measurements from all systems.</p><p>To summarize the metric, we first perform a weight normalization step. For each method we compute the percentage of LOC that method represents in the system, i.e. we divide the method's LOC by the total LOC of the system it belongs to. This represents Step 2 of our methodology, presented in Figure <ref type="figure" target="#fig_1">2</ref>. Then, we just use all measurements together.</p><p>Conceptually, to summarize the McCabe metric, we have taken all curves of density functions for all systems and combined them into a single curve. Performing weight normalization ensures that every system is represented equally in the benchmark, limiting the influence of bigger systems over small systems in the overall result.</p><p>Figure <ref type="figure">6</ref> represents the density functions of the summarized McCabe metric (plotted in black) and the McCabe metric for all individual systems (plotted in gray), also shown in Figure <ref type="figure" target="#fig_8">5d</ref>. As expected, the summarized density function respects the shape of individual system's density function.</p><p>A discussion of alternatives to summarize a metric distribution are presented in Section VII-B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Choosing percentile thresholds</head><p>We have observed in Figures <ref type="figure" target="#fig_8">5</ref> and<ref type="figure">6</ref> that systems differentiate the most in the last quantiles. In this section we present evidence that it is justifiable to choose thresholds in the tail of the distribution and that the derived thresholds are meaningful.</p><p>Figure <ref type="figure">7a</ref> quantifies the variability of the McCabe distribution between systems. The full line depicts the McCabe distribution (also shown in Figure <ref type="figure">6</ref>) and the dashed lines depict the MAD above the distribution and below the distribution. The MAD is a measure of variability defined as the mean of the absolute differences between each value and a central point.</p><p>From Figure <ref type="figure">7a</ref> we can observe that both the MAD above and below the curve increase rapidly towards the last quantiles (it has a similar shape as the metric distribution itself). In sum, from Figure <ref type="figure">7a</ref>, we can observe that the variability between systems is concentrated in the tail of the distribution. It is important to take this variability into account when choosing a quantile for deriving a threshold. Choosing a quantile for which there is very low variability (e.g. 20%) will result in a threshold which will not allow to distinguish quality between systems. Choosing a quantile for which there is too much variability (e.g. 99%) might fail to identify code in many systems. Hence, to derive thresholds it is justifiable to choose quantiles from the tail of the distribution.</p><p>As part of our methodology we proposed the use of the 70%, 80% and 90% quantiles to derive thresholds. For the McCabe metric, using our benchmark, these quantiles yield to thresholds 6, 8 and 14, respectively. Now we are interested to investigate if the thresholds are indeed representative of those percentages of code. For that, we computed quality profiles for each system in our benchmark. For low risk, we considered the lines of code for methods with McCabe between 1 -6, for moderate risk 7 -8, for high risk 9 -14, and for very-high risk &gt; 14. This means, that for low risk we expect to identify around 70% of the code, and for each of the other risk categories 10%. Figure <ref type="figure">7b</ref> depicts a box plot for all systems per risk category. The x-axis represents the four risk categories, and the y-axis represents the percentage of volume (lines of code) of each system per risk category. The size of the box is the interquartile range (IQR) and is a measure of variability. The vertical lines indicate the lowest/maximum value within 1.5 IQR. The crosses in the charts represent systems whose risk category is higher than 1.5 IQR. In the low risk category, we observe large variability which is explained because it is considering a large percentage of code. For the other categories, from moderate to very-high risk, we can observe that variability increases. This increase of variability was also expected, since we have observed that the variability of the metric is higher for the last quantiles of the metric. We can observe that there are only a few crosses per risk category, which indicates that most of the systems are represented by the box plot. Finally, for all risk categories, looking to the line in the middle of the box, the median of all observations, we observe that indeed the median is according to our expectations. For low risk category, the median is near 70%, while for other categories the median is near 10% which indicates that the derived thresholds are representative of the chosen percentiles.</p><p>Summarizing, the box plot shows that the derived thresholds allow to observe differences between systems in all risk categories. Also, as expected, we can observe that around 70% of the code is identified in the low risk category and around 10% is identified for the moderate, high and very-high risk categories since the boxes are centered around the expected percentages for each category.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. VARIANTS AND THREATS</head><p>In this section we present a more elaborated discussion and alternatives taken into account regarding the two decisions in our methodology: weighting with size, and using relative size. Additionally, we discus other issues regarding removal of outliers and issues affecting metric computation.</p><p>Section VII-A we discuss the reasoning behind using LOC to weight the metric and possible risks due to correlation between metrics. Section VII-B discusses the need of aggregating measurements using relative weight, and discusses other possible alternatives to achieve similar results. Section VII-C explains how to identify outliers and the criteria to remove them. Finally, Section VII-D explain the impact of using different tools or configurations when deriving metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Weight by size</head><p>A fundamental part of our methodology is the combination of two metrics, more precisely, a metric for which thresholds are going to be derived with a size metrics such as LOC. In some contexts, particular attention should be paid when combining two metrics. For instance, when designing a software quality model it is desirable that each metric measures a unique attribute of the software. When two metrics are correlated it is often the case that they are measuring the same attribute. In this case only one should be used. We acknowledge such correlation between McCabe and LOC. The Spearman correlation value between McCabe and LOC for our data set (100 systems) is 0.779 with very-high confidence (pvalue &lt; 0.01).</p><p>In our methodology, the combination of metrics has a different purpose. We use LOC as a measure of size and use it to have a better representation of the part of the system we are characterizing. Instead of assuming every unit (e.g. method) of the same size, we take its size in the system measured in LOC. When doing this, we observed that we emphasized the variation of the metric allowing a more clear distinction between software systems. Hence, the correlation between LOC and other metrics poses no problem.</p><p>When referring to the LOC metric we could mean either logical or physical lines of code. In any case, since these metrics are highly correlated similar results are expected. Other LOC metrics could also be considered, however the study of such alternatives is deferred to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Use of relative weight</head><p>In Section VI-C we advocate the use of relative weight to aggregate measurements from all systems. The reasoning is that, since all the systems have similar distributions, the overall result should represent all systems equally. If we consider all  measurements together without applying any aggregation technique the large systems (systems with a bigger LOC) would influence the overall result. Figure <ref type="figure" target="#fig_11">8a</ref> compares the influence of size between simply aggregating all measurements together (black dashed line) and using relative weight (black full line) using as example the Vuze and JMule McCabe distributions (depicted in gray). Vuze has about 330 thousand LOC, while JMule has about 40 thousand LOC. We can observe that the dashed line is very close to the Vuze system meaning that the Vuze system has a stronger influence in the overall result. In comparison, using the relative weight results in a distribution in the middle of the Vuze and JMule distributions as depicted in the full line. Hence, it is justifiable to use the relative weight since it allows us to be size independent and it takes into account all measurements in equal proportion.</p><p>In alternative to the use of relative weight we could consider taking the mean/median quantile for all systems. Since the mean/median are measures of central tendency, we could compute the distributions for every system (as shown in gray in Figure <ref type="figure">6</ref>) and then, take the mean/median value of all distributions per quantile. Figure <ref type="figure" target="#fig_11">8b</ref> compares the relative weight to mean quantile and median quantile. As we can observe the result distributions shape is similar although thresholds for the 70%, 80% and 90% quantiles would be different. There are also problems with the mean/median. The mean is a good measure of central tendency if the underneath distribution is normal. We applied Shapiro-Wilk test <ref type="bibr" target="#b20">[21]</ref> for normality for all quantiles and verified that the distribution is not normal. Additionally, the mean is sensitive to extreme values, and would favor higher values when aggregating measurements. The median, on the other hand, relies on the order of the distributions to take a central value just taking into account the value of the central point, ignoring information. Additionally, for the last quantiles, the median relies on few data points, i.e., very few methods fall in the last quantiles, meaning that the distribution in the last quantiles will be sensitive to the addition of new data points. Finally, by using the mean/median the metric maximal value will not correspond to the maximal observable value, hiding information about the metric distribution. For our benchmark, the maximal McCabe  value is 911. However, from Figure <ref type="figure" target="#fig_11">8b</ref>, for the mean and median, we can observe that values of the metric for the 100% quantile (maximal value of the metric) are much lower.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Outliers</head><p>In statistics, it is common practice to check for the existence of outliers. An outlier is an observation whose value is distant relative to a set of observations.</p><p>According to Mason et al. <ref type="bibr" target="#b20">[21]</ref>, outliers are relevant because they can obfuscate the phenomena being studied or may contain interesting information that is not contained in other observations. There are several strategies to deal with outliers: remove observations, or use outlier-resistant techniques.</p><p>In our analysis, we compared the distribution of metrics between systems. Figure <ref type="figure" target="#fig_13">9a</ref> depicts the distribution of the McCabe metric for our data set of 100 systems (in gray) plus one outlier system (in black). We can observe that the outlier system has a metric distribution radically different from the other systems.</p><p>Figure <ref type="figure" target="#fig_13">9b</ref> depicts the effect of the presence of the outlier when summarizing the McCabe metric. The full line represents the curve that summarizes the McCabe distribution for 100 systems, previously shown in Figure <ref type="figure">6</ref>, and the dashed line represents the result of the 100 systems plus the outlier. From Figure <ref type="figure" target="#fig_13">9b</ref>, we can observe that the presence of the outlier has limited influence in the overall result, meaning that our methodology has resilience against outliers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Impact of the tools/scoping</head><p>The computation of metric values and metric thresholds can be affected by the measurement tool and by scoping.</p><p>Different tools implement different variations of the same metrics. Taking as example the McCabe metric, some tools implement the Extended McCabe metric, while other might implement the Strict McCabe metric and also call it Mc-Cabe. As the values from these metrics can be different, the computed thresholds can also be different. To overcome this problem, the same tool should be used both to derive thresholds and to analyze systems using the derived thresholds.</p><p>The configuration of the tool with respect to which files to include or exclude in the analysis (scoping) also influences the computed thresholds. For instance, the existence of unit test code, which contains very little complexity, will result in lower threshold values. On the other hand, the existence of generated code, which normally have very high complexity, will result in higher threshold values. Hence, it is extremely important to know which data is used for calibration. As previously stated, for deriving thresholds we removed both generated code and test code from our analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. THRESHOLDS FOR SIG'S QUALITY MODEL METRICS</head><p>Throughout the paper, the McCabe metric was used as case study. To investigate the applicability of our methodology to other metrics, we repeated the analysis for the SIG quality model metrics. We found that our methodology can be successfully applied to derive thresholds for all these metrics. <ref type="bibr">Figures 10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12</ref>, and 13 depict the distribution and the box plot per risk category for unit size (method size in LOC), unit interfacing (number of parameters per method), module inward coupling (file fan-in), and module interface size (number of methods per file), respectively.</p><p>From the distribution plots, we can observe, as for McCabe, that for all metrics both the highest values and the variability between systems is concentrated in the last quantiles.</p><p>Table <ref type="table" target="#tab_3">IV</ref> summarizes the quantiles used and the derived thresholds for all the metrics from the SIG quality model. As for the McCabe metric, we derived quality profiles for each metric using our benchmark in order to verify that the thresholds are representative of the chosen quantiles. The results are again similar. Except for the unit interfacing metric, the low risk category is centered around 70% of the code and all others are centered around 10%. For the unit interfacing metric, since the variability is relative small until the 80% quantile we decided to use 80%, 90% and 95% quantiles to derive thresholds. For this metric, the low risk category is a round 80%, the moderate risk is near 10% and the other two around 5%. Hence, from the box plots we can observe that the thresholds are indeed recognizing code around the defined quantiles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Contributions</head><p>We proposed a novel methodology for deriving software metric thresholds and a calibration of previously introduced metrics. Our methodology improves over others by fulfilling three fundamental requirements: i) it respects the statistical properties of the metric, such as metric scale and distribution;</p><p>ii) it is based on data analysis from a representative set of systems (benchmark); iii) it is repeatable, transparent and straightforward to carry out. These requirements were achieved by aggregating measurements from different systems using relative size weighting. Our methodology was applied to a large set of systems and thresholds were derived by choosing specific percentages of overall code of the benchmark.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Discussion</head><p>Using a benchmark of 100 object-oriented systems (C# and Java), both proprietary and open-source, we explained in detail our methodology for the McCabe metric. We have shown that the distribution of the metric is preserved and that the methodology is resilient to the influence of large systems or outliers. Thresholds were derived using 70%, 80% and 90% quantiles and checked against the benchmark to show that thresholds indeed represent these quantiles. The analysis of these results was replicated with success using four other metrics from the SIG quality model. Variants in our methodology for deriving threshold were analyzed as well as threats to our methodology.</p><p>Our methodology has proven capable to derive thresholds for all the metrics of the SIG quality model. For unit interfacing the 80%, 90% and 95% was used since the metric variability only increases much later than for other metrics. Thresholds for all other metrics were derived using 70%, 80% and 90%. For all metrics, our methodology showed that the derived thresholds are representative of the chosen quantiles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Industrial applications</head><p>The thresholds derived with our methodology have been successfully used in practice by SIG for software analysis <ref type="bibr" target="#b3">[4]</ref>, benchmarking <ref type="bibr" target="#b21">[22]</ref> and certification <ref type="bibr" target="#b22">[23]</ref>. Thresholds based on expert opinion have been replaced by thresholds derived with our methodology which have been used with success.</p><p>Our methodology has also been applied for other metrics. Luijten et al. <ref type="bibr" target="#b23">[24]</ref> found empirical evidence that systems with higher technical quality have higher issue solving efficiency. The thresholds used for classifying issue efficiency were derived using the methodology described in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Future work</head><p>Several avenues of future work are foreseen. Empirical studies to validate software metrics with external qualities, using metric thresholds, such as the one from Luijten et al. <ref type="bibr" target="#b23">[24]</ref> are foreseen. Techniques to characterize curves based on a fixed number of points, such as proposed by Schwetlick et al. <ref type="bibr" target="#b24">[25]</ref> could be used to choose the quantiles to better characterize the metric distribution. Finally, it would be interesting to apply our methodology to suites of metrics proposed by others, e.g. to the CDK metrics <ref type="bibr" target="#b1">[2]</ref>, or to metrics for other types of software artifacts, e.g. databases or XML schemas.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Quality profiles for four P2P systems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Summary of the methodology steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: McCabe distribution for Vuze system represented with a histogram and a quantile plot.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>depicts the distribution of the McCabe values for the Vuze system. The x-axis represents the McCabe values and the y-axis represents the number of methods that have such a McCabe value (frequency).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Figure 3a allows us to observe that more than 30.000 methods have a McCabe value ≤ 10 (the frequency of the first bin is 30.000).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 :</head><label>4</label><figDesc>Fig. 4: McCabe distribution for the Vuze system (nonweighted and weighted by LOC) annotated with the x and y values for the first three changes of the metric.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Non-weighted and weighted McCabe distributions for 100 projects of the benchmark.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4b depicts the</head><label></label><figDesc>Figure 4b depicts the weighted distribution of the McCabe values for the Vuze system. Hence, instead of having the percentage of methods in the x-axis, we will have now the percentage of LOC. Comparing Figure 4a to Figure 4b, we can observe that in the weighted distribution the variation of the McCabe values starts much earlier. The first three changes for the McCabe values are at 18%, 28% and 36% quantiles.In sum, for the Vuze system, both weighted and nonweighted plots show that large McCabe values are concentrated in just a small percentage of code. However, while in the non-weighted distribution the variation of McCabe values happen in the tail of the distribution (66% quantile), for the weighted distribution the variation starts much earlier, at the 18% quantile.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5</head><label>5</label><figDesc>Figure 5 depicts the non-weighted and weighted distributions of the McCabe metric for 100 projects. Each line represents an individual system. Figures 5a and 5c depict the full McCabe distribution and Figures 5b and 5d depict a cropped version of the previous, restricted to quantiles higher than or to 70% and to a maximal McCabe value of 100.When comparing Figure4to Figure5we observe that, as seen for the Vuze system, weighting by LOC emphasizes the metric variability.Hence, weighting by LOC not only emphasizes the difference between methods in a single system, but also make the differences between systems more evident. A discussion about the correlation of the LOC metric with other metrics and the impact of it on our methodology is presented in Section VII-A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6 :Fig. 7 :</head><label>67</label><figDesc>Fig. 6: Summarized McCabe distribution. The line in black represents the summarized McCabe distribution. Each gray line depicts the McCabe distribution of a single system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>(a) Effect of large systems in aggregation. (b) Mean, Median as alternatives to Relative Weight.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Effect of using relative weight in the presence of large systems and comparison with alternatives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>(a) McCabe distribution with an outlier. (b) McCabe characterization with and without an outlier.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: Example of outliers and outlier effect on the McCabe characterization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 10 :Fig. 11 :</head><label>1011</label><figDesc>Fig. 10: Unit size (method size in LOC)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 12 :Fig. 13 :</head><label>1213</label><figDesc>Fig. 12: Module Inward Coupling (file fan-in)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I :</head><label>I</label><figDesc>Quality profiles: Unit complexity</figDesc><table><row><cell></cell><cell>risk:</cell><cell>Low</cell><cell>Moderate</cell><cell>High</cell><cell>Very high</cell></row><row><cell>JMule</cell><cell>0.4.1</cell><cell>70.52%</cell><cell>6.04%</cell><cell>11.82%</cell><cell>11.62%</cell></row><row><cell>LimeWire</cell><cell>4.13.1</cell><cell>78.21%</cell><cell>6.73%</cell><cell>9.98%</cell><cell>5.08%</cell></row><row><cell>FrostWire</cell><cell>4.17.2</cell><cell>75.10%</cell><cell>7.30%</cell><cell>11.03%</cell><cell>6.57%</cell></row><row><cell>Vuze</cell><cell>4.0.04</cell><cell>51.95%</cell><cell>7.41%</cell><cell>15.32%</cell><cell>25.33%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II :</head><label>II</label><figDesc>Number of systems per technology and license.</figDesc><table><row><cell>Technology</cell><cell>License</cell><cell>n</cell><cell>LOC</cell></row><row><cell>Java</cell><cell>Proprietary OSS</cell><cell>60 22</cell><cell>8,435K 2,756K</cell></row><row><cell>C#</cell><cell>Proprietary OSS</cell><cell>17 1</cell><cell>794K 10K</cell></row><row><cell></cell><cell>Total</cell><cell>100</cell><cell>11,996K</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE III :</head><label>III</label><figDesc>Number of systems per functionality.</figDesc><table><row><cell>Functionality type</cell><cell>n</cell></row><row><cell>Catalogue or register of things or events</cell><cell>8</cell></row><row><cell>Customer billing or relationship management</cell><cell>5</cell></row><row><cell>Document management</cell><cell>5</cell></row><row><cell>Electronic data interchange</cell><cell>3</cell></row><row><cell>Financial transaction processing and accounting</cell><cell>12</cell></row><row><cell>Geographic or spatial information systems</cell><cell>2</cell></row><row><cell>Graphics and publishing tools or system</cell><cell>2</cell></row><row><cell>Embedded software for machine control</cell><cell>3</cell></row><row><cell>Job, case, incident or project management</cell><cell>6</cell></row><row><cell>Logistic or supply planning and control</cell><cell>8</cell></row><row><cell>Management or performance reporting</cell><cell>2</cell></row><row><cell>Mathematical modeling (finance or engineering)</cell><cell>1</cell></row><row><cell>Online analysis and reporting</cell><cell>6</cell></row><row><cell>Operating systems or software utility</cell><cell>14</cell></row><row><cell>Software development tool</cell><cell>3</cell></row><row><cell>Stock control and order processing</cell><cell>1</cell></row><row><cell>Trading</cell><cell>1</cell></row><row><cell>Workflow support and management</cell><cell>10</cell></row><row><cell>Other</cell><cell>8</cell></row><row><cell>Total</cell><cell>100</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE IV :</head><label>IV</label><figDesc>Metric thresholds and used quantiles for the SIG quality model metrics.</figDesc><table><row><cell>Metric / Quantiles</cell><cell>70%</cell><cell cols="2">80% 90%</cell></row><row><cell>Unit complexity</cell><cell>6</cell><cell>8</cell><cell>14</cell></row><row><cell>Unit size</cell><cell>30</cell><cell>44</cell><cell>74</cell></row><row><cell>Module inward coupling</cell><cell>10</cell><cell>22</cell><cell>56</cell></row><row><cell>Module interface size</cell><cell>29</cell><cell>42</cell><cell>73</cell></row><row><cell>Metric / Quantiles</cell><cell>80%</cell><cell cols="2">90% 95%</cell></row><row><cell>Unit interfacing</cell><cell>2</cell><cell>3</cell><cell>4</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>978-1-4244-8628-1/10/$26.00 ©2010 IEEE</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>jmule.org/, limewire.com/, www.frostwire.com/, www.vuze.com/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>Thanks to Harro Stokman and Joost Schalken for inspiring discussions, to José Pedro Correia by the support of extracting the metrics, and to several other colleagues of the SIG for providing comments to earlier versions of this work. The first author is supported by the Fundac ¸ão para a Ciência e a Tecnologia, grant SFRH/BD/30215/2006.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A complexity measure</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Mccabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="308" to="320" />
			<date type="published" when="1976-12">Dec. 1976</date>
		</imprint>
	</monogr>
	<note>Software Engineering</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A metrics suite for object oriented design</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Chidamber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Kemerer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="476" to="493" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Software metrics: roadmap</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Fenton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Neil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE -Future of SE Track</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="357" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A practical model for measuring maintainability</title>
		<author>
			<persName><forename type="first">I</forename><surname>Heitlager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kuipers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Quality of Information and Communications Technology (QUATIC&apos;07)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="30" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">NPATH: a measure of execution path complexity and its applications</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Nejmeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="188" to="200" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The application of software maintainability models in industrial software systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Coleman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lowther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Oman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Softw</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="16" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Applying design-metrics to object-oriented frameworks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Erni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lewerentz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">METRICS &apos;96: Proceedings of the 3rd International Symposium on Software Metrics</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page">64</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Establishing software metric thresholds</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>French</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Software Measurement (IWSM&apos;99)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Finding software metrics threshold values using ROC curves</title>
		<author>
			<persName><forename type="first">R</forename><surname>Shatnawi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Swain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Software Maintenance and Evolution: Research and Practice</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Thresholds for objectoriented measures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Benlarbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Emam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSRE &apos;00: Proc. of the 11th International Symposium on Software Reliability Engineering</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page">24</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The optimal class size for object-oriented software</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">El</forename><surname>Emam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Benlarbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Melo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lounis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Rai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="494" to="509" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An approach to outlier detection of software measurement data using the K-means clustering method</title>
		<author>
			<persName><forename type="first">K.-A</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O.-S</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D.-H</forename><surname>Bae</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEM&apos;07</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="443" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A tale of four kernels</title>
		<author>
			<persName><forename type="first">D</forename><surname>Spinellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE&apos;08</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="381" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Comparative analysis of evolving software systems using the gini coefficient</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vasa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lumpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Branch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSM&apos;09</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="179" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Power-laws in a large object-oriented software system</title>
		<author>
			<persName><forename type="first">G</forename><surname>Concas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marchesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pinna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Serra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="687" to="708" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Power laws in software</title>
		<author>
			<persName><forename type="first">P</forename><surname>Louridas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Spinellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vlachos</surname></persName>
		</author>
		<ptr target="http://portal.acm.org/citation.cfm?id=1391984.1391986" />
	</analytic>
	<monogr>
		<title level="m">TOSEM&apos;08</title>
		<imprint>
			<date type="published" when="2008-09">Sep 2008</date>
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Power law distributions in class relationships</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wheeldon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Counsell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCAM&apos;03</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page">45</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The Benchmark Release 10 -project planning edition</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lokan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Software Benchmarcking Standards Groups Ltd., Tech. Rep</title>
		<imprint>
			<date type="published" when="2008-02">February 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">SIG/T ÜViT evaluation criteria -Trusted Product Maintainability, version 1.0</title>
		<author>
			<persName><forename type="first">Sig)</forename></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Üv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Informationstechnik</forename><surname>Gmbh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">(t</forename><surname>Üvit</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Software Improvement Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<orgName type="collaboration">R Development Core Team</orgName>
		</author>
		<title level="m">R: A Language and Environment for Statistical Computing, R Foundation for Statistical Computing</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Gunst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Hess</surname></persName>
		</author>
		<title level="m">Statistical Design and Analysis of Experiments</title>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Benchmarking technical quality of software products</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Correia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WCRE &apos;08: Proceedings of the 2008 15th Working Conference on Reverse Engineering</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="297" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Certification of technical quality of software products</title>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Int&apos;l Workshop on Foundations and Techniques for Open Source Software Certification</title>
		<meeting>of the Int&apos;l Workshop on Foundations and Techniques for Open Source Software Certification</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="35" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Faster defect resolution with higher technical quality of software</title>
		<author>
			<persName><forename type="first">B</forename><surname>Luijten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SQM &apos;10: Proc. of the 4th International Workshop on Software Quality and Maintainability</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Least squares approximation by splines with free knots</title>
		<author>
			<persName><forename type="first">H</forename><surname>Schwetlick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schütze</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
