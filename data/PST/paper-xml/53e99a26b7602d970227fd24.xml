<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Detecting Object Usage Anomalies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrzej</forename><surname>Wasylkowski</surname></persName>
							<email>wasylkowski@cs.uni-sb.de</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Zeller</surname></persName>
							<email>zeller@cs.uni-sb.de</email>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christian</forename><surname>Lindig</surname></persName>
							<email>lindig@cs.uni-sb.de</email>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Computer Science</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Detecting Object Usage Anomalies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7E2BA30291E7D5243F15B49D6D48E49E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.2.4 [Software/Program Verification]: Class invariants, Statistical methods</term>
					<term>F.3.2 [Semantics of Programming Languages]: Program analysis</term>
					<term>F.3.3 [Studies of Program Constructs]: Control primitives, Object-oriented constructs Algorithms, Design, Reliability</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Interacting with objects often requires following a protocol-for instance, a specific sequence of method calls. These protocols are not always documented, and violations can lead to subtle problems. Our approach takes code examples to automatically infer legal sequences of method calls. The resulting patterns can then be used to detect anomalies such as "Before calling next(), one normally calls hasNext()". To our knowledge, this is the first fully automatic defect detection approach that learns and checks method call sequences. Our JADET prototype has detected yet undiscovered defects and code smells in five popular open-source programs, including two new defects in ASPECTJ.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>When interacting with an object, the program has to follow the rules mandated by its interface. For individual methods, the compiler checks whether the caller is allowed to invoke the method, and whether its arguments are correctly typed. The interplay of multiple methods, though-in particular, whether a specific sequence of method calls is allowed or not-is neither specified nor checked at compile time. Only if the program fails at run-time may the programmer discover that she would have been required to, say, call Stack.push() before invoking Stack.elements() or, to check an iterator's value using Iterator.hasNext() before incrementing it with Iterator.next(). Consequently, illegal call sequences may still loom in the code even though all tests pass.</p><p>In this paper, we propose mining object usage models from code examples-representations of typical object usage as possible sequences of method calls. These patterns can be used to automatically find locations in programs that deviate from normal object usage-that is, defect candidates.</p><p>In Section 2, we describe how to extract object usage models from JAVA code-finite state automata with anonymous states and transitions labeled with feasible method calls (Figure <ref type="figure" target="#fig_0">1(a-b</ref>)). For instance, the iter model tells us the typical interaction with a JAVA iterator object: Typically, hasNext() is called first (in a loop condition), and then either the interaction ends (the loop exits), or next() is called and the loop starts again. Our approach focuses on modeling objects from the point of view of single methods, using intraprocedural analysis only. This allows us to get comprehensive results guaranteed by static analysis and yet remain scalable.</p><p>In Section 3, we extract patterns such as "next() can precede hasNext()" from models (Figure <ref type="figure" target="#fig_0">1(c)</ref>). These patterns are collected over the entire code body and then fed into a classifier which identifies locations that violate these patterns (Figure <ref type="figure" target="#fig_0">1(d-e</ref>))-that is, likely defect locations. Section 4 summarizes our experiences with five popular open-source programs. Our JADET prototype detects a large number of code smells in these programs, including a previously undiscovered ASPECTJ defect where next() never precedes hasNext()-the first loop iteration always exits. This is not the first work to extract and check temporal object behavior. However, it is the first to automatically do both for individual objects, and therefore can find errors undetected by others. Our main advantage is being able to find program-specific temporal patterns without the need of any external input apart from the program itself. In Section 5, we discuss the related work in mining temporal object behavior and detecting defects automatically, and highlight the contributions of the present approach. Section 6 closes with a conclusion and consequences for future work.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MINING USAGE MODELS</head><p>In order to show, how we mine object usage models from code, we will consider the sample source code shown in Figure <ref type="figure" target="#fig_1">2</ref>. We want to create models of objects from the point of view of the methods they occur in. So for instance we create a model of the random variable in createStack(), or of the dest parameter of addElements(), etc. More generally, we are going to create models for the following objects:</p><p>• Every object that is created (via new) in a method-for instance, the variable random in createStack().</p><p>• Method parameters-such as the dest and src parameters of addElements().</p><p>• Return values-such as the return value of the call to createStack() in the test() method.</p><p>• Exceptions-such as e from the catch clause in test().</p><p>We will call such objects abstract objects. Our approach takes a set of JAVA classes as input and produces models for all abstract objects existing in methods defined in those classes. This is a two step process. In the first step, we create a model for each method. This model represents the behavior of the method and is similar to a control flow graph. In the second step, we use this method model to construct the set of object usage models of abstract objects occurring in the analyzed method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Step 1: Creating a method model</head><p>In the first step of the mining process, we create a method model. The states of this model are based on locations in the code, whereas transitions are labeled with instructions. More precisely, each state corresponds to exactly one instruction and represents the place in the code just before this instruction. For every predecessor of an instruction, there is a transition between the state corresponding to the predecessor and the state corresponding to the instruction.</p><p>Additionally, there is single exit state to which all states corresponding to return instructions are connected to it with an epsilon transition. The structure of such a model mirrors the code structure and the model itself is closely related to the control flow graph of the analyzed method-with the difference that instructions are labels of transitions instead of states.</p><p>A method model is mined on the bytecode level (i.e. with states based on locations in the bytecode and transitions based on bytecode instructions). For the purposes of the presentation, though, we will assume this happens on the source code level. Figure <ref type="figure" target="#fig_2">3</ref> shows the method model constructed by applying the mining algorithm described above to the createStack() method code from Figure <ref type="figure" target="#fig_1">2</ref>. By convention, we mark the transition to the exit state by a transition without destination state.</p><p>In the method model, exceptions that may be thrown by the code being analyzed are treated specially. For every instruction in the code, we infer the set of all exceptions that may be thrown as a result of executing this instruction. For example, in case of a method call, we would create a set consisting of all exceptions declared as being thrown by the callee. For each such exception, there are two principal possibilities: either the exception is handled inside the method being analyzed or it is propagated to the caller.</p><p>If the exception is handled, the situation is straightforward: exception-handling code is itself represented in the method model, so we just need to add an appropriate transition. In order to recognize a transition as representing an exception being thrown, we annotate its label with the exception's class name.</p><p>If the exception is propagated to the caller, we add a new state to the model. In order to distinguish this exceptional state from all others, it is labeled with the exception's class name and represents the exit from the method with the specified exception being thrown. Then we add an appropriate transition to this state, just as in the case of an exception that is handled.</p><p>The test() method in Figure <ref type="figure" target="#fig_1">2</ref> gives an example of how to treat exceptions. The call inside the try block may either return normally or throw one of two exceptions: TooLargeException or TooSmallException. In the resulting method model, there are exactly three transitions outgoing from the state corresponding to this call. The first one has as its destination the exit state and is labeled just with the method call. The second has as its destination the stack.&lt;init&gt;() stack.push(...) stack.push(...) state corresponding to the first instruction inside the catch block and is labeled with the method call annotated with the name of the exception's class (in this case TooLargeException). The third transition has as its destination the state marked with the name of the unhandled exception's class: TooSmallException.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Step 2: Creating an object usage model</head><p>In the second step of the mining process, the method model is projected onto the abstract object whose model we want to create. For instance, in case of createStack(), we have a method model; now we want to break this down to a separate model for each abstract object obj within createStack(). This is done by replacing all transitions by epsilon transitions that do not call a method on obj nor use obj as a parameter to some method call.</p><p>In order to take local aliasing into account, we apply a data-flow analysis to discover all places in the code where the object might be a target or a parameter of a method call. Labels of the non-epsilon transitions are transformed by replacing each method call with the full name and signature of the method being called. Additionally, if the object of interest was used as a parameter of a method call, the label of the corresponding transition is annotated with the position(s) of this object in the parameter list of the method call. Lastly, in order to reduce the number of states and thus improve comprehension, the epsilon transitions are removed. Such a model, with states based on locations in the code and transitions based on instructions that use the modeled object as an argument or a target of a method call, is called an object usage model.</p><p>Special attention must be paid to objects that are cast in the program. A common pattern is to take an object from a collection or an object resulting from a method call and cast it to several different types depending on the outcome of the instanceof operation. What this amounts to is essentially having a set of multiple concrete objects with different types, all of which, however, are represented by the same abstract object. Our analysis treats casts accordingly: each cast induces creation of a new object usage model for the abstract object being cast. Each of those models describes usage of the concrete object it represents, including the usage that happens before the object is cast. We found this usage to be actually quite common and it was the main reason we do not treat casts in themselves as inducing abstract objects.</p><p>As an example of casts, consider the method addElements() from Figure <ref type="figure" target="#fig_1">2</ref>. The dest variable is an instance of the Vector class, but inside the code there is one place where it is cast to the Stack class (which is a subclass of the Vector class). This means that there are two object usage models created for this variable. The first one models the dest variable as a Vector only and the second models the dest variable as a Stack.</p><p>To create an usage model for the stack variable defined in the createStack() method, we transform the method model from the Figure <ref type="figure" target="#fig_2">3</ref> to the model shown in Figure <ref type="figure" target="#fig_3">4</ref>. For the purposes of the presentation, the names of the labels have been simplified by removing method signatures and just indicating the number of their parameters using ellipsis instead. In all subsequent models, epsilon transitions will be depicted using dashed lines (with the only exception being the "entry" and "exit" transitions).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1:</head><p>The pattern {start() ≺ stop(), lock() ≺ unlock()} is common to three methods, but violated by get()</p><formula xml:id="formula_0">Temporal property start() ≺ lock() ≺ eof() ≺ Method stop() unlock() close() get() × × open() × × hello() × × × parse() × ×</formula><p>In practice, all abstract objects in a method share one method model (because they all occur in the same method); the data-flow analysis is conducted only once for each method, simultaneously creating the models for all abstract objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">FINDING ANOMALIES</head><p>In this paper, the main application for object usage models is identifying programming patterns. We define a programming pattern (or simply pattern) as a set of temporal properties over method calls.</p><p>As an example of a pattern, consider the set P = {hasNext() ≺ next(), next() ≺ hasNext()}, where m ≺ n means that there is a possibility of calling m before calling n (not necessarily directly). This pattern P is exhibited by iter object usage model in Figure <ref type="figure" target="#fig_0">1</ref>(b).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Mining programming patterns</head><p>To discover patterns such as the one above, we first need to mine temporal properties over method calls from the program being analyzed. Initially, we do this on a per-object usage model basis, so that for each object usage model O, we create a control flow relation R(O) = {(m, n) | n can be called after m}. This relation is by definition transitive. (Note that m and n can be methods of different classes, because object usage models also contain methods called with the modeled object as a parameter.)</p><p>Intuitively, control flow relation R(O) for an object usage model O contains all such pairs of method calls (m, n) for which there exists a path through the model O on which m occurs before n (not necessarily directly, i.e. the edges corresponding to m and n do not have to be adjacent).</p><p>In the next step, we produce for every method M a set of temporal properties T (M) satisfied by M, defined as</p><formula xml:id="formula_1">T (M) = {m ≺ n | (m, n) ∈ R(O) for some O created by analyzing M}.</formula><p>After we have created sets of temporal properties over method calls for all methods, we need to mine common patterns from those sets. To do this, we use an approach called frequent itemset mining <ref type="bibr" target="#b15">[15]</ref>. Frequent itemset mining takes as an input a set S = {S 1 , . . . , S k }, where each</p><formula xml:id="formula_2">S i = {s i 1 , . . . , s i m i</formula><p>} is a set of properties, as well as a support threshold min_support. It produces as an output a set of patterns P = {P 1 , . . . , P n } that occur in at least min_support sets. Formally, if we define support(T ) = |{S i ∈ S | T ⊆ S i }|, which is the number of sets of properties that include all properties from pattern T , frequent itemset mining guarantees that T ∈ P iff support(T ) ≥ min_support.</p><p>Intuitively, support of a pattern is the number of methods that respect that pattern (i.e. exhibit all temporal properties constituting the pattern). Applying frequent itemset mining to the set S containing all T (M) sets will discover a set of all patterns that are exhibited by at least min_support methods. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Properties</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• •</head><formula xml:id="formula_3">• • • • • • • • • • • • • • • • • • • • • • • violation M • • • P P'</formula><p>Figure <ref type="figure">5</ref>: Each pattern corresponds to a block in the cross table over methods and properties. Blocks in turn form a lattice hierarchy. Violations always correspond to neighboring blocks in the hierarchy. The numbers in the lattice denote the support of the corresponding pattern.</p><p>However, according to our definition, if we have two patterns P 1 and P 2 , where P 2 is a proper subset of P 1 (i.e. each temporal property present in P 2 is also present in P 1 , but not vice versa) and yet they both have the same support, both will end up in the final set of patterns. P 2 does not contribute anything to our knowledge, because it occurs only in the same methods in which P 1 does, and so we do not want it to be included in the results. To achieve this, we will restrict ourselves to such patterns, for which every proper superset has less support. Such patterns are called closed.</p><p>As an example of frequent itemset mining, consider Table <ref type="table">1</ref>. In this example, S = {T (get()), T (open()), T (hello()), T (parse())}, where the sets of temporal properties are T (get()) = {start() ≺ stop(), eof() ≺ close()}, T (hello()) = {start() ≺ stop(), lock() ≺ unlock(), eof() ≺ close()}, and so on. If we assume a support threshold min_support = 2, frequent itemset mining will produce as an output the set P = {P 1 , P 2 } consisting of two patterns: P 1 = {start() ≺ stop(), eof() ≺ close()} and P 2 = {start() ≺ stop(), lock() ≺ unlock()}. P 1 has a support of 2 (because only two methods exhibit all its temporal properties: get() and hello()) and P 2 has a support of 3 (it is exhibited by methods open(), hello() and parse()).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Detecting anomalies</head><p>Frequent patterns minded from code express normal object usage. A pattern that is respected by many methods but violated by few represents an anomaly and is the focus of our interest.</p><p>How do we detect pattern violations? A methods M violates a closed pattern P if another (closed) pattern P ′ ⊂ P exists such that M respects all properties of P ′ but not all of P. In Table <ref type="table">1</ref> method get() violates pattern P = {start() ≺ stop(), lock() ≺ unlock()}, because P ′ = {start() ≺ stop()} is a closed sub pattern of P, for example.</p><p>However, not all violation are equally likely to point to real defects. We consider the ratio between the number of methods that respect a pattern P and those that violates it: patterns that are respected by many and violated by few methods are likely to be genuine defects. This ratio is the confidence for a violation, defined as s/(s + v) where s is the support of a violated pattern, and v the number of violations. The confidence for get() in Table <ref type="table">1</ref> violating pattern P is 3/4 because P has support 3, and P ′ has support 4, leading to one violation. The support is a value between zero and one, and expressed as a percentage. For practical purposes, only violations exceeding a minimum confidence (parameter min_confidence) are considered.</p><p>Detecting all violations exceeding a minimum confidence would require to look at all closed patterns in a table like Table <ref type="table">1</ref>. Our key insight is that each pattern corresponds a block in the cross table over methods and properties. And a pattern violation corresponds to an imperfect block, like shown on the left of Figure <ref type="figure">5</ref>. Indeed, such an imperfect block is really a composition of two blocks (or patterns): a slim and tall block, and a wider and short block. They correspond to P ′ and P in our definition of violations above.</p><p>Computing all blocks in a cross table efficiently is provided by Formal Concept Analysis. Blocks form a hierarchy, as shown on the right in Figure <ref type="figure">5</ref>. Another insight is that imperfect blocks are always formed by two neighboring blocks in the hierarchy. Our mining implementation COLIBRI thus computes the concept lattice and inspects all neighboring blocks in order to find all violations <ref type="bibr" target="#b20">[20]</ref>.</p><p>A cross table may have exponentially many patterns. Mining can be still made efficient because support for patterns decreases monotonically in the lattice from the top down. COLIBRI computes only the topmost patterns (or blocks) that both exceed a minimum support (parameter min_support) and from these violations that exceed the minimum confidence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Ranking anomalies</head><p>Anomalies discovered by the process described above are interesting, but there are typically several of them and of course not all of them are true defects. Investigating every single anomaly is timeconsuming and would defeat one of the main advantages of our approach: full automatization.</p><p>To solve this problem, we developed a method to rank anomalies. We wanted our ranking method to favor anomalies that are violations of a frequently occurring pattern by a relatively small number of methods. We also wanted it to favor anomalies that violate "rare" patterns, i.e. those that are dissimilar from others, because we have noticed that some classes induce many meaningless patterns with many anomalies. This is the case, for instance, for the StringBuffer class. A common usage pattern of this class is that we call append(String) and then at some later point toString() on that same object. This leads to marking the code that calls append(int), but not append(String) as anomalous, whereas it is clear that this is definitely not a defect.</p><p>To achieve the goals stated above, we assign a number, called defect indicator, to each anomaly and then rank them in the descending order of their indicators. The defect indicator of an anomaly is defined as ind = u • s/v, where s is the support of the pattern being violated, v is the number of methods in which the violation occurs, and u is the so-called uniqueness factor. In order to calculate the uniqueness factor, we first have to do the following steps: • We assign to each pattern P the number np(P) being the maximum over na(C)'s for all classes C ∈ C(P). Intuitively, if we consider the class in C(P) that most often occurs in other anomalies (i.e. these anomalies violate patterns containing calls to methods defined by this class), then np(P) tells us the number of those occurrences.</p><formula xml:id="formula_4">•</formula><p>The uniqueness factor of an anomaly A is defined as 1/np(P), where P is a pattern violated by the anomaly A. This number is equal to 1 if each class from C(P) occurs only in P (indicating uniqueness of P and thus also A). The more anomalies violating patterns having something in common with P, the smaller the uniqueness factor of the anomaly. 1   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EXPERIMENTS</head><p>We have implemented a prototype called JADET (for "Java Anomaly Detector") that implements mining of object usage models. To evaluate the effectiveness of JADET, we have applied it to several complex Java projects (see Table <ref type="table" target="#tab_1">2</ref>): ACT-RBOT, which is a cognitive agent based social simulation toolkit/production system 2 ; ASPECTJ, an aspect-oriented extension to the JAVA programming language 3 ; AZUREUS, a bittorrent client 4 ; COLUMBA, an email client 5 and MUSICOMP, a melody generator 6 . All the experiments were performed under the following conditions:</p><p>• We analyzed all methods whose libraries were available. Surprisingly, this was not the case for all methods. In the case of ACT-RBOT, the libraries included in the project "jar" file had conflicting versions which prevented us from analyzing thirty methods in one of such libraries. The MUSICOMP application code contained a call to a method in one of WEKA classes that was not defined by that class. In AZUREUS, we missed the Apple Cocoa-Java classes. In ASPECTJ, the package org.aspectj.bea.jvm was missing.</p><p>• A violation is characterized by three numbers: the support of the pattern being violated, the confidence of the violation, and the number of properties missing 7 . We considered a violation as an anomaly if the following three conditions where met: (1) its support exceeded 20, (1) its confidence exceeded 90%, and (3) it did not miss more than two properties. These constants were obtained by empirically testing a few alternatives in order to balance the number of false positives and true negatives, but we did not systematically investigate if these are the optimal values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Case study: AspectJ</head><p>The largest program in our set is ASPECTJ, a compiler for the AS-PECTJ language. ASPECTJ is an extension to the JAVA programming language making it possible to express cross-cutting concerns that can be later compiled into the bytecode. This is a sufficiently complex, big and mature project to put our technique to a good test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Object usage models</head><p>JADET analyzed 36,044 out of 36,045 methods defined in ASPECTJ and created 253,084 models in less than 14 minutes on a 1.83GHz Intel Core Duo.</p><p>Figure <ref type="figure" target="#fig_6">6</ref> shows a model of a java.util.Stack object mined from one of the methods in ASPECTJ. From this model, we can see that the stack was first created, then elements have been pushed to it in a loop and finally an enumeration of all the elements was 1 A somewhat similar idea of clustering execution profiles based on their similarity to find the faulty ones has been evaluated by Dickinson et al. <ref type="bibr" target="#b10">[10]</ref> and found very effective. 2 http://sourceforge.net/projects/act-rbot/ 3 http://www.eclipse.org/aspectj/ 4 http://azureus.sourceforge.net/ 5 http://columbamail.org/drupal/ 6 http://sourceforge.net/projects/musicomp/ 7 this can be thought of as the width of the hole in the block  requested. This model illustrates well the difference between approaches that base model states on object states and our approach that bases model states on locations in the code.</p><p>Although the first call to push() is bound to change the state of the object (from empty to non-empty), it does not result in statechanging transition in our model. This is because there is no difference between the first and the subsequent calls to push from the user's perspective. They are all part of a code that puts elements into the stack. If this code were split in, say, two loops, this would be represented in the model by two loops, as well. Similarly, the call to elements() that does not change the state of the stack is depicted as a state-changing transition in our model, because the way the stack is used has changed. We no longer put elements into it, but rather we extract them.</p><p>Another model is shown in Figure <ref type="figure" target="#fig_7">7</ref>. This model does not contain a single call with the object being modeled used as a target. Because of this, limiting model creation to include only such method calls (and not including "external" method calls) would result in an empty model. The model produced by JADET is quite interesting as it encompasses operations on several different classes in one entity. It shows how ASPECTJ's internal mapping between JAVA classes (java.lang.Class) and ASPECTJ type implementations (AjTypeImpl) works.</p><p>This model has been mined from the method called getAjType, which gets an AjTypeImpl object corresponding to a given Class object (subsequently called c). As we can see, the method uses a Map object to represent the mapping. It first checks whether the class c is already present in the map as a key. If it is not, new type implementation is created and the map is updated (the rightmost path in the model). If the class c is present in the map, it is checked whether the corresponding type implementation is up-to-date. If it is not, new type implementation is created and the map is updated (the leftmost path in the model). If the type implementation is upto-date, nothing else remains to be done (the middle path).</p><p>Overall, the mining process resulted in more than 250,000 models being created, and thus we found it impossible to investigate them all. Instead, we looked at a small sample of models mined and selected a number that we found interesting and that were small  enough to present (see also <ref type="bibr">Figures 8,</ref><ref type="bibr">9 and 10)</ref>. Due to the fact that our small sample already contained a large fraction of interesting models, we are confident that the remaining set contains many more models that could be suitable for program understanding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Programming patterns and anomalies</head><p>Mining programming patterns, finding violations, filtering and ranking anomalies for ASPECTJ took less than 4 minutes and reported 276 anomalies. Those anomalies encompassed 790 violations, occurring in 295 methods (recall that one anomaly may consist of several violations, each in a different method; also, one method may contain several violations). Figure <ref type="figure" target="#fig_9">11</ref> shows the frequency distribution of a number of violations exhibited by a single method. We inspected these 790 violations manually. Two of them were defects, five were code smells (meaning any program property that indicates something may go wrong <ref type="bibr" target="#b14">[14]</ref>) and 84 pointed to code that could be improved with respect to readability and/or maintainability (we will call such results "hints"). Five violations have not been classified, because the source code of the corresponding methods is not part of the ASPECTJ, even though the methods themselves are. The remaining 694 violations were false positives.</p><p>Our ranking method proved successful. The Top 10 anomalies (see Table <ref type="table" target="#tab_2">3</ref>) encompassed 15 violations, out of which two were defects (ranked 1st and 7th), three were code smells, one was a hint and nine were false positives (we actually examined eleven anomalies as the Top 10, because anomalies in the 10th and 11th position had identical defect indicators). It is important to notice that both defects and three out of five code smells were ranked in the Top 10. This reduces the impact of the large number of false positives. In practice, a programmer could spend time only on highly ranked violations and still hope to find the most interesting ones.</p><p>Let us now take a closer look at the defects that we have found. Figure <ref type="figure" target="#fig_1">12</ref> shows part of the method that contained the first defect (#165631 in the ASPECTJ bug database). The loop in this code processes only the first element returned by the iterator, even though it should process all of them. The pattern that is violated in this case is P = {hasNext() ≺ hasNext(), hasNext() ≺ next()}; and it is the property hasNext() ≺ hasNext() which is missing in the faulty method.  The second defect (#41069 in the BCEL bug database 8 ) is much more subtle. It occurs in the method visitCALOAD(), shown in Figure <ref type="figure" target="#fig_2">13</ref>. Here, P = {stack() ≺ constraintViolated(), stack() ≺ stack()} is the pattern that is violated (all of the methods were defined in the InstConstraintVisitor class). The task of visitCALOAD() is to check whether a given CALOAD bytecode instruction is legal. This instruction is part of a family of array loading instructions (AALOAD, BALOAD, CALOAD, etc.), each of which takes an array and an index from the stack and pushes back the value contained in the array under the given index. These instructions all differ by the expected type of the elements in the array; for CALOAD, for instance, this is char.</p><p>In order for the instruction to be legal, two conditions must be satisfied: The first element on the stack must be an array of appropriate type and the second element on the stack must be an integer. If these conditions are not satisfied, the method is required to call the constraintViolated() method.</p><p>The faulty method checks the second condition and the first half of the first condition, i.e. it checks whether the first element on 8 BCEL is used as part of ASPECTJ and the defect is located in a method defined by one of BCEL's classes public String getRetentionPolicy () { ... for (Iterator it = ...; it.hasNext();) { ... = it.next(); ... return retentionPolicy; } ... } Figure <ref type="figure" target="#fig_3">14</ref>: A code smell in ASPECTJ. The loop body is executed at most once-but this is not a defect, since the object iterated upon has at most one element, too.</p><p>the stack is an array, but not if the array is of an appropriate type. It does this using two helper methods which perform the actual check and call constraintViolated() themselves if the check fails. However, neither helper checks whether the array is of an appropriate type. Thus, visitCALOAD method itself would have to do the check and, in case it fails, call constraintViolated(). And this is this call that JADET discovered to be missing.</p><p>One should note that the first defect could have been found by tools that check for code violating a fixed set of rules, because the pattern here is very general, and constitutes an anomaly in almost every JAVA program. Finding the second defect, though, requires domain knowledge that cannot be coded in a universal rule. Thus, to find the defect, it is necessary to infer domain-specific patterns first, as exemplified by our approach.</p><p>Let us now take a look at the code smell ranked in the 2nd position. It is of interest to us, because it has a very high defect indicator (nearly as high as the defect on the 1st position) and yet is not a defect itself. The code of the anomalous method is shown in Figure <ref type="figure" target="#fig_3">14</ref>. It is very similar to the code of the defect shown in Figure <ref type="figure" target="#fig_1">12</ref> and, indeed, the pattern that is violated here is also very similar: P = {hasNext() ≺ hasNext(), hasNext() ≺ next(), next() ≺ hasNext(), next() ≺ next()}. The last two properties are missing in the anomalous method, i.e. it is not possible to call next twice on the same iterator object.</p><p>This time, however, this is not a defect. The collection through which the code iterates is a list of so-called retention policies associated with an annotation. Each annotation may have at most one retention policy associated with it, and so the collection holds at most one element. This is not documented in the code; it is clear that a simple if instead of a for loop should have been used. <ref type="foot" target="#foot_0">9</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">More experiments</head><p>Table 2 lists all programs we have tried JADET on. In each case, we looked at the Top 10 anomalies and classified them manually. <ref type="foot" target="#foot_1">10</ref>The summary of these experiments can be found in Table <ref type="table" target="#tab_3">4</ref>. Note that each anomaly may encompass more than one violation (as there may be many methods that violate the same pattern in the same way) and thus Top-10 anomalies may in fact mean "15 violations", as in the case of ASPECTJ. As can be seen, JADET is most effective on large programs, resulting in a large number of models. This is expected, because in order to find patterns (and thus be able to find violations), there must be enough data to support them. Also, our approach benefits from stability and consistency of the source code that makes the defects "stick out".</p><p>Our results show that JADET can find new defects in software, even in mature code like ASPECTJ. The second defect in ASPECTJ could not have possibly been found by any other existing tool; as illustrated in the examples, the main strength of our approach lies in it being able to construct project-specific patterns and violations thereof.</p><p>Additionally, our approach is fully automatic; the programmer is only required to take a look at the found anomalies and to decide whether they are real defects or not (admittedly, she has to be competent enough and the time needed to classify anomalies is highly dependent on the level of competencee; this problem, however, is shared by all unsound approaches to defect detection). In particular, she does not have to specify patterns nor in any way configure the tool to fit to the particular project that is to be analyzed. JADET is also very practical, having small execution times and a ranking system in place, thus freeing the user from the burden of examining all anomalies to select the most interesting ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Threats to validity</head><p>Out of five defects we have found in the test programs, four have been confirmed by the tool developers. The only defect that has not been confirmed is the second defect in ASPECTJ. The reason for this is that even though we found this defect by analyzing AS-PECTJ, this is a defect in BCEL and we submitted the bug report to the BCEL bug database. The project, however, is in a stagnation phase right now and bug reports are not being processed. Nevertheless, we created a small, incorrect .class file that passes verification by BCEL because of the issue we have discovered, so we know this is a real defect, even though we do not have any confirmation from the developers.</p><p>The main threat to the validity of our results are errors in the code that creates object usage models that are used as a basis for generating patterns. We have spent a long time on checking for correctness of the models that have been created for various programs. We have also created programs for which we constructed models by hand and then checked whether those created by JADET were identical. In the process we have found defects in the modelcreating code and those defects have been subsequently removed. We assume that any remaining defects (and imprecisions induced by not having points-to analysis) affect only a very small number of models.</p><p>Another threat is that we have investigated only five programs and it is possible that our results do not generalize. We have tried to mitigate this risk by choosing programs that have very different purposes and including two quite big, commonly used projects as subjects: ASPECTJ and AZUREUS.</p><p>Other potential problems include defects in frequent itemset mining or in the code that looks for violations and ranks anomalies. We think such errors are very improbable: the code that does frequent itemset mining and violations extraction is mature and has already been used several different projects and none of these projects discovered any defects in it. The code that ranks violations, on the other hand, is very simple and well tested, so that we expect it to be correct as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Mining temporal program behavior</head><p>Mining object usage models was inspired by the work of Eisenbarth et al. on object process graphs <ref type="bibr" target="#b11">[11]</ref>. Object usage models are similar to their object process graphs, but we focus on modeling objects from the point of view of single methods, without using expensive points-to analysis, and thus our approach scales to large programs.</p><p>Dynamic analysis has also been used to produce program models. Dallmeier et al. <ref type="bibr">[7]</ref> use so-called inspectors to discover state of the object at runtime. Lorenzoli et al. <ref type="bibr" target="#b23">[23]</ref> use anonymous states and transitions described by method calls annotated with parameters. Quante and Koschke <ref type="bibr" target="#b26">[26]</ref> create dynamic object process graphs and Xie et al. <ref type="bibr" target="#b34">[34]</ref> create abstract-object-state machines with states being described by possible return values of method calls. These approaches capture only true program behavior instead of a conservative approximation, but this also means that they need extensive test cases to produce at least somewhat complete results and automatic defect detection possibilities are limited.</p><p>Other researchers used approaches such as grammar learning <ref type="bibr" target="#b3">[3]</ref> or based on model checking <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b21">21]</ref>. These techniques are not fully automatic. Ammons et al. <ref type="bibr" target="#b3">[3]</ref> require manual annotations to relate functions to objects, while Alur et al. <ref type="bibr" target="#b2">[2]</ref> and Henzinger et al. <ref type="bibr" target="#b16">[16]</ref> rely on initial predicates to be able to get the first abstraction of the program. Liu et al. <ref type="bibr" target="#b21">[21]</ref> require specifying sets of functions as input and find instantiations of six categories of rules over those functions.</p><p>The PERRACOTTA tool of Yang and Evans <ref type="bibr" target="#b36">[36]</ref> also mines temporal rules of program behavior. Their approach can only discover behavior that fits into templates (such as alternation) provided by the user. Williams and Hollingsworth <ref type="bibr" target="#b33">[33]</ref> mine software repositories to find function usage patterns where one function is directly called after another one (perhaps conditionally), which is more limited than our approach. Some research has also been done in the area of supporting programmers by providing them with examples of usages of a particular API. Tools that address this problem include MAPO by Xie and Pei <ref type="bibr" target="#b35">[35]</ref>, PROSPECTOR by Mandelin et al. <ref type="bibr" target="#b24">[24]</ref> and XSNIPPET by Sahavechaphan and Claypool <ref type="bibr" target="#b29">[29]</ref>.</p><p>Cook and Wolf <ref type="bibr" target="#b6">[6]</ref> have written the seminal work on inferencing finite-state machines from event sequences, where they compare Markov methods, neural networks, and grammar inference as means to construct models; their work applies on software development processes, though.</p><p>All of the approaches that mine temporal properties produce representations that can also be used as specifications. In addition, there are also approaches that suggest various formalisms for specifications of temporal behavior. These approaches include the type-state concept by Strom and Yemini <ref type="bibr" target="#b30">[30]</ref>, protocols by Yellin and Strom <ref type="bibr" target="#b37">[37]</ref>, interface automata by de Alfaro and Henzinger <ref type="bibr" target="#b1">[1]</ref> and the idea of treating objects as regular processes presented by Nierstrasz <ref type="bibr" target="#b25">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Automatic defect detection</head><p>Finding patterns was inspired by the PR-MINER tool of Li and Zhou <ref type="bibr" target="#b19">[19]</ref> who use frequent itemset mining to find sets of functions, variables and data types that frequently appear together. In contrast, our approach takes ordering into account and is thus able to find defects (like the first defect in ASPECTJ) that could not be found using PR-MINER.</p><p>In a recent work, Ramanathan et al. <ref type="bibr" target="#b27">[27]</ref> describe CHRONICLER, a tool for mining precedence relations among procedure calls. Their approach is interprocedural and can thus find patterns spanning multiple functions, but is restricted to "must precede" relations (in contrast to our "can precede") and is thus suited to finding a different class of defects than our method. CHRONICLER is also object-insensitive.</p><p>Our ranking method for anomalies was inspired by clustering algorithm used by Dickinson et al. <ref type="bibr" target="#b10">[10]</ref> to find faulty executions based on their profiles. Dallmeier et al. <ref type="bibr" target="#b8">[8]</ref> used differences in sequences of method calls between passing and failing runs to detect defects, but they use dynamic analysis (so that they need a test that fails in order to find a defect) and their granularity (finding defective classes) is larger than ours (finding defective methods). Weimer and Necula <ref type="bibr" target="#b31">[31]</ref> learn pairs of matching functions (like open and close) from method-call traces and look for violations of these pairings in error-handling code only.</p><p>Livshits and Zimmermann <ref type="bibr" target="#b22">[22]</ref> use software repositories to mine coding patterns and look for their violations in the DYNAMINE tool. In order to find a pattern, DYNAMINE needs to have it added to the repository after the first revision and be confirmed using dynamic analysis afterwards. Kim et al. <ref type="bibr" target="#b18">[18]</ref> developed BUGMEM, using fixes mined from software repositories to construct patterns of defects and their fixes. Both approaches require extensive history of software revisions in repository to be effective.</p><p>Yang and Evans <ref type="bibr" target="#b36">[36]</ref> also focused on finding defects, but their approach is limited to finding behavior that fits into templates provided by the user. Engler et al. <ref type="bibr" target="#b12">[12]</ref> also used such a template-based approach. Hovemeyer and Pugh <ref type="bibr" target="#b17">[17]</ref> created FINDBUGS, which statically looks for a priori specified bug patterns.</p><p>Fink et al. <ref type="bibr" target="#b13">[13]</ref> look for violations of a specification given as a typestate, so they can mark a sequence of method calls as faulty only if it was specified as erroneous by the typestate. Reiss <ref type="bibr" target="#b28">[28]</ref> developed the CHET system that allows programmers to specify the way a component should be used and checks these specifications. The SLAM tool by Ball and Rajamani <ref type="bibr" target="#b5">[5]</ref> uses a model checker to validate temporal safety properties. DeLine and Fähndrich <ref type="bibr" target="#b9">[9]</ref> created FUGUE, a tol that allows for specifying typestates for objects and checking the code for conformance to those typestates. Antoy and Hamlet <ref type="bibr" target="#b4">[4]</ref> instrument code defining abstract data types to check operations for conformance with an algebraic specification. In each of those cases, the specification has to be entered manually.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS AND CONSEQUENCES</head><p>Our experiments with JADET have successfully demonstrated that our approach can effectively detect new defects in software, even in mature code like ASPECTJ. The approach is fully automatic, requires few resources, and scales up to very complex systems. As it leverages existing code to find anomalies, it automatically adapts to the project conventions at hand. JADET is thus complementary to existing approaches that focus on single methods or check uni-versal programming rules; as a side effect, it promotes consistency in object usage across the product code.</p><p>JADET is light-weight and yet effective, given the large percentage of true defects and code smells among the top ranked anomalies. We expect an even higher detection rate in earlier software production stages. Despite these early successes, we still see much room for improvement. Our future work will focus on the following topics: Improved code analysis. JADET has a number of limitations in its current implementation when it comes to analyzing code. It does not analyze the whole JAVA language: multithreading and reflection are not supported and instructions that belong to either of these categories are silently ignored during analysis. Fields are always treated as holding an unknown value. Furthermore, JADET does not implement points-to analysis. Addressing these issues would improve accuracy of usage models and can easily be overcome by augmenting the tool. However, this may hurt our goal of creating a tool that is practical and scalable to large programs; and it is not certain whether defect detection would improve as well.</p><p>Improved patterns. The patterns we are currently using reflect only a small part of the knowledge present in models. In particular, we do not make a distinction between normal and exceptional returns; we also abstract away most of the structural information present in the models. For instance, our patterns can not distinguish between some set of methods being called a fixed number of times and the same set being called in a loop, even though this information is present in the object usage models.</p><p>Negative examples. Another possible enhancement is extending the definition of the pattern to include not only information about things that are expected to happen, but also information about things that are expected not to happen. As a simple motivational example, consider a class that expects its clients to call one of many "initializer" methods before performing any other operation. This typically means that clients are allowed to call exactly one of these methods. Expressing this fact in patterns would allow us to discover cases where more than one "initializer" method is called.</p><p>Portable models. Right now, identifying patterns and models requires an existing code base that is "mostly correct". In practice, it could therefore be helpful to reuse patterns from existing projects. While this is straight-forward for projects that use the same classes directly, we are investigating measures that would account for usage of similar classes, as well as indirect class usage.</p><p>In general, we find that existing software encodes lots of knowledge that can and should be leveraged for improving quality. We hope that object usage models can make a small, but distinct contribution for leveraging this knowledge.</p><p>For future and related work regarding object usage models, see http://www.st.cs.uni-sb.de/models/</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: How JADET works. JADET extracts object usage models from JAVA methods. The resulting method call patterns are fed into a classifier which detects abnormal usage.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Code exercising vector-manipulating methods.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Method model of the createStack() method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Object usage model of the stack variable defined in the createStack() method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>We assign to each pattern P the set of classes C(P), methods called on which are part of the pattern. For instance, in case of a pattern P = {X.x() ≺ Y.x(), Y.x() ≺ Y.y()} we would have C(P) = {X, Y }. • We assign to each JAVA class C the number na(C) of anomalies, for which the pattern they violate contains a call to one of the methods of the class C. Formally, na(C) = |{A | A is an anomaly violating a pattern P, where C ∈ C(P)}|. This tells us the number of anomalies that are related to C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Stack model mined from ASPECTJ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Class model mined from ASPECTJ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>Figure 9: StringTokenizer model mined from ASPECTJ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Frequency distribution of a number of violations exhibited by a single method in ASPECTJ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :Figure 13 :</head><label>1213</label><figDesc>Figure 12: A defect in ASPECTJ. The loop body is executed at most once. public void visitCALOAD (CALOAD o) { Type arrayref = stack().peek(1); Type index = stack().peek(0); indexOfInt(o, index); arrayrefOfArrayType(o, arrayref); } Figure 13: Another defect in ASPECTJ. The method should check the array type, and call constraintViolated() if the check fails.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Details of the JADET case study subjects</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2"># Methods</cell><cell></cell><cell></cell><cell></cell><cell>Mining time</cell></row><row><cell>Program</cell><cell cols="3"># Classes Analyzed</cell><cell cols="6">Total # Models # Patterns # Anomalies Models Anomalies</cell></row><row><cell>ACT-RBOT 0.8.2</cell><cell cols="2">2,492</cell><cell cols="2">26,501 26,531</cell><cell>187,137</cell><cell>436</cell><cell>192</cell><cell>9:03</cell><cell>0:53</cell></row><row><cell>ASPECTJ 1.5.3</cell><cell cols="2">2,957</cell><cell cols="2">36,044 36,045</cell><cell>253,084</cell><cell>666</cell><cell>276</cell><cell>13:19</cell><cell>3:47</cell></row><row><cell>AZUREUS 2.5.0.0</cell><cell cols="2">3,585</cell><cell cols="2">22,359 22,367</cell><cell>157,313</cell><cell>1244</cell><cell>365</cell><cell>7:28</cell><cell>0:50</cell></row><row><cell>COLUMBA 1.2</cell><cell cols="2">1,165</cell><cell>6,894</cell><cell>6,894</cell><cell>54,371</cell><cell>97</cell><cell>64</cell><cell>2:06</cell><cell>0:11</cell></row><row><cell>MUSICOMP 1.0 beta</cell><cell cols="2">347</cell><cell>2,078</cell><cell>2,079</cell><cell>17,321</cell><cell>3</cell><cell>3</cell><cell>1:02</cell><cell>0:04</cell></row><row><cell></cell><cell>c.isArray()</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">c.getComponentType()</cell><cell cols="2">c.getName()</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>Figure 8: Class model mined from ASPECTJ. st.&lt;init&gt;() st.nextToken() st.countTokens()</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Top 10 anomalies for ASPECTJ.</figDesc><table><row><cell cols="4">Rank Defect ind. Support Uniq. factor Anomaly type</cell></row><row><cell>1</cell><cell>174.25</cell><cell>697</cell><cell>0.250 defect</cell></row><row><cell>2</cell><cell>174.00</cell><cell>696</cell><cell>0.250 code smell</cell></row><row><cell>3</cell><cell>25.00</cell><cell>50</cell><cell>0.500 hint</cell></row><row><cell>4</cell><cell>20.00</cell><cell>20</cell><cell>1.000 false positive</cell></row><row><cell>5</cell><cell>19.67</cell><cell>59</cell><cell>1.000 3 × false positive</cell></row><row><cell>6</cell><cell>19.00</cell><cell>38</cell><cell>0.500 false positive</cell></row><row><cell>7</cell><cell>14.87</cell><cell>119</cell><cell>0.125 defect</cell></row><row><cell>8</cell><cell>13.00</cell><cell>26</cell><cell>1.000 2 × code smell</cell></row><row><cell>9</cell><cell>12.00</cell><cell>24</cell><cell>1.000 2 × false positive</cell></row><row><cell>10</cell><cell>11.50</cell><cell>23</cell><cell>0.500 false positive</cell></row><row><cell>10</cell><cell>11.50</cell><cell>23</cell><cell>0.500 false positive</cell></row><row><cell cols="4">private boolean verifyNIAP (...) {</cell></row><row><cell>...</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Iterator iter = ...;</cell><cell></cell></row><row><cell cols="3">while (iter.hasNext ()) {</cell><cell></cell></row><row><cell></cell><cell cols="2">... = iter.next ();</cell><cell></cell></row><row><cell></cell><cell>...</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">return verifyNIAP (...);</cell></row><row><cell>}</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">return true;</cell><cell></cell><cell></cell></row><row><cell>}</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>A classification of the top 10 anomalies for the case study subjects. In all investigated programs, JADET makes suggestions that improve code quality.</figDesc><table><row><cell>Program</cell><cell cols="3"># Defects # Code # Hints</cell><cell># False</cell></row><row><cell></cell><cell></cell><cell>smells</cell><cell></cell><cell>positives</cell></row><row><cell>ACT-RBOT 0.8.2</cell><cell>2</cell><cell>0</cell><cell>13</cell><cell>4</cell></row><row><cell>ASPECTJ 1.5.3</cell><cell>2</cell><cell>3</cell><cell>1</cell><cell>9</cell></row><row><cell>AZUREUS 2.5.0.0</cell><cell>1</cell><cell>2</cell><cell>6</cell><cell>4</cell></row><row><cell>COLUMBA 1.2</cell><cell>0</cell><cell>0</cell><cell>3</cell><cell>17</cell></row><row><cell>MUSICOMP 1.0 beta</cell><cell>0</cell><cell>0</cell><cell>4</cell><cell>6</cell></row><row><cell></cell><cell>5</cell><cell>5</cell><cell>27</cell><cell>40</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_0"><p>The acute reader may have noticed that the patterns in this example and in the first defect are different, when in fact they should not be. The reason for this is impreciseness of the dataflow analysis. The for loop in the code smell we have just examined is enclosed in another loop and the iterator "reaches" the hasNext instruction of the next iteration of the outer loop just before it is "killed". We plan to solve this problem as part of the future work on increasing the precision of the analysis.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_1"><p><ref type="bibr" target="#b10">10</ref> The ACT-RBOT program contained libraries it used included in its own "jar" file instead of them being packaged in different "jar" files. As a result, only five of Top 10 anomalies were anomalies in the program itself and these were the only ones we examined.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. Martin Burger, Valentin Dallmeier, Stephan Neuhaus, Rahul Premraj, David Schuler, and Thomas Zimmermann, as well as the anonymous reviewers, provided helpful and constructive comments on earlier revisions of this paper. Andrzej Wasylkowski is funded by the DFG-Graduiertenkolleg "Leistungsgarantien für Rechnersysteme".</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Interface automata</title>
		<author>
			<persName><forename type="first">L</forename><surname>Alfaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE-9: Proc. of the 8th European Software Engineering Conference held jointly with 9th ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="109" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Synthesis of interface specifications for Java classes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Černý</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Nam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;05: Proc. of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="98" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Mining specifications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ammons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;02: Proc. of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="4" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatically checking an implementation against its formal specification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Antoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hamlet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="69" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatically validating temporal safety properties of interfaces</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPIN &apos;01: Proc. of the 8th International SPIN Workshop on Model Checking of Software</title>
		<imprint>
			<publisher>Springer-Verlag New York, Inc</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="103" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Discovering models of software processes from event-based data</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="215" to="249" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Mining object behavior with ADABU</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dallmeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lindig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wasylkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WODA &apos;06: Proc. of the Fourth International Workshop on Dynamic Analysis</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="17" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Lightweight defect localization for Java</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dallmeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lindig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP &apos;05: European Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Black</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Typestates for objects</title>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECOOP &apos;04: European Conference on Object-Oriented Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3086</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Finding failures by cluster analysis of execution profiles</title>
		<author>
			<persName><forename type="first">W</forename><surname>Dickinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podgurski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;01: Proc. of the 23rd International Conference on Software Engineering</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="339" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Static object trace extraction for programs with pointers</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vogel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="263" to="284" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Bugs as deviant behavior: a general approach to inferring errors in systems code</title>
		<author>
			<persName><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;01: Proc. of the 18th ACM Symposium on Operating Systems Principles</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="57" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Effective typestate verification in the presence of aliasing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ramalingam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Geay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSTA &apos;06: Proc. of the International Symposium on Software Testing and Analysis</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="133" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Improving the design of existing code</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName><surname>Refactoring</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Data mining: concepts and techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kamber</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Permissive interfaces</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wermelinger and Gall</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Finding bugs is easy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hovemeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="92" to="106" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Memories of bug fixes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E E</forename><surname>James Whitehead</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE-14: Proc. of the 14th ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="35" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">PR-Miner: automatically extracting implicit programming rules and detecting violations in large software code</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wermelinger and Gall</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="306" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mining patterns and violations using concept analysis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lindig</surname></persName>
		</author>
		<ptr target="http://code.google.com/p/colibri-ml/" />
	</analytic>
	<monogr>
		<title level="m">the software is available from</title>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
		<respStmt>
			<orgName>Saarland University, Software Engineering Chair</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">LtRules: an automated software library usage rule extraction tool</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Richardson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;06: Proc. of the 28th International Conference on Software Engineering (tool demonstrations)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="823" to="826" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">DynaMine: finding common error patterns by mining software revision histories</title>
		<author>
			<persName><forename type="first">B</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wermelinger and Gall</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="296" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Inferring state-based behavior models</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lorenzoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mariani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pezzè</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WODA &apos;06: Proc. of the Fourth International Workshop on Dynamic Analysis</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Jungloid mining: helping to navigate the API jungle</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mandelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kimelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;05: Proc. of the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="48" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Regular types for active objects</title>
		<author>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA &apos;93: Proc. of the 8th Annual Conference on Object-Oriented Programming Systems, Languages, and Applications</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Dynamic object process graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Quante</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSMR &apos;06: Proc. of the 10th European Conference on Software Maintenance and Reengineering</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Path-sensitive inference of function precedence protocols</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Ramanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Grama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jagannathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;07: Proc. of the 29th International Conference on Software Engineering</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="240" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Specifying and checking component usage</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Reiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AADEBUG &apos;05: Proc. of the Sixth International Symposium on Automated and Analysis-Driven Debugging</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">XSnippet: mining for sample code</title>
		<author>
			<persName><forename type="first">N</forename><surname>Sahavechaphan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Claypool</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA &apos;06: Proc. of the 21st Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="413" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Typestate: A programming language concept for enhancing software reliability</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yemini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="157" to="171" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Mining temporal specifications for error detection</title>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS &apos;05: Proc. of the 12th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Zuck</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="461" to="476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Wermelinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gall</surname></persName>
		</author>
		<title level="m">Proc. of the 10th European Software Engineering Conference held jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
		<meeting>of the 10th European Software Engineering Conference held jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005-09-05">2005. September 5-9, 2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Recovering system specific rules from software repositories</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Hollingsworth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MSR &apos;05: Proc. of the 2005 International Workshop on Mining Software Repositories</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Automatic extraction of abstract-object-state machines from unit-test executions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yuan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;06: Proc. of the 28th International Conference on Software Engineering</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="835" to="838" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">MAPO: mining API usages from open source repositories</title>
		<author>
			<persName><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MSR &apos;06: Proc. of the 2006 International Workshop on Mining Software Repositories</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="54" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Perracotta: mining temporal API rules from imperfect traces</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bhat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;06: Proc. the 28th International Conference on Software Engineering</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="282" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Protocol specifications and component adaptors</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Yellin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Strom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="292" to="333" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
