<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Preventing Accidental Data Disclosure in Modern Operating Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Adwait</forename><surname>Nadkarni</surname></persName>
							<email>anadkarni@ncsu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">North Carolina State University</orgName>
								<address>
									<settlement>Raleigh</settlement>
									<region>North Carolina</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">William</forename><surname>Enck</surname></persName>
							<email>enck@cs.ncsu.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">North Carolina State University</orgName>
								<address>
									<settlement>Raleigh</settlement>
									<region>North Carolina</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Preventing Accidental Data Disclosure in Modern Operating Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">409133D7B3D80CFA4D3CA4D61CDECCDD</idno>
					<idno type="DOI">10.1145/2508859.2516677</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.4.6 [Operating Systems]: Security and Protection-access controls, information flow controls OS security</term>
					<term>access control</term>
					<term>information flow control</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Modern OSes such as Android, iOS, and Windows 8 have changed the way consumers interact with computing devices. Tasks are often completed by stringing together a collection of purpose-specific user applications (e.g., a barcode reader, a social networking app, a document viewer). As users direct this workflow between applications, it is dicult to predict the consequence of each step. Poor selection may result in accidental information disclosure when the target application unknowingly uses cloud services. This paper presents Aquifer as a policy framework and system for preventing accidental information disclosure in modern operating systems. In Aquifer, application developers define secrecy restrictions that protect the entire user interface workflow defining the user task. In doing so, Aquifer provides protection beyond simple permission checks and allows applications to retain control of data even after it is shared.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Operating system security architectures are currently undergoing a fundamental change. Modern OSes <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b41">42]</ref>, such as Android, iOS, and Windows 8, take the suggestion of decades of security research <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b13">14]</ref> and run each application as a unique security principal. While having finergrained security principals prevents many obvious attacks, complete sandboxing <ref type="bibr" target="#b18">[19]</ref> is inadequate.</p><p>Applications share data with one another, perhaps more so now than in the past. Consider the Android platform where applications are designed to work together to perform a larger, user-defined task. For example, a shopping app might: 1) invoke a barcode scanner app that uses the camera to read the UPC from an item, 2) look up that item on the Web, and then 3) use a social networking app to share the item and best deal with friends. This modularity strikes a balance between simple UNIX tools (e.g., sed, grep) and monolithic GUI applications (e.g., MS O ce).</p><p>A key challenge for modern OS security is controlling this user-directed workflow between apps and preventing accidental information disclosure. For example, a photo of a whiteboard containing meeting notes might be inadvertently uploaded to a social networking site, or a confidential document might be inadvertently stored on a cloud server when viewed. Accidental disclosure is growing concern for consumer privacy, and has been a large concern for companies and organizations attempting to comply with the many data security compliance standards, e.g., HIPAA <ref type="bibr" target="#b38">[39]</ref>, GLBA <ref type="bibr" target="#b37">[38]</ref>, PCI DSS <ref type="bibr" target="#b29">[30]</ref>, and IRS 1075 <ref type="bibr" target="#b39">[40]</ref>.</p><p>Preventing accidental disclosure is not as simple as restricting the set of applications an application with sensitive data can interact with (e.g., Saint <ref type="bibr" target="#b28">[29]</ref>). A trusted application receiving data might share that data with another application that has unexpected disclosure. Hence, in a collaborative application environment, we must address the accidental disclosure problem as one of information flow. Specifically, we identify the data intermediary problem as a growing concern for modern OSes. The data intermediary problem is a subtype of secure information flow vulnerability that results when user choices dictate data flows between user-facing apps and apps lose control of the data.</p><p>In this paper, we present Aquifer as a policy framework and system to mitigate accidental information disclosure in modern operating systems. Aquifer is specifically designed to protect large, application-specific, user data objects such as o ce documents, voice or written notes, and images. In Aquifer, developers of applications that originate data objects specify secrecy restrictions based on the runtime context and the purpose of the app. This policy restricts all apps participating in a user interface workflow that Aquifer dynamically constructs as the user navigates di↵erent applications. Aquifer enforces two types of secrecy restrictions: export restrictions ensure only specific apps can export the data o↵ the host, and required restrictions ensure that specific apps are involved in workflows when exporting controlled data objects read from persistent storage. This policy is specified using a decentralized information flow control (DIFC) motivated language that allows many data owners on a workflow to participate in secrecy restrictions. In e↵ect, Aquifer allows applications to gain control of shared sensi-tive data, thereby addressing the data intermediary problem for these large data objects.</p><p>This paper makes the following contributions:</p><p>• We identify the data intermediary problem as a growing concern for modern operating systems. While the data intermediary problem is present in traditional commodity OSes, the lack of application separation did not expose it as a concern.</p><p>• We propose the Aquifer policy framework for addressing accidental disclosures that result from the data intermediary problem in modern OSes. Aquifer allows app developers to contribute DIFC-based secrecy restrictions to protect application-specific data objects.</p><p>We formally define the policy logic and prove its safety.</p><p>• We provide a proof-of-concept implementation of Aquifer and integrate it with Android. We demonstrate how Aquifer can be practically realized within an existing platform, and provide three case studies by modifying popular open source applications.</p><p>The remainder of this paper proceeds as follows. Section 2 provides a use case and problem definition. Section 3 overviews our approach. Section 4 formally defines the Aquifer policy logic. Section 5 describes the Aquifer system design. Section 6 details the implementation. Section 7 evaluates Aquifer's policy compatibility and performance. Section 8 discusses limitations. Section 9 overviews related work. Section 10 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MOTIVATION AND PROBLEM</head><p>Modern operating systems such as Android, iOS, and Windows 8 present a new programming abstraction for software developers. Instead of placing all functionality into a single window with multiple dialog boxes, the application's user interface is separated into multiple screens where each screen handles a specific task. To complete a task, the user navigates through a series of screens. These screens may be in the same or di↵erent applications. For example, Android applications use intents addressed to action strings (see Section 2.4) to help the OS find the best application for a task. Similarly, Windows 8 provides "share charms" to help users complete tasks with di↵erent applications. Finally, iOS provides limited sharing and navigation between applications using URL protocol handlers.</p><p>In each of these OSes, applications are treated as separate security principles, although the specific security mechanisms di↵er. Android separates applications as di↵erent UNIX user IDs, and Windows 8 uses SUIDs. In contrast, iOS runs all applications as the mobile user with a generic sandbox policy. However, digital signatures are used to identify applications, and permission state (e.g., location access) is saved per-application.</p><p>Throughout the remainder of the paper, we frequently use Android to simplify discussion and provide concrete examples. Our choice of Android is motivated by several factors. Most importantly, Android provides the most flexible sharing model between applications. As the following discussion will make clear, sharing data between applications underlies the security problem. Android is also open source, used by hundreds of millions of consumers, and well described in security literature. We believe that other modern OSes A confidential contract received via Email is 1) read in a viewer, 2) converted to PDF, 3) embedded with a written signature, and 4) Emailed back to the sender.</p><p>that provide clear sharing abstractions (e.g., share charms in Windows 8) can benefit from our policy abstractions and design; however the implementation details will di↵er.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Use Case: Signing a Document</head><p>The following example provides a simple use case of how a user Alice might physically sign a document using several applications in a modern OS. Note that this is just one of many potential ways Alice can execute this task.</p><p>Alice receives a confidential contract in her business Email app. She needs to sign and return the contract, but does not have access to a printer or a scanner. Therefore, Alice uses the DocuSign app on her smartphone to digitally attach a written copy of her signature. The task begins by Alice accessing the message containing contract.doc in the Email app. Alice reads contract.doc by sharing it with the DocuView app. After reading contract.doc, Alice wishes to sign it with DocuSign; however, DocuSign only operates on PDF files. Therefore, Alice shares contract.doc with the WordToPDF app to create contract.pdf, which returns the PDF to DocuView. Alice then shares contract.pdf with DocuSign, which embeds a copy of her written signature, creating signed.pdf. The file is then shared with the Email app to return the signed contract via Email. This task workflow is depicted in Figure <ref type="figure" target="#fig_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Problem Definition</head><p>The document signing use case provides an example of how a user might combine several applications to accomplish a task. In the example, the business Email app received a confidential contract. Based on the email headers, Email knows contract.doc should not be exported o↵ of the host by any application except itself. However, Alice needs to modify contract.doc in ways that Email does not support. One of the valuable features of modern OSes is the large collection of third-party applications that act as modules to perform specific tasks. While these apps provide valuable functionality, they also present a security risk: once Email shares contract.doc with another app, it loses control of it, which may result in accidental disclosures that violate compliance regulations (e.g., HIPAA <ref type="bibr" target="#b38">[39]</ref>, GLBA <ref type="bibr" target="#b37">[38]</ref>, PCI DSS <ref type="bibr" target="#b29">[30]</ref>, and IRS 1075 <ref type="bibr" target="#b39">[40]</ref>). For example, the WordToPDF application might perform the PDF conversion on a cloud server, or DocuView might synchronize viewed documents with cloud storage. Similarly, signed.pdf containing the user's written signature should only be used when the user intends. The user may be unaware (or not think of) the sometimes subtle implications of selecting which apps to use.</p><p>The preceding example demonstrates the data intermediary problem. This problem occurs whenever the user directs an application to share sensitive data with another application that may not be trusted with that data. From the Email app's perspective, all of the other applications are data intermediaries in performing the user's task of signing contract.doc. We have created a specific term for this subproblem to di↵erentiate it from secure information flow problems that result from background processing. The data intermediary problem is specific to information flows that result from user choices in selecting applications to process data. Furthermore, the problem is most apparent in modern OSes, because they 1) distinguish applications as security principals, and 2) provide modular applications to perform larger user tasks. We note that the data intermediary problem has always been present in operating systems; however, it made little sense to discuss when all user applications ran with the user's ambient authority.</p><p>For the purposes of this paper, we focus on the data intermediary problem with respect to accidental data disclosure that results from user selection. We leave the much harder threat model of a malicious application as the motivation for future work. However, we note that the primitives described in this paper can form the basis of a system to defend against this stronger adversary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Threat Model</head><p>While our work is motivated by data security compliance regulations, we do not focus on the specific compliance rules themselves. Instead, we seek to address the broader challenge of creating mechanisms that help prevent the accidental disclosure portion of the data intermediary problem. We are specifically concerned with preventing the accidental export of large, application-specific, user data. There are potentially many data owners with di↵erent secrecy requirements. Therefore, an application may be both a data owner and a data intermediary, depending on the policy perspective, and each data owner's secrecy requirements must be met, even if doing so prevents data from being used.</p><p>Accidental data disclosure may occur in various ways. The user may share data with the wrong application (e.g., sharing a photo of whiteboard meeting notes via a social networking app). Such data export may not comply with the owner's policy, but may still occur through the user's interaction. Poorly programmed applications may also unknowingly leak private data to the cloud. For example, a document editor might backup documents to the cloud, and an app might send data as part of targeted advertisements.</p><p>The work in this paper does not seek to prevent malicious data disclosure. That is, we do not address side channels or collusion between applications. We also do not consider malicious daemons that operate outside our confinement. Finally, we are specifically concerned with data on the host and do not address exposure of data from cloud services once it is allowed to leave the host.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Background: Android</head><p>Android runs a Linux kernel, but defines its own application runtime environment. The Java-based middleware API forces developers to design their applications within a component framework. Android defines four component Android's binder framework provides process control and IPC between components. Applications generally do not interact with binder directly. Instead, they use intent messages, which start activity and service components, and send messages to broadcast receiver components. The key attribute of intent messages is their ability to be sent to implicit addresses. For this, Android uses action strings, such as ACTION_VIEW and ACTION_SEND. Applications define intent filters to register to receive messages addressed to specific action strings. The Android framework then automatically determines potential intent message destinations (i.e. resolves the intent), presenting the user with a list of targets if a single destination must be chosen from a set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">OVERVIEW</head><p>Aquifer is designed around the concept of a user interface workflow. As previously discussed, an emergent property of modern OS applications is that they are relatively simple, purpose or service specific, and often combined with other apps to perform a larger task. When the user performs a task, the execution transitions between UI screens. The next UI screen can be in the same or di↵erent application. Aquifer tracks the specific instances of the UI screens used to perform the user's task and abstracts them as a UI workflow.</p><p>Security policy is applied to the UI workflow abstraction, as shown in Figure <ref type="figure">2</ref>. We choose the UI workflow abstraction to define security policy, because it approximates the task at hand. All operations performed as part of this task will have similar security requirements. Frequently, the task will be centered around a single data object and its derivative objects, as demonstrated in the document signing use case.</p><p>Note that UI workflows are not necessarily linear. They are dynamically defined as the user navigates functionality on the host. This includes branches to perform subtasks. For example, a user interacting with a shopping application may navigate to a barcode scanner to retrieve the UPC code of a product via a camera. When this branch returns, the user continues the task. As shown in Figure <ref type="figure">2</ref>  Figure <ref type="figure" target="#fig_1">3</ref> depicts the Aquifer architecture for Android. Aquifer provides an API for applications to manage policy. This policy is enforced by the Aquifer System, which places hooks into Android's Activity Manager service. Finally, Aquifer has a small kernel component to monitor file communication.</p><p>Aquifer is built around the following principles: Decentralized policy specification: Modern OSes increasingly contain application-specific data. Therefore OS providers cannot practically define security policy. Instead, Aquifer uses the multiple-owner policy semantics of decentralized information flow control (DIFC) <ref type="bibr" target="#b26">[27]</ref>. Since each application is a potential stakeholder on data, DIFC provides a well-founded notion of data ownership and an articulation in each context of what each principal is trusted to do with that data. Developers &amp; Users define policy: The developers of applications that own data can frequently identify security sensitive data. Aquifer then infers user intention from the UI workflow. While this reduces the burden on the user, it does not entirely eliminate it. Sometimes the application must distinguish between confidential and public data. This context can frequently be acquired via preliminary labeling, which ranges by application. For example, the Email app in our use case could determine secrecy requirements from an Email header set by the sender. Applications such as note apps (e.g., Evernote) already have semantic tags on data (e.g., business, personal) that can be leveraged. User data labeling has been shown to be useful for specifying policy <ref type="bibr" target="#b22">[23]</ref>. In other cases (e.g., DocuSign), the policy specification is inherent to the functionality of the app. Compatibility with legacy applications: Aquifer focuses protection on large, application-specific, data objects. Applications frequently process these data objects locally. This allows Aquifer to be compatible with most legacy applications and only requires modifications of applications that must specify policy (i.e., data owners). If no secrecy restrictions are specified, Aquifer uses a default-allow policy. Minimizing policy violations: Policy violations confuse users by either prompting the user to make security decisions, or breaking functionality. Aquifer helps minimize policy violations by allowing applications to influence the functionality available to users. For example, Android uses "action strings" (e.g., ACTION_SEND, ACTION_VIEW, ACTION_EDIT) that help the OS find an appropriate consumer for shared data. When Android finds multiple possible recipients, the user is presented a list of targets from which to choose. Similar functionality is provided by Windows 8's share charm. If the user chooses a target application that attempts to ex-port data, and the UI workflow export restriction denies the app to use the network, a security exception will result. Often, this will break the functionality of the app, resulting in a poor user experience. Therefore, to prevent such scenarios from even occurring, Aquifer allows a data owner to specify a UI workflow filter that limits the potential targets. Compatibility with background functionality: UI screens may communicate with daemons (e.g., service and content provider components in Android). If interaction with a daemon passes sensitive data between two UI workflows, e.g., between screens C and Y in Figure <ref type="figure">2</ref>, Aquifer must propagate the policy restrictions to the receiving workflow. However, Aquifer cannot simply propagate the workflow security policy to the daemon process, as this would cause the daemon and subsequent UI workflows to be restricted by all previous UI workflow policies. Ultimately this would result in an unusable system. Therefore, Aquifer requires a more precise method of tracking information within daemons. For this, Aquifer could leverage systems such as TaintDroid <ref type="bibr" target="#b12">[13]</ref> and CleanOS <ref type="bibr" target="#b36">[37]</ref>. However, the primary focus of this paper is the ability to specify and enforce security policies with respect to the UI workflow. Therefore, for our prototype implementation, we use a lighter weight heuristic based on tracking file descriptors used by daemons (see Section 5.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">AQUIFER POLICY</head><p>A key challenge of Aquifer is defining the appropriate policy semantics for addressing the data intermediary problem in modern OSes. We first motivate the security policy types supported by Aquifer and then formally define the logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Policy Types</head><p>The primary concern of Aquifer is accidental export of high-value, application-specific user data. Therefore, our secrecy restrictions are defined with respect to export control. Export restrictions allow any functionality on the host, but prevent leakage to remote parties that are not mediated by the framework. As mentioned in Section 3, Aquifer uses a default-allow policy to ensure compatibility with legacy applications processing unconstrained data objects. However, the policy becomes default-deny if restrictions are present.</p><p>Based on a manual survey of Android applications, we identified the need for the following secrecy restrictions. Export Restrictions: The most basic type of secrecy restriction is a whitelist of applications that are allowed to send data o↵ the device. Frequently, the whitelist contains only the application that specifies the export restriction. For example, in the document signing use case in Section 2, the Email app wishes to ensure that only it can send contract.doc and derivative files o↵ the host. We allow an application to specify a list to support suites of applications or lists of known trusted applications. Required Restrictions: The second type of secrecy restriction is motivated by copies of files left on persistent storage. Required restrictions ensure that cached copies of files cannot be later exported without the knowledge of the data owner. In our document signing use case, DocuSign may wish to protect the handwritten signature of Alice by ensuring that a file containing the signature can only be sent o↵ the device when DocuSign participates in the workflow. Since DocuSign is the trusted authority for handwritten signature data, it trusts itself to ensure user approval for using a workflow that involves sending a signed document o↵ the host. Required restrictions are particularly useful for applications that provide a UI for the user to choose and return a specific file. Finally, while it is likely that applications will only specify a single required restriction, Aquifer allows a list. We currently require all applications on the list to be present on the workflow. In the future, we will explore the usefulness of "k of" policies. Filters: A direct consequence of enforcement of export restrictions is access control violations, and Aquifer attempts to reduce these violations through workflow filters. Aquifer allows applications to define these UI workflow filters specifically to enhance usability. In the case of Android, filters limit the results of intent resolution shown to the user. Similar filters can be constructed for Windows 8's share charm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Policy Logic</head><p>Aquifer formalizes the export, required, and filter policy types into a logic. Our logic is motivated by the decentralized label model (DLM) <ref type="bibr" target="#b26">[27]</ref>. We chose DLM over other DIFC logics <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b35">36]</ref> due to its clear owner semantics in the policy label. We extend DLM by replacing the set of readers with a tuple containing our export, required, and filter restrictions. Note that Aquifer uses DIFC to control data export and not interaction between apps.</p><p>Aquifer uses applications as security principals. We chose applications over UI screens, because the fine granularity of UI screens would be cumbersome to specify and manage. Developers defining security policy do not necessarily know the UI screens in other applications.</p><p>The UI workflow policy itself is a collection of owner policies, where each owner is an application. The owner policy contains an export list, a required list, and a workflow filter: Definition 1 (Export list). An export list E is a set of applications that may access the network while participating in the UI workflow.</p><p>Definition 2 (Required list). A required list R is a set of applications that all must have been present on the UI workflow at sometime in the past for any application on the UI workflow to access the network. Definition 3 (Workflow filter). A workflow filter F is a set of tuples {(s1, T1), . . . , (sn, Tn)}, each containing an action string si and a set of targets Ti. If the normal resolution of an intent message sent to action string si is a set of apps N , then the resulting allowed target applications is N \ Ti.</p><p>To simplify discussion, we define functions for retrieving the action string and set of targets from a workflow filter. For a filter F , actions(F ) returns the set of all action strings in F . Similarly, for a filter F and an action string s, targets(F, s) returns the set of target applications for action string s. Note that for the following logic to be correct, we assume that there does not exist an s such that targets(F, s) = ;. If this occurs, Aquifer simply removes s from actions(F ), implying there are no restrictions for s (default allow).</p><p>Having defined export lists, workflow filters, and required lists, we can now define a workflow label. Definition 4 (Workflow label). A workflow label L is an expression L = {O1 : (E1, R1, F1); . . . ; On : (En, Rn, Fn)}, where Oi is an owner (application) and Ei, Ri, and Fi are an export list, required list, and workflow filter, respectively, specified by Oi.</p><p>A label L contains a set of owners denoted owners(L), which is the set of all owners that have specified a restriction for the UI workflow (i.e., O1, . . . , On in Definition 4). To modify L (i.e., add, remove, or change), an owner Oi must contain the active UI screen and can only modify its portion of L (i.e., O1 cannot change E2, R2, or F2).</p><p>We define functions for retrieving the parts of an owner's policy from a label L. Care is needed to account for Aquifer's default allow policy when no restrictions are specified by an owner. Let the set of all applications be A, and the set of all possible action strings be S. For each owner Oi, exports(L, Oi) returns Ei, unless Oi 6 2 owners(L) or Ei = ;, in which case exports(L, Oi) returns A. Semantically, this means Oi does not have any export restrictions. Similarly, for each owner Oi, filters(L, Oi) returns Fi, unless Oi 6 2 owners(L) or Fi = ;, in which case it returns {(s, A)|8s 2 S}. In contrast, for each owner Oi, requires(L, Oi) returns Ri regardless if Oi exists or if Ri is specified.</p><p>A useful concept is the e↵ective policy. That is, given a label L with multiple owners, what policy should be enforced. We define the e↵ective export list, required list, and workflow filter as follows. There are various scenarios in which Aquifer must combine two workflow labels, e.g., propagating a workflow label from a file, or through a daemon. When this occurs, we join the two labels L1 and L2 to create a new label that is the least restrictive label that maintains all of the restrictions specified by L1 and L2 <ref type="bibr" target="#b26">[27]</ref>. Similar to the definition of an e↵ective workflow filter, the last rule ensures that the workflow filter for the new label L contains the union of action strings in L1 and L2, and the intersection of the target applications for each of those action strings. Finally, we note that when the above conditions results in the universal set for one of the restriction lists, our implementation removes the list to indicate default allow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">AQUIFER SYSTEM DESIGN</head><p>The Aquifer system enforces the Aquifer policy logic within a modern operating system. While we try to keep our description general, we frequently provide concrete examples using the Android platform.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Managing UI Workflows</head><p>As described in Section 3, Aquifer defines and enforces policy with respect to a UI workflow. A UI workflow is a graph that tracks the history of UI screens that comprise the user's task. This section discusses how Aquifer identifies and manages the workflow. Identifying the Workflow: As the user navigates to new a new UI screen (e.g., Android activity component instance), Aquifer adds the screen to the workflow. Aquifer does not need to store the exact workflow graph to enforce the workflow label policy. Aquifer needs to keep track of: 1) WV , a list of applications the workflow has visited (for e↵ective required list Re), and 2) WR, a list of metadata for currently "running" UI screens (for e↵ective export list Ee). The metadata required for WR is dependent on the specific Aquifer implementation and the information required to enforce the policy. For this discussion, we assume it contains at least the app name and process identifier.</p><p>Ideally, we would like to start each UI screen in a separate process. This allows Aquifer to easily enforce the workflow policy by turning network access on and o↵ for the process. If the same process is used in two simultaneous UI workflows with labels L1 and L2, Aquifer must assign both workflows the label L1 tL2 in order to preserve the restrictions on both workflows. This can lead to overly restrictive policy.</p><p>At first, separate processes for UI screens seemed straightforward for our Android implementation of Aquifer. Android is designed to allow components to transparently interoperate with components in di↵erent processes. Therefore, conceptually we could modify the Android framework to start each activity component instance in a separate process. However, we ran into two problems. First, activity components are simply Java objects that extend the Activity class and sometimes share global variables with the rest of the application. In such cases, starting the activity component in a new process causes the application to crash when an uninitialized value of a global object is retrieved. Second, in the cases when activity components could be run in a separate process, Android did not provide an easy mechanism to start multiple processes if multiple instances of that activity component are needed.</p><p>To account for these limitations, we made the following compromise. When starting an activity component, Aquifer checks if the process for that component already exists. If not, a new process is started, and there is no problem. If a process does exist, Aquifer determines if it is part of the current UI workflow. If so, the activity is started in this process. If not, Aquifer terminates the process. If applications are developed following Android's recommended conventions, an activity should save its state to persistent storage when Android calls the onStop() callback, indicating the activity is no longer visible. Aquifer then starts a new process for the activity for this UI workflow. This approach is less desirable than poly-instantiation (suggested above), because if applications do not save their state, data loss may result. An undesirable user experience may also result if an activity component in the middle of a UI task is terminated, or if activities call each other in a loop. One way developers can reduce the impact of Aquifer's need to terminate processes is to develop their applications such that each activity starts in a separate process. This can be easily done using annotations in the app's manifest file. Policy Administration: Only the active (i.e., currently displayed) UI screen can modify the UI workflow policy. Aquifer exports a policy management API to applications that includes the ability to query, set, and remove the export list, required list, and workflow filter for that application. We note that a UI screen can only retrieve and modify the policy for the application that contains it. This keeps an application from reading the policies set by other applications, but it does not prevent it from learning the e↵ective policy, which can be queried by testing network access. Removing Unrelated Policy: In developing Aquifer for Android, we identified an opportunity to remove unnecessary restrictions from the UI workflow label L. Activity components can be started in two ways: startActivity() and startActivityForResult(). The former method never returns a value, whereas the latter does. Aquifer leverages this artifact by pruning the workflow label as follows. When UI workflow branch returns, Aquifer determines if the activity component was started for a result. If not, Aquifer checks if owner policy can be removed. An owner policy for application O can be removed from L if and only if: 1) no UI screen of app O exists in the set of running UI screens WR, and 2) no past UI screen (e.g., activity component instance) of app O returned a value. To ensure the latter condition, we modified WV to include an extra bit of information indicating whether or not a UI screen for the application was started for a result. Note that this heuristic is conservative and may not remove an owner policy if a value was returned on a branch that later does not return a value. Once WR is empty, Aquifer terminates the workflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Enforcing Policy</head><p>The Aquifer UI workflow policy restricts which applications can send data to the network. The workflow label contains a list of owners and corresponding export lists, required lists, and workflow filters that are used to calculate the e↵ective export list Ee, e↵ective required list Re, and e↵ective workflow filter Fe.</p><p>Aquifer enforces Ee and Re by controlling the network access of the process containing the UI screen. Since applications are security principals, it does not matter if each UI screen runs in its own process, or all UI screens for an application run in the same process. For each process p corresponding to application app(p), Aquifer enables network access if and only if:</p><formula xml:id="formula_0">(Ee = ; _ app(p) 2 Ee) ^(8r 2 Re, r 2 WV )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simply put, this equation implements default allow only if</head><p>Ee is empty and all r in Re are satisfied. Otherwise, the application corresponding to p must be listed in Ee.</p><p>Aquifer must re-evaluate the network access control for each process on a UI workflow whenever: a) an application on the UI workflow modifies its policy, or b) a new UI screen is added to the workflow. The latter condition is only neces-sary when the application for the added UI screen completes the restriction requirement for satisfying Re.</p><p>Finally, as described in Definition 3, Aquifer enforces workflow filters by reducing the list of applications shown to the user on transitions between UI screens.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Tracking Background Functionality</head><p>Aquifer is designed to enforce security policy on user facing software. However, UI screens sometimes use background functionality such as daemons and file storage. When this occurs, Aquifer must carefully propagate policy labels between UI workflows. UI Screen Accessing a Daemon: Daemons may be accessed by multiple workflows. Simply joining labels whenever a UI screen accesses a daemon will quickly result in all workflows having the same overly restrictive label. To avoid this, Aquifer uses intelligent tracking in daemons.</p><p>One method of intelligent tracking is to incorporate finegrained tracking (e.g., TaintDroid <ref type="bibr" target="#b12">[13]</ref> and CleanOS <ref type="bibr" target="#b36">[37]</ref>). Unfortunately, existing systems would require substantial retrofitting to enforce Aquifer policy. TaintDroid can only track 32 distinct identifiers. CleanOS extends TaintDroid to store identifiers in the taint tag bitvector; however, this storage cannot be used directly for Aquifer workflow labels. Furthermore, the source code for CleanOS was not available at the time of writing. Since the focus of this paper is the UI workflow security semantics, and not building another fine-grained data tracking framework, we reduced the scope of our tracking to OS-visible objects allowing coarse kernel mediation (i.e., files).</p><p>By restricting Aquifer to tracking files, we only need to track open file descriptors sent between UI screens and daemons. Android applications can pass file descriptors through binder. This commonly occurs with content provider components. Consider an activity component in application A that wants to read an image file that is owned by application B. App B can use a content provider component to share the image file with other applications without the image file being world readable. To do this, app B allows app A to query its content provider for a content URI, or passes the content URI directly to app A (e.g., content://app_b/img/42). App A can then open a FileInputStream for app B's content provider using this URI. Behind the scenes, app B's process will open the image file and pass the open file descriptor to app A using binder. App A can then read from the image file as if it opened the file itself.</p><p>Aquifer for Android implicitly tracks file descriptors in daemons by leveraging Linux's file_permission LSM hook. This hook is invoked whenever an inode is read or written, as opposed to the commonly used inode_permission hook, which is invoked when the file is opened. file_permission provides Aquifer the file and the process performing the read or write, regardless of how the process obtained the file descriptor. Using file_permission also avoids ambiguous read-write file open masks, as well as properly propagating labels when the workflow label changes between file open and file write. However, these advantages come at the cost of degraded performance that results from retrieving the file's label for each read and write operation. UI Screen Accessing a File: By using file_permission, Aquifer leverages the Linux kernel's tracking of file descriptors. Hence, even when a file is written through a daemon, Aquifer sees the UI screen accessing the file directly. When a process in a UI workflow reads or writes a file, Aquifer propagates the workflow label to and from the file in a standard way. Let the workflow have label LW and the file have label LF . If the UI screen writes to a file, the file's label is updated to LW t LF . If the UI screen reads from a file, the UI workflow label becomes LW t LF .</p><p>To accomplish these updates, Aquifer relies on a kernel module and the userspace Aquifer Service. When a file is read or written, a kernel hook extracts LF from the file (e.g., from its xattr) and notifies the Aquifer Service via an upcall, sending LF and the access mode. The Aquifer Service updates LW (if necessary) and returns a new LF (if necessary). The kernel module then stores the new LF with the file (e.g., in its xattr) if necessary.</p><p>Finally, propagating labels to persistent storage using file granularity means that Aquifer cannot handle sub-file data items such as database records. This limitation is currently in place for implementation and performance reasons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">IMPLEMENTATION</head><p>We implemented Aquifer for Android v4.0.3 (ICS) and the Linux Kernel v3.0.8 (omap). Aquifer adds approximately 2,200 lines of code in the Android Framework, and approximately 1,000 lines in the kernel. The source code is available at http://research.csc.ncsu.edu/security/aquifer.</p><p>The core userspace implementation is the Aquifer Service, a new system service responsible for maintaining the workflow abstraction and policy language calculus. The Aquifer Service is invoked by hooks placed in Android's Activity-Manager service. These hooks inform Aquifer when system state changes a↵ect the UI workflow state. The hooks are also used to filter intent resolution before presenting results to the user. The Aquifer Service also exposes an API to applications to safely add and modify their owner policies.</p><p>Aquifer uses a Linux security module (LSM) to mediate file access and a file descriptor transfer between processes. We use the file_permission LSM hook to only propagate the label if the data is read or written. The file policy is stored in extended attributes (xattrs), and the Aquifer LSM forwards file events and file policy to the Aquifer Service via a netlink socket. We also ensure that the SDcard is also formatted to support xattrs.</p><p>The final component of our implementation is the Aquifer device driver, which provides a channel for the userspace Aquifer Service to communicate with the Aquifer LSM. The Aquifer Service uses this interface to manipulate the network access privilege of a process. The Aquifer Service also sets up the netlink socket with the LSM via this interface to receive events about file accesses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EVALUATION</head><p>We now evaluate Aquifer by accessing the need and appropriateness of its protection, proving the safety of label joins, and measuring the performance overhead. We also provide three case studies to demonstrate Aquifer in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Application Survey</head><p>To understand the need for Aquifer and addressing the data intermediary problem, we performed a manual survey of Android applications. Survey Setup: We selected the top 50 free Android applications from 10 categories in the Google Play Store (500 apps total). We chose categories based on use of privacysensitive application-specific data or the ability to use such data. For example, we omitted game-related categories, news and magazines, etc. We selected the following categories: Business, Communication, Media and Video, Music and Audio, Photography, Personalization, Productivity, Shopping, Social, and Tools. Our application survey began by reading the market description of the application. For example, we identified if it creates or acquires data from the cloud. If we could identify a potential need for Aquifer, we studied the application manifest and manually ran the application as needed. Specifically, we looked at the types of interaction an application uses, e.g., complete isolation, data sharing in workflows, storing data in shared storage, as well as the type of data that was shared, i.e., we ignored data with no security or privacy value. Finally, we created a list of workflows that each app can be a part of to gain insight into how Aquifer's policies could enhance application security. Results: Table <ref type="table" target="#tab_2">1</ref> provides the statistics from our study. We found a number of data sources that produced and shared data. Apps that did not produce any data, but processed data from other apps, were classified as intermediaries. We identified a larger number of intermediaries, which suggests more applications provide data services than produce data. This motivates the need to address the data intermediary problem. We also categorized applications based on the usefulness of Aquifer's export and required restriction policies. These results motivate the appropriateness of Aquifer policy.</p><p>The application study also identified many interesting use cases. For example, some applications facilitate business meetings by sharing of files during meetings. Aquifer can be used to help protect confidential business files against inadvertent exposure. We also identified many free applications that provide value-add capabilities, e.g., image transformation. There are reasons why users may wish to edit photographs on the phone. The user may wish to ensure the intermediary does not export copies, particularly if the user is a professional photographer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Security Evaluation</head><p>Aquifer specifically seeks to protect application-specific data that cannot be enforced by system security policy. The security and privacy sensitivity of application-specific data is often only known to the developer and the user. We seek to reduce the onus on the user by having developers specify security policy. We note that app developers already participate in policy by specifying which permissions an app uses, and assigning permissions to restrict app interfaces.</p><p>Aquifer allows app developers to specify host export restrictions on data used by a UI workflow. The policy for a UI workflow is maintained in a workflow label L (Definition 4). When information from one UI workflow is propagated to another UI workflow via files, Aquifer merges the two workflow labels using the join (t) operator (Definition 8). Sec- tion 4 claimed the join operation ensures the resulting label is at least as restrictive as both the original labels. We formally prove the safety of the join operation and hence of the Aquifer policy language. We do this in two parts. First, we define an e↵ective restriction relation that ensures the evaluated policy is more restrictive. Then, we define an owner restriction relation that ensures that all of an owner's restrictions are maintained. This is important, because while L2 may be e↵ectively more restrictive than L1, an owner's restrictions may be changed at a later time by another owner such that L2 is no longer more restrictive than L1. With these two definitions, we can define an overall restriction relation that is needed to prove the safety of Aquifer. The formal proof is provided in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Performance Evaluation</head><p>To understand the performance overhead of Aquifer, we performed several microbenchmarks. The experiments were performed on a Samsung Galaxy Nexus (maguro) running Android v4.0.3 and Aquifer built on the same version. We performed each experiment at least 50 times. Average results with 95% confidence intervals are shown in Table <ref type="table" target="#tab_3">2</ref>. App load time: Aquifer initializes its UI workflow structures when the first application is loaded. This consists of creating a new label and data structures for WV and WR to maintain the workflow state. We compared the time to start the first application of a UI workflow in Aquifer to a baseline application load time in Android. The average overhead is 3.58 ms, which is negligible. App filtering: Aquifer filters the potential target applications when Android uses an implicit intent to start an activity component. We measured the time between sending an intent message and the resolution of the final list of applications presented to the user. Aquifer only causes a negligible delay of 1.1 ms. Network access check: Aquifer places a hook in the kernel that is called every time a process attempts to access the network. For this experiment, we created an application with an activity component that attempts to access the network repeatedly. Since Android already performs a similar check to enforce its INTERNET permission, Aquifer's additional checks have negligible impact. Workflow policy change: An application with an active activity can modify the UI workflow policy label, which requires recalculation of the e↵ective policy and reassignment of network privileges to all workflow participants. This policy re-evaluation only takes 1.98 ms. Label propagation on read and write: Each file read operation requires Aquifer to retrieve the file's label from its xattr and join it to the workflow's label. Each file write operation requires Aquifer to retrieve the file's label, modify it, and store the new label. For this experiment, we measured the overhead of reading and writing a 1MB file  with a small workflow policy. We performed each read and write 50 times, flushing after each write, and sleeping 500 ms between consecutive measurements. Table <ref type="table" target="#tab_3">2</ref> shows an overhead of 6.49% for writes and 9.87% for reads. Note that while Aquifer writes are more complex than reads, the read overhead is greater, because the read time is significantly less than the write time. Furthermore, a production version of Aquifer could cache policies in memory to avoid unnecessary xattr operations.</p><p>To further investigate the read and write overhead, we performed a more detailed study of the time required. We repeated the previous experiment, but used a range of workflow label sizes and complexities. We started with a simple single owner label containing an owner policy of 148 bytes and increased gradually to a fairly complex label containing multiple owners and occupying 1KB. Figure <ref type="figure" target="#fig_5">4</ref> shows the time required for Aquifer to perform the read and write label propagation based on the policy size. The horizontal line shows the time to perform the read and write in Android without Aquifer modifications. There are four contributors to this overhead: 1) context switches when transporting labels from kernel space to user space and vice versa; 2) performing the xattr operations, 3) marshalling and unmarshalling the policy to and from the binary form; and 4) copying the data itself.</p><p>Figure <ref type="figure" target="#fig_5">4</ref> shows a relatively constant overhead, indicating that the setup cost of context switches and xattr operations overwhelms the cost of marshalling data and copying data between bu↵ers. Finally, the overhead for reading and writ- Listing 1: Aquifer policy modifications to K-9E Mail ing empty labels is negligible, as we avoid propagating empty labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Case Studies</head><p>To demonstrate how Aquifer works in practice, we performed three case studies involving open source Android applications such as K-9 Mail, OI File Manager, and PDFView.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.1">Case Study 1 (Confidential PDF)</head><p>K-9 Mail is an open source fork of the original Email client in the Android Open Source Project (AOSP). We modified K-9 Mail to create K-9E Mail, an enterprise email client for use by the employees of a fictional enterprise. We also used the open source PDFView application, which we modified to emulate an intermediary that backs up the files accessed by the user to the user's account in the cloud.</p><p>Our modifications of PDFView include 1) sending the PDF file to a network server, and 2) saving a version of a PDF file, and then on a later invocation of PDFView, opening the saved file and sending it to the network. PDFView does not go out of its way to collect data, rather data is collected only as a consequence of using it.</p><p>K-9E Mail allows the user to view attachments in other applications. For our case study, we use an Email with the file contract.pdf attached. When the user selects to view contract.pdf, K-9E Mail creates an intent message with the implicit address ACTION_VIEW and the datatype set to application/pdf. When K-9E Mail uses this intent to start an activity, Android displays a chooser allowing the user to select the viewer. In our case study, this chooser contains the default DocumentViewer app and our modified PDFView app. We verified that the PDF could be viewed by both Doc-umentViewer and PDFView while running in the Aquifer enhanced Android framework, without any modification to either app. When we viewed contract.pdf, PDFView successfully exported the PDF as designed.</p><p>We then modified K-9E Mail to be Aquifer-aware. For the case study, we included logic to identify a PDF as confidential if the filename contains strings such as "contract," "confidential," "secret," etc. Note that we used this classification scheme purely for demonstration purposes. A production version of an Aquifer-aware Email client could be much more intelligent (e.g., scan the subject and body for keywords, use predefined X-Headers, etc.). The Email client should also provide the user visual clues that the attachment is treated as confidential, and potentially a method to declassify an attachment in the event of false labeling.</p><p>Our second modification was to set the owner policy for the UI workflow before a confidential attachment is viewed.  We used the following owner policy.</p><formula xml:id="formula_1">E = {K9EMail} R = {} F = {(ACTION SEND, {K9EMail})}</formula><p>This policy ensures that only K-9E Mail can export the data, and if any application in the UI workflow uses the AC-TION_SEND action string to start an activity, only K-9E Mail will be displayed, filtering out other options (e.g., YahooMail, HotMail), as shown in Figure <ref type="figure" target="#fig_2">5</ref>. Adding this policy to K-9 Mail required very few changes, as shown in Listing 1.</p><p>We then re-performed our previous experiment. This time, when PDFView attempted to send contract.pdf, it could not reach the network. Furthermore, when PDFView saved a copy of contract.pdf, the workflow label was copied with it. When we later invoked PDFView as part of an unrestricted UI workflow, it read contract.pdf (due to our changes) and the workflow was successfully labeled, again keeping PDFView from exporting the document.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.2">Case Study 2 (Choosers)</head><p>The previous case study shows how K-9E Mail can share data while ensuring that only it can export the data o↵ the device. In this case study, we demonstrate how K-9E Mail can allow a larger set of applications to export the data only if the user's consent is provided.</p><p>For this case study, K-9E Mail trusts all other applications to send confidential documents o↵ the host, but only if the user selects the file as part of a workflow. This policy is valuable to prevent accidental backup to cloud storage by other applications the user might have installed. This policy goal is accomplished using a trusted chooser application and a require restriction. For example, if K-9E Mail trusts the OI File Manager, the following policy can protect documents saved to the SDcard from accidental disclosure.</p><formula xml:id="formula_2">E = {ALL} R = {OI File Manager} F = {}</formula><p>Using this policy, Aquifer allows the original K-9 Mail app to send the saved attached document when both, 1) starting the OI File Manager from K-9 Mail to choose an attachment, and 2) starting OI File Manager first and sharing the document with K-9 Mail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.3">Case Study 3 (Document Viewers)</head><p>Our final case study evaluates whether or not Aquifer policies are compatible with popular data intermediaries. We downloaded 25 of the most popular free document and image viewers and editors. Each was shared a file that has an Aquifer policy that prevents the intermediary from opening network connections. For the 25 applications, we encountered 0 application crashes due to access control failures. We found that seven of the applications (e.g., KingSoft O ce, Olive o ce) contain advertisement libraries that immediately make network connections, before displaying the document. However, when Aquifer denies these network connections, the applications handle the denied connection without error and without usability impact (except for the absence of the ad). This use case supports our hypothesis that many data intermediary applications are built with modularity in mind and have limited dependencies on the Internet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">DISCUSSION</head><p>Aquifer policy specification may lead to usability failures if application developers do not predict all of the ways in which the user might construct a UI workflow. One potential case is when regulate restrictions can conflict with filters. Regulate restrictions require an app to participate on a workflow. However, if that app is not included in a workflow filter, the user may never be able to navigate through it. This example demonstrates a need for developers to coordinate on Aquifer policy at some level.</p><p>Another type of unexpected usability failure due to Aquifer policy results when a user clicks on a hyperlink in a protected document. If the Web browser is not in the export list, it will fail to navigate to the URL when launched from the workflow containing the document. Technically, the URL was part of the document and should not be exported. However, a policy may wish to include a trusted Web browser in the export list to ensure hyperlink functionality.</p><p>Finally, as discussed in our first case study, there are various situations when the app developer may need to indicate to the user that data is classified in order to avoid user confusion that may lead to access control violations. Such situations must be addressed on an application-specific basis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">RELATED WORK</head><p>Modern OSes, such as Android, iOS, and Windows 8, take the suggestion of decades of security research <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b13">14]</ref> and run each application as a unique security principal. In these systems, security policy is defined with respect to permissions, which are granted to apps and restrict access to APIs and other applications. Research has criticized Android's permission framework for being both too coarse grained <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16]</ref> and too confusing for users <ref type="bibr" target="#b16">[17]</ref>. Researchers have built enhanced security frameworks around Android permissions <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b5">6]</ref>, some of which ease policy specification, while others make it more complicated.</p><p>Ultimately, permissions lack transitive semantics, which make them insu cient to express the security goals of mod-ern OSes, as demonstrated by Android permission privilege escalation attacks <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b19">20]</ref>. IPC Inspection <ref type="bibr" target="#b17">[18]</ref> adds transitivity by reducing app permissions at runtime, similar to Biba low watermark <ref type="bibr" target="#b4">[5]</ref>. Unfortunately, this requires apps to request extra permissions to operate, resulting in permission bloat. In contrast, Quire <ref type="bibr" target="#b10">[11]</ref> adds IPC provenance records to help developers prevent confused deputy attacks. From the secrecy perspective, TaintDroid <ref type="bibr" target="#b12">[13]</ref> and AppFence <ref type="bibr" target="#b20">[21]</ref> use dynamic taint analysis to determine when privacy sensitive values such as location and phone identifiers are sent to the network. However, they lack the necessary policy semantics to address the data intermediary problem.</p><p>Traditionally, OS protection systems provide transitive protection semantics using information flow control (IFC) <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref>. IFC labels subjects and objects, and uses a lattice to define a relation between the labels. Original IFC systems (e.g., MLS <ref type="bibr" target="#b3">[4]</ref>) use a central definition of security labels, which does not meet the needs of software that defines new types of information (i.e., apps in modern operating systems). Myers and Liskov <ref type="bibr" target="#b26">[27]</ref> defined a decentralized label model (DLM) that has formed the policy model for several decentralized information flow control (DIFC) operating systems (e.g., Asbestos <ref type="bibr" target="#b40">[41]</ref>, HiStar <ref type="bibr" target="#b46">[47]</ref>, Flume <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b23">24]</ref>, Laminar <ref type="bibr" target="#b32">[33]</ref>, and Fabric <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b1">2]</ref>). DIFC allows applications to define their own label types.</p><p>Aquifer's policy is based on DIFC semantics, but it is optimized for the specific needs of the data intermediary problem. Traditional DIFC regulates interaction between processes and access to data objects. In modern OSes like Android, apps are frequently purpose specific and complex tasks are performed in user-driven workflows. Strict restrictions on communication and data sharing among applications would disrupt these workflows and limit the user to using only specific applications. Therefore, we relax DIFC constraints to enable greater inter-app data sharing, providing applications with a mechanism to control exfiltration of their data o↵ the device instead.</p><p>Previous systems have controlled accidental data disclosure. Compartmented Mode Workstations (CMW) <ref type="bibr" target="#b7">[8]</ref> assign and propagate sensitivity labels to data objects and processes (e.g. a screenshot has the label of the highest secrecy level of the data windows captured in it). A user action that leads to a flow from a high secrecy to a low secrecy level is met with a dialog box, confirming if the action was intended. Trusted Window Systems <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b33">34]</ref> prevent accidental cut-and-paste actions by the user from a high-secrecy document to a low-secrecy document altogether.</p><p>Other factors leading to accidental data exposure, such as missing access control checks and poor programming have also motivated research. Resin <ref type="bibr" target="#b45">[46]</ref> allows the programmer to configure application level data assertions to prevent accidental information leaks in Web applications. Resin is designed to help programmers detect vulnerabilities and bugs in their own applications, but does not provide Aquifer-like information flow guarantees in a multi-application environment. Liquid Machines <ref type="bibr" target="#b43">[44]</ref> provides enterprise support for policy compliant remote content access using encryption. The use of encryption may restrict the user from using third party applications.</p><p>Finally, we are not the first to consider the challenges of modern operating systems. The ServiceOS project at Microsoft Research, which includes MashupOS <ref type="bibr" target="#b41">[42]</ref> and Gazelle <ref type="bibr" target="#b42">[43]</ref>, considers similar problems, but focuses on Web browsers. Also under this umbrella project is Access Control Gadgets (ACG) <ref type="bibr" target="#b31">[32]</ref>, which uses trusted UI widgets to infer user intentions when accessing sensors (e.g., camera, microphone). ACGs are a generalization of the much earlier concept of a "powerbox," which is a trusted dialog box originally used by CapDesk <ref type="bibr" target="#b11">[12]</ref> and DarpaBrowser <ref type="bibr" target="#b0">[1]</ref> to grant a process access to a file based on the user's natural file selection process. Along these lines, Aquifer infers data access based on the UI workflow as the user performs a task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">CONCLUSION</head><p>Modern operating systems have changed both the way users use software and the underlying security architecture. These two changes make accidental data disclosures easier. To address this problem, we presented the Aquifer security framework that assigns host export restrictions on all data accessed as part of a UI workflow. Our key insight was that when applications in modern operating systems share data, it is part of a larger workflow to perform a user task. Each application on the UI workflow is a potential data owner, and therefore can contribute to the security restrictions. The restrictions are retained with data as it is written to storage and propagated to future UI workflows that read it. In doing so, we enable applications to sensibly retain control of their data after it has been shared as part of the user's tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX A. AQUIFER POLICY SAFETY PROOF</head><p>We now prove the safety of the join operation in the Aquifer policy logic. Before proving the join operation ensures policy restriction, we must define a restriction relation. We do this in two parts. First, we define an e↵ective restriction relation that ensures the evaluated policy is more restrictive. Then, we define an owner restriction relation that ensures that all of an owner's restrictions are maintained. This is important, because while L 2 may be e↵ectively more restrictive than L 1 , an individual owner's restrictions may be changed at a later time by another owner such that L 2 is no longer more restrictive than L 1 . With these two definitions, we can define an overall restriction relation that is needed to prove the safety of Aquifer. Definition 9 (E↵ective restriction relation ve). Let L 1 and L 2 be workflow labels with e↵ective export lists, required lists, and workflow filters E 1e , E 2e , R 1e , R 2e , F 1e , and F 2e , respectively. L 2 is e↵ectively more restrictive than L 1 , denoted L 1 ve L 2 , if and only if: We now prove the safety of the Aquifer policy language.</p><formula xml:id="formula_3">E 1e ◆ E 2e</formula><p>Theorem 1. The Aquifer policy language is safe.</p><p>Proof. We prove the safety of the Aquifer policy language by construction. Let L 1 and L 2 be workflow labels. Workflow policy propagation creates a new label L 1 t L 2 . We must show that ))} Definition 9 first requires showing that actions(F 1e ) ✓ actions(F 12e ). This is true, because F 12e contains all of the action strings in the filters for both L 1 and L 2 . Second, we must show that 8s 2 actions(F 1e ), targets(F 1e ) ✓ targets(F 12e ). This is ensured by the intersection of targets when generating F 12e . This completes the conditions needed to satisfy Definition 9, as well as Definition 11 for L 1 v L 1 t L 2 . The proof that L 2 v L 1 t L 2 follows similarly and is not shown for brevity.</p><formula xml:id="formula_4">L 1 v L 1 t</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Document signing use case with four apps.A confidential contract received via Email is 1) read in a viewer, 2) converted to PDF, 3) embedded with a written signature, and 4) Emailed back to the sender.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Aquifer architecture for Android</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 5 (</head><label>5</label><figDesc>E↵ective export list). For a workflow label L, the e↵ective export list Ee = T exports(L, O), 8O 2 owners(L). Definition 6 (E↵ective required list). For a workflow label L, the e↵ective required list Re = S requires(L, O), 8O 2 owners(L). Definition 7 (E↵ective workflow filter). For a workflow label L, the e↵ective workflow filter Fe is the set of tuples containing action string and corresponding target application set created by taking the union of all action strings and the intersection of the targets for those action strings. More precisely, Fe = {(si, Ti) | si 2 S actions(F ) and Ti = T targets(F, si), 8F 2 filters(L, O), 8O 2 owners(L)}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 8 (</head><label>8</label><figDesc>Label join t). For workflow labels L1 and L2, the join L = L1 tL2 is a new label ensuring the following for all owners O: owners(L) = owners(L1) [ owners(L2) exports(L, O) = exports(L1, O) \ exports(L2, O) requires(L, O) = requires(L1, O) [ requires(L2, O) filters(L, O) = {(si, Ti)|si 2 actions(F1) [ actions(F2), Ti = targets(si, F1) \ targets(si, F2), where F1 = filters(L1, O), F2 = filters(L2, O)}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Aquifer File Label Propagation Time. Error bars indicate 95% confidence intervals</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Aquifer Workflow Filter, a) Without policy and b) With Policy that allows only K-9E Mail</figDesc><graphic coords="10,61.77,58.78,105.44,187.46" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>R</head><label></label><figDesc>1e ✓ R 2e actions(F 1e ) ✓ actions(F 2e ) 8s 2 actions(F 1e ), targets(F 1e , s) ◆ targets(F 2e , s) Conceptually, Definition 9 ensures that (1) L 2 has less exporters than L 1 , (2) L 2 has more required apps on the workflow than L 1 , and (3) any workflow filters in L 1 are enforced by L 2 with targets that are more restrictive (less than) those in L 1 .Definition 10 (Owner restriction relation v O ). Let L 1 and L 2 be workflow labels, O be the owner for which the relation is evaluated, F 1 = filters(L 1 , O), andF 2 = filters(L 2 , O). L 2 is more restrictive than L 1 for owner O, denoted L 1 v O L 2 , if and only if: exports(L 1 , O) ◆ exports(L 2 , O) requires(L 1 , O) ✓ requires(L 2 , O) actions(F 1 ) ✓ actions(F 2 ) 8s 2 actions(F 1 ), targets(F 1 , s) ◆ targets(F 2 , s)Conceptually, Definition 10 ensures the same properties as Definition 9, but with respect to owner O. Definition 11 (Restriction relation v). Let L 1 and L 2 be workflow labels. L 2 is more restrictive than L 1 , denoted L 1 v L 2 , if and only if L 1 ve L 2 and 8O 2 owners(L 1 ), L 1 v O L 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>, Aquifer Kernel Android Framework Applications</head><label></label><figDesc></figDesc><table><row><cell>App 1</cell><cell>App 2</cell><cell>App 3</cell></row><row><cell>Aquifer</cell><cell>Aquifer</cell><cell>Activity</cell></row><row><cell>API</cell><cell>System</cell><cell>Manager</cell></row><row><cell cols="2">Aquifer Kernel Module</cell><cell>File System</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Application Survey Results</figDesc><table><row><cell>Characteristic</cell><cell>Number of Apps</cell></row><row><cell>Data sources</cell><cell>85 (17%)</cell></row><row><cell>Data intermediaries</cell><cell>140 (28%)</cell></row><row><cell>Value from Export Policy</cell><cell>70 (14%)</cell></row><row><cell>Value from Regulate Policy</cell><cell>78 (15.6%)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>Microbenchmark Results</figDesc><table><row><cell>Benchmark</cell><cell>Android</cell><cell>Aquifer</cell><cell>Overhead</cell></row><row><cell>App load</cell><cell cols="2">188.49±5.36 ms 192.07±6.30 ms</cell><cell>1.9%</cell></row><row><cell>App filter</cell><cell cols="2">194.12±7.91 ms 195.22±7.52 ms</cell><cell>0.55%</cell></row><row><cell>Net access</cell><cell cols="2">108.60±6.48 ms 109.64±6.31 ms</cell><cell>0.53%</cell></row><row><cell>Policy change</cell><cell>-</cell><cell>1.98±1.27 ms</cell><cell>-</cell></row><row><cell>File Read (1MB)</cell><cell>4.76±0.09 ms</cell><cell>5.23±0.22 ms</cell><cell>9.87%</cell></row><row><cell cols="3">File Write (1MB) 23.89±0.45 ms 25.44±0.86 ms</cell><cell>6.49%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>1</head><label></label><figDesc>AquiferList exportList = new AquiferList () ; 2 exportList . add ( this . getPackageName () );</figDesc><table><row><cell>3</cell></row><row><cell>4 AquiferFilter filter = new AquiferFilter () ;</cell></row><row><cell>5 filter . addTarget ( android . intent . ACTION_SEND , this .</cell></row><row><cell>getPackageName () );</cell></row><row><cell>6</cell></row><row><cell>7 AquiferPolicy policy = new AquiferPolicy () ;</cell></row><row><cell>8 policy . setExportList ( exportList );</cell></row><row><cell>9 policy . setFilter ( filter );</cell></row><row><cell>10</cell></row><row><cell>11 IAquiferService aquifer = IAquiferService . Stub .</cell></row><row><cell>asInterface ( ServiceManager . getService (" Aquifer " ));</cell></row><row><cell>12 aquifer . addPolicy ( policy );</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>L 2 and L 2 v L 1 t L 2 . Based on Definition 11, L 1 v L 1 t L 2 i↵ (a) for all O 2 owners(L 1 ), L 1 v O L 1 t L 2 and (b) L 1 ve L 1 t L 2 .Condition (a) is satisfies Definition 10 by expanding L 1 t L 2 using Definition 8, as follows. For all owners O 2 owners(L 1 ), letF 1 = filters(L 1 , O) and F 2 = filters(L 2 , O), then exports(L 1 , O) ◆ exports(L 1 , O) \ exports(L 2 , O) requires(L 1 , O) ✓ requires(L 1 , O) [ requires(L 2 , O) actions(F 1 ) ✓ actions(F 1 ) [ actions(F 2 )8s 2 actions(F 1 ), targets(F 1 , s)◆ targets(F 1 , s) \ targets(F 2 , s) Condition (b)is satisfies Definition 9 by expanding L 1 t L 2 using Definition 8 and applying Definitions 5-6 to determine the e↵ective policy. Export list: for L 1 , E 1e = T exports(L 1 , O) for all O 2 owners(L 1 ). For L 1 t L 2 , E 12e = T (exports(L 1 , O) \ exports(L 2 , O)) for all O 2 (owners(L 1 )[owners(L 2 )). To satisfy Definition 9, we must show E 1e ◆ E 12e . If an export list exists for an owner O i in L 2 but not L 1 , exports(L 1 , O) will return the set of all applications (see Section 4) and the intermediate stage will be exports(L 2 , O). However, if this contains an application that was not in E 1e it will be removed in the outer intersection. Therefore, E 1e ◆ E 12e . Required list: for L 1 , R 1e = S requires(L 1 , O) for all O 2 owners(L 1 ). For L 1 tL 2 , R 12e = S (requires(L 1 , O)[requires(L 2 , O)) for all O 2 (owners(L 1 ) [ owners(L 2 )). Clearly, R 1e ✓ R 1e2 , which satisfies Definition 9.</figDesc><table /><note><p><p><p><p><p>Workflow Filters: for L 1 ,</p>F 1e ={(s, T ) | s 2 [ actions(F ) and T = \ targets(F, s), 8F 2 filters(L 1 , O), 8O 2 owners(L 1 )} For L 1 t L 2 , F 12e ={(s, T ) | s 2 [ (actions(F 1 ) [ actions(F 2 ))</p>and</p>T = \ (targets(F 1 , s) \ targets(F 2 , s)),</p>8F 1 2 filters(L 1 , O), 8F 2 2 filters(L 2 , O), 8O 2 (owners(L 1 ) [ owners(L 2</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was supported in part by an NSA Science of Security Lablet grant at North Carolina State University and NSF grants CNS-1222680 and CNS-1253346. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the funding agencies. We would also like to thank Patrick McDaniel, Patrick Traynor, Kevin Butler, Tsung-Hsuan Ho, Ashwin Shashidharan, Vasant Tendulkar, and the anonymous reviewers for their valuable feedback during the writing of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.combex.com/papers/darpa-report/html/" />
		<title level="m">A Capability Based Client: The DarpaBrowser</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Sharing Mobile Code Securely With Information Flow Control</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Askarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Methodology for Empirical Analysis of Permission-Based Security Models and its Application to Android</title>
		<author>
			<persName><forename type="first">D</forename><surname>Barrera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">G</forename><surname>Kayacik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorshot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Somayaji</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer and Communications Security</title>
		<meeting>the ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2010-10">Oct. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Bell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Lapadula</surname></persName>
		</author>
		<idno>MTR-2547</idno>
	</analytic>
	<monogr>
		<title level="m">Secure Computer Systems: Mathematical Foundations</title>
		<meeting><address><addrLine>Bedford, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Integrity considerations for secure computer systems</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Biba</surname></persName>
		</author>
		<idno>MTR-3153</idno>
	</analytic>
	<monogr>
		<title level="j">MITRE</title>
		<imprint>
			<date type="published" when="1977-04">Apr. 1977</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Toward Taming Privilege-Escalation Attacks on Android</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bugiel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shastry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Network and Distributed System Security Symposium</title>
		<meeting>Network and Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">CRePE: Context-Related Policy Enforcement for Android</title>
		<author>
			<persName><forename type="first">M</forename><surname>Conti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T N</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Crispo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Information Security Conference</title>
		<meeting>Information Security Conference</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Compartimented Mode Workstation: Results Through Prototyping</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Cummings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Fullam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Gosselin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Picciotto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Woodward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wynn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Privilege Escalation Attacks on Android</title>
		<author>
			<persName><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Information Security Conference (ISC)</title>
		<meeting>the 13th Information Security Conference (ISC)</meeting>
		<imprint>
			<date type="published" when="2010-10">Oct. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Lattice Model of Secure Information Flow</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="236" to="243" />
			<date type="published" when="1976-05">May 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Quire: Lightweight Provenance for Smart Phone Operating Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dietz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shekhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pisetsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th USENIX Security Symposium</title>
		<meeting>the 20th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011-08">August 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Capdesk</forename></persName>
		</author>
		<ptr target="http://www.combex.com/tech/edesk.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-G</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 9th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2010-10">Oct. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">PinUP: Pinning User Files to Known Applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jaeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Annual Computer Security Applications Conference</title>
		<meeting>Annual Computer Security Applications Conference</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On Lightweight Mobile Phone Application Certification</title>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ongtang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 16th ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2009-11">Nov. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The E↵ectiveness of Application Permissions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Felt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Greenwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Conference on Web Application Development (WebApps)</title>
		<meeting>the USENIX Conference on Web Application Development (WebApps)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Android Permissions: User Attention, Comprehension and Behavior</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Felt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Egelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Haney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Usable Privacy and Security</title>
		<meeting>the Symposium on Usable Privacy and Security</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Permission Re-Delegation: Attacks and Defenses</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Felt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Security Symposium</title>
		<meeting>USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Secure Environment for Untrusted Helper Applications: Confining the Wily Hacker</title>
		<author>
			<persName><forename type="first">I</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Systematic Detection of Capability Leaks in Stock Android Smartphones</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grace</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium</title>
		<meeting>the Network and Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2012-02">Feb. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">These Aren&apos;t the Droids You&apos;re Looking For: Retrofitting Android to Protect Data from Imperious Applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hornyack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Sub-Operating Systems: A New Approach to Application Security</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bellovin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGOPS European workshop</title>
		<meeting>ACM SIGOPS European workshop</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Tag, You Can See It! Using Tags for Access Control in Photo Sharing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Klemperer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Mazurek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sleeper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Baur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">F</forename><surname>Cranor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGCHI Conference on Human Factors in Computing Systems (CHI)</title>
		<meeting>the ACM SIGCHI Conference on Human Factors in Computing Systems (CHI)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Noninterference for a Practical DIFC-Based Operating System</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Information Flow Control for Standard OS Abstractions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brodsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cli↵er</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Operating Systems Principles</title>
		<meeting>ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fabric: A Platform for Secure Distributed Computation and Storage</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Waye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the ACM Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Decentralized Model for Information Flow Control</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles</title>
		<meeting>the ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Apex: Extending Android Permission Model and Enforcement with User-defined Runtime Constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nauman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ASIACCS</title>
		<meeting>ASIACCS</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Semantically Rich Application-Centric Security in Android</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ongtang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mclaughlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Annual Computer Security Applications Conference</title>
		<meeting>the 25th Annual Computer Security Applications Conference</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<ptr target="https://www.pcisecuritystandards.org/security_standards/documents.php" />
		<title level="m">Data Security Standard: Requirements and Security Assessment Procedures, Version 2.0, Oct. 2010. Available at</title>
		<imprint>
			<publisher>Payment Card Industry (PCI)</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Towards trusted cut and paste in the X Window System</title>
		<author>
			<persName><forename type="first">J</forename><surname>Picciotto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh Annual Computer Security Applications Conference</title>
		<meeting>the Seventh Annual Computer Security Applications Conference</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">User-Driven Access Control: Rethinking Permission Granting in Modern Operating Systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Roesner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cowan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Laminar: Practical Fine-Grained Decentralized Information Flow Control</title>
		<author>
			<persName><forename type="first">I</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Conference on Programming Language Design and Implementation</title>
		<meeting>of the Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Design of the EROS trusted window system</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vanderburgh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Northup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chizmadia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Sub-Identities: Towards Operating System Support for Distributed System Security</title>
		<author>
			<persName><forename type="first">P</forename><surname>Snowberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thain</surname></persName>
		</author>
		<idno>2005-18</idno>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>University of Notre Dame, Department of Computer Science and Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Disjunctive Category Labels</title>
		<author>
			<persName><forename type="first">D</forename><surname>Stefan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Russo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazieres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of NordSec</title>
		<meeting>of NordSec</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">CleanOS: Limiting Mobile Data Exposiure with Idle Eviction</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ames</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhamidipati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bijlani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Geambasu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sarda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>the USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Gramm-Leach-Bliley Act, Finiancial Privacy Rule. 15 USC §6801- §6809</title>
		<ptr target="http://www.law.cornell.edu/uscode/usc_sup_01_15_10_94_20_I.html" />
		<imprint>
			<date type="published" when="1999-11">Nov. 1999</date>
			<publisher>US Congress</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Health Insurance Portability and Accountability Act of</title>
		<ptr target="http://www.access.gpo.gov/nara/cfr/waisidx_07/45cfr164_07.html" />
	</analytic>
	<monogr>
		<title level="s">Privacy Rule. 45 CFR</title>
		<imprint>
			<biblScope unit="volume">164</biblScope>
			<date type="published" when="1996-08">1996. Aug. 2002</date>
			<publisher>US Congress</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Publication 1075: Safeguards for Protecting Federal Tax Returns and Return Information</title>
		<ptr target="http://www.irs.gov/pub/irs-pdf/p1075.pdf" />
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>US Internal Revenue Service (IRS)</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Labels and Event Processes in the Asbestos Operating System</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vandebogart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Efstathopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Frey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ziegler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007-12">December 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Protection and Communication Abstractions for Web Browsers in MashupOS</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the ACM Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">The Multi-Principle OS Construction of the Gazelle Web Browser</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Grier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Venter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Company Overview of Liquid Machines</title>
		<author>
			<persName><forename type="first">B</forename><surname>Week</surname></persName>
		</author>
		<ptr target="http://investing.businessweek.com/research/stocks/private/snapshot.asp?privcapId=3079632" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">PACL&apos;s: An Access Control List Approach to Anti-viral Security</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wichers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Olsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crossley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kerchen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Levitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th National Computer Security Conference</title>
		<meeting>the 13th National Computer Security Conference</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Improving application security with data flow assertions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGOPS 22nd symposium on Operating systems principles</title>
		<meeting>the ACM SIGOPS 22nd symposium on Operating systems principles</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Making Information Flow Explicit in HiStar</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Boyd-Wickizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 7th symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="263" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Securing Distributed Systems with Information Flow Control</title>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Boyd-Wickizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazieres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Networked Systems Design and Implementation</title>
		<meeting>the USENIX Symposium on Networked Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
