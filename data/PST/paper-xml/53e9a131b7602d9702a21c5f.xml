<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Search-based model transformation by example</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010-09-22">22 September 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marouane</forename><surname>Kessentini</surname></persName>
							<email>kessentm@iro.umontreal.ca</email>
						</author>
						<author>
							<persName><forename type="first">Houari</forename><surname>Sahraoui</surname></persName>
							<email>sahraouh@iro.umontreal.ca</email>
						</author>
						<author>
							<persName><forename type="first">Mounir</forename><surname>Boukadoum</surname></persName>
							<email>mounir.boukadoum@uqam.ca</email>
						</author>
						<author>
							<persName><forename type="first">Omar</forename><forename type="middle">Ben</forename><surname>Omar</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Département d&apos;Informatique et Recherche Opérationnelle</orgName>
								<orgName type="institution" key="instit1">Université de Montréal</orgName>
								<orgName type="institution" key="instit2">succ Centre-Ville</orgName>
								<address>
									<postCode>6128, H3C 3J7</postCode>
									<settlement>Montréal</settlement>
									<region>CP, QC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Département d&apos;Informatique</orgName>
								<orgName type="institution" key="instit1">Université du Québec à Montréal</orgName>
								<orgName type="institution" key="instit2">succ Centre-ville</orgName>
								<address>
									<postCode>8888, H3C 3P</postCode>
									<settlement>Montréal</settlement>
									<region>CP, QC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Search-based model transformation by example</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2010-09-22">22 September 2010</date>
						</imprint>
					</monogr>
					<idno type="MD5">6DA431B014B180F59A51258B5BC1765C</idno>
					<idno type="DOI">10.1007/s10270-010-0175-7</idno>
					<note type="submission">Received: 1 June 2009 / Revised: 19 August 2010 / Accepted: 20 August 2010 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Search-based software engineering</term>
					<term>Automated model transformation</term>
					<term>Transformation by example</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Model transformation (MT) has become an important concern in software engineering. In addition to its role in model-driven development, it is useful in many other situations such as measurement, refactoring, and test-case generation. Roughly speaking, MT aims to derive a target model from a source model by following some rules or principles. So far, the contributions in MT have mostly relied on defining languages to express transformation rules. However, the task of defining, expressing, and maintaining these rules can be difficult, especially for proprietary and non-widely used formalisms. In some situations, companies have accumulated examples from past experiences. Our work starts from these observations to view the transformation problem as one to solve with fragmentary knowledge, i.e. with only examples of source-to-target MTs. Our approach has two main advantages: (1) it always proposes a transformation for a source model, even when rule induction is impossible or difficult to achieve; (2) it is independent from the source and target formalisms; aside from the examples, no extra information is needed. In this context, we propose an Communicated by Prof. Krzysztof Czarnecki.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In the context of model-driven development (MDD) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b64">65]</ref>, the creation of models and model transformations (MTs) is a central task that requires a mature development environment, based on the best practices of software engineering principles. For a comprehensive approach to MDD, models and MTs must be designed, analyzed, synthesized, tested, maintained and subjected to configuration management to ensure their quality. This makes MT a central concern in the MDD paradigm: not used only in forward engineering, it allows concentrating the maintenance effort on models and using transformation mechanisms to generate code. As a result, many transformation languages are emerging.</p><p>Practical model-to-model transformation languages are of prime importance. Despite the many approaches <ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref> that addressed the request for proposals of OMG QVT RFP <ref type="bibr" target="#b4">[5,</ref><ref type="bibr">6]</ref>, the MT problem has no universal solution since most existing approaches to solve it depend on the source and target metamodels. A popular view attributes the situation to the difficulty of defining or expressing transformation rules, especially for proprietary or non-widely used formalisms.</p><p>Most contributions in MT are concerned with defining languages to express transformation rules. Transformation rules can be implemented using: <ref type="bibr" target="#b0">(1)</ref> general programming languages such as Java or C#; (2) graph transformation languages like AGG <ref type="bibr" target="#b5">[7]</ref> and VIATRA <ref type="bibr" target="#b6">[8]</ref>; (3) specific languages such as ATL <ref type="bibr" target="#b7">[9,</ref><ref type="bibr" target="#b8">10]</ref> and <ref type="bibr">QVT [6,</ref><ref type="bibr" target="#b9">11]</ref>. Sometimes, transformations are based on invariants (pre-conditions and postconditions specified in languages such as OCL <ref type="bibr" target="#b10">[12]</ref>). These approaches have been successfully applied to transformation problems where knowledge exists about the mapping between the source and target models. Still, there exist situations where defining the set of rules is a complex task, and many difficulties accompany the results <ref type="bibr" target="#b11">[13]</ref> (incompleteness, redundancy, inconsistency, etc.). In particular, the experts may find it difficult to master both the source and target meta-models <ref type="bibr" target="#b12">[14]</ref>.</p><p>On the other hand, it is recognized that experts are more easily keen on giving transformation examples than defining complete and consistent transformations rules <ref type="bibr" target="#b13">[15]</ref>. This particularly applies to industrial organizations where a memory of past transformation examples can be found, thus motivating transformation-by-examples approaches such as the one proposed in <ref type="bibr" target="#b14">[16]</ref> whose principle is to semi-automatically derive transformation rules from an initial set of examples (interrelated source and target models), using inductive logic programming (ILP). However, this kind of approach is not adaptable to situations where only a few examples are available.</p><p>We can alternatively view MT as an optimization problem where a (partial) target model is to be automatically derived from available examples. In this context, we recently introduced an optimization-based approach to automate MT called model transformation as optimization by examples (MOTOE) <ref type="bibr" target="#b15">[17]</ref>. MOTOE views MT as a combinatorial optimization problem where the transformation of a source model is obtained by finding, for each of its constructs, a similar transformation from an example base. Due to the large number of possible combinations, a heuristic-search strategy is used to build the transformation solution as a set of individual construct transformations. Taking inspiration from our previous paper <ref type="bibr" target="#b15">[17]</ref>, we extend MOTOE with a more sophisticated transformation building process and use a larger scale validation with industrial data. In particular, we compare two strategies: <ref type="bibr" target="#b0">(1)</ref> parallel exploration of different transformation possibilities (call it population-based MT) by means of a global search heuristic implemented with particle swarm optimization (PSO) <ref type="bibr" target="#b16">[18]</ref>, and (2) initial transformation possibility improvements (call it adaptation-based MT) implemented with a hybrid heuristic search that combines PSO with the local search heuristic simulated annealing (SA) <ref type="bibr" target="#b17">[19]</ref>.</p><p>The approach we propose has the advantage over rule-based algorithms that, for any source model, it always proposes a transformation, even when rule induction is impossible or difficult to achieve. Although, it can be seen as a form of case-based reasoning (CBR) <ref type="bibr" target="#b18">[20]</ref>, it actually differs from CBR in that all the existing models are used to derive a solution, not only the most similar one. Another interesting advantage is that our approach is independent from the source and target formalisms; aside from the examples, no extra information is needed. Still, our approach is not meant primarily to replace rule-based approaches; instead, it targets situations where rules are not available, difficult to define, or non-consensual.</p><p>In this paper, we illustrate and evaluate our approach on the well known case of transforming UML class diagrams (CLD) to relational schemas (RS). As will be shown in Sect. <ref type="bibr" target="#b3">4</ref>, the models obtained by using our transformation approach are comparable to those derived by transformation rules. Our choice of CLD-to-RS transformation is motivated by the fact that it is well known and reasonably complex; this allows us to focus on describing the technical aspects of our approach and comparing its results with those of a well-known alternative. Our approach can also be applied to more complex transformations such as sequence diagrams-to-colored Petrinets <ref type="bibr" target="#b19">[21]</ref>.</p><p>The remainder of this paper is structured as follows: Sect. 2 is dedicated to the MT-problem statement. In Sect. 3, we describe the principles of our approach. The details are discussed in Sect. 3; they include the adaptation of two search algorithms for the MT problem. Section 4 contains the validation results of our approach with industrial projects and a comparison between the global-and adaptation-based strategies. In Sect. 5, the related work in MT is discussed. We conclude and suggest research directions in Sect. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Approach overview</head><p>This section shows how, under some circumstances, MT can be seen as an optimization problem. We also show why the size of the corresponding search space makes heuristic search necessary to explore it. Finally, we give the principles of our approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem statement</head><p>Defining transformations for domain-specific or complex languages requires proficiency in high-level programming languages, knowledge of the underlying metamodels, and knowledge of the semantic equivalency between the metamodels' concepts <ref type="bibr" target="#b0">[1]</ref>. Therefore, creating MT rules may become a complex task <ref type="bibr" target="#b20">[22]</ref>. On the other hand, it is often easier for experts to show transformation examples than to express complete and consistent transformation rules <ref type="bibr" target="#b12">[14]</ref>. This observation has led to a new research direction: model transformation by example (MTBE), where, like in <ref type="bibr" target="#b14">[16]</ref>, rules are semi-automatically derived from examples.</p><p>In the absence of rules or an exhaustive set of examples that allows rule extraction, an alternative solution is to derive a partial target model from the available examples. The generation of such models consists of finding, in the examples, model fragments that best match the model to transform. To characterize the problem, we start with some definitions. Definition 3.1 (Model to transform) A model to transform, M, is a model composed of n constructs expressed in a predefined abstract syntax. Definition 3.2 (Model construct) A construct is a source or target model element, for example, a class in a CLD. It may contain properties that describe it, e.g., its name.</p><p>Complex constructs may contain sub-constructs; for example, a class could have attributes. For graph-based formalisms, constructs are typically nodes and links between nodes. For instance, classes, associations, and generalizations are model constructs in UML CLDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.3 (Block)</head><p>A block defines a previously performed transformation trace between a set of constructs in the source model and a set of constructs in the target model.</p><p>Constructs that should be transformed together are grouped within the same block. For example, a generalization link g between two classes A and B cannot be mapped independently from the mapping of A and B. In our case, we assume that blocks are manually defined by domain experts when transforming models. Finally, blocks are not general rules since they involve concept instances (e.g., class Student) instead of just concepts (e.g., class concept). In other words, where transformation rules are expressed in terms of metamodels, blocks are expressed in terms of concrete models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.4 (Transformation example)</head><p>A transformation example, TE, is a mapping of constructs from a source model to the corresponding target model. Formally, we define a TE as a triple SM D, TMD, M B , where SMD denotes the source model, TMD denotes the target model, and MB is a set of mapping blocks that relate sets of constructs in SMD to their equivalents in TMD. For example, the creation of a database schema from a UML CLD describing student records is a transformation example. The base of examples is a set of transformation examples.</p><p>Our goal is to combine and adapt transformation blockswhich are fragments coming from one or more MTs in the base of examples-to generate a new transformed model by similarity. A fragment from an example model is considered to be similar to one from the source model if it shares the same construct types with similar properties. For instance, in a CLD, a fragment with an association pays between two classes Client and Bill is similar to a fragment from another diagram containing an association evaluates relating classes ControlExam and Module. The degree of similarity depends on the properties and associations of the classes (attributes types, cardinalities, etc.). In the absence of transformation rules, any combination of blocks is a transformation possibility. For example, when transforming a CLD to a database schema, any class can be translated into a table, a foreign key in an existing table, two tables, or any other possible combination of target constructs. However, with transformation examples, the possibilities are reduced to the transformations of similar constructs in the examples.</p><p>The transformation of a model M with n constructs, using a set of examples that globally define m possibilities (blocks), consists of finding the subset from the m possibilities that best transforms each of the n constructs of M. "Best transforms" means that each construct can be transformed by one of the selected possibilities and that construct transformations are mutually consistent. In this context, m n possible combinations have to be explored. This number can quickly become huge. For example, an average UML CLD with 40 classes and 60 links (generalization, associations, and aggregations) defines 100 constructs <ref type="bibr">(40 + 60)</ref>. At the same time, an example base with a reasonable number of examples may contain hundreds of blocks, say 300. In this case, 300 100 possible combinations should be explored. If we limit the possibilities for each construct to only blocks that contain similar constructs, the number of possibilities becomes</p><formula xml:id="formula_0">m 1 × m 2 × m 3 × • • • × m n</formula><p>where each m i ≤ m represents the number of transformation possibilities for construct i. Although the number of possibilities is reduced, it could still be very large for large CLDs. In the same example, assuming that each of the 100 constructs has 8 or more mapping possibilities leads to exploring at least 8 100 combinations. Considering these magnitudes, exploring all the possibilities cannot be done within a reasonable time frame. This calls for alternative approaches such as heuristic search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Approach overview</head><p>We propose an approach that uses knowledge from previously solved transformation cases (examples) to solve new MT problems by using combinations of the past problem solutions. More specifically, the (partial) target models are automatically derived by an optimization process that exploits the available examples.</p><p>Figure <ref type="figure">1</ref> shows the general structure of MOTOE. The approach takes as inputs a base of examples (i.e., a set of transformation examples) and a source model to transform, and generates as output a target model. The generation process can be viewed as the selection of the subset of transformation fragments (blocks) in the example base that best matches the constructs of the source model (using a similarity function). In other words, the transformation is done as an assembly of building blocks. The quality of the produced target model is measured by the conformance of the selected fragments to structural constraints, i.e., by answering the following two questions: (1) did we choose the right blocks? and</p><p>(2) did they fit together? Figure <ref type="figure" target="#fig_0">2</ref> illustrates the case of a source model with six constructs to transform represented by dots. A transformation solution consists of assigning to each construct c i a mapping block, i.e., a transformation possibility from the example base (blocks are represented by rectangles in Fig. <ref type="figure" target="#fig_0">2</ref>). A possibility is considered to be adequate if the assigned block contains a construct similar to c i (similarity evaluation is discussed in Sect. 3.3).</p><p>As many block assembly schemes are possible, the transformation is a combinatorial optimization problem. The number of possible solutions quickly becomes huge as the number of blocks increases. A deterministic search is not practical in such cases, hence the use of heuristic search. The dimensions of the solution space are the constructs of the source model to transform. A solution is determined by the assignment of a transformation fragment (block) to each source model construct. The search is guided by the quality of the solution according to internal coherence (inside a block), and external coherence (between blocks).</p><p>To explore the solution space, we study two different search strategies in this work. The first one uses a global heuristic search by means of the PSO algorithm <ref type="bibr" target="#b16">[18]</ref>. The second one first uses a global heuristic search to shrink the search space and find a first transformation solution; then it uses a local heuristic search, using SA algorithm <ref type="bibr" target="#b17">[19]</ref>, to refine the found solution.</p><p>To illustrate our example-based transformation mechanism, consider the case of MT between UML CLD and RS. Figure <ref type="figure">3</ref> shows a simplified metamodel of the UML CLD,   <ref type="figure">4</ref> shows a partial view of the RS metamodel, composed of table, column, attribute, etc. Normally, the transformation mechanism, based on rules, will specify how the persistent classes, their attributes and their associations should be transformed into tables, columns and keys.</p><p>The choice of this particular example is only motivated by considerations of clarity. MOTOE is independent from the nature of the transformation problem since it does not depend on the source and target metamodels. Instead, it applies to any formalism where prior examples of successful transformation are available.</p><p>A transformation example of a CLD to a RS is presented in Figs. <ref type="figure">5</ref> and<ref type="figure">6</ref>. The CLD is the source model (a) and the RS is the target one (b). The CLD contains 12 constructs that represent 7 classes (including 2 association classes), 3 asso-Fig. <ref type="figure">6</ref> Equivalent RS target model to the CLD source model of Fig. <ref type="figure">5</ref> ciations, and 2 generalization links. The five non-associative classes are mapped to tables with the class attributes mapped to columns of the tables. The associations between Student and Module, and between Teacher and Module, are respectively, translated into tables Register and Intervene with, as columns, the attributes of the associative classes. Each of these tables also contains two foreign keys to their related tables. Association evaluate becomes a foreign key in table ControlExam. Finally, the generalization links are mapped as foreign keys in the tables corresponding to the subclasses.</p><p>The decisions made in this transformation example are not unique alternatives. For instance, we can find many rules (point of views) to transform a generalization link. One of them maps abstract class Person as a duplication of its attributes in the tables that correspond to classes Student and Teacher.</p><p>Following Definition 3.4 of Sect. 2.1, SMD corresponds to the CLD, TMD represents the corresponding RS and MB is the set of mapping blocks between the two models. For example, a block describes the mapping of the association evaluate and classes Module and ControlExam in Fig. <ref type="figure">5</ref>. This block respectively assigns tables Module and ControlExam to the two classes, and foreign key IDModule to the association (Fig. <ref type="figure">5</ref>). As mentioned earlier, the transformations of the three constructs are grouped within the same block since they are interdependent.</p><p>To ease the manipulation of the source and target models and their transformation, the models are described using a set of predicates that correspond to the included constructs. Each construct is represented by one or more predicates. For example, Class Teacher in Fig. <ref type="figure">5</ref> is described as follows:</p><p>The first predicate indicates that Teacher is a class. The second one states that Level is an attribute of that class and that its value is not unique ("_" instead of "unique").</p><p>The mapping blocks relate the predicates in the source model to their equivalent constructs in the target model. For instance, in Fig. <ref type="figure" target="#fig_3">7</ref>, block B37<ref type="foot" target="#foot_0">1</ref> which contains the generalization link and the two classes Teacher and Person is described as follows:</p><p>Mappings are expressed with the ':' character. So, the mapping between predicates Attribute (IDPerson, Person, unique) and Column (IDPerson, Person, pk) indicates that the "unique" attribute IDPerson in class Person is transformed into the column IDPerson in table Person with the status of primary key. Similarly, the mapping between Generalization(Person, Teacher) and Column(IDPerson, Teacher, pfk) indicates that the generalization link is represented by the primary-foreign key (pfk) IDPerson in table <ref type="table">Teacher</ref>.</p><p>A model M i to transform is characterized by its description SMD i , i.e. a set of constructs expressed by predicates. A construct can be transformed in many ways, each having a degree of relevance. This depends on three factors:</p><p>(1) the adequacy of the individual construct transformations;</p><p>(2) the internal consistency of the individual transformations inside the blocks; (3) the transformation (external) coherence between the related blocks, i.e., blocks sharing the same constructs. For example, consider a model to transform that has two classes, Dog and Animal, related by a generalization link g. g could become a table, many tables, a column, a foreign key, or any other possibility. A possibility is considered adequate if there exists a block in the example base that maps a generalization link. For instance, the mapping of block B37 (Fig. <ref type="figure" target="#fig_3">7</ref>) is adequate because it also involves a generalization link. It is also internally consistent since it maps a similar pair of classes. Finally, it is externally coherent if Dog and Animal are only mapped to tables in the other blocks that contain them.</p><p>The transformation quality of a source model is the sum of the transformation qualities of its constructs. Consequently, finding a good transformation is equivalent to finding the combination of construct transformations that maximizes the global quality. But since the number of combinations may be very large because of multiple mapping possibilities, it may become difficult, if not impossible, to evaluate them exhaustively. As stated previously, heuristic search offers a good alternative in this case. The search space dimensions are the constructs and the possible coordinates in these dimensions are the block numbers. A solution then consists of choosing a block number for each construct. The exploration of the search space using heuristic algorithms is presented next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Transformation using search-based methods</head><p>We describe in this section the adaptation of PSO and SA to automate MT. To apply them to a specific problem, one must specify the encoding of solutions, the operators that allow movement in the search space so that new solutions are obtained, and the fitness function to evaluate a solution's quality. These three elements are detailed in Sects. 3.1, 3.2, and 3.3, respectively. Their use by PSO and SA to solve the MT problem is presented in Sects. 3.4 and 3.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Representing transformation solutions</head><p>One key issue when applying a search-based technique is finding a suitable mapping between the problem to solve and the techniques to use, i.e., in our case, encoding transformations between the source and target models. As stated in Sect. 2, we view the set of potential solutions as points in a n-dimensional space where each dimension corresponds to one of the n constructs of the model to transform. For instance, the transformation of the model shown in Fig. <ref type="figure" target="#fig_4">8</ref> will generate a seven-dimensional space that accounts for the four classes and three relationships.</p><p>Each construct is mapped from a finite set of m blocks extracted from the transformation examples. As a result, the dimensions of the search space take discrete values b = {i|1 ≤ i ≤ m}. Thus, to define a particular solution, we associate with each dimension (construct) a block number that contains a transformation possibility and defines a coordinate in the corresponding dimension. The resulting n-tuple of block numbers then defines a vector position in the n-dimensional space. For instance, the solution shown in Table <ref type="table" target="#tab_0">1</ref> suggests that construct1 (class Command) be </p><formula xml:id="formula_1">+ = X V X'</formula><p>Fig. <ref type="figure">9</ref> Change Operator in PSO transformed according to block28, construct2 (class Bill) be transformed according to block3, etc. To summarize, a solution is implemented as a vector where the constructs of the model to transform are the elements and the block numbers that refer to transformation possibilities from the example base are the element values. The proposed coding is valid for both heuristics. In the case of PSO, as an initial population, we create k solution vectors with a random assignment of blocks. Alternatively, SA starts from a solution vector produced by PSO.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Deriving a transformation solution</head><p>A change operator is needed to modify a candidate solution in order to produce a new one. In our case, it modifies a transformation of the source model in order to produce a new one. This is accomplished by changing the blocks for some constructs, which is equivalent to changing the coordinates of the solution in the search space. Unlike solution encoding, change operators are implemented differently by the PSO and SA heuristics. PSO changes blocks as a result of movement in the search space driven by a velocity function; SA performs the change randomly.</p><p>In the case of PSO, a translation (velocity) vector is regularly updated and added to a position vector to define new solutions (see Sect. 3.4, (3) and (4) for details). For example, the solution shown in Table <ref type="table" target="#tab_0">1</ref> may lead to the new solution shown at the bottom of Fig. <ref type="figure">9</ref>. Velocity vector V assigns a real-valued translation for each element of the position vector. After adding the two vectors, the elements of the result are each rounded to the nearest integer to represent block numbers. (The allowable values are bound by 1 and the maximum X X' Fig. <ref type="figure">10</ref> Change Operator in SA number of available blocks). As shown in Fig. <ref type="figure">9</ref>, the new solution updates the block numbers of all construct. Thus, block 42 replaces block 19, block 7 remains the same, block 49 replaces block 51, etc.</p><p>For SA, the change operator involves randomly choosing l dimensions (l &lt; n) and replacing their assigned blocks by randomly selected ones from the example base. For instance, Fig. <ref type="figure">10</ref> shows a new solution derived from the one of Table <ref type="table" target="#tab_0">1</ref>. Constructs 1, 5 and 6 are selected for change. They are assigned blocks 52, 24, and 11 in place of 19, 16, and 83, respectively. The other constructs keep their transformation blocks. The number of blocks to change is a parameter of the SA algorithm (three in this example).</p><p>In summary, regardless of the search heuristic, a change consists of assigning new block numbers to one or more dimensions. Thus, it creates a new transformation solution vector X i+1 from the previous one X i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Evaluating transformation solutions</head><p>The fitness function quantifies the quality of a transformation solution, which is basically a 1-to-1 assignment of blocks from the example base to the constructs of the source model. As discussed in Sect. 2, the fitness function must consider the three following aspects for a construct jto transform:</p><p>• Adequacy of the assigned block to construct j; • Internal coherence of the individual construct transformation; • External coherence with the other construct transformations.</p><p>In this context, we define the fitness function of a solution as the sum of qualities of the n individual construct transformations. Formally,</p><formula xml:id="formula_2">f = n j=1 a j × ic j + ec j (1)</formula><p>where j stands for a construct, a j is the adequacy factor, ic j the internal-coherence factor and ec j the externalcoherence factor. a j has value 1 if the block associated to construct j contains at least one construct of the same type, and value 0 otherwise. It basically penalizes the assignment of irrelevant blocks by assigning a zero adequacy value to them; this serves to reduce the search space. The internal-coherence factor ic j measures the similarity, in terms of properties, between the construct to transform and the construct of the same type in the assigned block. As shown in Sect. 3.1, the properties of the constructs are represented by the parameters of the predicates. Formally:</p><formula xml:id="formula_3">ic j =</formula><p>number of matched parameters in the predicates of the jth construct total number of parameters in the predicates of the jth construct</p><p>In general, a block assigned to a construct j contains more constructs than the one that is adequate with j. The externalcoherence factor evaluates to which extent these constructs match the constructs that are linked to j in the source model. ec j is defined as ec j = number of matched constructs related to the jth construct total number of constructs related to jth construct</p><p>To illustrate the fitness calculation, consider again the example of Fig. <ref type="figure" target="#fig_4">8</ref>. The association payable_by (sixth dimension) is defined by the predicate</p><formula xml:id="formula_4">Association (1,n,1,1,_,Command, Bill)</formula><p>where the first four parameters indicates the multiplicities (1..n and 1..1), the fifth the name of the associative class if it exists, and the last two the source and target classes (Command andBill). Consider a solution s 1 that assigns block 42 to this association:</p><p>In this case, a 6 (adequacy for the 6 th construct) is equal to 1 because block 42 contains a predicate Association that relates classes Client and Reservation. This association predicate has five parameters out of seven that match the ones of pays (1, n, x, x, _, origin and destination class names). As a result, we have ic 6 = 5/7 = 0.71. Moreover, according to block 42, to be consistent with the transformation of payable_by, classes Bill and Command have to be mapped to tables. On the other hand, s 1 also assigns blocks 28 and 3 to classes Bill (dimension 2) and Client (dimension 4), respectively. These two blocks are defined as follows.</p><p>In both blocks, classes are transformed into tables. Since this does not conflict with block 42, we have for the two related constructs c 6 = 2/2 = 1.</p><p>The fitness function also evaluates the completeness of a transformation indirectly. A solution that does not transform a subset of constructs will be penalized. Those constructs will have null values (a j being always equal to 0). Finally, to make the values comparable across models with different numbers of constructs, a normalized version of the fitness function is used. For a particular construct, the fitness varies between 0 and 2 (ic j and ec j can be both equal to 1). Considering the n constructs, we normalized the fitness function as follows:</p><formula xml:id="formula_5">f nor = f 2 × n (2)</formula><p>We used this normalized fitness function for both PSO and SA.</p><p>3.4 Global search (PSO)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">PSO principles</head><p>Particle swarm optimization is a parallel population-based computation technique <ref type="bibr" target="#b16">[18]</ref>. It was originally inspired from the flocking behavior of birds, which emerges from very simple individual conducts. Many variations of the algorithm have been proposed over the years, but they all share a common basis. First, an initial population (named swarm) of random solutions (named particles) is created. Then, each particle flies in the n-dimensional problem space with a velocity that is regularly adjusted according to the composite flying experience of the particle and some, or all, the other particles. All particles have fitness values that are evaluated by the objective function to be optimized. Every particle in the swarm is described by its position and velocity. A particle position represents a possible solution to the optimization problem, and velocity represents the search distances and directions that guide particle flying. In this paper, we use basic velocity and position update rules defined by Kennedy and Eberhart <ref type="bibr" target="#b16">[18]</ref>:</p><formula xml:id="formula_6">V id = W × V id + C 1 × Rand() × P id -X id +C 2 × Rand() P gd -X id (3) X id = X id + V id<label>(4)</label></formula><p>At each time (iteration), V id represents the particle velocity and X id its position in the search space. P id (also called pbest for local best solution), represents the ith particle's best previous position, and P gd (also called gbest for global best solution), represents the best position among all particles in the population. w is an inertia term; it sets a balance between the global and local exploration abilities in the swarm. Constants c 1 and c 2 represent cognitive and social weights associated to the individual and global behavior, respectively. There are also two random functions rand() and Rand() (normally uniform in the interval [0, 1]) that represent stochastic acceleration during the attempt to pull each particle toward the pbest and gbest positions. For a n-dimensional search space, the i th particle in the swarm is represented by a n-dimensional vector, x i = (x i1 , x i2 , . . ., x id ). The velocity of the particle, pbest and gbest are also represented by n-dimensional vectors. Algorithm 1 summarizes the generic PSO procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">PSO</head><p>The is represented as a set of K particles, each defined by a position vector corresponding to the n constructs of the model to transform. For a particle position, the values of the position vector's elements are the mapping blocks selected for each construct. Our version of PSO starts by randomly generating the particle positions and velocities in the swarm. This is done by randomly affecting a block number to each of the n constructs (dimensions). Thus, the initial particle population represents K different possibilities (solutions) to transform the source model by combining blocks from the transformation examples. The fitness of each particle is measured by the fitness function defined by ( <ref type="formula">1</ref>) and (2).</p><p>The particle with the highest fitness is memorized as the global best solution during the search process. At each iteration, the algorithm compares the fitness of each particle with those of the other particles in the population to determine the gbest position for use to update the swarm. Then, for each particle, it compares its current positions with pbest, and update the latter if an improvement is found. The new positions affect the velocity of each particle according to <ref type="bibr" target="#b2">(3)</ref>.</p><p>The algorithm iterates until the particles converge towards a good transformation solution of the source model. In our case, we define a maximum number of iterations after which we select the gbest as the transformation solution. The algorithm stops before if all the particles converge to the same solution.</p><p>The parameters in Eq.( <ref type="formula">3</ref>) have an important effect on the search efficiency of the PSO algorithm. Acceleration constants c 1 and c 2 adjust the amount of "tension" in the system. Low values allow particles to roam far from target regions before being tugged back, while high values result in abrupt movement toward, or past, target regions <ref type="bibr" target="#b21">[23]</ref>. Based on past research experience, we set both constants to 1. Equations ( <ref type="formula">3</ref>) and ( <ref type="formula" target="#formula_6">4</ref>) may lead to large absolute values for V id and X id , so that a particle may overshoot the problem space. Therefore, V id and X id should be confined to a maximum velocity V max , and a maximum position X max , such that</p><formula xml:id="formula_7">X max = N ; X id = min (max (0, X id + V id ), X max ) (5)</formula><p>V max serves as a constraint to control the global exploration ability of a particle swarm. It should take values in the interval [-m, m], m being the number of blocks in the existing transformation examples. X id represents the block number affected to a construct; it must be a positive integer. Hence, a real value for X id is rounded to the closest block number by dropping the sign and the fractional part. The inertia weight (w) is another important parameter of the PSO search. A proper value for w provides a balance between global and local exploration, and results in less iterations to find a solution on average. In practice, it is often linearly decreased through the course of the PSO, for the PSO to have more global search ability at the beginning of the run and more local search ability near the end. For the validation experience in this paper, the parameter was set as follows <ref type="bibr" target="#b21">[23]</ref>:</p><formula xml:id="formula_8">W = W max - W max -W min iter max × iter (6)</formula><p>where W max is the initial value of weighting coefficient, W min is a minimal value of weighting coefficient, iter max is the maximum number of iterations, and iter is the current iteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Local search (SA)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1">SA principles</head><p>In the case of a quick run of PSO (only a few iterations), the best transformation solution can be improved by using another search heuristic. We propose in this work to use SA in combination with PSO. SA <ref type="bibr" target="#b17">[19]</ref> is a search algorithm that gradually transforms a solution following the annealing principle used in metallurgy.</p><p>The generic behavior of this heuristic is described by Algorithm 2. After defining an initial solution, the algorithm iterates the following three steps:</p><p>1. Determine a new neighboring solution, 2. Evaluate the fitness of the new solution 3. Decide on whether to accept the new solution in place of the current one based on the fitness gain/lost.</p><p>When cost &lt; 0, the new solution has lower cost than the current solution and it accepted. For cost &gt; 0 the new solution has higher cost. In this case, the new solution is accepted with probability e -cost/T . The introduction of a stochastic element in the decision process avoids being trapped in a local minimum solution. Parameter T , called temperature, controls the acceptance probability of a lesser good solution. T begins with a high value, for a high probability of accepting a solution during the early iterations. Then, it decreases gradually (cooling phase) to lower the acceptation probability as we advance in the iteration sequence. For each temperature value, the three steps of the algorithm are repeated for a fixed number of iterations.</p><p>One attractive feature of the SA algorithm is that it is problem-independent and can be applied to most combinatorial optimization problems <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b23">25]</ref>. However, SA is usually slow to converge to a solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2">SA for MT</head><p>To obtain a more robust optimization technique, it is common to combine different search strategies in an attempt to compensate the deficiencies of individual algorithms <ref type="bibr" target="#b22">[24]</ref>. In our case, the search for a solution is done in two steps. First, a global search is quickly performed to locate the portion of search space where good solutions are likely to be found. This is performed by PSO and results in a near-optimal solution. In the second step, the obtained solution is refined by the SA algorithm.</p><p>As described in Sect. 3.1, solutions are coded by assigning a block number to each construct in order to form a vector. The SA algorithm starts with an initial solution generated by a quick run of PSO. As for PSO, the fitness function presented in Sect. 3.3 measures the quality of the solution at the end of each iteration. The generation of a neighboring solution is obtained by randomly changing a number of dimensions with new randomly selected blocks. The way in which we decrement the temperature coefficient is critical to the success of the algorithm. SA theory states that we should allow enough iterations for each temperature value to allow the system to stabilize at that temperature. Unfortunately, the theory also states that the number of iterations at each temperature to achieve this might vary exponentially with problem size. As this is impractical, a compromise measure is to either do a large number of iterations for a few temperature values, a small number of iterations for many temperatures values, or strike a balance between the two. One way to decrement the temperature is use a geometric cooling schedule <ref type="bibr" target="#b17">[19]</ref>. The temperature is reduced using:</p><formula xml:id="formula_9">T i+1 = α × T i (<label>7</label></formula><formula xml:id="formula_10">)</formula><p>where α is a constant less than 1. Experience has shown that α should be between 0.8 and 0.99, with better results being found at the higher end of the range. On the other hand, the higher the value of α, the longer it will take to decrement the temperature to the stopping criterion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation and comparison</head><p>To evaluate the feasibility of our approach, we conducted an experiment with industrial data. We start by presenting our experimental setting. Then, we describe and discuss the obtained results. We compare in particular the results of PSO with the PSO-SA combination. Finally, we evaluate the impact of the example base size on transformation quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Setting</head><p>We used 12 examples of class-diagrams to RS transformations to build an example base EB</p><formula xml:id="formula_11">= { CLD i , SR i |1 ≤ i ≤ 12}.</formula><p>The examples were provided by an industrial partner.</p><p>As showed in Table <ref type="table" target="#tab_1">2</ref>, the size of the CLDs varied from 28 to 92 constructs, with an average of 58. Altogether, the 12 examples defined 257 mapping blocks. Because our industrial partner uses Rational Rose to derive RS from UML class models, we did not have transformation blocks defined by experts during the transformation. For the need of the experience, we automatically extracted the transformation traces from XMI files produced by Rational Rose. Then, we manually partitioned the traces into blocks. To evaluate the quality of transformations produced by MOTOE, we used a 12-fold cross validation procedure. For each fold, one class diagram CLD j is transformed by using the remaining 11 transformation examples (EB j = { CLD i , RS i |i = j}). Then the transformation result of each fold is checked for correctness. The correctness of a transformation tCLD j was measured by two methods: automatic correctness (AC) and manual correctness (MC). Automatic correctness consists of comparing the derived transformation tCLD j to the known RS j , construct by construct. This method has the advantage of being automatic and objective. However, since a given CLD j may have different transformation possibilities, AC could reject a valid construct transformation because it yields a different RS from the one provided. To account for those situations, we also use MC which manually evaluates tCLD j , here again construct by construct. In both cases, the correctness of a transformation is the proportion of constructs that are correctly transformed.</p><p>To set the parameters of PSO for the global search strategy, we started with commonly found values in the literature <ref type="bibr" target="#b24">[26]</ref><ref type="bibr" target="#b25">[27]</ref><ref type="bibr" target="#b26">[28]</ref> and adapted some of them to the particularities of the transformation problem. The final parameters values were set as follows:</p><p>• The swarm is composed of 40 particles. We found this number to provide a good balance between population diversity and the quantity of available examples. • The inertia weight W is initially set to 1.3 and gradually decreased after each iteration according to (6), until it reaches 0.3, • C 1 and C 2 are both equal to 1 to give equal importance to local and global search. • The maximum number of iterations is set to twice the size of the population, i.e. 80. This is a generally accepted heuristic <ref type="bibr" target="#b21">[23]</ref>.</p><p>• Since two different executions of a search heuristic may produce different results for the same model, we decided, for each of 12 folds, to take the best result from 5 executions.</p><p>As mentioned previously, the initial particle positions are randomly generated. The range of values for each particle coordinate (construct) is defined as [0, MaxBlocks] where MaxBlocks is the total number of blocks extracted from the 11 examples of the fold. In our case, MaxBlocks is 257 minus the number of blocks of the fold example.</p><p>For the hybrid search strategy, the SA algorithm was applied using the following parameters:</p><p>• The initial temperature of the process is randomly selected in the range [0, 1]; • The geometric cooling coefficient α is 0.98; • The iteration interval for temperature update is 10,000 (to account for SA's slowness); • The number of dimensions to change for generating a neighboring solution is set to 2. This value offers a good balance with the large number of iterations; • The stopping criterion (temperature threshold) is 0.1.</p><p>To quickly generate an initial solution for SA, we limited the number of particles to 10 and the number of iterations to 20 for PSO.</p><p>With these parameter values, the transformation of the largest of the used diagrams only took a few seconds of runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Results and discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Results</head><p>Tables <ref type="table" target="#tab_1">2</ref> and<ref type="table" target="#tab_2">3</ref>, respectively, show the obtained correctness for each of the 12 folds, when using global and hybrid search. Both automatic and manual correctness values were high and, as expected, manual evaluation yielded better correctness since it considered all the correct transformations and not only the specific alternatives chosen by our industrial partner. We consider correctness values (74 and 94% for, respectively, the automatic and the manual validation) as relatively high relatively given the context of no transformation rules and the limited number of used examples.</p><p>Table <ref type="table" target="#tab_1">2</ref> shows the correctness of the generated transformations using the PSO heuristic. The automatic correctness measure had an average value of 73.3%, with most of the models transformed with at least 70% precision. The manual correctness measure was much greater, with an average value of 93.2%; this indicates that the proposed transformations were almost as correct as the ones given by experts. The worst model (SM9) had an acceptable MC of 87% and four models obtained an MC greater than 95%, with a value of 98.1% for SM8. The hybrid search gave slightly better correctness results as shown in Table <ref type="table" target="#tab_2">3</ref>. Both automatic and manual correctness were slightly better on average (93.4% for AC and 94.8 for MC). With regards to MC, the quality of eight MTs was improved while that of four was slightly degraded. For instance, MC for the worst transformed model (SM9) improved from 87 to 93.1%, while that for the best transformed model (SM5) decreased from 95.2 to 93%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Discussion</head><p>One observation to be made from the results in Tables <ref type="table" target="#tab_1">2</ref> and<ref type="table" target="#tab_2">3</ref> is that, with the exception of model SM7, hybrid search yielded better results than global search for the models with the highest numbers of constructs. This may be due to the fact that, when the number of dimensions is high, the search space is very large and the use of PSO leads to particle movement steps that can only approximate the location of the target solution. A more focused search consisting of global search followed by local exploration produces better results in this case. In contrast, for a smaller search space (less dimensions), area coverage by the particles is easier, and a global search appears to be more efficient to zero in on the solution.</p><p>To better analyze the performance of the hybrid strategy, Fig. <ref type="figure">11</ref> shows, for all models, the average final values of the fitness function after the quick search with PSO and their corresponding values after the refinement made by SA. As one can see, substantial fitness improvement occurred (&gt;50% in many cases) in each case of the 12-fold cross validation. It appears then that the hybrid strategy brings a Fig. <ref type="figure">11</ref> Fitness improvement with SA after PSO initial pass Fig. <ref type="figure" target="#fig_0">12</ref> Example-size variation with PSO good compromise between correctness and execution time: it allows improving the transformation correctness with a slight increase of the execution time. The obtained results also show that our fitness function is a good estimator of transformation correctness.</p><p>An important consideration is the impact of the example base size on transformation quality. Drawn for SM7, the results of Figs. 12 and 13 show that our approach also proposes transformation solutions in situations where only few examples are available. When using the global search strategy, AC seems to grow steadily and linearly with the number of examples. For the hybrid strategy, the correctness seems to follow an exponential curve; it rapidly grows to acceptable values and then slows down. Indeed, AC improved from roughly 30 to 65% as the example base size went from 1 to 4 examples. Then, it grew only by an additional 15% as the size varied from 6 to 11 examples.</p><p>When manually analyzing the results, we noticed that some of the 12 models had constructs not present in the other models. Those constructs were generally not transformed as no adequate block could be found for them. However, others were transformed by adapting the transformation of constructs of the same nature. This was the case, for instance, for an association with multiplicity (1..N , 1..N ). Since the multiplicity elements are considered as parameters of the construct, the transformation of an association (0..N , 0..N ) was applied with a penalty for the fitness function. Although these few cases of adaptation improved the global correctness scores, we did not specifically address the issue at the current stage of our research.</p><p>Finally, since we viewed the transformation problem as a combinatorial problem addressed with heuristic search, it is important to contrast the correctness results with the execution time. We executed our algorithm on a standard desktop computer (Pentium CPU running at 2 GHz with 1GB of RAM). The execution time is shown in Fig. <ref type="figure">14</ref> for a number of constructs to transform corresponding to small to medium-sized problems. The Figure reveals that greater execution times may be obtained in comparison with using rule-based tools for small-dimensional problems. In any case, our approach is meant to apply to situations where rule-based solutions are normally not readily available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related work</head><p>The work proposed in this paper can be related to three research areas in software engineering, of which the most relevant one is MT in the context of MDD. Some links can also be found with by-example and search-based software engineering (SBSE), but our concerns are different as will be discussed below. As a result, only a comparison to alternatives in the first area is warranted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Model transformation</head><p>Several MT approaches can be found in the literature (see, for example, the classifications given in <ref type="bibr" target="#b27">[29,</ref><ref type="bibr" target="#b28">30]</ref>). Czarnecki and Helsen <ref type="bibr" target="#b27">[29]</ref> distinguish between two main types: modelto-model and model-to-code. They describe five categories of the former: Graph-transformation-based <ref type="bibr" target="#b29">[31]</ref>, relational <ref type="bibr" target="#b30">[32]</ref>, structure-driven <ref type="bibr" target="#b31">[33]</ref>, direct-manipulation and hybrid. They use various criteria to analyze them, like the consideration of model-driven architecture (MDA) as a basis for transformation, the complexity and scalability of the transformation mechanism, the use or not of annotations, the level of automation, and the used languages and implementation techniques. In general, the reported approaches are based on empirically obtained rules <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b32">34]</ref> in contradistinction to block transformation in MOTOE. In rules-based approaches, the rules are defined in metamodels while our blocks relate to specific problems, with a varying structure, for different problems.</p><p>In existing transformation approaches such as graph transformation <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b33">[35]</ref><ref type="bibr" target="#b34">[36]</ref><ref type="bibr" target="#b35">[37]</ref><ref type="bibr" target="#b36">[38]</ref><ref type="bibr" target="#b37">[39]</ref><ref type="bibr" target="#b38">[40]</ref>, a transformation rule consists of two parts: a left-hand side (LHS) and a right-hand side (RHS). The LHS accesses the source model, whereas the RHS expands in the target model. By comparison, each block in MOTOE contains a transformation of source elements (LHS) to their equivalent target elements (RHS). However, in a graph-transformation approach, potentials conflicts between transformation elements are verified with pre and post condition. In our case, pre and post conditions are replaced by the fitness function that ensures transformations coherency.</p><p>In rule based approaches, a rule is applied to a specific location within its source scope. Since there may be more than one match for a rule within a given source scope, we need an application strategy. The strategy could be deterministic, non-deterministic or even interactive <ref type="bibr" target="#b39">[41]</ref>. For example, a deterministic strategy could exploit some standard traversal strategy (such as depth-first) over the containment hierarchy in the source. In our work, the transformation possibilities (blocks) are randomly chosen with no strategy for rules application (e.g., rules scheduling).</p><p>Transformation rules are usually designed to have a functional character: given some input in the source model, they produce a concrete result in the target model <ref type="bibr" target="#b8">[10]</ref>.</p><p>A declarative rule (i.e., one that only uses declarative logic and/or patterns) can often be applied in the inverse direction. However, since different inputs may lead to the same output, the inverse of a rule may not be a function. We have the same problem in our approach since blocks are only defined in one direction (from CLD to RS for example). To ensure a bidirectional transformation property, we need to apply our methodology to examples from the other direction.</p><p>If we define cognitive complexity as the level of difficulty to design a MT, we believe that collecting/recording transformation examples may be less difficult than producing and maintaining consistent transformation rule sets. This is consistent with recent trend in industry where we find several tools to record transformations and automatically generate transformation traceability records <ref type="bibr" target="#b40">[42]</ref>.</p><p>The traditional approach for implementing MTs is to specify transformation rules and automate the transformation process by using a MT language <ref type="bibr" target="#b41">[43]</ref>. Most of these languages are powerful enough to implement large-scale and complex MT tasks. However, the transformation rules are usually defined at the metamodel level, which requires a clear and deep understanding about the abstract syntax and semantic interrelationships between the source and target models. In some cases, domain concepts may be hidden in the metamodel and difficult to unveil <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b32">34]</ref> (e.g., some concepts are hidden in attributes or association ends, rather than being represented as first-class entities). These implicit concepts may make writing transformation rules difficult.</p><p>To help address the previous challenges, an alternative approach called MTBE was proposed in <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b14">16]</ref>. In it, users are asked to build a prototypical set of interrelated mappings between the source and target model instances, and then the metamodel-level transformation rules will be semi-automatically generated. Because users configure the mappings at the instance level, without knowing any details about the metamodel definition or the hidden concepts, combined with the generated rules, the simplicity of specifying MTs can be improved. Varrò and Balogh <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b14">16]</ref> propose a semi-automated process for MTBE using ILP. The principle of their approach is to derive transformation rules semi-automatically from an initial prototypical set of interrelated source and target models. Another similar work is that of Wimmer et al. <ref type="bibr" target="#b42">[44]</ref> who derive ATL transformation rules from examples of business process models. Both works use semantic correspondences between models to derive rules. Their differences include the fact that <ref type="bibr" target="#b42">[44]</ref> presents an object-based approach that finally derives ATL rules for MT, while <ref type="bibr" target="#b14">[16]</ref> derives graph transformation rules. Another difference is that they respectively use abstract versus concrete syntax: Varro uses IPL while Wimmer relies on an ad hoc technique. Both approaches provide a semi-automatic generation of MT rules that needs further refinement by the user. Also, since both approaches are based on semantic mappings, they are more appropriate in the context of exogenous MTs between different metamodel. Unfortunately, the generation of rules to transform attributes is not well supported in most MTBE implementations. Our model is different from both previous approaches to MTBE. We do not create transformation rules to transform a source model, directly using examples instead. As a result, our approach does not rely upon formalisms.</p><p>Recently, a similar approach to MTBE, called Model Transformation By Demonstration (MTBD), was proposed <ref type="bibr" target="#b43">[45]</ref>. Instead of the MTBE idea of inferring the rules from a prototypical set of mappings, users are asked to demonstrate how the MT should be done, through direct editing (e.g., add, delete, connect, update) of the source model, so as to simulate the transformation process. A recording and inference engine was been developed, as part of a prototype called MT-Scribe, to capture all user operations and infer a user's intention during a MT task. A transformation pattern is generated from the inference, specifying the preconditions of the transformation and the sequence of operations needed to realize the transformation. This pattern can be reused by automatically matching the preconditions in a new model instance and replaying the necessary operations to simulate the MT process. However, this approach needs a large number of simulated patterns to be efficient and it requires a high level of user intervention. In fact, the user must choose the suitable transformation pattern. Finally, the authors do not show how MTBD can be useful to transform an entire source model and only provide examples of transforming model fragments.</p><p>Some others metamodel matching works can also be considered as variants of by-example approaches. Garcia-Magarino et al. <ref type="bibr" target="#b45">[46]</ref> propose an approach to generate transformation rules between two meta-models that satisfy some constraints introduced manually by the developer. In <ref type="bibr" target="#b46">[47]</ref>, the authors propose to automatically capture some transformation patterns in order to generate matching rules in the metamodel level. This approach is similar to MTBD, but it is used at the meta-model level. The fundamental difference of these approaches with ours is that we do not generate transformation rules and MOTOE does not need to specify the source and target metamodels as input.</p><p>To conclude, the previous problems limit the applicability of MTBE/MTBD for some transformation problems. In such situations, MOTOE may leads to more relevant solutions. In our approach, the definition of transformation examples is based on the use of traceability information <ref type="bibr" target="#b40">[42,</ref><ref type="bibr" target="#b47">[48]</ref><ref type="bibr" target="#b48">[49]</ref><ref type="bibr" target="#b49">[50]</ref><ref type="bibr" target="#b50">[51]</ref><ref type="bibr" target="#b51">[52]</ref>. Traceability usually allows tracing artifacts within a set of chained operations, where the operations may be performed either manually (e.g., crafting a software design for a set of software requirements) or with automated assistance (e.g., generating code from a set of abstract descriptions). For example, Triple Graph Grammars (TGG) <ref type="bibr" target="#b52">[53]</ref> explicitly maintain the correspondence of two graphs by means of correspondence links. These correspondence links play the role of traceability links that map elements of one graph to elements of the other graph, and vice versa. With TGG, one has to explicitly describe the correspondence between the source and target models, which is difficult if the transformation is complex and the intermediate models are required during the transformation. In <ref type="bibr" target="#b53">[54]</ref>, a traceability framework for Kermeta is discussed. This framework supports the creation of traces throughout a transformation chain. Marvie describes a transformation composition framework <ref type="bibr" target="#b54">[55]</ref> that allows manual creation of linkings (traces). This framework does not support the automatic generation of traces.</p><p>Finally, a large part of the work on traceability in MDE uses it for detecting model inconsistency and fault localization in transformations. In MOTOE, this is not the goal as the purpose is to use trace information as input to automate the transformation process. The trace information (model correspondence) between a source and target model define a transformation example that is decomposed in some independent blocks as explained before.</p><p>Our approach is also different from CBR methods where the level of granularity must be the example as a whole, i.e., a transformation example <ref type="bibr" target="#b18">[20]</ref>; in our case, we do not select the most similar example and adapt its transformation; rather, we aggregate the best transformation possibilities coming from different examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">By-example software engineering</head><p>The approach proposed in this paper is based on using past transformation examples. Various such "by-example" approaches have been proposed in the software engineering literature <ref type="bibr" target="#b55">[56,</ref><ref type="bibr" target="#b56">57]</ref>. However, the problems addressed by them differ from ours in both nature and objectives. The closest work to ours is program transformations by demonstration <ref type="bibr" target="#b57">[58,</ref><ref type="bibr" target="#b58">59]</ref>, in which a user manually changes program examples while a monitoring plug-in to the development environment records the changes. Then, the recorded data are analyzed to create general transformations that can be reused in subsequent programs. However, the overall process is not automated and requires frequent interaction with the user, and the generated transformation patterns are found via a different algorithms than the one used by MOTOE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Search-based software engineering</head><p>Our approach is inspired by contributions in SBSE <ref type="bibr" target="#b59">[60]</ref><ref type="bibr" target="#b60">[61]</ref><ref type="bibr" target="#b61">[62]</ref><ref type="bibr" target="#b62">[63]</ref><ref type="bibr" target="#b63">[64]</ref><ref type="bibr" target="#b65">66]</ref>. As the name indicates, SBSE uses a search-based approach to solve optimization problems in software engineering. Once a software engineering task is framed as a search problem, by defining it in terms of solution representation, fitness function and solution change operators, there are many search algorithms that can be applied to solve that problem. To the best of our knowledge, inspired among others by the roadmap paper of Harman <ref type="bibr" target="#b61">[62]</ref>, the idea of treating MT as a combinatorial optimization problem to be solved by a search-based approach was not studied before our proposal in <ref type="bibr" target="#b15">[17]</ref>. For this reason, we cannot compare our approach to existing works in SBSE since their application domain is different.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Summary and conclusion</head><p>In summary, we described MOTOE, a novel approach to automate MT using heuristic search. MOTOE uses a set of transformation examples to derive a target model from a source model. The transformation is seen as an optimization problem where different transformation possibilities are evaluated and, for each possibility, a quality is associated depending on its conformance with the examples at hand. The search space is explored with two methods. In the first one, we use PSO with transformation solutions generated from the examples at hand as particles. Particles progressively converge toward a good solution by exchanging and adapting individual construct transformation possibilities. In the second method, a partial run of PSO is performed to derive an initial solution. This solution is then refined using a local search with SA. The refinement explores neighboring solutions obtained by trying individual construct transformation possibilities derived from the example base. In both methods, the quality of a solution considers the adequacy of construct transformations as well as their mutual consistency.</p><p>We illustrated MOTOE with the transformation of UML CLDs to RS. In this context, we conducted a validation on real industrial models. The experiment results clearly indicate that the derived models are comparable to those proposed by experts (correctness of more than 90% with manual evaluation). They also reveal also that some constructs were correctly transformed although no transformation examples were available for them. This was possible because the approach uses syntactic similarity between construct types to adapt their transformations. We also showed that the two methods used for the space search produced comparable results when properly applied, and that PSO alone is enough with small-to-medium models while the combination PSO-SA is more suitable when the size of the models to transform is larger. For both methods, our transformation process derives a good quality transformation in an acceptable execution time. Finally, the validation study showed that the quality of MT improves with the number of examples. However, it reaches a stable score after as few as nine examples.</p><p>Our proposed method also has limitations. First, MOTOE's performance depends on the availability of transformation examples, which could be difficult to collect.</p><p>Second, the generation of blocks from the examples is done manually in our present work; we could partially automate this task using decomposition heuristics. Third, due to the nature of our solution, i.e., an optimization technique, the transformation process can be time consuming for large models. Finally, as we use heuristic algorithms, different execution for the same source models may lead to different target models. Nevertheless, we showed in our validation that solutions that have high fitness values also have good correctness. Moreover, this is close to what happens in the real world where different experts could propose different target models.</p><p>From the applicability point of view, our approach can theoretically be applied to the transformation of models for any pair of source/target formalisms. To practically assess this claim, we are currently experimenting with other formalisms such as sequence diagrams to Petri nets. We also plan to work on adapting our approach to other transformation problems such as code generation (model-to-code), refactoring (code-to-code), and reverse engineering (code-to-model). The refactoring problem also has the advantage of exploring endogenous transformations where source and target models conform to the same metamodel. Regarding the quality evaluation of transformations, the fitness function we used could be improved. In this work, we gave equal importance to all constructs. In the real world, some construct types may be more important than others.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2</head><label>2</label><figDesc>Fig. 1 MOTOE overview</figDesc><graphic coords="4,53.56,160.79,232.84,89.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 Fig. 4 Fig. 5</head><label>345</label><figDesc>Fig. 3 Class diagram metamodel</figDesc><graphic coords="4,308.68,56.57,232.84,80.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 7</head><label>7</label><figDesc>Fig. 7 Base of transformation examples and block generation in the source model of TE4</figDesc><graphic coords="6,114.64,57.02,365.80,235.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 8</head><label>8</label><figDesc>Fig. 8 Example of source model (UML-class diagram)</figDesc><graphic coords="6,308.68,332.45,232.84,165.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 13 Fig. 14</head><label>1314</label><figDesc>Fig. 13 Example-size variation with PSO-SA</figDesc><graphic coords="13,71.08,56.42,197.32,154.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Solution representation</figDesc><table><row><cell>Dimension</cell><cell>Construct</cell><cell>Block number</cell></row><row><cell>1</cell><cell>Class(Command)</cell><cell>28</cell></row><row><cell>2</cell><cell>Class(Bill)</cell><cell>3</cell></row><row><cell>3</cell><cell>Class(Article)</cell><cell>21</cell></row><row><cell>4</cell><cell>Class(Seller)</cell><cell>13</cell></row><row><cell>5</cell><cell>Aggregation</cell><cell>9</cell></row><row><cell>6</cell><cell>Association(payable_by)</cell><cell>42</cell></row><row><cell>7</cell><cell>Association(pays)</cell><cell>5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc><ref type="bibr" target="#b10">12</ref>-fold cross validation with PSO</figDesc><table><row><cell>Source model</cell><cell>Number of constructs</cell><cell>Fitness</cell><cell>AC</cell><cell>MC</cell></row><row><cell>SM 1</cell><cell>72</cell><cell>0.696</cell><cell>0.618</cell><cell>0.882</cell></row><row><cell>SM 2</cell><cell>83</cell><cell>0.714</cell><cell>0.682</cell><cell>0.928</cell></row><row><cell>SM 3</cell><cell>49</cell><cell>0.762</cell><cell>0.721</cell><cell>0.943</cell></row><row><cell>SM 4</cell><cell>53</cell><cell>0.796</cell><cell>0.719</cell><cell>0.931</cell></row><row><cell>SM 5</cell><cell>38</cell><cell>0.773</cell><cell>0.789</cell><cell>0.952</cell></row><row><cell>SM 6</cell><cell>47</cell><cell>0.746</cell><cell>0.652</cell><cell>0.918</cell></row><row><cell>SM 7</cell><cell>78</cell><cell>0.715</cell><cell>0.772</cell><cell>0.957</cell></row><row><cell>SM 8</cell><cell>34</cell><cell>0.896</cell><cell>0.822</cell><cell>0.981</cell></row><row><cell>SM 9</cell><cell>92</cell><cell>0.61</cell><cell>0.634</cell><cell>0.87</cell></row><row><cell>SM 10</cell><cell>28</cell><cell>0.892</cell><cell>0.908</cell><cell>0.969</cell></row><row><cell>SM 11</cell><cell>59</cell><cell>0.773</cell><cell>0.717</cell><cell>0.915</cell></row><row><cell>SM 12</cell><cell>63</cell><cell>0.805</cell><cell>0.762</cell><cell>0.938</cell></row><row><cell>Average</cell><cell>58</cell><cell>0.764</cell><cell>0.733</cell><cell>0.932</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3</head><label>3</label><figDesc><ref type="bibr" target="#b10">12</ref>-fold cross validation with PSO-SA</figDesc><table><row><cell>Source model</cell><cell>Number of constructs</cell><cell>Fitness</cell><cell>AC</cell><cell>MC</cell></row><row><cell>SM 1</cell><cell>72</cell><cell>0.735</cell><cell>0.696</cell><cell>0.947</cell></row><row><cell>SM 2</cell><cell>83</cell><cell>0.784</cell><cell>0.723</cell><cell>0.962</cell></row><row><cell>SM 3</cell><cell>49</cell><cell>0.632</cell><cell>0.69</cell><cell>0.912</cell></row><row><cell>SM 4</cell><cell>53</cell><cell>0.619</cell><cell>0.672</cell><cell>0.956</cell></row><row><cell>SM 5</cell><cell>38</cell><cell>0.742</cell><cell>0.733</cell><cell>0.93</cell></row><row><cell>SM 6</cell><cell>47</cell><cell>0.737</cell><cell>0.704</cell><cell>0.953</cell></row><row><cell>SM 7</cell><cell>78</cell><cell>0.743</cell><cell>0.79</cell><cell>0.942</cell></row><row><cell>SM 8</cell><cell>34</cell><cell>0.845</cell><cell>0.813</cell><cell>0.975</cell></row><row><cell>SM 9</cell><cell>92</cell><cell>0.648</cell><cell>0.667</cell><cell>0.931</cell></row><row><cell>SM 10</cell><cell>28</cell><cell>0.846</cell><cell>0.873</cell><cell>0.983</cell></row><row><cell>SM 11</cell><cell>59</cell><cell>0.796</cell><cell>0.73</cell><cell>0.92</cell></row><row><cell>SM 12</cell><cell>63</cell><cell>0.772</cell><cell>0.72</cell><cell>0.964</cell></row><row><cell>Average</cell><cell>58</cell><cell>0.742</cell><cell>0.734</cell><cell>0.948</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>For ease of traceability, the blocks are sequentially numbered, starting from the first transformation example in the example base. For instance, the nine blocks of example TE1 are labeled B 1 to B 9 . The 13 blocks of TE2 B 10 to B</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_1"><p>, and so on. When a solution is produced, it is relatively easy to determine which examples contributed to it.123</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Author Biographies</head><p>Marouane <ref type="bibr">Kessentini</ref>  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Model-driven development of complex software: a research roadmap</title>
		<author>
			<persName><forename type="first">R</forename><surname>France</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rumpe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE 2007): Future of Software Engineering</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Briand</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Wolf</surname></persName>
		</editor>
		<meeting><address><addrLine>Los Alamitos</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Soceity Press</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">MOF Query/Views/ Transformations, Revised Submission</title>
		<idno>OMG Document: ad/ 03-08-11, ad/03-08-12, ad/03-08-13</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>Interactive Objects and Project Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<idno>ptc/05-11-01</idno>
		<ptr target="http://www.omg.org/docs/ptc/05-11-01.pdf" />
		<title level="m">Meta Object Facility (MOF) 2.0 Query/View/Transformation Specification Final Adopted Specification</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Query/Views/Transformations RFP, Revised submission, version 1.0. OMG Document</title>
		<author>
			<persName><forename type="first">Qvt-Merge</forename><surname>Group</surname></persName>
		</author>
		<idno>ad/2004-04-01</idno>
		<ptr target="http://www.omg.org/cgi-bin/doc?ad/2004-04-01" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Meta Object Facility (MOF). Version 1</title>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<ptr target=".4.www.omg.org/technology/documents/formal/mof.htm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">AGG: a graph transformation environment for system modeling and validation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Tool Exihibition at Formal Methods</title>
		<meeting>Tool Exihibition at Formal Methods<address><addrLine>Pisa, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Generic and meta-transformations for model transformation engineering</title>
		<author>
			<persName><forename type="first">D</forename><surname>Varro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pataricza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UML 2004</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Baar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Strohmeier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Moreira</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Mellor</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3273</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<orgName type="collaboration">ATLAS Group</orgName>
		</author>
		<ptr target="http://www.eclipse.org/gmt" />
		<title level="m">The ATLAS Transformation Language</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Transforming models with ATL</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kurter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Of the Model Transformations in Practice Workshop at MoDELS 2005</title>
		<meeting>Of the Model Transformations in Practice Workshop at MoDELS 2005<address><addrLine>Jamaica</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Query/Views/Transformations RFP, Revised Submission</title>
		<author>
			<persName><forename type="first">Sun</forename><surname>Compuware</surname></persName>
		</author>
		<idno>OMG Document ad/2003-08-07</idno>
		<ptr target="http://www.omg.org/cgi-bin/doc?ad/2003-08-07" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Object Modeling with the OCL, The Rationale behind the Object Constraint Language</title>
		<author>
			<persName><forename type="first">T</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Recent developments of the ZEUS expert system ZEX</title>
		<author>
			<persName><forename type="first">U</forename><surname>Behrens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Flasinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hagge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jurek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ohrenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Nucl. Sci</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="65" to="68" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Model transformation by example</title>
		<author>
			<persName><forename type="first">D</forename><surname>Varro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MOD-ELS 2006</title>
		<meeting>MOD-ELS 2006<address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4199</biblScope>
			<biblScope unit="page" from="410" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Automated abstraction of class diagrams</title>
		<author>
			<persName><forename type="first">A</forename><surname>Egyed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="449" to="491" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Automating model transformation by example using inductive logic programming</title>
		<author>
			<persName><forename type="first">D</forename><surname>Varro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Balogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Symposium on Applied Computing | Model Transformation Track</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Model transformation as an optimization problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kessentini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sahraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Boukadoum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of MOD-ELS 2008</title>
		<meeting>MOD-ELS 2008<address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5301</biblScope>
			<biblScope unit="page" from="159" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Particle swarm optimization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Eberhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Neural Networks</title>
		<meeting>IEEE International Conference on Neural Networks</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="1942" to="1948" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Optimization by simulated annealing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kirkpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Gelatt</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">.</forename><surname>Vecchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sciences</title>
		<imprint>
			<biblScope unit="volume">220</biblScope>
			<biblScope unit="issue">4598</biblScope>
			<biblScope unit="page" from="671" to="680" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Case-based reasoning: foundational issues, methodological variations, and system approaches</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aamodt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Plaza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell. Commun</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="52" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Example-based sequence diagrams to colored petri nets transformation using heuristic Search</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kessentini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bouchoucha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sahraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Boukadoum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 6th European Conference on Modeling Foundations and Applications (ECMFA 2010)</title>
		<meeting>6th European Conference on Modeling Foundations and Applications (ECMFA 2010)<address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Decision reuse in an interactive model transformation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Siikarla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Syst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th European Conference on Software Maintenance and Reengineering</title>
		<meeting><address><addrLine>Athens, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-04-01">2008. April 1-4, 2008. 2008</date>
			<biblScope unit="page" from="123" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Particle swarm optimization: developments, applications and resources</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Eberhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Congress on Evolutionary Computation</title>
		<meeting>IEEE Congress on Evolutionary Computation</meeting>
		<imprint>
			<publisher>CEC</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="81" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Convergence and finite-time behaviour of simulated annealing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Romeo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1985 Decision and Control Control</title>
		<meeting>1985 Decision and Control Control</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Stochastic relaxation, Gibbs distributions, and the Bayesian restoration of images</title>
		<author>
			<persName><forename type="first">S</forename><surname>Geman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Geman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="721" to="741" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Particle swarm optimization for task assignment problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Salman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Imtiaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Al-Madani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IASTED International Conference on Artificial Intelligence and Applications</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Applying particle swarm optimization to software testing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Windisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wappler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wegener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual Conference on Genetic and Evolutionary Computation</title>
		<meeting>the 9th Annual Conference on Genetic and Evolutionary Computation<address><addrLine>London, England; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007-07">July 2007. 2007</date>
			<biblScope unit="page" from="1121" to="1128" />
		</imprint>
	</monogr>
	<note>GECCO &apos;07</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Velocity-aligned discrete oriented polytopes for dynamic collision detection</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Coming</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">G</forename><surname>Staadt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Visual. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Classification of model transformation approaches</title>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Helsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOSPLA&apos;03 Workshop on Generative Techniques in the Context of Model-Driven Architecture</title>
		<meeting><address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A taxonomy of model transformation</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Gorp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Workshop on Graph and Model Transformation</title>
		<meeting>International Workshop on Graph and Model Transformation</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Graph Transformation for Specification and Programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Habel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuske</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kuske</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plump</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<ptr target="http://citeseer.nj.nec.com/article/andries96graph.html" />
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Universität Bremen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A Relational approach to defining transformations in a metamodel</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Akehurst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UML 2002-The Unified Modeling Language 5th International Conference</title>
		<editor>
			<persName><forename type="first">J.-M</forename><surname>Jézéquel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Hussmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Cook</surname></persName>
		</editor>
		<meeting><address><addrLine>Dresden, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-10-04">September 30-October 4, 2002. 2002</date>
			<biblScope unit="volume">2460</biblScope>
			<biblScope unit="page" from="243" to="258" />
		</imprint>
	</monogr>
	<note>. Proceedings, LNCS</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">MOF 2.0 Query/Views/Transformations RFP, Revised Submission</title>
		<idno>OMG Document ad/2003-08-11</idno>
		<ptr target="http://www.omg.org/cgi-bin/doc?ad/2003-08-11" />
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Interactive Objects Software GmbH, Project Technology, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Heterogeneous views integration and its automation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Egyed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
		<respStmt>
			<orgName>University of Southern California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Model transformation by graph transformation: a comparative study</title>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ehrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Guerra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Lara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lengyel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Levendovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Prange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Varro-Gyapay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Model Transformations in Practice</title>
		<imprint>
			<date type="published" when="2005-09">September (2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Graph matching: theoretical foundations, algorithms, and applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Bunke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Vision Interface</title>
		<meeting>the Vision Interface</meeting>
		<imprint>
			<publisher>Montreal/Canada</publisher>
			<date type="published" when="2000">2000. 2000</date>
			<biblScope unit="page" from="82" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Comparing two model transformation approaches</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Küster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sendall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wahler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings UML 2004 Workshop OCL and Model Driven Engineering</title>
		<meeting>UML 2004 Workshop OCL and Model Driven Engineering<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-10-12">October 12 (2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Confluence of typed attributed graph transformation systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Kuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICGT&apos;02</title>
		<title level="s">LNCS 2505</title>
		<meeting>ICGT&apos;02<address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="161" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Applying a model transformation taxonomy to graph tansformation technology</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Gorp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graph and Model Transformation Workshop</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</editor>
		<meeting>Graph and Model Transformation Workshop</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>to appear in ENTCS</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Applying a model transformation taxonomy to graph transformation technology</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Van Gorp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graph and Model Transformation Workshop</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Karsai</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</editor>
		<meeting>Graph and Model Transformation Workshop</meeting>
		<imprint>
			<publisher>ENTCS</publisher>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program transformation with stratego/XT: rules, strategies, tools, and systems in StrategoXT-0.9</title>
		<title level="s">of Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Lengauer</surname></persName>
		</editor>
		<imprint>
			<publisher>Spinger, Heidelberg</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3016</biblScope>
			<biblScope unit="page" from="216" to="238" />
		</imprint>
	</monogr>
	<note>Domain-Specific Program Generation</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Traceability as input for model transformations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Vanhoof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Van Baelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Joosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Berbers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Traceability Workshop, European Conference in Model Driven Architecture</title>
		<meeting>Traceability Workshop, European Conference in Model Driven Architecture</meeting>
		<imprint>
			<publisher>EC-MDA</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Feature-based survey of model transformation approaches</title>
		<author>
			<persName><forename type="first">K</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Helsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Syst. J. (Special Issue on Model-Driven Softw. Dev</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="621" to="645" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Towards model transformation generation by-example</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Strommer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kargl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kramler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HICSS-40 Hawaii International Conference on System Sciences</title>
		<meeting>HICSS-40 Hawaii International Conference on System Sciences<address><addrLine>Hawaii, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Model Transformation by Demonstration</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m">MoDELS09</title>
		<meeting><address><addrLine>Denver, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-10">October 2009</date>
			<biblScope unit="page" from="712" to="726" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Model transformation by-example: an algorithm for generating many-to-many transformation rules in several model transformation languages</title>
		<author>
			<persName><forename type="first">I</forename><surname>Garcia-Magarino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Gomez-Sanz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fuentes-Fernandez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Theory and Practice of Model Transformations (ICMT&apos;09)</title>
		<meeting>the 2nd International Conference on Theory and Practice of Model Transformations (ICMT&apos;09)<address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5563</biblScope>
			<biblScope unit="page" from="52" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Towards the efficient development of model transformations using model weaving and matching transformations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Fabro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Syst. Model</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="305" to="324" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Loosely coupled traceability for atl</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Model Driven Architecture (ECMDA) Workshop on Traceability</title>
		<meeting>the European Conference on Model Driven Architecture (ECMDA) Workshop on Traceability</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Survey of Traceability Approaches in Model-Driven Engineering</title>
		<author>
			<persName><forename type="first">I</forename><surname>Galvão</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Goknil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDOC&apos;07</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="313" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Clémentine Nebut Meta-model Matching for Automatic Model Transformation Generation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Falleri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lafourcade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE 11th International Conference on Model Driven Engineering Languages and Systems</title>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A Transformation Composition Framework for Model Driven Engineering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Marvie</surname></persName>
		</author>
		<idno>LIFL-2004-10</idno>
	</analytic>
	<monogr>
		<title level="j">LIFL</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A metamodel based model transformation approach</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Duancheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACIS International Conference on Software Engineering Research, Management and Applications</title>
		<meeting>ACIS International Conference on Software Engineering Research, Management and Applications</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="184" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Incremental model synchronization with triple graph grammars</title>
		<author>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Models &apos;06: Proceedings of the 9th International Conference on Model Driven Engineering Languages and Systems</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Whittle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Reggio</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4199</biblScope>
			<biblScope unit="page" from="543" to="557" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Towards a traceability framework for model transformations in kermeta</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Falleri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Nebut</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>HAL-CCSd-CNRS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Incremental model transformation for the evolution of model-driven systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hearnden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lawley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Raymond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Driven Engineering Languages and Systems, 9th International Conference, MoD-ELS 2006</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Nierstrasz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Whittle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Reggio</surname></persName>
		</editor>
		<meeting><address><addrLine>Genova, Italy; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">October 1-6, 2006. 2006</date>
			<biblScope unit="volume">4199</biblScope>
			<biblScope unit="page" from="321" to="335" />
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Query-by-example: operations on piecewise continuous data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Morgan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 9th international conference on very large data bases</title>
		<meeting>9th international conference on very large data bases<address><addrLine>Florence, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983-11-02">October 31-November 2. 1983</date>
			<biblScope unit="page" from="305" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Defining web schema transformers by example</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lechner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schrefl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of DEXA&apos;03</title>
		<meeting>DEXA&apos;03<address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Watch What I Do: Programming by Demonstration</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cypher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Programming by example: programming by analogous examples</title>
		<author>
			<persName><forename type="first">A</forename><surname>Repenning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Perrone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="90" to="97" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Search-based software engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">F</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="833" to="839" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Pareto optimal search based refactoring at the design level</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO&apos;07: Proceedings of the 9th Annual Conference on Genetic and Evolutionary Computation</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1106" to="1113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">The current state and future of search based software engineering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Software Engineering (ICSE 2007)</title>
		<meeting>the 29th International Conference on Software Engineering (ICSE 2007)<address><addrLine>Minneapolis, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05">May. 2007</date>
			<biblScope unit="page" from="20" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">A UML/SPT model analysis methodology for concurrent systems based on genetic algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shousha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Briand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Labiche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Model Driven Engineering Languages and Systems MODELS08</title>
		<meeting>the 11th International Conference on Model Driven Engineering Languages and Systems MODELS08</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="475" to="489" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Simulated annealing for improving software quality prediction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bouktif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sahraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO2006: Proceedings of the 8th Annual Conference on Genetic and Evolutionary Computation</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1893" to="1900" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">MDA Explained. The Model Driven Architecture: Practice and Promise</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kleppe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bast</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>Reading</note>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Search-based determination of refactorings for improving the class structure of object-oriented systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Seng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stammel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Burkhart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;06: Proceedings of the 8th Annual Conference on Genetic and Evolutionary Computation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1909" to="1916" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
