<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Combining Events And Threads For Scalable Network Services Implementation And Evaluation Of Monadic, Application-level Concurrency Primitives</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Peng</forename><surname>Li</surname></persName>
							<email>lipeng@cis.upenn.edu</email>
						</author>
						<author>
							<persName><forename type="first">Steve</forename><surname>Zdancewic</surname></persName>
							<email>stevez@cis.upenn.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<addrLine>PLDI&apos;07 June 11-13</addrLine>
									<postCode>2007</postCode>
									<settlement>San Diego</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Combining Events And Threads For Scalable Network Services Implementation And Evaluation Of Monadic, Application-level Concurrency Primitives</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D277FB0427AFF2635FF546FDBBD316E1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1.1 [Programming techniques]: Applicative (Functional) Programming</term>
					<term>D.1.3 [Programming techniques]: Concurrent Programming</term>
					<term>D.2.11 [Software Engineering]: Software Architectures-Domain-specific architectures</term>
					<term>D.3.3 [Programming Languages]: Language Constructs and Features-Concurrent programming structures, Control structures, Frameworks</term>
					<term>D.4.1 [Operating Systems]: Process Management-Concurrency, Multiprocessing / multiprogramming / multitasking, Scheduling, Threads. General Terms Languages, Design, Experimentation, Performance, Measurement Event, Thread, Concurrency, Networking, Programming, Scalability, Implementation, Monad, Haskell</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper proposes to combine two seemingly opposed programming models for building massively concurrent network services: the event-driven model and the multithreaded model. The result is a hybrid design that offers the best of both worlds-the ease of use and expressiveness of threads and the flexibility and performance of events.</p><p>This paper shows how the hybrid model can be implemented entirely at the application level using concurrency monads in Haskell, which provides type-safe abstractions for both events and threads. This approach simplifies the development of massively concurrent software in a way that scales to real-world network services. The Haskell implementation supports exceptions, symmetrical multiprocessing, software transactional memory, asynchronous I/O mechanisms and application-level network protocol stacks. Experimental results demonstrate that this monad-based approach has good performance: the threads are extremely lightweight (scaling to ten million threads), and the I/O performance compares favorably to that of Linux NPTL.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Modern network services present software engineers with a number of design challenges. Peer-to-peer systems, multiplayer games, Events vs. threads: Two implementation strategies for building such inherently concurrent systems have been successful. Both the multithreaded and event-driven approaches have their proponents and detractors. The debate over which model is "better" has waged for many years, with little resolution. Ousterhout <ref type="bibr" target="#b18">[19]</ref> has argued that "threads are a bad idea (for most purposes)," citing the difficulties of ensuring proper synchronization and debugging with threadbased approaches. A counter argument, by von Behren, Condit, and Brewer <ref type="bibr" target="#b24">[25]</ref>, argues that "events are a bad idea (for highconcurrency servers)," essentially because reasoning about control flow in event-based systems is difficult and the apparent performance wins of the event-driven approach can be completely recouped by careful engineering <ref type="bibr" target="#b25">[26]</ref>.</p><p>The debate over threads and events never seems to end because a programmer often has to choose one model and give up the other. For example, if a Linux C programmer uses POSIX threads to write a web server, it is difficult to use asynchronous I/O. On the other hand, if the programmer uses epoll and AIO in Linux to write a web server, it will be inconvenient to represent control flow for each client. The reason for this situation is that conventional thread abstraction mechanisms are too rigid: threads are implemented in the OS and runtime libraries and the user cannot easily customize these components and integrate them with the application. Although threads can be made lightweight and efficient, an event-driven system still has the advantage on flexibility and customizability: it can always be tailored and optimized to the application's specific needs.</p><p>The hybrid model: Ideally, the programmer would design parts of the application using threads, where threads are the appropriate abstraction (for per-client code), and parts of the system using events, where they are more suitable (for asynchronous I/O interfaces). To make this hybrid model feasible, not only should the system provide threads, but the thread scheduler interface must also provide a certain level of abstraction, in the form of event handlers, which hides the implementation details of threads and can be used by the programmer to construct a modular event-driven system.</p><p>Many existing systems implement the hybrid model to various degrees; most of them have a bias either toward threads or toward events. For example, Capriccio <ref type="bibr" target="#b25">[26]</ref> is a user-level, cooperative thread library with a thread scheduler that looks very much like an event-driven application. However, it provides no abstraction on the event-driven side: the scheduler uses a low-level, unsafe programming interface that is completely hidden from the programmer.</p><p>On the other hand, many event-driven systems uses continuationpassing style (CPS) programming to represent the control flow for each client; the problem is that CPS programs are often difficult to write and understand. Although CPS is a scalable design, it is not as intuitive as conventional multithreaded programming styles (for most programmers). Application-level implementation: The hybrid model adopted here encourages both the multithreaded components and the eventdriven components of the application be developed in a uniform programming environment. To do so, it is most convenient to implement the concurrency abstractions (both thread abstractions and event abstractions) entirely inside the application, using standard programming language idioms. We call this idea application-level implementation.</p><p>Programming concurrency abstractions entirely inside the application is a significant challenge on legacy programming language tools: for languages like C, implementing user-level threads and schedulers involves a lot of low-level, unsafe programming interfaces. Nevertheless, it is indeed feasible to implement the hybrid model directly at application-level using modern functional programming languages such as Haskell. In 1999, Koen Claessen <ref type="bibr" target="#b7">[8]</ref> showed that (cooperative) threads can be implemented using only a monad, without any change to the programming language itself. A hybrid framework for network services:</p><p>This paper uses Claessen's technique to implement the hybrid model entirely inside the application and develop a framework for building massively concurrent network services. Our implementation is based on Concurrent Haskell <ref type="bibr" target="#b13">[14]</ref>, supported by the latest version of GHC <ref type="bibr" target="#b10">[11]</ref>. Improving on Claessen's original, proof-of-concept design, our implementation offers the following:</p><p>• True Parallelism: Application-level threads are mapped to multiple OS threads and take advantage of SMP systems.</p><p>• Modularity and Flexibility: The scheduler is a customizable event-driven system that uses high-performance, asynchronous I/O mechanisms. We implemented support for Linux epoll and AIO; we even plugged a TCP stack to our system. • Exceptions: Multithreaded code can use exceptions to handle failure, which is common in network programming. • Thread synchronization: Non-blocking synchronization comes almost for free-software transactional memory (STM) in GHC can be transparently used in application-level threads. We also implemented blocking synchronization mechanisms such as mutexes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation:</head><p>Our hybrid concurrency framework in Haskell competes favorably against most existing thread-based or eventbased systems for building network services. It provides elegant interfaces for both multithreaded and event-driven programming, and it is all type-safe! Experiments suggest that, although everything is written in Haskell, a pure, lazy, functional programming language, the performance is acceptable in practice:</p><p>• I/O performance: Our implementation delivers performance comparable to Linux NPTL in disk and FIFO pipe performance tests, even when tens of thousands of threads are used.</p><p>• Scalability: Besides bounds on memory size and other system resources, there is no limit on the number of concurrent clients that our implementation can handle. In the I/O tests, our implementation scaled to far more threads than Linux NPTL did.</p><p>From the OS point of view, it is just as scalable as an eventdriven system. • Memory utilization: Our implementation has extremely efficient memory utilization. All the thread-local state is explicitly controlled by the programmer. As we have tested, each monadic thread consumes as little as 48 bytes at run time, and our system is capable of running 10,000,000 such threads on a real machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of contributions:</head><p>The idea of the concurrency monad is not new at all-we are building on work done by functional programming researchers. Our contribution is to experiment with this elegant design in real-world systems programming and evaluate this technique, both qualitatively and quantitatively:</p><p>1. We scaled up the design of the concurrency monad to a realworld implementation, providing elegant and flexible interfaces for building massively concurrent network services using efficient asynchronous I/O.</p><p>2. We proved that the monad-based design has good performance: it delivers optimal I/O performance; it has efficient memory utilization and it scales as well as event-driven systems.</p><p>3. We demonstrated the feasibility of the hybrid programming model in high-performance network servers, providing future directions for both systems and programming language research.</p><p>Our experience also suggests that Haskell is a reasonable language for building scalable systems software: it is expressive, succinct, efficient and type-safe; it interacts well with C libraries and APIs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The hybrid programming model</head><p>This section gives some background on the multithreaded and event-driven approaches for building massively concurrent network services, and motivates the design of the hybrid model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A comparison of events vs. threads</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Programming:</head><p>The primary advantage of the multithreaded model is that the programmer can reason about the series of actions taken by a thread in the familiar way, just as for a sequential program. This approach leads to a natural programming style in which the control flow for a single thread is made apparent by the program text, using ordinary language constructs like conditional statements, loops, exceptions, and function calls.</p><p>Event-driven programming, in contrast, is hard. Most generalpurpose programming languages do not provide appropriate abstractions for programming with events. The control flow graph of an event-driven program has to be decomposed into multiple event handlers and represented as some form of state machine with explicit message passing or in continuation-passing style (CPS). Both representations are difficult to program with and reason about, as indicated by the name of Python's popular, event-driven networking framework, "Twisted" <ref type="bibr" target="#b23">[24]</ref>. Performance: The multithreaded programming style does not come for free: In most operating systems, a thread uses a reserved segment of stack address space, and the virtual memory space exhausts quickly on 32-bit systems. Thread scheduling and context switching also have significant overheads. However, such performance problems can be reduced by well engineered thread libraries and/or careful use of cooperative multitasking-a recent example in this vein is Capriccio <ref type="bibr" target="#b25">[26]</ref>, a user-level thread library specifically for use in building highly scalable network services.</p><p>The event-driven approach exposes the scheduling of interleaved computations explicitly to the programmer, thereby permitting application-specific optimizations that significantly improve performance. The event handlers typically perform only small amounts of work and usually need only small amounts of local storage. Compared to multithreaded systems, event-driven systems can have the minimal per-thread memory overheads and context switching costs. Furthermore, by grouping similar events together, they can be batch-processed to improve code and data locality <ref type="bibr" target="#b14">[15]</ref>. Flexibility and customizability: Most thread systems provide an abstract yet rigid, synchronous programming interface and the implementation of the scheduler is mostly hidden from the programming interface. Hiding the scheduler makes it inconvenient when the program requires the use of asynchronous I/O interfaces not supported by the thread library, especially those affecting the scheduling behavior. For example, if the I/O multiplexing of a userlevel thread library is implemented using the portable select interface, it is difficult to use an alternative high-performance interface like epoll without modifying the scheduler.</p><p>Event-driven systems are more flexible and customizable because the programmer has direct control of resource management and direct access to asynchronous OS interfaces. Many highperformance I/O interfaces (such as AIO, epoll and kernel event queues) provided by popular OSes are asynchronous or eventdriven, because this programming model corresponds more closely to the model of hardware interrupts. An event-driven system can directly take advantage of such asynchronous, non-blocking interfaces, while using thread pools to perform synchronous, blocking operations at the same time.</p><p>Another concern is that most user-level cooperative thread systems do not take advantages of multiple processors, and adding such support is often difficult <ref type="bibr" target="#b25">[26]</ref>. Event-driven systems can easily utilize multiple processors by processing independent events concurrently <ref type="bibr" target="#b28">[29]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The hybrid programming model</head><p>In 1978, Lauer and Needham <ref type="bibr" target="#b15">[16]</ref> argued that the multithreaded and event-driven models are dual to each other. They described an one-to-one mapping between the constructs of each paradigm and suggest that the two approaches should be equivalent in the sense that either model can be made as efficient as the other. The duality they presented looks like this: Threads Events thread continuation ∼ event handler scheduler ∼ event loop exported function ∼ event blocking call ∼ send event / await reply The Lauer-Needham duality suggests that despite their large conceptual differences and the way people think about programming in them, the multithreaded and event-driven models are really the "same" underneath. Most existing approaches trade off threads for events or vice versa, choosing one model over the other. The current situation is shown in Figure <ref type="figure" target="#fig_0">1</ref>: multithreaded systems are difficult to customize, and event-driven systems have poor programming abstractions.</p><p>We adopt a different route: rather than using the duality to justify choosing threads over events or vice versa (since either choice can be made as efficient and scalable as the other), we see the duality as a strong indication that the programmer should be able to use both models of concurrency in the same system. The duality thus suggests that we should look for natural ways to support switching between the views as appropriate to the task at hand.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> presents the hybrid model that can be seen either as a multithreaded system with a programmable scheduler, or as an event-driven system with a thread abstraction for representing control flow. The key is to implement both thread abstractions that represent control flow, and event abstractions that provide scheduling primitives. These abstractions provide control inversion between the two worlds: the threads play the active role and make blocking calls into the I/O system, but the underlying event-driven system also plays the active role and schedules the execution of threads as if calling event handlers. The hybrid model gives the best of two worlds: the expressiveness of threads and the customizability of events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Application-level implementation</head><p>Implementing the hybrid model is challenging. Conventional thread abstractions are provided outside the application by means of OS/VM/compiler/library support. The scheduler code may live in a different address space, be written in a different language, use very low-level programming interfaces, be linked to different libraries, and be compiled separately from the multithreaded code. Such differences in the programming environments makes it inconvenient to combine the threads and the scheduler in the same application. Thus, a challenge is how to develop both components of the hybrid model (the boxes on the top and bottom of Figure <ref type="figure" target="#fig_1">2</ref>) in the same programming environment, by which we mean:</p><p>• they are written in the same programming language;</p><p>• they can share the same software libraries;</p><p>• they live in the same address space;</p><p>• they can easily communicate using shared data structures;</p><p>• their source codes are compiled and optimized together to produce a single executable file.</p><p>This problem can be solved if the thread/event abstractions (the center box of Figure <ref type="figure" target="#fig_1">2</ref>) are also developed in the same programming environment, entirely inside the application as program modules. We refer to this approach as application-level implementation. A good approximation of this idea is event-driven systems with continuation-passing-style (CPS) event handlers <ref type="bibr" target="#b23">[24]</ref>. In many languages, CPS can be implemented entirely inside the application, using standard programming idioms such as function closures or objects. Furthermore, the CPS approach also solves the problem of control inversion: CPS represents multithreaded computation, but such computation can be manipulated as values and called as event handlers. The only caveat is that CPS is not as intuitive and easy to understand as C-like, imperative threads-not every programmer can think in CPS!</p><p>The next section shows that, with a little more support from programming languages, good abstractions can be provided to hide the details of CPS from the programmer, and the result is an elegant implementation of the hybrid model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Implementing the hybrid model in Haskell</head><p>The CPS programming technique provides a great foundation for application-level implementation of the hybrid model: CPS has expressive control flow, and CPS can be readily represented in many programming languages. The challenge is to build the thread abstraction and hide the details of continuation passing.</p><p>The simplest idea is to perform a source-to-source CPS translation <ref type="bibr" target="#b2">[3]</ref> in the compiler. This approach is not entirely applicationlevel because it requires nonstandard compiler extensions. Furthermore, because we want the multithreaded code to have the same programming environment as the scheduler code, the compiler has to translate the same language to itself. Such translations are often verbose, inefficient and not type-safe.</p><p>Can we achieve the same goal without writing compiler extensions? One solution, developed in the functional programming community and supported in Haskell, is to use monads <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b26">27]</ref>. The Haskell libraries provide a Monad interface that allows generic programming with functional combinators. The solution we adopt here is to design the thread control primitives (such as fork) as monadic combinators, and use them as a domain-specific language directly embedded in the program. Such primitives hide the "internal plumbing" of CPS in their implementation and gives an abstraction for multithreaded programming.</p><p>In principle, this monad-based approach can be used in any language that supports the functional programming style. However, programming in the monadic style is often not easy, because it requires frequent use of binding operators and anonymous functions, making the program look quite verbose. Haskell has two features that significantly simplify this programming style:</p><p>• Operator Overloading: Using type classes, the standard monad operators can be made generic, because the overloading of such operators can be resolved by static typing. • Syntactic Sugar: Haskell has a special do-syntax for programming with monads. Using this syntax, the programmer can write monadic code in a C-like imperative programming style, and the compiler automatically translates this syntax to generic monadic operators and anonymous functions.</p><p>In 1999, Koen Claessen showed that cooperative multithreading can be represented using a monad <ref type="bibr" target="#b7">[8]</ref>. His design extends to an elegant, application-level implementation technique for the hybrid model, where the monad interface provides the thread abstraction and a lazy data structure provides the event abstraction. This section revisits this design, and the next section shows how to use this technique to multiplex I/O in network server applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Traces and system calls</head><p>In this paper, we use the phrase "system calls" to refer to the following thread operations at run time:</p><p>• Thread control primitives, such as fork and yield.</p><p>• I/O operations and other effectful IO computations in Haskell.</p><p>A central concept of Claessen's implementation is the trace, a structure describing the sequence of system calls made by a thread.</p><p>A trace may have branches because the corresponding thread can use fork to spawn new threads. For example, executing the (recursive) server function shown on the left in Figure <ref type="figure" target="#fig_2">4</ref>  A run-time representation of a trace can be defined as a tree using algebraic data types in Haskell. The definition of the trace is essentially a list of system calls, as shown in Figure <ref type="figure" target="#fig_3">5</ref>. Each system call in the multithreaded programming interface corresponds to exactly one type of tree node. For example, the SYS FORK node has two sub-traces, one for the continuation of the parent thread and one for the continuation of the child. Note that Haskell's type system distinguishes code that may perform side effects as shown in the type of a SYS NBIO node, which contains an IO computation that returns a trace. § ¤ </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lazy evaluation of traces and thread control:</head><p>We can think of a trace as the output of a thread execution: as the thread runs and makes system calls, the nodes in the trace are generated. What makes the trace interesting is that computation is lazy in Haskell: a computation is not performed until its result is used. Using lazy evaluation, the consumer of a trace can control the execution of its producer, which is the thread: whenever a node in the trace is examined (or, forced to be evaluated), the thread runs to the system call that generate the corresponding node, and the execution of that thread is suspended until the next node in the trace is examined. In other words, the execution of threads can be controlled by traversing their traces. Figure <ref type="figure" target="#fig_4">3</ref> shows how traces are used to control the thread execution. It shows a run-time snapshot of the system: the scheduler decides to resume the execution of a thread, which is blocked on a system call sys epoll wait in the sock send function. The following happens in a sequence:</p><p>1. The scheduler forces the current node in the trace to be evaluated, by using the case expression to examine its value. 2. Because of lazy evaluation, the current node of the trace is not known yet, so the continuation of the thread is called in order to compute the value of the node.</p><p>3. The thread continuation runs to the point where the next system call sys nbio is performed.</p><p>4. The new node in the trace is generated, pointing to the new continuation of the thread.</p><p>5. The value of the new node, SYS NBIO is available in the scheduler. The scheduler then handles the system call by performing the I/O operation and runs the thread continuation, from Step 1 again.</p><p>The lazy trace gives the event abstraction we need. It is an abstract interface that allows the scheduler to play the "active" role and the threads to play the "passive" role: the scheduler can use traces to actively "push" the thread continuations to execute. Each node in the trace essentially represents part of the thread execution.</p><p>The remaining problem is to find a mechanism that transforms multithreaded code into traces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The CPS monad</head><p>A monad can provide the thread abstraction we need. System calls can be implemented as monad operations, and the do-syntax of Haskell offers an imperative programming style. The implementation of this monad is quite tricky, but the details are hidden from the programmer (in the box between the thread abstraction and the event abstraction in Figure <ref type="figure" target="#fig_1">2</ref>).</p><p>Haskell's monad typeclass, shown in Figure <ref type="figure" target="#fig_5">6</ref>, requires a monad implemented using a parameterized abstract datatype m to support two key operations. The first operation, return, takes a value of type a and "lifts" it into the monad. The second infix operation, (&gt;&gt;=) <ref type="bibr">(</ref> The monad we need encapsulates the side effects of a multithreaded computation, that is, generating a trace. The tricky part is that if we simply represent a computation with a data type that carries its result value and its trace, such a data type cannot be used as a monad, because the monads require that computations be sequen-tially composable. Given two complete (possibly infinite) traces, there is no meaningful way to compose them sequentially.</p><p>The solution is to represent computations in continuationpassing style (CPS), where the final result of the computation is the trace. A computation of type a is thus represented as a function of type (a-&gt;Trace)-&gt;Trace that expects a continuation, itself a function of type (a-&gt;Trace), and produces a Trace. This representation can be used to construct a monad M. The standard monadic operations (return and sequential composition) for this monad are defined in Figure <ref type="figure" target="#fig_6">7</ref> Intuitively, return takes a value x of type a and, when given a continuation c, simply invokes the continuation c on x. The implementation of (&gt;&gt;=) threads the continuations through the operations to provide sequential composition: given the "final" continuation c, (M g) &gt;&gt;= f first calls g, giving it a continuation (the expression beginning (\a -&gt; ...) that expects the result a computed by g. This result is then passed to f, the results of which are encapsulated in the closure h. Finally, since the final continuation of the whole sequential composition is c, that continuation is passed to h. Altogether, we can think of this as (roughly) doing g;f;c.</p><p>Given a computation M a in the above CPS monad, we can access its trace by adding a "final continuation" to it, that is, adding a leaf node SYS RET to the trace. The function build trace in Figure <ref type="figure" target="#fig_7">8</ref>  In Figure <ref type="figure" target="#fig_8">9</ref>, each system call is implemented as a monadic operation that creates a new node in the trace. The arguments of system calls are filled in to corresponding fields in the trace node. Since the code is internally organized in CPS, we are able to fill the trace pointers (fields of type "Trace") with the continuation of the current computation (bound to the variable c in the code).</p><p>For readers unfamiliar with monads in Haskell, it may be difficult to follow the above code. Fortunately, these bits of code encapsulate all of the "twisted" parts of the internal plumbing in the CPS. The implementation of the monad can be put in a library, and the programmer only needs to understand its interface. To write multithreaded code, the programmer simply uses the do-syntax and the system calls; to access the trace of a thread in the event loop, one just applies the function build trace to it to get the lazy trace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Building network services</head><p>With the concurrency primitives introduced in the previous section, we can combine events and threads to build scalable network services in an elegant way: the code for each client is written in a "cheap", monad-based thread, while the entire application is an event-driven program that uses asynchronous I/O mechanisms. Our current implementation uses the Glasgow Haskell Compiler (GHC) <ref type="bibr" target="#b10">[11]</ref>. It is worth noting that GHC already supports efficient, lightweight user-level threads, but we do not use one GHC thread for each client directly, because the default GHC library uses the portable (yet less scalable) select interface to multiplex I/O and it does not support non-blocking disk I/O. Instead, we employ only a few GHC threads, each mapped to an OS thread in the GHC runtime system. In the rest of the paper, we use the name monadic thread for the application-level, "cheap" threads written in the dosyntax, and we do not distinguish GHC threads from OS threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Programming with monadic threads</head><p>In the do-syntax, the programmer can write code for each client session in the familiar, multithreaded programming style, just like in C or Java. All the I/O and effectful operations are performed through system calls. For example, the sys nbio system call takes a non-blocking Haskell IO computation as its argument. The sys epoll wait system call has a blocking semantics: it waits until the supplied event happens on the file descriptor.</p><p>The multithreaded programming style makes it easy to hide the non-blocking I/O semantics and provide higher level abstractions by encapsulating low-level operations in functions. For example, a blocking sock accept can be implemented using nonblocking accept as shown in Figure <ref type="figure" target="#fig_0">10</ref>: it tries to accept a connection by calling the non-blocking accept function. If it succeeds, the accepted connection is returned, otherwise it waits for an EPOLL READ event on the server socket, indicating that more connections can be accepted. § ¤  <ref type="bibr">Figure 11</ref> shows code that implements a naive round-robin scheduler; it uses a task queue called ready queue and an event loop called worker main. The scheduler does the following in each loop: (1) fetch a trace from the queue, (2) force the corresponding monadic thread to execute (using case) until a system call is made, (3) perform the requested system call, and (4) write the child nodes (the continuations) of the trace to the queue.</p><p>In our actual scheduler implementation, more system calls are supported. Also, a thread is executed for a large number of steps before switching to another thread to improve locality. § ¤ </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Exceptions</head><p>Exceptions are useful especially in network programming, where failures are common. Because the threaded code is internally structured in CPS, exceptions can be directly implemented as system calls (monad operations) shown in Figure <ref type="figure" target="#fig_10">12</ref>. The code in Figure <ref type="figure" target="#fig_4">13</ref> illustrates how exceptions are used by a monadic thread. The scheduler code in Figure <ref type="figure" target="#fig_0">11</ref> needs to be extended to support these system calls. When it sees a SYS CATCH node, it pushes the node onto a stack of exception handlers maintained for each thread. When it sees a SYS RET or SYS THROW node, it pops one frame from the stack and continues with either the normal trace or exception handler, as appropriate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Multiple event loops and SMP support</head><p>Figure <ref type="figure" target="#fig_2">14</ref> shows the event-driven system in our full implementation. It consists of several event loops, each running in a separate OS thread, repeatedly fetching a task from an input queue or waiting for an OS event and then processing the task/event before putting the continuation of the task in the appropriate output queue. The worker main event loops are simply thread schedulers: they execute the monadic threads and generate events that can be consumed by other event loops.</p><p>To take advantage of SMP machines, the system runs multiple worker main event loops in parallel so that multiple monadic threads can make progress simultaneously. This setup is based on the assumption that all the I/O operations submitted by SYS NBIO are nonblocking and thread-safe. Blocking or thread-unsafe I/O operations are handled in this framework either by using a separate queue and event loop to serialize such operations, or by using synchronization primitives (described below) in the monadic thread.</p><p>This event-driven architecture is similar to that in SEDA <ref type="bibr" target="#b27">[28]</ref>, but our events are finer-grained: instead of requiring the programmer manually decompose a computation into stages and specify what stages can be performed in parallel, this event-driven scheduler automatically decomposes a threaded computation into finegrained segments separated by system calls. Haskell's type system ensures that each segment is a purely functional computation without I/O, so such segments can be safely executed in parallel.</p><p>Most user-level thread libraries do not take advantage of multiple processors, primarily because synchronization is difficult due to shared state in their implementations. Our event abstraction makes this task easier, because it uses a strongly typed interface in which pure computations and I/O operations are completely separated. Our current design can be further improved by implementing a sep-arate task queue for each scheduler and using work stealing to balance the loads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Asynchronous I/O in Linux</head><p>Our implementation supports two high-performance, event-driven I/O interfaces in Linux: epoll and AIO. Epoll provides readiness notification of file descriptors; AIO allows disk accesses to proceed in the background. A set of system calls for epoll and AIO are defined in Figure <ref type="figure" target="#fig_3">15</ref> These system calls are interpreted in the scheduler worker main. For each sys epoll wait call, the scheduler uses a library function to register an event with the OS epoll device. The registered event contains a reference to c, the child node that is the continuation of the application thread.</p><p>When the registered event is triggered, such events are harvested by a separate event loop worker epoll shown in Figure <ref type="figure" target="#fig_5">16</ref>. It uses a library function to wait for events and retrieve the traces associated with these events. Then, it put the traces into the ready queue so that their corresponding monadic threads can be resumed.</p><p>Under the hood, the library functions such as epoll wait are just wrappers for their corresponding C library functions implemented through the Haskell Foreign Function Interface (FFI).</p><p>AIO is similarly implemented using a separate event loop. In our system, the programmer can easily add other asynchronous I/O mechanisms in the same way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Supporting blocking I/O</head><p>For some I/O operations, the OS may provide only synchronous, blocking interfaces. Examples are: opening a file, getting the attributes of a file, resolving a network address, etc. If such operations are submitted using the SYS NBIO system call, the scheduler event loops will be blocked.</p><p>The solution is to use a separate OS thread pool for such operations, as shown in Figure <ref type="figure" target="#fig_2">14</ref>. Similar to sys nbio, we define another system call sys blio with a trace node SYS BLIO (where BLIO means blocking IO). Whenever the scheduler sees SYS BLIO, it sends the trace to a queue dedicated for blocking I/O requests. On the other side of the queue, a pool of OS threads are used, each running an event loop that repeatedly fetches and processes the blocking I/O requests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Thread synchronization</head><p>The execution of a monadic thread is interleaved with purely functional computations and effectful computations (submitted through system calls). On SMP machines, the GHC runtime system transparently manages the synchronization of purely functional computations (e.g. concurrent thunk evaluation) in multiple OS threads. For the synchronization of effectful computations, our implementation offers several options.</p><p>For nonblocking synchronization, such as concurrent accesses to shared data structures, the software transactional memory <ref type="bibr" target="#b11">[12]</ref> (STM) provided by GHC can be used directly. Monadic threads can simply use sys nbio to submit STM computations as IO operations. As long as the STM computations are nonblocking (i.e. without retry operations), the scheduler event loops can run them smoothly without being blocked.</p><p>For blocking synchronization, like the producer-consumer model, that affects thread scheduling, we can define our own synchronization primitives as system calls and implement them as scheduler extensions. For example, mutexes can be implemented using a system call sys mutex. A mutex is represented as a memory reference that points to a pair (l,q) where l indicates whether the mutex is locked, and q is a linked list of thread traces blocking on this mutex. Locking a locked mutex adds the trace to the waiting queue inside the mutex; unlocking a mutex with a non-empty waiting queue dispatches the next available trace to the scheduler's ready queue. Other synchronization primitives such as MVars in Concurrent Haskell <ref type="bibr" target="#b13">[14]</ref> can also be similarly implemented.</p><p>Finally, because our system supports the highly-scalable epoll interface in Linux, monadic threads can also communicate efficiently using pipes provided by the OS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">Application-level network stack</head><p>Our implementation includes an optional, application-level TCP stack. The end-to-end design philosophy of TCP suggests that the protocol can be implemented inside the application, but it is often difficult due to the event-driven nature of TCP. In our hybrid programming model, the ability to combine events and threads makes it practical to implement transport protocols like TCP at the application-level in an elegant and type-safe way.</p><p>We implemented a generic TCP stack in Haskell, in which the details of thread scheduling and packet I/O are all made abstract. The TCP implementation is systematically derived from a HOL specification <ref type="bibr" target="#b5">[6]</ref>. Although the development is a manual process, the purely functional programming style makes the translation from the HOL specification to Haskell straightforward.</p><p>We then glued the generic TCP code into our event-driven system in a modular fashion. In Figure <ref type="figure" target="#fig_2">14</ref>, there are two event loops for TCP processing: worker tcp input receives packets from a kernel event queue and process them; worker tcp timer processes TCP timer events. The system call sys tcp implements the user interface of TCP. A library (written in the monadic thread language) hides the sys tcp call and provides the same high-level programming interfaces as standard socket operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head><p>The main goal of our tests was to determine whether the Haskell implementation of the hybrid concurrency model could achieve acceptable performance for massively-concurrent network applications like web servers, peer-to-peer overlays and multiplayer games. Such applications are typically bound by network or disk I/O and often have many idle connections. In addition, we wanted to investigate the memory overheads of using Haskell and the concurrency monad. The concurrency primitives are implemented using higher-order functions and lazy data structures that we were concerned would impose too many levels of indirection and lead to inefficient memory usage. Such programs allocate memory very frequently and garbage collection plays an important role.</p><p>We used a number of benchmarks designed to assess the performance of our Haskell implementation. For I/O benchmarks we tested against comparable C programs using the Native POSIX Thread Library (NPTL), which is an efficient implementation of Linux kernel threads. We chose NPTL because it is readily available in today's Linux distributions, and many user-level thread implementations and event-driven systems also use NPTL as a defacto reference of performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Software setup:</head><p>The experiments used Linux (kernel version 2.6.15) and GHC 6.5, which supports SMP and software transactional memory. The C versions of our benchmarks configured NPTL so that the stack size of each thread is limited to 32KB. This limitation allows NPTL to scale up to 16K threads in our tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Benchmarks</head><p>Memory consumption: <ref type="foot" target="#foot_0">1</ref>In our application-level scheduler, each thread is represented using a trace and an exception stack. The trace is an unevaluated thunk implemented as function closures, and the exception stack is a linked list. All the thread-local state is encapsulated in these memory objects.</p><p>To measure the minimal amount of memory needed to represent such a thread, we wrote a test program that launches ten million threads that just loop calling sys yield. Using the profiling information from the garbage collector, we found that the live set of memory objects is as small as 480MB after major garbage collections-each thread costs only 48 bytes in this test.</p><p>Of course, ten million threads are impractical in a real system. The point of this benchmark is that the representation of a monadic thread is so lightweight it is never a bottleneck of the system. The memory scalability of our system is like most event-driven systems; it is only limited by raw resources such as I/O buffers, file descriptors, sockets and application-specific, per-client states. Disk performance: 2 Our event-driven system uses the Linux asynchronous I/O library, so it benefits from the kernel disk head scheduling algorithm just as the kernel threads and other eventdriven systems do. We ran the benchmark used to assess Capriccio <ref type="bibr" target="#b25">[26]</ref>: each thread randomly reads a 4KB block from a 1GB file opened using O DIRECT without caching. Each test reads a total of 512MB data and the overall throughput is measured, averaged over 5 runs. Figure <ref type="figure" target="#fig_6">17</ref> compares the performance of our thread library with NPTL. This test is disk-bound: the CPU utilization is 1% for both programs when 16K threads are used. Our thread library slightly outperforms NPTL when more than 100 threads are used. The throughput of our thread library remains steady up to 64K threads-it performs just like the ideal event-driven system. FIFO pipe performance-mostly idle threads (IO): Our event-driven scheduler uses the Linux epoll interface for network I/O. To test its scalability, we wrote a multithreaded program to simulate network server applications where most connections are idle. The program uses 128 pairs of active threads to send and receive data over FIFO pipes. In each pair, one thread sends 32KB data to the other thread, receives 32KB data from the other thread and repeats this conversation. The buffer size of each FIFO pipe is 4KB. In addition to these 256 working threads, there are many idle threads in the program waiting for epoll events on idle FIFO pipes.</p><p>Each run transfers a total amount of 64GB data. The average throughput of 5 runs is used. Figure <ref type="figure" target="#fig_7">18</ref> shows the overall FIFO pipe throughput as the number of idle threads changes. This test is bound by CPU and memory performance. Both NPTL and our Haskell threads demonstrated good scalability in this test, but the throughput of Haskell is 30% higher than NPTL.</p><p>In all the I/O tests in Figures <ref type="figure" target="#fig_6">17</ref> and<ref type="figure" target="#fig_7">18</ref>, garbage collection takes less than 0.2% of the total program execution time. Although our system slightly outperforms NPTL in the above benchmarks, we are not trying to prove that our system has absolutely better performance. The goal is to demonstrate that the hybrid programming model implemented in Haskell can deliver practical performance that is comparable to other systems: a good programming interface can be more important than a few percent of performance!</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Case study: A simple web server</head><p>To test our approach on a more realistic application, we implemented a simple web server for static web pages using our thread library. We reused some HTTP parsing and manipulation modules from the Haskell Web Server project <ref type="bibr" target="#b16">[17]</ref>, so the main server consists of only 370 lines of code using monadic threads. To take advantage of Linux AIO, the web server implements its own caching. I/O errors are handled gracefully using exceptions. Not only is the multithreaded programming style natural and elegant, but the event-driven architecture also makes the scheduler clean. The scheduler, including the CPS monad, system call implementations, event loops and queues for AIO, epoll, mutexes, blocking I/O and exception handling (but not counting the wrapper interfaces for C library functions), is only 220 lines of well-structured code. The scheduler is designed to be customized and tuned: the programmer can easily add more system I/O interfaces or implement application-specific scheduling algorithms to improve performance. The web server and the I/O scheduler are completely type-safe: debugging is made much easier because many low-level programming errors are rejected at compile-time.</p><p>Figure <ref type="figure" target="#fig_14">19</ref> compares our simple web server to Apache 2.0.55 for a disk-intensive load. We used the default Apache configuration on Debian Linux except that we increased the limit for concurrent connections. Using our system, we implemented a multithreaded client load generator in which each client thread repeatedly requests a file chosen at random from among 128K possible files available on the server; each file is 16KB in size. The server ran on the same machine used for the IO benchmarks, and the client machine communicated with the server using a 100Mbps Ethernet connection. Our web server used a fixed cache size of 100MB. Before each trial run we flushed the Linux kernel disk cache entirely and preloaded the directory cache into memory. The figure plots the overall throughput as a function of the number of client connections. On both servers, CPU utilization fluctuates between 70% and 85% (which is mostly system time) when 1,024 concurrent connections are used. Our simple web server compares favorably to Apache on this disk-bound workload.</p><p>For mostly-cached workloads (not shown in the figure), the performance of our web server is also similar to Apache. A future work is to test our web server using more realistic workloads and implement more advanced scheduling algorithms, such as resource aware scheduling used in Capriccio <ref type="bibr" target="#b25">[26]</ref>.</p><p>The web server also works with our application-level TCP stack implementation. By editing one line of code in the web server, the programmer can choose between the standard socket library and the customized TCP library. Because the protocol stack is now part of the application, we are able to tailor and optimize the TCP stack to the server's specific requirements. For example, urgent pointers and active connection setup are not needed. We can implement server-specific algorithms directly in the TCP stack to fight against DDoS attacks. Furthermore, our TCP stack is a zerocopy implementation 3 ; it uses IO vectors to represent data buffers indirectly. The combination of packet-driven I/O and disk AIO provides a framework for application-level implementation of highperformance servers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related work and discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Language-based concurrency</head><p>We are not the first to address concurrency problems by using language-based techniques. There are languages specifically designed for concurrent programming, such as Concurrent ML (CML) <ref type="bibr" target="#b21">[22]</ref> and Erlang <ref type="bibr" target="#b3">[4]</ref>, or for event-driven programming such as Esterel <ref type="bibr" target="#b4">[5]</ref>. Java and C# also provide some support for threads and synchronization. Most of these approaches pick either the multithreaded or event model. Of the ones mentioned above, CML is closest to our work because it provides very lightweight threads and event primitives for constructing new synchronization mechanisms, but its thread scheduler is still hidden from the programmer. There are also domain-specific languages, such as Flux <ref type="bibr" target="#b6">[7]</ref>, intended for building network services by composing existing C or Java libraries.</p><p>Rather than supporting lightweight threads directly in the language, there is also a large body of work on using language-level continuations to implement concurrency features <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b8">9]</ref>. Our work uses a similar approach, except that we do not use language-level continuations -the CPS monad and lazy data structures are sufficient for our purpose.</p><p>It is worth noting that this paper only focuses on the domain of massively-concurrent network programming. Similar problems have also been studied in the domain of programming graphical user interfaces some time ago, and prior work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b20">21]</ref> showed different approaches to combine threads and events by using explicit message passing with local event handlers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Event-driven systems and user-level threads</head><p>The application-level thread library is motivated by two projects: SEDA <ref type="bibr" target="#b27">[28]</ref> and Capriccio <ref type="bibr" target="#b25">[26]</ref>. Our goal is to get the best parts from both projects: the event-driven architecture of SEDA and the multithreaded programming style of Capriccio. Capriccio uses compiler transformations to implement linked stack frames; our application-level threads uses first-class closures to achieve the same effect.</p><p>Besides SEDA <ref type="bibr" target="#b27">[28]</ref>, there are other high-performance, eventdriven web servers, such as Flash <ref type="bibr" target="#b19">[20]</ref>. Larus and Parkes showed that event-driven systems can benefit from batching similar operations in different requests to improve data and code locality <ref type="bibr" target="#b14">[15]</ref>. However, for complex applications, the problem of representing control flow with events becomes challenging. There are libraries and tools designed to make event-driven programs easier by structuring code in CPS, such as Python's Twisted package <ref type="bibr" target="#b23">[24]</ref> and 3 Our current implementation uses iptables queues to read packets, so there is still unnecessary copying of incoming packets. However, this is not a fundamental limit-an asynchronous packet I/O interface would allow us to implement true zero-copying. C++'s Adaptive Communication Environment (ACE) <ref type="bibr" target="#b0">[1]</ref>. Adya et al. <ref type="bibr" target="#b1">[2]</ref> present a hybrid approach to automate stack management in C and C++ programming.</p><p>Multiprocessor support for user-level threads is a challenging problem. Event-driven systems, in contrast, can more readily take advantage of multiple processors by processing independent events concurrently <ref type="bibr" target="#b28">[29]</ref>. A key challenge is how to determine whether two pieces of code might interfere: our thread scheduler benefits from the strong type system of Haskell and the use of software transactional memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Type-safe construction of the software stack</head><p>Our work is orthogonal, but in some sense similar to the Singularity <ref type="bibr" target="#b12">[13]</ref> project, which constructs an operating system using typesafe languages. Singularity uses language-based abstractions to isolate processes and eliminate overheads of hardware-enforced protection domains; we use language-based abstractions to isolate software components and eliminate overheads of OS abstractions. Singularity reconstructs the traditional software stack from bottom up; our approach attempts to do so from top down.</p><p>In our hybrid programming model, many software components that are traditionally implemented in the OS, such as threads, IO libraries and network stacks, can be modularly lifted into the application and share the same programming environment. In fact, the event-driven system described in Figure <ref type="figure" target="#fig_2">14</ref> looks quite like a small operating system itself. This application-level approach has many advantages for building high-performance network services: the interfaces among these components are completely type-safe; each component can be customized to the application's needs; compiling them together also opens opportunities for optimizations across components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>Events and threads should be combined into a hybrid programming model in general-purpose programming languages. With proper language support, application-level concurrency primitives can be made extremely lightweight and easy to use. Our experiments demonstrate that this approach is practical and our programming experience suggests that this is a very appealing way of writing scalable, massively concurrent systems software.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Threads vs. events</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. The hybrid model and application-level implementation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Some threaded code (left) and its trace (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>-Figure 5 .</head><label>5</label><figDesc>Figure 5. System calls and their corresponding traces</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Thread execution through lazy evaluation (the steps are described in the text)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Haskell's Monad interface (excerpt)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. The CPS monad M</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Converting monadic computation to a trace</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Implementing some system calls</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 .Figure 11 .</head><label>1011</label><figDesc>Figure 10. Wrapping non-blocking I/O calls to blocking calls</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. System calls for exceptions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 .Figure 13 .</head><label>1413</label><figDesc>Figure 14. The event-driven system: event loops and task queues</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 15 .Figure 16 .</head><label>1516</label><figDesc>Figure 15. System calls for epoll and (read-only) AIO</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 17 .Figure 18 .</head><label>1718</label><figDesc>Figure 17. Disk head scheduling test</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 19 .</head><label>19</label><figDesc>Figure 19. Web server under disk-intensive load</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The memory consumption test used a machine with dual Xeon processors and</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>2GB RAM. We set the GHC's suggested heap size for garbage collection to be 1GB.<ref type="bibr" target="#b1">2</ref> The disk and FIFO I/O benchmarks were run on a single-processor Celeron 1.2GHz machine with a 32KB L1 cache, a 256KB L2 cache, 512MB RAM and a 7200RPM, 80GB EIDE disk with 8MB buffer. We set GHC's suggested heap size for garbage collection to be 100MB.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank all the members of the PLClub at the University of Pennsylvania, Milo M.K. Martin, Yun Mao, Simon Peyton Jones and Simon Marlow for their help and feedbacks on this project. In addition, we would like to thank the PLDI reviewers for their valuable comments and extensive proofreading of the original draft. This work is supported by NSF grant CCF-0541040.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The ADAPTIVE Communication Environment: Object-Oriented Network Programming Components for Developing Client/Server Applications. 11th and 12th Sun Users Group Conference</title>
		<imprint>
			<date type="published" when="1993-12">December 1993 and June 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cooperative Task Management without Manual Stack Management</title>
		<author>
			<persName><forename type="first">Atul</forename><surname>Adya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marvin</forename><surname>Theimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">J</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 Usenix Annual Technical Conference</title>
		<meeting>the 2002 Usenix Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Compiling with Continuations</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Appel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Concurrent Programming in Erlang, Second Edition</title>
		<author>
			<persName><forename type="first">Joe</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Virding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claes</forename><surname>Wikström</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Gerard</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georges</forename><surname>Gonthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Esterel Synchronous Programming Language: Design, Semantics, Implementation. Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="87" to="152" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Rigorous specification and conformance testing techniques for network protocols, as applied to TCP, UDP, and sockets</title>
		<author>
			<persName><forename type="first">Steve</forename><surname>Bishop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Fairbairn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Norrish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Wansbrough</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM &apos;05: Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="265" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Flux: A language for programming highperformance servers</title>
		<author>
			<persName><forename type="first">Brendan</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Grimaldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Kostadinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Corner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2006 USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2006-06">June 2006</date>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Poor Man&apos;s Concurrency Monad</title>
		<author>
			<persName><forename type="first">Koen</forename><surname>Claessen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="313" to="323" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Compiler Support for Lightweight Concurrency. Technical memorandum, Bell Labs</title>
		<author>
			<persName><forename type="first">Kathleen</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Reppy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-03">March 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Multi-threaded Higherorder User Interface Toolkit</title>
		<author>
			<persName><forename type="first">R</forename><surname>Emden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">H</forename><surname>Gansner</surname></persName>
		</author>
		<author>
			<persName><surname>Reppy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Trends</title>
		<editor>
			<persName><surname>User Interface Software</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dewan</forename><surname>Bass</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="61" to="80" />
			<date type="published" when="1993">1993</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">The</forename><surname>Glasgow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haskell</forename><surname>Compiler</surname></persName>
		</author>
		<ptr target="http://www.haskell.org/ghc" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Composable Memory Transactions</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurice</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Marlow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Peyton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-Jones</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>the ACM Symposium on Principles and Practice of Parallel Programming</meeting>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">An Overview of the Singularity Project</title>
		<author>
			<persName><forename type="first">Galen</forename><forename type="middle">C</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manuel</forename><surname>Fahndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orion</forename><surname>Hodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nick</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bjarne</forename><surname>Steensgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Tarditi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ted</forename><surname>Wobber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Zill</surname></persName>
		</author>
		<idno>MSR-TR-2005-135</idno>
		<imprint>
			<date type="published" when="2005-10">October 2005</date>
			<publisher>Microsoft Research</publisher>
			<pubPlace>Redmond, WA, USA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Concurrent Haskell</title>
		<author>
			<persName><forename type="first">Peyton</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sigbjorn</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><surname>Finne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting><address><addrLine>St. Petersburg Beach, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="295" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Using Cohort-Scheduling to Enhance Server Performance</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Parkes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="103" to="114" />
		</imprint>
	</monogr>
	<note>General Track</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the Duality of Operating Systems Structures</title>
		<author>
			<persName><forename type="first">Hugh</forename><forename type="middle">C</forename><surname>Lauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roger</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Second International Symposium on Operating Systems</title>
		<meeting>Second International Symposium on Operating Systems</meeting>
		<imprint>
			<date type="published" when="1978-10">October 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Developing a High-performance Web Server in Concurrent Haskell</title>
		<author>
			<persName><forename type="first">Simon</forename><surname>Marlow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Computational lambda-calculus and monads</title>
		<author>
			<persName><forename type="first">Eugenio</forename><surname>Moggi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science</title>
		<meeting>the Fourth Annual IEEE Symposium on Logic in Computer Science<address><addrLine>Pacific Grove, California</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1989-06">June 1989</date>
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Why Threads Are A Bad Idea (for most purposes)</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">K</forename><surname>Outsterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presentation given at the 1996 Usenix Annual Technical Conference</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Flash: An efficient and portable Web server</title>
		<author>
			<persName><forename type="first">S</forename><surname>Vivek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Willy</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX 1999 Annual Technical Conference</title>
		<meeting>the USENIX 1999 Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Concurrent Window System</title>
		<author>
			<persName><forename type="first">Rob</forename><surname>Pike</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="153" />
			<date type="published" when="1989">1989</date>
			<pubPlace>Spring</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">CML: A Higher Concurrent Language</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">H</forename><surname>Reppy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;91: Proceedings of the ACM SIGPLAN 1991 Conference on Programming Language Design and Implementation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="293" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Continuations and Threads: Expressing Machine Concurrency Directly in Advanced Languages</title>
		<author>
			<persName><forename type="first">Olin</forename><surname>Shivers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM SIGPLAN Workshop on Continuations</title>
		<meeting>the Second ACM SIGPLAN Workshop on Continuations</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<ptr target="http://twistedmatrix.com/" />
		<title level="m">The Twisted Project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Why Events Are A Bad Idea (for high-concurrency servers)</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Rob Von Behren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Workshop on Hot Topics in Operating Systems (HotOS IX)</title>
		<meeting>the 10th Workshop on Hot Topics in Operating Systems (HotOS IX)</meeting>
		<imprint>
			<date type="published" when="2003-05">May 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Capriccio: Scalable threads for internet services</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Rob Von Behren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninteenth Symposium on Operating System Principles (SOSP)</title>
		<meeting>the Ninteenth Symposium on Operating System Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Monads for Functional Programming</title>
		<author>
			<persName><forename type="first">Philip</forename><surname>Wadler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Marktoberdorf Summer School on Program Design Calculi</title>
		<meeting>the Marktoberdorf Summer School on Program Design Calculi</meeting>
		<imprint>
			<date type="published" when="1992-08">August 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">SEDA: An Architecture for Well-Conditioned, Scalable Internet Services</title>
		<author>
			<persName><forename type="first">Matt</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating System Principles (SOSP)</title>
		<meeting>the Symposium on Operating System Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Multiprocessor support for eventdriven programs</title>
		<author>
			<persName><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Yip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Dabek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 USENIX Annual Technical Conference (USENIX &apos;03)</title>
		<meeting>the 2003 USENIX Annual Technical Conference (USENIX &apos;03)<address><addrLine>San Antonio, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06">June 2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
