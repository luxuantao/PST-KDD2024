<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EFFICIENT MANAGEMENT OF TRANSITIVE RELATIONSHIPS IN LARGE DATA AND KNOWLEDGE BASES</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rakesh</forename><surname>Agrawal</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">AT&amp;T Bell Laboratorie.s</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<country>New Jersey</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Borgida</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Rutgers University</orgName>
								<address>
									<postCode>08903</postCode>
									<settlement>New Brunswick</settlement>
									<country>New Jersey</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">AT&amp;T Bell Laboratorie.s</orgName>
								<address>
									<postCode>07974</postCode>
									<settlement>Murray Hill</settlement>
									<country>New Jersey</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">EFFICIENT MANAGEMENT OF TRANSITIVE RELATIONSHIPS IN LARGE DATA AND KNOWLEDGE BASES</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E7E3613EB0F2A121074B1F5E93B28A13</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We argue that accessing the transitive closure of relationsbips is an important component of both databases and knowledge representation systems in Artificial Intelligence. The demands for efficient access and management of large relationships motivate the need for explicitly storing the transitive closure in a compressed and local way, while allowing updates to the base relation to be propagated incrementally. We present a transitive closure compression technique, based on labeling spanning trees with numeric intervals, and provide both analytical and empirical evidence of its efficacy, including a proof of optimality.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">OVERVlEW</head><p>The significance of transitive relationships has long been acknowledged in varied fields. Recently, database researchers have recognized its utility in querying databases -in fact, it has been argued that transitivity is the dominant form of recursion that is of practical utility [2, <ref type="bibr" target="#b28">24,</ref><ref type="bibr" target="#b31">27]</ref>.</p><p>After briefly reviewing the motivation for managing large transitive relationships in databases, we present a second application arex the management and use of subclass (IS-A) hierarchies in knowledge representation systems. After considering the (conflicting) demands of efficient access, update, and storage, we argue that the usual techniques based on graph management are not adequate for managing and querying large transitive binary relationships, and propose a new technique for encoding such information. In Section 3, we present an algorithm for computing such an encoding, and show that it produces optimal results in a certain subclass of possible encodings -ones based on eg trees for the graph of the relationship.</p><p>We present both analytical and empirical evidence of its efficacy. Incremental update algorithms are briefly discussed in Section 4. In Section 5 we compare our approach with altemative techniques that have appeared in the literature. We conclude with some final remarks in Section 6. Some proofs and other details have been omitted for lack of space. These can be found in <ref type="bibr">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">MOTlVATION</head><p>The computation of transitive relationships has been recognized as a sufficiently useful operation for it to have been included as an operator in a variety of query languages, based on both the relational and other data models <ref type="bibr">[2,11,19,21.271</ref>.</p><p>A general technique for speeding up query processing in the presemce of large amounts of data, even in the absence of such transitivity operator, is view materialization <ref type="bibr" target="#b8">[7,</ref><ref type="bibr" target="#b16">14]</ref>.</p><p>Frequently accessed views are computed once and stored so that future queries can be answered directly, by look up, from such materialized views, instead of computing them on-the-fly. For the same reason, the problem of managing views which are the transitive closure of some relationship is of considerable interest, not withstanding recent progress on efficient algorithms for =mY computing transitive relationships <ref type="bibr">[1,3,6,15,16,22.,29]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Transitivity</head><p>In Knowledge Representation Semantic networks and frame systems are among the most popdar techniques for representing and reasoning with knowledge in Artiicial Intelligence <ref type="bibr" target="#b11">[9]</ref>. Systems based on these techniques allow concepts to be organized into sub&amp;ass hierarchies (often known as "IS-A hierarchies"), with "inheritance" (the transitive traversal of such hierarchies) being a key component of their reasoning algorithms1 More recently, knowledge representation systems such as KL-ONE <ref type="bibr">[lo]</ref> and its successors (e.g., <ref type="bibr" target="#b10">[8,</ref><ref type="bibr">20,</ref><ref type="bibr" target="#b27">23,</ref><ref type="bibr" target="#b30">26]</ref>) have 1. Them are even ~qoeele for knowled~ qresa~tation systems in which aN kmwledge is rcpmrcntcd as nodea cormected by e variexy of IS-A links <ref type="bibr" target="#b15">[13]</ref>: Fred is hungry iE the.~ ia . prth ftm~ the node labeled "FE&amp; to that lhded "hungry". introduced compositional languages for defining concepts, where a concept is subsumed by another (belong under each other in the subclass hierarchy) by 'virtue of their definition: "all things whose children are doctors" is automatically more general than "all things whose children are eye-surgeons", if doctors subsume eye-surgeons. Computing the subsumption relationship between a new concept and previously known ones is the key inference made by such "terminologic logics"; in the process of making such computations, a frequent operation is finding out whether two previously known concepts are in the "subsumed by" relation. This relationship is therefore precomputed, cached as a hierarchy, and must be managed efficiently.</p><p>The space of concepts in a knowledge base can easily become quite large (an airplane, for example, may have close to 100,000 different kinds of parts -concepts), and must therefore be managed as a database, as in <ref type="bibr" target="#b34">[30]</ref>. Questions about the transitive closure of the IS-A relationship, given their importance and frequency, must be answered by a technique more efficient than simple pointer chasing in the underlying data structure, the current approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Approaches to Management of Transitive Relationships</head><p>Binary relationships can be represented as directed graphs, which at least in the case of the above knowledge representation systems are acyclic. We have already argued that in both the case of large databases and knowledge bases it will be desirable to avoid the run-time computation of the transitive closure. This suggests that we materialize the transitive closure.</p><p>However, the technique for storing materialized transitive closure must satisfy a number of conflicting requirements: storage camrot be used profligately, especially in main memory; look-up must be efficient, at least in the average case; in the case of large relations, the information will reside on secondary storage, and hence we need to minimiie I/O traflic; updates (at least additions) to the base relation are not infrequent, so the incremental cost of adding new no&amp;s and relationships should be less than recomputing the transitive closure.</p><p>These desiderata make unacceptable the obvious approaches for maintaining the transitive closure, such as linked lists or arrays of descendants, or 2dimensional Boolean arrays, since the addition of all transitively derivable relationships can increase the number of edges in the graph from O(n) to O(n'). Therefore, some compressed and local representation is needed. We now present such a compression scheme, which has been motivated by the technique for encoding trees, suggested by Schubert et. al. in <ref type="bibr" target="#b32">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE COMPRESSION SCHJWE</head><p>A binary relation, including a "source" field and "destination" field defined over the same domain corresponds to a graph with a no&amp; for each distinct value of the source and destination fields and a directed arc for each tuple in the relation. The successor list of a node is the list of all nodes that are reachable from the specified node by traversing arcs of the graph. and the immediate successor list of a node is the list of all nodes to which the specified no&amp; has a direct arc.</p><p>Similarly, the predecessor list of a node is the list of all no&amp;s that can reach this node by traversing arcs of the graph, and the immediate predecessor list of a node is the list of all nodes that have a direct arc to the specified node. We concentrate on relations that correspond to acyclic graphs. However, the techniques presented in this paper can also be extended to cyclic graphs by collapsing strongly connected components into one node.</p><p>The generic compression scheme considered in this paper is range compression. The basic i&amp;a is to assign numbers to nodes so that instead of individually listing all nodes within a certain range of values in a successor list, the range is recorded. This form of compression is often used, for example, in citing references in technical literature. However, the way numbers appear in citations, this fortunate situation does not occur very often (see Section 2 of this paper, for instance). Our endeavor is to develop node numbering techniques that yield maximum compression. We do so by covering the graph with one or more spanning trees, and using the trees to generate node numbers.</p><p>We motivate our compression scheme by 6rst considering the simple case when the original graph is a directed tree with arcs from parents to children, and then present the scheme for acyclic graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Directed Trees</head><p>Number each node to reflect its relative position in a postorder traversal of the tree. The number of a node will be called its postorder number. Now, assign to each node in the tree, an index consisting of the lowest postorder number among its descendents2. For simplicity, we assume that every node can reach itself, so that the index associated with a leaf no&amp; is the same as the postorder mrmber of the no&amp;. Lemma 1. Let the postorder number of node a be j, and let the index associated with a be i. There exists a direct path from node a to some other no&amp; b with the postorder number kiffi&lt;k&lt; j.</p><p>We thus have a compression scheme for trees that requires O(n) storage, only a constant factor (twice) the storage for the tree itself, to store the transitive closure and can answer reachability queries with only one range comparison.</p><p>Consider, for example, the tree shown in We now generalize the above scheme for the case of a directed acyclic graph. We assume that the graph consists of only one connected component; disjoint components can be hooked together by creating a virtual root no&amp;.</p><p>The compression scheme works as follows: Find a spanning tree T for the given graph G. We call T the tree-cover of G.</p><p>Assign postorder mrmbers and indices to the no&amp;s of T as outlined in the Section 3.1. Thus, at the end of this step, an interval [i,jJ would be associated with each node, such that j is the postorder number of the node and i the lowest postorder number among its descendents.</p><p>Examine all the nodes of G in the reverse topological order. At each node p. do the following processing:</p><p>-For every arc (p,q), add all the intervals associated with the node q to the intervals associated with the node p. -At the time of adding an interval to the interval set associated with a node, if one interval is subsumed by another, discard the subsumed interval. That is, if the two intervals [il.iz] and ljt.j2 ] are such that iI S jt and is 2 ja. then discard [ir.j,].</p><p>At each node now, there is a unique interval that encapsulates reachability information for the nodes that can be reached by following the tree arcs starting from this node.3 We will refer to this interval as the tree interval. In addition, there are intervals associated with a node that encapsulate reachability information for the nodes that can be reached by following one or more non-tree arcs starting from this node. We will refer to such intervals as non-tree intervals.</p><p>Lll LQI We now present an algorithm for finding the "optimum" tree-cover.</p><p>Let us first define optima@ in this context. Each interval associated with a node causes one extra unit of storage in the compressed closure. It also causes additional effort at the time of look-up. Let each interval associated with a node place a unit weight on the node. The optimization problem then reduces to finding a tree-cover that results in minimum weight summed over all the nodes. The minimum weight obviously will result in minimum storage. If we assume uniform probability for reachability query between any two nodes. then this criterion is optimum Erom the average time viewpoint also.</p><p>If a node has two intervals associated such that one interval subsumes the other. then the subsumed interval can be deleted.</p><p>That is, if a node has associated intervals [il,jl], [i2.j2], with illi21j21jl.</p><p>then only the irst of the two intervals need be counted. Such interval subsumption is taken into account in what follows.</p><p>It may also happen that a node has associated with it two intervals [il,jl],</p><p>[i2.j2], with i2 = j,+l.</p><p>In this case, one would think that a single interval [i Ir j,] would suffice. Such adjacent interval merging can cause problems as discussed later on. Two adjacent intervals count as two intervals for purposes of the following algorithm, lemmas, and theorem.</p><p>Here is the algorithm that obtains the optimum tree-cover for a given directed acyclic graph G: Algl (Optimum tree-cover):</p><p>Topologically sort G, Assume that all nodes with no predecessors are connected to a virtual level 0 root.</p><p>For every node j in G. in topological order, do:</p><p>Repeat for each incoming arc pair (iI&amp;. (i2,J: if size(pred(it)) &gt; sixe(pred(i2)) then delete (i2,j) else delete (i,j) For every ik immediate predecessor of j pdo') := C&amp;l u pm%),</p><p>In the algorithm above, pred(j), is the set of all predecessors of node j. and is incrementally computed. There is a tree arc to each node from the immediate predecessor that has the largest pred() set.</p><p>Lemma 2. If a node j has two incoming arcs (i,j). (i2.j). of which (il,J is included in the tree-cover, then only those predecessors of iI that are not predecessors of i2 will have to inherit the tree interval associated with j, PROOF. Obviously, i, will have to inherit j's tree interval. Any predecessor of il will also have to inherit this interval unless it is subsumed by some other interval associated with them. The way intervals are constructed, j's tree interval will be automatically subsumed by the tree interval associated with i2. Any predecessor of i2, therefore, does not have to inherit i's tree interval.</p><p>Lemma 3. If an interval [il,i2] subsumes another interval b 1, jz], then there is path from i2 to jz consisting solely of tree arcs.</p><p>PROOF. The interval [il,i2] represents a subtree of the spanning tree T such that its root is i, and i, is the smallest postorder number of any of its children. Similarly, the interval <ref type="bibr">[il,j2]</ref> represents a subtree of the spanning tree T such that its root is j2 and jr is the smallest postorder number of any of its children. Since [il,i2] subsumes ur,j2], we have it I j, and i2 2 j,. Therefore, the subtree rooted at j2 is contained in the subtree rooted at i2, and there is a path consisting of tree arcs from ia to j,.</p><p>Theorem 1. Algl gives the optimum tree-cover in the sense that the total number intervals associated with nodes (summed over all nodes) is minimum.</p><p>PROOF. Suppose there is another tree-cover T which is strictly better but does not follow from Alg 1. Topologically sort T. Starting from the lowest level (leaf-level), find the 6rst level at which a node j exists that does not follow the rules of Algl.</p><p>That is, T contains an arc (il.~~ but there is a predecessor i2 of i such that size@ed(i2)) &gt; sixe(pred(il)). Transform T into T such that the arc (ir J) is deleted and arc (i2,J is added. This change will cause a change in the number of intervals associated with the predecessors of j.</p><p>Let us represent by Ii the set consisting of i, and its predecessors in G not also predecessors of i2, and by I2 the set consisting of i2 and its predecessors in G who are also not the predecessors of il.</p><p>By Lemma 2, the tree interval associated with j will now be inherited by all nodes in It as a non-tree interval, but will no longer have to be inherited by nodes in Z2. Since size(pred(i2)) &gt; size(pred(i,)), in the absence of interval subsumption, this change causes a net reduction in the total cardinality of interval sets associated with nodes.</p><p>Let us now consider the effect of interval subsumption. Two things can go wrong in the presence of interval subsumption:</p><p>Fist, the number of intervals associated with nodes in Ia may not decrease since the tree interval of j which was inherited due to the non-tree arc (i2,j) was already subsumed by some interval [u,v] associated with some node Lz in I2 (see Figure <ref type="figure" target="#fig_2">3</ref>.4). For this to happen, we claim that i2 must also be a predecessor of il in T and hence camiot belong to 12. By Lemma 3, there must be a path consisting solely of tree arcs from v to j. and this path goes through the no&amp; i, as (i , , j) is the tree arc coming into j in T. If v is same as T2. we are done. Otherwise, there must be a path consisting of tree and non-tree arcs from ;a to v along which the interval [u,v] was inherited as non-tree interval. In that case also, iz is a predecessor of il. Second, the number of intervals associated with nodes in It may not increase as the intervals inherited from j are subsumed by the intervals already present with nodes in I,. First of all, the non-tree intervals inherited from j are not changed since by the very nature of the compression scheme, non-tree intervals are inherited along both tree and non-tree arcs. The only remaining question is whether the tree interval associated with j can be subsumed by an interval associated with a node it in It in T (see Figure <ref type="figure" target="#fig_2">3</ref>.5). The answer again is no, since in that case the subtree rooted at j must be contained in the subtree rooted at 7, or a node reachable from : l1 and there would be a path consisting solely of tree arcs from this node to i2. Thus, 7, would also be a predecessor of i2. The above transformation is recursively applied to all nodes in the graph till T is transformed into a tree cover that is at least as good as T and follows the rules of Algl. Hence Proved.</p><p>Note that the complexity of computing the compressed transitive closure of a graph is the same as the computation of its transitive closure. However, compression is a one-time activity. and once the compressed closure has been obtained, it can be repeatedly used to efficiently answer queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Storage Requirement</head><p>Algl minimizes the storage required for storing the compressed closure. We now examine how much storage is required for the compressed closure if the optimum tree cover generated by Algl is used for compression. There is a tree interval associated with every node in the graph. The number of non-tree intervals associated with a graph is given by the following lemma: Lemma 4. The number of non-tree intervals associated with a no&amp; i equals the cardinality of the node set N;, where N1 consists of all no&amp;s j such that i. there is a path from i to j containing one or more nontree arcs, and ii. there is no k E NI such that there is path consisting solely of tree arcs from k to j.</p><p>PROOF. In absence of interval subsumption, a path from i to j containing one or more non-tree arcs propagates j% tree interval to i. We need not consider the non-tree intervals associated with j, since j must have inherited this interval from some other node I along a path from j to I that contains one or more non-tree arcs, but then this is a subpath of the pathfromitoI.</p><p>If there is a path from a node k to j consisting solely of tree arcs, then the tree interval of j is subsumed by the tree interval associated with k. Since k is in Ni. the h'ee interval of k is inherited by i and will subsume the tree interval of j. Hence proved.</p><p>The total storage requirement can now be obtained by summing the number of non-tree intervals over all the nodes, and depends on the nature of the graph.  The creation of such "meaningful" bundles of objects is the whole essence of constructing inheritance hierarchies, and we do not expect worst case graphs to arise in the applications envisaged. Experience with Lassie, a classification-based software retrieval system <ref type="bibr" target="#b14">[12]</ref>. supports this belief.</p><p>We empirically investigate the average case behavior in Section 3.3. Before that, we look at some improvements that are possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Improvements</head><p>The number of intervals associated with a node can be reduced by merging adjacent intervals, that is, if the two intervals [i,,i2] and ul.j2 ] are such that ji = i, + 1. then create one [iI. j2] corresponding to these two intervals. It now becomes possible to generate overlapping intervals: merge two intervals.</p><p>[il,i2] and hdd im [il,i21. if il 5 j, I i2 I j,.</p><p>Such merging can sometimes result in significant reduction in storage requirement. For example, in Figure <ref type="figure" target="#fig_2">3</ref>.6. the m nontree intervals associated with n-m-l top nodes can be collapsed into a single interval, bringing the total number of intervals required down to (m+l) + 2(n-m-1) = h-m-1. which is again 0 (n).</p><p>Unfortunately, merging of adjacent intervals is orderdependent. Consider, for example. the following two graphs that are structurally equivalent, but lead to different compressions depending on how the children are ordered: No intend is merged in the 6rst case. However, if the order of c and d were. interchanged, the non-tree interval [1.2] inherited through the non-tree arc (d,b) can be merged with the tree interval [3.3] of the node. Fiimg an optimum ordering of no&amp; numbers to maximize the benefits of interval merging appears to be a combinatorial problem. We have omitted the merging of the intervals in Algl to be able to present a class of labelings for which Algl is optimal. In actual use, one may obtain tree cover using Algl and then merge adjacent intervals whenever encountered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Performance Evaluation</head><p>In this section we present the results of simulation experiments performed to evaluate empirically the effectiveness of the proposed compression technique. The effectiveness has been measured in terms of the storage required for storing the transitive closure with and without compression. The total storage required was computed as the number of successors at each no&amp; for the original and transitive closure graphs. For the compressed transitive closure, in the simplest scheme, one has to store both end-points for every range interval. One may do better, for example, by storing the ranges separately and pointers to ranges at the nodes. We have computed the storage required for the compressed closure as twice the number of intervals required at each node to obtain baseline performance measure for the compression scheme.</p><p>Following <ref type="bibr">[l]</ref>. synthetic graphs were used as data sets in performance experiments. Two primary parameters define a database that can be represented as a graph: the average degree of a node and the number of nodes. We considered datasets with the average out-degree specified. The rationale for the choice of these parameters has been discussed at length in <ref type="bibr">[l]</ref>. Experiments were run for various combiitions of degrees and sizes, but we present here only the representative trends.</p><p>Figure <ref type="figure" target="#fig_2">3</ref>.9 shows the storage requirement for the transitive closure of a random 1000 node graph as the degree of the graph is varied. The storage requirement is plotted as a multiple of the size of the original graph. Initially, as the degree of the graph is increased from 1 to 2 to 3, the size of the transitive closure increases rapidly as new paths are found to nodes that previously were unreachable. (A degree 1 graph is likely to consist of several unconnected components). Further increases in the degree do not increase the size of the closure as much, since most of the nodes are already reachable and addition of more arcs only establishes alternate paths to already reachable nodes. We found that of the 495.000 possible arcs in a 1000 node acyclic graph, 442.000 were already present in the closure of graph of degree 4. The size of the graph itself increases linearly with degree. Beyond a The size of the compressed closure also rises at first, though less so than the size of the full transitive closure. As more and more arcs are added, however, a deeper, less branchy tree can be found to cover the graph. Most successors of a node can he reached solely through tree arcs. Paths through nontree arcs result in intervals that are mostly subsumed. Consequently, the size of the compressed closure actually begins to decrease as the degree of the graph is increased. This decrease contrasts with the increasing size of the original graph. Eventually the size of the compressed closure becomes even less than the size of the original graph itself.</p><p>That the compressed closure requires less storage than even the original graph may appear surprising at first. A graph of high degree has many "redundant" arcs whose removal does not affect the reachability information in the graph. The compressed closure avoids the extra storage required for these redundant arcs, resulting in less storage overall.</p><p>It can be argued that when the transitive closure includes most arcs in tbe graph, one should store the inverse, storing tuples only for sourcedestination pairs between which a path cannot be found in the graph In the case of a directed acyclic graph the maximum number of arcs in the graph is exactly half the total possible. When we say that most of the possible arcs have been includeed, we mean that the total number of arcs in the closure is close to 1%n2. If a topological ordering of the graph is stored as well, then one can use the topological ordering to identify the lAn2 arcs that are possible according to this ordering. However, such a scheme makes incremental updates more complex as the topological sort may also have to be increm~tally updated. In spite of this practical diificulty with inverse closures, we measured the size of the inverse closure with respect to a particular topological sort and obtained the results shown in Figure <ref type="figure" target="#fig_2">3</ref>.10.</p><p>The sire of the inverse closure falls rapidly as the degree of the graph is increased, and relative to the size of the graph, it falls even more rapidly. However, the size of the compressed closure stays well below that of the inverse closure, and decreases at a rate comparable to the inverse closure for high Figures 3.9 and 3.10 showed that the transitive closure of a graph can be compressed to a small fraction of its size by using the techniques presented in this paper. Figure <ref type="figure" target="#fig_2">3</ref>.11 measures tbis compression for graphs with different numbers of nodes while the degree is kept fixed at 2. Storage requirement is again plotted as a multiple of the storage required for the original relation. Figure <ref type="figure" target="#fig_2">3</ref>.11 clearly shows that. for these random graphs, the size of the compressed closure increases slower than the size of the full closure as the size of the graph is increased, giving better compression for larger graphs. We also performed a sensitivity experiment in which we generated all possible directed acyclic graphs of 8 nodes and computed the size of compressed closure in nnmber of intervals. The result in Figure <ref type="figure" target="#fig_2">3</ref>.12 demonstrates the infrequency of worst-case graphs.</p><p>The above experiments were performed without adjacent intemd merging. We finally performed experiments in all cases to assess the benefits of interval merging. We found the additional compression obtained was rather small, usually less than 5%. While assigning postorder numbers to nodes, it is not necessary to choose contiguous numbers; one can leave gaps between numbers and the compression scheme presented in Section 3 would still work correctly. The initial gap could be &amp;temined by dividing the range of integers that can be accommodated in one word by the number of nodes in the graph:'. Figure <ref type="figure" target="#fig_11">4</ref>.1 shows the intervals assigned to nodes in the graph given in Figure <ref type="figure" target="#fig_2">3</ref>.2, where the gap between numbers is now 10 rather than 1. The incremental update algorithms presented below exploit gaps in the postorder numbers assigned to nodes. In the following discussion. we assume that all the postorder numbers currently in use are maintained in a sorted list L.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Additions Addition of a tree arc</head><p>Consider a new node i connected by a new arc (i,j) to an existing node i. Let the postorder number of i be n2 and that of its immediate child with smallest postorder rmmber be nr (nl is taken to he one less than the lower range of the interval associated with i, if i is a leaf node). Find the two postorder munbers between nr and n2 that have already been assigned and have the largest difference. Let these be ii1 and ii2. The case where the newly added no&amp; j is connected to more than one existing node is treated as an addition of a tree arc followed by an addition of a non-tree arc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Addition of a non-tree arc</head><p>If a non-tree arc (i,j) is added Tom the node i to no&amp; j, the intervals associated with j will have to be added to node i and all of its predecessors.</p><p>If the list of immediate predecessors is also maintained with each node, this propagation can be performed quite efficiently. Moreover. at the time of adding an interval to a node, if the new interval is subsumed by an interval already associated with the node, this interval need not be added. If no new interval is added to a node, the effect need not be propagated to the predecessors of this node.</p><p>If the predecessor list is not available with the nodes, then a scan over all the nodes would be necessary. At every no&amp; n. it must be checked if the node i can be reached from n; if yes, the intervals associated with j must be added to n. A further optimization is possible that can avoid propagation of updates to predecessors for certain kinds of additions. In the case of concept hierarchies in AI systems, when a new no&amp; is added and connected to existing nodes, the reachability set of the existing no&amp;s is unchanged (except that some nodes may now reach this new node also). Such updates frequently take place while "refining." a hierarchy.</p><p>An example of such an update in Figure <ref type="figure" target="#fig_11">4</ref>.2 would be the creation of no&amp; z and arcs (e,z), (x,z), and (z,h). To handle such updates, one can provide an additional gap beyond the postorder number in the tree interval associated with a node. Thus, h's interval could have been made <ref type="bibr">[11,</ref><ref type="bibr" target="#b29">25]</ref>, with the understanding that nodes numbered 21 through 25 are not reachable from h. x will now inherit the interval <ref type="bibr">[11,</ref><ref type="bibr" target="#b29">25]</ref> instead of [11.20] from h. Now when z is added, and if it is assigned a postorder number between 21 and 25. no update is required in both of its predecessors e and x, making hierarchy refinement a constant time operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>What if empty numbers run out</head><p>It is possible that when a new no&amp; j and the tree arc (i,j) is being added, there is no empty postorder number available for j. However, nodes can be remunbered to create a gap so that j can be assigned a postorder number. Simply go left (or right whichever is shorter in the number of intermediate nodes) of the postorder number of i in t, and find the first hole. Suitably renumber all the intermediate numbers. Record this set of intermediate numbers as a set S of tuples of the form &lt;oZdmm, new-. Now make a scan over all the nodes of the graph. If any okfnum appears in any of the intervals, replace oldrum by newnum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Deletions</head><p>Deletion of a tree arc Assume that the deleted arc is (i,j) and I is currently the largest postorder number in L. Take the subtree rooted at j and make it a child of the virtual mot. Remunber the nodes in the subtee. assigning them numbers &gt; 1. (The postorder munber of the virtual root is fixed at +).</p><p>Update tree intervals associated with the nodes in this subtree, but preserve non-tree intervals.</p><p>In the rest of the graph, modify any non-tree intervals that have old postorder numbers with new postorder numbers. Furthermore, if any of the tree predecessors of j had a nontree arc coming into node k of the subtree rooted at j. they should now inherit the intervals associated with k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deletion of a non-tree arc</head><p>There is no change to the sparming tree of the graph. Perform a traversal of all the nodes in the reverse topological order, recomputing the non-tree intervals.</p><p>Deletion has special properties in AI concept hierarchiesnodes are "deleted" to be ignored, but the subset relationships between remaining nodes is unchanged, and no update is required to the compressed closure.</p><p>Finally, note that the incremental update algorithms presented in this section do not preserve the optimality of the tree-cover, and it may be prudent to develop a new tree-cover after sufficient update activity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>A technique for encoding reachability information in a hierarchy (tree) was proposed Schubert et. al. in <ref type="bibr" target="#b32">[28]</ref>, wherein an interval consisting of the preorder number of the node and the highest preorder number among its descendents is associated with a node. The same technique was also proposed, independently. by O'Keefe in <ref type="bibr" target="#b29">[25]</ref>, also to apply only in the case of a tree. For the simple case of tree, our technique is identical to this technique. Schubert et al generalized their scheme somewhat to work for the case of overlapping hierarchies (n0s general directed acyclic graphs). Each hierarchy is treated independently and nodes are assigned intervals separately for each hierarchy. Thus, each node is assigned as many intervals as the number of hierarchies, and intervals associated with a no&amp; are differentiated by tagging them with the corresponding hierarchy identifiers. Hierarchies are taken as given: the decomposition of a graph into hierarchies is not addressed. Incremental updates were also not considered.</p><p>A transitive closure compression technique based on chain decomposition of graphs was proposed in <ref type="bibr" target="#b22">[18]</ref>. Each node is indexed with a chain number, and its sequence number in the chain. At each node, one need store only the earliest node in a chain (the one with the lowest sequence number) that csn be reached from it, and deduce that later nodes in the chain are reachable6.</p><p>Theorem 2. For any graph G, its transitive closure can be compressed using postorder numbers on a tree cover to require storage less than or equal to the storage required by the best chain compression possible without chain reduction.</p><p>In other words, given any good chain cover, without reduction, we can do at least as well with our scheme. (See [4] for proof). On the other hand, there clearly are cases where a tree cover does significantly better than a chain cover. Consider, for example, a tree. As we saw in Section 3, 0 (n) storage suffices to maintain closure in an n node tree. Sign&amp;a&amp;y greater storage would be required by any chain compression technique.</p><p>Tree-like data structures that have a low amortixed cost for incremental updates of transitive closure have been developed in <ref type="bibr" target="#b21">[17]</ref>. However, this scheme is not targetted towards compression and requires more storage than the complete transitive closure.</p><p>Recently, a technique has been proposed to compute the greatest lower bound (and least upper bound) in a lattice efficiently <ref type="bibr">[5]</ref>. While compressed transitive closure techniques, such as those presented in this paper, can be used for these lattice problems to advantage, further study is required to de&amp;mine whether any of the ideas in [5] can be applied to our problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>We presented a technique for compressing the transitive closure of a binary relation. The basic i&amp;a underlying this technique is to cover the graph with a spanning tree, use the position of a no&amp; in the tree to assign it a number, and then USC these node numbers in storing successor lists at each node, keeping only the end-points of a range when all intervening 6. A chain reduction tcchniquc was also proposed in [IS] that luvcr some n&amp;s uncovered by chains as a means of achieving farther mmpressim. We da not consider the additimal comprcssim off&amp; by chain rcductim in Th-2.</p><p>nodes are also successors. Our method for obtaining the SplUhg tree is optimal in that it minimixes the total storage required to store the compressed closure under certain reasonable conditions. We empirically demonstrated the effectiveness of the proposed compression technique on a variety of graphs, and that in some cases, the storage required for the compressed closure can become even less than the storage required for the original relation. We also presented incremental algorithms that allow updates to the base relation to propagate to the materialized closure without having to recompute the whole closure.</p><p>The techniques prese-nted in this paper may provide the basic buikling blocks for efficient implementation of future deductive and knowledge base systems. With the compressed closure, answering a transitive closure query in a deductive database system reduces to a lookup instead of a graph traversal. Indeed, we are planning to incorporate these techniques in prototype systems based on a-extended relational algebra <ref type="bibr">[2]</ref>. These techniques are also useful for efficient propagation of inherited values and properties, and will be central to an implementation of the INCINERATE data model <ref type="bibr" target="#b23">[19]</ref>, in which the concept of inheritance is introduced in the relational data model. Similarly, we can use these compression techniques for the computation of subsumption, disjointness, least common ancestors, and other properties in frame-based knowledge representation systems. CLASSIC <ref type="bibr" target="#b10">[8]</ref>, a new knowledge representation system being developed in our laboratory, has separated the maintenance of subclass relationships into an abstract data type. that maintains the IS-A graph and encapsulates the technique for managing this data structure efficiently. We plan to use the techniques presented in this paper for tbis purpose.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 3.1. Compressed transitive closure for a tree 32 Directed Acyclic Graphs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 . 2 .Figure 3</head><label>323</label><figDesc>Figure 3.2. Compressed transitive closure for a DAG</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3</head><label>3</label><figDesc>Figure 3.4. i, cannot belong to Ia</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 3.5. 7, cannot belong to It</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Figure 3.6. A bipartite graph with a large compressed closure has a maximum value of (n+1)2/4 for n = 2m+l.The worst cases seem to occur when a large number of nodes have the same set of immediate successors. However, in such -=, a single common node can be created as an intermediary as shown in Figure3.7, and the same information can be stored in just (m+2) + 2(n-m-1) = 2n-m intervals, which is O(n).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>....*....m.............&gt; Flgure 3.7. A similar bipartite graph with a small compressed closure</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>IL11 il. 11 Figure 3 . 8 .</head><label>1138</label><figDesc>Figure 3.8. Order dependence in adjacent interval merging</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 . 9 .</head><label>39</label><figDesc>Figure 3.9. Storage required for a 1000 node graph as a function of average degree certain degree. the size of the closure increases slower than the size of the graph. and a dip is observed in the relative sire of the closure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3</head><label>3</label><figDesc>Figure 3.10. Storage required for a 1000 node graph as a function of average degree degrees.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Figure 3.11. Storage required for a degree 2 graph as a ftmction of number of nodes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 3.12. Frequency distribution of total number of intervals in the compressed closure of all possible 8-node acyclic graphs 4. INCREMENTAL UPDATES'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 4</head><label>4</label><figDesc>Figure 4.1. Compressed transitive closure with gaps in postorder numbers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>, one could use real numbera instead of intqcrs. Assign to j the postorder number n = (n,+n2)2 and the interval [;i,+l, n]. Also, add n to L. No update is required in the intervals associated with any other no&amp; of the graph. For example, in the graph of Fig. 4.1, the addition of node x and the tree arc (b.x) results in the postorder number 35 and the interval [31,35] to be assigned to node x. Similarly, the addition of node y and the tree arc (c.y) results in the postorder munber 45 and the interval [41.45] to be assigned to y. No change is required in any other part of the graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 4</head><label>4</label><figDesc>Figure 4.2. Compressed transitive closure after additions The addition of the non-tree arc (x,h) in our running example will cause the interval [11,20] associated with h to be inherited by x and the predecessors of x. However, [ 11,201 is subsumed by the interval [1,4] associated with b and hence no new interval is added to b. a or d. The resulting compressed storage structure is shown in Fig. 4.2.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>For the case of trees, this scheme is idatical to [B], wherein an intuval consisting 12 the prmrdcs nomher of rhea node and the highcat preorder number among its d-dents is assaciate.d with a node</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Direct Algorithms for Computing the Transitive Closure of Database Relations</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th hat&apos;1 Cor$ Very Large Data hses</title>
		<meeting>13th hat&apos;1 Cor$ Very Large Data hses<address><addrLine>Brighton, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-09">Sept. 1987</date>
			<biblScope unit="page" from="255" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Alpha: An Extension of Relational Algebra to Express a Class of Recursive Queries</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE 3rd Int&apos;l Co&amp; Data Engineering</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="879" to="885" />
			<date type="published" when="1987-02">Feb. 1987. July 1988</date>
			<pubPlace>Los Angeles, California</pubPlace>
		</imprint>
	</monogr>
	<note>Also in IEEE Truns. Softwme Eng.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multiprocessor Transitive Closure Algorithms</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int&apos;l Symp</title>
		<meeting>Int&apos;l Symp</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m">Databases in Parallel and Distributed Systems</title>
		<meeting><address><addrLine>Austin, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-12">Dec. 1988</date>
			<biblScope unit="page" from="56" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Efficient Management of Transitive Relationships in Large Data and Knowledge Bases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Borgida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>Murray Hill</publisher>
			<pubPlace>New Jersey</pubPlace>
		</imprint>
		<respStmt>
			<orgName>AT&amp;T Bell Laboratories Technical Memorandum</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient Implementation of Lattice Operations</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ait-Kaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Boyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lincoln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nasr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programmng Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="115" to="146" />
			<date type="published" when="1989-01">Jan. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Naive Evaluation of Recursively Defined Relations</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bancilhon</surname></persName>
		</author>
		<idno>DB-00485</idno>
		<imprint/>
	</monogr>
	<note type="report_type">Tech. Rept.</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><surname>Mcc</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<pubPlace>Austin, Texas</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficiently Updating Materialized Views</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">A P A</forename><surname>Blakeley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><surname>Tompa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">ACM-SIGMOD I986 Int&apos;l Con&amp; on Management of Data</title>
		<imprint>
			<date type="published" when="1986-05">May 1986</date>
			<biblScope unit="page" from="61" to="71" />
			<pubPlace>Washington D.C.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">CLASSIC: A Structnral Data Model for Objects</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borgida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Bra&amp;man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Resnick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1989 Int&apos;l Co@. on Mamgement of Data</title>
		<meeting>ACM-SIGMOD 1989 Int&apos;l Co@. on Mamgement of Data<address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989-06">May-June 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Bra&amp;man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">I</forename><surname>Levesque</surname></persName>
		</author>
		<title level="m">Readings in Knowledge Representation</title>
		<imprint>
			<publisher>Morgan Kauf?nann</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An Overview of the KL-ONE Knowledge Representation System</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Bra&amp;man</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Schmolze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognitive Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<date type="published" when="1985-06">April-June 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Graphical Query Language Supporting Recursion</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">0</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Co@. on Managtment of Data</title>
		<meeting>ACM SIGMOD Co@. on Managtment of Data</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="16" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Steps Toward a Knowledge-Based Software Information System</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Devanbu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Selfridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Ballard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Bra&amp;man</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>Murray Hill</publisher>
			<pubPlace>New Jersey</pubPlace>
		</imprint>
		<respStmt>
			<orgName>AT&amp;T Bell Laboratories Technical Memorandum</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">NETL: A System for Representing and Using Real-World Knowledge</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">E</forename><surname>Fahhnan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Performance Analysis of View Materialization Strategies</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1987</title>
		<meeting>ACM-SIGMOD 1987</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m">Conf. on Management of Data</title>
		<meeting><address><addrLine>San Fran&amp;co, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-05">May 1987.440453</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the Computation of the Transitive Closure of Relational Operators</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">E</forename><surname>Ioarmidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Int&apos;l Conf Very Large Data Bases</title>
		<meeting>12th Int&apos;l Conf Very Large Data Bases<address><addrLine>Kyoto, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-08">Aug. 1986</date>
			<biblScope unit="page" from="403" to="411" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An Efficient Transitive Closure Algorithm</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">E</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int&apos;l Conf</title>
		<meeting>14th Int&apos;l Conf</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Very Large Data Bases</title>
		<imprint>
			<date type="published" when="1988-08">Aug.-Sept. 1988</date>
			<pubPlace>Los Angeles, California</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Amortized Efficiency of a Path Retrieval Data Structure</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoreticul Computer Science</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="273" to="281" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A Compressed Transitive Closure Technique for Efficient Fixed-Point Query Processing</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Int&apos;l Cor$ Expert Database Systems, Tysons Comer</title>
		<meeting>2nd Int&apos;l Cor$ Expert Database Systems, Tysons Comer<address><addrLine>Virginia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-04">April 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Incorporating Hierarchy in a Relational Model of Data</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1989 Int&apos;l Confi Management of Data</title>
		<meeting>ACM-SIGMOD 1989 Int&apos;l Confi Management of Data<address><addrLine>Portland, Oregon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989-06">May-June 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Recent Developments in N&apos;IKL</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Kaczmarek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Robins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. w-86</title>
		<meeting>w-86<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="978" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Heuristic Search in Data Base Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hanson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ioatmidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebrsker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pm. 1st Int&apos;l Workshop Expert Database Systems</title>
		<imprint>
			<biblScope unit="page" from="96" to="107" />
			<date type="published" when="1984-10">Oct. 1984</date>
			<pubPlace>Kiawah Island, South Carolina</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">New Strategies for Computing the Transitive Closure of a Database Relation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. I3th Int&apos;l Conf. Very Large Data Bases</title>
		<meeting>I3th Int&apos;l Conf. Very Large Data Bases<address><addrLine>Brighton, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-09">Sept. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The Anatomy of the BACK System</title>
		<author>
			<persName><forename type="first">K</forename><surname>Luck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nehel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peltason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schmiedel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Kunstliche Intelligenz und Textverstehen -Report</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<date type="published" when="1987-01">Jan. 1987</date>
		</imprint>
		<respStmt>
			<orgName>Technical University of Berlin</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Future Directions in DBMS Research</title>
		<author>
			<persName><forename type="first">E</forename><surname>Neuhold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonehraker</surname></persName>
		</author>
		<idno>Rep.-88-001</idno>
	</analytic>
	<monogr>
		<title level="j">Int&apos;l Computer Science Inst</title>
		<imprint>
			<date type="published" when="1988-05">May 1988</date>
			<pubPlace>Berkeley, California</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech.</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A New Data Structure for Type Trees</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>O'keefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECAI-84: Advances in Artijicial Intelligence</title>
		<editor>
			<persName><forename type="first">T O'</forename><surname>Shea</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Small can he Beautiful in Knowledge Representation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Workshop on Principles of Knowledge-Based Systems</title>
		<meeting>IEEE Workshop on Principles of Knowledge-Based Systems<address><addrLine>Denver, Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984-12">Dec. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Traversal Recursion: A Practical Approach to Supporting Recursive Applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rosenthal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Heiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Manola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM-SIGMOD 1986 Int&apos;l Co@ on Manugement of Data</title>
		<meeting>ACM-SIGMOD 1986 Int&apos;l Co@ on Manugement of Data<address><addrLine>Washington D.C.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-05">May 1986</date>
			<biblScope unit="page" from="166" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Determining Type, Part, Color, and Time Relationships</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Papalaskaris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Taugher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="53" to="60" />
			<date type="published" when="1983-10">Oct. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Evaluation of Recursive Queries Using Join Indices</title>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Boral</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Ist Int&apos;l Con&amp; Expert Database Systems</title>
		<imprint>
			<biblScope unit="page" from="197" to="208" />
			<date type="published" when="1986-04">April 1986</date>
			<pubPlace>Charleston, South Carolina</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Database Support for Knowledge-Based Image</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Walter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Lockemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nagel</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<orgName type="collaboration">Evaluation</orgName>
		</author>
		<title level="m">Proc. 13th Int&apos;l Conf. Very Large Data Buses</title>
		<meeting>13th Int&apos;l Conf. Very Large Data Buses<address><addrLine>Brighton, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-09">Sept. 1987</date>
			<biblScope unit="page" from="3" to="11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
