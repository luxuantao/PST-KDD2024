<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How Fast Can Higher-Order Masking Be in Software?</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Dahmun</forename><surname>Goudarzi</surname></persName>
							<email>dahmun.goudarzi@cryptoexperts.com</email>
							<affiliation key="aff0">
								<orgName type="institution">CryptoExperts</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria and PSL Research University</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Matthieu</forename><surname>Rivain</surname></persName>
							<email>matthieu.rivain@cryptoexperts.com</email>
							<affiliation key="aff0">
								<orgName type="institution">CryptoExperts</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">How Fast Can Higher-Order Masking Be in Software?</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">430597336F369CF1754AF33CEDB94E59</idno>
					<idno type="DOI">10.1007/978-3-319-56620-7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:39+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Higher-order masking is widely accepted as a sound countermeasure to protect implementations of blockciphers against side-channel attacks. The main issue while designing such a countermeasure is to deal with the nonlinear parts of the cipher i.e. the so-called s-boxes. The prevailing approach to tackle this issue consists in applying the Ishai-Sahai-Wagner (ISW) scheme from CRYPTO 2003 to some polynomial representation of the s-box. Several efficient constructions have been proposed that follow this approach, but higher-order masking is still considered as a costly (impractical) countermeasure. In this paper, we investigate efficient higher-order masking techniques by conducting a case study on ARM architectures (the most widespread architecture in embedded systems). We follow a bottom-up approach by first investigating the implementation of the base field multiplication at the assembly level. Then we describe optimized low-level implementations of the ISW scheme and its variant (CPRR) due to Coron et al. (FSE 2013) [14]. Finally we present improved state-of-the-art polynomial decomposition methods for s-boxes with custom parameters and various implementation-level optimizations. We also investigate an alternative to these methods which is based on bitslicing at the s-box level. We describe new masked bitslice implementations of the AES and PRESENT ciphers. These implementations happen to be significantly faster than (optimized) state-of-the-art polynomial methods. In particular, our bitslice AES masked at order 10 runs in 0.48 megacycles, which makes 8 ms in presence of a 60 MHz clock frequency.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Since their introduction in the late 1990's, side-channel attacks have been considered as a serious threat against cryptographic implementations. Among the existing protection strategies, one of the most widely used relies on applying secret sharing at the implementation level, which is known as (higher-order ) masking. This strategy achieves provable security in the so-called probing security model <ref type="bibr" target="#b26">[24]</ref> and noisy leakage model <ref type="bibr" target="#b19">[17,</ref><ref type="bibr" target="#b35">32]</ref>, which makes it a prevailing way to get secure implementations against side-channel attacks.</p><p>Higher-Order Masking. Higher-order masking consists in sharing each internal variable x of a cryptographic computation into d random variables x 1 , x 2 , . . . , x d , called the shares and satisfying x 1 + x 2 + • • • + x d = x for some group operation +, such that any set of d -1 shares is randomly distributed and independent of x. In this paper, we will consider the prevailing Boolean masking which is based on the bitwise addition of the shares. It has been formally demonstrated that in the noisy leakage model, where the attacker gets noisy information on each share, the complexity of recovering information on x grows exponentially with the number of shares <ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b35">32]</ref>. This number d, called the masking order, is hence a sound security parameter for the resistance of a masked implementation.</p><p>When dth-order masking is involved to protect a blockcipher, a so-called dth-order masking scheme must be designed to enable computation on masked data. To be sound, a dth order masking scheme must satisfy the two following properties: (i) completeness, at the end of the encryption/decryption, the sum of the d shares must give the expected result; (ii) probing security, every tuple of d-1 or less intermediate variables must be independent of any sensitive variable.</p><p>Most blockcipher structures are composed of one or several linear transformation(s), and a non-linear function, called the s-box (where the linearity is considered w.r.t. the bitwise addition). Computing a linear transformation x → (x) in the masking world can be done in O <ref type="bibr">(d)</ref> complexity by applying to each share independently. This clearly maintains the probing security and the completeness holds by linearity since we have (x 1 ) + (x 2 ) + • • • + (x d ) = (x). On the other hand, the non-linear operations (such as s-boxes) are more tricky to compute on the shares while ensuring completeness and probing security.</p><p>Masked S-boxes. In <ref type="bibr" target="#b26">[24]</ref>, Ishai, Sahai, and Wagner tackled this issue by introducing the first generic higher-order masking scheme for the multiplication over F 2 in complexity O (d 2 ). The here-called ISW scheme was later used by Rivain and Prouff to design an efficient masked implementation of AES <ref type="bibr" target="#b37">[34]</ref>. Several works then followed to improve this approach and to extend it to other SPN blockciphers <ref type="bibr" target="#b11">[10,</ref><ref type="bibr" target="#b15">14,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b29">26]</ref>. The principle of these methods consists in representing an n-bit s-box as a polynomial i a i x i in F 2 n [x]/(x 2 n -x), whose evaluation is then expressed as a sequence of linear functions (e.g. squaring, additions, multiplications by constant coefficients) and nonlinear multiplications over F 2 n . The former are simply masked in complexity O <ref type="bibr">(d)</ref> (thanks to their linearity), whereas the latter are secured using ISW in complexity O (d 2 ). The total complexity is hence mainly impacted by the number of nonlinear multiplications involved in the underlying polynomial evaluation. This observation led to a series of publications aiming at conceiving polynomial evaluation methods with the least possible nonlinear multiplications <ref type="bibr" target="#b11">[10,</ref><ref type="bibr" target="#b17">15,</ref><ref type="bibr" target="#b38">35]</ref>. The so-called CRV method, due to Coron et al. <ref type="bibr" target="#b17">[15]</ref>, is currently the best known generic method with respect to this criteria.</p><p>Recently, an alternative to previous ISW-based polynomial methods was proposed by Carlet, Prouff, Rivain and Roche in <ref type="bibr" target="#b12">[11]</ref>. They introduce a so-called algebraic decomposition method that can express an s-box in terms of polynomials of low algebraic degree. They also show that a variant of ISW due to <ref type="bibr">Coron</ref> Prouff, Rivain and Roche <ref type="bibr" target="#b15">[14]</ref> can efficiently be used to secure the computation of any quadratic function. By combining the here-called CPRR scheme together with their algebraic decomposition method, Carlet et al. obtain an efficient alternative to existing ISW-based masking schemes. In particular, their technique is argued to beat the CRV method based on the assumption that an efficiency gap exists between an ISW multiplication and a CPRR evaluation. However, no optimized implementation is provided to back up this assumption.</p><p>Despite these advances, higher-order masking still implies strong performance overheads on protected implementations, and it is often believed to be impractical beyond small orders. On the other hand, most published works on the subject focus on theoretical aspects without investigating optimized low-level implementations. This raises the following question: how fast can higher-order masking be in software?</p><p>Our Contribution. In this paper, we investigate this question and present a case study on ARM (v7) architectures, which are today the most widespread in embedded systems (privileged targets of side-channel attacks). We provide an extensive and fair comparison between the different methods of the state of the art and a benchmarking on optimized implementations of higher-order masked blockciphers. For such purpose, we follow a bottom-up approach and start by investigating the efficient implementation of the base-field multiplication, which is the core elementary operation of the ISW-based masking schemes. We propose several implementations strategies leading to different time-memory trade-offs. We then investigate the two main building blocks of existing masking schemes, namely the ISW and CPRR schemes. We optimize the implementation of these schemes and we describe parallelized versions that achieve significant gains in performances. From these results, we propose fine-tuned variants of the CRV and algebraic decomposition methods, which allows us to compare them in a practical and optimized implementation context. We also investigate efficient polynomial methods for the specific s-boxes of two important blockciphers, namely AES and PRESENT.</p><p>As an additional contribution, we put forward an alternative strategy to polynomial methods which consists in applying bitslicing at the s-box level. More precisely, the s-box computations within a blockcipher round are bitsliced so that the core nonlinear operation is not a field multiplication anymore (nor a quadratic polynomial) but a bitwise logical AND between two m-bit registers (where m is the number of s-box computations). This allows us to translate compact hardware implementations of the AES and PRESENT s-boxes into efficient masked implementations in software. This approach has been previously used to design blockciphers well suited for masking <ref type="bibr" target="#b23">[21]</ref> but, to the best of our knowledge, has never been used to derive efficient higher-order masked implementations of existing standard blockciphers such as AES or PRESENT. We further provide implementation results for full blockciphers and discuss the security aspects of our implementations.</p><p>Our results clearly demonstrate the superiority of the bitslicing approach (at least on 32-bit ARM architectures). Our masked bitslice implementations of AES and PRESENT are significantly faster than state-of-the-art polynomial methods with fine-tuned low-level implementations. In particular, an encryption masked at the order 10 only takes a few milliseconds with a 60 MHz clock frequency (specifically 8 ms for AES and 5 ms for PRESENT).</p><p>Other Related Works. Our work focuses on the optimized implementation of polynomial methods for efficient higher-order masking of s-boxes and blockciphers, as well as on the bitslice alternative. All these schemes are based on Boolean masking with the ISW construction (or the CPRR variant) for the core non-linear operation (which is either the field multiplication or the bitwise logical AND). Further masking techniques exist with additional features that should be adverted here.</p><p>Genelle, Prouff and Quisquater suggest mixing Boolean masking and multiplicative masking <ref type="bibr" target="#b21">[19]</ref>. This approach is especially effective for blockciphers with inversion-based s-boxes such as AES. Prouff and Roche turn classic constructions from multi-party computation into a higher-order masking scheme resilient to glitches <ref type="bibr" target="#b36">[33]</ref>. A software implementation study comparing these two schemes and classical polynomial methods for AES has been published in <ref type="bibr" target="#b25">[23]</ref>. Compared to this previous work, our approach is to go deeper in the optimization (at the assembly level) and we further investigate generic methods (i.e. methods that apply to any s-box and not only to AES). Another worth-mentioning line of works is the field of threshold implementations <ref type="bibr" target="#b32">[29,</ref><ref type="bibr" target="#b33">30]</ref> in which the principle of threshold cryptography is applied to get secure hardware masking in the presence of glitches (see for instance <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b31">28,</ref><ref type="bibr" target="#b34">31]</ref>). Most of threshold implementations target first-order security but recent works discuss the extension to higher orders <ref type="bibr" target="#b5">[5]</ref>. It should be noted that in the context of hardware implementations, the occurrence of glitches prevents the straight use of classic ISW-based Boolean masking schemes (as considered in the present work). Threshold implementations and the Prouff-Roche scheme are therefore the main solutions for (higher-order) masking in hardware. On the other hand, these schemes are not competitive for the software context (due to limited masking orders and/or to an increased complexity) and they are consequently out of the scope of our study.</p><p>Finally, we would like to mention that subsequently to the first version of this work, and motivated by the high performances of our bitslice implementations of AES and PRESENT, we have extended the bitslice higher-order masking approach to any s-box by proposing a generic decomposition method in <ref type="bibr" target="#b22">[20]</ref>. New blockcipher designs with efficient masked bitslice implementation have also been recently proposed in <ref type="bibr" target="#b28">[25]</ref>.</p><p>Paper Organization. The next section provides some preliminaries about ARM architectures (Sect. 2). We then investigate the base field multiplication (Sect. 3) and the ISW and CPRR schemes (Sect. 4). Afterward, we study polynomial methods for s-boxes (Sect. 5) and we introduce our masked bitslice implementations of the AES and PRESENT s-boxes (Sect. 6). Eventually, we describe our implementations of the full ciphers (Sect. 7). The security aspects of our implementations are further discussed in the full version of the paper.</p><p>Source Code and Performances. For the sake of illustration, the performances of our implementations are mostly displaid on graphics in the present version. Exact performance figures (in terms of clock cycles, code size and RNG consumption) are provided in the full version of the paper (available on IACR ePrint). The source code of our implementations is also available on GitHub.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries on ARM Architectures</head><p>Most ARM cores are RISC processors composed of sixteen 32-bit registers, labeled R0, R1, . . . , R15. Registers R0 to R12 are known as variable registers and are available for computation. <ref type="foot" target="#foot_0">1</ref> The three last registers are usually reserved for special purposes: R13 is used as the stack pointer (SP), R14 is the link register (LR) storing the return address during a function call, and R15 is the program counter (PC). The link register R14 can also be used as additional variable register by saving the return address on the stack (at the cost of push/pop instructions). The gain of having a bigger register pool must be balanced with the saving overhead, but this trick enables some improvements in many cases.</p><p>In ARM v7, most of the instructions can be split into the following three classes: data instructions, memory instructions, and branching instructions. The data instructions are the arithmetic and bitwise operations, each taking one clock cycle (except for the multiplication which takes two clock cycles). The memory instructions are the load and store (from and to the RAM) which require 3 clock cycles, or their variants for multiple loads or stores (n + 2 clock cycles). The last class of instructions is the class of branching instructions used for loops, conditional statements and function calls. These instructions take 3 or 4 clock cycles.</p><p>One important specificity of the ARM assembly is the barrel shifter allowing any data instruction to shift one of its operands at no extra cost in terms of clock cycles. Four kinds of shifting are supported: the logical shift left (LSL), the logical shift right (LSR), the arithmetic shift right (ASR), and the rotate-right (ROR). All these shifting operations are parameterized by a shift length in [ <ref type="bibr">[1,</ref><ref type="bibr" target="#b35">32]</ref>] (except for the logical shift left LSL which lies in <ref type="bibr">[[0, 31]</ref>]). The latter can also be relative by using a register but in that case the instruction takes an additional clock cycle.</p><p>Eventually, we assume that our target architecture includes a fast True Random Number Generator (TRNG), that frequently fills a register with a fresh 32-bit random strings (e.g. every 10 clock cycles). The TRNG register can then be read at the cost of a single load instruction.<ref type="foot" target="#foot_1">2</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Base Field Multiplication</head><p>In this section, we focus on the efficient implementation of the multiplication over F 2 n where n is small (typically n ∈ [ <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b11">10]</ref>]). The fastest method consists in using a precomputed table mapping the 2 2n possible pairs of operands (a, b) to the output product a • b.</p><p>In the context of embedded systems, one is usually constrained on the code size and spending several kilobytes for (one table in) a cryptographic library might be prohibitive. That is why we investigate hereafter several alternative solutions with different time-memory trade-offs. Specifically, we look at the classical binary algorithm and exp-log multiplication methods. We also describe a tabulated version of Karatsuba multiplication, and another table-based method: the half-table multiplication. The obtained implementations are compared in terms of clock cycles, register usage, and code size (where the latter is mainly impacted by precomputed tables).</p><p>In the rest of this section, the two multiplication operands in F 2 n will be denoted a and b. These elements can be seen as polynomials a(x)</p><formula xml:id="formula_0">= n-1 i=0 a i x i and b(x) = n-1 i=0 b i x i over F 2 [x]/p(x)</formula><p>where the a i 's and the b i 's are binary coefficients and where p is a degree-n irreducible polynomial over F 2 [x]. In our implementations, these polynomials are simply represented as n-bit strings a = (a n-1 , . . . , a 0 ) 2 or equivalently a = n-1 i=0 a i 2 i (and similarly for b).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Binary Multiplication</head><p>The binary multiplication algorithm is the most basic way to perform a multiplication on a binary field. It consists in evaluating the following formula: <ref type="bibr">(1)</ref> by iterating over the bits of b. A formal description is given in Algorithm 1.</p><formula xml:id="formula_1">a(x) • b(x) = • • • b n-1 a(x)x + b n-2 a(x) x + b n-3 a(x) • • • x + b 0 a(x),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1. Binary multiplication algorithm</head><formula xml:id="formula_2">Input: a(x), b(x) ∈ F2[x]/p(x) Output: a(x) • b(x) ∈ F2[x]/p(x) 1. r(x) ← 0 2. for i = n -1 down to 0 do 3. r(x) ← x • r(x) mod p(x) 4.</formula><p>if bi = 1 then r(x) ← r(x) + a(x) 5. end for 6. return r(x) mod p(x)</p><p>The reduction modulo p(x) can be done either inside the loop (at Step 3 in each iteration) or at the end of the loop (at <ref type="bibr">Step 6)</ref>. If the reduction is done inside the loop, the degree of x • r(x) is at most n in each iteration. So we have</p><formula xml:id="formula_3">x • r(x) mod p(x) = x • r(x) -p(x) if r n-1 = 1 x • r(x) otherwise<label>(2)</label></formula><p>The reduction then consists in subtracting p(x) to x • r(x) if and only if r n-1 = 1 and doing nothing otherwise. In practice, the multiplication by x simply consists in left-shifting the bits of r and the subtraction of p is a simple XOR. The tricky part is to conditionally perform the latter XOR with respect to the bit r n-1 as we aim to a branch-free code. This is achieved using the arithmetic right shift<ref type="foot" target="#foot_2">3</ref> instruction (sometimes called signed shift) to compute (r 1) ⊕ (r n-1 × p) by putting r n-1 at the sign bit position, which can be done in 3 ARM instructions (3 clock cycles) as follows:</p><p>LSL $tmp , $res , # <ref type="bibr">(32 -n)</ref> ;; tmp = r_ {n -1} AND $tmp , $mod , $tmp , ASR #32 ;; tmp = p &amp; ( tmp ASR 32) EOR $res , $tmp , $res , LSL #1</p><p>;; r = ( r_ {n -1} * p) ^( r &lt;&lt; 1)</p><p>Step 4 consists in conditionally adding a to r whenever b i equals 1. Namely, we have to compute r ⊕ (b i × a). In order to multiply a by b i , we use the rotation instruction to put b i in the sign bit and the arithmetic shift instruction to fill a register with b i . The latter register is then used to mask a with a bitwise AND instruction. The overall Step 4 is performed in 3 ARM instructions <ref type="bibr">(</ref> The reduction must then be done at the end of the loop (Step 6), where we have r(x) = a(x) • b(x) which can be of degree up to 2n -2. Let r h and r be the polynomials of degree at most n -2 and n -1 such that r(x) = r h (x) • x n + r (x). Since we have r(x) mod p(x) = (r h (x) • x n mod p(x)) + r (x), we only need to reduce the high-degree part r h (x) • x n . This can be done by tabulating the function mapping the n -1 coefficients of r h (x) to the n -2 coefficients of r h (x)•x n mod p(x). The overall final reduction then simply consists in computing</p><formula xml:id="formula_4">T [r n] ⊕ (r ∧ (2 n -1)</formula><p>), where T is the corresponding precomputed table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Exp-Log Multiplication</head><p>Let g ∈ F 2 n be a generator of the multiplicative group F * 2 n . We shall denote by exp g the exponential function defined over [[0, 2 n -1]] as exp g ( ) = g , and by log g the discrete logarithm function defined over F * 2 n as log g = exp -1 g . Assume that these functions can be tabulated (which is usually the case for small values of n). The multiplication between field elements a and b can then be efficiently computed as</p><formula xml:id="formula_5">a • b = exp g (log g (a) + log g (b) mod 2 n -1) if a = 0 and b = 0 0 otherwise (3) Le us denote t = log g (a) + log g (b). We have t ∈ [[0, 2 n+1 -2]] giving t mod 2 n -1 = t -2 n + 1 if t n = 1 t otherwise (<label>4</label></formula><formula xml:id="formula_6">)</formula><p>where t n is the most significant bit in the binary expansion t = n i=0 t i 2 i , which can be rewritten as t mod 2 n -1 = (t + t n ) ∧ (2 n -1). This equation can be evaluated with 2 ARM instructions <ref type="foot" target="#foot_3">4</ref> (2 clock cycles) as follows:</p><p>ADD $tmp , $tmp , LSR #n ;; tmp = tmp + tmp &gt;&gt;n AND $tmp , #(2^n -1)</p><p>;; tmp = tmp &amp; (2^n -1)</p><p>Variant. Here again, a time-memory trade-off is possible: the exp g table can be doubled in order to handle a (n + 1)-bit input and to perform the reduction. This simply amounts to consider that exp g is defined over</p><formula xml:id="formula_7">[[0, 2 n+1 -2]] rather than over [[0, 2 n -1]].</formula><p>Zero-Testing. The most tricky part of the exp-log multiplication is to manage the case where a or b equals 0 while avoiding any conditional branch. Once again we can use the arithmetic right-shift instruction to propagate the sign bit and use it as a mask. The test of zero can then be done with 4 ARM instructions (4 clock cycles) as follows:</p><p>RSB $tmp , $opA , #0 ;; tmp = 0 -a AND $tmp , $opB , $tmp , ASR #32 ;; tmp = b &amp; ( tmp ASR 32) RSB $tmp , #0</p><p>;; tmp = 0 -tmp AND $res , $tmp , ASR #32</p><p>;; r = r &amp; ( tmp ASR 32)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Karatsuba Multiplication</head><p>The Karatsuba method is based on the following equation:</p><formula xml:id="formula_8">a • b = (a h + a )(b h + b ) x n 2 + a h b h (x n + x n 2 ) + a b (x n 2 + 1) mod p(x) (5)</formula><p>where</p><formula xml:id="formula_9">a h , a , b h , b are the n 2 -degree polynomials such that a(x) = a h x n 2 +a and b(x) = b h x n 2 + b .</formula><p>The above equation can be efficiently evaluated by tabulating the following functions:</p><formula xml:id="formula_10">(a h + a , b h + b ) → (a h + a )(b h + b ) x n 2 mod p(x), (a h , b h ) → a h b h (x n + x n 2 ) mod p(x), (a , b ) → a b (x n 2 + 1) mod p(x).</formula><p>We hence obtain a way to compute the multiplication with 3 look-ups and a few XORs based on 3 tables of 2 n elements.</p><p>In practice, the most tricky part is to get the three pairs (a h ||b h ), (a ||b ) and (a h + a ||b h + b ) to index the table with the least instructions possible. The last pair is a simple addition of the two first ones. The computation of the two first pairs from the operands a ≡ (a h ||a ) and b ≡ (b h ||b ) can then be seen as the transposition of a 2 × 2 matrix. This can be done with 4 ARM instructions (4 clock cycles) as follows: </p><formula xml:id="formula_11">EOR $tmp0 , $opA , $opB , LSR #( n /</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Half-Table Multiplication</head><p>The half-table multiplication can be seen as a trade-off between the Karatsuba method and the full-table method. While Karatsuba involves 3 look-ups in three 2 n -sized tables and the full-table method involves 1 look-up in a 2 2n -sized table, the half-table method involves 2 look-ups in two 2 3n 2 -sized tables. It is based on the following equation:</p><formula xml:id="formula_12">a • b = b h x n 2 (a h x n 2 + a ) + b (a h x n 2 + a ) mod p(x),<label>(6)</label></formula><p>which can be efficiently evaluated by tabulating the functions:</p><formula xml:id="formula_13">(a h , a , b h ) → b h x n 2 (a h x n 2 + a ) mod p(x), (a h , a , b ) → b (a h x n 2 + a ) mod p(x).</formula><p>Once again, the barrel shifter is useful to get the input triplets efficiently. Each look-up can be done with two ARM instructions (for a total of 8 clock cycles) as follows: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Performances</head><p>The obtained performances are summarized in Table <ref type="table" target="#tab_1">1</ref> in terms of clock cycles, register usage, and code size. For clock cycles, the number in brackets indicates instructions that need to be done only once when multiple calls to the multiplication are performed (as in the secure multiplication procedure described in the next section). These are initialization instructions such as loading a table address in a register. For n &gt; 8, elements take two bytes to be stored (assuming n ≤ 16) which implies an overhead in clock cycles and a doubling of the table size. For most methods, the clock cycles and register usage are constant w.r.t. n ≥ 8, whereas the code size depends on n. For the sake of illustration, we therefore additionally display the code size (and corresponding LUT sizes) in Fig. <ref type="figure" target="#fig_3">1</ref> for several values of n. We observe that all the methods provide different time-memory trade-offs except for Karatsuba which is beaten by the exp-log method (v1) both in terms of clock cycles and code size. The latter method shall then always be preferred to the former (at least on our architecture). As expected, the full-table method is by far the fastest way to compute a field multiplication, followed by the halftable method. However, depending on the value of n, these methods might be too consuming in terms of code size due to their large precomputed tables. On the other hand, the binary multiplication (even the improved version) has very poor performances in terms of clock cycles and it should only be used for extreme cases where the code size is very constrained. We consider that the exp-log method v2 (i.e. with doubled exp-table) is a good compromise between code size an speed whenever the full-table and half-table methods are not affordable (which might be the case for e.g. n ≥ 8). In the following, we shall therefore focus our study on secure implementations using the exp-log (v2), half-table or full-table method for the base field multiplication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Secure Multiplications and Quadratic Evaluations</head><p>We have seen several approaches to efficiently implement the base-field multiplication. We now investigate the secure multiplication in the masking world where the two operands a, b ∈ F 2 n are represented as random d-sharings (a 1 , a 2 , . . . , a d ) and (b 1 , b 2 , . . . , b d ). We also address the secure evaluation of a function f of algebraic degree 2 over F 2 n (called quadratic function in the following). Specifically, we focus on the scheme proposed by Ishai, Sahai, and Wagner (ISW scheme) for the secure multiplication <ref type="bibr" target="#b26">[24]</ref>, and its extension by Coron, Prouff, Rivain and Roche (CPRR scheme) to secure any quadratic function <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b15">14]</ref>  1. for every 1 ≤ i &lt; j ≤ d, sample a random value r i,j over F 2 n ; 2. for every</p><formula xml:id="formula_14">1 ≤ i &lt; j ≤ d, compute r j,i = (r i,j + a i • b j ) + a j • b i ; 3. for every 1 ≤ i ≤ d, compute c i = a i • b i + j =i r i,j . One can check that the output (c 1 , c 2 , . . . , c d ) is well a d-sharing of the product c = a • b. We indeed have i c i = i,j a i • b j = ( i a i )( j b j</formula><p>) since every random value r i,j appears exactly twice in the sum and hence vanishes.</p><p>Mask Refreshing. The ISW multiplication was originally proved probing secure at the order t = (d -1)/2 (and not d -1 as one would expect with masking order d). The security proof was later made tight under the condition that the input d-sharings are based on independent randomness <ref type="bibr" target="#b37">[34]</ref>. In some situations, this independence property is not satisfied. For instance, one might have to multiply two values a and b where a = (b) for some linear operation . In that case, the shares of a are usually derived as a i = (b i ), which clearly breaches the required independence of input shares. To deal with this issue, one must refresh the sharing of a. However, one must be careful doing so since a bad refreshing procedure might introduce a flaw <ref type="bibr" target="#b15">[14]</ref>. A sound method for maskrefreshing consists in applying an ISW multiplication between the sharing of a and the tuple (1, 0, 0, . . . , 0) <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b19">17]</ref>. This gives the following procedure:</p><p>1. for every 1 ≤ i &lt; j ≤ d, randomly sample r i,j over F 2 n and set r j,i = r i,j ; 2. for every 1</p><formula xml:id="formula_15">≤ i ≤ d, compute a i = a i + j =i r i,j .</formula><p>It is not hard to see that the output sharing (a 1 , a 2 , . . . , a d ) well encodes a. One might think that such a refreshing implies a strong overhead in performances (almost as performing two multiplications) but this is still better than doubling the number of shares (which roughly quadruples the multiplication time). Moreover, we show hereafter that the implementation of such a refreshing procedure can be very efficient in practice compared to the ISW multiplication.</p><p>CPRR Evaluation. The CPRR scheme was initially proposed in <ref type="bibr" target="#b15">[14]</ref> as a variant of ISW to securely compute multiplications of the form</p><formula xml:id="formula_16">x → x • (x)</formula><p>where is linear, without requiring refreshing. It was then shown in <ref type="bibr" target="#b12">[11]</ref> that this scheme (in a slightly modified version) could actually be used to securely evaluate any quadratic function f over F 2 n . The method is based on the following equation</p><formula xml:id="formula_17">f (x1 + x2 + • • • + x d ) = 1≤i&lt;j≤d f (xi + xj + si,j) + f (xj + si,j) + f (xi + si,j) + f (si,j) + d i=1 f (xi) + (d + 1 mod 2) • f (0)<label>(7)</label></formula><p>which holds for every</p><formula xml:id="formula_18">(x i ) i ∈ (F 2 n ) d , every (s i,j ) 1≤i&lt;j≤d ∈ (F 2 n ) d(d-1)/2</formula><p>, and every quadratic function f over F 2 n . From a d-sharing (x 1 , x 2 , . . . , x d ), the CPRR scheme computes an output d-sharing (y 1 , y 2 , . . . , y d ) as follows:</p><p>1. for every 1 ≤ i &lt; j ≤ d, sample two random values r i,j and s i,j over F 2 n , 2. for every</p><formula xml:id="formula_19">1 ≤ i &lt; j ≤ d, compute r j,i = r i,j + f (x i + s i,j ) + f (x j + s i,j ) + f ((x i + s i,j ) + x j ) + f (s i,j ), 3. for every 1 ≤ i ≤ d, compute y i = f (x i ) + j =i r i,j , 4. if d is even, set y 1 = y 1 + f (0).</formula><p>According to <ref type="bibr" target="#b7">(7)</ref>, we then have</p><formula xml:id="formula_20">d i=1 y i = f d i=1 x i ), which shows that the output sharing (y 1 , y 2 , . . . , y d ) well encodes y = f (x).</formula><p>In <ref type="bibr" target="#b12">[11,</ref><ref type="bibr" target="#b15">14]</ref> it is argued that in the gap where the field multiplication cannot be fully tabulated (2 2n elements is too much) while a function f : F 2 n → F 2 n can be tabulated (2 n elements fit), the CPRR scheme is (likely to be) more efficient than the ISW scheme. This is because it essentially replaces (costly) field multiplications by simple look-ups. We present in the next section the results of our study for our optimized ARM implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementations and Performances</head><p>For both schemes we use the approach suggested in <ref type="bibr" target="#b14">[13]</ref> that directly accumulates each intermediate result r i,j in the output share c i so that the memory cost is O <ref type="bibr">(d)</ref> instead of O(d 2 ) when the r i,j 's are stored. Detailed algorithms can be found in the appendix. The ARM implementation of these algorithms is rather straightforward and it does not make use of any particular trick.</p><p>As argued in Sect. 3.5, we consider three variants for the base field multiplication in the ISW scheme, namely the full-table method, the half-table method and the exp-log method (with doubled exp table). The obtained ISW variants are labeled ISW-FT, ISW-HT and ISW-EL in the following. The obtained performances are illustrated in Fig. <ref type="figure" target="#fig_4">2</ref> with respect to d. Note that we did not consider ISW-FT for n &gt; 8 since the precomputed tables are too huge.</p><p>These results show that CPRR indeed outperforms ISW whenever the field multiplication cannot be fully tabulated. Even the half-table method (which is more consuming in code-size) is slower than CPRR. For n ≤ 8, a CPRR evaluation asymptotically costs 1.16 ISW-FT, 0.88 ISW-HT, and 0.75 ISW-EL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Parallelization</head><p>Both ISW and CPRR schemes work on n-bit variables, each of them occupying a full 32-bit register. Since in most practical scenarios, we have n ∈ [ <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b9">8]</ref>], this situation is clearly suboptimal in terms of register usage, and presumably suboptimal in terms of timings. A natural idea to improve this situation is to use parallelization. A register can simultaneously store m := 32/n values, we can hence try to perform m ISW/CPRR computations in parallel (which would in turn enable to perform m s-box computations in parallel). Specifically, each input shares is replaced by m input shares packed into a 32-bit value. The ISW (resp. CPRR) algorithm load packed values, and perform the computation on each unpacked n-bit chunk one-by-one. Using such a strategy allows us to save multiple load and store instructions, which are among the most expensive instructions of ARM assembly (3 clock cycles). Specifically, we can replace m load instructions by a single one for the shares a i , b j in ISW (resp. x i , x j in CPRR) and the random values r i,j , s i,j (read from the TRNG), we can replace m store instructions by a single one for the output shares, and we can replace m XOR instructions by a single one for some of the addition involved in ISW (resp. CPRR). On the other hand, we get an overhead for the extraction of the n-bit chunks from the packed 32-bit values. But each of these extractions takes a single clock cycle (thanks to the barrel shifter), which is rather small compared to the gain in load and store instructions.</p><p>We implemented parallel versions of ISW and CPRR for n = 4 and n = 8. For the former case, we can perform m = 8 evaluations in parallel, whereas for the later case we can perform m = 4 evaluations in parallel. For n = 4, we only implemented the full-table multiplication for ISW, since we consider that a 256-byte table in code is always affordable. For n = 8 on the other hand, we did not implement the full-table, since we consider that a 64-KB table in code would be to much in most practical scenarios. Figures <ref type="figure" target="#fig_5">3</ref> and<ref type="figure" target="#fig_6">4</ref> give the obtained performances in terms of clock cycles.  These results show the important gain obtained by using parallelism. For ISW, we get an asymptotic gain around 30% for 4 parallel evaluations (n = 8) compared to 4 serial evaluations, and we get a 58% asymptotic gain for 8 parallel evaluations (n = 4) compared to 8 serial evaluations. For CPRR, the gain is around 50% (timings are divided by 2) in both cases (n = 8 and n = 4). We also observe that the efficiency order keeps unchanged with parallelism, that is: ISW-FT &gt; CPRR &gt; ISW-HT &gt; ISW-EL.</p><p>Remark 1. Note that using parallelization in our implementations does not compromise the probing security. Indeed, we pack several bytes/nibbles within one word of the cipher state but we never pack (part of) different shares of the same variable together. The probing security proofs hence apply similarly to the parallel implementations. 5   5 Putting several shares of the same variable in a single register would induce a security flaw in the probing model where full registers can be probed. For this reason, we avoid doing so and we stress that parallelization does not result in such an undesired result. However, it should be noted that in some other relevant security models, such as the single-bit probing model or the bounded moment leakage model <ref type="bibr" target="#b3">[3]</ref>, this would not be an issue anyway.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Mask-Refreshing Implementation</head><p>The ISW-based mask refreshing is pretty similar to an ISW multiplication, but it is actually much faster since it involves no field multiplications and fewer additions (most terms being multiplied by 0). It simply consists in processing:</p><p>for i = 1 .. d : for j = i + 1 .. d : r ← $; a i ← a i + r; a j ← a j + r;</p><p>A straightforward implementation of this process is almost 3 times faster than the fastest ISW multiplication, namely the full-table one (see Fig. <ref type="figure" target="#fig_7">5</ref>). We can actually do much better. Compared to a standard ISW implementation, the registers of the field multiplication are all available and can hence be used in order to save several loads and stores. Indeed, the straightforward implementation performs di + 1 loads and stores for every i ∈ [ <ref type="bibr">[1, d]</ref>], specifically 1 load-store for a i and di for the a j 's. Since we have some registers left, we can actually pool the a j 's loads and stores for several a i 's. To do so, we load several shares a i , a i+1 , . . . , a i+k with the LDM instruction (which has a cost of k + 2 instead of 3k) and process the refreshing between them. Then, for every</p><formula xml:id="formula_21">j ∈ [[i + k + 1, d]],</formula><p>we load a j , performs the refreshing between a j and each of the a i , a i+1 , . . . , a i+k , and store a j back. Afterwards, the shares a i , a i+1 , . . . , a i+k are stored back with the STM instruction (which has a cost of k + 2 instead of 3k). This allows us to load (and store) the a j only once for the k shares instead of k times, and to take advantage of the LDM and STM instructions. In practice, we could deal with up to k = 8 shares at the same time, meaning that for d ≤ 8 all the shares could be loaded and stored an single time using LDM and STM instructions. The performances of our implementations of the ISW-based mask refreshing are plotted in Fig. <ref type="figure" target="#fig_7">5</ref>. Our optimized refreshing is up to 3 times faster than the straightforward implementation and roughly 10 times faster that the full-tablebased ISW multiplication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Polynomial Methods for S-boxes</head><p>This section addresses the efficient implementation of polynomial methods for s-boxes based on ISW and CPRR schemes. We first investigate the two best known generic methods, namely the CRV method <ref type="bibr" target="#b17">[15]</ref>, and the algebraic decomposition method <ref type="bibr" target="#b12">[11]</ref>, for which we propose some improvements. We then look at specific methods for the AES and PRESENT s-boxes, and finally provide extensive comparison of our implementation results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">CRV Method</head><p>The CRV method was proposed by Coron, Roy and Vivek in <ref type="bibr" target="#b17">[15]</ref>. Before recalling its principle, let us introduce the notion of cyclotomic class. For a given integer n,</p><formula xml:id="formula_22">the cyclotomic class of α ∈ [[0, 2 n -2]] is defined as C α = {α•2 i mod 2 n -1; i ∈ N}.</formula><p>We have the following properties: (i) cyclotomic classes are equivalence classes partitioning [[0, 2 n -2]], and (ii) a cyclotomic class has at most n elements. In the following, we denote by x L the set of monomials {x α ; α ∈ L} for some set</p><formula xml:id="formula_23">L ⊆ [[0, 2 n -1]].</formula><p>The CRV method consists in representing an s-box S(x) over</p><formula xml:id="formula_24">F 2 n [x]/(x 2 n -x) as S(x) = t-1 i=1 p i (x) • q i (x) + p t (x),<label>(8)</label></formula><p>where p i (x) and q i (x) are polynomials with monomials in x L for some set L = C α1=0 ∪C α2=1 ∪C α3 ∪. . .∪C α such that for every i ≥ 3, α i = α j +α k mod 2 n -1 for some j, k &lt; i (or more generally</p><formula xml:id="formula_25">α i = 2 w • α j + α k mod 2 n -1 with k ∈ [[0, n -1]]</formula><p>). Such polynomials can be written as:</p><formula xml:id="formula_26">p i (x) = j=2 l i,j (x αj ) + c i,0 and q i (x) = j=2 l i,j (x αj ) + c i,0 ,<label>(9)</label></formula><p>where the l i,j , l i,j are linearized polynomials over F 2 n [x]/(x 2 nx) and where the c i,0 , c i,0 are constants in F 2 n . In <ref type="bibr" target="#b17">[15]</ref>, the authors explain how to find such a representation. In a nutshell, one randomly picks the q i 's and search for p i 's satisfying <ref type="bibr" target="#b9">(8)</ref>. This amounts to solve a linear system with 2 n equations and t • |L| unknowns (the coefficients of the p i 's). Note that when the choice of the classes and the q i 's leads to a solvable system, then it can be used with any s-box (since the s-box is the target vector of the linear system). We then have two necessary (non sufficient) conditions for such a system to be solvable: (1) the set L of cyclotomic classes is such that t • |L| ≥ 2 n , (2) all the monomials can be reached by multiplying two monomials from x L , that is</p><formula xml:id="formula_27">{x i • x j mod (x 2 n -x); i, j ∈ L} = x [[0,2 n -1]]</formula><p>. For the sake of efficiency, the authors of <ref type="bibr" target="#b17">[15]</ref> impose an additional constraint for the choice of the classes: (3) every class (but C 0 = {0}) have the maximal cardinality of n. Under this additional constraint, condition (1) amounts to the following inequality:</p><formula xml:id="formula_28">t • 1 + n • ( -1)) ≥ 2 n .</formula><p>Minimizing the number of nonlinear multiplications while satisfying this constraint leads to parameters t ≈ 2 n /n and ≈ 2 n /n.</p><p>Based on the above representation, the s-box can be evaluated using ( -2) + (t -1) nonlinear multiplications (plus some linear operations). In a first phase, one generates the monomials corresponding to the cyclotomic classes in L. Each x αi can be obtained by multiplying two previous x αj and x α k (where x αj might be squared w times if necessary). In the masking world, each of these multiplications is performed with a call to ISW. The polynomials p i (x) and q i (x) can then be computed according to <ref type="bibr" target="#b10">(9)</ref>. In practice the linearized polynomials are tabulated so that at masked computation, applying a l i,j simply consists in performing a look-up on each share of the corresponding x αj . In the second phase, one simply evaluates <ref type="bibr" target="#b9">(8)</ref>, which takes t -1 nonlinear multiplications plus some additions. We recall that in the masking world, linear operation such as additions or linearized polynomial evaluations can be applied on each share independently yielding a O(d) complexity, whereas nonlinear multiplications are computed by calling ISW with a O(d 2 ) complexity. The performances of the CRV method is hence dominated by the + t -3 calls to ISW.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mask Refreshing.</head><p>As explained in Sect. 4.1, one must be careful while composing ISW multiplications with linear operations. In the case of the CRV method, ISW multiplications are involved on sharings of values q i (x) and p i (x) which are linearly computed from the sharings of the x αj (see <ref type="bibr" target="#b10">(9)</ref>). This contradicts the independence requirement for the input sharings of an ISW multiplication, and this might presumably induce a flaw as the one described in <ref type="bibr" target="#b15">[14]</ref>. In order to avoid such a flaw in our masked implementation of CRV, we systematically refreshed one of the input sharings, namely the sharing of q i (x). As shown in Sect. 4.4, the overhead implied by such a refreshing is manageable.</p><p>Improving CRV with CPRR. As suggested in <ref type="bibr" target="#b12">[11]</ref>, CRV can be improved by using CPRR evaluations instead of ISW multiplications in the first phase of CRV, whenever CPRR is faster than ISW (i.e. when full-table multiplication cannot be afforded). Instead of multiplying two previously computed powers x αj and x α k , the new power x αi is derived by applying the quadratic function x → x 2 w +1 for some w ∈ [ <ref type="bibr">[1, n -1]</ref>]. In the masking world, securely evaluating such a function can be done with a call to CPRR. The new chain of cyclotomic classes</p><formula xml:id="formula_29">C α1=0 ∪ C α2=1 ∪ C α3 ∪ . . . ∪ C α must then satisfy α i = (2 w + 1)α j for some j &lt; i and w ∈ [[1, n -1]].</formula><p>We have implemented the search of such chains of cyclotomic classes satisfying conditions (1), ( <ref type="formula" target="#formula_3">2</ref>) and (3). We could validate that for every n ∈ [ <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b11">10]</ref>] and for the parameters ( , t) given in <ref type="bibr" target="#b17">[15]</ref>, we always find such a chain leading to a solvable system. For the sake of code compactness, we also tried to minimize the number of CPRR exponents 2 w + 1 used in these chains (since in practice each function x → x 2 w +1 is tabulated). For n ∈ {4, 6, 7} a single CPRR exponent (either 3 or 5) is sufficient to get a satisfying chain (i.e. a chain of cyclotomic class fulfilling the above conditions and leading to a solvable system). For the other values of n, we could prove that a single CPRR exponent does not suffice to get a satisfying chain. We could then find satisfying chains for n = 5 and n = 8 using 2 CPRR exponents (specifically 3 and 5). For n &gt; 8, we tried all the pairs and triplets of possible CPRR exponents without success, we could only find a satisfying chain using the 4 CPRR exponents 3, 5, 9 and 17.</p><p>Optimizing CRV Parameters. We can still improve CRV by optimizing the parameters ( , t) depending on the ratio θ = CCPRR CISW , where C CPRR and C ISW denote the costs of ISW and CPRR respectively. The cost of the CRV method satisfies</p><formula xml:id="formula_30">C CRV = ( -2) C CPRR + (t -1) C ISW = ( -2) • θ + t -1) C ISW ≥ ( -2) • θ + 2 n ( -1) • n + 1 -1 C ISW</formula><p>where the inequality holds from conditions ( <ref type="formula">1</ref>) and ( <ref type="formula">3</ref>) above. This lower bound ensures that the system contains enough unknowns to be solvable. In practice, it was observed in <ref type="bibr" target="#b17">[15]</ref> that this is a sufficient condition most of the time to get a solvable system (and our experiments corroborate this fact). Our optimized version of CRV hence consists in using the parameter minimizing the above lower bound and the corresponding t =</p><formula xml:id="formula_31">2 n ( -1)•n+1</formula><p>as parameters for given bit-length n and cost ratio θ.</p><p>It can be checked (see full version) that a ratio slightly lower than 1 implies a change of optimal parameters for all values of n except 4 and 9. In other words, as soon as CPRR is slightly faster than ISW, using a higher (i.e. more cyclotomic classes) and therefore a lower t is a sound trade. For our implementations of ISW and CPRR (see Sect. 4), we obtained a ratio θ greater than 1 only when ISW is based on the full-table multiplication. In that case, no gain can be obtain from using CPRR in the first phase of CRV, and one should use the original CRV parameters. On the other hand, we obtained θ-ratios of 0.88 and 0.75 for halftable-based ISW and exp-log-based ISW respectively. For the parallel versions, these ratios become 0.69 (half-table ISW) and 0.58 (exp-log ISW). For such ratios, the optimal parameter is greater than in the original CRV method (see full version for details).</p><p>For n ∈ {6, 8, 10}, we checked whether we could find satisfying CPRR-based chains of cyclotomic classes, for the obtained optimal parameters. For n = 6, the optimal parameters are ( , t) = (5, 3) (giving 3 CPRR plus 2 ISW) which are actually the original CRV parameters. We could find a satisfying chain for these parameters. For n = 8, the optimal parameters are ( , t) = (9, 4) (giving 7 CPRR plus 3 ISW). For these parameters we could not find any satisfying chain. We therefore used the second best set of parameters that is ( , t) = (8, 5) (giving 6 CPRR plus 4 ISW) for which we could find a satisfying chain. For n = 10, the optimal parameters are ( , t) = (14, 8) (giving 12 CPRR plus 7 ISW). For these parameters we could neither find any satisfying chain. So once again, we used the second best set of parameters, that is ( , t) = (13, 9) (giving 11 CPRR plus 8 ISW) and for which we could find a satisfying chain. All the obtained satisfying CPRR-based chains of cyclotomic classes are provided in the full version of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2. Performances of CRV original version and improved version (with and without optimized parameters).</head><p>Original CRV <ref type="bibr" target="#b17">[15]</ref> CRV with CPRR <ref type="bibr" target="#b12">[11]</ref> Optimized Table <ref type="table">2</ref> compares the performances of the original CRV method and the improved versions for our implementation of ISW (half-table and exp-log variants) and CPRR. <ref type="foot" target="#foot_4">6</ref> For the improved methods, we give the ratio of asymptotic performances with respect to the original version. This ratio ranks between 79% and 94% for the improved version and between 75% and 93% for the improved version with optimized parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Algebraic Decomposition Method</head><p>The algebraic decomposition method was recently proposed by Carlet, Prouff, Rivain and Roche in <ref type="bibr" target="#b12">[11]</ref>. It consists in using a basis of polynomials (g 1 , g 2 , . . . , g r ) that are constructed by composing polynomials f i as follows</p><formula xml:id="formula_32">g 1 (x) = f 1 (x) g i (x) = f i g i-1 (x)<label>(10)</label></formula><p>The f i 's are of given algebraic degree s. In our context, we consider the algebraic decomposition method for s = 2, where the f i 's are (algebraically) quadratic polynomials. The method then consists in representing an s-box S(x) over</p><formula xml:id="formula_33">F 2 n [x]/(x 2 n -x) as S(x) = t i=1 p i q i (x) + r i=1 i g i (x) + 0 (x),<label>(11)</label></formula><p>with</p><formula xml:id="formula_34">q i (x) = r j=1 i,j g j (x) + i,0 (x),<label>(12)</label></formula><p>where the p i 's are quadratic polynomials over F 2 n [x]/(x 2 nx), and where the i 's and the i,j 's are linearized polynomials over</p><formula xml:id="formula_35">F 2 n [x]/(x 2 n -x).</formula><p>As explain in <ref type="bibr" target="#b12">[11]</ref>, such a representation can be obtained by randomly picking some f i 's and some i,j 's (which fixes the q i 's) and then search for p i 's and i 's satisfying <ref type="bibr" target="#b12">(11)</ref>. As for the CRV method, this amounts to solve a linear system with 2 n equations where the unknowns are the coefficients of the p i 's and the i 's. Without loss of generality, we can assume that only 0 has a constant terms. In that case, each p i is composed of 1  2 n(n + 1) monomials, and each i is composed of n monomials (plus a constant term for 0 ). This makes a total of 1  2 n (n + 1) • t + n • r + 1 unknown coefficients. In order to get a solvable system we hence have the following condition: (1) 1  2 n (n + 1)</p><formula xml:id="formula_36">• t + n • r + 1 ≥ 2 n .</formula><p>A second condition is (2) 2 r+1 ≥ n, otherwise there exists some s-box with algebraic degree greater than 2 r+1 that cannot be achieved with the above decomposition i.e. the obtained system is not solvable for every target S.</p><p>Based on the above representation, the s-box can be evaluated using r + t evaluations of quadratic polynomials (the f i 's and the q i 's). In the masking world, this is done thanks to CPRR evaluations. The rest of computation are additions and (tabulated) linearized polynomials which are applied to each share independently with a complexity linear in d. The cost of the algebraic decomposition method is then dominated by the r + t calls to CPRR.</p><p>We implemented the search of sound algebraic decompositions for n ∈ [ <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b11">10]</ref>]. Once again, we looked for full rank systems i.e. systems that would work with any target s-box. For each value of n, we set r to the smallest integer satisfying condition (2) i.e. r ≥ log 2 (n) -1, and then we looked for a t starting from the lower bound t ≥ 2(2 n -rn-1) n(n+1) (obtained from condition (1)) and incrementing until a solvable system can be found. We then increment r and reiterate the process with t starting from the lower bound, and so on. For n ≤ 8, we found the same parameters as those reported in <ref type="bibr" target="#b12">[11]</ref>. For n = 9 and n = 10 (these cases were not considered in <ref type="bibr" target="#b12">[11]</ref>), the best parameters we obtained were (r, t) = (3, 14) and (r, t) = (4, 22) respectively.</p><p>Saving Linear Terms. In our experiments, we realized that the linear terms i g i (x) could always be avoided in <ref type="bibr" target="#b12">(11)</ref>. Namely, for the best known parameters (r, t) for every n ∈ [ <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b11">10]</ref>], we could always find a decomposition S(x) = t i=1 p i q i (x) hence saving r + 1 linearized polynomials. This is not surprising if we compare the number of degrees of freedom brought by the p i 's in the linear system (i.e. 1  2 n (n + 1) • t) to those brought by the i 's (i.e. n • r). More details are given in the full version of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Specific Methods for AES and PRESENT</head><p>Rivain-Prouff (RP) Method for AES. Many works have proposed masking schemes for the AES s-box and most of them are based on its peculiar algebraic structure. It is the composition of the inverse function x → x 254 over F 2 8 and an affine function: S(x) = Aff(x 254 ). The affine function being straightforward to mask with linear complexity, the main issue is to design an efficient masking scheme for the inverse function.</p><p>In <ref type="bibr" target="#b37">[34]</ref>, Rivain and Prouff introduced the approach of using an efficient addition chain for the inverse function that can be implemented with a minimal number of ISW multiplications. They show that the exponentiation to the 254 can be performed with 4 nonlinear multiplications plus some (linear) squarings, resulting in a scheme with 4 ISW multiplications. In <ref type="bibr" target="#b15">[14]</ref>, Coron et al. propose a variant where two of these multiplications are replaced CPRR evaluations (of the functions x → x 3 and x → x 5 ). 7 This was further improved by Grosso et al. in <ref type="bibr" target="#b24">[22]</ref> who the following addition chain leading to 3 CPRR evaluations and one ISW multiplications: x 254 = (x 2 • ((x 5 ) 5 ) 5 ) 2 . This addition chain has the advantage of requiring a single function x → x 5 for the CPRR evaluation (hence a single LUT for masked implementation). Moreover it can be easily checked by exhaustive search that no addition chain exists that trades the last ISW multiplication for a CPRR evaluation. We therefore chose to use the Grosso et al. addition chain for our implementation of the RP method.</p><p>Kim-Hong-Lim (KHL) Method for AES. This method was proposed in <ref type="bibr" target="#b29">[26]</ref> as an improvement of the RP scheme. The main idea is to use the tower field representation of the AES s-box <ref type="bibr" target="#b39">[36]</ref> in order to descend from F 2 8 to F 2 4  where the multiplications can be fully tabulated. Let δ denote the isomorphism mapping F 2 8 to (F 2 4 ) 2 with F 2 8 ≡ F 2 4 [x]/p(x), and let γ ∈ F 2 8 and λ ∈ F 2 4 such that p(x) = x 2 + x + λ and p(γ) = 0. The tower field method for the AES s-box works as follows:</p><formula xml:id="formula_37">1 a h γ + a l = δ(x), a h , a l ∈ F 2 4 4 a h = d a j ∈ F 2 4 2 d = λ a 2 h + a l • (a h + a l ) ∈ F 2 4 5 a l = d (a h + a l ) ∈ F 2 4 3. d = d 14 ∈ F 2 4 6. S(x) = Aff(δ -1 (a h γ + a l )) ∈ F 2 8</formula><p>At the third step, the exponentiation to the 14 can be performed as d 14 = (d 3 ) 4 • d 2 leading to one CPRR evaluation (for d → d 3 ) and one ISW multiplication (plus some linear squarings). 8 This gives a total of 4 ISW multiplications and one CPRR evaluation for the masked AES implementation. F •G Method for PRESENT. As a 4-bit s-box, the PRESENT s-box can be efficiently secured with the CRV method using only 2 (full table) ISW multiplications. The algebraic decomposition method would give a less efficient implementation with 3 CPRR evaluations. Another possible approach is to use the fact that the PRESENT s-box can be expressed as the composition of two quadratic functions S(x) = F • G(x). This representation was put forward by Poschmann et al. in <ref type="bibr" target="#b34">[31]</ref> to design an efficient threshold implementation of PRESENT. In our 7 The original version of the RP scheme <ref type="bibr" target="#b37">[34]</ref> actually involved a weak mask refreshing procedure which was exploited in <ref type="bibr" target="#b15">[14]</ref> to exhibit a flaw in the s-box processing.</p><p>The CPRR variant of ISW was originally meant to patch this flaw but the authors observed that using their scheme can also improve the performances. The security of the obtained variant of the RP scheme was recently verified up to masking order 4 using program verification techniques <ref type="bibr" target="#b2">[2]</ref>. 8 The authors of <ref type="bibr" target="#b29">[26]</ref> suggest to perform d 3 = d 2 •d with a full tabulated multiplication but this would actually imply a flaw as described in <ref type="bibr" target="#b15">[14]</ref>. That is why we use a CPRR evaluation for this multiplication.</p><p>context, this representation can be used to get a masked s-box evaluation based on 2 CPRR evaluations. Note that this method is asymptotically slower than CRV with 2 full-table ISW multiplications. However, due to additional linear operations in CRV, F • G might actually be better for small values of d.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Implementations and Performances</head><p>We have implemented the CRV method and the algebraic decomposition method for the two most representative values of n = 4 and n = 8. For n = 4, we used the full- We also implemented the specific methods described in Sect. 5.3 for the AES and PRESENT s-boxes, as well as their parallel counterparts. Specifically, we implemented the F • G method for PRESENT and the RP and KHL methods for AES. The RP method was implemented with both the half-table and the exp-log methods for the ISW multiplication. For the KHL method, the ISW multiplications and the CPRR evaluation are performed on 4-bit values. It was then possible to perform 8 evaluations in parallel. Specifically, we first apply the isomorphism δ on 8 s-box inputs to obtain 8 pairs (a h , a l ). The a h values are grouped in one register and the a l values are then grouped in a second register. The KHL method can then be processed in a 8-parallel version relying on the parallel ISW and CPRR procedures for n = 4.</p><p>Our implementation results (in terms of clock cycles) are depicted in Figs. <ref type="figure" target="#fig_8">6</ref> and<ref type="figure" target="#fig_9">7</ref> for n = 4 (with the F • G method as a particular case), in Figs. <ref type="figure">8</ref> and<ref type="figure">9</ref> for n = 8, and in Figs. 10 and 11 for the AES s-box.    We observe that the CRV method is clearly better than the algebraic decomposition method for n = 4 in both the serial and parallel case. This is not surprising since the former involves 2 calls to ISW-FT against 3 calls to CPRR for the latter. For n = 8, CRV is only slightly better than the algebraic decomposition, which is due to the use of CPRR and optimized parameters, as explained in Sect. 5.1. On the other hand, the parallel implementation of the algebraic decomposition method becomes better than CRV which is due to the efficiency of the CPRR parallelization.</p><p>Regarding the specific case of PRESENT, we see that the F • G method is actually better than CRV for d ∈ [ <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b11">10]</ref>] thought it is asymptotically slower. It can be checked (see full version) that CRV becomes faster only after d ≥ 38. In parallel, F • G is also faster than CRV until d ≥ 11. This shows that the F • G method offers a valuable alternative to the CRV method for PRESENT in practice. Note that many 4-bit s-boxes have a similar decomposition (see <ref type="bibr" target="#b6">[6]</ref> for an extensive analysis), so this method could be applied to further blockciphers.</p><p>For the AES, we observe that the RP method is better than KHL, which means that the gain obtained by using full-table multiplications does not compensate the overhead implied by the additional multiplication required in KHL compared to RP. We also see that the two versions of RP are very closed, which is not surprising since the difference regards a single multiplication (the other ones relying on CPRR). Using ISW-HT might not be interesting in this context given the memory overhead. For the parallel versions, KHL becomes better since it can perform 8 evaluations simultaneously, whereas RP is bounded to a parallelization degree of 4. This shows that though the field descent from F 2 8 to F 2 4 might be nice for full tabulation, it is mostly interesting for increasing the parallelization degree.</p><p>Eventually as a final and global observation, we clearly see that using parallelism enables significant improvements. The timings of parallel versions rank between 40% and 60% of the corresponding serial versions. In the next section, we push the parallelization one step further, namely we investigate bitslicing for higher-order masking implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Bitslice Methods for S-boxes</head><p>In this section, we focus on the secure implementation of AES and PRESENT sboxes using bitslice. Bitslice is an implementation strategy initially proposed by Biham in <ref type="bibr" target="#b4">[4]</ref>. It consists in performing several parallel evaluations of a Boolean circuit in software where the logic gates can be replaced by instructions working on registers of several bits. As nicely explained in <ref type="bibr" target="#b30">[27]</ref>, "in the bitslice implementation one software logical instruction corresponds to simultaneous execution of m hardware logical gates, where m is a register size [...] Hence bitslice can be efficient when the entire hardware complexity of a target cipher is small and an underlying processor has many long registers."</p><p>In the context of higher-order masking, bitslice can be used at the s-box level to perform several secure s-box computations in parallel. One then need a compact Boolean representation of the s-box, and more importantly a representation with the least possible nonlinear gates. These nonlinear gates can then be securely evaluated in parallel using the ISW scheme as detailed hereafter. Such an approach was applied in <ref type="bibr" target="#b23">[21]</ref> to design blockciphers with efficient masked computations. To the best of our knowledge, it has never been applied to get fast implementations of classical blockciphers such as AES or PRESENT. Also note that a bitsliced implementation of AES masked at first and second orders was described in <ref type="bibr">[1]</ref> and used as a case study for practical side-channel attacks on a ARM Cortex-A8 processor running at 1 GHz.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">ISW Logical AND</head><p>The ISW scheme can be easily adapted to secure a bitwise logical AND between two m-bit registers. From On the ARM architecture considered in this paper, registers are of size m = 32 bits. We can hence perform 32 secure logical AND in parallel. Moreover a logical AND is a single instruction of 1 clock cycle in ARM so we expect the above ISW logical AND to be faster than the ISW field multiplications. The detailed performances of our ISW-AND implementation are provided in the full version. We observe that the ISW-AND is indeed faster than the fastest ISW field multiplication (i.e. ISW-FT). Moreover it does not require any precomputed table and is hence lighter in code than the ISW field multiplications (except for the binary multiplication which is very slow).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Secure Bitslice AES S-box</head><p>For the AES s-box, we based our work on the compact representation proposed by Boyar et al. in <ref type="bibr" target="#b9">[8]</ref>. Their circuit is obtained by applying logic minimization techniques to the tower-field representation of Canright <ref type="bibr" target="#b10">[9]</ref>. It involves 115 logic gates including 32 logical AND. The circuit is composed of three parts: the top linear transformation involving 23 XOR gates and mapping the 8 s-box input bits x 0 , x 1 , . . . , x 7 to 23 new bits x 7 , y 1 , y 2 , . . . , y 21 ; the middle non-linear transformation involving 30 XOR gates and 32 AND gates and mapping the previous 23 bits to 18 new bits z 0 , z 1 , . . . , z 17 ; and the bottom linear transformation involving 26 XOR gates and 4 XNOR gates and mapping the 18 previous bits to the 8 s-box output bits s 0 , s 1 , . . . , s 7 . In particular, this circuit improves the usual count of 34 AND gates involved in previous tower-field representations of the AES s-box.</p><p>Using this circuit, we can perform the 16 s-box computations of an AES round in parallel. That is, instead of having 8 input bits mapped to 8 output bits, we have 8 (shared) input 16-bit words X 0 , X 1 , . . . , X 7 mapped to 8 (shared) output 16-bit words S 1 , S 2 , . . . , S 8 . Each word X i (resp. S i ) contains the ith bits input bit (resp. output bit) of the 16 s-boxes. Each XOR gate and AND gate of the original circuit is then replaced by the corresponding (shared) bitwise instruction between two 16-bit words.</p><p>Parallelizing AND Gates. For our masked bitslice implementation, a sound complexity unit is one call to the ISW-AND since this is the only nonlinear operation, i.e. the only operation with quadratic complexity in d (compared to other operations that are linear in d). In a straightforward bitslice implementation of the considered circuit, we would then have a complexity of 32 ISW-AND. This is suboptimal since each of these ISW-AND is applied to 16-bit words whereas it can operates on 32-bit words. Our main optimization is hence to group together pairs of ISW-AND in order to replace them by a single ISW-AND with fully filled input registers. This optimization hence requires to be able to group AND gates by pair that can be computed in parallel. To do so, we reordered the gates in the middle non-linear transformation of the Boyar et al. circuit, while keeping the computation consistent. We were able to fully parallelize the AND gates, hence dropping our bitslice complexity from 32 down to 16 ISW-AND. We thus get a parallel computation of the 16 AES s-boxes of one round with a complexity of 16 ISW-AND, that is one single ISW-AND s-box. Since an ISW-AND is (significantly) faster than any ISW multiplication, our masked bitslice implementation breaks through the barrier of one ISW field multiplication per s-box. Our reordered version of the Boyar et al. circuit is provided in the full version of the paper. Mask Refreshing. As for the CRV method, our bitslice AES s-box makes calls to ISW with input sharings that might be linearly related. In order to avoid any flaw, we systematically refreshed one of the input sharings in our masked implementation. Here again, the implied overhead is mitigated (between 5% and 10%).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Secure Bitslice PRESENT S-box</head><p>For our masked bitslice implementation of the PRESENT s-box, we used the compact representation given by Courtois et al. in <ref type="bibr" target="#b18">[16]</ref>, which was obtained from Boyar et al. 's logic minimization techniques improved by involving OR gates. This circuit is composed of 4 nonlinear gates (2 AND and 2 OR) and 9 linear gates (8 XOR and 1 XNOR).</p><p>PRESENT has 16 parallel s-box computations per round, as AES. We hence get a bitslice implementation with 16-bit words that we want to group for the calls to ISW-AND. However for the chosen circuit, we could not fully parallelize the nonlinear gates because of the dependency between three of them. We could however group the two OR gates after a slight reordering of the operations. We hence obtain a masked bitslice implementation computing the 16 PRESENT sboxes in parallel with 3 calls to ISW-AND. Our reordered version of the circuit is depicted in the full version of the paper. For the sake of security, we also refresh one of the two input sharings in the 3 calls to ISW-AND. As for the bitslice AES s-box, the implied overhead is manageable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Implementation and Performances</head><p>Figures 12 and 13 plot the performances obtained for our masked bitslice implementations of the AES and PRESENT s-boxes. For comparison, we also recall the performances of the fastest polynomial methods for AES and PRESENT (i.e. parallel versions of KHL and F • G) as well as the fastest generic methods for n = 8 and n = 4 (i.e. parallel versions of the algebraic decomposition method for n = 8 and CRV for n = 4).</p><p>These results clearly demonstrate the superiority of the bitslicing approach. Our masked bitslice implementations of the AES and PRESENT s-boxes are significantly faster than state-of-the art polynomial methods finely tuned at the assembly level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Cipher Implementations</head><p>This section finally describes masked implementations of the full PRESENT and AES blockciphers. These blockciphers are so-called substitution-permutation networks, where each round is composed of a key addition layer, a nonlinear layer and a linear diffusion layer. For both blockciphers, the nonlinear layer consists in the parallel application of 16 s-boxes. The AES works on a 128-bit state (which divides into sixteen 8-bit s-box inputs) whereas PRESENT works on a 64-bit state (which divides into sixteen 4-bit s-box inputs). For detailed specifications of these blockciphers, the reader is referred to <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b20">18]</ref>. For both blockciphers, we follow two implementation strategies: the standard one (with parallel polynomial methods for s-boxes) and the bitslice one (with bitslice s-box masking).</p><p>For the sake of efficiency, we assume that the key is already expanded, and for the sake of security we assume that each round key is stored in (non-volatile) memory under a shared form. In other words, we do not perform a masked key schedule. Our implementations start by masking the input plaintext with d -1 random m-bit strings (where m is the blockcipher bit-size) and store the d resulting shares in memory. These d shares then compose the sharing of the blockcipher state that is updated by the masked computation of each round. When all the rounds have been processed, the output ciphertext is recovered by adding all the output shares of the state. For the bitslice implementations, the translation from standard to bitslice representation is performed before the initial masking so that it is done only once. Similarly, the translation back from the bitslice to the standard representation is performed a single time after unmasking.</p><p>The secure s-box implementations are done as described in previous sections. It hence remains to deal with the key addition and the linear layers. These steps are applied to each share of the state independently. The key-addition step simply consists in adding each share of the round key to one share of the state. The linear layer implementations are described in the full version of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Performances</head><p>In our standard implementation of AES, we used the parallel versions of KHL and RP (with ISW-EL) for the s-box. For the standard implementation of PRE-SENT, we used the parallel versions of the F •G method and of the CRV method.  The obtained performances are summarized in Table <ref type="table" target="#tab_4">3</ref>. The timings are further plotted in Figs. 14 and 15 for illustration. These results clearly confirm the superiority of the bitslice implementations in our context. The bitslice AES implementation asymptotically takes 38% of the timings of the standard AES implementation using the best parallel polynomial method for the s-box (namely KHL). This ratio reaches 18% for PRESENT (compared to the F •G method). It is also interesting to observe that PRESENT is slower than AES for standard masked implementations whereas it is faster for masked bitslice implementations. In the latter case, a PRESENT computation asymptotically amounts to 0.58 AES computation. This ratio directly results from the number of calls to ISW-AND which is 10 × 16 = 160 for AES (16 per round) and 31 × 3 = 93 for PRESENT (3 per round). In order to illustrate the obtained performances in practice, Table <ref type="table" target="#tab_5">4</ref> gives the corresponding timings in milliseconds for a clock frequency of 60 MHz. For a masking order of 10, our bitslice implementations only take a few milliseconds.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>2) ;; tmp0 = [ a_h | a_l ^b_h ] EOR $tmp1 , $opB , $tmp0 , LSL #( n /2) ;; tmp1 = [ a_h | a_l | b_l ] BIC $tmp1 , #(2^n *(2^( n /2) -1) ) ;; tmp1 = [ a_l | b_l ] EOR $tmp0 , $tmp1 , LSR #( n /2) ;; tmp0 = [ a_h | b_h ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>EOR $tmp , $opB , $opA , LSL #n ;; tmp =[ a_h | a_l | b_h | b_l ] LDRB $res ,[ $tab1 , $tmp , LSR #( n /2) ;; res = T1 [ a_h | a_l | b_h ] EOR $tmp , $opA , $opB , LSL #(32 -n /2) ;; tmp =[ b_l |0..| a_h | a_l ] LDRB $tmp ,[ $tab2 , $tmp , ROR #(32 -n /2) ] ;; tmp = T2 [ a_h | a_l | b_l ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4. 1</head><label>1</label><figDesc>Algorithms ISW Multiplication. From two d-sharings (a 1 , a 2 , . . . , a d ) and (b 1 , b 2 , . . . , b d ), the ISW scheme computes an output d-sharing (c 1 , c 2 , . . . , c d ) as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Timings of ISW and CPRR schemes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Timings of (parallel) ISW and CPRR schemes for n = 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Timings of (parallel) ISW and CPRR schemes for n = 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Timings of mask refreshing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Timings for one s-box (n = 4). Fig. 7. Timings for 8 s-boxes (n = 4).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 6. Timings for one s-box (n = 4). Fig. 7. Timings for 8 s-boxes (n = 4).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .Fig. 9 .</head><label>89</label><figDesc>Fig. 8. Timings for one s-box (n = 8). Fig. 9. Timings for 4 s-boxes (n = 8).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 .Fig. 11 .</head><label>1011</label><figDesc>Fig. 10. Timings for one AES s-box. Fig. 11. Timings for 8 AES s-boxes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>two d-sharings (a 1 , a 2 , . . . , a d ) and (b 1 , b 2 , . . . , b d ) of two m-bit strings a, b ∈ {0, 1} m , the ISW scheme computes an output d-sharing (c 1 , c 2 , . . . , c d ) of c = a ∧ b as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 12 .Fig. 13 .</head><label>1213</label><figDesc>Fig. 12. Timings for 16 AES s-boxes. Fig. 13. Timings for 16 PRESENT sboxes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Timings of AES. Fig. Timings of masked PRE-SENT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Multiplication performances.</figDesc><table><row><cell></cell><cell cols="4">bin mult v1 bin mult v2 exp-log v1 exp-log v2</cell><cell>kara.</cell><cell>half-tab</cell><cell>full-tab</cell></row><row><cell cols="3">clock cycles (n ≤ 8) 10n + 3 (+3) 7n + 3 (+3)</cell><cell>18 (+2)</cell><cell>16 (+2)</cell><cell>19 (+2)</cell><cell>10 (+3)</cell><cell>4 (+3)</cell></row><row><cell cols="4">clock cycles (n &gt; 8) 10n + 4 (+3) 7n + 15 (+3) 35 (+2)</cell><cell>31 (+2)</cell><cell>38 (+2)</cell><cell>n/a</cell><cell>n/a</cell></row><row><cell>registers</cell><cell>5</cell><cell>5</cell><cell>5 (+1)</cell><cell>5 (+1)</cell><cell>6 (+1)</cell><cell>5 (+1)</cell><cell>5</cell></row><row><cell>code size (n ≤ 8)</cell><cell>52</cell><cell>2 n-1 + 48 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p><p>n+1 + 48 3 • 2 n + 40 3 • 2 n + 42 2 3n 2 +1 + 24 2 2n + 12</p>Fig. 1. Full code size (left graph) and LUT size (right table) w.r.t. n.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>table multiplication for ISW (256-byte table), and for n = 8 we used the half-table multiplication (8-KB table) and the exp-log multiplication (0.75-KB table). Based on our analysis of Sect. 5.1, we used the original CRV method for n = 4 (i.e. ( , t) = (3, 2) with 2 ISW multiplications), and we used the improved CRV method with optimized parameters for n = 8 (i.e. ( , t) = (8, 5) with 6 CPRR evaluations and 4 ISW multiplications). We further implemented parallel versions of these methods, which mainly consisted in replacing calls to ISW and CPRR by calls to their parallel versions (see Sect. 4.3), and replacing linear operations by their parallel counterparts.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 .</head><label>3</label><figDesc>Performances of masked blockciphers implementation.</figDesc><table><row><cell></cell><cell>Clock cycles</cell><cell cols="2">Code (KB) Random (bytes)</cell></row><row><cell>Bitslice AES</cell><cell>3280 d 2 + 14075 d + 12192</cell><cell>7.5</cell><cell>640d(d + 1)</cell></row><row><cell>Standard AES (KHL / /)</cell><cell>7640 d 2 + 6229 d + 6311</cell><cell>4.8</cell><cell>560d(d + 1)</cell></row><row><cell>Standard (AES RP-HT / /)</cell><cell>9580 d 2 + 5129 d + 7621</cell><cell>12.4</cell><cell>400d(d + 1)</cell></row><row><cell>Standard (AES RP-EL / /)</cell><cell>10301 d 2 + 6561 d + 7633</cell><cell>4.1</cell><cell>400d(d + 1)</cell></row><row><cell>Bitslice PRESENT</cell><cell cols="2">1906.5 d 2 + 10972.5 d + 7712 2.2</cell><cell>372d(d + 1)</cell></row><row><cell cols="2">Standard PRESENT (F • G / /) 11656 d 2 + 341 d + 9081</cell><cell>1.9</cell><cell>496d(d + 1)</cell></row><row><cell cols="2">Standard PRESENT (CRV / /) 9145 d 2 + 45911 d + 11098</cell><cell>2.6</cell><cell>248d(d + 1)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 4 .</head><label>4</label><figDesc>Timings for masked bitslice AES and PRESENT with a 60 MHz clock. ms 1.39 ms 1.99 ms 2.7 ms 8.01 ms Bitslice PRESENT 0.62 ms 0.96 ms 1.35 ms 1.82 ms 5.13 ms</figDesc><table><row><cell></cell><cell>d = 2</cell><cell>d = 3</cell><cell>d = 4</cell><cell>d = 5</cell><cell>d = 10</cell></row><row><cell>Bitslice AES</cell><cell>0.89</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that some conventions exist for the first four registers R0-R3, also called argument registers, and serving to store the arguments and the result of a function at call and return respectively.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p><ref type="bibr" target="#b2">2</ref> This is provided that the TRNG address is already in a register. Otherwise one must first load the TRNG address, before reading the random value. Our code ensures a gap of at least 10 clock cycles between two readings of the TRNG.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This instruction performs a logical right-shift but instead of filling the vacant bits with 0, it fills these bits with the leftmost bit operand (i.e. the sign bit).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Note that for n &gt; 8, the constant 2 n -1 does not lie in the range of constants enabled by ARM (i.e. rotated 8-bit values). In that case, one can use the BIC instruction to perform a logical AND where the second argument is complemented. The constant to be used is then 2 n which well belongs to ARM constants whatever the value of n.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>We only count the calls to ISW and CPRR since other operations are similar in the three variants and have linear complexity in d.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">sample an m-bit random value r i,j , 2. for every 1 ≤ i</title>
		<editor>&lt; j ≤ d, compute r j,i = (r i,j ⊕ a i ∧ b j ) ⊕ a j ∧ b i</editor>
		<imprint/>
	</monogr>
	<note>3. for every 1 ≤ i ≤ d, compute c = a i ∧ b i ⊕ j =i r i,j . References</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">DPA, bitslicing and masking at 1 GHz</title>
		<author>
			<persName><forename type="first">J</forename><surname>Balasch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gierlichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reparaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-48324-4_30</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2015</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Güneysu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Handschuh</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9293</biblScope>
			<biblScope unit="page" from="599" to="619" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Verified proofs of higher-order masking</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Belaïd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dupressoir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-A</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grégoire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-Y</forename><surname>Strub</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-46800-5_18</idno>
	</analytic>
	<monogr>
		<title level="m">EURO-CRYPT 2015</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="457" to="485" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parallel implementations of masking schemes and the bounded moment leakage model</title>
		<author>
			<persName><forename type="first">G</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dupressoir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Grégoire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-Y</forename><surname>Strub</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2016/912" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">912</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A fast new DES implementation in software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0052352</idno>
	</analytic>
	<monogr>
		<title level="m">FSE 1997</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1267</biblScope>
			<biblScope unit="page" from="260" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Higher-order threshold implementations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bilgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gierlichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nikova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-45608-8_18</idno>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2014</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Sarkar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Iwata</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8874</biblScope>
			<biblScope unit="page" from="326" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Threshold implementations of all 3×3 and 4×4 S-boxes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bilgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nikova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Stütz</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-33027-8_5</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2012</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Schaumont</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7428</biblScope>
			<biblScope unit="page" from="76" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">PRESENT: an ultra-lightweight block cipher</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bogdanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Knudsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Leander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Paar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poschmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J B</forename><surname>Robshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Seurin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Vikkelsoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES 2007</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4727</biblScope>
			<biblScope unit="page" from="450" to="466" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Heidelberg</forename><surname>Springer</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-74735-2_31</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Logic minimization techniques with applications to cryptology</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boyar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Matthews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Peralta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptol</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="280" to="312" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A very compact S-box for AES</title>
		<author>
			<persName><forename type="first">D</forename><surname>Canright</surname></persName>
		</author>
		<idno type="DOI">10.1007/11545262_32</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2005</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Rao</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Sunar</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3659</biblScope>
			<biblScope unit="page" from="441" to="455" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Higher-order masking schemes for S-boxes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Goubin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Quisquater</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rivain</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-34047-5_21</idno>
	</analytic>
	<monogr>
		<title level="m">FSE 2012</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Canteaut</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7549</biblScope>
			<biblScope unit="page" from="366" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Algebraic decomposition for probing security</title>
		<author>
			<persName><forename type="first">C</forename><surname>Carlet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rivain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roche</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-47989-6_36</idno>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2015</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9215</biblScope>
			<biblScope unit="page" from="742" to="763" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Towards sound approaches to counteract power-analysis attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rohatgi</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-48405-1_26</idno>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1999</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Wiener</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1666</biblScope>
			<biblScope unit="page" from="398" to="412" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Higher order masking of look-up tables</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-55220-5_25</idno>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2014</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8441</biblScope>
			<biblScope unit="page" from="441" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Higher-order side channel security and mask refreshing</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rivain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE 2013</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Moriai</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">8424</biblScope>
			<biblScope unit="page" from="410" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-43933-3_21</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fast evaluation of polynomials over binary finite fields and application to side-channel countermeasures</title>
		<author>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vivek</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-44709-3_10</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2014</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Batina</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8731</biblScope>
			<biblScope unit="page" from="170" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Solving circuit optimisation problems in cryptography and cryptanalysis</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">T</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hulme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mourouzis</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2011/475" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">475</biblScope>
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Unifying leakage models: from probing attacks to noisy leakage</title>
		<author>
			<persName><forename type="first">A</forename><surname>Duc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dziembowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Faust</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-55220-5_24</idno>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2014</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8441</biblScope>
			<biblScope unit="page" from="423" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m">FIPS PUB 197: Advanced Encryption Standard</title>
		<imprint>
			<date type="published" when="2001-11">November 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Thwarting higher-order side channel analysis with additive and multiplicative maskings</title>
		<author>
			<persName><forename type="first">L</forename><surname>Genelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Quisquater</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-23951-9_16</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2011</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Takagi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6917</biblScope>
			<biblScope unit="page" from="240" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the multiplicative complexity of Boolean functions and bitsliced higher-order masking</title>
		<author>
			<persName><forename type="first">D</forename><surname>Goudarzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rivain</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-53140-2_22</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2016</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Gierlichs</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Poschmann</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9813</biblScope>
			<biblScope unit="page" from="457" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">LS-designs: bitslice encryption for efficient masked software implementations</title>
		<author>
			<persName><forename type="first">V</forename><surname>Grosso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Leurent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Varıcı</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-46706-0_2</idno>
	</analytic>
	<monogr>
		<title level="m">FSE 2014</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Cid</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">8540</biblScope>
			<biblScope unit="page" from="18" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Efficient masked S-boxes processing -a step forward</title>
		<author>
			<persName><forename type="first">V</forename><surname>Grosso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-06734-6_16</idno>
	</analytic>
	<monogr>
		<title level="m">AFRICACRYPT 2014</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Vergnaud</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8469</biblScope>
			<biblScope unit="page" from="251" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Masking vs. multiparty computation: how large is the gap for AES?</title>
		<author>
			<persName><forename type="first">V</forename><surname>Grosso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Faust</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-40349-1_23</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2013</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Bertoni</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8086</biblScope>
			<biblScope unit="page" from="400" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Private circuits: securing hardware against probing attacks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2003</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2729</biblScope>
			<biblScope unit="page" from="463" to="481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-45146-4_27</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Improving the security and efficiency of block ciphers based on LS-designs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Journault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Standaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Varici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Des. Codes Cryptogr</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="495" to="509" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A fast and provably secure higher-order masking of AES S-box</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lim</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-23951-9_7</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2011</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Takagi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6917</biblScope>
			<biblScope unit="page" from="95" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On the power of bitslice implementation on Intel Core2 processor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Matsui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nakajima</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-74735-2_9</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2007</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4727</biblScope>
			<biblScope unit="page" from="121" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Pushing the limits: a very compact and a threshold implementation of AES</title>
		<author>
			<persName><forename type="first">A</forename><surname>Moradi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poschmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Paar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-20465-4_6</idno>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2011</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6632</biblScope>
			<biblScope unit="page" from="69" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Secure hardware implementation of nonlinear functions in the presence of glitches</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nikova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schläffer</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-00730-9_14</idno>
	</analytic>
	<monogr>
		<title level="m">ICISC 2008</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Cheon</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5461</biblScope>
			<biblScope unit="page" from="218" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Secure hardware implementation of nonlinear functions in the presence of glitches</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nikova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rijmen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schläffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptol</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="292" to="321" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Sidechannel resistant crypto for less than 2,300 GE</title>
		<author>
			<persName><forename type="first">A</forename><surname>Poschmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moradi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Khoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptol</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="322" to="345" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Masking against side-channel attacks: a formal security proof</title>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rivain</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-38348-9_9</idno>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2013</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7881</biblScope>
			<biblScope unit="page" from="142" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Higher-order glitches free implementation of the AES using secure multi-party computation protocols</title>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roche</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-23951-9_5</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2011</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Takagi</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6917</biblScope>
			<biblScope unit="page" from="63" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Provably secure higher-order masking of AES</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rivain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prouff</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-15031-9_28</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2010</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Mangard</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F.-X</forename><surname>Standaert</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6225</biblScope>
			<biblScope unit="page" from="413" to="427" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Analysis and improvement of the generic higher-order masking scheme of FSE 2012</title>
		<author>
			<persName><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vivek</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-40349-1_24</idno>
	</analytic>
	<monogr>
		<title level="m">CHES 2013</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Bertoni</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8086</biblScope>
			<biblScope unit="page" from="417" to="434" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A compact Rijndael hardware architecture with S-box optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Satoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Morioka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Takano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Munetoh</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-45682-1_15</idno>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2001</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boyd</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2248</biblScope>
			<biblScope unit="page" from="239" to="254" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
