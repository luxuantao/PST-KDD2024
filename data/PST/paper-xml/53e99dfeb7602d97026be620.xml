<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E0C4EFD7DCFD33FC710ED22EA6C0373C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Maximum Power Estimation for CMOS Circuits Using Deterministic and Statistical Approaches</head><p>Chuan-Yu Wang and Kaushik Roy, Senior Member, IEEE Abstract-Excessive instantaneous power consumption may reduce the reliability and performance of VLSI chips. Hence, to synthesize circuits with high reliability, it is imperative to efficiently obtain a precise estimation of the maximum power dissipation. However, due to the inherent input-pattern dependence of the problem, it is impractical to conduct an exhaustive search for circuits with a large number of primary inputs. Hence, the practical approach is to generate a tight lower bound and an upper bound for maximum power dissipation within a reasonable amount of central processing unit (CPU) time. In this paper, instead of using the traditional simulation-based techniques, we propose a novel approach to obtain a lower bound of the maximum power consumption using automatic test generation (ATG) technique. Experiments with MCNC and ISCAS-85 benchmark circuits show that our approach generates the lower bound with the quality which cannot be achieved using simulation-based techniques. In addition, a Monte Carlo-based technique to estimate maximum power dissipation is described. It not only serves as a comparison version for our ATG approach, but also generates a metric to measure the quality of a lower bound from a statistical point of view.</p><p>Index Terms-CMOS circuits, deterministic method, power estimation, search, statistical analysis, testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>W ITH the demand of high reliability in today's VLSI design, it is essential to accurately estimate the maximum power consumption during the synthesis of VLSI circuits. Peak power dissipation can have a large impact on reliability and hence, proper design guidelines should be considered for highly reliable systems. For a complementary metal-oxide-semiconductor (CMOS) circuit, the power dissipation is mainly due to signal switching at the internal and the output nodes of a circuit. Therefore, accurate estimation of the maximum power consumption involves exhaustively searching for two consecutive binary input vectors to induce as many switchings as possible (maximize the switched capacitance). Unfortunately, the problem is NP-complete and the time complexity for this search is where is the number of the primary inputs of the circuit. Hence, for circuits with large number of primary inputs, the only practical way to solve the problem is to generate a tight lower bound and an upper bound for maximum power consumption such that the range between lower and upper bound is as narrow as possible.</p><p>Several approaches have been proposed to estimate the maximum power consumption for CMOS circuits. In <ref type="bibr" target="#b3">[4]</ref>, Devadas et al. formulated the power dissipation of CMOS circuits as a Boolean function in term of the primary inputs. They tried to maximize the function by solving a weighted maxsatisfiability problem. During the branch-and-bound process which maximizes the objective function, the lower bound can be improved successively. However, the time complexity to obtain the objective function and to optimize the objective function are both exponential functions of the number of primary inputs (PI's). Hence, this approach is only feasible for small circuits. In <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b5">[6]</ref>, Kriplani et al. addressed the problem of determining an upper bound for the maximum power dissipation. They first generate an upper bound by propagating the signal uncertainty through the circuit. The bound is then successively made tighter by considering spatial correlation of signals at the outputs of logic gates. In this approach, the time to obtain the initial upper bound is linear in the number of gates, and the branch-and-bound strategy to improve the upper bound is, of course, CPU time intensive.</p><p>To generate a lower bound, traditional simulation-based approaches search for two consecutive input binary vectors to maximize the instantaneous power dissipation. The process is CPU time intensive. Furthermore, for a circuit with large number of PI's, simulation tends to generate a loose lower bound.</p><p>Motivated by these, we propose a novel approach to estimate the maximum power using the techniques of automatic test generation (ATG) for stuck-at faults. This technique can generate lower bounds of very high quality. In CMOS circuits, the power dissipation is dominated by the dynamic power consumption <ref type="bibr" target="#b0">[1]</ref>, and hence the instantaneous power dissipation due to two consecutive input binary vectors is proportional to <ref type="bibr" target="#b0">(1)</ref> where denotes the output capacitance of gate , and is a binary variable which indicates whether gate switches or not corresponding to the two input vectors. equals one if gate switches, and is zero if gate does not switch. To maximize efficiently, we sort the gates by the output capacitance (</p><p>) in nonincreasing order, and then assign transitions to gates (i.e., let ) from the sorted list of gates with the largest output capacitance. To justify the transitions (i.e., to see if is achievable), we use the modified justification mechanism in 9-V D algorithm <ref type="bibr" target="#b8">[9]</ref> (an ATG algorithm for stuck-at faults), which was originally used to justify the fault-propagation paths in combinational circuits. Experimentally, the execution time of our algorithm is approximately proportional to the number of gates in the circuit, and is comparable to the time of simulating the circuit once. In addition, experiments show the quality of the estimates are superior to the results from simulation.</p><p>To measure the quality of the lower bounds (of peak power), we propose a simulation-based approach to estimate the maximum power by a Monte Carlo-based technique. During the circuit simulation, we monitor the maximum power while estimating the mean and deviation of the power. The quality of the maximum power (a lower bound of peak power) can then be measured from a statistical point of view after the simulation.</p><p>The rest of the paper is organized as follows. To describe the ATG-based estimation, we briefly introduce some terminologies in Section II. The ATG-based estimation is illustrated in Section III. Section IV discusses how to measure the quality of a lower bound by Monte Carlo simulation. Section V presents the implementation and experimental results. Finally, conclusions are given in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. TERMINOLOGIES</head><p>1) Backtracing: In test generation for stuck-at faults, to activate a fault and propagate the fault effect to a primary output, a set of binary values ("0" or "1") will be assigned to a set of specific lines. To verify the assignments, backtracing is a process which checks the consistency between the assignments while propagating them toward the primary inputs. In our ATG-based estimation for maximum power, the transitions assigned to the gates are justified by a modified backtracing mechanism.</p><p>2) Implication: In stuck-at testing is used to verify all decisions made to justify an assignment. It computes the values of gates which can be uniquely determined, and checks if the values are consistent. If conflicts happen, the backtracing process will try an alternate way to verify the assignment.</p><p>3) Backtracking: While justifying an assignment in stuck-at testing, if there are several possible paths for backtracing, we choose one of them to try at a time. The decision made may lead to conflicts into previously assigned logic values. Backtracking strategy is used to alter the incorrect decision appropriately, and to recover the status of the circuit from the incorrect decision. Backtracking facilitates the trial-and-error process.</p><p>4) j-Frontier: In the progress of test generation, there are some gates whose outputs are known but not implied by the inputs (for example, a two-input AND gate, which has the output zero, and two unknown inputs). The j-Frontier is a set of gates which consists of all such gates in the circuit. In ATG, a successful propagation from the fault to primary outputs is verified by searching for a consistent assignment for the gates in j-Frontier. One of the challenges in our ATGbased estimation for maximum power is how to consistently assign the gates in j-Frontier's, which are left by different backtracings. We will discuss it in Section III-A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5) Composite Logic Values: In test generation, each gate is associated with a composite logic value</head><p>, where denotes the value of the gate in the fault-free circuit and denotes the value of the gate in the faulty circuit. In ATG-based estimation, however, the composite value associated with a gate denotes the values of the gate corresponding to two consecutive input vectors.</p><p>6) 9-V D Algorithm: The 9-V D algorithm is a pathsensitization TG algorithm. In generating a test for a stuck-at fault, it searches outputs and then justifies the path by consistently assigning the gates in j-Frontier. To justify the assignments, 9-V D algorithm keeps track of the values of all the gates in the circuit. In our approach, a similar mechanism is used to verify the transitions assigned in the circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. ATG-BASED ESTIMATION</head><p>In CMOS circuits, the capacitive load of a logic gate can be approximated by the fan-out of the gate <ref type="bibr" target="#b9">[10]</ref>. Hence, the dynamic power dissipation due to two consecutive input vectors is proportional to <ref type="bibr" target="#b1">(2)</ref> where , denote two consecutive input binary vectors to the circuit, represents the Boolean function of gate in term of PI's, and denotes the number of fan-outs of gate .</p><p>is a measure of the power dissipation due to two consecutive input vectors, and is the objective function to be maximized.</p><p>To maximize , instead of searching for appropriate and , we greedily assign transitions to the gates with large fan-out. The gates are first sorted by the fan-out number in nonincreasing order. Then, in each iteration, we select a gate which is untried and currently has the the largest fan-out number to justify the assignment: . The justification mechanism in our algorithm includes two processes-backtracing and implication, which will be discussed in Section III-A. If the justification for assigning transitions to a gate fails, the state of the circuit from the incorrect decision will be recovered, and next gate will be tried. The gates in the circuit are assigned and justified one by one until all gates have been processed.</p><p>To recover the state of the circuit from incorrect decisions, we store all the values which have been either assigned or implied to the gates in the circuit. To implement this, we associate each gate with a stack to store all the composite logic values which have been assigned to [ and denotes and , respectively]. The variables and can be "1," "0," or " " (unknown value). At each gate, the top of the stack stores the most recently updated value for the gate.</p><p>For example, in Fig. <ref type="figure" target="#fig_0">1</ref>, the top of the stacks of gate , , and are , , and , respectively. After assigning a rising transition (0/1) to , of is forced to be 1, and is still left unknown. Hence, /1 is pushed into the stack of to be gate 's current value. Then, the most recently updated values for , , and turn out to be 0/1, /1, and /1, respectively. We know , are the gates whose values have been changed. If it is determined later that assigning 0/1 to causes conflicts, the stacks of gate and are popped to recover the state of the circuit from the incorrect decision. To make a gate switch, either 0/1 or 1/0 can be tried if the current value of the gate is not in conflict with the new assignment. We define two composite values to be in conflict if they have "0" and "1" at the same position. For example, 1/0 cannot be assigned to gate in Fig. <ref type="figure" target="#fig_0">1</ref>, since 1/0 is in conflict with 0/ .</p><p>The ATG-based estimation is implemented as the algorithm . To better understand , we introduce the following notations.</p><p>1) : a subroutine, which returns the composite value at the top of gate 's stack.</p><p>returns the most updated value of gate .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2)</head><p>: a subroutine to push the composite value into the stack of gate .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3)</head><p>: a subroutine to check if two composite values and are in conflict. It returns 1 if and are in conflict, else returns a : the mechanism to recover the state of the circuit from an incorrect decision , which is made during the justification of a transition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5)</head><p>: the mechanism to justify the assignment ). In , (*) is actually implemented by two processes backtracing and implication, which will be discussed in Section III-A.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Justification of Transitions</head><p>To justify the transition assigned to a gate, the backtracing process generates a path for propagating the transition toward the PI's. The implication process then justifies the path by computing and checking the values of all implied gates.</p><p>The transition assigned to the output of a gate is justified if either one of the following paths can be generated.</p><p>1) Primary Path: A path for backtracing the transition from the assigned gate to a PI, which has the composite value not in conflict with the transition. 2) Secondary Path: A path for backtracing the transition from the assigned gate to a primary path, which was generated for justifying another transition. For example, in Fig. <ref type="figure" target="#fig_1">2</ref>, path 1 is a primary path for the transition at . We can also backtrace the transition at to the primary path , which was generated for justifying the transition at the output of gate . Consequently, a secondary path can be also generated (path 2). Either path 1 or path 2 justifies the transition at gate .</p><p>The justification process in our algorithm is complete, i.e., it can exhaustively search for the primary or secondary path to justify a transition. If the process returns FAIL for both rising and falling transitions at a gate output, it is impossible to have signal switching under the current state of the circuit. The justification process consists of two processes-backtracing and implication. The backtracing process makes decisions about how to justify a transition, and the incorrect decisions made by backtracing can be detected by the implication process. For example, in Fig. <ref type="figure" target="#fig_1">2</ref>, if fan-in is chosen for backtracing the transition 1/0 at gate , gate will be implied to have the value 0/ , which is in conflict with its current value 1/ .</p><p>In , the backtracing process is implemented by a recursive subroutine . For justifying an assigned transition, it backtraces the transition from the assigned gate toward the PI's gate by gate. At each gate the transition passes over, if there are several fan-ins not in conflict with the transition, the subroutine computes the priority of these fan-ins. The fan-ins are then sorted by the priority to decide the order in which they will be tried. We define the priority [ ] of a fan-in as</p><formula xml:id="formula_0">(3)</formula><p>where and denotes two constants which can be specified by the user before executing program , denotes the number of the fan-out of , and denotes the level of gate . In a circuit, the level of a gate is defined as: one plus (the maximum level of the gate's fan-ins). The level of the PI's are defined as zero. To increase the probability of a successful backtracing (to avoid backtracking), the fan-in with the maximum controllability [minimum ] should be selected first. However, to maximize (the power), one should select the fan-in with the largest number of fan-outs, and then make it switch. Hence, we design to make the tradeoff between the execution time and the quality of the estimate (power), by adjusting the positive real number and . For example, at gate in Fig. <ref type="figure" target="#fig_1">2</ref>, the priority of , , and are 1.4, 1.4, 1.2, respectively. That means are the favored fan-ins currently, and hence, the subroutine will try to backtrace the transition through or first. In stuck-at testing, the implication process is used to verify the decisions made by the backtracing process. In , the implication process works similar to the 9-V D algorithm, except for the j-Frontiers. In 9-V D algorithm, after a path for propagating the fault to a primary output has been built, the path is immediately justified by eliminating the j-Frontier. However, in ATG-based estimation, the j-Frontier left by a successful backtracing is not eliminated immediately. This is due to the fact that justifying the transition assigned to one gate may reduce the possibility of assigning transitions to the others. To maximize the number of transitions we can possibly get, j-Frontier's are not justified immediately after each assignment in . Instead, they are justified automatically while other transitions are assigned.</p><p>In Fig. <ref type="figure" target="#fig_2">3</ref>, for example, is an unjustified j-Frontier gate and it can be justified automatically when a falling transition is assigned to . If was justified at the time it was implied, an inappropriate decision ( , ) may be made to prohibit the transition at .</p><p>However, the unjustified j-Frontiers may be in conflict. For example, in Fig. <ref type="figure" target="#fig_3">4</ref>, it is impossible to assign , , and consistently, where , , and are j-Frontier gates. Since assigning transitions to the gates in different order may result in different j-Frontier's, one possible solution for the problem is to change the assigning order and redo the whole process. The procedure is repeated until a consistent assignment for the circuit is obtained. The solution maximizes the number of the transitions we can possibly get, but makes the execution time of the program unbounded [the number of the possible assigning orders is , where is the number of the gates in the circuit]. Hence, in , we solve the problem in a different way. We incorporate a justifying mechanism, which has adjustable criterion of justification, into the implication process. In the algorithm, a justification index is designed for controlling the criterion of justifying an assigned transition. Without using the maximum justification index, all transitions are just partially justified, i.e., the j-Frontier's generated by two transitions may be in conflict even if they have passed the consistency check. The implication process justifies the j-Frontier's according the criterion denoted by . The minimum value of is zero, which denotes a normal implication mode. A larger increases the possibility to have nonconflicting transitions, but may sacrifice the quality of the estimates. Consequently, the algorithm tries to obtain the result with the minimum possible . Setting to its maximum value guarantees that all transitions which have been justified are not in conflict. Hence the execution time of can be bounded by where is the maximum value of , and denotes the worst case complexity of the program.</p><p>Let us consider the two example circuits of Fig. <ref type="figure" target="#fig_4">5</ref>. In circuit (a), gate and are two unjustified j-Frontier gates in the mode . If is assigned the value /1, gate is implied to have the value /0. However, since PI feeds the OR gate , is implied to have the value , which is in conflict with the value /0. On the other hand, if is assigned /0, gate is implied to have the value . However, the value of gate should be /0 since feeds . Hence, cannot have the value /0 also. From above discussion it can be observed that it is impossible to assign consistently under the current state of the circuit. The inconsistency can be detected by Program . It will increase the value of by 1 and reexecute the assigning process. In , represents the mode that all simple gates in j-Frontiers will be justified immediately. In circuit (a), gate will be implied to have the value /1 if gate is assigned /1, and gate will be implied to have the value /0 if gate is assigned /0. It can be noted that one of the gates ( or ) will be implied during the justification of the other. Hence, for circuit (a), consistent assignments can be obtained if is used. In circuit (b), it can be noted that cannot be assigned consistently. To remove the inconsistency, XOR gate should be justified immediately when it is implied. In , represents the mode that all simple gates and XOR (XNOR) gates in j-Frontier will be justified immediately. Hence, a consistent assignment for circuit (b) can be obtained by using the mode</p><p>. By controlling , we can guarantee that estimates of high quality can be obtained without violating the spatial correlation of signals in circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Time Complexity</head><p>To facilitate analyzing the complexity of , we introduce the following notations.</p><p>The number of the levels in the circuit.</p><p>The maximum fan-in number of gates in the circuit.</p><p>The number of gates in the circuit. The worst case complexity of backtracing a transition through a gate.</p><p>The worst case complexity of backtracing a transition through a chosen fan-in. For justifying an assigned transition, the number of the possible paths for backtracing is . At each path, the execution time is bounded by . is bounded by , and dominated time to justify backtracing through the chosen fan-in, which is bounded by . From above derivations, the complexity of is , which is an exponential function of . To improve the execution time, we can set an upper bound on the number of backtrackings at a gate. If the bound is reached, the algorithm gives up backtracing the transition through the current gate. Setting the bound reduces the time for backtracking, and hence reduces the execution time of . For example, if the upper bound is set as one, the time complexity of the algorithm turns out to be , which is polynomial. It can be noted that setting the upper bound may reduce the quality of the result (power).</p><p>Experimental results show that, the program works quite efficiently for all the circuits we tried, no matter what bound was set. One reason for the phenomenon is: the worst case behavior of justifying an assigned transition can be observed if the gate cannot have the transition under the current state of the circuit (in that case, the algorithm exhaustively tries all possible paths). These situations are expected to be rare at the beginning of the assigning process, since most of the gates are left unassigned at this time. On the other hand, at the end of the assigning process, since most of the gates are assigned, only a small number of gates have to be checked for justifying an assignment. Hence, the speed of justifying a transition is expected to be fast.</p><p>Since the number of backtrackings at each gate is bounded by the number of the fan-ins, the algorithm is especially efficient for circuits with small value of (maximum fan-in number of gates).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. STATISTICAL ESTIMATION</head><p>For estimation of average power dissipation, researchers have used statistical techniques <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. With a prespecified accuracy, it can generate an estimate for the average power based on a number of simulation runs. In <ref type="bibr" target="#b6">[7]</ref>, Burch et al. made the assumption that power dissipation of the CMOS combinational circuit over a fixed time interval is a normally distributed random variable. They then generated bounds for average power with the preset accuracy based on the assumption.</p><p>In our statistical approach to estimate the peak power, we propose to simulate the circuit and monitor the maximum value of the instantaneous power generated from simulation, which is defined as the simulated maximum power. To determine if a simulated maximum power ( ) is satisfactory, we associate each with a measure of quality, which is a function of the mean and deviation of the instantaneous power. Therefore, we apply Monte Carlo technique to estimate the mean and deviation of the instantaneous power while simulating the circuit. The application is straightforward, and hence, the detailed descriptions have been omitted. In this approach, the desired quality of the simulated maximum power can be specified before the simulation. The program stops simulating the circuit if 1) the prespecified bound on the number of simulations (say, 100 000) has been exceeded or 2) the measure of quality of the simulated maximum power has exceeded the prespecified criterion. This approach can be implemented in a gate-level simulator which estimates the mean and deviation of the power while stressing the circuit by the PI's with high activity values (we assume that high activity at the inputs produces high activity at the internal nodes. XOR gates can be an exception under zero delay assumption. Extensive experiments suggest that our assumption is valid <ref type="bibr" target="#b2">[3]</ref>).</p><p>To facilitate estimating the mean and deviation of the instantaneous power , the normality assumption of should be justified first. As mentioned in <ref type="bibr" target="#b6">[7]</ref>, it cannot be proved that the power dissipation over a finite period, especially if the period is as short as one clock cycle, is normally distributed. However, according to Function 1, is the summation of many random binary variables which denote the transitions of the gates due to two consecutive input vectors. If the transitions are independent identically distributed (i.i.d.), the distribution of should be approximately normal according to Central Limit Theorem (CLT) (if the number of the gates in the circuit is large). However, signals at the gate inputs can be spatially correlated. For example, for an XOR gate with two switching fan-ins, the output cannot have transitions. However, as mentioned in <ref type="bibr" target="#b6">[7]</ref>, if there are many gates with the transitions which are approximately independent, the requirement for normality is roughly achieved.</p><p>Under the normality assumption of instantaneous power , the distribution function of , which is denoted by , can be calculated if both the mean and deviation of are known. For a simulated maximum power with a large value of , the probability of generating a sample of instantaneous power larger than by further simulations is low. Hence, we propose to associate the simulated maximum power with the probability as its measure of quality. For example, in Fig. <ref type="figure" target="#fig_5">6</ref>, denotes the instantaneous power which is a random variable. The value of is the quality measure of , where is the simulated maximum power. It can be noted that . From Monte Carlo simulation, the deviation of power is known, and the mean of lies within the range , with confidence . Here is the mean value of the samples of power from simulation, is user-specified percentage error of mean value , and is user-specified confidence of mean value <ref type="bibr" target="#b6">[7]</ref>. For a simulated maximum power , we can measure its quality by calculating according to the mean and deviation of . The resultant lies within a range ( ) where and denote the bounds of . In statistics, the quality measure of [ ] falls into the range ( ) with confidence . We can interpret the measure as with confidence , the probability of the event is greater than where is a random sample of instantaneous power. It is less likely, by further simulations, to increase a simulated maximum power with a large value of of high confidence level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTAL RESULTS</head><p>The proposed ATG-based estimation ( ), along with the statistical estimation ( ), have been implemented in C under the Berkeley SIS environment.</p><p>In , the parameters for computing the backtracing priority of the fan-ins are set as . In the simulator , the probability and activity values <ref type="bibr" target="#b1">[2]</ref> of the  primary inputs are specified before simulating the circuits. The probability of a signal denotes the statistical ratio between the number of the clock cycles on which the signal is high and the total number of the clock cycles. The activity of a signal is defined as the statistical ratio between the number of the clock cycles on which the signal switches and the total number of the clock cycles. In , the probability values of the PI's are set as 0.5. It is generally believed that the PI's with highactivity values tend to stress the circuit with high switching activities at the internal and output nodes <ref type="bibr" target="#b2">[3]</ref>. To maximize the instantaneous power, the activity values of PI's should be set as high as possible. We set the activity values of the PI's as 0.9 in , because of the following two reasons. 1) The bit-correlations of the two input vectors which induce the peak power in the circuit are unknown. Hence, the activity values of the PI's should not be set as one and 2) the PI's with very high activity values may not be suitable for stressing the circuits with XOR or XNOR gates (e.g., xor, cccxor in Table <ref type="table" target="#tab_2">II</ref>).</p><p>We show statistics of benchmark circuits in Table <ref type="table" target="#tab_1">I</ref>. Table <ref type="table" target="#tab_2">II</ref> shows the results for six small circuits. Results for ISCAS85 and MCNC91 benchmark circuits are shown in Tables III and IV, respectively. In Tables II-IV, maximum power 's are measured according to (2):</p><p>where denotes the fan-out number of gate . In , the maximum power and CPU time are measured based on 10 000 input patterns. As mentioned in Section IV, we can measure the mean and distribution of the power while monitoring the maximum power . In Tables II-IV, we associate each maximum power with a quality measure at 95% confidence level. From the results in Tables II-IV, the significances of the ATG-based estimation can be concluded as follows.  1) Considering the speed-performance of , for very large circuits (say, over 100 000 gates), the ATG-based estimation may be the only feasible way to generate a reliable lower bound for peak power.</p><p>2) The ATG-based estimation generates the lower bounds superior to the results from the conventional simulationbased techniques (e.g., i10, i5, and i4 in Table <ref type="table" target="#tab_4">IV</ref> and C7552, C6288, C880 in Table <ref type="table" target="#tab_3">III</ref>). It should be mentioned that there are some parameters left within ( , , and the assigning order of gates), which can be varied to improve the results. Considering the speedperformance of , it is reasonable to modify to use several sets of parameters for power estimation, and to report the best bound generated. For example, for Circuit C5315 and C1355 in Table <ref type="table" target="#tab_3">III</ref>, better lower bounds 2620 and 384, respectively, can be obtained from by setting , .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSIONS AND FUTURE WORK</head><p>In this paper, a novel approach has been proposed to estimate the maximum power using test generation techniques for stuck-at faults. Furthermore, a statistical approach has been proposed to generate a lower bound for peak power. It can also measure the quality of the lower bound from a statistical point of view. Experiments show the test generation approach is superior to the traditional simulation-based technique in both efficiency and the quality of the results. Within a very small amount of CPU time, the ATG-based estimation can generate estimates superior to the results from simulating the circuit for a long period of time. Considering the speed of ATGbased estimation, it not only serves as an estimator which is superior to simulation, but also may be the only practical way to estimate the maximum power for very large circuits.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Stacks for justification and backtracking.</figDesc><graphic coords="2,326.88,59.58,209.52,157.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Backtracing for justifying a switching.</figDesc><graphic coords="3,323.28,59.58,216.72,184.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Justification of j-Frontier.</figDesc><graphic coords="4,107.58,59.82,121.92,115.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. j-Frontier gates in conflict.</figDesc><graphic coords="4,363.42,59.58,136.32,117.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Different requirements for J x .</figDesc><graphic coords="5,57.60,59.58,222.00,142.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Quality measure.</figDesc><graphic coords="6,50.94,59.59,236.00,135.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE I STATISTICS</head><label>I</label><figDesc>OF BENCHMARK CIRCUITS</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE II RESULTS</head><label>II</label><figDesc>OF MAX P AND SIM P FOR SMALL CIRCUITS</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE III RESULTS</head><label>III</label><figDesc>OF MAX P AND SIM P FOR ISCAS-85 BENCHMARKS</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE IV RESULTS</head><label>IV</label><figDesc>OF MAX P AND SIM P FOR MCNC BENCHMARKS</figDesc><table /></figure>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Manuscript received August 15, 1995; revised August 15, 1997. This work was supported in part by ARPA under Contract F33615-95-C-1625 and by the NSF under CAREER Award 9501869-MIP, IBM, Rockwell, and AT&amp;T/Lucent Foundation. The authors are with the School of Electrical and Computer Engineering, Purdue University, West Lafayette, IN USA 47907. Publisher Item Identifier S 1063-8210(98)01312-2.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Low-power CMOS digital design</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Chandrakasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Brodersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Solid-State Circuit</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="473" to="483" />
			<date type="published" when="1992-04">Apr. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Transition density, a stochastic measure of activity in digital circuits</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Najm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th ACM IEEE Design Automation Conf</title>
		<meeting>28th ACM IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="644" to="649" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Saving power in the control path of embedded processors</title>
		<author>
			<persName><forename type="first">C</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tsui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Despain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Design Test Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="32" to="41" />
			<date type="published" when="1994-12">Dec. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Estimation of power dissipation in CMOS combinational circuits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Keutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Custom Integr. Circuits Conf</title>
		<meeting>IEEE Custom Integr. Circuits Conf</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Maximum current estimation in CMOS circuits</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kriplani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Najm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hajj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th ACM IEEE Design Automation Conf</title>
		<meeting>29th ACM IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="2" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Resolving signal correlations for estimating maximum currents in CMOS combinational circuits</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kriplani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Najm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hajj</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th ACM IEEE Design Automation Conf</title>
		<meeting>29th ACM IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="2" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Monte Carlo approach for power estimation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Burch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Najm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Trick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. VLSI Syst</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="63" to="71" />
			<date type="published" when="1993-03">Mar. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Statistical estimation of the switching activity in digital circuits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Xakellis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Najm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 31th ACM IEEE Design Automation Conf</title>
		<meeting>31th ACM IEEE Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="728" to="733" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<author>
			<persName><forename type="first">M</forename><surname>Abramovici</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Breuer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Systems Testing and Testable Design</title>
		<meeting><address><addrLine>Rockville, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Circuit activity based logic synthesis for low power reliable operations</title>
		<author>
			<persName><forename type="first">K</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Prasad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. VLSI Syst</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="503" to="513" />
			<date type="published" when="1993-12">Dec. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
