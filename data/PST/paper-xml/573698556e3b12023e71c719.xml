<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Programming Slick Network Functions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Bilal</forename><surname>Anwer</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Theophilus</forename><surname>Benson</surname></persName>
							<email>tbenson@cs.duke.edu</email>
						</author>
						<author>
							<persName><forename type="first">Nick</forename><surname>Feamster</surname></persName>
							<email>feamster@cs.princeton.edu</email>
						</author>
						<author>
							<persName><forename type="first">Dave</forename><surname>Levin</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Georgia Tech Duke University</orgName>
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Maryland</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Programming Slick Network Functions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">33499013AFDD9E6BBF8021D3A5ED1446</idno>
					<idno type="DOI">10.1145/2774993.2774998</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:02+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.1 [Computer-Communication Networks] Network Architecture and Design Algorithms</term>
					<term>Design</term>
					<term>Experimentation Software-Defined Networking (SDN)</term>
					<term>Network Functions Virtualization (NFV)</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Current approaches to in-network traffic processing involve the deployment of monolithic middleboxes in virtual machines. These approaches make it difficult to reuse functionality across different packet processing elements and also do not use available in-network processing resources efficiently. We present Slick, a framework for programming network functions that allows a programmer to write a single high-level control program that specifies custom packet processing on precise subsets of traffic. The Slick runtime coordinates the placement of fine-grained packet processing elements (e.g., firewalls, load balancers) and steers traffic through sequences of these element instances. A Slick program merely dictates what processing should be performed on specific traffic flows, without requiring the programmer to specify where in the network specific processing elements are instantiated or how traffic should be routed through them. In contrast to previous work, Slick handles both the placement of fine-grained elements and the steering of traffic through specific sequences of element instances, allowing for more efficient use of network resources than solutions that solve each problem in isolation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent trends suggest that network operators seek to deploy an increasing range of network functions in the network. These functions can perform arbitrary functions on packets, including access control, intrusion detection, load balancing, caching, and transcoding. It is commonly-if not always-assumed that these functions should be deployed as monolithic middleboxes <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b48">49]</ref>. Until recently, these middleboxes have been deployed as vertically integrated hardware (e.g., dedicated load balancers, firewalls, and other devices), although the shift towards network functions virtualization (NFV) <ref type="bibr" target="#b9">[10]</ref> has enabled the deployment of these middleboxes in virtual machines <ref type="bibr" target="#b32">[33]</ref>.</p><p>Current approaches to NFV make it possible to place existing middleboxes in virtual machines at various points in the network and steer traffic through those middleboxes, instantiating and decommissioning instances in response to changing traffic conditions. This approach to deploy network functions imposes severe limitations. First, it requires the wholesale deployment of an existing middlebox; they do not allow an operator to implement custom, fine-grained packet processing functions in the data-plane that could be re-used across multiple applications. For example, many middleboxes may (re)implement their own packet processing modules that filter or load-balance traffic, compute statistics on traffic flows, or otherwise perform operations on packets (e.g., checksums) that could be shared across different functions. Second, deploying an entire middlebox inside a virtual machine does not scale to a large number of instances on any physical machine, and deploying (or migrating) the middlebox functions may be cumbersome in their own right.</p><p>We offer a fundamentally different approach to deploy network functions. Rather than the conventional approach of redirecting traffic flows through monolithic middleboxes, we propose a programming model that allows a programmer to specify which sequences of network functions should be applied to traffic that passes through the network, leaving the thornier questions of where in the network those functions are actually applied and how these functions are applied to the underlying runtime system. This paper presents Slick, an approach to programming network functions that allows an operator to implement network functions as chains of lightweight functions that can be placed at arbitrary locations in the network and composed into more complex packet processing sequences. Slick has two salient features:</p><p>• Programming abstraction. We develop a programming abstraction that allows a network operator to (1) implement custom network functions in a high-level language (i.e., Python) and ( <ref type="formula">2</ref>) specify which traffic flows should be routed through sequences of these functions. A programmer may implement (or reuse) specific functions as elements (a programming model that takes inspiration from Click <ref type="bibr" target="#b27">[28]</ref>) and specify sequences of elements that should operate on specific portions of flowspace. • Runtime. Slick's runtime scalably and efficiently implements the programming abstraction we have designed by decomposing network-wide packet processing into constituent functions and placing those functions at appropriate locations in the network. In contrast to existing approaches, which consider placement in the absence of steering <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b43">44]</ref>, or vice versa <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b22">23]</ref>, Slick takes a holistic approach, performing both placement of modular packet-processing elements and steering of traffic through those elements.</p><p>In contrast to NFV-which concerns the instantiation and management of existing monolithic middleboxes in virtual machines-Slick allows the placement of fine-grained functions, specified as elements that the programmer can write in a high-level programming language (e.g., Python), making the placement of these functions more nimble, taking better advantage of available network resources, and allowing potential reuse and sharing of network functions that are applied to traffic. Slick determines how many instances of each element should be instantiated and where individual elements should be placed ("placement"), as well as which traffic flows to direct through specific element instances ("steering"). Slick elements can be reconfigured at runtime after they are installed, and Slick policies can specify that placement or steering should change at runtime, in response to triggers from the network. For example, a middlebox that checks DNS requests against a blacklist could trigger all of the user's traffic to be steered through the closest deep-packet inspection element.</p><p>We develop several placement and steering algorithms and evaluate them on enterprise and data-center network topologies. Our evaluation shows that Slick's heuristics can achieve near-optimal network bandwidth utilization on many network topologies and can reduce the average link utilization compared to an approach that only uses consolidation by as much as a factor of two.</p><p>The rest of the paper is organized as follows. Section 2 compares Slick to other related work, including systems that have implemented placement and steering independently, as well as more theoretical treatments of middlebox control. Section 3 describes the Slick architecture, including its programming model and the runtime that it exposes to network operators. Sections 4 and 5 describe the implementation of Slick and our evaluation of Slick's placement and steering algorithms and its controller's performance on a variety of network topologies. Section 6 discusses possible directions for future work; we conclude in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Network functions virtualization (NFV) allows network operators to instantiate middleboxes in virtual machines and place those VMs at arbitrary locations in the network <ref type="bibr" target="#b9">[10]</ref>; current approaches to NFV still treat middleboxes as monolithic entities, and do not explore how the constituent components of a middlebox might be decomposed into smaller modules. Other recent work has explored how monolithic middleboxes in a cellular network might be instantiated as virtual machines <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b48">49]</ref>. In contrast, Slick explores how an operator can implement individual functions in a high-level language and specify how those functions are chained together, while remaining agnostic to how those functions are replicated and installed across the network.</p><p>Programming model. Slick's programming model has two salient features: the decomposition of functions into modular elements and the use of triggers to redirect processing from an in-network element to the controller. Both of these features are inspired by previous work. Slick's use of the element abstraction is inspired by Click <ref type="bibr" target="#b27">[28]</ref>, which allowed programmers to write modular elements and compose them into packet processing pipelines on a single node. Slick differs from Click in that it constructs such pipelines across a network, and hence must address questions of both placement and steering. Extensible Open Middleboxes (xOMB) <ref type="bibr" target="#b2">[3]</ref>, RFC 3234 <ref type="bibr" target="#b4">[5]</ref>, and other work on modeling middleboxes <ref type="bibr" target="#b21">[22]</ref> inspired the design and granularity of Slick element functions. Previous work has also proposed the use of triggers to allow one network element to signal to another <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b46">47]</ref>; Slick incorporates this notion of triggers in a holistic programming model that supports more expressive triggers and perform other packet processing actions in response to the triggers. Although Slick's programming model draws inspiration from this previous work, none of these systems incorporate these mechanisms into a single coherent programming model, as Slick does. Although OpenNF <ref type="bibr" target="#b16">[17]</ref> and Split/Merge <ref type="bibr" target="#b39">[40]</ref> offer programming interfaces and control-plane mechanisms for helping operators migrate existing middleboxes, they do not allow operators to write network functions that operate on specific traffic flows in the data plane, nor do they provide mechanisms for placing network functions.</p><p>Programming Languages. Many programming languages for software defined networks can be used to express network policies <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b47">48]</ref>. Most of these languages (e.g., Frenetic <ref type="bibr" target="#b13">[14]</ref>, Pyretic <ref type="bibr" target="#b34">[35]</ref>, Maple <ref type="bibr" target="#b47">[48]</ref>) provide higher-level abstractions for programming OpenFlow <ref type="bibr" target="#b33">[34]</ref> switches. Merlin <ref type="bibr" target="#b46">[47]</ref> and Kinetic <ref type="bibr" target="#b26">[27]</ref> provides some abstractions for handling events that middleboxes may raise (similar to Slick's ability to process triggers), but neither provides a mechanism for installing network functions onto machines that host these functions. None of this prior work focuses on decomposing the functions provided by monolithic middleboxes into finer-grained, reusable modules, or the placement or steering functions required to implement network-wide policies with these modules.</p><p>Steering. Charikar et al. <ref type="bibr" target="#b6">[7]</ref> and ETTM <ref type="bibr" target="#b7">[8]</ref> assume that network functions can be placed at all machines in the network and treat resource management purely as a steering problem. This approach simplifies resource management algorithms, since placing all functions on every node reduces resource management to a traffic steering problem. Unfortunately, as the number of middlebox functions proliferates-even Slick already supports about 15 distinct network functions-simply placing all functions on every node quickly becomes intractable.</p><p>Other recent work on steering <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b49">50]</ref> has assumed prespecified, fixed placement of middleboxes within a network and focused on developing an optimal steering mechanism that minimizes utilization. In contrast, Slick makes no such assumption about placement and must thus develop mechanisms for both steering and placement. Our evaluation demonstrates that control over placement significantly reduces both path length and average link utilization. pSwitching <ref type="bibr" target="#b22">[23]</ref> and OpenPipes <ref type="bibr" target="#b17">[18]</ref> provide mechanisms for steering traffic through middleboxes or hardware modules but do not offer a high-level programming model and do not propose specific steering mechanisms.</p><p>Placement. Stratos explores questions of middlebox placement to reduce inter-rack traffic in data centers <ref type="bibr" target="#b14">[15]</ref> but focuses on placement of entire virtual machines and does not explore the placement of individual network functions, as in Slick. In contrast, Slick studies a different class of placement problems that arise when middleboxes are decomposed into constituent functions, each of which may have different resource utilization and effects on traffic flows. CoMB work explores whether multiple middleboxes can be consolidated on single physical machines <ref type="bibr" target="#b40">[41]</ref> but studies consolidation at the granularity of virtual machines, as opposed to individual network functions. Our evaluation demonstrates that studying consolidation at the granularity of individual functions allows for different placement decisions (e.g., placing elements that increase the amount of network traffic towards the end of a path, and vice versa), thus significantly reducing network utilization compared to CoMB. Sherry et al. explore placing existing network middleboxes in the cloud and routing traffic through these off-path middleboxes for processing <ref type="bibr" target="#b43">[44]</ref>; in contrast, Slick enables on-path processing with fine-grained network functions that an operator writes in a high-level language.</p><p>Applications. The IETF service function chaining working group is actively exploring various applications of service function chaining <ref type="bibr" target="#b42">[43]</ref>, including in mobile and data-center networks. Yang et al. have studied how to enable certain applications by embedding net- work functions in an underlying network graph, but the work focuses primarily on theoretical problems associated with embedding chains of network functions in an underlying network graph <ref type="bibr" target="#b28">[29]</ref> and does not have a working system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Slick</head><p>In this section, we present an overview of Slick, describe a motivating example (and explain why this example is difficult to implement in existing NFV architectures), and describe Slick's programming model and runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>Figure <ref type="figure" target="#fig_0">1</ref> illustrates Slick's architecture. The Slick controller runs an application that specifies a sequence of elements that should process a particular portion of flow space. An application specifies which traffic should flow through specific sequences of elements. The Slick controller supports these applications by deploying elements (on top of a shim on each machine) and installing forwarding rules in the switches to direct traffic through particular sequences of elements. The controller instantiates functions on machines and installs forwarding rules in switches to steer traffic towards those machines. The Slick runtime takes a high-level policy and determines the number of element instances to deploy (and where to deploy them) to ensure that no single element or network link is overloaded and that traffic sees good end-to-end performance. Given values for each packet-header field, the controller determines the sequence of elements that should be applied to a particular flow and installs flow table modifications into corresponding switches to ensure that the respective flow is forwarded through the corresponding sequence of element descriptors.</p><p>Motivating Example. Suppose an operator configures the network so that all Web traffic traverses an intrusion detection system (IDS) <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b45">46]</ref>. The application specifies that all Web traffic (i.e., TCP traffic with port 80) flows through an IDS element, with all packets of a TCP connection in both directions traversing the same element. The controller deploys one or more IDS elements in the network and installs rules in the switches to direct port-80 traffic through the element. As traffic demand increases, any single IDS element may become overloaded; at this point, the Slick controller instantiates a second IDS element and splits the port-80 traffic over two IDS elements, taking care to ensure that ongoing TCP connections complete at the original IDS element and only new flows traverse the second element. If the traffic demand decreases to the levels from before the controller added additional elements and all flows through the first IDS element expire, the controller reclaims resources by removing that IDS element instance. Over time, the controller monitors the machine and network load, adjusting the traffic splitting and routing to minimize congestion. The IDS itself might inspect network traffic and perform deep-packet inspection (DPI) only when it observes DNS traffic from a device on the network to a blacklisted DNS domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Programming Abstractions</head><p>Each network function corresponds to a software element. An element may be configured either at initialization time or dynamically; it may also generate an event stream that sends events to the controller. A Slick control application specifies a high-level policy, indicating which traffic flows should traverse a particular sequence of elements (e.g., packets with destination port 80 should traverse a firewall followed by a transcoder); an operator can write such a policy independently of the network topology or where the elements are installed.</p><p>Slick supports modular, composable elements that permit reuse across many applications; each element also supports dynamic configuration and supports sending events to the Slick controller that might subsequently affect its operation. Slick elements are inspired by elements in Click modular routers <ref type="bibr" target="#b27">[28]</ref>, from which we derive Slick's name. In this section, we describe how to program functions and applications, detailing the interfaces they expose and the abstractions presented to them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Writing Slick Elements</head><p>Slick elements run on machines; an element can be an arbitrary executable and may also have state. Elements process packets, handle configuration requests from applications, and send events to the controller.</p><p>Element methods. When a controller first installs an element on a machine, it invokes the element's init() method. As packets destined for that element arrive at the machine, the element's pro-cess_pkt() method is called; this method can perform arbitrary packet processing. An element can also be configured dynamically by the controller: the configure() method allows the controller to dynamically reconfigure network elements. This method also allows a controller to update an element's internal state; for example, a firewall element could accept new rules via configure(). Finally, an element can issue asynchronous, distributed triggers that allows it to send events to the controller. The raise_trigger method accepts arbitrary inputs and delivers them to the controller (who, as we will see, delivers them to the proper applications' trigger handlers). Figure <ref type="figure" target="#fig_1">2</ref> shows an example of a simple Slick element that logs all packets that it sees. The init method (lines 6-10) performs any operations that should be called when the element is initialized (in this case, opening a file); the process_pkt method (lines 12-16) is invoked whenever the element sees a packet.</p><p>Two properties of the Element class design make it easy to reuse elements across applications. First, elements need not specify the traffic flows that they process; an element simply processes any that is passed to it. Second, elements are agnostic about what application is invoking them. For example, the TriggerAll element sends an event to the controller, and any control application that registers for these events will receive them. Because any element implementation is agnostic about both the subset of traffic that it will operate on and the applications that will instantiate it, any given element implementation can be reused across a wide variety of applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Programming Slick Applications</head><p>Slick applications run at the controller. These control applications specify a sequence of elements that should process a given portion of flow space (e.g., send all port 53 traffic through a Logger element).</p><p>Instantiating elements. An application specifies a portion of flow space and applies that flow to a particular element/elements using the apply_elem() method. Applying an element to a portion of flow space causes the controller to install that element at the appropriate locations in the network. Figure <ref type="figure" target="#fig_3">3a</ref> shows an example HttpLogger control application. Lines 7-9 specify that the controller should ensure that Logger (Figure <ref type="figure" target="#fig_1">2</ref>) operates on all traffic with destination port 80, and to supply http.log as its input parameter (which will set the log's filename). The apply_elem() method (Line 10) takes as inputs the flow to which an element should be applied, the name of the element, and an optional set of parameters to send to those elements' init() method. Each call to apply_elem creates a new instance of the specified elements.</p><p>A Slick application may create multiple instances of multiple elements. For example, the HttpLogger application could have made another call to apply_elem on all port 443 traffic with another Logger function to also log HTTPS traffic. The apply_elem method returns a unique element descriptor for each instantiated element, to allow the controller to configure these elements after installation time, and to process triggers.</p><p>Interacting with elements. An application can also interact with any installed element after the element has been installed in the network. Applications use configure() with the corresponding element descriptor to send arbitrary configuration messages to Slick controller, which will ultimately result in a call to that element instance's configure(). When an element sends a trigger to the controller, the controller calls the corresponding application's handle_trigger() method and passes it two values:the descriptor of the element that raised the trigger and any associated data. HttpLoggerViaTrigger in Figure <ref type="figure" target="#fig_3">3b</ref>   a trigger for every packet) to all HTTP traffic; handle_trigger() will thus be called with each HTTP packet sent in the network.</p><p>Choosing where functions are performed. Figures <ref type="figure" target="#fig_3">3a</ref> and<ref type="figure" target="#fig_3">3b</ref> illustrate how Slick's programming model allows a programmer to chose where processing takes place: (1) HttpLogger places all the work in the in-network machine by having the Logger element capture and log all of the packets to file; (2) HttpLoggerViaTrigger uses the TriggerAll element to cause the controller to log all packets at the controller application. Each of these implementations represents two extreme design points. The first approach places all processing at the elements themselves, which is similar to how middleboxes operate today. This approach scales well, depending on where elements are installed in the network. The latter approach places all processing at the controller, which can introduce a bottleneck at the controller.</p><p>Building applications from multiple elements. Slick applications can also define interactions between multiple elements. Figure <ref type="figure" target="#fig_5">4</ref> shows a BlacklistDropper application, which also illustrates the use of raise_trigger and configure in the DNSBlacklist element. The application applies DNSBlacklist element to all outgoing DNS traffic (line 5), which raises a trigger whenever it detects a DNS lookup to a blacklisted domain (lines <ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref>. When the application receives this trigger, it installs the DropAll element that simply  drops all packets (lines 11-14), applying it to all subsequent traffic from the host that initiated the DNS lookup (line 14). Slick also allows element chains, enabling sequential processing of packet flows by the elements in the chain. For example, to log all the port 80 traffic and subsequently drop all the traffic, we can modify (line 10) in Figure <ref type="figure" target="#fig_3">3a</ref> as follows: eds = self.apply_elem(flow, ["Logger", "DropAll"], parameters)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Runtime</head><p>The Slick controller maps a control application's high-level policy to the available pool of network resources (i.e., available network bandwidth and computational elements). Given a high-level policy, the controller determines how many instances of each element to deploy and where to place or migrate them (placement). The controller also determines the paths that each traffic flow should take through the network so that traffic flows are processed by the correct sequence of elements and also experience good end-to-end performance (steering). The controller must adapt to topology changes and machine failures, as well as shifts in load and changes in the high-level policy. A shim on each machine allows the controller to interact with the elements (e.g., to configure the element and receive triggers).   The Slick controller maps each new flow to elements that are installed on machines in the network and keeps an updated view of what resources are available on each machine. Instead of performing a single optimization given resources and traffic flows, the Slick controller performs a continuous incremental optimization that minimizes changes to the installed configuration and ongoing network traffic flows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Placement</head><p>The controller's placement algorithm determines the machines in the network where element instances should be installed. The placement algorithm may ultimately place multiple instances of the same element at different places in the network, and a single machine may also host multiple elements.</p><p>Placement aims to place instances of elements at various machines in the network to ensure that flows are processed by their corresponding element sequences while using a reasonable amount of bandwidth and machine resources and ensuring a low-latency end-to-end path. Slick uses an inflation heuristic to reduce the overall network bandwidth required to support element sequences and a consolidation heuristic to reduce both the utilization on individual links and the number of overall machines required to host element instances. Table <ref type="table" target="#tab_0">1</ref> summarizes how different heuristics help achieve different placement goals or have no impact on Slick's goals. Placement applies these two heuristics in order: the controller first decides whether (and how) to consolidate elements on physical machines; second, the controller determines where to place the consolidated elements.</p><p>Step 1: Consolidating elements. When we have more than one element that should operate sequentially on a certain flow space, the first step is to decide whether we should consolidate contiguous elements onto a single machine, or if we should distribute them across multiple machines. Consider the network in Figure <ref type="figure" target="#fig_7">5</ref>, which shows two possible configurations in which a chain of two elements can be deployed.  The inflation heuristic helps determine whether an element should be placed closer to the source or closer to the destination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Element</head><p>We define an inflation factor as log( f out / f in ), where f in and f out are the input and output traffic volumes, respectively. The intuition for consolidation is that elements with negative inflation factor should be placed closer to sources, and elements with positive inflation factor should be placed closer to destinations. For any ordered list of elements (E 1 , . . . , E n ), we can decide places to "break" the list into any number of sub-lists, where each sub-list is placed on a single machine.</p><p>We can define the inflation factor of a machine m, λ m , as the sum of all of the inflation factors of the respective elements placed on that machine. A negative inflation factor thus means that the consolidated elements on that node decrease overall traffic, and vice versa for a positive inflation factor. Then, for a path of length l, we can define the inflation for some consolidation along that path p, λ p as</p><formula xml:id="formula_0">∑ l i=1 (i -l/2) • λ i .</formula><p>The brute-force consolidation algorithm searches all possible consolidation combinations to minimize total inflation. Given M possible machines on which to place a sequence of E elements, the algorithm tests <ref type="table" target="#tab_2">2</ref> enumerates some example elements, their inflation factors, and whether they should be placed closer to source or destination. The priority of placing an element near sources or destinations can be overridden by Slick application writer.</p><formula xml:id="formula_1">∑ E i=1 E-1 i-1 • M i possible combinations. Table</formula><p>Step 2: Placing consolidated elements. Once minimum-cost consolidation is computed, the placement algorithm uses the flow connectivity matrix for each flow space, where c i j is the number of flows from i to j. The placement algorithm identifies the longest common routing path between the source(s) and destination(s). It then places consolidated elements with negative inflation factor on the node of longest common routing path that is closest to source(s), for elements with positive inflation factor, the algorithm places the consolidated element on the node of the longest common routing path that is closest to destination(s).</p><p>Elements with inflation factors near zero should be placed at machines that minimize the average path length for all sourcedestination pairs in the flow space, or that have the highest betweenness centrality for all source-destination pairs that exchange traffic in a given flow space. The betweenness centrality <ref type="bibr" target="#b29">[30]</ref> of a vertex v, c v is given by the expression:</p><formula xml:id="formula_2">c v = ∑ v / ∈{s,d} ρ sd (v) ρ sd<label>(1)</label></formula><p>where ρ sd is the total number of shortest paths between s and d and ρ sd (v) is the number of those paths that pass through vertex v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Steering</head><p>Given elements placed in the network and a flow that must traverse a sequence of elements, the steering module determines the specific sequence of element instances that a given flow should pass through.</p><p>If there are multiple instances of a particular element, the steering module determines which element instance should be used to send traffic through a particular sequence of elements. The steering module acts on a virtual topology that includes the elements and the connectivity between them.</p><p>Steering determines, for each portion of flow space, the specific sequence of element instances that should be used to process traffic for that flow. Recall that any given element might be installed in more than one place in the network; steering thus determines the instances of each element that traffic for a particular flow space should be routed through. Slick performs steering by constructing a virtual topology that represents the sources, destinations, and possible sequences of element instances at each stage of an element sequence; given this virtual topology, it computes a lowest cost path through the corresponding sequence of elements, for each portion of flow space. We describe this process in more detail below.</p><p>A Slick program determines the sequence of elements for each corresponding part of flow space; each element may have multiple instances in the network. Given an element sequence {E 1 , . . . , E n } for some portion of flow space, where any E i may have multiple instances, Slick must steer each traffic flow through any instance of each element in the sequence.</p><p>To help Slick compute the appropriate sequence of element instances for each portion of flow space, we represent the set of all element instances as a virtual topology, as shown in Figure <ref type="figure" target="#fig_8">6</ref>. Traffic from s to d is routed through one instance of E i , in order, from E i to E n . Each edge in the virtual topology has a weight that corresponds to the sum of the physical network distance multiplied by the antilog of the inflation factor. This gives us weight of each virtual edge based on the physical network topology and inflation factor of the element instances. For a flow to which n elements are to be applied, this graph takes O(n + ∏ n i=1 m i ) time to construct, where m i is the number of element instances at stage i. Given this virtual topology, Slick computes the shortest weighted path from s to d.</p><p>To avoid overloading specific element instances, Slick removes machines from the virtual topology if their load exceeds some operator-specified threshold. If no machines that host instances The Slick runtime operates on top of an existing SDN controller (in our implementation, Pox), and hosts applications that specify functions that should operate on different parts of flow space. The controller installs and configures elements on machines in the network, which interface to the controller via a shim (Placement). The controller also uses a wire protocol (e.g., OpenFlow) to configure flow-table entries in switches to steer traffic through the appropriate elements installed on machines (Steering).</p><p>of some element E i have spare capacity (again, determined by an operator-specified threshold), the Slick controller will provision another instance of the element on a new machine with the help of the placement module.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Routing</head><p>Given a specific sequence of element instances to forward traffic through, the routing module installs flow table entries into switches to ensure that a traffic flow follows a specific path between each pair of installed elements in an element sequence. It enables the steering module to implement asymmetric steering such that ingress and egress paths of the same flow can be asymmetric <ref type="bibr" target="#b41">[42]</ref>. It also provides Slick runtime with network link information and placement module about the active switches generating traffic for a given flow space. Slick's routing module simply implements shortestpath routing between two element instances, although the module itself provides for other possible routing decisions between pairs of elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>We implemented Slick in about 15,000 lines of Python, with Slick's controller built on top of POX <ref type="bibr" target="#b37">[38]</ref> controller as an SDN application. About half of the code involves the basic controller functions, such as communication with elements and interfacing to placement and steering modules, as well as the element shim as shown in Figure <ref type="figure" target="#fig_9">7</ref>. The remainder of the code includes several elements and reference applications that use them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Controller</head><p>The controller implementation includes functions to discover topology and machine resources, as well as the runtime that implements placement, steering and routing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Discovery</head><p>The Slick controller must discover both the network topology, the machines in the network that can host packet processing elements, and the current network conditions (e.g., available network resources, current machine load). It discovers topology using a link-layer discovery protocol (e.g., LLDP) and machine resources through a custom resource discovery protocol.</p><p>Network topology and congestion. Network switches and servers are discovered using OpenFlow's link-layer discovery protocol (LLDP). The controller maintains a network map that includes a mapping of element instances (each of which is identified by an element descriptor) to its location in the network topology, as well as a mapping between the MAC addresses that the controller knows about and their corresponding IP addresses. The controller also periodically polls the traffic load of each network link and the amount of traffic that each element is processing.</p><p>Machine resources. Each Slick machine runs a shim layer that registers with the Slick controller; the controller keeps track of the available machines on which it can install elements. Each machine's shim has a configuration file that contains information about that machine's available resources and any other constraints that exist; this specification ensures that the controller only installs elements on machines that have both the capability and the available resources to perform the corresponding processing (e.g., a configuration might ensure that a certain encryption element is only installed on machines with the corresponding hardware acceleration for cryptographic operations). These specifications also include various other parameters including the number, types, and speeds of the processors on the machine, available storage, and the operating system type and version of the machine.</p><p>Network model and overlay network abstraction. Using information about available machines and link loads, the controller builds a network model to perform operations including (1) finding machines that can host a particular element (for placement); (2) finding machines where specific elements have been installed; (3) avoid routing new traffic flows through either congested links or loaded elements. Ultimately, the controller uses these functions to construct an overlay network for each network policy that includes the elements that are pertinent to any particular flow space.</p><p>Using knowledge of the underlying network topology and machine resources, Slick places elements and maintains an overlay network topology that abstracts the physical topology. Each policy has a corresponding overlay network topology; the steering module uses this overlay network to find, for each flow, the shortest path between the source and destination that traverses a particular sequence of elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Runtime</head><p>We implemented a variety of placement, steering, and routing algorithms in Slick. Slick implements several placement algorithms, including placing elements on k random machines in the network, placing nodes according to centrality, placing elements on compatible machines in a round-robin fashion, and weighting placement according to centrality on a graph with nodes weighted according to traffic load. Each placement algorithm is several hundred lines of Python. Slick implements steering according to random paths through the virtual topology (Figure <ref type="figure" target="#fig_8">6</ref>), shortest hop count through the topology, and two different shortest paths through the virtual topology: one based purely on link weights, and another where link weights are assigned according to traffic loads. Each steering algorithm is between about 50 and 200 lines of Python. Routing is based on shortest paths in the underlying topology through the sequence of elements that steering selects; for this function, we were mainly able to rely on path setup functions in Pox, but we also implemented a mechanism to route on shortest paths through the underlying topology. Slick's routing algorithm generates microflow forwarding table entries, which creates the potential for a large number of flow-table entries. Other work has explored ways to reduce the number of flow tables installed in switches, and Slick may be able to exploit these techniques <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b38">39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Elements and Applications</head><p>Shim. The Slick shim layer makes it possible to deploy and decommission elements at runtime and also includes a virtual switch to multiplex and de-multiplex traffic through these elements. The shim also allows Slick to marshal control messages between Slick's control applications running on the controller and the elements. Control messages and triggers between applications and the controller are encapsulated in JSON and sent over TCP connections.</p><p>Reference elements and applications. To demonstrate the flexibility and generality of Slick's programming model, we have implemented nearly 15 elements, which we have incorporated into several real-world applications. The Slick elements provide functions at different granularities and levels of complexity. These function include network traffic logging, TCP Stream analysis to detect OS and browsers, DNS deep packet inspection, encryption, decryption, compression, and decompression. The applications we have implemented include a traffic quarantine application that is triggered by DNS-based traffic monitoring and an application firewall.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>We evaluate Slick using Mininet emulations for a variety of traffic matrices and topologies. We address the following questions:</p><p>(1) What is the performance of Slick's placement and steering algorithms? (2) How efficiently does Slick place network elements and steer traffic through these elements? (3) How close are Slick's placement and steering algorithms to the optimal solution? (4) How does Slick generalize across different types of network topologies?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experiment Setup</head><p>We evaluate Slick using the Mininet network emulator <ref type="bibr" target="#b18">[19]</ref>. We opted for evaluating Slick using emulation rather than simulations or testbeds because emulations allow us to evaluate Slick under a variety of network topologies and with a variety of traffic matrices while ensuring that our results faithfully replicate the dynamics of real networks. We ran the Slick controller on one virtual machine and performed network emulation using Mininet on another. Each virtual machine had eight cores assigned and both VMs were running on a server with 16 cores(Intel Xeon E5620 @ 2.40GHz) and 24 GB RAM. The Mininet emulator limits our evaluations to topologies with less than 60 switches. For all evaluations, we use the applications and elements discussed in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Topology.</head><p>To demonstrate Slick's generality, we emulate a number of network topologies representing data-centers and enterprise networks. We evaluate Slick using a Fat Tree <ref type="bibr" target="#b0">[1]</ref> network and using a canonical tree topology that is representative of small data centers <ref type="bibr" target="#b3">[4]</ref> and enterprise networks <ref type="bibr" target="#b25">[26]</ref>. In each topology, we assume that a Slick machine is attached to all switches within the network, so each machine that is attached to a switch can also host Slick elements. For all the experiments we use fat-tree with 20 (K=4) switches and tree topologies with 3 tiers and 15 nodes, except where stated otherwise.</p><p>Traffic Matrices. We evaluate Slick using a combination of two types of traffic matrices. (1) East-West traffic, emulating machineto-machine traffic patterns which are prevalent in modern datacenters <ref type="bibr" target="#b3">[4]</ref>, (e.g., MapReduce workloads). This traffic matrix generates traffic solely between end hosts within the same network; and (2) North-South traffic, emulating user-to-server traffic patterns that exist in a number of networks including data centers, enterprise campus networks, and WAN. Traffic is between servers at the edge and the core-devices which act as a gateway to the Internet.</p><p>Evaluation Metrics. We evaluate Slick's effects on data-plane resource utilization and the performance of the Slick controller. First, we study the effects of Slick's programming model and algorithms on the overall network data plane utilization (Section 5.2). We show how using Slick's programming model and algorithms can help efficient implementation of Slick policies. To evaluate the efficiency of Slick's implementation of network policies, we focus on the following metrics: the sum of the average link utilizations (aggregate average network bandwidth), which allows us to understand the efficiency of the different algorithms; path length, which allows us to understand the impact of the different algorithms on the performance of individual flows; and link utilization, which also allows us to understand the effects of different algorithms on network traffic aggregates. In Section 5.3, we study the effects of network size, the length of Slick element chains, and the number of Slick element instances on the performance of the Slick controller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Efficiency</head><p>We now evaluate the outcomes of the placement and steering that Slick computes. In doing so, we focus on evaluating Slick's performance against an Optimal algorithm, which provides an upper bound on Slick's performance; and a Random algorithm, which provides a reasonable lower bound on Slick's performance. The Random placement algorithm randomly places elements and Random steering algorithm randomly chooses which traffic to steer through which elements, while the Optimal algorithm assumes that all elements are placed at all locations and that each node has infinite capacity, thus eliminating the need for placement and steering. The Optimal algorithm ensures that the shortest paths are used at the cost of employing more elements.</p><p>We have evaluated Slick, Random, and Optimal algorithms under all topologies and traffic matrices. Due to space constraints, we focus on the results from the largest emulations, but the results from smaller experiments are qualitatively similar. In Figure <ref type="figure">8</ref>, we present the total bandwidth utilization from running the three algorithms on the tree topology and fat-tree topologies. The Tree1 and Fat-tree-1 experiments make decisions on four different flow spaces, which have both East-West and North-South traffic flows. We deploy four  element chains with one to two elements in each chain. For each flow space, all of the sources are clustered in single rack and all of the destinations of a flow space are in single switch rack. In the Tree2, Tree3, Fat-Tree-2, and Fat-tree-3 setups, sources and destinations are randomly distributed across the network. Tree2 and Fat-tree-2 have eight randomly selected source destination pairs and Tree3 and Fat-Tree-3 have sixteen randomly selected source destination pairs. Slick consistently outperforms Random varying between 20% and 120%. Interestingly, for the traffic matrices where sources are clustered in single rack as well as destinations, (tree-1, fat-tree1 in Figure <ref type="figure">8</ref>), Slick performs within 5% of Optimal. For topologies where sources and destinations are randomly distributed across the network, Slick performs between Random and Optimal: consistently reducing the performance gap between Optimal and Random by half.</p><p>We also examine the link utilizations, paths lengths, and number of element instances in the resulting solutions Figure <ref type="figure" target="#fig_12">9a</ref> and Figure <ref type="figure" target="#fig_12">9b</ref>). Although Slick has comparable path lengths (Figure <ref type="figure" target="#fig_12">9b</ref>) and number of elements as Random (Slick and Random use one element instance and Optimal uses 20 element instances for the Fat-Tree topology), Slick achieves much lower link utilization than Random for the same number of element instances. The link utilizations that Slick achieves are comparable to those achieved by Optimal. Moreover, Optimal can only maintain shorter paths at the cost of deploying significantly more elements: In this experiment, Optimal uses N times more elements than Slick, where N is the number of switches in the topology.</p><p>Comparison to CoMB's "Strict" Consolidation. Slick uses inflation rates to guide consolidation and placement. CoMB <ref type="bibr" target="#b40">[41]</ref>) also utilized consolidation as a way to reduce overall network utilization. CoMB argues for a strict consolidation, which always consolidates all elements in a chain onto one machine. We examine network utilization under CoMB and Slick's consolidation techniques and show that using inflation rates to guide consolidation can significantly reduce network utilization.</p><p>We observe that while both consolidation techniques perform comparable, there are situations when Slick consolidation outperforms CoMB's strict consolidation, reducing overall utilization by up to 50%. We examine the different element chains and observe that strict consolidation does not perform as well when chains contain a combination of elements with inflation factor &gt; 0 and inflation factor &lt; 0. In these cases, strict consolidation fails to account for the inflation factors and the resulting transformation in traffic that increase network utilization (e.g., a decompressor/encryption element that increases the overall data transmitted).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">General Scaling Properties</head><p>We evaluate Slick on scenarios that involve processing a different number of unique flow spaces and a random distribution of traffic sources and destinations.</p><p>Number of distinct flow spaces. Figure <ref type="figure" target="#fig_13">10</ref> shows the aggregate average bandwidth utilization for Slick placement and steering with varying number of flow spaces. We use a tree topology; in each run, we increase the number of flow spaces and applications and introduce an element chain in the network. We can see with increasing number of flow spaces Slick placement consistently performs within 10-15% of Optimal placement and outperforms Random placement for varying number of flow sizes. In all these experiment runs Optimal had 15 more copies of element instances than Random and Optimal, corresponding to the number of switches in the network. Each flow space had four to eight sources and four to eight destinations in it but all the sources and destinations in each flow space were non-overlapping.</p><p>Increasing Source Destination Pairs. In above experiment the intersection of sources and destinations was an empty set for all the flow spaces but both East-West and North-South traffic pattern  were present in them. In Figure <ref type="figure" target="#fig_15">11</ref>, we present the aggregate average bandwidth utilization for the Slick algorithms with varying number of distributed switches all across the networks such that the intersection of source and destination switches can or cannot be an empty set. This experiment also has both North-South and East-West traffic flows. We use fixed tree and Fat-Tree topologies.</p><p>Here we use a simple application with only one flow space. We deploy this application in both Tree and Fat-Tree topologies. For each experiment iteration, we randomly select source destination pairs and generate traffic between them. We increase the number of randomly selected host pairs from 1 to 16. As we can see that for both Tree 11a and Fat-Tree 11b topologies the Slick placement algorithm performance starts decreasing with increasing number of randomly distributed hosts. But for both topologies Slick placement consistently performs better than Random placement and in many cases performs comparably to Optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Individual Placement and Steering Algorithms</head><p>We quantify the benefits of each of Slick's placement and steering algorithms by evaluating different combinations of placement and steering algorithms: (Slick,Random), a version of Slick with our placement algorithms but with Random steering; (Optimal, Slick) a version of Slick with our steering algorithm but the optimal place-  In Figure <ref type="figure" target="#fig_17">12</ref>, we compare the link utilization and path lengths for the different algorithms. Figure <ref type="figure" target="#fig_17">12</ref> shows that Slick's steering algorithm contributes significantly to Slick's improvement's over random by providing reductions of both the median and 99th percentile path lengths (19%,30%) and link utilization (37%,34%) over random steering. We used a Fat-Tree topology. We deploy one element to process traffic of one flow space; with 16 randomly distributed source destination switch pairs across the network. The traffic matrix has both East-West and North-South traffic flows. Figure <ref type="figure" target="#fig_17">12a</ref> shows that Slick's placement results in higher link utilizations in exchange for deploying fewer element instances. Figure <ref type="figure" target="#fig_17">12b</ref> shows that Slick placement places elements in locations that provide shorter path length by restricting the number of elements used. In real-world networks, the presence of background traffic may result in higher overall traffic latencies, but we expect the results to be qualitatively similar; the respective differences in network performance between different configurations may be larger, as a reulst of this increased background traffic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Controller Performance</head><p>We now explore the scalability of Slick's control plane and examine the different parameters that can affect its performance. We evaluate how the following dimensions: a) Network Size; b) Size of elements   Network Size and Element Chain Size. To quantify the effects of network topology and element chain size on the Slick controller's performance, we run a Slick control application with multiple flow spaces and element chains on topologies of varying sizes. From Table <ref type="table" target="#tab_3">3</ref>, we observe that the time for placement is linear as a function of network size. Similarly, the placement algorithm's time as well as element instantiation time is impacted by number of elements in the element chain as shown in Figure <ref type="figure" target="#fig_20">14</ref>. Topology size and element chain size both have a profound effect on the cost of placement. We also show that steering is understandably only impacted by the number of element instances, as we explain in more detail below.</p><p>Element Instances. In this experiment, we fix the network size and size of element chain and increase the number of element instances that can potentially operate on the flow space (i.e., more element instances in each stage of Figure <ref type="figure" target="#fig_8">6</ref>). As the number of element instances in the network increases, Slick's steering algorithm's computation time increases linearly, as shown in Figure <ref type="figure" target="#fig_19">13</ref>. Since the steering algorithm will be called only on subset of flow spaces in a network (flows requiring Slick element processing), the longer time to run the algorithm is less of a concern. Additionally, Random steering in Figure <ref type="figure" target="#fig_19">13</ref> shows the lower bound for computation time for any steering algorithm implemented in Slick.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Future Work</head><p>In this section, we discuss possible avenues for future work. We plan to release the source code to help encourage future research along the lines we have outlined in this section.</p><p>Security. The security of Slick's element placement could be improved in the following ways: (1) enforcing resource isolation between different elements on a Slick machine; (2) enforcing control over an element's ability to modify and transform packet headers and payload; and (3) default path for a new flow when elements and switches are configured. The Slick shim enforces access control and can enforce limitations on header transformations. Slick's design explicitly allows for elements to run in separate separate address spaces, thus allowing Slick to use existing primitives for resource isolation (e.g., Cgroups <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b30">31]</ref>, Unikernels <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b32">33]</ref>). Yet, more work is needed to explore exactly how various authorization policies might be expressed and implemented within the context of Slick. These questions are further complicated by the increasing prevalence of end-to-end encryption, which may require additional mechanisms for authorization and key distribution.</p><p>Element sharing. In principle, Slick makes it possible for multiple applications to share an element instance that is installed in the network. In such cases, different applications may have unique or conflicting configurations for the same element instance: For example, two different applications may use an encryption instance with different encryption keys or a compression element with different levels of compression. To support this level of flexibility, the Slick programming model would need to be extended to allow a programmer to specify which flows (and applications should map to specific element instances).</p><p>Testing and Verification. Slick includes no primitives for enabling testing, debugging, and verification of data-plane elements. Future work might explore ways to adapt existing work on automating test packet generation to test the deployment of Slick middlebox functions <ref type="bibr" target="#b23">[24]</ref>; applying invariant checkers to determine that the modifications that Slick elements perform on packets do not result in incorrect forwarding behavior or behavior that violates other highlevel policies or intent <ref type="bibr" target="#b24">[25]</ref>; verifying that Slick policies achieve any isolation properties that a network programmer may specify <ref type="bibr" target="#b35">[36]</ref>; and verifying that any Slick policies that are deployed do not violate end-to-end reachability properties <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>Network Routing. Slick implements several placement and steering algorithms, but only one network routing algorithm (i.e., shortest path routing), yet the performance and optimality of Slick's placement and steering algorithms depend on the underlying network routing algorithm. Future work could evaluate the effectiveness of Slick's placement and steering algorithms in the context of different network routing algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>Most work on managing and orchestrating middleboxes has focused on deploying monolithic middleboxes, rather than deploying individ-ual functions written in a high-level language. Slick takes the latter approach, representing a departure from existing designs, which provides the programmer with improved flexibility and scaling properties. Slick allows a programmer to write a single application that describes a sequence of processing elements for a given part of flow space, leaving the details of how those elements are replicated and placed throughout the network to the runtime. We presented a prototype and displayed the strength of the programming model by implementing several elements and realistic applications. We showed that Slick can achieve near-optimal network bandwidth utilization for a variety of topologies and traffic loads.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Slick architecture. A programmer writes a Slick program that runs at the controller, which in turn installs elements (i.e., high-level functions) on machines in the network (placement) and installs forwarding rules on switches to direct traffic flows through sequences of elements (steering).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The Logger element logs all packets it receives. (We have elided the element's shutdown method for clarity.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>4 5 4 5</head><label>44</label><figDesc>applies the TriggerAll element (which simply raises 1 class HttpLogger ( Application ): 2 def __init__ (self , controller , ad ): 3 Application . __init__ (self , controller , ad) def init(self ): 6 parameters = [{" file_name ":"/tmp/ http_log_mach "}] 7 flow = self. make_wildcard_flow () 8 flow['tp_dst '] = 80 9 flow['nw_proto '] = 6 10 ed = self. apply_elem (flow , [" Logger "], parameters ) 11 if(self. check_elems_installed (ed )): 12 self. installed = True (a) Logging all port-80 traffic at in-network traffic elements. 1 class HttpLoggerViaTrigger ( Application ): 2 def __init__ (self , controller , ad ): 3 Application . __init__ (self , controller , ad) def init(self ): 6 flow = self. make_wildcard_flow () 7 flow['tp_dst '] = 80 8 flow['nw_proto '] = 6 9 self.ed = self. apply_elem (flow , [" TriggerAll "]) 10 if(self. check_elems_installed (self.ed )): 11 self. installed = True 12 self. file_handle =open("http.log", 'a') 13 14 def handle_trigger (self , ed , msg ): 15 if(ed in self.ed ): 16 self. file_handle . write(str(msg )) (b) Logging all port 80 traffic at the controller.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Two implementations of HttpLogger that perform logging in different locations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 27 {</head><label>27</label><figDesc>class BlacklistDropper ( Application ): 2 def init(self , blacklist ): 3 flow = self. make_wildcard_flow () 4 flow['tp_dst '] = 53 5 eds = self. apply_elem (flow , [" DnsDpi "]) 6 if(self. check_elems_installed (eds )): 7 self. installed = True 8 droppers = list () 9 10 def handle_trigger (self , ed , trigger ): 11 if( trigger ['type '] == 'BlacklistedQuery '): 12 src_flow = self. make_wildcard_flow () 13 src_flow ['nw_src '] = trigger ['src_ip '] 14 eds = apply_elem (src_flow , [" DropAll "]) 15 if(self. check_elems_installed (eds )): 16 droppers . append (eds [0]) 17 18 19 class DNSBlacklist ( Element ): 20 def init(self , blacklist ): 21 self. blacklist = blacklist 22 23 def process_pkt (self , pkts ): 24 domain , src_ip = extract_dns_domain (pkts) 25 if( domain in self. blacklist ): 26 self. raise_trigger (self.ed , (self , params ): 32 if( params ['command '] == 'set-blacklist '): 33 self. blacklist = params ['blacklist ']</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Slick applications can use triggers to asynchronously compose elements. Element descriptors disambiguate multiple instances of the same element.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>(a)</head><label></label><figDesc>Consolidation. (b) No Consolidation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: When making placement decisions, the Slick controller must determine whether to consolidate multiple elements on a single machine or distribute those elements across multiple machines in the network or use a combination of the two.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure6: Slick uses a virtual topology with m i elements at each stage i to decide how to steer traffic from source to destination in the order specified in the Slick application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure7: The Slick runtime operates on top of an existing SDN controller (in our implementation, Pox), and hosts applications that specify functions that should operate on different parts of flow space. The controller installs and configures elements on machines in the network, which interface to the controller via a shim (Placement). The controller also uses a wire protocol (e.g., OpenFlow) to configure flow-table entries in switches to steer traffic through the appropriate elements installed on machines (Steering).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>T re e 1 T 1 F a tT re e 2 F a tT re e 3 TwoFigure 8 :</head><label>11238</label><figDesc>Figure 8: Network utilization under different algorithms: Slick, Random, and Optimal.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Comparison of Slick placement with Random and Optimal placement algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Slick placement performance with increasing number of unique flow spaces that the application processes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Effect of different placement algorithms on traffic distribution, for different numbers of random source-destination pairs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Quantifying the benefits of Slick's different algorithms.ment; and (Slick,Slick) a version of Slick with Slick's placement and steering algorithms.In Figure12, we compare the link utilization and path lengths for the different algorithms. Figure12shows that Slick's steering algorithm contributes significantly to Slick's improvement's over random by providing reductions of both the median and 99th percentile path lengths (19%,30%) and link utilization (37%,34%) over random steering. We used a Fat-Tree topology. We deploy one element to process traffic of one flow space; with 16 randomly distributed source destination switch pairs across the network. The traffic matrix has both East-West and North-South traffic flows. Figure12ashows that Slick's placement results in higher link utilizations in exchange for deploying fewer element instances. Figure12bshows that Slick placement places elements in locations that provide shorter path length by restricting the number of elements used. In real-world networks, the presence of background traffic may result in higher overall traffic latencies, but we expect the results to be qualitatively similar; the respective differences in network performance between different configurations may be larger, as a reulst of this increased background traffic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Performance of Slick's steering algorithm compared to random steering. in a chain; c) Number of Element Instances in each stage of the chain. affect the run times of Slick's placement and steering modules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Effect of element chain size on Slick algorithms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>How different placement heuristics help achieve Slick objectives.</figDesc><table><row><cell>Heuristic Consolidation Inflation</cell><cell>Reduce b/w utilization Yes Yes</cell><cell>Reduce resource utilization Yes Yes</cell><cell>Reduce latency Yes</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Effect of network topology size on Slick's steering and placement algorithms.</figDesc><table><row><cell>Topology</cell><cell>Avg. Steering</cell><cell>Avg. Placement</cell></row><row><cell>Size (Nodes)</cell><cell>Time (ms)</cell><cell>Time (ms)</cell></row><row><cell>15</cell><cell>13</cell><cell>131</cell></row><row><cell>31</cell><cell>15</cell><cell>404</cell></row><row><cell>63</cell><cell>11</cell><cell>581</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Jennifer Rexford for her thoughtful comments throughput the course of this project. This work was supported by DARPA through the U.S. Navy SPAWAR under contract N66001-11-C-4017 and NSF Awards CNS-1531281, CNS-1261357, and CSR-1409249.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A scalable, commodity, data center network architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Al-Fares</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Loukissas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM Conference</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>Cited on page 8.</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Network Configuration in A Box: Towards End-to-End Verification of Network Reachability and Security</title>
		<author>
			<persName><forename type="first">E</forename><surname>Al-Shaer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Marrero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>El-Atawy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Elbadawi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ICNP</title>
		<meeting><address><addrLine>Princeton, NJ</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>Cited on page 11.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">xOMB: Extensible Open Middleboxes with Commodity Servers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Braud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kapoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ANCS</title>
		<meeting>ANCS</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Network traffic characteristics of data centers in the wild</title>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM Internet Measurement Conference</title>
		<meeting><address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-11">Nov. 2010</date>
		</imprint>
	</monogr>
	<note>Cited on page 8.</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Middleboxes: Taxonomy and Issues. Internet Engineering Task Force</title>
		<author>
			<persName><forename type="first">B</forename><surname>Carpenter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3234</biblScope>
			<date type="published" when="2002-02">Feb. 2002</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt" />
		<title level="m">Control groups</title>
		<imprint/>
	</monogr>
	<note>Cited on page 11.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Multi-Commodity Flow with In-Network Processing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Naamad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zou</surname></persName>
		</author>
		<ptr target="http://www.cs.princeton.edu/~jrex/papers/mopt14.pdf" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
		<respStmt>
			<orgName>Princeton University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">ETTM: Scalable Fault Tolerant Network Manager</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Uppal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Brajkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brandon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th USENIX NSDI</title>
		<meeting>8th USENIX NSDI<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-04">Apr. 2011</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Enter the Andromeda zone -Google Cloud Platform latest networking stack</title>
		<ptr target="http://goo.gl/u59Iw1" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="http://www.etsi.org/technologies-clusters/technologies/nfv" />
		<title level="m">ETSI Network Function Virtualization</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">BUZZ: Testing Context-Dependent Policies in Stateful Data Planes</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Fayaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tobioka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<idno>CMU-CyLab-14-013</idno>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Cited on page 11.</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Enforcing Network-wide Policies in the Presence of Dynamic Middlebox Actions Using Flowtags</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Fayazbakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th USENIX NSDI</title>
		<meeting>11th USENIX NSDI<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-04">Apr. 2014</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">FlowTags: Enforcing network-wide policies in the presence of dynamic middlebox actions</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Fayazbakhsh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking</title>
		<meeting>ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking<address><addrLine>Hong Kong, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-08">Aug. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Frenetic: A network programming language</title>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Story</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Functional Programming</title>
		<imprint>
			<date type="published" when="2011-09">Sept. 2011</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Stratos: Virtual Middleboxes as First-Class Entities</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gember</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Grandl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<idno>TR1771</idno>
		<imprint>
			<date type="published" when="2012-06">June 2012</date>
		</imprint>
		<respStmt>
			<orgName>University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Toward softwaredefined middlebox networking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gember</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ghadiyali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM Workshop on Hot Topics in Networks</title>
		<meeting>the 11th ACM Workshop on Hot Topics in Networks</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="7" to="12" />
		</imprint>
	</monogr>
	<note>Cited on page 1.</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">OpenNF: Enabling innovation in network function control</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gember-Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Viswanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Grandl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Khalid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
		<meeting><address><addrLine>Chicago, IL</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="163" to="174" />
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">OpenPipes: Prototyping high-speed networking systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Covington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM 2009 Demo Session</title>
		<imprint>
			<date type="published" when="2009-08">Aug. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Reproducible Network Experiments Using Container-based Emulation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Handigol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Lantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM CoNext Conference</title>
		<meeting>ACM SIGCOMM CoNext Conference</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Cited on page 8.</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A wakeup call for Internet monitoring systems: The case for distributed triggers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3nd ACM Workshop on Hot Topics in Networks (Hotnets-III)</title>
		<meeting>3nd ACM Workshop on Hot Topics in Networks (Hotnets-III)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">SoftCell: Scalable and flexible cellular core network architecture</title>
		<author>
			<persName><forename type="first">X</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vanbever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th International Conference on emerging Networking EXperiments and Technologies (CoNEXT)</title>
		<meeting>9th International Conference on emerging Networking EXperiments and Technologies (CoNEXT)</meeting>
		<imprint>
			<date type="published" when="2013-12">Dec. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Modeling Middleboxes</title>
		<author>
			<persName><forename type="first">D</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Network</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="20" to="25" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A Policy-aware Switching Layer for Data Centers</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tavakoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM Conference</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Real time network policy checking using header space analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kazemian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Whyte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th USENIX NSDI</title>
		<meeting>10th USENIX NSDI<address><addrLine>Lombard, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-04">Apr. 2013</date>
		</imprint>
	</monogr>
	<note>Cited on page 11.</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Veriflow: Verifying network-wide invariants in real time</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Caesar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Godfrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th USENIX NSDI</title>
		<meeting>10th USENIX NSDI<address><addrLine>Lombard, IL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-04">Apr. 2013</date>
		</imprint>
	</monogr>
	<note>Cited on page 11.</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Understanding the evolution of network configuration: A tale of two campuses</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM Internet Measurement Conference</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>Cited on page 8.</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Kinetic: Verifiable dynamic network control</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Reich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th USENIX NSDI</title>
		<meeting>12th USENIX NSDI<address><addrLine>Oakland, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The Click modular router</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="263" to="297" />
			<date type="published" when="2000-08">Aug. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">PACE: Policy-Aware Application Cloud Embedding</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Liaghat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hajiaghayi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Wilfong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">R</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM</title>
		<meeting><address><addrLine>Turin, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A set of measures of centrality based upon betweenness</title>
		<author>
			<persName><forename type="first">F</forename><surname>Linton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sociometry</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="35" to="41" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
	<note>Cited on page 6.</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<ptr target="https://linuxcontainers.org/" />
		<title level="m">Linux Containers</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Unikernels: library operating systems for the cloud</title>
		<author>
			<persName><forename type="first">A</forename><surname>Madhavapeddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mortier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rotsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gazagnaire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th International Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>18th International Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS)<address><addrLine>Houston, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-03">Mar. 2013</date>
		</imprint>
	</monogr>
	<note>Cited on page 11.</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Clickos and the art of network function virtualization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Raiciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bifulco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Huici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th USENIX Symposium on Networked Systems Design and Implementation (NSDI 14)</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014-04">Apr. 2014</date>
			<biblScope unit="page" from="459" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">OpenFlow: Enabling innovation in campus networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Communications Review</title>
		<imprint>
			<date type="published" when="2008-04">Apr. 2008</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A Compiler and Run-time System for Network Programming Languages</title>
		<author>
			<persName><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM POPL</title>
		<meeting><address><addrLine>Philadelphia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-01">Jan. 2012</date>
			<biblScope unit="page" from="217" to="230" />
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Verifying Isolation Properties in the Presence of Middleboxes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Lahav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Argyraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1409.7687" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>Cited on page 11.</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Bro: a System for Detecting Network Intruders in Real-Time</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="2435" to="2463" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
	<note>Cited on page 3.</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<ptr target="http://www.noxrepo.org/pox/about-pox/" />
		<title level="m">OpenFlow controller</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">SIMPLEfying Middlebox Policy Enforcement using SDN</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Qazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-C</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Split/Merge: System Support for Elastic Execution in Virtual Middleboxes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rajagopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jamjoom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Networked Systems Design and Implementation</title>
		<meeting><address><addrLine>Lombard, Illinois</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Design and implementation of a consolidated middlebox architecture</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Egi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th USENIX NSDI</title>
		<meeting>9th USENIX NSDI<address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-04">Apr. 2012</date>
		</imprint>
	</monogr>
	<note>Cited on pages 1, 2 and 9</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<ptr target="http://goo.gl/cQMV6k" />
		<title level="m">Service Function Chaining Problem Statement(IETF Draft RFC)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<ptr target="https://datatracker.ietf.org/wg/sfc/charter/" />
		<title level="m">SFC: Service Function Chaining</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Making middleboxes someone elseś problem: Network processing as a cloud service</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM<address><addrLine>Helsinki, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-08">Aug. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Fresco: Modular composable security services for softwaredefined networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Porras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Yegneswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Fong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tyson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<ptr target="https://www.snort.org/" />
		<title level="m">Snort intrusion detection system</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Merlin:a language for provisioning network resources</title>
		<author>
			<persName><forename type="first">R</forename><surname>Soule</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Marandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pedone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Sirer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CoNEXT</title>
		<meeting>CoNEXT</meeting>
		<imprint>
			<date type="published" when="2014-12">Dec. 2014</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Maple:simplifying sdn programming using algorithmic policies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">R</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM Conference</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Cited on page 2.</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">An untold story of middleboxes in cellular networks</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM<address><addrLine>Toronto, Ontario, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-08">Aug. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">StEERING: A Software-Defined Networking for Inline Service Chaining</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Beheshti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Beliveau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lefebvre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Patney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rubow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Subrahmaniam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Manghirmalani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shirazipour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Truchan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tatipamula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ICNP</title>
		<meeting><address><addrLine>Goettingen, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
