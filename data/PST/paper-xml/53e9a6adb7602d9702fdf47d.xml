<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Operational Semantics for StAC, a Language for Modelling Long-Running Business Transactions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michael</forename><surname>Butler</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Electronics and Computer Science</orgName>
								<orgName type="institution">University of Southampton Highfield</orgName>
								<address>
									<postCode>SO17 1BJ</postCode>
									<settlement>Southampton</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Carla</forename><surname>Ferreira</surname></persName>
							<email>carla.ferreira@dei.ist.utl.pt</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Technical University of Lisbon Av. Rovisco Pais</orgName>
								<address>
									<postCode>1049-001</postCode>
									<settlement>Lisbon</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Operational Semantics for StAC, a Language for Modelling Long-Running Business Transactions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">9DB350B1CF27A9ECDA8401752C21EB8E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents the StAC language and its operational semantics. StAC (Structured Activity Compensation) is a business process modelling language and a distinctive feature of the language is its support for compensation. A compensation is an action taken to recover from error or cope with a change of plan, especially when rollback of a process is not possible. StAC is similar to a process algebraic language such as Hoare's CSP or Milner's CCS but has additional operators dealing with compensation and with exception handling. In this paper we present an operational semantics for the language.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The StAC language (Structured Activity Compensation) was introduced in <ref type="bibr" target="#b2">[3]</ref> as a business process modelling language and includes constructs for modelling compensation in business processes. In the context of business transactions, Gray <ref type="bibr" target="#b10">[11]</ref> defines a compensation as the action taken to recover from error or cope with a change of plan. Compensation is a useful feature when modelling long running business transactions where rollback is not always possible because parts of a transaction will have been committed or because parts of a transaction (e.g., communications with external agents) are inherently impossible to undo. Consider the following example: a client buys some books in an on-line bookstore and the bookstore debits the client's account as the payment for the book order. The bookstore later realises that one of the books in the client's order is out of print. To compensate the client for this problem, the bookstore can credit the account with the amount wrongfully debited and send a letter apologising for their mistake. This example shows that compensation is more general than traditional rollback in database transactions. Compensation is important when a system cannot control everything, such as when interaction with humans is involved.</p><p>StAC gives a precise interpretation to the mechanics of compensation, including the combination of compensation with parallel execution, hierarchy and exceptions. StAC was inspired by the BPBeans framework <ref type="bibr" target="#b5">[6]</ref> that allows an application to be built by a nested hierarchy of business processes. Like BPBeans, StAC provides ways to coordinate basic acivities by supporting sequential and concurrent processes, as well as compensation and exceptions. Similar coordination mechanisms are found in the BizTalk <ref type="bibr" target="#b14">[15]</ref> and BPEL4WS <ref type="bibr" target="#b6">[7]</ref> business coordination languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The StAC Language</head><p>StAC has taken inspiration from other process algebras, especially Milner's Calculus for Communicating Systems (CCS) <ref type="bibr" target="#b15">[16]</ref> and Hoare's Communicating Sequential Processes (CSP) <ref type="bibr" target="#b11">[12]</ref>. Both CCS and CSP model processes in terms of the atomic events in which they can engage. The languages provide operators for defining structured processes such as sequencing, choice, parallel composition, communication and hiding. StAC provides a similar process term language along with operators for compensation and exceptions. A StAC process has global data state associated with it and this state is changed by atomic events (or activities).</p><p>Typically the data states of a StAC process are represented using state variables and the effect of atomic activities is represented using assignment to variables. Formally a system is described by a set of equations of the form N i = P i , where each N i is a process name and P i is a StAC process expression. The syntax of StAC processes is presented in Table <ref type="table" target="#tab_0">1</ref>. Note that recursion is allowed since a process P i may contain a call to a process named N j .</p><p>The specification of a system is not complete with the StAC equations alone, as we might also want to specify the effect of the basic activities on the information structures. Instead of extending StAC to include variables and expressions we use existing state-based formal notations to define the state variables and activities. Possible notations are Z <ref type="bibr" target="#b18">[19]</ref>, VDM <ref type="bibr" target="#b12">[13]</ref>, B <ref type="bibr" target="#b0">[1]</ref> and the guarded command language <ref type="bibr" target="#b7">[8]</ref>. Any formal notation where it is possible to define a state, and where operations are partial relations on that state may be used to complement StAC. Examples of the use of the B notation to specify the data states of a StAC process and the effect of activities on the variables may be found in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>.</p><p>The StAC language allows sequential and parallel composition of processes, and the usual process combinators. Besides these, it has specific combinators to deal with compensation. An overview of the language is given in this section. Each activity label A (in StAC) has an associated activity A → representing an atomic change in the state: if Σ is the set of all possible states, then A → is a relation on Σ. The process skip does nothing and immediately terminates successfully. This process has a similar interpretation to the CSP skip that describes successful termination. The process call call(N ) calls the process named N returning if and when N terminates successfully. Hiding is identical to the CSP hiding operator. With hiding one can make the execution of activities invisible to the environment. Sequential and Parallel Operators. The sequential construct combines two processes, P ; Q. In process P ; Q, P is executed first, and only when P terminates successfully can Q be executed.</p><p>In parallel process P X Q, the execution of the activities of P and Q is synchronised over the activities in X, while the execution of the remaining activities of P and Q is interleaved. Synchronisation can introduce deadlock, e.g., process P may be waiting to synchronise with Q over an activity A and that activity will never occur in Q. If set X is empty (no synchronisation) we will represent the parallel process as P Q.</p><p>Condition. Choice. The external choice P [] Q selects whichever of P or Q is enabled (i.e., not blocked). If both P and Q are enabled, the choice is made by the environment and it is resolved at the first activity. The environment could be a user selecting one of the options in a menu, for example. Notice that the [] operator causes nondeterminism in some cases. Consider the following example:</p><formula xml:id="formula_0">(A; B) [] (A; C).</formula><p>When activity A occurs it is not possible to determine which one of the two behaviours A; B or A; C will be chosen. In this case, the choice is made internally by the system rather than by the environment. Internal nondeterminism may be specified directly using the internal choice operator ( ).</p><p>The parallel and choice operators may be extended to generalised versions over (possibly infinite) sets of indexed processes. For example, a process that allows a user to choose a book could be described in StAC as:</p><formula xml:id="formula_1">[] b ∈ BOOK • ChooseBook.b</formula><p>Details of the generalised versions of the operators may be found in <ref type="bibr" target="#b8">[9]</ref> Attempt Block and Early Termination. An important feature in business processing is the possibility of terminating processes before they have concluded their main tasks. Early termination might arise if an exception occurs or a customer decides to abandon a transaction. It might also arise in the case of speculative parallelism, where several tasks, representing alternative ways of achieving a goal, are commenced in parallel and when one completes, the remaining tasks may be abandoned. We have included in StAC what we term an attempt block. An attempt block P {Q}R first executes Q, and if Q terminates successfully it then continues with P . If an early termination operation ( ) is executed within Q, the block continues with R. For example, the process C{A; ; B}D will first execute A, then the early termination will cause B to be skipped over and D to be executed. Any behaviour sequentially following the execution of early termination within an attempt block will be skipped. So an attempt block P {Q}R can be viewed as an exception construct, with early termination representing the raising of an exception and R representing the exception handler.</p><p>The effect of the early termination is limited to the attempt block so in the following process, the early termination in the attempt block has no effect on the process S running in parallel with the block:</p><formula xml:id="formula_2">{(P ; ; Q)} S</formula><p>(We write {Q} as short for skip{Q}skip.)</p><p>In the case of parallel processes within an attempt block, a termination instruction within one of the parallel process also affects the other processes. For example, in the process { (P ; ; Q) R } the early termination after P allows R to terminate early. Our use of the term 'allows' is deliberate here. R is not required to terminate immediately. It may continue for several more steps before terminating early, it may continue to completion or it may execute forever if it is a non-terminating process. In any case, if and when the main body of an attempt block terminates and at least one of its constituent process has executed an early termination, then the whole of the main body is deemed to have terminated early.</p><p>Compensation Operators. The next few StAC operators are related to compensation. In the compensation pair P ÷ Q, P is the primary process and Q is the compensation process. When a compensation pair runs, it runs the primary task, and once the primary process has successfully completed, the compensation process is remembered (installed) for possible later invocation.</p><p>The reverse operation ( ) causes the currently installed compensation handlers to be invoked. For example (A ÷ A ); will execute A, install A and then the reverse operation will cause A to be executed. The overall behaviour is A; A .</p><p>In the case of activities composed using sequential composition, the compensation process is constructed in the reverse order to the primary process execution. Consider the process (A ÷ A ); (B ÷ B ). This process behaves as A; B and has the compensation task B ; A . A sequential compensation task can be viewed as a stack where compensation processes are pushed on to the top of the stack. The process (A ÷ A ); (B ÷ B ); behaves as A; B, and then the operator causes the compensation task to be executed, so the overall behaviour is (A; B); (B ; A ) (which we write as A; B; B ; A ).</p><p>In the case of parallel processes, execution of compensations is also performed in parallel. The parallel process (A ÷ A ) (B ÷ B ) executes A and B concurrently and the resulting compensation process is A B .</p><p>The accept operation (P ) indicates that currently installed compensations should be cleared, meaning that after an accept the compensation task is set to skip. The process (A ÷ A ); (B ÷ B ); P ; executes A and B, when the operation is called the compensation task B ; A has already been cleared by the P operator so B ; A will not be executed.</p><p>Next we will consider the combination of compensation with choice. The process (A ÷ A ) [] (B ÷ B ) behaves as either A or B, the choice between A and B is made by the environment. The compensation task in the case that A is chosen is A and in the other case is B .</p><p>If the primary process terminates early, the compensation process will not be installed. For example, in the process: (A; ; B) ÷ C compensation C would not be installed because of the early termination in the primary process.</p><p>In the case that a compensation pair is running in parallel with a process that executes an early termination, this early termination cannot affect the compensation pair while the compensation pair is executing. So the compensation pair will either not get executed at all or will be expected to execute to completion, including installation of the compensation handler. For example, the process { (A ÷ B) } will either behave as skip or as (A ÷ B).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scoping of Compensation. The compensation scoping brackets [• • •</head><p>] provide nested compensation scoping are used to delimit the scope of the acceptance and reversal operators. All StAC processes have an implicit outer compensation scope. The start of scope creates a new compensation task, and invoking a reversal instruction within that scope will only execute those compensation activities that have been remembered since the start of the scope. In the process</p><formula xml:id="formula_3">(A ÷ A ); [ (B ÷ B ); ],</formula><p>the overall process would behave as A; B; B . Compensation A is not invoked because its outside the scope of the reversal instruction. An acceptance instruction, within a scope, will only clear the compensation activities that have been recorded since the start of the scope. For example, the process:</p><formula xml:id="formula_4">(A ÷ A ); [ (B ÷ B ); P ]; (C ÷ C )</formula><p>after A, B and C have been executed, has C ; A as compensation. Since the acceptance instruction is within the compensation scope, it just clears the compensation process B that is within the brackets. Another feature of compensation scoping is that compensation is remembered beyond a scope if a reversal instruction is not performed, as in the example:</p><formula xml:id="formula_5">(A ÷ A ); [ (B ÷ B ) ]; (C ÷ C ).</formula><p>Here, after executing A; B; C the compensation process is C ; B ; A , which includes the compensation process B of the inner scope. B is retained because there is no acceptance instruction within the brackets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example: Order Fulfillment</head><p>To illustrate the use of StAC we present the order fulfillment example described in <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr" target="#b4">[5]</ref>. ACME Ltd distributes goods which have a relatively high value to its customers. When the company receives an order from a customer, the first step is to verify whether the stock is available. If not available the customer is informed that his/her order can not be accepted. Otherwise, the warehouse starts preparing the order for shipment, and a courier is booked to deliver the goods to the customer. Simultaneously with the warehouse preparing the order, the company does a credit check on the customer to verify that the customer can pay for the order. The credit check is performed in parallel because it normally succeeds, and in this normal case the company does not wish to delay the order unnecessarily. If the credit check fails the preparation of the order is stopped.</p><p>Here we present a very simple representation of the order acceptance and focus on the order fulfillment part in more detail. Before presenting the ACME process, we introduce the following syntactic sugar:</p><formula xml:id="formula_6">TRY P THEN Q ELSE R = Q{P }R IF G THEN P ELSE Q = G&amp;P [] ¬G&amp;Q</formula><p>At the top level the application is defined as a sequence as follows:</p><formula xml:id="formula_7">ACME = AcceptOrder ÷ RestockOrder;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TRY FulfillOrder THEN P ELSE</head><p>The first step in the ACME process is a compensation pair. The primary action of this pair is to accept the order and deduct the order quantity from the inventory database. The compensation action is simply to add the order quantity back to the total in the inventory database. Following the compensation pair, the FulfillOrder process is invoked. If the order has been fulfilled correctly (FulfillOrder terminates sucessfully), the order is accepted, otherwise (FulfillOrder terminates early) the order is reversed.</p><p>Notice that some processes are written with a bold font, e.g., AcceptOrder, this means that those processes are activity labels, so they are not further decomposed.</p><p>The order is fulfilled by packaging the order at the warehouse while concurrently doing a credit check on the customer. If the credit check fails, the FulfillOrder process is terminated early:</p><formula xml:id="formula_8">FulfillOrder = WarehousePackaging (CreditCheck; IF ¬okCreditCheck THEN ELSE skip)</formula><p>Because WarehousePackaging is within the scope of the early termination, a failed credit check allows WarehousePackaging to terminate early, possible before all the items in the order have been packed. The WarehousePackaging process consists of a compensation pair in parallel with the PackOrder process:</p><formula xml:id="formula_9">WarehousePackaging = (BookCourier ÷ CancelCourier) PackOrder</formula><p>The compensation pair books the courier, with the compensation action being to cancel the courier booking. CancelCourier might result in a second message being sent to the courier rather than reversing the send of the message which booked the courier. The PackOrder process packs each of the items in the order in parallel. Each PackItem activity is reversed by a corresponding UnpackItem:</p><formula xml:id="formula_10">PackOrder = i ∈ order • (PackItem(i) ÷ UnpackItem(i))</formula><p>In the case that a credit check fails, the FulfillOrder process terminates early with the courier possibly having been booked and possibly some of the items having being packed. The reversal instruction will then be invoked and will result in the appropriate compensation activity being invoked for those activities that did take place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Semantics</head><p>In this section we will present the operational semantics for StAC. To do this we introduce a variant of the language called StAC i to which we give an operational semantics. We refer to StAC i as the semantic language. In StAC i , a process can have several simultaneous compensation tasks associated with it. A process decides which task to attach the compensation activities to, and each individual compensation task can be reversed or accepted. This contrasts with the language presented in Section 2, where scoping of compensation is hierarchical and each scope has a single implicit compensation task. To distinguish different compensation tasks, the operators that deal with compensation, i.e., compensation pair, acceptance and reversal, are indexed by the compensation task index to which they apply. The syntax of StAC i is presented in Table <ref type="table" target="#tab_2">2</ref>. Later we define a translation from StAC to StAC i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Semantic Language</head><p>Several of the StAC i operators are retained from StAC without any alterations. The changes concern operators that deal with compensation and early termination (indicated with bold font in Table <ref type="table" target="#tab_2">2</ref>). </p><formula xml:id="formula_11">P ; Q (sequence) | i (indexed reverse) | P X Q (parallel) | P i (indexed accept) | P Q (internalchoice) | ↑ i P (push) | P [] Q (externalchoice) | J £ i (merge)</formula><p>After an early termination, the process within an attempt block may continue to execute for several steps before terminating. To deal with this we have added a boolean flag v to the attempt block representing the following two possibilities: P {Q} false R -Process Q can continue its execution since no early termination instruction has been invoked within Q. P {Q} true R -An early termination instruction has previously been invoked within the attempt block and process Q may terminate prematurely.</p><p>The term early represents a process that has terminated early. It is used to distinguish a process that has terminated early from a process that has terminated successfully (skip).</p><p>In some case we require that a process that has already commenced execution, e.g., a compensation pair, be protected from early termination caused by another process within an attempt block. This is achieved using the protection block |P | v . The boolean flag v will initially be false, and once the protected process executes its first visible activity the flag will be changed to true and P will then be protected from an early termination originating from outside the protection block. A protection block may still be terminated by an early termination invocation within the protection block.</p><p>In our semantics, the compensation information of a process is maintained by a compensation function that maps each compensation task index to a compensation process. The accept and reverse operators are subscripted with the index of the compensation process to which they should be applied. In the StAC i language we introduce the push operator that stores a compensation process in a compensation task, i.e., ↑ i Q will store Q on top of compensation task i, where i is an index. A compensation pair P ÷ i Q can be defined in terms of the push operator as follows:</p><formula xml:id="formula_12">| P ; ↑ i Q | false .</formula><p>Here, P will be executed first and after it has concluded its execution the process push will store Q in task i. The protection block ensures that, once the process P ; ↑ i Q has commenced, it is not affected by early termination emanating from outside the protection block.</p><p>An important operator in StAC i is the merge operator. The expression J £ i, where J is a set of indices, merges all compensation tasks belonging to J into the compensation task i. All compensation tasks in J are put in parallel, the result is added to the compensation task i and all compensation tasks J are cleared. For example, in the process (A ÷ i A ); (B ÷ j B ); {i, j} £ k the merge operator will compose in parallel the compensation task i (A ) with compensation task j (B ), and add parallel process A B to compensation task k. Compensation tasks i and j will be removed.</p><p>Consider the following process that uses three individual compensation tasks:</p><formula xml:id="formula_13">(A ÷ i A ); (B ÷ j B ); (C ÷ k C ); {i, j} £ k.</formula><p>Initially it executes A, B and C and then merges compensation tasks i and j into compensation task k. Joining compensation tasks i and j results in the parallel process A B , that will be put in front of the compensation task k, giving (A B ); C as the resulting compensation for task k.</p><p>The new(i).P i construct in StAC i creates a new compensation task identified by bound variable i. This can be used to model the compensation scope of StAC. For example, the StAC process</p><formula xml:id="formula_14">(A ÷ A ); [(B ÷ B ); ; (C ÷ C )] can be represented in StAC i as (A ÷ i A ); new(j).((B ÷ j B ); j ; (C ÷ j C ); {j} £ i)</formula><p>When the reversal instruction is invoked on compensation task j it will only execute B . Compensation process A that in StAC was outside the scope, in StAC i is in a different compensation task, and does not get invoked. The merge is used to preserve any compensations not reversed within the scoping brackets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Operational Semantics for Compensation</head><p>This section presents the operational semantics for the StAC i operators excluding termination operators. The semantics of termination is described in Section 3.3. Plotkin <ref type="bibr" target="#b17">[18]</ref> describes how to use transition systems to define an operational semantics; here a system is defined in terms of transition rules between configurations. For the operational semantics of StAC i , a configuration is a tuple:</p><p>(P, C, σ) ∈ P rocess × (I → P rocess) × Σ</p><p>In the above tuple, C is a function that returns the compensation process C(i), for each compensation index i. If C(i) =⊥, then the compensation is not in use. Σ represents the data state and Σ is included in our model of StAC processes since we want to model the ability of a basic activity to change the data state.</p><p>The labelled transition (P, C, σ)</p><formula xml:id="formula_15">A -→ (P , C, σ )<label>( 1 )</label></formula><p>denotes that the execution of a basic activity A may cause a configuration transition from (P, C, σ) to (P , C, σ ). Notice that the execution of a basic activity does not alter the compensation function. Instead, only the compensation operators may alter the compensation function.</p><p>In the configuration transition (1) we used an activity as the transition label, but two other labels may be used, they are τ and . The set B of all possible transition labels is defined as:</p><formula xml:id="formula_16">B = A ∪ {τ, }</formula><p>where A represents the set of all activity labels. The label τ is a special label that represents an operation not visible to the external environment. In the transition rules we consider that label B ∈ B, while A ∈ A. Activity. We assume that an activity is a relation from states to states, and write σ A → σ when σ is related to σ by A →. The execution of an activity imposes a change in the state, leaving the compensation function unchanged:</p><formula xml:id="formula_17">σ A → σ (A, C, σ) A -→ (skip, C, σ )</formula><p>Conditional. In the conditional process b &amp; P the execution of P is guarded by a boolean function b. If the boolean function b is true in the current state σ, then P may be executed:</p><formula xml:id="formula_18">(P, C, σ) B -→ (P , C , σ ) ∧ b(σ) = true (b &amp; P, C, σ) B -→ (P , C , σ )</formula><p>Notice that when B is an activity, the guard is evaluated in the state to which the activity B is applied, ensuring that b holds when the activity is executed. Since there is no transition rule dealing with a false guard, a false guard causes the process to block. Name Process Call. The call of a process N (where N = P is an equation) will substitute call(N ) by the process on the left-side of the equation:</p><formula xml:id="formula_19">N = P (call(N ), C, σ) τ -→ (P, C, σ)</formula><p>Hiding. The rule on the left below says that the hiding operator makes the occurrence of an activity labelled from set S invisible to the environment. The rule on the right states that the occurrence of an activity not labelled from S is visible:</p><formula xml:id="formula_20">(P, C, σ) A -→ (P , C , σ ) ∧ A ∈ S (P \ S, C, σ) τ -→ (P \ S, C , σ ) (P, C, σ) B -→ (P , C , σ ) ∧ B / ∈ S (P \ S, C, σ) B -→ (P \ S, C , σ )</formula><p>Hiding events in skip is the same as skip:</p><formula xml:id="formula_21">(skip \ S, C, σ) τ -→ (skip, C, σ)</formula><p>Sequence. The next rule shows the execution of activities within the first process of a sequential composition:</p><formula xml:id="formula_22">(P, C, σ) B -→ (P , C , σ ) (P ; Q, C, σ) B -→ (P ; Q, C , σ )</formula><p>If the first process in the sequence has terminated successfully, then the second process can be executed immediately:</p><formula xml:id="formula_23">(skip; Q, C, σ) τ -→ (Q, C, σ)</formula><p>Parallel. The rule below shows that the occurrence of activity A ∈ X requires processes P and Q to synchronise in</p><formula xml:id="formula_24">P X Q: A ∈ X ∧ (P, C, σ) A -→ (P , C, σ ) ∧ (Q, C, σ) A -→ (Q , C, σ ) (P X Q, C, σ) A -→ (P X Q , C, σ )</formula><p>Notice that both processes refer to the same basic activity which updates the state from σ to σ . This is because the state is intended to be global and the parallel processes do not have their own local state.</p><p>The following two rules specify that parallel processes can evolve independently for B ∈ X:</p><formula xml:id="formula_25">B ∈ X ∧ (P, C, σ) B -→ (P , C , σ ) (P X Q, C, σ) B -→ (P X Q, C , σ ) B ∈ X ∧ (P, C, σ) B -→ (P , C , σ ) (Q X P, C, σ) B -→ (Q X P , C , σ )</formula><p>The rule below states that the parallel process P X Q terminates (i.e., reduces to skip) when both P and Q terminate:</p><formula xml:id="formula_26">(skip X skip, C, σ) τ -→ (skip, C, σ)</formula><p>Internal Choice. Internal choice decides nondeterministically which process P or Q will occur:</p><formula xml:id="formula_27">(P Q, C, σ) τ -→ (P, C, σ) (P Q, C, σ) τ -→ (Q, C, σ)</formula><p>External Choice. The next two rules state that in P [] Q only one of the processes P or Q is executed:</p><formula xml:id="formula_28">(P, C, σ) B -→ (P , C , σ ) ∧ B = τ (P [] Q, C, σ) B -→ (P , C , σ ) (P, C, σ) B -→ (P , C , σ ) ∧ B = τ (Q [] P, C, σ) B -→ (P , C , σ )</formula><p>The following rules state that the occurrence of internal actions will not resolve the choice between P and Q:</p><formula xml:id="formula_29">(P, C, σ) τ -→ (P , C , σ ) (P [] Q, C, σ) τ -→ (P [] Q, C , σ ) (Q, C, σ) τ -→ (Q , C , σ ) (P [] Q, C, σ) τ -→ (P [] Q , C , σ )</formula><p>Create Compensation Task. The rule for the new construct selects an index for a compensation task that is not in use and sets that task to skip:</p><formula xml:id="formula_30">C(k) =⊥ (new(i).P i , C, σ) τ -→ (P k , C[k := skip], σ) C[k := skip] denotes that compensation task k is set to skip.</formula><p>Push. The rule for the push operator adds the compensation process Q to the compensation function C:</p><formula xml:id="formula_31">(↑ i Q, C, σ) τ -→ (skip, C[i := (Q; C(i))], σ) C[i := Q; C(i)]</formula><p>denotes that compensation task i is set to Q in sequence with the previous compensation for task i. In this manner, the compensation process is built in the reverse order of the execution of the primary processes.</p><p>Reverse. In the next rule, the operator i causes the compensation task i to be executed, and also resets that compensation task to skip:</p><formula xml:id="formula_32">( i , C, σ) τ -→ (C(i), C[i := skip], σ)</formula><p>Note that compensation tasks do not store any state with them: if the state changes between the compensation being stored and executed, the current state is used.</p><p>Accept. The operator P i clears the compensation task i to skip without executing it:</p><formula xml:id="formula_33">(P i , C, σ) τ -→ (skip, C[i := skip], σ)</formula><p>Merge. The operator J £ i merges all compensation tasks of set J in parallel on to the front of compensation task i:</p><formula xml:id="formula_34">(J £ i, C, σ) τ -→ (skip, C[ i := (||j ∈ J . C(j)); C(i), J :=⊥ ], σ)</formula><p>In the above rule the expression J :=⊥ denotes attributing to all tasks of set J the value ⊥ meaning these tasks are no longer in use. Set J must be disjoint from i.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Operational Semantics for Termination</head><p>This section concludes the presentation of StAC i semantics by defining the operational rules related to early termination.</p><p>Protected Block. This rule states that the occurrence of a basic activity within a protected process P will place the label true on the protection block. It is not necessary to distinguish whether the value v is initially true or false, in both cases the final label will be true:</p><formula xml:id="formula_35">(P, C, σ) B -→ (P , C , σ ) ∧ B = τ ∧ v ∈ BOOL ( |P | v , C, σ ) B -→ ( |P | true , C , σ )</formula><p>Note that occurrence of a τ is not regarded as commencing a protection block so the above rule does not apply to τ . The following rule deals with τ :</p><formula xml:id="formula_36">(P, C, σ) τ -→ (P , C , σ ) ∧ v ∈ BOOL ( |P | v , C, σ ) τ -→ ( |P | v , C , σ )</formula><p>A terminated protection block becomes skip:</p><formula xml:id="formula_37">( |skip| v , C, σ ) τ -→ ( skip , C, σ )</formula><p>Early Termination. Invocation of the early termination operation causes a process to execute a visible -event and then become the early process:</p><formula xml:id="formula_38">( , C, σ) -→ early, C, σ)</formula><p>Later, when the rules for the attempt block are presented, it will be seen that this early termination event will cause the enclosing attempt block to commence early termination and that the event will be contained within the enclosing attempt block and will not be visible outside it. In a sequential process if the first process has terminated early, the overall sequential process is interrupted and terminates early: The terminate function terminates all constituents of P except for compensation merge operations and protected blocks that have commenced execution. The early process is added to ensure that the indication of early termination is maintained. Allowing the merge to be executed is important because merging of compensations will typically be required before exiting an attempt block. The terminate function is defined later in this section.</p><p>A consequence of the previous rule is that if in a compensation pair the primary process terminates early, the overall process terminates early and the compensation process Q will not be installed.</p><p>Hiding or protection of an early terminated process gives an early terminated process:</p><formula xml:id="formula_39">(early \ S , C, σ) τ -→ (early , C, σ) (|early| v , C, σ) τ -→ (early , C, σ)</formula><p>In a parallel process if both have terminated early, or one has terminated early and the other has terminated early, the overall process will terminate early:</p><formula xml:id="formula_40">(early X early, C, σ) τ -→ (early, C, σ) (early X skip, C, σ) τ -→ (early, C, σ) (skip X early, C, σ) τ -→ (early, C, σ)</formula><p>Attempt Block. If the main body of an attempt block can engage in an early termination event, then its termination flag is set to true and the early termination event is made invisible:</p><formula xml:id="formula_41">(Q, C, σ) -→ (Q , C, σ) (P { Q } v R, C, σ) τ -→ (P { Q } true R, C, σ)</formula><p>When the main body of an attempt block terminates successfully, the left hand continuation process will be executed:</p><formula xml:id="formula_42">(P {skip} v R, C, σ) τ -→ (P, C, σ)</formula><p>(The flag v will always be f alse whenever an attempt block body evolves to skip.)</p><p>When the main body of an attempt block terminates prematurely, the right hand continuation process will be executed:</p><formula xml:id="formula_43">(P {early} v R, C, σ) τ -→ (R, C, σ)</formula><p>An attempt block may also evolve by executing events of the main body other than , regardless of the value of the flag v:</p><formula xml:id="formula_44">(Q, C, σ) B -→ (Q , C , σ ) ∧ B = (P {Q} v R, C, σ) B -→ (P {Q } v R, C , σ )</formula><p>When the termination flag has been set to true, the main body of an attempt block may terminate early. However, all protected blocks that have started their execution are made to complete their execution. This is provided for in as follows:</p><formula xml:id="formula_45">(P {Q} true R, C, σ) τ -→ (P {terminate(Q)} false R, C, σ)</formula><p>Note that setting the termination flag back to f alse in this rule prevents terminate being applied infinitely which would otherwise cause an infinite cycle of τ events. Function terminate. The terminate function clears all processes that no longer should continue and keeps the protected blocks that have already started. The first three definitions below show processes that may continue running, as they may contain protected blocks. The fourth rule says that a merge of compensation tasks is allowed to execute. The fifth rule shows that early termination is propagated by terminate:</p><formula xml:id="formula_46">terminate(P ; Q) = terminate(P ); terminate(Q) terminate(P X Q) = terminate(P ) X terminate(Q) terminate(P {Q} v R) = {terminate(Q)} v terminate(J £ i) = J £ i terminate(early) = early</formula><p>The next rule shows that a protected block that has not started its execution (its flag is false) is terminated immediately. The rule following that states that a protected block that has started its execution (its flag is true) can continue until it has finished:</p><formula xml:id="formula_47">terminate(|P | false ) = skip terminate(|P | true ) = |P | true</formula><p>The final rule applies to any process not matching the previous rules for terminate. Such processes are made to finish immediately:</p><formula xml:id="formula_48">terminate(P ) = skip</formula><p>It is easy to show that terminate is idempotent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Translation from StAC to StAC i</head><p>We define a semantics for the StAC language by defining a translation of StAC processes into StAC i processes. This way the interpretation of a StAC process is given in terms of a StAC i process.</p><p>For each process definition of the form N = P , we construct an indexed process definition:</p><formula xml:id="formula_49">N i = T(P, i)</formula><p>where T translates a process written in the syntax of StAC to a process in the syntax of StAC i in the context of compensation index i. The translation function T is shown in Table <ref type="table" target="#tab_3">3</ref>. For the translation to work correctly, the root StAC process definition should be of the form N = [P ], ensuring that the outermost compensation task is properly created.</p><p>The first three rules of the translation function T show that basic activities, skip and have the same representation in StAC and StAC i . The next rule shows that a call to process named N in the context of index i becomes a call to process N i . </p><formula xml:id="formula_50">(A, i) =A T(skip, i) = skip T( , i) = T(call(N ), i) = call(Ni) T( , i) = i T(P , i) =P i T(P ÷ Q, i) = |T(P, i) ÷i T(Q, i)| f alse T(b &amp; P, i) = b &amp; T(P, i) T(P \ S, i) = T(P, i) \ S T(P ; Q, i) = T(P, i) ; T(Q, i) T(P [] Q, i) = T(P, i) [] T(Q, i) T(P Q, i) = T(P, i) T(Q, i) T(P {Q}R, i) = T(P, i){T(Q, i)}T(R, i) T([P ], i) =new(j).( T(P, j); {j} £ i ) T(P X Q, i) = new(j, k).( (T(P, j) X T(Q, k)); {j, k} £ i )</formula><p>The StAC i representation for the compensation operators accept, reverse, and compensation pair, is obtained by adding a compensation task index to each of them.</p><p>The remaining rules (except the last two), show how to translate composite constructs. The translation rules are defined on the constituents of the constructor.</p><p>Because the order of execution of P X Q is not known, their compensation should not have a predefined order of execution. So each parallel process will have a new compensation task. This way their compensation processes will also be a parallel process: the parallel composition of the new compensation tasks. In the translation rule for P Q, two new compensations tasks j and k are created and processes P and Q are translated using j and k. The resulting processes will be composed in parallel. Lastly, the new compensation tasks j and k are merged into the initial task i, which means that the compensations of the parallel processes are retained (unless they have been explicitly committed). Notice that compensation tasks are merged in parallel, so the outcome of the merge is process C(j) C(k), that will be pushed on top of C(i).</p><p>The compensation scoping brackets [P ] are translated to a new compensation task j and process P is translated using index j. Then the compensation task j is merged into the initial index i, so all the compensation information that was not reversed or accepted can be preserved by adding it to compensation task i.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions</head><p>The semantic definition of StAC is somewhat complicated, in particular the use of indexed compensation tasks. An alternative approach would be to embed the installed compensations within the process terms, for example, by representing a scope in the form [P, Q] where P is the remaining process to be executed within the scope and Q represents the compensation installed so far for this scope. However the interaction between early termination and compensation means that installed compensations must be preserved whenever a scope terminates early. Because scopes can be nested, this requires that the installed compensations for the nested scopes need to be accumulated before a process terminates. We found it easier to describe this by separating the installed compensations from the process terms which in turn required the use of indexed compensation.</p><p>In <ref type="bibr" target="#b4">[5]</ref> we have used indexed compensation to explore generalisations of the modelling language in which processes may have multiple compensation 'threads'. It is not clear how useful this is in its full generality, but two idioms do appear to be useful: selective compensation, where some activities are compensated and others are not (yet) compensated, and alternative compensation, where activities can have several alternative compensations and the compensation to be selected may depend on the nature of the exception.</p><p>The use of indexed compensation should also make it possible to model the style of compensation used in BPEL4WS <ref type="bibr" target="#b6">[7]</ref>. BPEL4WS supports similar operators to StAC, such as compensation, concurrency, and sequencing. In BPEL4WS, reversal is invoked through exception handlers, while acceptance is implicit in scoping. Reversal (called compensate in BPEL4WS) can identify particular subprocesses which should be compensated and this can be modelled using indexed compensation. BPEL4WS is layered on top of XML (its processes and data are specified in the BPEL dialect of XML), and at the moment BPEL4WS does not have a formal semantics. We plan to investigate further the use of StAC to give a semantics to BPEL4WS.</p><p>In <ref type="bibr" target="#b13">[14]</ref>, a compensation is formalised in terms of the properties it has to guarantee. However, <ref type="bibr" target="#b13">[14]</ref> does not provide a modelling language as StAC does, rather it provides a characterisation of properties of compensation. Bocchi et al <ref type="bibr" target="#b1">[2]</ref> define a language πt-calculus for modelling long-running transactions based on Milner's π-calculus <ref type="bibr" target="#b16">[17]</ref>. The πt-calculus includes a transaction construct that contains a compensation handler and a fault manager. ConTracts <ref type="bibr" target="#b19">[20]</ref> attempt to provide a structured approach to compensation. In ConTracts the invocation of a particular compensation has to be made explicitly within a conditional instruction (if the outcome of a step is false, then a specific task is executed to compensate for this). ConTracts do not have the notion of installing a compensation handler nor acceptance nor reversal found in StAC.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>early; P, C, σ) τ -→ (terminate(P ); early, C, σ)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>StAC Syntax</figDesc><table><row><cell>Process ::= A</cell><cell>(activity label)</cell><cell cols="2">| P Q (internal choice)</cell></row><row><cell>| skip</cell><cell>(skip)</cell><cell cols="2">| P {Q}R (attempt block)</cell></row><row><cell cols="2">| b &amp; P (condition)</cell><cell>|</cell><cell>(early termination of attempt)</cell></row><row><cell cols="4">| call(N ) (call named process) | P ÷ Q (compensation pair)</cell></row><row><cell cols="2">| P \ S (hiding)</cell><cell>|</cell><cell>(reverse)</cell></row><row><cell>| P ; Q</cell><cell>(sequence)</cell><cell>| P</cell><cell>(accept)</cell></row><row><cell>| P</cell><cell>Q (parallel)</cell><cell>| [P ]</cell><cell>(compensation scoping)</cell></row><row><cell>X</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">| P [] Q (external choice)</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>StACi Syntax ([P ] and P ÷ Q are derived operators)</figDesc><table><row><cell>Process ::= A</cell><cell>(activitylabel)</cell><cell>|</cell><cell>(earlytermination)</cell></row><row><cell>| skip</cell><cell>(skip)</cell><cell>| P {Q}vR</cell><cell>(attempt block)</cell></row><row><cell cols="2">| b &amp; P (conditional)</cell><cell>| early</cell><cell>(premature termination)</cell></row><row><cell cols="3">| call(N ) (namedprocesscall) | |P |v</cell><cell>(protection block)</cell></row><row><cell cols="2">| P \ S (hiding)</cell><cell cols="2">| new(i).Pi (new compensation task)</cell></row><row><cell>|</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 .</head><label>3</label><figDesc>Translation Rules</figDesc><table><row><cell>T</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>R. de Nicola et al. (Eds.): COORDINATION 2004, LNCS 2949, pp. 87-104, 2004. c Springer-Verlag Berlin Heidelberg 2004</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The B-Book: Assigning Programs to Meanings</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename></persName>
		</author>
		<idno>1996. 88</idno>
		<imprint>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A calulus for long-running transactions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bocchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FMOODS&apos;03</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">LNCS</biblScope>
			<biblScope unit="page">103</biblScope>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A process compensation language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Integrated Formal Methods(IFM&apos;2000)</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
	<note>volume 1945 of LNCS</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">An introduction to compensation with business process beans</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chessell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vines</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Griffin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-08">August 2001</date>
			<biblScope unit="page">92</biblScope>
		</imprint>
		<respStmt>
			<orgName>Transaction Processing Design and New Technology Development Group, IBM UK Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Extending the concept of transaction compensation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chessell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vines</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Henderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Systems Journal</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">103</biblScope>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Business process beans: System design and architecture document</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chessell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vines</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Warr</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-01">January 2001</date>
			<biblScope unit="page">88</biblScope>
		</imprint>
		<respStmt>
			<orgName>Transaction Processing Design and New Technology Development Group, IBM UK Laboratories</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Business process execution language for web services</title>
		<author>
			<persName><forename type="first">F</forename><surname>Curbera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Goland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Leymann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Roller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thatte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Weerawarana</surname></persName>
		</author>
		<ptr target="http://www-106.ibm.com/developerworks/library/ws-bpel/" />
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="page">103</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A Discipline of Programming</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<title level="m">Precise Modelling of Business Processes with Compensation</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="page">89</biblScope>
		</imprint>
		<respStmt>
			<orgName>University of Southampton</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Using B Refinement to Analyse Compensating Business Processes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Butler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third International ZB Conference (ZB&apos;2003), volume 2651 of LNCS</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Transaction Processing: Concepts and Techniques</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Reuter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<biblScope unit="page">87</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Jones</surname></persName>
		</author>
		<title level="m">Systematic Software Development Using VDM</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A formal approach to recovery by compensating transactions</title>
		<author>
			<persName><forename type="first">H</forename><surname>Korth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th VLDB Conference</title>
		<meeting><address><addrLine>Brisbane, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page">103</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">BizTalk Server 2000 Business Process Orchestration</title>
		<author>
			<persName><forename type="first">B</forename><surname>Metha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Beckman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mital</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Engineering Bulletin</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">88</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and Concurrency</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A calculus of mobile processes, I and II</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">103</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A structural approach to operational semantics</title>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
		<idno>DAIMI FN-19</idno>
		<imprint>
			<date type="published" when="1981-09">September 1981</date>
			<biblScope unit="page">95</biblScope>
		</imprint>
		<respStmt>
			<orgName>Aarhus University, Computer Science Department</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Spivey</surname></persName>
		</author>
		<title level="m">The Z Notation</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page">88</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Database Transaction Models for Advanced Applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wachter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Reuter</surname></persName>
		</author>
		<editor>A. Elmagarmid</editor>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Morgan Kaufmann Publishers</publisher>
			<biblScope unit="page">103</biblScope>
		</imprint>
	</monogr>
	<note>The ConTract model</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
