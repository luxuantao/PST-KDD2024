<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Interpretation of Type Theory in Locally Cartesian Closed Categories</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Martin</forename><surname>Hofmann</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Edinburgh JCMB</orgName>
								<address>
									<addrLine>Mayfield Rd</addrLine>
									<postCode>EH9 3JZ</postCode>
									<settlement>Edinburgh</settlement>
									<region>KB</region>
									<country key="GB">Scotland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Interpretation of Type Theory in Locally Cartesian Closed Categories</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">981E3308340FA939A0BEA8E9A6ED02EB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T10:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show how to construct a model of dependent type theory (category with attributes) from a locally cartesian closed category (lccc). This allows to define a semantic function interpreting the syntax of type theory in an lccc. We sketch an application which gives rise to an interpretation of extensional type theory in intensional type theory.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction and Motivation</head><p>Interpreting dependent type theory in locally cartesian closed categories (lcccs) and more generally in (non split) fibrational models like the ones described in <ref type="bibr" target="#b6">[7]</ref> is an intricate problem. The reason is that in order to interpret terms associated with substitution like pairing for Z-types or application for H-types one needs a semantical equivalent to syntactic substitution. To clarify the issue let us have a look at the "naive" approach described in Seely's seminal paper <ref type="bibr" target="#b13">[14]</ref> which contains a subtle inaccuracy.</p><p>Assume some dependently typed calculus like the one defined in <ref type="bibr" target="#b9">[10]</ref> and an lccc C (a category with finite limits and right adjoints to every pullback functor in order to interpret dependent product types.)</p><p>The idea is to interpret contexts as objects in C, types in context /~ as morphisms with codomain the interpretation of F, and terms as sections (right inverses) of the interpretation of their types. Now the empty context gets interpreted as the terminal object and a context F,z:c~ gets interpreted as the domain of the interpretation of F k cr type. A Z-type Zz: o-.7" in context F gets interpreted as the composition s o t where s is the interpretation of cr and t is the interpretation of r in (context F, z: ~). This "typechecks" because the codomain of t is the interpretation of F, x: c~ which is the domain of the interpretation of g. The problem appears when we try to interpret pairing. Assume/~ ~-M : cr is a term of type cr and F F N : fix := M] is a term of type v with x replaced by M. We want to interpret their pairing F b-(M, N) : Zx: g.r. Let m and n be the interpretations of the former and the latter. The morphism m is a section of s and n is a section of the interpretation of v[x :--M] which a priori has nothing to do with t --the interpretation of ~'. Seely argues that substitution should be interpreted as a pullback, so that the interpretation of r[x := M] becomes the pullback of t along m. One might then interpret the pair (M, N) as the composition m ~ o n where m ~ is the upper arrow of this pullback.</p><p>The subtle flaw of this idea is that the interpretation of fix := M] is already fixed by the clauses of the interpretation and there is no reason why it should equal the chosen pullback of t along m.</p><p>Curien <ref type="bibr" target="#b4">[5]</ref> addresses the problem by making substitution a syntactic operator which may then be interpreted as (chosen) pullback. However, this changes the calculus and also results in a quite complicated interpretation function for as explained in <ref type="bibr" target="#b4">[5]</ref> type equality must be modelled by isomorphism instead of actual semantic equality.</p><p>On the other hand interpretation of type theory is relatively straightforward if one has a model equipped with a semantic substitution operation which commutes with composition and all semantic type and term formers. In this case one can show that syntactic and semantic substitution do agree. The technique of interpreting type theory in such a model has been worked out by Streicher <ref type="bibr" target="#b14">[15]</ref> in great detail. See also Pitts' forthcoming survey article <ref type="bibr" target="#b11">[12]</ref>.</p><p>Unfortunately, however, it seems impossible to endow an arbitrary lccc with a pullback operation which would satisfy these coherence requirements. In this paper we propose another solution under which a type is not merely interpreted as a morphism, but as a whole family of morphisms indexed over possible substitutions. More abstractly, we describe a construction which turns an arbitrary lccc into an equivalent category with attributes (cwa) --a "split" notion of model introduced by Cartmell <ref type="bibr" target="#b3">[4]</ref>, see also <ref type="bibr" target="#b11">[12]</ref>, for which an interpretation function is readily available. The method we use is a very general procedure due to B@nabou (see <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b6">[7,</ref><ref type="bibr">Prop. 1.3.6]</ref>) which turns an arbitrary fibration into an equivalent split fibration. Our contribution consists of the observation that the cwa obtained thus has not merely a split substitution operation, but is closed under all type formers the original lccc supported. In particular the resulting cwa has//-types, Z-types, and (extensional) identity types. Phoa <ref type="bibr">[11, p. 14]</ref> has considered this as an open problem. Locally cartesian closed categories play the role of a running example here; the arguments immediately carry over to the more general notions of model studied by Jacobs <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> and other authors.</p><p>On a more elementary level the method computes additional information along with the inductive definition of the interpretation which allows to identify the interpretation of a substituted type r[x := M] as a pullback of the interpretation of r albeit not the previously chosen one.</p><p>In the next section we define categories with attributes and sketch the standard interpretation function. Section 3 contains the main result --the construction of a cwa out of an lccc. In Section 5 we give a extension to universes which, however, does not handle the most general case. For many lcccs arising in the semantics of type theory in particular sets and w-sets and all toposes there is already known a natural equivalent cwa. For the case of toposes see <ref type="bibr" target="#b6">[7,</ref><ref type="bibr">Ex. 4.3.5]</ref>. In Section 6 we give an example where this is not the case and thus provide an application of the main result. Section 7 offers some concluding remarks and sketches an alternative construction of equivalent split fibration due to Power which does not extend to H-and Z-types. Some familiarity with basic category theory and dependent type theory will be assumed. Introductory material may be found in <ref type="bibr" target="#b0">[1]</ref> (categories) and <ref type="bibr" target="#b9">[10]</ref> (dependent type theory). Both subjects are also well described in <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Categories with attributes</head><p>A category with attributes (cwa) is given by the following data -a category C with terminal object i. The unique morphism from object /~ into 1 is written !r. @, -an operation p(-) which to each ~ E Fam(F) associates a C-morphism p(a) with codomain F --the canonical projection of a. The domain of p(c 0 is written F 9 a.</p><p>-An operation q(-,-) which to each C-morphism f : B --~ F and a C Fam(F) associates a morphism q(f, or):</p><formula xml:id="formula_0">B. cr[f] --~ F.c~ such that 2 B, q(y' q B ,F</formula><p>f is a pullback and the coherence conditions q(idr, o') = idr.a and q(f0 g, ~r) = q(f, ~r) o q(g, c~[f])</p><p>for g : A --+ B are satisfied.</p><p>Example 1. An important example of a cwa which also gives some intuition about the meaning of the various ingredients is the term model of some dependent type theory constructed as follows. Provided that suitable interpretations of base types and type constructors are given, a partial interpretation function can be defined by structural induction in such a way that every context is interpreted as a C-object, every type is interpreted as an element of Faro at the interpretation of its context and finally terms are interpreted as sections (right inverses) of the canonical projections associated to their types. If M is a right inverse of p(~) then by a slight abuse of language we say that M is a section of cr. The pullback requirement for q(f, or) allows to define a semantic equivalent to substitution on terms: If M is a section of c~ C Fam(F) and f : B ~ F then there is a unique section of a</p><formula xml:id="formula_1">[f] written M[f] which satisfies q(/, ~r) o M[f] = M o f .</formula><p>This interpretation is sound in the sense that the interpretation of all derivable judgements is defined and that all equality judgements are validated w.r.t. the actual equality in the model. An auxiliary property of the interpretation is that syntactic substitution is interpreted as its semantic counterpart -Ill.</p><p>What it means that a cwa is closed under a type former can be almost directly read off from the syntactic rules. For example closure under Z-types means that -for every two families o" C Fam(_P) and T C Fam(F. <ref type="bibr" target="#b6">(7)</ref> there is a family , T[q(f, ~r)]) and similar coherence laws for pairing and the projections. See <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b11">12]</ref> for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T) e Faro(r)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">From lcccs to categories with attributes</head><p>Our aim in this section is to construct a category with attributes supporting Hand Z-types, and extensional identity types from a given locally cartesian closed category.</p><p>Preliminaries. Let C be a category with finite limits (terminal object and pullbacks) and F E Oh(C). The slice category C/F has as objects C-morphisms with codomain F and a C/F-morphism from s : dora(s) ~ F to t : Categories with finite limits loosely correspond to dependent type theories if one views morphisms as families of types the morphisms denoting the projection from the disjoint union of all fibres to the indexing type. For example in the lccc of sets the type of m, n-matrices indexed over the set N • N would be modelled as the function format : Mat ~ N • N which maps an arbitray matrix to its "format" a pair of natural numbers indicating the numbers of rows and columns.</p><formula xml:id="formula_2">dora(t) --* 1" is a C-morphism a : dom(s) --~ dora(t)</formula><p>Substitution then corresponds (up to isomorphism) to pullback and composition to disjoint union. For example we obtain the set of square matrices indexed over N as the pullback of format along the diagonal function N ~ N x N and similarly the set of matrices with variable number of columns indexed over the number of rows as the composition of format with the first projection N x N---~ N.</p><p>Using equalisers one can also model extensional identity types. In order to have dependent product types one also needs right adjoints to pullback functors which leads to the following definition. Definition 1. A locally cartesian closed category (lccc) is a category with finite limits and right adjoints H I to every pullback functor f* :</p><formula xml:id="formula_3">C/I" ~ C/B for f:B---*F.</formula><p>Examples of lcccs are the categories of sets and w-sets, all toposes, and the term model of extensional Martin-LSf type theory as constructed in <ref type="bibr" target="#b13">[14]</ref>. For the rest of this section assume a fixed lccc C. In order to derive an interpretation of dependent type theory in C we construct a cwa with base category C as follows. where the lower right trapezium and the outer square are pullbacks. It follows from a simple diagram chase that the resulting lower left trapezium is also a pullback as required. Since 8(s, a) is defined by a universal property it must be functorial.</p><p>We continue with the definition of the cwa of functorial families. If a E Faro(F) then the canonical projection p(v-) is defined as v-(idr). Thus F-v-= dom(v-(~dr)). is defined by composition the functor laws for Fam are immediate. Finally, the morphism q(f, cr) is given by c~(idr, f) which indeed yields the required pullback square. The coherence law for q(-, -) follows from the functoriality of ~. Notice that by the definition of canonical projection a section of some family cr is merely a right inverse to ~(id). Thus terms do not carry any intensional information with respect to substitution. See also Section 5.</p><p>We have now constructed a cwa over C which can be shown to be equivalent to C in some suitable 2-categorical sense. We shall content ourselves by noticing that the hat-construction and canonical projection (p) establish an equivalence between the category Fam(F) where a morphism from a to r is a map f with p(r) o f = p(~r), and the slice category C/F for every F E Oh(C).</p><p>Theorem2. The category with attributes constructed above admits Z-types, Htypes, and extensional identity types.</p><p>Pro@ We give the full proof for E-types which conveys the idea and sketch the interpretation of//-types and identity types. Let o-E Fam(F) and r E Fam(F. c O. The family Z(c~, r) is defined by Z(~r, r)(s) := a(s) o r(q(s, a)) and ~(~, r)(s, ~) := r(q(s, c0, c~(s, ~)). Thus to obtain the value of Z(a, r) at some substitution s : B ~ F we first perform the substitution inside ~r yielding ~(s) and r yielding 7-(q(s, cr)) and then calculate the sum of the resulting morphisms in C as usual by composition.</p><p>dom(Z(o', v)(sa)) r(q(s, (r), (r(s, a)! dom(~(fr, 7-)(s))</p><formula xml:id="formula_4">(8)1 B / T(q(s, cr))] ~r(s, c~) , q(s, c~! F.cr f/1 ,B ,F o~ 8</formula><p>The fact that E(cr, r)(s, a) = r(q(s, o'), c~(s, a)) forms a pullback with a and the vertical arrows follows because the vertical composition of two pullback squares is a pullback. Functoriality follows from functoriality of ~r and r and the coherence laws for q(.,-). Next, we check that the thus defined Z-type is indeed stable under substitution. If f: B --* F and s: A --+ B then Z(~r, r) It remains to show that these operations are stable under substitution. We do the calculation for pairing, the two other cases may be verified similarly or can be deduced from the case of pairing and the fland rl-equations. Let M and N be as above in the definition of pairing and f : B -+ s Our aim is to show that</p><formula xml:id="formula_5">[f](s) = ~(rr, r)(fs) = cr(fs) o 7-(q(fs, (r)) = o-[f](s) o r(q(f, c~)o q(s, ~r[f])) = o-[f](s) o r[q(f, a)](q(s, o-[f])) = S(o'[f], r[q(f,</formula><formula xml:id="formula_6">(M, N)[f] = (M[f], N[f])</formula><p>The participating sections are defined uniquely by the equations</p><formula xml:id="formula_7">q(f, Z(cr, 7-)) o(M, N)[f] = (M, N) o f q(f,~r) 0 M[f] = M of q(/, 7-[M]) o N[I] = No f Now in view of the unique charaeterisation of (M, N)[f] stability follows if we can show q(f, Z(cr, r)) 0(M[f], N[f]) --(M, N) o f</formula><p>Here the left hand side equals q(q(f, ~r), 7-</p><formula xml:id="formula_8">)o q(M[f], 7[q(f, c0])0 N[f]</formula><p>by expanding the definitions of ~ and pairing. This in turn equals q(q(f, or) 0</p><formula xml:id="formula_9">M[f], 7-)0 N[f]</formula><p>using the coherence law for q(-,-). Now using the defining equation for M <ref type="bibr">[f]</ref> and applying the coherence law in the other direction we arrive at q(M, 7-)0 q(f, 7</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>-[M]) o Nil]</head><p>Using the defining equation for N[f] and the definition of (M, N) we arrive at the right hand side.</p><p>The type constructors H and identity type are defined in a similar fashion. For families ~, 7-as above the value of the family H(c~, 7-) at substitution s : B /~ is//o(~)(7-(q(s, g))). We leave the messy, but essentially forced definitions of the morphism part and the associated combinators to the reader.</p><p>For ~r E Faro(F) and M,N sections of p(cr) we define the identity type Eqr N) at s as the (chosen) equaliser of M[s] and N[s] where M[s] is the unique section of ~(s) for which q(8, g) o M[s] = M o s. Compatibility of substitution of the associated combinators requires again some lengthy calculation which in the case of H basically amount to reproving the Beck-Chevalley condition for lcccs <ref type="bibr" target="#b13">[14]</ref>.</p><p>It is worth pointing out that a certain choice of pullbacks and equalisers albeit not a split one is required to interpret identity types which are the basic source of type dependency.</p><p>In a similar way we can show that the cwa of families supports lists or natural numbers if the category C supports them in a coherent way. Instead of carrying out these (rather laborious) examples we attempt to clarify the ideas a bit further by elaborating the conditions on C which are necessary in order that in the associated category with attributes we can interpret an (admittedly contrived) type former governed by the rules</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F F o" type r ~-T(r type</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T-FORM</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F}-M:a F F T-intro(M): T(~r)</head><p>T-INTRO and the associated congruence rules. This can in general be interpreted if there is an operation T which to every morphism ~r with codomain P associates a morphism T(c 0 also with codomain P and to every pullback square another pullback square f' T&lt;r) </p><formula xml:id="formula_10">p(~r[f]) = cr(f)l B q(f, cr)= cr(idv, f! V.a = dom(o'(idv)) / ,r' f</formula><p>This example shows that the described method carries over to other type constructors like e.g. lists or natural numbers provided they are present in C in a coherent way. We also see that a type former need not necessarily be given by a universal construction as is the case for H-and Z-types. The lesson to be learned is that whenever a type former admits a functorial action on pullback squares which is compatible with the associated structure then it may be lifted to the cwa of families.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The interpretation in the family model</head><p>The general interpretation function for categories with attributes now gives rise to a semantic function mapping contexts to objects in C, types to families over their context, etc. Now if F k-~ type then IF k-o'~(id[rl) is an object in the slice category C/[F] which we may view as the intended interpretation of in C. This intended semantics is not "compositional" since for example in the interpretation of pairing we use substitutions other than the identity. A reader familiar with theory of functional programming may notice here some similarity with the continuation-passing-style translation where semantics is inductively defined with respect to an arbitrary continuation, but in the end one is only interested in the instance of the identity continuation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Universes</head><p>In the construction described above types get interpreted as functions associating substitutions to morphisms. Terms, however, get interpreted simply as sections and do not carry any intensional information about their behaviour under substitution, it being forced upon by the universal property of the pullbacks associated with families. This implies that our construction does not carry over to universes (which mix terms and types) unless the universe was "split" in the first place. What this means is exemplified by the following definition specialising the notion of model for the Calculus of Constructions given in <ref type="bibr" target="#b5">[6]</ref>. In <ref type="bibr" target="#b5">[6]</ref> the last requirement is weakened to isomorphism in C/F of the morphisms associated by -*gen. The stricter condition imposed here means that the V operator is stable under substitution up to equality. The two most prominent examples of dictoses, namely the category of sets with /2 = {0, 1} and the category of w-sets with f2 equal the set of partial equivalence relations on w are split dictoses. In split dictoses we can interpret the Calculus of Constructions Theorem4.</p><p>To every split dictos there exists an equivalent cwa with enough structure to interpret the Calculus of Constructions.</p><p>Proof. Let us first define what it means for a cwa with H-types to be a model of the Calculus of Constructions. Following <ref type="bibr" target="#b14">[15]</ref> we need a family Prop over 1 and a family Prf over 1 9 Prop in such a way that two morphisms s, s ~ : F --* 1 9 Prop are equal if Prf[s] = Prf[s']. Moreover, if cr is a family over F and p : F 9 c~ ~ 1 9 Prop then there is a morphism VG(p) : F ~ 1 9 Prop such that Prf[Vo(s)] = H(cr, Prf[s]). One could stay even closer to the syntax but only at the expense of clarity. Now let a split dictos C be given. We construct a cwa with base C as follows. The set of families over F is defined as the disjoint union of the set of functorial families as defined in Section 3 and the homset C(F, D). We call the elements of C(F, ~2) propositional families (over F). The operations of substitution and canonical projection are extended to propositional families by defining for (r : /~--+/2andf:B~F: For the definition of the H-type H(a, r) we first replace ~r by 5" if cr is propositional. So let's assume that z is functorial. Then we proceed by case distinction on whether r is functorial or propositional. In the former case we use the Htype for functorial families as defined in Section 3. If r is propositional, i.e.</p><p>7" : F. ~r ---+ 1. Prop then we define H(0-, v) as the propositional family Vp(o)(7").</p><p>Abstraction and application are defined by suitably interspersing the isomorphism between Vs(p)*gen and Hs(p*gen) assumed in the definition of a split dictos.</p><p>By lengthy but straightforward calculation it follows that this satisfies all the properties of dependent products. In particular to see that//is stable under substitution we instantiate the coherence property for V with the pullback square formed out of p(~[f]), p(o'), q(f, cr), and f for some f: B --+ F.</p><p>The Y-operator is defined in exactly the same way using the fact that propositional families and morphisms into 1. Prop coincide.</p><p>As in Ex. 2 the hat-construction and canonical projection define an equivalence between C and the constructed cwa.</p><p>It deserves attention that the coherence requirement imposed on the Y-operation was crucial for the definition of H-types by case distinction and that the methods described in this paper do not seem to generalize to arbitrary dictoses or more generally lcccs which support universes in a non split way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6</head><p>Application: A category of setoids</p><p>As mentioned in the Introduction for many lcccs an equivalent cwa is known already. However, there is an interesting example motivated by a construction in <ref type="bibr" target="#b2">[3]</ref> for which the construction described in this paper seems to be the only viable way. Consider the syntax of intensional Martin-LSf type theory with natural numbers as described e.g. in <ref type="bibr" target="#b9">[10]</ref>. We write F t-cr true to mean that there exists a term F ~-M : ~r. We write x and + for the nondependent special cases of and H, resp. A category C of "setoids" (Types with equivalence relations) is formed as follows.</p><p>An object of C is a quintuple X = (Xs~t, Xrel, r, s, t) such that the following hold. i) X~t is a closed type. ii) x, x': X~t ~-Xr~t(x, x') type. iii) x: X,~t ~r(x): Xr~l(x, x). iv) x, x': X,~t, p: Xr~,(x, x') ~ s(p): X~,(x', x). v) x, x', x": Xs~t, p: X,.~t(x, x'), q: X~,,(x', x") ~-t(p, q): X~ez(x, x"). So r,s,t are "proofs" that X~ is an equivalence relation on X,~t. If no confusion can arise the subscripts sa and ~el may be omitted.</p><p>-A morphism from X to Y is a term x: X~,t t-f(x) : Y~t such that x, x' : Xset , -: Xrel(X, x') I-Yrel(f(x), f(x') ) true Moreover, two morphisms f and f~ are identified if</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">: x~o~ ~ Y~.(f(=), f'(~))true</head><p>It is easy to check that equality on morphisms is an equivalence relation and that morphisms are closed under composition and contain the identity so that indeed a category has been defined. Essentially, this construction is the same as the one described in <ref type="bibr" target="#b2">[3]</ref> although there the category is defined categorically rather than syntactically and one starts out with an lccc in the first place. By mimicking the argument given there we obtain the following proposition.</p><p>Propositlonh. The category C of setoids is locally cartesian closed and contains a natural numbers object.</p><p>Proof. We only give the required objects leaving the verifications to the reader.</p><p>Let f : Y -~ X and g : Z --* X. The pullback of f and g is defined as the object W given by W,~t = Zy: Y.Zz: Z.X(f(y), g(z)) and Wrel((y, Z, --), (y', Z', --)) = Y(y, y') X Z(z, z'). The two pullback projections send (y, z,-) to y and z re- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>W~.((~, u,-), (x', ~', -)) := X(x,x') X IIy:Y.IIp:X(f(y),x).IIp':X(f(y),x').Z(u y p, u' y p')</head><p>where</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Resp(u) := r[v,v':y.~p:x(f(v),~).Hp':x(f(v'),~).y(v,~') ~ z(~ y p,~ ~' p')</head><p>The morphism II](g) itself is then the first projection from W to X. Finally the natural numbers object has as underlying type the type of natural numbers and the intensional identity type [dy as relation.</p><p>Unfortunately, this proof only shows the existence of pullbacks and// and no canonical choice arises from it because the constructions given in the proof are not independent of the particular representatives chosen for the involved morphisms. Therefore, in order to endow the category of setoids with chosen structure the use of the axiom of choice seems unavoidable. However, given such a choice we can use the method described in this paper to obtain an interpretation of extensional type theory in the category of setoids and thus in a certain sense in intensional type theory. The category of setoids is a worthwhile object for further study. In particular it appears to have coequalisers of equivalence relations and thus provides a model for the extensional quotient types studied by Mendler in <ref type="bibr" target="#b8">[9]</ref>. Moreover, we believe that the full subcategory of the category of setoids consisting of those objects taken on by the interpretation function is actually equivalent to the lccc of types and terms in extensional type theory defined in <ref type="bibr" target="#b13">[14]</ref> and presented there as the initial one. Incidentally, the precise proof of initiality (up to natural isomorphism) of this syntactic lccc is another field of application for our methods. We have described a method for obtaining an equivalent category with attributes from a locally cartesian closed category. This solves the problem of interpreting (at least first order) dependent type theory in lcccs. The method consists of applying B4nabou's construction of a split fibration from an arbitrary one to the particular case of the codomain fibration associated to an lccc. The observation that the thus obtained cwa is closed under various type operators is to our knowledge original. Incidentally, for another somewhat dual construction of split fibrations due to Power <ref type="bibr" target="#b12">[13]</ref> this is not the case. Using it Faro(F) would be the set of pairs (s, cr) where s and cr are morphisms with common codomain and dora(s) = F.</p><p>The associated canonical projection to such a family is the morphism s*cr with codomain F. If f : B ~ F then we define (s,~r)[f] as (s0.f, cr). This gives rise to a cwa which, however, is not even closed under X-types in a natural way. Intuitively, the reason is that (s, cQ can be viewed as a type ~ together with a delayed substitution which is meant to be carried out upon taking the canonical projection. But if two types have different associated substitutions we cannot compute their sum or product without performing the substitutions which destroys the split property.</p><p>Power's very elegant result applies to much more general coherence problems than the one considered here; in fact it requires some effort to extract the above concrete description from the general construction. The aim of the previous paragraph is by no means to critieise his beautiful work, but to pinpoint the particular properties of B4nabou's construction which make our result go through.</p><p>In view of the lack of generality with respect to universes pointed out in Section 5 one might want to endow the meaning of terms with behaviour under substitution, too. Then, however, the framework of cwas is no longer sufficient and more generally no model in which substitution on terms is modelled by a universal property could work. We do not know of any notion of model where this is not the case, so maybe some further research into the abstract semantics of dependent types is called for.</p><p>In conclusion we may remark that a certain gap in the literature has been filled, but that the practical usefulness of the result remains unclear until more examples like the one from Section 6 are found and investigated. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>For example the natural choice ~ of pullbacks in the category of sets does not work. Indeed, if f : A --* B, g : B ~ C, and h : D ~ C are set-theoretic functions then (According to the canonical choice) the pullback of h along g o f is the set {(a, d) l a e A A d E D A g(f(a)) = h(d)} whereas the iterated pullback of h first along g then along f gives the set {(a,(b,d))la C A A b e B A d E D A f ( a) = b A g(b) = h(d)} which is equipollent, but not equa~to the former. It seems to be open whether there exists another choice of pullb~cks in the category of sets which commute with composition (and the type formers).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>-a. functor Fam: C ~ -"+ Sets with morphism part written Fam(f)(o') ~-abbr ~[f]. More elementarily, this means that Fam(F) is a set for each F E Ob(C) and if d E Faro(F) and f : B --+ F then ~[f] e Fam(F) and the two coherence conditions tr[idr] = cr and cr[fo g] : cr[f][g] for g : A --+ B are satisfied.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>-</head><label></label><figDesc>for every two sections M of a and N of T[M] there is a section (M, N) of Z(a, v) --the pairing of M and N for every section M of ~(c~, T) there is a section M.1 of o-and a section M.2 of r[M.1] --the two projections of M such that (M, N).I -M and (M, N).2 = N and (optionally) (M.1, M.2) = M and for y: B ~ F we have Z(cr, r)[f] = Z(cr[f]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>with t o a = s. Notice the important triviality that any C-morphism a with codomain dora(t) is a C/F-morphism with codomain t (and domain t 0 a.) For each C-morphism f : B ~ F there is a functor f* : C/F ~ C/B sending s : dom(s) --~ F to the left vertical arrow of the pullback of s along f. The action of f* on morphisms is defined by the universal property of the pullback. The functor f* has a right adjoint Z] which sends s : dom(s) ---* B to the composition f0 s. The arrow category C -~ has as objects all morphisms of C and commuting squares as morphisms. Equivalently, a C--*-morphism from s : dora(s) ---+ B to t : dora(s) --~ F is a C-morphism f : B ~ F and a C/B-morphism a : s --~ f*t. Taking the domain of a morphism extends to a functor dom : C ~ --* C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>For F E Oh(C) the set Faro(F) is defined as the set of those functors a from the slice category C/F to the arrow category C ~ which map every morphism to a pullback square and for which cod o ~ = dom. More precisely c~ E Fam(F) associates to every morphism s : B --+ F a C-morphism a(s) with codomain B and to a : B' --+ B a morphism v-(s, a) such that do&lt;v-. Moreover, the assignment of the morphism ~r(s, a) is functorial in the sense that v-(s, idB) = iddo,~(~(,)) and v-(s, so/~) = o'(s, a) 0 a(so a,/3) for /3 : B" --+ B'. An element of the thus defined set Fam(F) is called a functorial family over F.Example 2. The intuition behind these families is that instead of making substitution (viz. pullback) an arbitrarily chosen structure, every family comes equipped with its own behaviour under substitution. Thus in v-(s) one should view s as a requested substitution and v'(s) itself as the result of performing this substitution. Indeed, given a (not necessarily split) choice of pullbacks in C we can see that every C-morphism v-with codomain/" induces a family &amp; over F. For s : B -+ F we put &amp;(s) := s*r where s* is the pullback functor defined above. If in addition a : B' --+ B we define 8(s,~) as the unique mediating morphism</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>If in addition f: B --+ F we define the substitution v-[f] by v-[f](s) := v-(fo s) for s: A -+ B and by ~r[f](s, a) := er(fQ s, a) for ~: A' ~ A. Since this substitution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>~r)])(s) as required. For the morphism part we calculate similarly. The pairing and projection combinators are defined as usual in an lccc: If M is a section of a, i.e. a right inverse of cr(idv) and N is a section of r[M], i.e. a right inverse to r[M](idv) = r(M) then we define the pairing (M, N) as q(M, r)o N which is a section of Z(g, r) by simple equality reasoning. On the other hand, if M is a section of Z(cr, r) then M.1 := p(r) o M is a section of M and M.2 is the unique section of r[M.1] with q(M.1, r)oM.2 = M determined by the universal property of the pullback. Now we have (M.1, M.2) = M by definition, (M, N).I = M by equational reasoning, and (M, N).2 = N by uniqueness of the second projection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>sense that T(id) : id and T(f'o g') : T(f')o T(g'). This action on pullback squares is another way of stating that T is compatible with the chosen pullback up to isomorphism and admits a functorial action on isomorphisms, but of course not necessarily on arbitrary morphisms. Moreover, for each section M of r we need a section T-intro(M) of T(rr)in such a way that in the above pullback situation we haveT(f') o T-intro(M') : T-intro(M) o fwhere M' is the unique section of ~r' with f' o M' : M o f. This is the coherence condition one would reasonably expect. Now we can define a T-operator on families by putting T(rr)(s) :: T(rr(s)) and T(rr)(s, c 0 :: T(rr(s, r~)) for (r 6 Fam(F) and s : B --+ F and c~ : B' --~ B. Functoriality follows from functoriality of rr and T(-). The operation T-fntro is defined as in C. Stability of same under substitution follows directly from the above coherence condition by instantiating with the pullback square B. f[o-] = dom(cr(f))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Definition3. A split dictos is an lccc C with a morphism gen : T --+ ~2 and an operation which to every two morphisms s : S ---+ F and p : S -+ t'2 associates a morphism Vs(p) : F --*/2 such that Vs(p)*gen and Hs(p*gen) are isomorphic in C/F and for every pullback square f : T --+ ~2 we have Vt(p) 0 f = Vs(p0 f').</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>cr) defined by universal property like in Ex. 2 It follows by straightforward calculation that this is a cwa. Every propositional family cr : /1 ~ /2 induces a functorial family 5 defined by applying the hatconstruction from Ex. 2 to ~r* gen. We may then extend Z-types and other possible type formers except H-types to propositional families by precomposition with'. We have a functorial family Prop over 1 defined by Prop = !a. W.l.o.g. we may identify 1 9 Prop with X?. A propositional family Prf over 1 9 Prop is then defined as the identity on ~2. Notice that if s : F ~ 1 9 Prop then Prf[s] equals s. Therefore Prf[-]  is injective as required.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>spectively. Now let f : Y --~ X and g : Z --* Y. We define [If (g) : W --~ X by w~e, := ~: X.~u: nv: z.x(f(v), ~) -~ ~z: z.Y (g(z), v).nesp(u)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>7 S u m m a r y a n d C o n c l u d i n g R e m a r k s</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>A c k n o w l e d g e m e n tMy thanks go to Thomas Streicher for explaining B6nabou's construction to me.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>This and the following diagrams have been typeset using Paul Taylor's diagram macros.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* The author is supported by a European Union HCM fellowship; contract number ERBCHBICT930420</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Category Theoryfor Computing Science. International Series in Computer Science</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Wells</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">B6nabou. Fibred categories and the foundations of naive category theory</title>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Symbolic Logic</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="10" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Some free constructions in realizability and proof theory</title>
		<author>
			<persName><forename type="first">A</forename><surname>Carboni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Pure and Applied Algebra</title>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Generalized algebraic theories and contextual categories</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cartmell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
		<respStmt>
			<orgName>Univ. Oxford</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Substitution up to isomorphism</title>
		<author>
			<persName><forename type="first">Pierre-Louis</forename><surname>Curien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="51" to="86" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ehrhard</surname></persName>
		</author>
		<author>
			<persName><surname>Dictoses</surname></persName>
		</author>
		<title level="m">Proc. Conf. Category Theory and Computer Science</title>
		<meeting>Conf. Category Theory and Computer Science<address><addrLine>Manchester, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer LNCS</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">389</biblScope>
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<title level="m">Categorical Type Theory</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>University of Nijmegen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Comprehension categories and the semantics of type theory</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="page" from="169" to="207" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Quotient types via coequalisers in Martin-L6f&apos;s type theory</title>
		<author>
			<persName><forename type="first">P</forename><surname>Nax</surname></persName>
		</author>
		<author>
			<persName><surname>Mendler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the informal proceedings of the workshop on Logical Frameworks</title>
		<meeting><address><addrLine>Antibes</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-05">May 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Programming in Martin-Lb&apos;f&apos;s Type Theory, An Introduction</title>
		<author>
			<persName><forename type="first">B</forename><surname>Nordstr6m</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Petersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Clarendon Press</publisher>
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">An introduction to fibrations, topos theory, the effective topos, and modest sets</title>
		<author>
			<persName><forename type="first">Wesley</forename><surname>Phoa</surname></persName>
		</author>
		<idno>ECS-LFCS-92-208</idno>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>LFCS Edinburgh</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Categorical logic</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Logic in Computer Science</title>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date>199</date>
			<biblScope unit="volume">VI</biblScope>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A general coherence result</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Pure and Applied Algebra</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="165" to="173" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Locally cartesian closed categories and type theory</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName><surname>Seely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Proceedings of the Cambridge Philosophical Society</title>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="33" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Semantics of Type Theory</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Streicher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Birkhs</title>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
