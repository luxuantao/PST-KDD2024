<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Finding Nearest Neighbors in Growth-restricted Metrics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
							<email>karger@theory.lcs.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department">MIT Laboratory for Computer Science Cambridge</orgName>
								<address>
									<postCode>02139</postCode>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Matthias</forename><surname>Ruhl</surname></persName>
							<email>ruhl@theory.lcs.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department">MIT Laboratory for Computer Science Cambridge</orgName>
								<address>
									<postCode>02139</postCode>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Finding Nearest Neighbors in Growth-restricted Metrics</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6AB4EEA61BC1FC09E8BCF5DE3DDB9FA7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:13+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Most research on nearest neighbor algorithms in the literature has been focused on the Euclidean case. In many practical search problems however, the underlying metric is non-Euclidean. Nearest neighbor algorithms for general metric spaces are quite weak, which motivates a search for other classes of metric spaces that can be tractably searched.</p><p>In this paper, we develop an efficient dynamic data structure for nearest neighbor queries in growth-constrained metrics. These metrics satisfy the property that for any point q and distance d the number of points within distance 2d of q is at most a constant factor larger than the number of points within distance d. Spaces of this kind may occur in networking applications, such as the Internet or Peer-to-peer networks, and vector quantization applications, where feature vectors fall into low-dimensional manifolds within high-dimensional vector spaces.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Finding the nearest neighbor of a point in a given metric is a classic algorithmic problem with many practical applications. Some such applications are database queries, in particular for complex data such as multimedia data or biological structures, e.g. on protein structures or genome data. Other uses are in lossy data compression, where data can be encoded by the closest representative from a fixed set of representatives. The common characteristic of these examples is that comparing two elements is costly, so one would like to develop data structures that allow for nearest neighbor searching with a small number of comparisons.</p><p>In the formal setting, one is given a metric space M ´M dµ (where d is symmetric and satisfies the triangle-inequality), and a subset S M of n points in the space. Allowing for some preprocessing one wants to efficiently answer queries of two kinds:</p><p>(i) Nearest Neighbor: Given a point q ¾ M, return the point in S that is closest to q among all points in S.</p><p>(ii) Range Query: Given a point q ¾ M and r 0, return all points p ¾ S that satisfy d´p qµ r.</p><p>It is also desirable that the data structure support efficient insertion and deletion of points from S. These problems are quite hard for general metrics, evidenced by the fact that known data structures perform poorly (requiring time Ω´n 1 δ µ) for range queries with non-trivial r, or for nearest neighbor searches where the query point is relatively far from its nearest neighbor (see "related work" below). This seemingly is because general metrics do not provide enough structure to solve these problems efficiently.</p><p>In the instances where search problems arise in practice, however, the underlying metric usually is far from general, but satisfies additional constraints. Developing efficient search data structures for these metric spaces is an important problem.</p><p>Previous research on this problem has focused on the Euclidean case, i.e. M ´Êd L p µ, which is particularly important since many practical applications deal with "feature vectors" that are naturally embedded in Euclidean space. A large number of data structures have been developed that perform very well (with logarithmic time per operation) in low dimensional Euclidean spaces. There is, however, a significant number of problems where the data cannot easily be embedded into low-dimensional Euclidean space, or such an embedding results in the loss of information.</p><p>In this paper, we are concerned with sample sets S that have a certain smooth-growth property. Throughout this paper, we let B p ´rµ : s ¾ S d´p sµ r be the ball of radius r around p in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Expansion Rate)</head><p>We say that S has ´ρ cµ-expansion iff for all p ¾ M and r 0, B p ´rµ ρ µ B p ´2rµ c ¡ B p ´rµ</p><p>In the bulk of this paper, we will set ρ O´log S µ and refer to c as the expansion rate of S. £</p><p>Intuitively, for any space satisfying this property, points from S "come into view" at a constant rate when we expand a ball around any point p ¾ M.</p><p>The factor 2 in the expansion definition can be replaced by any other constant with a corresponding change in c. For intuition, consider the set of points in a uniform d-dimensional grid under the L 1 metric. Balls in this metric are d-dimensional hypercubes. Multiplying the ball radius by 2 corresponds to increasing each side length by this amount, which increases the volume of the cube, and thus the number of points in it, by 2 d . Thus, the L 1 metric on the grid has ´1 2 d µ-expansion.</p><p>Based on this grid intuition, we can consider the expansion rate to be a kind of "dimensionality" measurement for our metric space. Expansion rate is incomparable to standard dimension, however: a balanced binary tree, which can be embedded in 2 dimensions, has a huge expansion rate. A low dimensional manifold in a high dimensional space can have a very low expansion rate (as in the applications discussed below). Under standard dimensionality, a subset of points has no higher dimension than its containing set; this powerful fact is not true for the expansion rate. However, we will see below that a weaker and still useful result does hold: a random subset of points from a low-expansion metric space has low expansion. Thus, for example, a collection of points randomly distributed in a d-dimensional Euclidean cube has expansion rate O´dµ.</p><p>The expansion property, applied recursively, shows that the number of points in a ball of radius r is at most polynomial in r. The converse is not true, however: the expansion property requires this growth to be reasonably smooth -it rules out the possibility (consistent with the polynomial bound) that as the ball grows, we encounter a few points, then a long period with no points, then suddenly a tremendous number of points.</p><p>Our result. Our main result is a randomized data structure, the metric skip list, that allow for nearest neighbor queries in spaces with constant expansion rates (c O´1µ). The data structure can answer nearest neighbor queries in O´log nµ time, and range queries in time O´log n • kµ (where k is the number of returned elements) with high probability. The data structure can be constructed in O´n log nµ time, uses O´n log nµ space and allows for the addition and deletion of points in expected O´log n log log nµ time. The assumption that c is constant simplifies notation; more generally, the running time is logarithmic in n, but polynomial in the expansion rate c. <ref type="foot" target="#foot_0">1</ref> The data structure is Las Vegas, i.e. always returns the correct result regardless of our random choice. The structure works even if the metric space does not have a bounded expansion rate, although its running time bounds degrade.</p><p>Our data structure is quite simple, deducing from the low expansion property that a random sample of a few points in a given ball around the query point is likely to yield a point inside a much closer ball.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applications.</head><p>Clearly, the main motivation for looking at spaces with low expansion rates is because they actually appear in real problems. We are aware of at least two applications where this is the case.</p><p>In Internet applications, it is often important for nodes to find other nodes that are "near" each other with respect to distance as measured by latency or bandwidth. This paper was motivated by work on the Chord system <ref type="bibr">[7]</ref> which provides routing infrastructure for various peer-to-peer applications. In many such applications, it is useful for clients of the system to find a nearest Chord node that can proxy for them in the application. In data caching applications, it is useful to solve the more general problem of finding a nearby node that actually has a copy of the desired data. Plaxton et al. <ref type="bibr" target="#b6">[6]</ref> tackled this problem. They describe a distributed system that stores replicated copies of a data item, and a protocol that lets any node retrieve a "nearby" copy of the data item -more precisely, their randomized scheme finds a copy whose expected distance is close to that of the nearest copy. Their scheme makes the same "constant expansion" assumption as we make here. In fact, they require more: that ratio of points in the larger ball to that in the smaller ball must be upper and lower bounded by constants exceeding one. We require only the upper bound. In an additional improvement, when data is replicated by the Chord protocol, our scheme can be used to find the closest (rather than just close in expectation) copy of a data item.</p><p>A second application comes from machine learning. A current thread of machine learning research <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b8">8]</ref> postulates that the feature vectors representing points being analyzed form a low-dimensional manifold of a high dimensional space. There is no a-priori specification of the manifold; rather, a large set of example points is provided. The distance metric on these points is given in the high dimensional space. Identifying near neighbors among the example points is useful -for example, to implement the standard k-nearest neighbors algorithm for classification, or to identify neighborhoods in the manifold in order to construct local parameterizations of the manifold. Under assumptions of limited curvature (which are also made in the AI literature) and random selection of example points from the manifold, the low-expansion property will hold (as it does for low dimensional Euclidean spaces) and our near-neighbor structure could be applied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work.</head><p>As mentioned previously, most research on nearest neighbor search has focused on the case of vector spaces and/or Euclidean metrics <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b2">2]</ref>. There has been a growing interest in general metrics, however. In a recent survey <ref type="bibr" target="#b4">[4]</ref>, <ref type="bibr">Chávez et al.</ref> give an overview on the data structures developed for these applications. The most frequent approach is by "pivoting" <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11]</ref>, i.e. the space is partitioned into two halves by picking a random pivot, and putting points into either half of the partition according to their distance to the pivot element. Variations use multiple pivoting elements per split <ref type="bibr" target="#b3">[3]</ref>. While these structures answer queries in O´log nµ time for a point that is actually in the set S, they cannot be used efficiently to find nearest neighbors, or perform range queries unless the radii involved are very small. This is because in general the search ranges can split at every pivoting step, requiring the exploration of a significant part of the search tree. (Comparable to the performance guarantee of nearest neighbor searches using quad-trees, which is O´Ônµ.) Also, dynamic maintenance of the trees, in particular deletion, is difficult.</p><p>Clarkson <ref type="bibr" target="#b5">[5]</ref> developed two data structures for non-Euclidean spaces. He assumes that the samples S and q are drawn from the same (unknown) probability distribution. While his data structures apply to the low-expansion spaces that we consider (as long as the non-trivial assumption of random inputs is satisfied), they have super-logarithmic query times, and do not allow for insertion or deletion of elements.</p><p>The already mentioned paper by Plaxton et al <ref type="bibr" target="#b6">[6]</ref> contains a data structure for low expansion spaces that allows for locating data objects in a shared network in that space. The data structure cannot be directly used for nearest neighbor search, as it returns only approximately closest data items. Moreover, the construction makes additional crucial assumptions on the space, such as B p ´2rµ 8 B p ´rµ for all p ¾ S and r 0, so does not necessarily work on all spaces with low expansion.</p><p>Outline. The paper is structured as follows. First, we will derive some additional properties of spaces with low expansion rates. We then describe and discuss our data structure for searching in low expansion metrics, describe an application to a peer-to-peer networking protocol, and conclude the paper with describing some directions for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">CONSEQUENCES OF LOW EXPANSION</head><p>Let us begin by introducing notation, and proving a few facts about spaces with low expansion that show why sampling is a good way to find nearest neighbors in these spaces.</p><p>We begin by proving the fact claimed in the introduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2</head><p>A random subset of m points from a metric space with ´ρ cµ-expansion will have ´max´cρ O´log mµµ 2cµ-expansion with high probability (in the size of the subset).</p><p>Proof: We prove ´max´cρ µµ 2cµ-expansion for some µ O´log mµ.</p><p>Let Z be the sample from the metric space S. Consider a particular ball B p ´rµ for some point p in the sample. Let us now condition on the number k of points in Z B p ´2rµ. If k cρ then the expansion property is vacuously satisfied. Similarly, if k µ we are done. So we can assume k cρ and k µ. This implies B p ´2rµ contains at least k cρ points in Z and thus in S. From the expansion property for S we know that B p ´2rµ has at most c times as many points as B p ´rµ in S. Conditioned on k, the set of points included in the sample is chosen at random from S B p ´2rµ; thus, each such point is in B p ´rµ with probability at least 1 c. Thus, the expected number of points k ¼ in Z B p ´rµ is at least k c. Since k µ, a standard Chernoff bound implies that k ¼ k 2c with probability 1 e Ω´µµ . By choosing µ O´log mµ (varying the constant according to the precise desired probability bound) we deduce that k ¼ k 2c with high probability in m.</p><p>Our analysis has shown that regardless of k, the ball obeys the expansion property with high probability in m. Thus, the same high probability result holds without conditioning. This outcome holds with high probability for any particular p ¾ Z and any particular r. It thus holds with high probability in m for any of the m 2 ¡ pairwise distances between points in Z. Since these particular distances are the only ones where ball-sizes change, the claim is proven. £</p><p>As can be seen in the proof, sampling creates a size log m neighborhood of a point within which expansion fails to be preserved; this motivated the parameter ρ that excepts small balls from the expansion-rate bound. Now we turn to developing our data structure. In the following, we will assume that the metric space M is normalized (by scaling) such that the maximum distance between any two points in S is 1.</p><p>As before, let n be the size of the subset S.</p><p>All the algorithms we describe below can be viewed as random walks on the set S. To find q, we start at an arbitrary point p ¾ S, and step through a sequence of points that quickly converges to q. In fact, in each step we expect to halve the number of points closer to q than our current position, resulting in a O´log nµ query time.</p><p>The steps in the random walk are performed by sampling points from S in a ball around our current point p. We will now show how this yields good performance. First, we state a simple claim about inclusions of balls around a pair of points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 (Sandwich Lemma)</head><p>If d´p qµ r, then B q ´rµ B p ´2rµ B q ´4rµ. Proof: For the first inclusion, if s ¾ B q ´rµ, then d´p sµ d´p qµ • d´q sµ r • r 2r. For the second inclusion, if s ¾ B p ´2rµ, then d´q sµ d´q pµ • d´p sµ r • 2r 4r. £ This simple observation leads us to the sampling lemma which is the basis for our algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4 (Sampling Lemma)</head><p>Let M be a metric space, and S M be a subset of size n with ´ρ cµ-expansion, where ρ Ω´log nµ. Then for all p q ¾ S and r d´p qµ with B q ´r 2µ ρ, the following is true.</p><p>When selecting 3c 3 points in B p ´2rµ uniformly at random, with probability at least 9 10, one of these points will lie in B q ´r 2µ.</p><p>Proof: This follows from the Sandwich Lemma. Let k : B q ´r 2µ be the number of "good" points. Since B q ´r 2µ B q ´rµ B p ´2rµ by the Sandwich Lemma, all good points are possible results in our sampling. Also due to the Sandwiching Lemma, we have B p ´2rµ B q ´4rµ c 3 B q ´r 2µ c 3 ¡k, the last inequality due to the limited expansion rate. Thus, the probability that one sample is good is at least k ´c3 kµ 1 c 3 . The probability that c 3 samples are all bad is at most</p><formula xml:id="formula_0">1 1 c 3 3c 3 1 e 3 0 05</formula><p>Thus, we succeed with probability more than 90 %. Because the sample space had at least logarithmic size, the effect of sampling without replacement vs. with replacement is negligible. £</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A simple local search algorithm</head><p>The Sampling Lemma immediately suggests a nearest neighbor search algorithm. let p be an arbitrary point in S while p is not the nearest neighbor of q in S let X random sample of 3c 3 elements of B p ´2d´p qµµ let p element of X p of minimal distance to q Let us briefly discuss this algorithm. For simplicity, we analyze this scheme in terms of the ratio R between maximum and minimum pairwise distances between points in the metric space, and assume that the set has ´1 cµ-expansion (as opposed to the ´O´log nµ cµ-expansion considered in the rest of the paper).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5</head><p>The local search algorithm completes with high probability in O´log Rµ time.</p><p>Proof: We start with a point at distance at most 1 from the query point (recall that we normalized our space this way). By the sampling lemma, each local search step (iteration of the while loop) will halve our distance to q with probability at least 9 10 (and will never increase it). It follows that the expected number of iterations to halve our distance to q is at most 10 9, and the expected number of iterations to produce log R halvings is ´10 9µ log R. But after log R halvings, we will have a point at distance at most 1 R from q. Since by definition of R there are no points at this small a distance, we must terminate sooner with the nearest neighbor of q.</p><p>A standard Chernoff bound on the expectation yields the high probability result. £</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Space-Inefficient Structure</head><p>The local search algorithm relies on a random-sampling primitive which we have yet to implement. We provide a data structure that supports the necessary sampling. We saw above that local search takes only O´log Rµ time with high probability. It follows trivially that with high probability, we will need to examine only O´log Rµ samples from a ball around any particular point p in our search. Our data structure simply chooses these O´log Rµ samples in advance for all n points in the metric space.</p><p>Of course, we do not have advance knowledge of the query points, so we cannot predict the distance between a point p and the query point. Without such knowledge, we do not know what radius of ball around p to sample from. We get around this problem by choosing from a set of balls with power-of-two radii. One such ball will have radius within twice the current distance to the query point, and we can use the in-advance samples from that ball.</p><p>More precisely, for each integer k, each point p chooses a set of 3c 3 log R level k finger points uniformly at random from the set B p ´2 k µ of points within distance 2 k of p. Denote this set of fingers as F k ´pµ. This selection is done for each k up to k log R, since there are no points closer than this distance to p. Note also that the level 0 fingers are simply random points in the metric space. Given these finger points, we use the following algorithm. QUERY´qµ let p be any point in S while p is not the nearest neighbor of q let k be maximum such that d´p qµ 2 k let p closest point to q in F k 1 ´pµ return p</p><p>We can analyze this algorithm using the Sampling Lemma. Given some point p at distance r from q, with 2 ´k•1µ r 2 k , we use samples (fingers) from the ball of radius 2 k 2r. The Sampling Lemma thus applies, telling us that we halve the distance of the current point to q with constant probability. The analysis of the previous section therefore applies to tell us the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 6</head><p>There is a data structure of size O´n log 2 Rµ that answers nearneighbor queries with high probability in O´log Rµ time.</p><p>Proof: There are log R distinct powers of 2 between the maximum and minimum distances in the metric spaces. For each such power of 2, we need O´log Rµ fingers for each of our n points. £</p><p>The problem with this approach, however, is the fact that drawing samples uniformly at random from prescribed spheres is not easy. In particular, if we demand that all these samples are independent of each other, efficient dynamic maintenance of the data structure seems difficult.</p><p>If we do not require dynamic maintenance of the data structure, however, this approach can be developed into a data structure by independently choosing the samples in "advance" during construction time. This scheme produces a data structure we call a "metric search tree" with the same time bounds as our current structure that can be analyzed by an application of branching processes. We omit the details in this version of the paper.</p><p>Instead, we concentrate on a data structure where the "pre-chosen" samples are not completely independent. While allowing for easier insertion and deletion, this makes the analysis more complicated, as we will see.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">METRIC SKIP LISTS</head><p>We now describe the metric skip list data structure that solves the nearest neighbor search problem in metric spaces with constant expansion rates. It follows the sampling paradigm described in the last section. To avoid the problem of creating (and maintaining) completely independent samples, we use a trick previously applied to the design of treaps (a dictionary data structure). To construct our data structure, we introduce a random ordering on the points in the sample space S. The construction of the data structure will then be deterministic given the ordering. But, using the fact that the ordering is truly random, we will show good performance guarantees.</p><p>For simplicity, we will assume in the following that all pair-wise distances of points in S are distinct (via perturbation).</p><p>We impose a random total order on S s 1 s 2 s n . We call s i•1 the successor of s i , and let s 1 be the successor of s n , so one can actually imagine the points arranged on a circle.</p><p>The data structure consists of sets of pre-chosen samples for every point s i ¾ S. We will refer to those samples as being "stored at" the corresponding point s i . For each node s i , we will store finger lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7</head><p>For r 0 the radius r finger list for s i , denoted F r ´si µ, contains the indices of the first 24c 3 elements after s i in the ordering that have a distance r to s i . If we reach the end of the ordering, we wrap around to the beginning, and if there are less than 24c 3 elements of this kind in S, then F r ´si µ just contains all of them. The length k finger lists are defined analogously, with the constant 24c 3 replaced by k.</p><p>In the remainder of this section we will analyze the space requirements of the data structure, prove that it can be used to find nearest neighbors in time O´log n log log nµ, and give an off-line O´n log n log log nµ construction algorithm. We defer the problem of dynamic updates (addition and removal of points from S) to the following section. Later in section 4.2 we will also improve the running time of the FIND-algorithm to O´log nµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Space requirements</head><p>At first glance, it seems that the number of finger lists F r ´si µ we have to store at a node is not bounded. But it actually turns out that with high probability only O´log nµ of the finger lists are distinct, as we will show now. Thus, it is enough to just store these, indexed by r. This leads to O´log nµ storage per node, or O´n log nµ for the whole data structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 8</head><p>Let S s 1 s n be a randomly ordered subset of a metric space M ´M dµ, k ¾ AE, and p ¾ M. Then with high probability, there are only O´k log nµ distinct length k finger lists for each s i .</p><p>Proof: We give an algorithm that outputs all the elements in any F r ´pµ, and analyze its behavior. Consider the following algorithm:</p><formula xml:id="formula_1">let j 0, F s 1 s 2 s k for i = k • 1 to n do if d´p s i µ max s¾F d´p sµ then // new element closer let j j • 1, f j element s ¾ F maximizing d´p sµ, F ´F Ò f j µ s i output F f 1 f 2 f j .</formula><p>We claim that this algorithm outputs all elements that appear in any length k finger list of p. Clearly, an element s i will not be in a finger list, if there are k elements before it in the ordering which are all closer to p than s i . The set F maintained by the algorithm always contains the k closest element to p among s 1 s 2 s i 1 . Using this invariant, we see that no elements besides the ones output at the end can appear in a finger list.</p><p>We will now show that the number of elements in the output is O´k log nµ with high probability. To be output, an element must first enter F. An element s i enters F if and only if it is one of the k closest elements to p among s 1 s i . These items are a random permutation of (some subset of) S, so s i is one of the k closest to p with probability k i. It follows immediately that the expected number of points entering F is ∑ k i O´k log nµ. For the high probability bound, consider generating the list s 1 s n backwards from the end by repeatedly choosing a random element not yet in the list. From this framework it can be seen that the probability of s i becoming a finger is independent of all other such events. Thus, the number of fingers is a sum of independent indicator random variables with mean O´k log nµ, and thus is O´k log nµ with high probability by the Chernoff bound.</p><p>Finally, note that the number of elements output upper-bounds the number of distinct length k finger lists, since the set F (which enumerates all finger lists) changes once each time we produce a new output element in the above algorithm. £</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The FIND-operation</head><p>The FIND-operation on our data structure is the "obvious" application of the sampling search strategy given in section 2. The algorithm is defined as follows:</p><p>FIND´qµ (finds nearest neighbor of q in S) Let us first prove the correctness of the algorithm. For this we will not need the fact that S has low expansion, i.e. the algorithm will work correctly (if not particularly efficiently) on any metric space.</p><formula xml:id="formula_2">let i 1 // i is current position let m 1 // m is</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 9</head><p>The FIND-algorithm always returns the nearest neighbor to q in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>We only move forward in the ordering, i.e. i is strictly increasing. An invariant of the algorithm is that s m is always the point closest to q among s 1 s i . Assume, for contradictions sake, that after moving from i to j, this condition did not hold. Then there must be a point s k (i k j) with d´s k qµ d´s i qµ r. This implies d´s k s i µ 2r. But such an s k should have been included in the finger list F r ´si µ, and would not have been skipped. The contradiction shows the correctness of the algorithm. £</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Running time analysis for FIND</head><p>In the following running time analysis, we will make a simplifying assumption to be removed later. When we access a finger list, we do so by the corresponding radius r. The unbounded number of possible values for r prevents us from storing the finger lists indexed by r, however. Therefore we store the finger lists in an array ordered by r. The most straightforward way of locating the correct list is therefore binary search on r, which leads to an additional cost of O´log log nµ per finger list access. Later, we will reduce this time to constant per finger list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 10</head><p>The FIND-algorithm with high probability accesses only O´log nµ finger lists. Thus, its running time is O´log n log log nµ with high probability.</p><p>Proof: First observe that the FIND-algorithm actually steps through all the elements that would appear in the length 1 finger lists of q (had q been inserted where we start the search). In particular, any time we take an element s i with d´s i qµ d´s m qµ, we are taking a 1-finger-list element. We will refer to these as "record" items. Note from Lemma 8 that there are O´log nµ record items with high probability. However, the algorithm will also encounter nodes that are not record items. We must bound this work.</p><p>We consider the running time of the algorithm on the first third S n 3 s 1 s 2 s n 3 of the elements, and prove that with high probability it is only O´log nµ. But "high probability" implies that the bound is true for any starting point, in particular the point where we end up after processing the first third of the points. This allows us to process the second (and eventually last) third of the points again in O´log nµ each, yielding at total time bound of O´log nµ. So consider the first third S n 3 . Suppose that our search is currently at item s k , having passed the set S k s 1 s k 1 . The set S S k is (thanks to our random ordering) a random subset of S, of size at least 2n 3. It follows from Lemma 2 that S S k is a metric space with ´O´log nµ 2cµ-expansion. In other words, with high probability, for all r 0 such that B q ´rµ Ω´log nµ, we have</p><formula xml:id="formula_3">B q ´2rµ ´S ÒS k µ 2c ¡ B q ´rµ ´S ÒS k µ</formula><p>We briefly defer the case of B q ´rµ O´log nµ. For larger balls, we have just argued that the elements in the finger list are drawn at random from a space with expansion rate 2c. Thus drawing 24c 3 3´2cµ 3 of them will yield one with distance at most d i 2 with probability at least 9 10, by Lemma 4. This tells us that the if test in the FIND algorithm will be satisfied with probability at least 9 10 in each iteration.</p><p>To outline our argument, we make two assumptions that must be revisited later. First, we assume any record-breaking step also reduces the distance by half. Second, we assume that the outcomes of the iterations are independent. Under these two assumptions, we can analyze our algorithm as a random walk.</p><p>Let d 1 d 2 be the distances to q of the elements s i visited during the execution of FIND on the first third of the elements. We will model d i as a random walk. The analysis above (and our assumption about record events) means that with probability 9 10 the if test succeeds and we halve our distance to q. When the if test fails, by definition and the Sandwich Lemma, we have</p><formula xml:id="formula_4">d i•1 4d i . It follows that E log d i•1 ℄ log d i 9 10•2¡1 10 log d i 7 10.</formula><p>In other words, the random walk has negative drift.</p><p>Such a random walk has the property that in O´log nµ moves, it will move O´log nµ times to a value below any previous encountered value. Such a move discovers a record breaking item. Since by Lemma 8 there are only O´log nµ record-breakers, we will have found them all within O´log nµ time steps.</p><p>We must now revisit our assumptions. Our argument that the distance halves with probability 9/10 per iteration ignored two cases. First, if we are on one of the ρ O´log nµ closest points to q, then the expansion rate need not hold. Second, in iterations where we encounter a record breaker, the distance need not halve. Note that each outcome (being on a close point, or encountering a record breaker) happens only O´log nµ times. We model this by letting an adversary "cancel" O´log nµ of the distance-halving steps that occur in our algorithm. The random walk analysis generalizes to this case and still shows that O´log nµ record-breakers will be encountered within O´log nµ steps.</p><p>Finally, it remains to justify our assumption above that the random walk steps are independent. We use the principle of deferred decisions. In an iteration starting at s i , our algorithm selects the closest item s j ¾ F 2r ´si µ that satisfies the if test. We can identify s j by walking forward on the list from f i , adding valid items to the finger list until the finger list is full or we encounter an appropriate s j . In this variant of the algorithm, we reach s j before examining any node following s j in the list. Thus, by the principle of deferred decisions, the fingers of s j are independent of all our previous steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>£</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Range Queries</head><p>In a range query we want to find all elements in S that are within a distance r of a query point q. These queries can be answered by a variant of our FIND-algorithm in time O´´log n • kµ log log nµ with high probability, where k is the number of returned points.</p><p>We simply modify the FIND-algorithm to never query finger lists with a radius of less than 2r. This ensures that we will never miss any of the points within the required ball around q. Similar to the original FIND, the behavior of this algorithm can be analyzed as a random walk, where the points within distance r of q are considered to be one set at distance r to q. It takes at most time O´log nµ for the random walk to get within distance r of q, and then O´kµ time to visit all points in the query radius, since it takes expected constant time between visiting successive elements in the ball. This yields a total bound of O´log n • kµ finger list accesses, for a O´´log n • kµ log log nµ running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Offline construction</head><p>Before considering dynamic updates to the data structure, we first present a simple O´n log n log log nµ off-line construction algorithm for our data structure.</p><p>Suppose we truncate all finger lists F r ´si µ, so that they do not "wrap around" at the end of the ordering, but rather only include elements after s i in the ordering. This data structure would still support searches, as long as they start at s 1 , at the beginning of the ordering.</p><p>Constructing this data structure can be done by starting with an empty data structure, and repeatedly adding s n s n 1 s n 2 s 1 to the beginning of the previously constructed data structure. This way, when we insert s i , we only have to compute s i 's finger lists, while the finger lists of already inserted elements remain the same (since, by definition, they will not contain s i ). At each step, the data structure so far is a metric skip list on the (random) subset of items s i•1 s n . This random sample has low expansion (Lemma 2) so the finger list computations for s i are fast.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Constructing the new element's finger lists</head><p>The construction of the new element s i 's finger lists can be done by a modification of the FIND algorithm. We start a search for s i at s i•1 , the successor of s i . But instead of just maintaining the closest element s m encountered so far, we keep the 24c 3 closest elements seen so far, dropping the furthest element of that set as soon as a closer element becomes available. As seen in the proof of Lemma 8, this yields all elements of s i 's finger lists.</p><p>The running time analysis of this search is virtually identical to the one given for the FIND-algorithm. The main change is that the number of finger elements is now 24c 3 times as large, which causes the random walk on the distances to be slower by that factor. But it still yields a O´log n log log nµ bound with high probability.</p><p>Thus, we can construct our data structure in time O´n log n log log nµ. The problem is that this approach does not immediately lend itself to performing dynamic updates, because by always inserting at the "beginning" of the ordering, we would not guarantee that the ordering remains random.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">DYNAMIC MAINTENANCE</head><p>In this section we describe how the metric skip list data structure can be maintained dynamically, i.e. how elements can added and deleted in O´log n log log nµ amortized expected time each. We will focus mostly on the INSERT-operation to add a new node to the structure, as the analysis for the deletion of a node is very similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Augmenting the data structure</head><p>To make dynamic maintenance of the search data structure possible efficiently, we have to add two more pieces of data to the basic structure described in the previous section. These are:</p><p>Nearest Neighbor Lists NN´s i µ R´s i µ: For every point s i we main-tain a radius R´s i µ 0 such that c log n B s i ´R´s i µµ 3c log n, and a list NN´s i µ of the points in B s i ´R´s i µµ.</p><p>Query Lists Q r ´si µ: For each finger list F r ´si µ we store an associated list of all elements s j that queried F r ´si µ when constructing their own finger lists. The exception to this is that we do not record s j 's queries for its finger lists with radius less than R´s j µ.</p><p>These additions do not change the O´n log nµ space requirement of the data structure. The nearest neighbor lists require O´log nµ space per node. And since the number of queries performed when constructing an element's finger lists is O´log nµ with high probability, the total number of entries in the query lists is O´n log nµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A faster FIND</head><p>It turns out that with only small changes, the FIND-algorithm can be modified to run time O´log nµ with high probability, with a corresponding bound of O´log n • kµ for the range search. We will use these bounds from now on to compute running times.</p><p>We change the FIND-algorithm so that once it queries a finger list F r ´si µ with r R´s i µ, we stop the random walk, and just return the closest element to the query point in NN´s i µ, which takes time O´log nµ by a linear pass.</p><p>The only reason that we incurred an additional O´log log nµ factor in the running time of the FIND-algorithm so far is that this was the time per accessed node to find the correct finger list. Suppose now that we further augment our data structure such that for each j ¾ F r ´si µ there is an associated pointer to F r ´s j µ, and also pointers from F r ´si µ to F 2r ´si µ. Maintaining these pointers can be subsumed in the total time taken for INSERT and DELETE.</p><p>Thus, we can find the next finger list in the FIND-procedure in constant time if the radius we query is "not too far off" the previous one. But this is true in the case of the FIND algorithm. The query radius never increases more than from r to 2r, and we can find that finger list in time O´1µ. From that point, we can seek through decreasing r for the correct radius finger list. Each drop in radius takes O´1µ time, but can be "charged" against the improved distance-in the FIND algorithm, we can basically think of this as a random walk step which improves with probability 1 rather than 9/10. Thus the analysis goes through unchanged, showing O´log nµ steps, but now the "steps" bound not only the number of nodes visited but also the work at each node.</p><p>A similar change can be made to the range query procedure given in section 3.4, yielding a running time of O´log n • kµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Range queries revisited</head><p>In section 3.4, we considered the range query of reporting all points within distance r of a point q. Now we consider the related query, where given a number k and a point q, we are asked to output the k closest points to q. This type of query will be useful to us for the INSERT procedure.</p><p>Unfortunately, this problem cannot be directly reduced to the one we already solved, as finding the correct r such that B q ´rµ k is difficult. It would be considerably easier if in addition to the expansion property we also had a lower bound of the form B q ´2rµ c ¼ B q ´rµ because that would relate r and k very closely. However, it is still possible to solve the problem efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 11</head><p>There is an algorithm that, given a point q and a number k, outputs the k closest neighbors of q in time O´log n • kµ. £ Due to its technical nature, we defer the proof to the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">The INSERT-operation</head><p>We have seen in section 3.5 how to construct our data structure in an offline manner, and in particular how to construct the finger lists of any newly inserted element q. The main change for dynamic updates is that now insertions do not occur "at the beginning" of the ordering, but rather at a random position in the middle. This means that the new element q has to appear on other elements' finger lists. The main difficulty of making insertion efficient is to be able to quickly find the elements that should point to q.</p><p>How do we find the elements s i that should include q in their finger lists? An element could have computed different finger lists, had q been present, only if it queried a finger list that should have contained q as well during its construction. This observation is only self-referential at first glance: to construct a finger list F r ´si µ of radius r, s i would query only finger lists with radius 2r or higher.</p><p>Using the query lists we introduced, the elements s i that have to point to q can be found using a search backwards along query pointers. First, we know that q has to be included in the distance 1 (the maximal distance) finger lists for the 24c 3 elements preceding it in the ordering. Then, recursively, whenever we add q to a finger list, we check all elements s i mentioned in the associated query list to determine which of these should change their finger lists, and so on.</p><p>The correctness follows, since, as mentioned above, for constructing a finger list of radius r, the INSERT procedure would only query finger lists of radius 2r and higher. That means that by fixing all radius 1 finger lists, we will inductively fix all other affected lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">The algorithm</head><p>In summary, the INSERT-procedure for a new element q is the following.</p><p>1. Insert q at a random position in the ordering. 2. Construct q's finger lists by searching forward in the ordering (cf. section 3.5) 3. Find 3c 2 log n nodes closest to q, compute R´qµ, NN´qµ such that NN´qµ 2c log n. 4. Include q in NN´s i µ among the 3c 2 log n nodes s i closest to q, as necessary. 5. Follow query pointers backwards to find all nodes that see q in the construction of their finger lists. For these elements and the 3c 2 log n closest neighbors: (i) Update their finger lists as necessary to include q.</p><p>(ii) Update the query list entries they caused, as necessary.</p><p>We will now bound the expected running time of the INSERToperation, and give more details on the implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">The analysis</head><p>We perform the running time analysis step by step of the algorithm. To do it, we introduce one more definition. The q-rank of point p is the number of points closer to q than p is.</p><p>Step 2: Constructing q's finger lists</p><p>Computing the finger lists can be done by a modified FINDoperation as in section 3.5, using time O´log nµ.</p><p>Step 3: Finding 3c 2 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>log n closest neighbors</head><p>We can do this using the procedure from Lemma 11 in time O´log nµ. In time O´log nµ we can find the element of q-rank 2c log n among these elements, which yields R´qµ and NN´qµ.</p><p>Step 4: Include q in NN´s i µ Due to the expansion property, any node s i for which q is among the 3c log n closest nodes must be among the 3c 2 log n nodes closest to q. So this step of the algorithm suffices to maintain the correct values of the NN´s i µ.</p><p>Using the list of the 3c 2 log n nearest neighbors s i computed in step 3, we can check for each of them in O´1µ by comparing d´s i qµ to R´s i µ to determine whether q should be included in NN´s i µ.</p><p>When this causes an NN´s i µ to grow beyond size 3c log n, we can recompute that element's finger lists, NN´s i µ and R´s i µ (such that NN´s i µ 2c log n) in time O´log nµ. Since it takes c log n insertions to cause such a change, the amortized cost per insertion is only O´1µ. Thus, the total amortized time of step 4 is O´log nµ.</p><p>Step 5: Following query pointers backwards In the next step of the algorithm, we follow query pointers backwards to determine which finger lists have to be updated following the insertion of q.</p><p>First, we will show that the number of nodes that we reach using this search is O´log nµ in expectation. Then, we will show that each of these nodes is pointed to by only a constant number of query pointers, so that the query pointer traversal takes total time O´log n log log nµ, the additional O´log log nµ factor coming from having to look up the correct finger and query lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 12</head><p>The expected number of elements that encounter q in the construction of their finger lists is O´log nµ.</p><p>Proof: Here and in the following we will use different methods to bound the work spent on the c log n nodes closest to q and all the other nodes.</p><p>In this case, we have to give no particular analysis for the c log n closest nodes, since even if they all encountered q they would only be O´log nµ nodes.</p><p>For the remaining n c log n nodes we are going to use a bounding technique that we will also use repeatedly in the remaining runtime analysis. Let s i be some fixed node in the structure, and p see ´rµ be the probability that s i sees the element of s i -rank r during its finger list construction. This probability p see ´rµ has the property that it is monotonically decreasing in r. This is because if an element of rank r were replaced by an element of rank r ¼ with r ¼ r in the same ordering, s i would still see this element in its search, if it saw the element of rank r before. Thus r ¼ r µ p see ´r¼ µ p see ´rµ.</p><p>Also, since the finger list construction only depends on the ranks of the elements, p see ´rµ is actually independent of the element s i .</p><p>Two more observations yield the desired bound. First, since the number of nodes that are encountered in a finger list construction is O´log nµ in expectation, we have ∑ n r 1 p see ´rµ O´log nµ. Second, if an element s i has q-rank r c log n, then q has a s i -rank of at least r c. This follows directly from the expansion property of the metric space. Thus, we have E #elements that "see" q℄ Let s i be any node. Then the number of finger lists that overlap q's position, that are queried in the construction of s i 's finger lists, is at most 24c 3 O´1µ. Thus, s i can "see" q only a constant number of times during the construction of its finger lists.</p><p>Proof: When constructing s i 's finger lists, the first time we access a finger list that overlaps q's position in the ordering, this finger list by definition contains all elements before q that we might include into s i 's finger list. This number is therefore at most 24c 3 . If we move to one of these points, then by the next time we access a finger list overlapping q's position, their number has decreased by one. So after seeing q's position at most 24c 3 times, we will move past it. £</p><p>The previous lemma implies that only 24c 3 query pointers from finger lists containing q can point to an element s i that "sees" q during its finger list construction. Thus the running time for the "query pointer search" part of step 5 is O´log n log log nµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Step 5(i): Updating finger lists</head><p>The time taken to create the finger lists containing q is at most O´log log nµ times the number of these finger lists. The O´log log nµ is taken to find the correct insertion point of the new finger list among the other finger lists. We will now show that q appears in an expected number of O´log nµ finger lists, yielding a total bound for this step of O´log n log log nµ.</p><p>We will first use a coarse bound that we will use for the c log n elements closest to q. Lemma 14 Let s i be any node. Then the expected number of s i 's finger lists that q appears in is O´1µ.</p><p>Proof: Consider the construction of s i 's finger lists. If we imagine s i being at the beginning of an order of n elements, and inserting q at a random position in that order, then q can only appear on the finger lists that are created "after" its insertion point in the ordering.</p><p>Consider some position k in the order. The 24c 3 -rd smallest s irank of the elements before the k-th position is expected to be close to 24c 3 n k O´n kµ. So since the remaining finger lists are constructed from only O´n kµ elements, the proof of Lemma 8 implies that the expected number of finger lists created after this point is O´log´n kµµ.</p><p>If q gets inserted at a random position, the expected number of finger lists created after that point is therefore on the order of</p><formula xml:id="formula_5">1 n n ∑ k 1 log n k log n log n! n log n ´log n O´1µµ O´1µ as claimed. £</formula><p>Again, this bound is enough for the c log n elements closest to q, as it yields an expected total number of O´log nµ occurrences among these elements, but we require a different approach for the remaining elements.</p><p>If E fl ´rµ is the expected number times that an element of s irank r appears in s i 's finger lists, then again we have ∑ n r 1 E fl ´rµ O´log nµ and r ¼ r µ E fl ´r¼ µ E fl ´rµ, by similar arguments as in the proof of Lemma 12 for p see ´rµ. Following the same proof technique as above, this shows that the expected total number of finger lists that q appears in is O´log nµ among all elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 15</head><p>An element q appears in O´log nµ finger lists in expectation. £</p><p>Step 5(ii): Updating query lists All the nodes that "see" q in the construction of their finger lists might now take potentially different query paths than before the insertion of q. So we have to construct as much of the new query paths as might be influenced by the insertion of q.</p><p>For a node s i that includes q in its finger lists, the queried finger lists might be different as long as q remains among the closest 24c 3 elements. For a node s i that does not include q in its finger lists, the queried finger lists might be different up to the next element that s i does include into its finger lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 16</head><p>The insertion of q causes O´log nµ query list pointers to change in expectation.</p><p>Proof: We will first treat the nodes s i separately for which q is one of the c log n closest nodes to s i (i.e. q ¾ NN´s i µ). For each of these nodes, the expected number of changed query pointers is O´1µ, for a total of O´log nµ for all these s i . This is because only 24c 3 of the nodes of NN´s i µ appear in s i 's finger lists with radius R´s i µ, and only these could result in a change of query pointers. The probability that q is one of these nodes is therefore O´1 log nµ. As the worst case number of changed query pointers is O´log nµ, the expected number of pointer that have to be changed is O´1 log n ¡lognµ O´1µ.</p><p>For all other elements, we are going to distinguish between the cases that q does appear or does not appear on their finger lists. First, the elements that include q in their finger lists.</p><p>Let E ¼ ´rµ be the expected number of queries performed for the finger list construction of an element s i , such that q has s i -rank r, while q is among the elements of the current finger lists. As there are always 24c 3 elements in the current finger list, we end up charging each query to 24c 3 elements. Since the expected total number of queries for s i is O´log nµ, we therefore have</p><formula xml:id="formula_6">n ∑ r 1 E ¼ ´rµ 24c 3 ¡O´lognµ O´log nµ</formula><p>As an element with a lower rank in the same position in the search will stay as long or longer in the finger list during the search, we have that r ¼ r µ E ¼ ´r¼ µ E ¼ ´rµ. A similar calculation as in Lemma 12 gives that q is expected to influence at most a total number of O´log nµ query pointers.</p><p>Second, we have to analyze the number of query pointers influenced by q among the elements that see q during their finger list construction, but do not actually include q among their finger list elements. The changes that q might necessitate are limited to the finger list construction from seeing q until the next finger list element is found. We will bound this in a similar fashion as above: let E ¼¼ ´rµ be the expected number of elements seen by s i after an ele- ment of rank r, before the next element of its finger lists is found (we bound this independent of whether q is actually a finger list element itself, we only bound the number of search steps until the next element is found). Again, we have r ¼ r µ E ¼¼ ´r¼ µ E ¼¼ ´rµ, because s i is more likely to see an element of lower rank in its finger list construction.</p><p>We have</p><formula xml:id="formula_7">n ∑ r 1 E ¼¼ ´rµ O´log nµ ∑ j 1 E X 2 j 2℄</formula><p>where X j is the number of elements seen between the j-th and the ´j • 1µ-st of s i 's finger list elements that we find, searching from s i . Since the variables X j are distributed geometrically with a constant expectation, we also have E X 2 j ℄</p><p>O´1µ, and therefore ∑ n r 1 E ¼¼ ´rµ O´log nµ. So in this case also, q is expected to influ- ence at most a logarithmic number of query lists. £ Thus, the running time of the INSERT-operation is expected total time O´log n log log nµ. Note that we did not analyze the cost to remove finger and query list entries now obsolete due to the insertion of q. But since our work will be linear in their size, and the size of the structure is expected to grow upon insertion of an element, the above bounds dominate the insertion time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">The DELETE-operation</head><p>For the DELETE-operation, we use the query lists to determine all finger lists containing q. Essentially, we do the opposite of what we did for INSERT, and rebuild a node's finger lists if NN´s i µ becomes smaller than c log n. Thus, the same time bounds apply, and the operation takes time O´log n log log nµ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">APPLICATION TO PEER-TO-PEER NET-WORKS</head><p>The nearest neighbor search structure described in this paper can be used with only slight modifications in the Chord Peer-To-Peer network protocol co-developed by the first author <ref type="bibr">[7]</ref>. We will now give a brief introduction to the relevant parts of the Chord data management protocol and describe how the nearest neighbor structure can be used in this context.</p><p>The Chord protocol allows for distributed data access by storing data items in multiple locations across the network. Every node gets assigned a random identifier, and the nodes can be imagined ordered on a circle based on these IDs. If an data item is stored in the network, it has one primary location, where the original copy of the item is stored. To speed up accesses, an item might be replicated to be stored at other nodes besides the primary location. In Chord, these copies are held on the nodes which immediately precede the primary location in the order of IDs. I.e., the item copies propagate backwards along the ordering, and the nodes that hold the item always form a continuous segment of the ordering of nodes.</p><p>In many applications of Peer-To-Peer networks, such as in wireless networks, the cost of accessing an data item grows as the distance to the item increases. Thus, it is advantageous to locate the "closest" copy of a data item to speed up accesses and lower operating costs. We will now show how the data structure developed in the previous sections can be used to this effect.</p><p>Observe that our data structure can easily be made "distributed" by simply storing the finger and query lists at the node in the network that they are associated with. This requires only O´log nµ additional storage for each node. As the nodes in Chord already have random IDs and are therefore naturally ordered in a random order, we can make use of the same ordering for our data structure.</p><p>The FIND, INSERT and DELETE protocols work as before, although in practice it might not be possible to store pointers into another node's finger lists that allow for O´1µ lookups of the correct lists. Thus, a list lookup cost of O´log log nµ is more realistic, and the operations become more costly by that factor. But since the cost of an operation in a Peer-to-peer network is dominated by the number of node-to-node communications (which stays O´log nµ) and not by in-node computations, this does not seem to be a great loss.</p><p>Suppose now that we want to find the closest copy to a node q of an data item whose primary locations is node p. The search is similar to the FIND-operation with the difference that we will not search beyond p, since all copies of the data item are stored directly before the node p in the ordering. On a high level, the search algorithm is as follows:</p><p>1. If the item is stored at node q, stop and access the item.</p><p>2. Find a location p ¼ containing the item, so that there is no closer node with the item between q and p ¼ in the ordering.</p><p>3. Perform a FIND from p ¼ for q, keeping track of the closest item containing node seen, and stop as soon as the FIND operation moves beyond p.</p><p>Step 1 needs no explanation -if the item is already at our current location there is no need to look for it elsewhere. Step 2 is straightforward by a modification of the Chord lookup protocolthat protocol does a binary search for q, and it can be modified to report an "overshoot" if it encounters any p that contains the item.</p><p>Step 3 finds the closest copy of an item, assuming that the second step completed successfully, because during the FIND operation we will see all elements that are closer to q than the previously closest element we saw, starting out with p ¼ . So we cannot possibly miss seeing the closest element to q between p ¼ and p, which is the one we are looking for. And obviously, we can terminate the search as soon as we have passed p since the following elements do not contain the item. Both steps only take time O´log nµ (or rather access that number of nodes).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>We have introduced a new data structure for nearest neighbor search in metric spaces with low expansion rates. The structure is simple, efficient, and can easily be use in a distributed environment, for example if points correspond to nodes in a network.</p><p>An interesting open problem is to make the data structure fault tolerant, in the following sense. If the data structure is actually distributed on a set of nodes, such as a Peer-To-Peer network, then it is not unlikely that single nodes just "fail" without invoking a deletion procedure. Is it possible to augment the data structure to work even when nodes (and their associated finger lists) just disappear?</p><p>Another interesting property of low expansion metrics is that they can be embedded into an O´Ôlog nµ-dimensional Euclidean space with low distortion (as opposed to the O´log nµ-dimensional space required for general metrics). This allows for approximate nearest neighbor searches by reduction to the Euclidean case. It would be interesting to see whether this avenue leads to other approaches to this problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>n ∑ r 1 1 p</head><label>11</label><figDesc>Pr element of q-rank r "sees" q℄ O´log nµ • n ∑ r c log n p see ´r cµ O´log nµ • c n ∑ r see ´rµ O´log nµ proving the lemma. £ Lemma 13</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>minimum so far while i n do let r d´s i qµ if j ¾ F 2r ´si µ such that d´s j qµ d´s m qµ or d´s j qµ r 2 then let i be the smallest index ¾ F 2r ´si µ with that property if d´s i qµ d´s m qµ then let m i else let i max F 2r ´si µ output s m .</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Recall that on a grid the expansion rate c is exponential in the standard dimension d; thus being polynomial in c fits the outcome, common in geometric algorithms and data structures, of being exponential in the standard dimension.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX The Algorithm</head><p>In this section we prove Lemma 11: we give an algorithm that reports the k closest neighbors of a node q in time O´log n • kµ. The algorithm can be summarized as follows: K-RANGE-QUERY´q kµ (returns k nearest neighbors of q in S) let s m nearest neighbor of q let r R´s m µ, B B q ´rµ while B k do let r AUGMENT´r B qµ, B B q ´rµ output k points in B closest to q Note that the assignments B B q ´rµ here correspond to range queries in the sense of section 3.4.</p><p>The sub-routine AUGMENT´r B qµ that we have to define later can be called with B B q ´rµ and B log n. It returns with high probability in time O´ B µ an r ¼ r such that</p><p>In other words, B grows by a constant factor each time.</p><p>The correctness of the above algorithm is clear. As for the running time, the first two lines take time O´log nµ. Every execute of the while loop takes time O´log n • B µ. Since B grows geometrically, the sum of these times collapses to O´log n • kµ, as claimed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The AUGMENT-Procedure</head><p>The AUGMENT-procedure overcomes the problem that by there is no bound on by how much we have to increases r to increase the size of B q ´rµ by a constant factor. The procedure uses sampling near B to obtain an estimate on the local growth rate of B q ´rµ. AUGMENT´r B qµ</p><p>The running time of this algorithm is O´ B µ as each iteration of the loop requires a lookup of F 2r ´bi µ, which can be done in constant time as in section 4.2, because we already have pointers to F r ´bi µ after the range search that computed B. Note that if there is no element in b i 's finger lists of distance more than 2r to b, then we can set r i ∞.</p><p>For correctness, we need to prove that the inequalities (1) hold (we use r ¼ to refer to the value returned by the AUGMENT-procedure).</p><p>The lower bound is the easier of the two. Note that none of the a i are in B, as their distance to q is at least d´a i qµ d´a i b i µ d´b i qµ 2r r r. On the other hand, by returning the median of the r i , we guarantee that the new ball B q ´r¼ µ now contains at least half of the a i . It remains to show that there are not too many repetitions among the a i .</p><p>For this and the following it will be useful to recall that the b i are arranged on a circle order in the search data structure. For notational simplicity assume that they occur in the order b 1 , b 2 , , b in the data structure. Notice that we have a i a j if i • 24c 3 j. This is because b i would encounter b i•1 b i•2 b i•24c 3 before seeing a j in its finger list construction, and since all the b's are closer to b i than a j , a j would not be included into b i 's finger list. That is, each a i appears at most 24c 3 times among the other a's. Thus, B q ´r¼ µ B • 1 2 1 24c 3 B , which shows the first inequality. While the previous inequality holds unconditionally, we will prove that the second inequality holds with high probability. Let p be the element of q-rank 7c 2 B , and R : d´p qµ • r. We will show that with high probability r ¼ R. This is enough, because by the expansion property B q ´Rµ c B q ´d´p qµµ 7c 3 B , using R d´p qµ • r 2d´p qµ.</p><p>Let X i be the event that r i R. To show that with high probability at least half of the X i occur, we will bound them by other events. Let P be the set of elements with q-rank in B • 1 c 2 B , and Q be the set of element with q rank in c 2 B • 1 7c 2 B . Note that the elements of Q all are at least distance 4r r 3r from the elements in B, and thus would be considered as choices for the a i in the AUGMENT procedure.</p><p>In the random order of the data structure the sets P and Q occur interleaved with the points b 1 b 2 b . Let us focus on the random sub-ordering consisting just of these 7c 2 B elements. Let Y i be the event that b i is directly followed by an element of Q in this ordering. We then have that Y i implies X i . This is because if b i includes the element of Q that directly follows it in its finger list, then that element is a valid candidate for a i , and since it is closer than R to q, X i is true. On the other hand, if b i does not include this element in its finger list, then there must be 24c 3 elements closer than it to b i between the two in the ordering. Since Y i holds, these elements must have q-rank 7c 2 B , thus cannot be closer than 2r to b i , but also cannot be further than R from b i , thus X i is satisfied.</p><p>We now proceed to bound the probability that less than half of the Y i happen. Fix any ordering of the b i and P. If we imagine inserting the elements of Q at random places in this ordering, then there are B • P • Q Q ¡ ways to do so. If, however, more than half of the Y i are not true, then the elements of Q may not be inserted directly behind the b i for which Y i is not true. Thus, there are only</p><p>choices for an ordering. By multiplying with the number of possible choices for which Y i are not true, we obtain an upper bound on the probability of failure by:</p><p>0 882 B This is polynomially small since B log n.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Multidimensional binary search trees used for associative searching</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="509" to="517" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Optimal expected-time algorithms for closest point problems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bentley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Weide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions of Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="563" to="580" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Near neighbor search in large metric spaces</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="574" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Searching in metric spaces</title>
		<author>
			<persName><forename type="first">E</forename><surname>Chávez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Baeza-Yates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Marroqu Ín</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="273" to="321" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Nearest neighbor queries in metric spaces</title>
		<author>
			<persName><forename type="first">K</forename><surname>Clarkson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="63" to="93" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Accessing nearby copies of replicated objects in a distributed environment</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">G</forename><surname>Plaxton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Richa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="241" to="280" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Chord: A scalable peer-to-peer lookup service for internet applications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kasshoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mapping a manifold of perceptual observations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A global geometric framework for nonlinear dimensionality reduction</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Langford</surname></persName>
		</author>
		<ptr target="http://isomap.stanford.edu" />
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">290</biblScope>
			<biblScope unit="issue">5500</biblScope>
			<biblScope unit="page" from="2319" to="2323" />
			<date type="published" when="2000-12">December 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Satisfying general proximity/similarity queries with metric trees</title>
		<author>
			<persName><forename type="first">J</forename><surname>Uhlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="175" to="179" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Data structures and algorithms for nearest neighbor search in general metric spaces</title>
		<author>
			<persName><forename type="first">P</forename><surname>Yianilos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SODA</title>
		<meeting>SODA</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="311" to="321" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
