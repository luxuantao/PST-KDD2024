<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Volume Rendering of Sparse Datasets Using Adaptive Mesh Refinement</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ralf</forename><surname>Kahler</surname></persName>
							<email>kaehler@zib.de</email>
						</author>
						<author>
							<persName><forename type="first">Mark</forename><surname>Simon</surname></persName>
							<email>mark.simon@zib.de</email>
						</author>
						<author>
							<persName><forename type="first">Hans-Christian</forename><surname>Hege</surname></persName>
							<email>hege@zib.de</email>
						</author>
						<title level="a" type="main">Fast Volume Rendering of Sparse Datasets Using Adaptive Mesh Refinement</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4B16090076790AD30568E4EBAD573028</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>scalar field visualization</term>
					<term>volume rendering</term>
					<term>3D texture mapping</term>
					<term>hierarchical space partitioning</term>
					<term>AMR tree</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we present an algorithm that accelerates 3D texturebased volume rendering of large and sparse data sets. A hierarchical data structure (known as AMR tree) consisting of nested uniform grids is employed in order to efficiently encode regions of interest. The hierarchies resulting from this kind of space partitioning yield a good balance between the amount of volume to render and the number of texture bricks -a prerequisite for fast rendering.</p><p>Comparing our approach to an octree based algorithm we show that our algorithm increases rendering performance significantly for sparse data. A further advantage is that less parameter tuning is necessary.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>1 Introduction 3D imaging and computational science produce increasingly large volumetric data sets. The number of voxels output by 3D imaging devices is proportional to the third power of their spatial resolution which continuously grows linear due to technical advances e.g. in detector technology. While data volumes consisting of O (10 9 ) voxels are not unusual today, future imaging devices and large scale simulations will create tera-scale data sets. These huge data sets have to be handled and explored interactively. Despite the enormous computer hardware development this remains a challenge.</p><p>Hierarchical representations allow to speed up the rendering process, typically at the expense of some preprocessing time. Furthermore, they enable switching between different levels of detail, which greatly facilitates interactive navigation and provides appropriate means for data analysis of multiscale phenomena.</p><p>Since the early days of direct volume rendering, the prevalent types of rendering algorithms, namely ray casting <ref type="bibr" target="#b11">[14,</ref><ref type="bibr" target="#b16">19]</ref>, cell projection, splatting <ref type="bibr" target="#b29">[32]</ref>, and volume rendering via 3D textures <ref type="bibr" target="#b6">[9,</ref><ref type="bibr" target="#b4">7,</ref><ref type="bibr" target="#b31">34]</ref>, have been accelerated by hierarchical volume representations.</p><p>Due to the advent of powerful texturing hardware, slice based volume rendering algorithms, either using 2D <ref type="bibr" target="#b8">[11]</ref> or 3D texture mapping <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b31">34]</ref>, became very popular. They allow to obtain an image quality that suffices for many applications and make interactive frame rates on standard graphics hardware possible. The textures result from transfer functions that map the original data to color and opacity values. In case of 3D texture mapping, the texture coordinates at the polygon's vertices are interpolated and determine a slice through the 3D texture. This approach leverages the trilinear interpolation hardware and has the additional advantage that textures need to be loaded only once, independent of the viewpoint. If the data set is too large to fit in texture memory, the full volume may be rendered in multiple passes, placing only portions of the volume data, so called bricks, into the texture memory on each pass.</p><p>For sparse data sets the rendering speed can be significantly increased by skipping non-interesting regions, as noticed earlier in various volume rendering approaches. If the ratio of relevant to non-relevant volumes is small enough, this can be exploited with specialized variants of almost all types of volume rendering algorithms. This technique is well suited for interactive visualization, in particular if the criterion of relevance can be adjusted reasonable fast, such that user itself can ensure not to miss important details. More sophisticated approaches like truely error-controlled numerical computation of the volume rendering integrals, are more expensive and view-dependent. Furthermore, in many applications particular subvolumes shall be ignored deliberately, e.g. irrelevant spatial objects that have been identified in a preceding image segmentation step.</p><p>Disregarding irrelevant parts of the data volume is especially effective for spatially sparse data sets. Since such data occur frequently in nature it is worthwhile to devise specific rendering algorithms. For instance in biomedical visualization, line-like structures, like vessel trees, neuron trees, trabeculae in bones, or filament structures in muscels, have to be visualized. Thin structures occur on all length scales in nature, ranging from chain molecules in chemistry to filaments of galaxies and galaxy clusters. In numerical simulations often large computational volumes have to be considered to take care of boundary conditions, though the interesting phenomena happen in very tight spatial regions. Here also a tight fitting of relevant subvolumes helps to save rendering time.</p><p>In case of rendering via 3D textures, sparsity of data can be exploited by assigning individual 3D textures -usually called texture bricks -to the relevant regions. The optimal coverage of the relevant subvolumes would be achieved by assigning a texture brick to each voxel that has been classified as relevant. This of course would result in an enormous number of texture and polygon coordinates to be computed and specified, since every brick has to be intersected with the proxy geometries (i.e. the slices to be rendered). Therefore a good balance between the volume enclosed by texture bricks and the number of created bricks is crucial.</p><p>In this paper we present an algorithm that achieves this balance by utilizing a hierarchical data structure, the so called adaptive mesh refinement (AMR) tree, which has been introduced by Marsha Berger in the 1980s for numerical gas dynamical simulations <ref type="bibr" target="#b2">[5]</ref>.</p><p>We compare the AMR-based algorithm with an octree-based algorithm and show that significant gains in rendering performance are achieved. The AMRbased algorithm has the additional advantage that it requires less user interaction for parameter adjustment, since its standard parameter settings already yield good rendering performance, almost independent of the topology and spatial distribution of the interesting subregions.</p><p>Section 2 surveys related work. We describe our approach in Section 3.1. In Section 3.2 we compare it to an octree approach. Sections 4.1 and 4.2 address the 3D texture based rendering of AMR and octree hierarchies, respectively. In Section 5 we list performance results of the methods on different data sets. Conclusions and future work are presented in Sections 6 and 7, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>The idea to accelerate volume rendering algorithms by ignoring subregions that do not contribute to the final image has been pursued by many researchers. Levoy <ref type="bibr" target="#b17">[20]</ref> presented a ray transversal algorithm that skips empty space by utilizing a hierarchical data structure indicating the presence of non-transparent material. The pyramidal data structure (a complete octree) has been employed by many researchers, too. Subramanian and Fussel <ref type="bibr" target="#b24">[27]</ref> also designed a ray tracer that works efficiently when the data of interest is distributed sparsely through the volume. A simple preprocessing step identifies the voxels representing features of interest and stores these in a kD-tree. The partitioned space is then efficiently ray-traced to render the voxel data.</p><p>Laur and Hanrahan <ref type="bibr" target="#b14">[17]</ref> proposed a splatting algorithm that works on a pyramidal representation of the volume and chooses the number of splats adaptively, according to user-supplied error criteria. Storing data mean and root mean square at each node permits rendering by progressive refinement. Nodes within the user-specified tolerance are rendered as single splats by utilizing texture mapping capabilities.</p><p>Danskin and Hanrahan <ref type="bibr" target="#b7">[10]</ref> presented algorithms that exploit homogeneity: not only empty, but also homogeneous regions are traversed in a fast manner. The algorithms enable to take into account also accumulated opacity. Generalizing these ideas Wilhelms and Van Gelder used multi-dimensional trees, whose nodes contain also importance information which is used for selective traversal, e.g. in a coherent projection rendering approach <ref type="bibr" target="#b30">[33]</ref>.</p><p>Extending the idea of exploiting the distance transform to speed up the background traversal <ref type="bibr" target="#b32">[35]</ref>, Cohen and Sheffer <ref type="bibr" target="#b5">[8]</ref> introduced so-called proximity clouds that store the 'uniformity information' typically encoded in a space partitioning tree directly in the voxel raster: voxel data contain either a data value or information indicating how far incident rays may leap without missing important features.</p><p>A different multiscale approach is to project the volume data into a wavelet basis and exploit this e.g. by performing the integration process for rays on the resulting wavelet coefficients directly <ref type="bibr" target="#b28">[31]</ref>. This has been extended by Lippert and Gross <ref type="bibr" target="#b19">[22]</ref>, who employ Fourier descriptions of wavelet basis functions to efficiently compute line integrals.</p><p>Lee and Park <ref type="bibr" target="#b15">[18]</ref> reduced ray-casting overheads by an adaptive block subdivision. Their algorithm applies a uniform space subdivision and then merges coherent uniform blocks in order to generate adaptive-sized blocks which are efficient for leaping space. They achieved 25% to 70% performance gain in rendering time over some octree implementation.</p><p>LaMar et. al. introduced a multiresolution technique for interactive texturebased volume visualization of very large data sets <ref type="bibr" target="#b13">[16]</ref>. They also use an octree representation and employ an adaptive scheme for rendering the volume in regions-of-interest at high resolution and the volume away from these regions at progressively lower resolutions. Weiler et.al. <ref type="bibr" target="#b27">[30]</ref> additionally developed methods for avoiding artifacts that occur due to incorrect texture interpolation and opacity correction at brick boundaries. Boada et.al. <ref type="bibr" target="#b10">[13]</ref> present an error and importance driven strategy for selecting a set of octree nodes from the full pyramidal structure.</p><p>Some of these ideas have been extended for handling time-varying data sets. Ma et.al. <ref type="bibr" target="#b12">[15]</ref> developed a corresponding octree encoding and rendering algorithm of time-varying volume data. Shen et. al. <ref type="bibr" target="#b22">[25]</ref> proposed a data structure, called time-space partitioning (TSP) tree, that can effectively capture both the spatial and the temporal coherence from a time-varying field. This is utilized in a ray casting algorithm. In recent time this work has been extended to hardware volume rendering using 3D texture mapping <ref type="bibr" target="#b23">[26]</ref>.</p><p>For AMR data, resulting from simulations of hyperbolic PDEs by finite difference algorithms, a direct volume rendering using cell projection has been developed by Weber et.al. <ref type="bibr" target="#b26">[29]</ref> and Ma <ref type="bibr" target="#b20">[23]</ref>.</p><p>Tong et.al. developed methods for volume block trimming and texture block merging in order to load only volume data hat contains important objects into texture memory <ref type="bibr" target="#b25">[28]</ref>. Srinivasan et.al. <ref type="bibr" target="#b21">[24]</ref> present an octree data structure to encapsulate non-transparent voxels.</p><p>We present an algorithm that in a first step creates an AMR hierarchy on base of the 3D image contents. It utilizes a clustering algorithm for merging cells into rectilinear regions. In order to minimize waste of texture memory caused by OpenGL (and possibly hardware) restrictions as well as to reduce texture I/O, we employ a packing algorithm. The created hierarchies are rendered via hardware assisted 3D texture mapping.</p><p>3 Generating the Hierarchies 3.1 Generating the AMR Hierarchy</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">The AMR Data Structure</head><p>In the AMR approach the whole computational domain is covered by a coarse grid, representing the root node of the hierarchical data structure. In regions where higher resolution is required, finer subgrids are inserted as child nodes of the root grid. Together they define a new level of the hierarchy, increasing the resolution of their parent grid by a factor, usually referred to as refinement factor. Figure <ref type="figure" target="#fig_0">1</ref> shows a 2D example. This process repeats recursively until all grid cells on the finest resolution level satisfy certain error criteria, which depend on the particular numerical simulation. For simplification purposes the AMR schemes usually fulfill the following restrictions:</p><p>• The refinement factor is a positive integer, possibly different for the various spatial directions.</p><p>• The subgrids are axis-aligned, structured rectilinear meshes, consisting of hexahedral cells with constant edge lengths.</p><p>• Subgrids are completely contained within their parent grids. • Subgrids begin and end on parent cell boundaries, which implies that parents grid cells are either completely refined or completely unrefined.</p><p>In the next paragraph we describe how we utilize AMR hierarchies to efficiently capture the relevant parts of the datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Extracting the Relevant Regions</head><p>In a preparing step we generate a pyramidal hierarchy of coarser resolutions of the original grid by subsampling with an integer factor. The pyramidal hierarchy will only be used in the preprocessing step, but not during rendering. The coarsening factor usually is chosen as 2. Larger values are possible and may be useful to reduce the amount of memory needed to store the pyramidal hierarchy. The factor may also be different for each of the 3 coordinate directions. Each cell on the coarser level stores the minimum and maximum values of all the data voxels of the subregion it covers, as shown in Figure <ref type="figure" target="#fig_1">2</ref> is recursively repeated until the number of data samples in one direction drops below some specified lower bound. In cases where the cell size of the original dataset does not match a multiple of a power of the refinement factor, the remainder cells are covered by one coarser cell on the next layer. This might</p><formula xml:id="formula_0">A A B C D</formula><p>involve some cropping of the subgrids' bounding boxes, when descending from a coarser to a finer layer.</p><p>After this preparing step we build the hierarchy of axis-aligned subgrids that provide a tight enclosing of the relevant subareas. The coarsest resolution of the pyramid defines the root grid of the hierarchy.</p><p>Next, the cells of the root grid are inspected and the relevant ones are marked for refinement. In order to classify the voxels into relevant and irrelevant ones an importance criterion is necessary. This might be based on transparency or on a segmentation which assigns voxels to classes based upon their values. In the first case the colormap's alpha values in the interval associated with the minimal and maximal values being stored in the coarse cells are examined and in case the threshold is exceeded the cell is flagged. Now the subgrids are created by invoking a clustering algorithm. It efficiently encloses the grid cells that require refinement by axis-aligned rectilinear regions, subject to the following conditions: minimize the number of created boxes as well as the number of covered cells that do not need refinement. The algorithm will be presented in subsection 3.1.3. Thereby child grids of the root level are defined. This clustering procedure is recursively applied to the new subgrids until the finest level of the min-max layers is reached. Then the original data cells that are covered by the grids on this layer, are inspected and clustered again. Thereby the memory overhead of storing two additional values for each cell of the original data volume is avoided without limiting the clustering granularity to the cell size of the first min-max layer. Now the data samples covered by these grids are copied and stored in the grids' tree node. The pseudo code for these steps is given in Figure <ref type="figure">3</ref> (re-clustering is omitted for simplification purposes). Some care is necessary at the boundary faces of the grids. To avoid artifacts caused by discontinuities between adjacent grids during the rendering via 3D-textures, one has to assure that they share one row of data samples at their common boundary faces <ref type="bibr" target="#b13">[16]</ref>.</p><p>Notice that one could alternatively cluster directly on the original data volume, without first creating the min-max-pyramid, but this would increase the time for creating the AMR-hierarchy, because the clusterer works faster on smaller grids. As discussed in <ref type="bibr" target="#b3">[6]</ref> the running time is O(k(P + M)), where k is the total number of grids upon termination of the algorithm, P is the number of flagged cells, and M is related to the determination of the inflection points, see subsection 3.1.3. Dividing the preprocessing step into pyramid creation and clustering is advantageous, since only the clustering step has to be repeated if the colormap is changed -which may happen several times during a visualization session.</p><p>Notice also that this AMR hierarchy offers the possibility to obtain a multiresolution representation of the interesting regions by applying appropriate averaging methods in order to compute the data samples on the coarser grids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">The Clustering Algorithm</head><p>An efficient and fast algorithm for clustering cells into axis-aligned regions was suggested by Berger and Rigoutsos <ref type="bibr" target="#b3">[6]</ref>, adopting signature-based methods used in computer vision and pattern recognition. We will shortly describe the basic ideas in this section. For more details the reader might refer to <ref type="bibr" target="#b3">[6]</ref>.</p><p>First for each slice perpendicular to the x-y, x-z and y-z planes the number  detected and pruned off, in order to place a minimal bounding box around the flagged cells. Any interior zero entry in these lists indicates a potential cutting index, i.e. a position at which the given volume is subdivided into two smaller subregions. In cases where the signatures are all non-zero, the Laplacian second derivative of each signature list is computed and the biggest inflection point of these three lists is taken as the splitting point. The described procedure is repeated recursively on the newly created subregions, until one of the following halting criteria is satisfied:</p><p>• The subregion exceeds some efficiency ratio, i.e. the ratio of the number of its cells needing refinement to its total number of cells is greater than a preselected value between 0% and 100%.</p><p>• The further subdivision of the region would result in grid dimensions smaller than some minimal extension.</p><p>As a result the data volume is partitioned in a kD-tree manner, which will be relevant for the back-to-front traversal of the generated hierarchy in the rendering step (see subsection 4.1.2). Our implementation of the clustering algorithm was inspired by Paul Walker's version [1] that is used in the AMR software package DAGH <ref type="bibr">[2]</ref>. Adjusting it to our specific needs resulted in performance gains of about a factor of 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generating the Octree</head><p>We compare the AMR approach with an octree based renderer, similar to the one described in <ref type="bibr" target="#b21">[24]</ref>. First the data volume is partitioned into bricks of preselectable dimensions. These should equal a power of two, in order to minimize the amount of texture memory needed in the rendering step (see section 4). Note that, just like in the AMR case, adjacent nodes need to share data samples at their common faces. These bricks define the leaf nodes of the full octree hierarchy. Only subbranches with leaf nodes that cover non-transparent regions of the data volume are inserted into the hierarchy. rendering performance is affected by As mentioned in the introduction the • the size of the subvolumes to render the number of bricks.</p><p>• the number of polygon and texture coordinates to be generated and thus Since the subvolumes of the leaf nodes are later defined as texture bricks (see section 4), the rendering performance can be increased by reducing their number without enlarging the size of volume to render. In order to do so one checks if all eight children of an octree node are leaves, and thus have to be rendered. Then they are cut off and the node becomes a new leaf. This reduces the number of bricks needed by 7 and also decreases the amount of texture memory, since the overlapping boundaries are canceled. Another reduction of bricks is achieved by taking into account the ratio between the sum of volumes covered by the leaves of a node and the node's volume itself. If this ratio exceeds a preselected threshold, the branch is cut and the node gets a leaf node (see Figure <ref type="figure" target="#fig_3">5</ref>), which usually increases the volume to render. This threshold can be different for each level of the hierarchy. To find a good balance between the performance limiting factors mentioned above, these parameters have to be to be adjusted carefully, as also noticed in <ref type="bibr" target="#b21">[24]</ref>. Now the data volumes covered by the resulting leaves of the octree are copied and stored in the hierarchy's nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Rendering</head><p>We render the created subvolumes utilizing the 3D-texture mapping approach. Individual 3D-textures are assigned to the separate subvolumes and are clipped against equidistant slices parallel to the viewplane. The slices are then blended back-to-front in the frame buffer.</p><p>The volume rendering routines for both, the AMR and the octree hierarchies are implemented in AMIRA <ref type="bibr" target="#b0">[3]</ref>, a 3D visualization system developed at ZIB. One channel textures and the OpenGL colortable extension were used. In the following we describe the differences for both types of hierarchies, AMR tree and octree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Rendering the AMR hierarchy</head><p>The graphics hardware assumes the dimensions of 3D-textures to be equal to a power of two. This could be achieved by extending the data subvolume of each leaf grid of the AMR hierarchy to the next bigger power of two, for example by clamping the boundary texels and restricting the generated texture coordinates to the unextended area. Regarding the potentially large number of textures to deal with, this would result in a typically large overhead of unused texture memory. We decided to reduce this overhead by utilizing a packing algorithm that merges separate textures into one bigger texture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Packing the Leaf Bricks</head><p>For our purposes the following variant of the three-dimensional packing problem is appropriate: pack a given number of rectilinear boxes into one container with fixed width and depth sizes, such that its height is minimized. For a more formal definition see <ref type="bibr" target="#b18">[21]</ref>. This problem belongs to the class of NP-hard problems, but a couple of useful heuristics have been suggested. We adopt a level-by-level layer-by-layer packing scheme, a three-dimensional version of the next-nit-necreasing-neight (NFDH) algorithm <ref type="bibr" target="#b9">[12]</ref>. First the boxes are inserted into a list, in the order of decreasing height. The packing algorithm starts at the lower left-hand corner of the container and inserts the boxes from left to right until the right border is reached. Then a new row is opened, with a depth coordinate given by the largest depth of the already inserted boxes. This procedure is repeated until the lowest layer of the container is filled. Then a new layer is opened and this process continues until all boxes are inserted. See Figure <ref type="figure" target="#fig_4">6</ref> for a 2D example.</p><p>We iterate this procedure with different values for the base layer extensions of the container, chosen as powers of two. For the resulting containers the heigth is extended to the next power of 2, and the one with smallest volume is taken. Then a 3D texture of this size is defined with the subtextures inserted at their computed positions. For each brick its offset position in the merged texture is stored.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Back to Front Rendering</head><p>Even for axis-aligned subvolumes, generally it is not possible to render them back-to-front in a brick-by-brick approach, because occlusion cycles might occur when looking from certain viewpoints, c.f. Figure <ref type="figure" target="#fig_5">7</ref>. But since the clustering algorithm described in section 3.1.3 internally generates a kD-tree partitioning of the data volume, no cycles occur in the AMR approach. Thus we use this kD-tree in order to traverse the generated bricks in the correct order. At each node the actual viewpoint is compared to the value of the node's split position and the two child nodes are visited in a back-to-front manner. If the node is a leaf, the associated subvolume is rendered slice by slice.</p><p>Computing the intersection points of the slices and the bricks' bounding boxes is done in software. We speed up this procedure by first determining for each brick the interval of slices that intersect it. This is accomplished by projecting the bounding box corners of the brick on the planes normal direction as shown in Figure <ref type="figure">8</ref>. Only for this subset the intersections need to be computed. This is done by first determining which bounding box corners lie above and which below the oriented plane, by comparing the projections onto the plane normal vector of the plane center and the corners of the bounding box. A lookuptable stores which edges are intersected and their correct order (needed for the definition of the associated polygon) for each configuration. The intersection coordinates are computed by linear interpolation between the endpoints of these edges. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Rendering the Octree</head><p>Since most leaf nodes of the octree already have dimensions equal to a power of 2, each of them is converted into a separate texture brick. Merging them into one big texture generally increases the amount of texture size due to the non-optimal packing scheme.</p><p>Each octree brick is rendered separately in a back-to-front traversal. The view-consistent order can easily be determined by a table lookup at each node, which returns the correct order to visit the children with respect to the actual viewpoint <ref type="bibr" target="#b1">[4]</ref>.</p><p>As in the AMR case, for each brick the interval of intersecting slices is precomputed and the intersection points are determined using the fast table-lookup approach mentioned above. In <ref type="bibr" target="#b21">[24]</ref> the authors determine the intersection points by computing several templates, which are translated to the actual box position.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setting</head><p>We applied our algorithm to several data sets with decreasing degree of sparseness. The performance was tested on a SGI Onyx2 InfiniteReality2 with two RM7 raster managers with 64 MB texture memory. The runs were performed on a single 195 MHz MIPS R10k processor.</p><p>Since texture based volume rendering is fillrate limited, the frame rates depend on the size of the viewer window, the number of slices, and the area in screen space covered by the data volume (and thus on the actual position of the viewpoint).</p><p>We averaged the framerates for several positions inside and outside the data volume, by choosing viewpoints located on different circles with variing radii and orientations, as indicated in Figure <ref type="figure">9</ref>. For all examples the sizes of the rendered images were 764 × 793 pixels; the numbers of slices are listed below.</p><p>Figure <ref type="figure">9</ref>: Some of the camera positions used for determination of the average rendering speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Input Data</head><p>In the examples we used the opacity value as importance criterion. Voxels with an associated opacity value greater than α thres = 0.03 were marked as relevant.</p><p>The datasets I and II are confocal microscopy images of neurons inside a honey bee's brain. About 0.1% respectively 0.2% voxels were marked as rele vant and the volumes were rendered with 1.200 slices. For dataset II a greater threshold of α thres = 0.1 was used, in order to eliminate noise contained in the microscopy image.</p><p>Dataset III represents a part of a human vascular tree. Here 1.2% voxels were tagged as relevant. This dataset also was rendered with 1200 slices.</p><p>Example IV contains data from a molecular dynamics simulation and conformational analysis. About 4% of voxels were marked as relevant. The volume was rendered with 320 slices. This is the only dataset which fitted into memory without bricking, i.e. in the standard volume rendering approach the frame rate was dominated by the fill rate.</p><p>The last example is a non sparse datatset containing 23% of relevant voxels, which was rendered with 900 slices.</p><p>Images of the different datasets are shown in Figure <ref type="figure" target="#fig_7">10</ref> to Figure <ref type="figure" target="#fig_11">14</ref>. The left image of each figure shows an example volume rendering, the images in the middle depict the bounding boxes of the AMR hierarchy, and the right images display the octree bounding boxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experimental Results</head><p>The statistics are shown in Tables <ref type="table" target="#tab_4">1 to 5</ref>. For each dataset we list the results for standard volume rendering, for the octree and the AMR approach. The first rows ('Standard') show the results for the standard volume rendering approach. Rows labeled 'Octree I' contain the octree result with leaf dimensions that result in optimal frame rates. The ratio threshold was set to 1. Rows labeled 'Octree II' show the best octree results we achieved, by adjusting the ratio threshold parameters. For the definition of these parameters see section 3.2.</p><p>The fourth rows ('AMR I') display AMR results with the clusterer's efficiency parameter set to 0.85 and a minimal extension bound of 15. The last rows, labeled 'AMR II', report the optimal results achieved by adjusting these parameters for each dataset. For datasets I and II the entries for 'AMR I' and 'AMR II' are identical because the parameters mentioned abouve already were optimal for these examples.</p><p>The tables' columns list the number of created texture bricks, the percentage of the data volume covered by them, the amount of texture memory (after extension to the next power of 2 and packing them into one texture in the AMR case), the preprocessing times, the number of levels of the hierarchies and finally the frame rates. On the InfiniteReality2 the texelsize is 2, so the internal size of the textures is twice the number given in the table.</p><p>Note that for the datasets I,II,III and IV the volume entries for the standard case give values greater than 100%, because the bricks share a common row of voxels at their boundaries. For the standard approch the preprocessing times are just given by the times to allocate and define the texture or textures (in cases where bricking is necessary). The preprocessing times for the AMR hierarchies are split into the part needed for the resampling and a second part for clustering and packing. Note that only the clustering and packing step has to be updated, when the colormap is changed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>We presented an algorithm that accelerates the rendering of large datasets. The AMR approach achieves a good balance between the number of boxes needed for tightly capturing the relevant voxels of the data volume and the number of covered non-relevant ones. We compared our approach with the results of an octree based spatial subdivision. The number of created texture bricks is much smaller than the bricks created by the corresponding octree hierarchy, see Figures <ref type="figure" target="#fig_3">1 to 5</ref>. Thus for the sparse datasets the AMR approach achieved significant performance gains. The frame rates for the standard and optimal parameter settings in the AMR cases are similar for all data sets. This shows that the standard setting usually yields good performance and hence almost no user interaction is necessary for finding optimal rendering parameters.</p><p>In contrast, the optimal parameter settings for the octree based algorithm vary strongly for the different datasets and are therefore difficult to determine for a given dataset.</p><p>We reduced the additional amount of texture memory caused by the power of 2 restrictions of OpenGL (respectively the graphics hardware), by packing several bricks into one bigger texture. For the datasets I, II and III the best AMR results needed less texture memory compared to the best octree results. For dataset IV the size was almost equal. For the non-sparse dataset V the amount was twice as high as for the octree case.</p><p>So the AMR-based algorithm yields best results for sparse and large data sets and in this case has clear advantages compared to the octree-based one with regard to the frame rates, as well as to the amount of required texture memory. Even for the non-sparse data set V the AMR-based algorithm achieves frame rates comparable to those of the octree based algorithm.</p><p>7 Future Work</p><p>In order be forearmed for the large scale simulations and huge image data sets expected for the future we will optimize the texture packing approach. Furthermore we will examine the use of better packing algorithms, for example those similar to the one presented in <ref type="bibr" target="#b18">[21]</ref>. It would also be interesting to test other cluster algorithms and compare the preprocessing times and qualities of the resulting hierarchies.</p><p>Currently we are extending our algorithm for rendering data sets from AMR simulation, i.e. where an AMR hierarchy has already been established by the numerical solver. Here other requirements have to be considered, e.g. not refined areas have to be partitioned without introducing cycles. And one has to deal with the problem of opacity corrections and artifacts on the boundaries of grids with different levels of resolution.     </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: 2D example of an AMR grid hierarchy. Root grid A has one subgrid B, which again has two children (C, D).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Creating the pyramidal structure. The bottom line shows the original data samples (on a 2D grid). The rows above indicate the min-max-layers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: Pseudo code for creating the AMR hierarchy via clustering.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Subbranch of the octree: ratio of volume of leaf nodes B and D and the root A is 1 5 6 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: 2D example of the next-fit-decreasing-height packing heuristic: subvolumes are inserted from left to right, starting at the lower left corner.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: A 3D example of axis-aligned bounding boxes, that form a cycle from the considered viewpoint.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>4 IFigure 8 :</head><label>48</label><figDesc>Figure 8: Computing the interval of slices intersecting an brick by projecting its corners onto the slices' normal direction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Dataset I, bee brain neuron, left: standard, middle: AMR, right: octree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Dataset II: bee brain neuron, left: standard, middle: AMR, right: octree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Dataset III: vascular tree, left: standard, middle: AMR, right: octree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Dataset IV: molecule conformation, left: standard, middle: AMR, right: octree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Dataset V: bee brain, left: standard, middle: AMR, right: octree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Dataset II: Neurons inside a bee brain, containing 566 × 990 × 200 voxels and rendered with 1200 slices.</figDesc><table><row><cell></cell><cell cols="3">levels bricks volume</cell><cell>texsize</cell><cell>preproc.</cell><cell>fps</cell></row><row><cell>standard</cell><cell>1</cell><cell>7</cell><cell cols="2">103.0% 208.0 MB</cell><cell>8.1s</cell><cell>0.1</cell></row><row><cell>Octree I</cell><cell>8</cell><cell>1503</cell><cell>2.9%</cell><cell>3.1 MB</cell><cell>6.5s</cell><cell>10.2</cell></row><row><cell>Octree II</cell><cell>8</cell><cell>615</cell><cell>3.6%</cell><cell>5.1 MB</cell><cell>17.3s</cell><cell>13.1</cell></row><row><cell>AMR I</cell><cell>4</cell><cell>333</cell><cell>0.8%</cell><cell>2.0 MB</cell><cell cols="2">21.3s+2.7s 28.6</cell></row><row><cell>AMR II</cell><cell>4</cell><cell>333</cell><cell>0.8%</cell><cell>2.0 MB</cell><cell cols="2">21.3s+2.7s 28.6</cell></row><row><cell cols="7">Table 1: Dataset I: Neurons inside a bee brain, containing 654×993×200 voxels</cell></row><row><cell cols="3">and rendered with 1200 slices.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="3">levels bricks volume</cell><cell>texsize</cell><cell>preproc.</cell><cell>fps</cell></row><row><cell>standard</cell><cell>1</cell><cell>7</cell><cell cols="2">103.0% 208.0 MB</cell><cell>8.0s</cell><cell>0.1</cell></row><row><cell>Octree I</cell><cell>8</cell><cell>1786</cell><cell>3.4%</cell><cell>3.7 MB</cell><cell>17.2s</cell><cell>8.2</cell></row><row><cell>Octree II</cell><cell>8</cell><cell>857</cell><cell>5.3%</cell><cell>6.4 MB</cell><cell>15.1s</cell><cell>11.8</cell></row><row><cell>AMR I</cell><cell>4</cell><cell>417</cell><cell>1.4%</cell><cell>4.0 MB</cell><cell cols="2">19.5s+4.6s 24.6</cell></row><row><cell>AMR II</cell><cell>4</cell><cell>417</cell><cell>1.4%</cell><cell>4.0 MB</cell><cell cols="2">19.5s+4.6s 24.6</cell></row><row><cell></cell><cell cols="3">levels bricks volume</cell><cell>texsize</cell><cell>preproc.</cell><cell>fps</cell></row><row><cell>standard</cell><cell>1</cell><cell>23</cell><cell cols="2">103.1% 736.0 MB</cell><cell>13.3s</cell><cell>0.1</cell></row><row><cell>Octree I</cell><cell>7</cell><cell>3277</cell><cell>7.7%</cell><cell>15.9 MB</cell><cell>34.6s</cell><cell>3.2</cell></row><row><cell>Octree II</cell><cell>7</cell><cell>1907</cell><cell>8.7%</cell><cell>19.0 MB</cell><cell>11.7s</cell><cell>3.9</cell></row><row><cell>AMR I</cell><cell>5</cell><cell>1388</cell><cell>4.3%</cell><cell cols="3">16.0 MB 34.4s+13.9s 6.3</cell></row><row><cell>AMR II</cell><cell>5</cell><cell>1525</cell><cell>3.9%</cell><cell cols="3">16.0 MB 34.4s+13.5s 6.5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Dataset III: Vascular tree, containing 528 × 574 × 700 voxels and rendered with 1200 slices.</figDesc><table><row><cell></cell><cell cols="4">levels bricks volume texsize</cell><cell>preproc.</cell><cell>fps</cell></row><row><cell>standard</cell><cell>1</cell><cell>1</cell><cell cols="2">100.0% 16.0 MB</cell><cell>0.5s</cell><cell>3.5</cell></row><row><cell>Octree I</cell><cell>8</cell><cell>652</cell><cell>8.9%</cell><cell>0.6 MB</cell><cell>4.1s</cell><cell>13.7</cell></row><row><cell>Octree II</cell><cell>8</cell><cell>587</cell><cell>7.9%</cell><cell>0.9 MB</cell><cell>6.1s</cell><cell>15.6</cell></row><row><cell>AMR I</cell><cell>4</cell><cell>61</cell><cell>8.8%</cell><cell cols="3">1.0 MB 0.9s + 0.7s 14.3</cell></row><row><cell>AMR II</cell><cell>4</cell><cell>333</cell><cell>6.9%</cell><cell cols="3">1.0 MB 0.9s + 0.8s 16.7</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Dataset IV: Molecular conformation dataset, containing 185×202×157 voxels and rendered with 320 slices.</figDesc><table><row><cell></cell><cell cols="4">levels bricks volume texsize</cell><cell>preproc.</cell><cell>fps</cell></row><row><cell>standard</cell><cell>1</cell><cell>2</cell><cell cols="2">101.0% 64.0 MB</cell><cell>2.0s</cell><cell>0.4</cell></row><row><cell>Octree I</cell><cell>7</cell><cell>2947</cell><cell>37.6%</cell><cell>14.5 MB</cell><cell>11.0s</cell><cell>3.7</cell></row><row><cell>Octree II</cell><cell>7</cell><cell>1814</cell><cell>37.0%</cell><cell>15.0 MB</cell><cell>7.2s</cell><cell>4.5</cell></row><row><cell>AMR I</cell><cell>3</cell><cell>619</cell><cell>32.1%</cell><cell cols="3">32.0 MB 6.1s + 11.4s 4.5</cell></row><row><cell>AMR II</cell><cell>3</cell><cell>501</cell><cell>35.0%</cell><cell cols="3">32.0 MB 6.1s + 13.2s 4.7</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Dataset V: Bee brain dataset, containing 749 × 495 × 100 voxels and rendered with 900 slices.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Acknowledgments</head><p>We thank Malte Z¨ockler for the idea and implementation of the intersection algorithm based on a lookup-table, that was sketched in subsection 4.1.2 and Johannes Schmidt-Ehrenberg, Detlev Stalling, Malte Z¨ockler and Werner Benger for proof reading and fruitful discussions respectively.</p><p>The single neuron and bee brain datasets where provided by Robert Brandt (research group Randolf Menzel, Freie Universit¨at Berlin), the vascular tree dataset by Thomas Lange (research group Peter Schlag, Robert-R¨ossle-Klinik and Unversit¨atsklinikum Charit´e, Berlin) and the molecular dataset by Johannes Schmidt-Ehrenberg, Daniel Baum, and Frank Cordes (ZIB). This work was supported in part by the Max-Planck-Institut fu¨r Gravitationsphysik (Albert-Einstein-Institut) in Potsdam/Germany.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.amiravis.com" />
		<title level="m">Amira User&apos;s Guide and Reference Manual as well as Amira Programmer&apos;s Guide. Konrad-Zuse-Zentrum fu¨r Informationstechnik Berlin (ZIB) and Indeed -Visual Concepts GmbH</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An algorithm for perspective viewing of objects represented by octrees</title>
		<author>
			<persName><forename type="first">G</forename><surname>Walid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hanan</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><surname>Samet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="59" to="66" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Local adaptive mesh refinement for shock hydrodynamics</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Collela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Computational Physics</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="84" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An algorithm for point clustering and grid generation</title>
		<author>
			<persName><forename type="first">Marsha</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Isidore</forename><surname>Rigoutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Accelerated volume rendering and tomographic reconstruction using texture mapping hardware</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cabral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Cam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Foran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1994 Symposium on Volume Visualization</title>
		<editor>
			<persName><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Wolfgang</forename><surname>Krueger</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Proximity clouds: An acceleration technique for 3D grid traversal. The Visual Computer</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Sheffer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Accelerating volume reconstruction with 3D texture mapping hardware</title>
		<author>
			<persName><forename type="first">T</forename><surname>Cullip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Neumann</surname></persName>
		</author>
		<idno>TR93-027</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
			<pubPlace>Chapel Hill</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science at the University of North Carolina</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report Technical Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast algorithms for volume ray tracing</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">M</forename><surname>Danskin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Volume Visualization</title>
		<imprint>
			<date type="published" when="1992-10">October 1992</date>
			<biblScope unit="page" from="91" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Volume rendering</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Loren</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (Proceedings of SIGGRAPH 88)</title>
		<meeting><address><addrLine>Atlanta, Georgia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-08">August 1988</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Performance bounds for level-oriented two dimensional packing algorithms</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Coffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="808" to="826" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Multiresolution volume visualization with a texture-based octree</title>
		<author>
			<persName><forename type="first">R</forename><surname>Scopigno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Boada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Navazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="185" to="197" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Ray tracing volume densities</title>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">T</forename><surname>Kajiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">P</forename><surname>Von Herzen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 84)</title>
		<meeting>SIGGRAPH 84)<address><addrLine>Minneapolis, Minnesota</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984-07">July 1984</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="165" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Efficient encoding and rendering of time-varying volume data</title>
		<author>
			<persName><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diann</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming-Yun</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
		</author>
		<idno>No. 98-22 (NASA CR-1998-208424</idno>
		<imprint>
			<date type="published" when="1998-06">June 1998</date>
			<publisher>NASA Langley Research Center</publisher>
			<pubPlace>Hampton, VA.</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Institute for Computer Applications in Science and Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">ICASE Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multiresolution techniques for interactive texture-based volume visualization</title>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">C</forename><surname>Lamar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Ebert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Markus</forename><surname>Gross</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
		</editor>
		<meeting><address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="355" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Hierarchical splatting: A progressive refinement algorithm for volume rendering</title>
		<author>
			<persName><forename type="first">David</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 91)</title>
		<meeting>SIGGRAPH 91)<address><addrLine>Las Vegas, Nevada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-07">July 1991</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="285" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Fast volume rendering using adaptive block subdivision. Pacific Graphics &apos;97</title>
		<author>
			<persName><forename type="first">Choong</forename><surname>Hwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Kyo</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Park</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997-10">October 1997</date>
			<publisher>Korea</publisher>
		</imprint>
	</monogr>
	<note>Held in Seoul</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Display of surfaces from volume data</title>
		<author>
			<persName><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics &amp; Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05">May 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient ray tracing of volume data</title>
		<author>
			<persName><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="261" />
			<date type="published" when="1990-07">July 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On three-dimensional packing</title>
		<author>
			<persName><forename type="first">Keqin</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kam-Hoi</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="847" to="867" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast wavelet based volume rendering by accumulation of transparent texture maps</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lippert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="431" to="444" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
		</author>
		<title level="m">Parallel rendering of 3d amr data on the sgi/cray t3e. Proc. 7th Symposium on Frontiers of Massively Parallel Computation</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="138" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Rendering by template-based octree projection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Eurographics Workshop on Visualization in Scientific Computing</title>
		<meeting>the 8th Eurographics Workshop on Visualization in Scientific Computing</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="155" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A fast volume rendering algorithm for time-varying fields using a time-space partitioning (TSP) tree</title>
		<author>
			<persName><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ling-Jan</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;99</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Ebert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Markus</forename><surname>Gross</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
		</editor>
		<meeting><address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="371" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Accelerating timevarying hardware volume rendering using TSP trees and color-based error metrics</title>
		<author>
			<persName><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Ellsworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ling-Jen</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization and Graphics Symposium</title>
		<meeting><address><addrLine>Salt Lake City, UT</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000. 2000</date>
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Applying space subdivision techniques to volume rendering</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">S</forename><surname>Fussel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;90</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="150" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Efficiently rendering large volume data using texture mapping hardware. Joint EUROGRAPHICS -IEEE TCVG Symposium on Visualization</title>
		<author>
			<persName><forename type="first">X</forename><surname>Tong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tsang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Tang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-05">May 1999</date>
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Visualization of adaptive mesh refinement data</title>
		<author>
			<persName><forename type="first">Gunther</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kenneth</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Terry</forename><forename type="middle">J</forename><surname>Ligocki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kwan-Liu</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Shalf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IS&amp;T/SPIE Electronic Imaging</title>
		<meeting>IS&amp;T/SPIE Electronic Imaging</meeting>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Levelof-detail volume rendering via 3D textures</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weiler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zimmerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Volume Visualization and Graphics Symposium</title>
		<imprint>
			<date type="published" when="1994">2000. 1994</date>
			<biblScope unit="page" from="7" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A multiresolution framework for volume rendering</title>
		<author>
			<persName><forename type="first">Ru¨diger</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Volume Visualization</title>
		<imprint>
			<date type="published" when="1994-10">1994. October 1994</date>
			<biblScope unit="page" from="51" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Footprint evaluation for volume rendering</title>
		<author>
			<persName><forename type="first">Lee</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH 90)</title>
		<meeting>SIGGRAPH 90)<address><addrLine>Dallas, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-08">August 1990</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="367" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Multi-dimensional trees for controlled volume rendering and compression</title>
		<author>
			<persName><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Allen</forename><surname>Van Gelder</surname></persName>
		</author>
		<idno>UCSC-CRL- 94-02</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Santa Cruz</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Direct volume rendering via 3D textures</title>
		<author>
			<persName><forename type="first">Orion</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Allen</forename><surname>Vangelder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
		<idno>UCSC-CRL-94-19</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Santa Cruz</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Acceleration of ray-casting using 3d distance transforms</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zuiderveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Koning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viergever</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization in Biomedical Computing, Proceedings of VBC&apos;92</title>
		<imprint>
			<publisher>SPIE</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="324" to="335" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
