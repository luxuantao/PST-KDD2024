<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Weak Memory Models: Balancing Definitional Simplicity and Implementation Flexibility</title>
				<funder ref="#_97vV33y">
					<orgName type="full">DARPA BRASS Program</orgName>
				</funder>
				<funder ref="#_3DYq6dg">
					<orgName type="full">unknown</orgName>
				</funder>
				<funder ref="#_weKHkSJ">
					<orgName type="full">POWER Complex</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Sizhuo</forename><surname>Zhang</surname></persName>
							<email>szzhang@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Artificial Intelligence Laboratory Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Muralidaran</forename><surname>Vijayaraghavan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Artificial Intelligence Laboratory Massachusetts Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Weak Memory Models: Balancing Definitional Simplicity and Implementation Flexibility</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/PACT.2017.29</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>weak memory model Definition Model properties / Implementation flexibility Operational model</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The memory model for RISC-V, a newly developed open source ISA, has not been finalized yet and thus, offers an opportunity to evaluate existing memory models. We believe RISC-V should not adopt the memory models of POWER or ARM, because their axiomatic and operational definitions are too complicated. We propose two new weak memory models: WMM and WMM-S, which balance definitional simplicity and implementation flexibility differently. Both allow all instruction reorderings except overtaking of loads by a store. We show that this restriction has little impact on performance and it considerably simplifies operational definitions. It also rules out the out-of-thin-air problem that plagues many definitions. WMM is simple (it is similar to the Alpha memory model), but it disallows behaviors arising due to shared store buffers and shared write-through caches (which are seen in POWER processors). WMM-S, on the other hand, is more complex and allows these behaviors. We give the operational definitions of both models using Instantaneous Instruction Execution (I 2 E), which has been used in the definitions of SC and TSO. We also show how both models can be implemented using conventional cache-coherent memory systems and out-of-order processors, and encompasses the behaviors of most known optimizations.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>A memory model for an ISA is the specification of all legal multithreaded program behaviors. If microarchitectural changes conform to the memory model, software remains compatible. Leaving the meanings of corner cases to be implementation dependent makes the task of proving the correctness of multithreaded programs, microarchitectures and cache protocols untenable. While strong memory models like SC and SPARC/Intel-TSO are well understood, weak memory models of commercial ISAs like ARM and POWER are driven too much by microarchitectural details, and inadequately documented by manufacturers. For example, the memory model in the POWER ISA manual <ref type="bibr" target="#b10">[11]</ref> is "defined" as reorderings of events, and an event refers to performing an instruction with respect to a processor. While reorderings capture some properties of memory models, it does not specify the result of each load, which is the most important information to understand program behaviors. This forces the researchers to formalize these weak memory models by empirically determining the allowed/disallowed behaviors of commercial processors and then constructing models to fit these observations <ref type="bibr" target="#b6">[7]</ref>- <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b11">[12]</ref>- <ref type="bibr" target="#b15">[16]</ref>.</p><p>The newly designed open-source RISC-V ISA <ref type="bibr" target="#b16">[17]</ref> offers a unique opportunity to reverse this trend by giving a clear definition with understandable implications for implementations. The RISC-V ISA manual only states that its memory model is weak in the sense that it allows a variety of instruction reorderings <ref type="bibr" target="#b17">[18]</ref>. However, so far no detailed definition has been provided, and the memory model is not fixed yet.</p><p>In this paper we propose two weak memory models for RISC-V: WMM and WMM-S, which balance definitional simplicity and implementation flexibility differently. The difference between the two models is regarding store atomicity, which is often classified into the following three types <ref type="bibr" target="#b18">[19]</ref>:</p><p>? Single-copy atomic: a store becomes visible to all processors at the same time, e.g., in SC. ? Multi-copy atomic: a store becomes visible to the issuing processor before it is advertised simultaneously to all other processors, e.g., in TSO and Alpha <ref type="bibr" target="#b4">[5]</ref>. ? Non-atomic (or non-multi-copy-atomic): a store becomes visible to different processors at different times, e.g., in POWER and ARM.</p><p>Multi-copy atomic stores are caused by the store buffer or write-through cache that is private to each processor. Non-atomic stores arise (mostly) because of the sharing of a store buffer or a write-through cache by multiple processors, and such stores considerably complicate the formal definitions <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. WMM is an Alpha-like memory model which permits only multi-copy atomic stores and thus, prohibits shared store buffers or shared write-through caches in implementations. WMM-S is an ARM/POWERlike memory model which admits non-atomic stores. We will present the implementations of both models using out-oforder (OOO) processors and cache-coherent memory systems.</p><p>In particular, WMM and WMM-S allow the OOO processors in multicore settings to use all speculative techniques which are valid for uniprocessors, including even the load-value speculation <ref type="bibr" target="#b19">[20]</ref>- <ref type="bibr" target="#b23">[24]</ref>, without additional checks or logic. We give operational definitions of both WMM and WMM-S. An operational definition specifies an abstract machine, and the legal behaviors of a program under the memory Figure <ref type="figure">1</ref>. Summary of different memory models model are those that can result by running the program on the abstract machine. We observe a growing interest in operational definitions: memory models of x86, ARM and POWER have all been formalized operationally <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b24">[25]</ref>, and researchers are even seeking operational definitions for high-level languages like C++ <ref type="bibr" target="#b25">[26]</ref>. This is perhaps because all possible program results can be derived from operational definitions mechanically while axiomatic definitions require guessing the whole program execution at the beginning. For complex programs with dependencies, loops and conditional branches, guessing the whole execution may become prohibitive.</p><p>Unfortunately, the operational models of ARM and POWER are too complicated because their abstract machines involve microarchitectural details like reorder buffers (ROBs), partial and speculative instruction execution, instruction replay on speculation failure, etc. The operational definitions of WMM and WMM-S are much simpler because they are described in terms of Instantaneous Instruction Execution (I 2 E), which is the style used in the operational definitions of SC <ref type="bibr" target="#b0">[1]</ref> and TSO <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b24">[25]</ref>. An I 2 E abstract machine consists of n atomic processors and an n-ported atomic memory. The atomic processor executes instructions instantaneously and in order, so it always has the up-to-date architectural (register) state. The atomic memory executes loads and stores instantaneously. Instruction reorderings and store atomicity/non-atomicity are captured by including different types of buffers between the processors and the atomic memory, like the store buffer in the definition of TSO. In the background, data moves between these buffers and the memory asynchronously, e.g., to drain a value from a store buffer to the memory.</p><p>I 2 E definitions free programmers from reasoning partially executed instructions, which is unavoidable for ARM and POWER operational definitions. One key tradeoff to achieve I 2 E is to forbid a store to overtake a load, i.e., disallow Ld-St reordering. Allowing such reordering requires each processor in the abstract machine to maintain multiple unexecuted instructions in order to see the effects of future stores, and the abstract machine has to contain the complicated ROBlike structures. Ld-St reordering also complicates axiomatic definitions because it creates the possibility of "out-ofthin-air" behaviors <ref type="bibr" target="#b26">[27]</ref>, which are impossible in any real implementation and consequently must be disallowed. We also offer evidence, based on simulation experiments, that disallowing Ld-St reordering has no discernible impact on performance.</p><p>For a quick comparison, we summarize the properties of common memory models in Figure <ref type="figure">1</ref>. SC and TSO have simple definitions but forbid Ld-Ld and St-St reorderings, and consequently, are not candidates for RISC-V. WMM is similar to RMO and Alpha but neither has an operational definition. Also WMM has a simple axiomatic definition, while Alpha requires a complicated axiom to forbid outof-thin-air behaviors (see Section V-B), and RMO has an incorrect axiom about data-dependency ordering (see Section X).</p><p>ARM, POWER, and WMM-S are similar models in the sense that they all admit non-atomic stores. While the operational models of ARM and POWER are complicated, WMM-S has a simpler I 2 E definition and allows competitive implementations (see Section IX-B). The axiomatic models of ARM and POWER are also complicated: four relations in the POWER axiomatic model <ref type="bibr" target="#b9">[10,</ref><ref type="bibr">Section 6]</ref> are defined in a fixed point manner, i.e., their definitions mutually depend on each other.</p><p>Release Consistency (RC) are often mixed with the concept of "SC for data-race-free (DRF) programs" <ref type="bibr" target="#b27">[28]</ref>. It should be noted that "SC for DRF" is inadequate for an ISA memory model, which must specify behaviors of all programs. The original RC definition <ref type="bibr" target="#b5">[6]</ref> attempts to specify all program behaviors, and are more complex and subtle than the "SC for DRF" concept. We show in Section X that the RC definition fails a litmus test for non-atomic stores and forbids shared write-through caches in implementation.</p><p>This paper makes the following contributions: 1) WMM, the first weak memory model that is defined in I 2 E and allows Ld-Ld reordering, and its axiomatic definition; 2) WMM-S, an extension on WMM that admits non-atomic stores and has an I 2 E definition; 3) WMM and WMM-S implementations based on OOO pro-cessors that admit all uniprocessor speculative techniques (such as load-value prediction) without additional checks; 4) Introduction of invalidation buffers in the I 2 E definitional framework to model Ld-Ld and other reorderings. Paper organization: Section II presents the related work. Section III gives litmus tests for distinguishing memory models. Section IV introduces I 2 E. Section V defines WMM. Section VI shows the WMM implementation using OOO processors. Section VII evaluates the performance of WMM and the influence of forbidding Ld-St reordering. Section VIII defines WMM-S. Section IX presents the WMM-S implementations with non-atomic stores. Section X shows the problems of RC and RMO. Section XI offers the conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>SC <ref type="bibr" target="#b0">[1]</ref> is the simplest model, but naive implementations of SC suffer from poor performance. Although researchers have proposed aggressive techniques to preserve SC <ref type="bibr" target="#b28">[29]</ref>- <ref type="bibr" target="#b37">[38]</ref>, they are rarely adopted in commercial processors perhaps due to their hardware complexity. Instead the manufactures and researchers have chosen to present weaker memory models, e.g., TSO <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b38">[39]</ref>, PSO <ref type="bibr" target="#b3">[4]</ref>, RMO <ref type="bibr" target="#b3">[4]</ref>, Alpha <ref type="bibr" target="#b4">[5]</ref>, Processor Consistency <ref type="bibr" target="#b39">[40]</ref>, Weak Consistency <ref type="bibr" target="#b40">[41]</ref>, RC <ref type="bibr" target="#b5">[6]</ref>, CRF <ref type="bibr" target="#b41">[42]</ref>, Instruction Reordering + Store Atomicity <ref type="bibr" target="#b42">[43]</ref>, POWER <ref type="bibr" target="#b10">[11]</ref> and ARM <ref type="bibr" target="#b43">[44]</ref>. The tutorials by Adve et al. <ref type="bibr" target="#b44">[45]</ref> and by Maranget et al. <ref type="bibr" target="#b45">[46]</ref> provide relationships among some of these models.</p><p>A large amount of research has also been devoted to specifying the memory models of high-level languages: C++ <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b46">[47]</ref>- <ref type="bibr" target="#b49">[50]</ref>, Java <ref type="bibr" target="#b50">[51]</ref>- <ref type="bibr" target="#b52">[53]</ref>, etc. We will provide compilation schemes from C++ to WMM and WMM-S.</p><p>Recently, Lustig et al. have used Memory Ordering Specification Tables (MOSTs) to describe memory models, and proposed a hardware scheme to dynamically convert programs across memory models described in MOSTs <ref type="bibr" target="#b18">[19]</ref>. MOST specifies the ordering strength (e.g., locally ordered, multi-copy atomic) of two instructions from the same processor under different conditions (e.g., data dependency, control dependency). Our work is orthogonal in that we propose new memory models with operational definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MEMORY MODEL LITMUS TESTS</head><p>Here we offer two sets of litmus tests to highlight the differences between memory models regarding store atomicity and instruction reorderings, including enforcement of dependency-ordering. All memory locations are initialized to 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Store Atomicity Litmus Tests</head><p>Figure <ref type="figure" target="#fig_1">2</ref> shows four litmus tests to distinguish between these three types of stores. We have deliberately added data dependencies and Ld-Ld fences (FENCE LL ) to these litmus tests to prevent instruction reordering, e.g., the data dependency between I 2 and I 3 in Figure <ref type="figure" target="#fig_1">2a</ref>. Thus the resulting behaviors can arise only because of different store atomicity properties. We use FENCE LL for memory models that can reorder data-dependent loads, e.g., I 5 in Figure <ref type="figure" target="#fig_1">2b</ref> would be the MB fence for Alpha. For other memory models that order data-dependent loads (e.g., ARM), FENCE LL could be replaced by a data dependency (like the data dependency between I 2 and I 3 in Figure <ref type="figure" target="#fig_1">2a</ref>). The Ld-Ld fences only stop Ld-Ld reordering; they do not affect store atomicity in these tests.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SBE:</head><p>In a machine with single-copy atomic stores (e.g., an SC machine), when both I 2 and I 5 have returned value 1, stores I 1 and I 4 must have been globally advertised. Thus r 2 and r 4 cannot both be 0. However, a machine with store buffers (e.g., a TSO machine) allows P1 to forward the value of I 1 to I 2 locally without advertising I 1 to other processors, violating the single-copy atomicity of stores. WRC: Assuming the store buffer is private to each processor (i.e., multi-copy atomic stores), if one observes r 1 = 2 and r 2 = 1 then r 3 must be 2. However, if an architecture allows a store buffer to be shared by P1 and P2 but not P3, then P2 can see the value of I 1 from the shared store buffer before I 1 has updated the memory, allowing P3 to still see the old value of a. A write-through cache shared by P1 and P2 but not P3 can cause this non-atomic store behavior in a similar way, e.g., I 1 updates the shared write-through cache but has not invalidated the copy in the private cache of P3 before I 6 is executed. WWC: This litmus test is similar to WRC but replaces the load in I 6 with a store. The behavior is possible if P1 and P2 share a write-through cache or store buffer. However, RC forbids this behavior (see Section X). IRIW: This behavior is possible if P1 and P2 share a writethrough cache or a store buffer and so do P3 and P4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Instruction Reordering Litmus Tests</head><p>Although processors fetch and commit instructions in order, speculative and out-of-order execution causes behaviors as if instructions were reordered. Figure <ref type="figure">3</ref> shows the litmus tests on these reordering behaviors. are buffered in the store buffers. The resulting behavior is as if the store and the load were reordered on each processor. MP: In an Alpha machine, I 1 and I 2 may be drained from the store buffer of P1 out of order; I 3 and I 4 in the ROB of P2 may be executed out of order. This is as if P1 reordered the two stores and P2 reordered the two loads. LB: Some machines may enter a store into the memory before all older instructions have been committed. This results in the Ld-St reordering shown in Figure <ref type="figure">3c</ref>. Since instructions are committed in order and stores are usually not on the critical path, the benefit of the eager execution of stores is limited. In fact we will show by simulation that Ld-St reordering does not improve performance (Section VII). MP+Ctrl: This test is a variant of MP. The two stores in P1 must update memory in order due to the fence. Although the execution of I 6 is conditional on the result of I 4 , P2 can issue I 6 speculatively by predicting branch I 5 to be not taken. The execution order I 6 , I 1 , I 2 , I 3 , I 4 , I 5 results in r 1 = 1 and r 2 = 0. MP+Mem: This test replaces the control dependency in MP+Ctrl with a (potential) memory dependency, i.e., the unresolved store address of I 5 may be the same as the load address of I 6 before I 4 is executed, However, P2 can execute I 6 speculatively by predicting the addresses are not the same. This results in having I 6 overtake I 4 and I 5 . MP+Data: This test replaces the control dependency in MP+Ctrl with a data dependency, i.e., the load address of I 5 depends on the result of I 4 . A processor with loadvalue prediction <ref type="bibr" target="#b19">[20]</ref>- <ref type="bibr" target="#b23">[24]</ref> may guess the result of I 4 before executing it, and issue I 5 speculatively. If the guess fails to match the real execution result of I 4 , then I 5 would be killed. But, if the guess is right, then essentially the execution of the two data-dependent loads (I 4 and I 5 ) has been reordered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Miscellaneous Tests</head><p>All programmers expect memory models to obey perlocation SC <ref type="bibr" target="#b54">[55]</ref>, i.e., all accesses to a single address appear to execute in a sequential order which is consistent with the program order of each thread (Figure <ref type="figure">4</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proc. P1</head><p>Proc. P2 Out-of-thin-air behaviors (Figure <ref type="figure" target="#fig_3">5</ref>) are impossible in real implementations. Sometimes such behaviors are permitted by axiomatic models due to incomplete axiomatization.</p><formula xml:id="formula_0">I 1 : r 1 = Ld a I 3 : St a 1 I 2 : r 2 = Ld a Models with per-location SC forbid: r 1 = 1, r 2 = 0 Figure 4. Per-location SC Proc. P1 Proc. P2 I 1 : r 1 = Ld b I 3 : r 2 = Ld a I 2 : St a r 1 I 4 : St b r 2 All models forbid: r 1 = r 2 = 42</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DEFINING MEMORY MODELS IN I 2 E</head><p>Figure <ref type="figure" target="#fig_4">6</ref> shows the I 2 E abstract machines for SC, TSO/PSO and WMM models. All abstract machines consist of n atomic processors and an n-ported atomic memory m. Each processor contains a register state s, which represents all architectural registers, including both the general purpose registers and special purpose registers, such as PC. The abstract machines for TSO/PSO and WMM also contain a store buffer sb for each processor, and the one for WMM also contains an invalidation buffer ib for each processor as shown in the figure. In the abstract machines all buffers are unbounded. The operations of these buffers will be explained shortly.</p><p>The operations of the SC abstract machine are the simplest: in one step we can select any processor to execute the next instruction on that processor atomically. That is, if the instruction is a non-memory instruction (e.g., ALU or branch), it just modifies the register states of the processor; if it is a load, it reads from the atomic memory instantaneously and updates the register state; and if it is a store, it updates the atomic memory instantaneously and increments the PC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. TSO Model</head><p>The TSO abstract machine proposed in <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b24">[25]</ref> (Figure <ref type="figure" target="#fig_4">6b</ref>) contains a store buffer sb for each processor. Just like SC, any processor can execute an instruction atomically, and if the instruction is a non-memory instruction, it just modifies the local register state. A store is executed by inserting its address, value pair into the local sb instead of writing the data in memory. A load first looks for the load address in the local sb and returns the value of the youngest store for that address. If the address is not in the local sb, then the load returns the value from the atomic memory. TSO can also perform a background operation, which removes the oldest store from a sb and writes it into the atomic memory. As we discussed in Section III, store buffer allows TSO to do St-Ld reordering, i.e., pass the SB litmus test (Figure <ref type="figure">3a</ref>).</p><p>In order to enforce ordering in accessing the memory and to rule out non-SC behaviors, TSO has a fence instruction, which we refer to as Commit. When a processor executes a Commit fence, it gets blocked unless its sb is empty. Eventually, any sb will become empty as a consequence of the background operations that move data from the sb to the memory. For example, we need to insert a Commit fence after each store in Figure <ref type="figure">3a</ref> to forbid the non-SC behavior in TSO.</p><p>We summarize the operations of the TSO abstract machine in Figure <ref type="figure" target="#fig_5">7</ref>. Each operation consists of a predicate and an action. The operation can be performed by taking the action only when the predicate is true. Each time we perform only one operation (either instruction execution or sb dequeue) atomically in the whole system (e.g., no two processors can execute instructions simultaneously). The choice of which operation to perform is nondeterministic. Enabling St-St reordering: We can extend TSO to PSO by changing the background operation to dequeue the oldest store for any address in sb (see the PSO-DeqSb operation in Figure <ref type="figure" target="#fig_5">7</ref>). This extends TSO by permitting St-St reordering.</p><p>V. WMM MODEL WMM allows Ld-Ld reordering in addition to the reorderings allowed by PSO. Since a reordered load may read a stale PSO-DeqSb (background store buffer dequeue) Predicate: The sb of a processor is not empty. Action: Assume the value of the oldest store for some address a in the sb is v. Then this store is removed from sb, and the atomic memory m[a] is updated to v. value, we introduce a conceptual device called invalidation buffer, ib, for each processor in the I 2 E abstract machine (see Figure <ref type="figure" target="#fig_4">6c</ref>). ib is an unbounded buffer of address, value pairs, each representing a stale memory value for an address that can be observed by the processor. Multiple stale values for an address in ib are kept ordered by their staleness.</p><p>The operations of the WMM abstract machine are similar to those of PSO except for the background operation and the load execution. When the background operation moves a store from sb to the atomic memory, the original value in the atomic memory, i.e., the stale value, enters the ib of every other processor. A load first searches the local sb. If the address is not found in sb, it either reads the value in the atomic memory or any stale value for the address in the local ib, the choice between the two being nondeterministic.</p><p>The abstract machine operations maintain the following invariants: once a processor observes a store, it cannot observe any staler store for that address. Therefore, (1) when a store is executed, values for the store address in the local ib are purged; (2) when a load is executed, values staler than the load result are flushed from the local ib; and (3) the background operation does not insert the stale value into the ib of a processor if the sb of the processor contains the address.</p><p>Just like introducing the Commit fence in TSO, to prevent loads from reading the stale values in ib, we introduce the Reconcile fence to clear the local ib. Figure <ref type="figure" target="#fig_6">8</ref> summarizes the operations of the WMM abstract machine.</p><p>WMM-Nm (non-memory execution): Same as TSO-Nm. WMM-Ld (load execution) Predicate: The next instruction of a processor is a load. Action: Assume the load address is a. If a is present in the sb of the processor, then the load returns the value of the youngest store for a in the local sb. Otherwise, the load is executed in either of the following two ways (the choice is arbitrary):</p><p>1) The load returns the atomic memory value m[a], and all values for a in the local ib are removed.</p><p>2) The load returns some value for a in the local ib, and all values for a older than the load result are removed from the local ib. (If there are multiple values for a in ib, the choice of which one to read is arbitrary). WMM-St (store execution) Predicate: The next instruction of a processor is a store. Action: Assume the store address is a and the store value is v. The processor inserts the store a, v into its sb, and removes all values for a from its ib. WMM-Com (Commit execution): Same as TSO-Com. WMM-Rec (execution of a Reconcile fence) Predicate: The next instruction of a processor is a Reconcile. Action: All values in the ib of the processor are removed. WMM-DeqSb (background store buffer dequeue) Predicate: The sb of a processor is not empty. Action: Assume the value of the oldest store for some address a in the sb is v. First, the stale address, value pair a, m[a] is inserted to the ib of every other processor whose sb does not contain a. Then this store is removed from sb, and m[a] is set to v.  <ref type="figure">3a</ref> and<ref type="figure">3b</ref>). To forbid the behavior in Figure <ref type="figure">3a</ref>, we need to insert a Commit followed by a Reconcile after the store in each processor.</p><p>Reconcile is needed to prevent loads from getting stale values from ib. The I 2 E definition of WMM automatically forbids Ld-St reordering (Figure <ref type="figure">3c</ref>) and out-of-thin-air behaviors (Figure <ref type="figure" target="#fig_3">5</ref>). Ld-Ld reordering: WMM allows the behavior in Figure <ref type="figure">3b</ref> due to St-St reordering. Even if we insert a Commit between the two stores in P1, the behavior is still allowed because I 4 can read the stale value 0 from ib. This is as if the two loads in P2 were reordered. Thus, we also need a Reconcile between the two loads in P2 to forbid this behavior in WMM.</p><p>No dependency ordering: WMM does not enforce any dependency ordering. For example, WMM allows the behaviors of litmus tests in Figures <ref type="figure">3d,</ref><ref type="figure">3e</ref> and 3f (I 2 should be Commit in case of WMM), because the last load in P2 can always get the stale value 0 from ib in each test. Thus, it requires Reconcile fences to enforce dependency ordering in WMM. In particular, WMM can reorder the data-dependent loads (i.e., I 4 and I 5 ) in Figure <ref type="figure">3f</ref>. Multi-copy atomic stores: Stores in WMM are multicopy atomic, and WMM allows the behavior in Figure <ref type="figure" target="#fig_1">2a</ref> even when Reconcile fences are inserted between Ld-Ld pairs I 2 , I 3 and I 5 , I 6 . This is because a store can be read by a load from the same processor while the store is in sb. However, if the store is ever pushed from sb to the atomic memory, it becomes visible to all other processors simultaneously. Thus, WMM forbids the behaviors in Figures <ref type="figure" target="#fig_1">2b, 2c</ref> and<ref type="figure" target="#fig_1">2d</ref> (FENCE LL should be Reconcile in these tests). Per-location SC: WMM enforces per-location SC (Figure <ref type="figure">4</ref>), because both sb and ib enforce FIFO on same address entries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Axiomatic Definition of WMM</head><p>Based on the above properties of WMM, we give a simple axiomatic definition for WMM in Figure <ref type="figure" target="#fig_7">9</ref> in the style of the axiomatic definitions of TSO and Alpha. A True entry in the order-preserving table (Figure <ref type="figure" target="#fig_7">9b</ref>) indicates that if instruction X precedes instruction Y in the program order (X &lt; po Y ) then the order must be maintained in the global memory order (&lt; mo ). &lt; mo is a total order of all the memory and fence instructions from all processors. The notation S rf -? L means a load L reads from a store S. The notation max &lt;mo {set of stores} means the youngest store in the set according to &lt; mo . The axioms are self-explanatory: the program order must be maintained if the order-preserving table says so, and a load must read from the youngest store among all stores that precede the load in either the memory order or the program order. (See the appendix of <ref type="bibr" target="#b55">[56]</ref> for the equivalence proof of the axiomatic and I 2 E definitions.)</p><p>These axioms also hold for Alpha with a slightly different order-preserving table, which marks the (Ld,St) entry as a = b. (Alpha also merges Commit and Reconcile into a single fence). However, allowing Ld-St reordering creates the possibility of out-of-thin-air behaviors, and Alpha uses an additional complicated axiom to disallow such behaviors <ref type="bibr" target="#b4">[5,</ref><ref type="bibr">Chapter 5.6.1.7]</ref>. This axiom requires considering all possible execution paths to determine if a store is ordered after a load by dependency, while normal axiomatic models only examine a single execution path at a time. Allowing Ld-St reordering also makes it difficult to define Alpha operationally.</p><p>Axiom Inst-Order (preserved instruction ordering): </p><formula xml:id="formula_1">X &lt;po Y ? order(X, Y ) ? X &lt;mo Y Axiom Ld-Val (the value of a load): St a v rf -? Ld a ? St a v = max&lt;mo{St a v | St a v &lt;mo Ld a ? St a v &lt;po Ld a}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Compiling C++11 to WMM</head><p>C++ primitives <ref type="bibr" target="#b46">[47]</ref> can be mapped to WMM instructions in an efficient way as shown in Figure <ref type="figure">10</ref>. For the purpose of comparison, we also include a mapping to POWER <ref type="bibr" target="#b56">[57]</ref>. The Commit; Reconcile sequence in WMM is the same as a sync fence in POWER, and Commit is similar to lwsync. The cmp; bc; isync sequence in POWER serves as a Ld-Ld fence, so it is similar to a Reconcile fence in WMM. In case of Store SC in C++, WMM uses a Commit while POWER uses a sync, so WMM effectively saves one Reconcile. On the other hand, POWER does not need any fence for Load Consume in C++, while WMM requires a Reconcile.</p><formula xml:id="formula_2">C++</formula><p>Besides the C++ primitives, a common programming paradigm is the well-synchronized program, in which all critical sections are protected by locks. To maintain SC behaviors for such programs in WMM, we can add a Reconcile after acquiring the lock and a Commit before releasing the lock.</p><p>For any program, if we insert a Commit before every store and insert a Commit followed by a Reconcile before every load, then the program behavior in WMM is guaranteed to be sequentially consistent. This provides a conservative way for inserting fences when performance is not an issue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. WMM IMPLEMENTATION</head><p>WMM can be implemented using conventional OOO multiprocessors, and even the most aggressive speculative techniques cannot step beyond WMM. To demonstrate this, we describe an OOO implementation of WMM, and show simultaneously how the WMM model (i.e., the I 2 E abstract machine) captures the behaviors of the implementation. The implementation is described abstractly to skip unrelated details (e.g., ROB entry reuse). The implementation consists of n OOO processors and a coherent write-back cache hierarchy which we discuss next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Write-Back Cache Hierarchy (CCM)</head><p>We describe CCM as an abstraction of a conventional write-back cache hierarchy to avoid too much details. In the following, we explain the function of such a cache hierarchy, abstract it to CCM, and relate CCM to the WMM model. Consider a real n-ported write-back cache hierarchy with each port i connected to processor P i. A request issued to port i may be from a load instruction in the ROB of P i or a store in the store buffer of P i. In conventional coherence protocols, all memory requests can be serialized, i.e., each request can be considered as taking effect at some time point within its processing period <ref type="bibr" target="#b57">[58]</ref>. For example, consider the non-stalling MSI directory protocol in the Primer by Sorin et al. <ref type="bibr" target="#b58">[59,</ref><ref type="bibr">Chapter 8.7.2]</ref>. In this protocol, a load request takes effect immediately if it hits in the cache; otherwise, it takes effect when it gets the data at the directory or a remote cache with M state. A store request always takes effect at the time of writing the cache, i.e., either when it hits in the cache, or when it has received the directory response and all invalidation responses in case of miss. We also remove the requesting store from the store buffer when a store request takes effect. Since a cache cannot process multiple requests to the same address simultaneously, we assume requests to the same address from the same processor are processed in the order that the requests are issued to the cache.</p><p>CCM (Figure <ref type="figure">11</ref>) abstracts the above cache hierarchy by operating as follows: every new request from port i is inserted into a memory request buffer mrb <ref type="bibr">[i]</ref>, which keeps requests to the same address in order; at any time we can remove the oldest request for an address from a mrb, let the request access the atomic memory m, and either send the load result to ROB (which may experience a delay) or immediately dequeue the store buffer. m represents the coherent memory states. Removing a request from mrb and accessing m captures the moment when the request takes effect.</p><p>It is easy to see that the atomic memory in CCM corresponds to the atomic memory in the WMM model, because they both hold the coherent memory values. We will show shortly that how WMM captures the combination of CCM and OOO processors. Thus any coherent protocol that can be abstracted as CCM can be used to implement WMM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Out-of-Order Processor (OOO)</head><p>The major components of an OOO processor are the ROB and the store buffer (see Figure <ref type="figure">11</ref>). Instructions are fetched into and committed from ROB in order; loads can be issued (i.e., search for data forwarding and possibly request CCM) as soon as its address is known; a store is enqueued into the store buffer only when the store commits (i.e., entries in a store buffer cannot be killed). To maintain the per-location SC property of WMM, when a load L is issued, it kills younger loads which have been issued but do not read from stores younger than L. Next we give the correspondence between OOO and WMM. Store buffer: The state of the store buffer in OOO is represented by the sb in WMM. Entry into the store buffer when a store commits in OOO corresponds to the WMM-St operation. In OOO, the store buffer only issues the oldest store for some address to CCM. The store is removed from the store buffer when the store updates the atomic memory in CCM. This corresponds to the WMM-DeqSb operation. ROB and eager loads: Committing an instruction from ROB corresponds to executing it in WMM, and thus the architectural register state in both WMM and OOO must match at the time of commit. Early execution of a load L to address a with a return value v in OOO can be understood by considering where a, v resides in OOO when L commits. Reading from sb or atomic memory m in the WMM-Ld operation covers the cases that a, v is, respectively, in the store buffer or the atomic memory of CCM when L commits. Otherwise a, v is no longer present in CCM+OOO at the time of load commit and must have been overwritten in the atomic memory of CCM. This case corresponds to having performed the WMM-DeqSb operation to insert a, v into ib previously, and now using the WMM-Ld operation to read v from ib. Speculations: OOO can issue a load speculatively by aggressive predictions, such as branch prediction (Figure <ref type="figure">3d</ref>), memory dependency prediction (Figure <ref type="figure">3e</ref>) and even loadvalue prediction (Figure <ref type="figure">3f</ref>). As long as all predictions related to the load eventually turn out to be correct, the load result got from the speculative execution can be preserved. No further check is needed. Speculations effectively reorder dependent instructions, e.g., load-value speculation reorders data-dependent loads. Since WMM does not require preserving any dependency ordering, speculations will neither break WMM nor affect the above correspondence between OOO and WMM. Fences: Fences never go into store buffers or CCM in the implementation. In OOO, a Commit can commit from ROB only when the local store buffer is empty. Reconcile plays a different role; at the time of commit it is a NOP, but while it is in the ROB, it stalls all younger loads (unless the load can bypass directly from a store which is younger than the Reconcile). The stall prevents younger loads from reading values that would become stale when the Reconcile commits. This corresponds to clearing ib in WMM. Summary: For any execution in the CCM+OOO implementation, we can operate the WMM model following the above correspondence. Each time CCM+OOO commits an instruction I from ROB or dequeues a store S from a store buffer to memory, the atomic memory of CCM, store buffers, and the results of committed instructions in CCM+OOO are exactly the same as those in the WMM model when the WMM model executes I or dequeues S from sb, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. PERFORMANCE EVALUATION OF WMM</head><p>We evaluate the performance of implementations of WMM, Alpha, SC and TSO. All implementations use OOO cores and coherent write-back cache hierarchy. Since Alpha allows Ld-St reordering, the comparison of WMM and Alpha will show whether such reordering affects performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Evaluation Methodology</head><p>We ran SPLASH-2x benchmarks <ref type="bibr" target="#b59">[60]</ref>, <ref type="bibr" target="#b60">[61]</ref> on an 8-core multiprocessor using the ESESC simulator <ref type="bibr" target="#b61">[62]</ref>. We ran all benchmarks except ocean ncp, which allocates too much memory and breaks the original simulator. We used simmedium inputs except for cholesky, fft and radix, where we used sim-large inputs. We ran all benchmarks to completion without sampling.</p><p>The configuration of the 8-core multiprocessor is shown in Figures <ref type="figure" target="#fig_1">12</ref> and<ref type="figure">13</ref> . We do not use load-value speculation in this evaluation. The Alpha implementation can mark a younger store as committed when instruction commit is stalled, as long as the store can never be squashed and the early commit will not affect single-thread correctness. A committed store can be issued to memory or merged with another committed store in WMM and Alpha. SC and TSO issue loads speculatively and monitor L1 cache evictions to kill speculative loads that violate the consistency model. We also implement store prefetch as an optional feature for SC and TSO; We use SC-pf and TSO-pf to denote the respective implementations with store prefetch.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Simulation Results</head><p>A common way to study the performance of memory models is to monitor the commit of instructions at the commit slot of ROB (i.e., the oldest ROB entry). Here are some reasons why an instruction may not commit in a given cycle:</p><p>? empty: The ROB is empty.</p><p>? exe: The instruction at the commit slot is still executing. (only in SC or TSO). Figure <ref type="figure" target="#fig_8">14</ref> shows the execution time (normalized to WMM) and its breakdown at the commit slot of ROB. The total height of each bar represents the normalized execution time, and stacks represent different types of stall times added to the active committing time at the commit slot. WMM versus SC: WMM is much faster than both SC and SC-pf for most benchmarks, because a pending older store in the store queue can block SC from committing loads. WMM versus TSO: WMM never does worse than TSO or TSO-pf, and in some cases it shows up to 1.45? speedup over TSO (in radix) and 1.18? over TSO-pf (in lu ncb). There are two disadvantages of TSO compared to WMM. First, load speculation in TSO is subject to L1 cache eviction, e.g., in benchmark ocean cp. Second, TSO requires prefetch to reduce store miss latency, e.g., a full store queue in TSO stalls issue to ROB and makes ROB empty in benchmark radix. However, prefetch may sometimes degrade performance due to interference with load execution, e.g., TSO-pf has more commit stalls due to unfinished loads in benchmark lu ncb. WMM versus Alpha: Figure <ref type="figure" target="#fig_10">15</ref> shows the average number of cycles that a store in Alpha can commit before it reaches the commit slot. However, the early commit (i.e., Ld-St reordering) does not make Alpha outperform WMM (see Figure <ref type="figure" target="#fig_8">14</ref>), because store buffers can already hide the store miss latency. Note that ROB is typically implemented as a FIFO (i.e., a circular buffer) for register renaming (e.g., freeing physical registers in order), precise exceptions, etc. Thus, if the early committed store is in the middle of ROB, its ROB entry cannot be reused by a newly fetched instruction, i.e., the effective size of the ROB will not increase. In summary, the Ld-St reordering in Alpha does not increase performance but complicates the definition (Section V-B). Unlike the multi-copy atomic stores in WMM, stores in some processors (e.g., POWER) are non-atomic due to shared write-through caches or shared store buffers. If multiple processors share a store buffer or write-through cache, a store by any of these processors may be seen by all these processors before other processors. Although we could tag stores with processor IDs in the store buffer, it is infeasible to separate values stored by different processors in a cache.</p><formula xml:id="formula_3">E D UQ H V F K R OH V N \ II W IP P OX B F E OX B Q F E R F H D Q B F S UD G L[ UD G LR V LW \ UD \ WU D F H Y R OU H Q G Z D WH UB Q V T Z D WH UB V S &amp;\FOHV</formula><p>In this section, we introduce a new I 2 E model, WMM-S, which captures the non-atomic store behaviors in a way independent from the sharing topology. WMM-S is derived from WMM by adding a new background operation. We will show later in Section IX why WMM-S can be implemented using memory systems with non-atomic stores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. I 2 E Definition of WMM-S</head><p>The structure of the abstract machine of WMM-S is the same as that of WMM. To model non-atomicity of stores, i.e., to make a store by one processor readable by another processor before the store updates the atomic memory, WMM-S introduces a new background operation that copies a store from one store buffer into another. However, we need to ensure that all stores for an address can still be put in a total order (i.e., the coherence order), and the order seen by any processor is consistent with this total order (i.e., per-location SC).</p><p>To identify all the copies of a store in various store buffers, we assign a unique tag t when a store is executed (by being inserted into sb), and this tag is copied when a store is copied from one store buffer to another. When a background operation dequeues a store from a store buffer to the memory, all its copies must be deleted from all the store buffers which have them. This requires that all copies of the store are the oldest for that address in their respective store buffers.</p><p>All the stores for an address in a store buffer can be strictly ordered as a list, where the youngest store is the one that entered the store buffer last. We make sure that all ordered lists (of all store buffers) can be combined transitively to form a partial order (i.e., no cycle), which has now to be understood in terms of the tags on stores because of the copies. We refer to this partial order as the partial coherence order (&lt; co ), because it is consistent with the coherence order.</p><p>Consider the states of store buffers shown in Figure Figure <ref type="figure" target="#fig_11">17</ref> shows the background operations of the WMM-S abstract machine. The operations that execute instructions in WMM-S are the same as those in WMM, so we do not show them again. (The store execution operation in WMM-S needs to also insert the tag of the store into sb). Binding background copy with load execution: If the WMM-S-Copy operation is restricted to always happen right before a load execution operation that reads from the newly created copy, it is not difficult to prove that the WMM-S model remains the same, i.e., legal behaviors do not change. In the rest of the paper, we will only consider this "restricted" version of WMM-S. In particular, all WMM-S-Copy operations in the following analysis of litmus tests fall WMM-DeqSb (background store buffer dequeue) Predicate: There is a store S in a store buffer, and all copies of S are the oldest store for that address in their respective store buffers. Action: Assume the address, value, tag tuple of store S is a, v, t . First, the stale address, value pair a, m[a] is inserted to the ib of every processor whose sb does not contain a. Then all copies of S are removed from their respective store buffers, and the atomic memory m[a] is updated to v. WMM-S-Copy (background store copy) Predicate: There is a store S that is in the sb of some processor i but not in the sb of some other processor j. Additionally, the partial coherence order will still be acyclic if we insert a copy of S into the sb of processor j. Action: Insert a copy of S into the sb of processor j, and remove all values for the store address of S from the ib of processor j. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Properties of WMM-S</head><p>WMM-S enforces per-location SC (Figure <ref type="figure">4</ref>), because it prevents cycles in the order of stores to the same address. It also allows the same instruction reorderings as WMM does (Figure <ref type="figure">3</ref>). We focus on the store non-atomicity of WMM-S. Non-atomic stores and cumulative fences: Consider the litmus tests for non-atomic stores in Figures <ref type="figure" target="#fig_1">2b,</ref><ref type="figure" target="#fig_1">2c</ref> and 2d (FENCE LL should be Reconcile in these tests). WMM-S allows the behavior in Figure <ref type="figure" target="#fig_1">2b</ref> by copying I 1 into the sb of P2 and then executing I 2 , I 3 , I 4 , I 5 , I 6 sequentially. I 1 will not be dequeued from sb until I 6 returns value 0. To forbid this behavior, a Commit is required between I 2 and I 3 in P2 to push I 1 into memory. Similarly, WMM-S allows the behavior in Figure <ref type="figure" target="#fig_1">2c</ref> (i.e., we copy I 1 into the sb of P2 to satisfy I 2 , and I 1 is dequeued after I 5 has updated the atomic memory), and we need a Commit between I 2 and I 3 to forbid the behavior. In both litmus tests, the inserted fences have a cumulative global effect in ordering I 1 before I 3 and the last instruction in P3.</p><p>WMM-S also allows the behavior in Figure <ref type="figure" target="#fig_1">2d</ref> by copying I 1 into the sb of P2 to satisfy I 2 , and copying I 5 into the sb of P4 to satisfy I 6 . To forbid the behavior, we need to add a Commit right after the first load in P2 and P4 (but before the FENCE LL /Reconcile that we added to stop Ld-Ld reordering). As we can see, Commit and Reconcile are similar to release and acquire respectively. Cumulation is achieved by globally advertising observed stores (Commit) and preventing later loads from reading stale values (Reconcile). Programming properties: WMM-S is the same as WMM in the properties described in Section V-C, including the compilation of C++ primitives, maintaining SC for wellsynchronized programs, and the conservative way of inserting fences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. WMM-S IMPLEMENTATIONS</head><p>Since WMM-S is strictly more relaxed than WMM, any WMM implementation is a valid WMM-S implementation. However, we are more interested in implementations with non-atomic memory systems. Instead of discussing each specific system one by one, we explain how WMM-S can be implemented using the ARMv8 flowing model, which is a general abstraction of non-atomic memory systems <ref type="bibr" target="#b7">[8]</ref>. We first describe the adapted flowing model (FM) which uses fences in WMM-S instead of ARM, and then explain how it obeys WMM-S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. The Flowing Model (FM)</head><p>FM consists of a tree of segments s[i] rooted at the atomic memory m. For example, Figure <ref type="figure" target="#fig_7">19</ref> shows four OOO processors (P1. . .P4) connected to a 4-ported FM which has six segments (s[1 . . . 6]). Each segment is a list of memory requests, (e.g., the list of blue nodes in s <ref type="bibr" target="#b5">[6]</ref>, whose head is at the bottom and the tail is at the top).</p><p>OOO interacts with FM in a slightly different way than CCM. Every memory request from a processor is appended to the tail of the list of the segment connected to the processor (e.g., s <ref type="bibr" target="#b0">[1]</ref> for P1). OOO no longer contains a store buffer; after a store is committed from ROB, it is directly sent to FM and there is no store response. When a Commit fence reaches the commit slot of ROB, the processor sends a Commit request to FM, and the ROB will not commit the Commit fence until FM sends back the response for the Commit request.</p><p>Inside FM, there are three background operations: (1) Two requests in the same segment can be reordered in certain cases; (2) A load can bypass from a store in the same segment;</p><p>(3) The request at the head of the list of a segment can flow into the parent segment (e.g., flow from s <ref type="bibr" target="#b0">[1]</ref> into s <ref type="bibr" target="#b4">[5]</ref>) or the atomic memory (in case the parent of the segment, e.g., s <ref type="bibr" target="#b5">[6]</ref>, is m). Details of these operations are shown in Figure <ref type="figure" target="#fig_12">18</ref>.</p><p>It is easy to see that FM abstracts non-atomic memory systems, e.g., Figure <ref type="figure" target="#fig_7">19</ref> abstracts a system in which P1 and P2 share a write-through cache while P3 and P4 share another. Two properties of FM+OOO: First, FM+OOO enforces per-location SC because the segments in FM never reorder requests to the same address. Second, stores for the same address, which lie on the path from a processor to m in the tree structure of FM, are strictly ordered based on their distance to the tree root m; and the combination of all such orderings will not contain any cycle. For example, in Figure <ref type="figure" target="#fig_7">19</ref>, stores in segments s <ref type="bibr" target="#b2">[3]</ref> and s <ref type="bibr" target="#b5">[6]</ref> are on the path from P3 to m; a store in s <ref type="bibr" target="#b5">[6]</ref> is older than any store (for the same address) in s <ref type="bibr" target="#b2">[3]</ref>, and stores (for the same address) in the same segment are ordered from bottom to top (bottom is older).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FM-Reorder (reorder memory requests)</head><p>Predicate: The list of segment s[i] contains two consecutive requests rnew and r old (rnew is above r old in s[i]); and neither of the following is true: 1) rnew and r old are memory accesses to the same address. 2) rnew is a Commit and r old is a store. Action: Reorder rnew and r old in the list of s[i]. FM-Bypass (store forwarding) Predicate: The list of segment s[i] contains two consecutive requests rnew and r old (rnew is above r old in s[i]). rnew is a load, r old is a store, and they are for the same address. Action: we send the load response for rnew using the store value of r old , and remove rnew from the segment. FM-Flow (flow request) Predicate: A segment s[i] is not empty. Action: Remove the request r which is the head of the list of s <ref type="bibr">[i]</ref>.</p><p>If the parent of s[i] in the tree structure is another segment s[j], we append r to the tail of the list of s[j]. Otherwise, the parent of s[i] is m, and we take the following actions according to the type of r:</p><p>? If r is a load, we send a load response using the value in m.</p><p>? If r is a store a, v , we update m[a] to v.</p><p>? If r is a Commit, we send a response to the requesting processor and the Commit fence can then be committed from ROB. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Relating FM+OOO to WMM-S</head><p>WMM-S can capture the behaviors of any program execution in implementation FM+OOO in almost the same way that WMM captures the behaviors of CCM+OOO. When a store updates the atomic memory in FM+OOO, WMM-S performs a WMM-S-DeqSb operation to dequeue that store from store buffers to memory. When an instruction is committed from a ROB in FM+OOO, WMM-S executes that instruction. The following invariants hold after each operation in FM+OOO and the corresponding operation in WMM-S:</p><p>1) For each instruction committed in FM+OOO, the execution results in FM+OOO and WMM-S are the same.</p><p>2) The atomic memories in FM+OOO and WMM-S match.</p><p>3) The sb of each processor P i in WMM-S holds exactly all the stores in FM+OOO that is observed by the commits of P i but have not updated the atomic memory. (A store is observed by the commits of P i if it has been either committed by P i or returned by a load that has been committed by P i). 4) The order of stores for the same address in the sb of any processor in WMM-S is exactly the order of those stores on the path from P i to m in FM+OOO.</p><p>It is easy to see how the invariants are maintained when the atomic memory is updated or a non-load instruction is committed in FM+OOO. To understand the commit of a load L to address a with result v in processor P i in FM+OOO, we still consider where a, v resides when L commits. Similar to WMM, reading atomic memory m or local ib in the load execution operation of WMM-S covers the cases that a, v is still in the atomic memory of FM or has already been overwritten by another store in the atomic memory of FM, respectively. In case a, v is a store that has not yet updated the atomic memory in FM, a, v must be on the path from P i to m. In this case, if a, v has been observed by the commits of P i before L is committed, then L can be executed by reading the local sb in WMM-S. Otherwise, on the path from P i to m, a, v must be younger than any other store observed by the commits of P i. Thus, WMM-S can copy a, v into the sb of P i without breaking any invariant. The copy will not create any cycle in &lt; co because of invariants 3 and 4 as well as the second property of FM+OOO mentioned above. After the copy, WMM-S can have L read v from the local sb.</p><p>Performance comparison with ARM and POWER: As we have shown that WMM-S can be implemented using the generalized memory system of ARM, we can turn an ARM multicore into a WMM-S implementation by stopping Ld-St reordering in the ROB. Since Section VII already shows that Ld-St reordering does not affect performance, we can conclude qualitatively that there is no discernible performance difference between WMM-S and ARM implementations. The same arguments apply to the comparison against POWER and RC. Here we elaborate the problems of RC (both RC sc and RC pc ) and RMO, which have been pointed out in Section I. RC: Although the RC definition <ref type="bibr" target="#b5">[6]</ref> allows the behaviors of WRC and IRIW (Figures <ref type="figure" target="#fig_1">2b</ref> and<ref type="figure" target="#fig_1">2d</ref>), it disallows the behavior of WWC (Figure <ref type="figure" target="#fig_1">2c</ref>). In WWC, when I 2 reads the value of store I 1 , the RC definition says that I 1 is performed with respect to (w.r.t) P2. Since store I 5 has not been issued due to the data dependencies in P2 and P3, I 1 must be performed w.r.t P2 before I 5 . The RC definition says that "all writes to the same location are serialized in some order and are performed in that order with respect to any processor" [6, Section 2]. Thus, I 1 is before I 5 in the serialization order of stores for address a, and the final memory value of a cannot be 2 (the value of I 1 ), i.e., RC forbids the behavior of WWC and thus forbids shared write-through caches in implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RMO:</head><p>The RMO definition [4, Section D] is incorrect in enforcing dependency ordering. Consider the litmus test in Figure <ref type="figure" target="#fig_1">20</ref> (MEMBAR is the fence in RMO). In P2, the execution of I 6 is conditional on the result of I 4 , I 7 loads from the address that I 6 stores to, and I 9 uses the results of I 7 . According the definition of dependency ordering in RMO <ref type="bibr" target="#b3">[4,</ref><ref type="bibr">Section D.3.3]</ref>, I 9 depends on I 4 transitively. Then the RMO axioms <ref type="bibr" target="#b3">[4,</ref><ref type="bibr">Section D.4</ref>] dictate that I 9 must be after I 4 in the memory order, and thus forbid the behavior in Figure <ref type="figure" target="#fig_1">20</ref>. However, this behavior is possible in hardware with speculative load execution and store forwarding, i.e., I 7 first speculatively bypasses from I 6 , and then I 9 executes speculatively to get 0. Since most architects will not be willing to give up on these two optimizations, RISC-V should not adopt RMO.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XI. CONCLUSION</head><p>We have proposed two weak memory models, WMM and WMM-S, for RISC-V with different tradeoffs between definitional simplicity and implementation flexibility. However RISC-V can have only one memory model. Since there is no obvious evidence that restricting to multi-copy atomic stores affects performance or increases hardware complexity, RISC-V should adopt WMM in favor of simplicity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XII. ACKNOWLEDGMENT</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>I 1 :a 1 I 4 : 6 : r 4 =I 1 :a 2 I 2 : r 1 = 3 : 5 :I 1 :a 1 I 2 : r 1 = 5 :b 1 I 6 : r 3 =</head><label>1146412213511215163</label><figDesc>St St b 1 I 2 : r 1 = Ld a I 5 : r 3 = Ld b I 3 : r 2 = Ld (b+r 1 -1) I Ld (a+r 3 -1) SC forbids but TSO allows: r 1 = 1, r 2 = 0, r 3 = 1, r 4 = 0 (a) SBE: test for multi-copy atomic stores Proc. P1 Proc. P2 Proc. P3 I 1 : St a 2 I 2 : r 1 = Ld a I 4 : r 2 = Ld b I 3 : St b (r 1 -1) I 5 : FENCE LL I 6 : r 3 = Ld a TSO, RMO and Alpha forbid, but RC, ARM and POWER allow: r 1 = 2, r 2 = 1, r 3 = 0 (b) WRC: test for non-atomic stores [7] St Ld a I 4 : r 2 = Ld b I St b (r 1 -1) I St a r 2 TSO, RMO, Alpha and RC forbid, but ARM and POWER allow: r 1 = 2, r 2 = 1, m[a] = 2 (c) WWC: test for non-atomic stores [46], [54] St Ld a I St Ld b I 3 : FENCE LL I 7 : FENCE LL I 4 : r 2 = Ld b I 8 : r 4 = Ld a TSO, RMO and Alpha forbid, but RC, ARM and POWER allow: r 1 = 1, r 2 = 0, r 3 = 1, r 4 = 0(d) IRIW: test for non-atomic stores<ref type="bibr" target="#b6">[7]</ref> </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Litmus tests for store atomicity</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>I 1 :a 1 I 3 :b 1 I 2 : r 1 = 1 : 2 : 2 :a 1 I 4 : 3 :I 1 :a 1 I 4 : r 1 = 3 : 1 : 1 I 3 :Figure 3 .</head><label>113121122143114131133</label><figDesc>Figure 3. Litmus tests for instruction reorderingsSB: A TSO machine can execute I 2 and I 4 while I 1 and I 3 are buffered in the store buffers. The resulting behavior is as if the store and the load were reordered on each processor. MP: In an Alpha machine, I 1 and I 2 may be drained from the store buffer of P1 out of order; I 3 and I 4 in the ROB of P2 may be executed out of order. This is as if P1 reordered the two stores and P2 reordered the two loads. LB: Some machines may enter a store into the memory before all older instructions have been committed. This results in the Ld-St reordering shown in Figure3c. Since instructions are committed in order and stores are usually not on the critical path, the benefit of the eager execution of stores is limited. In fact we will show by simulation that Ld-St reordering does not improve performance (Section VII). MP+Ctrl: This test is a variant of MP. The two stores in P1 must update memory in order due to the fence. Although</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Out-of-thin-air read</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. I 2 E abstract machines for different models</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Operations of the TSO/PSO abstract machine</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Operations of the WMM abstract machine</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Axiomatic definition of WMM</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Normalized execution time and its breakdown at the commit slot of ROB</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>? pendSt: The load (in SC) or Commit (in TSO, Alpha and WMM) cannot commit due to pending older stores. ? flushLS: ROB is being flushed because a load is killed by another older load (only in WMM and Alpha) or older store (in all models) to the same address. ? flushInv: ROB is being flushed after cache invalidation caused by a remote store (only in SC or TSO). ? flushRep: ROB is being flushed after cache replacement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 15 .</head><label>15</label><figDesc>Figure 15. Average cycles to commit stores early in Alpha</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 17 .</head><label>17</label><figDesc>Figure 17. Background operations of WMM-S</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 18 .</head><label>18</label><figDesc>Figure 18. Background operations of FM</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>1 : 3 :b 1 I 6 :c 1 I 7 : r 2 = 1 I 9 : r 4 =Figure 20 .</head><label>131617219420</label><figDesc>Figure 19. OOO+FM</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>16 (primes are copies). A, B, C and D are different stores to the same address, and their tags are t A , t B , t C and t D , respectively. A and B are copies of A and B respectively created by the background copy operation. Ignoring C , the partial coherence order contains: t D &lt; co t B &lt; co t A (D is older than B, and B is older than A in P2), and t C &lt; co t B (C is older than B in P3). Note that t D and t C are not related here. At this point, if we copied C in P3 as C into P1, we would add a new edge t A &lt; co t C , breaking the partial order by introducing the cycle t A &lt; co t C &lt; co t B &lt; co t A . Thus copying of C into P1 should be forbidden in this state.Similarly, copying a store with tag t A into P1 or P2 should be forbidden because it would immediately create a cycle: t A &lt; co t A . In general, the background copy operation must be constrained so that the partial coherence order is still acyclic after copying.</figDesc><table><row><cell></cell><cell>W? ??</cell><cell>W? ??</cell><cell>W? ??</cell></row><row><cell>??????? ????? ????????? ?</cell><cell>?? ???</cell><cell>?? ??? ? ???</cell><cell>?? ???</cell></row><row><cell>??????? ??????? ?K?????</cell><cell>? ???</cell><cell>? ???</cell><cell>? ???</cell></row><row><cell cols="4">Figure 16. Example states of store buffers</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>978-1-5090-6764-0/17 $31.00 ? 2017 IEEE DOI 10.1109/PACT.2017.29</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>TSO-Nm (non-memory execution)Predicate: The next instruction of a processor is a non-memory instruction. Action: Instruction is executed by local computation. TSO-Ld (load execution) Predicate: The next instruction of a processor is a load. Action: Assume the load address is a. The load returns the value of the youngest store for a in sb if a is present in the sb of the processor, otherwise, the load returns m[a], i.e., the value of address a in the atomic memory. TSO-St (store execution) Predicate: The next instruction of a processor is a store. Action: Assume the store address is a and the store value is v. The processor inserts the store a, v into its sb. TSO-Com (Commit execution) Predicate: The next instruction of a processor is a Commit and the sb of the processor is empty. Action: The Commit fence is executed simply as a NOP. TSO-DeqSb (background store buffer dequeue) Predicate: The sb of a processor is not empty. Action: Assume the address, value pair of the oldest store in the sb is a, v . Then this store is removed from sb, and the atomic memory m[a] is updated to v.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>&amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp; 6 &amp;</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>We thank all the anonymous reviewers on the different versions of this paper over the two years. We have also benefited from the discussions with <rs type="person">Andy Wright</rs>, <rs type="person">Thomas Bourgeat</rs>, <rs type="person">Joonwon Choi</rs>, <rs type="person">Xiangyao Yu</rs>, and <rs type="person">Guowei Zhang</rs>. This work was done as part of the <rs type="projectName">Proteus</rs> project under the <rs type="funder">DARPA BRASS Program</rs> (grant number <rs type="grantNumber">6933218</rs>).</p></div>
			</div>
			<div type="funding">
<div><p>Axiomatic model Store atomicity Allow shared writethrough cache/shared store buffer Instruction reorderings Ordering of data-dependent loads SC Simple; I <rs type="programName">2 E [1] Simple [1] Single-copy atomic No None Yes TSO Simple; I 2 E [2] Simple [3] Multi-copy atomic No Only St-Ld reordering Yes RMO Doesn</rs>'t exist Simple; needs fix [4] <rs type="projectName">Multi-copy atomic No All four Yes Alpha Doesn't exist Medium [5] Multi-copy atomic No All four No RC Doesn't exist Medium [6] Unclear No All four Yes ARM</rs> and <rs type="funder">POWER Complex</rs>; non I 2 E [7], [8] Complex [9], [10] Non-atomic <rs type="projectName">Yes All four Yes WMM Simple; I 2 E Simple Multi-copy atomic No All except Ld-St reordering No WMM-S Medium</rs>; <rs type="person">I 2 E Doesn</rs>'t exist Non-atomic Yes All except Ld-St reordering No</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_97vV33y">
					<idno type="grant-number">6933218</idno>
					<orgName type="project" subtype="full">Proteus</orgName>
				</org>
				<org type="funded-project" xml:id="_weKHkSJ">
					<orgName type="project" subtype="full">Multi-copy atomic No All four Yes Alpha Doesn&apos;t exist Medium [5] Multi-copy atomic No All four No RC Doesn&apos;t exist Medium [6] Unclear No All four Yes ARM</orgName>
					<orgName type="program" subtype="full">2 E [1] Simple [1] Single-copy atomic No None Yes TSO Simple; I 2 E [2] Simple [3] Multi-copy atomic No Only St-Ld reordering Yes RMO Doesn</orgName>
				</org>
				<org type="funded-project" xml:id="_3DYq6dg">
					<orgName type="project" subtype="full">Yes All four Yes WMM Simple; I 2 E Simple Multi-copy atomic No All except Ld-St reordering No WMM-S Medium</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">How to make a multiprocessor computer that correctly executes multiprocess programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computers, IEEE Transactions on</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="690" to="691" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">x86-tso: a rigorous and usable programmer&apos;s model for x86 multiprocessors</title>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="89" to="97" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The SPARC Architecture Manual: Version 8</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Prentice-Hall, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gremond</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The SPARC architecture manual (Version 9)</title>
		<imprint>
			<publisher>PTR Prentice Hall Englewood Cliffs</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">07632</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Alpha Architecture Handbook, Version 4</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>Compaq Computer Corporation</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Memory consistency and event ordering in scalable shared-memory multiprocessors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lenoski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Laudon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Symposium on Computer Architecture</title>
		<meeting>the 17th International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Understanding power multiprocessors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Maranget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="175" to="186" />
			<date type="published" when="2011">2011</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Modelling the armv8 architecture, operationally: Concurrency and isa</title>
		<author>
			<persName><forename type="first">S</forename><surname>Flur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pulte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sezgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Maranget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Deacon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<idno type="DOI">10.1145/2837614.2837615</idno>
		<ptr target="http://doi.acm.org/10.1145/2837614.2837615" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page" from="608" to="621" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An axiomatic memory model for power multiprocessors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mador-Haim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Maranget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Memarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="495" to="512" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Herding cats: Modelling, simulation, testing, and data mining for weak memory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Maranget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tautschnig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ibm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Isa</forename><surname>Power</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-07-02">Version 2.07, 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The semantics of power and arm multiprocessor machine code</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ishtiaq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th workshop on Declarative aspects of multicore programming</title>
		<meeting>the 4th workshop on Declarative aspects of multicore programming</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Proceedings</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Maranget</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-22110-16</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-642-22110-16" />
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification: 23rd International Conference, CAV 2011</title>
		<meeting><address><addrLine>Snowbird, UT, USA; Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">July 14-20, 2011. 2011</date>
			<biblScope unit="page" from="50" to="66" />
		</imprint>
	</monogr>
	<note>Weak Memory Models</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A formal hierarchy of weak memory models</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods in System Design</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="178" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Synchronising c/c++ and power</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Memarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Batty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Maranget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="311" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Software verification for weak memory via program transformation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nimal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tautschnig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Languages and Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="512" to="532" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The risc-v instruction set</title>
		<ptr target="https://riscv.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The risc-v instruction set manual</title>
		<author>
			<persName><forename type="first">A</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Asanovi</surname></persName>
		</author>
		<idno>UCB/EECS-2016-118</idno>
		<ptr target="https://people.eecs.berkeley.edu/?krste/papers/riscv-spec-v2.1.pdf" />
		<imprint>
			<date type="published" when="2014-05">May 2014</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
		<respStmt>
			<orgName>EECS Department, University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>User-level isa, version 2.1</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Armor: defending against memory consistency model mismatches in heterogeneous architectures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lustig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Trippel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pellauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Martonosi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd Annual International Symposium on Computer Architecture</title>
		<meeting>the 42nd Annual International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="388" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Value locality and load value prediction</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">B</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="138" to="147" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Correctly implementing value prediction in microprocessors that support multithreading or multiprocessing</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Cain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=563998.564039" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual ACM/IEEE International Symposium on Microarchitecture</title>
		<meeting>the 34th Annual ACM/IEEE International Symposium on Microarchitecture<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="328" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The potential of using dynamic information flow analysis in data value prediction</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Ghandour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Akkary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Masri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on Parallel architectures and compilation techniques</title>
		<meeting>the 19th international conference on Parallel architectures and compilation techniques</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="431" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Eole: Paving the way for an effective implementation of value prediction</title>
		<author>
			<persName><forename type="first">A</forename><surname>Perais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Architecture (ISCA), 2014 ACM/IEEE 41st International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="481" to="492" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Practical data value speculation for future high-end processors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Perais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seznec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High Performance Computer Architecture (HPCA), 2014 IEEE 20th International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="428" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A better x86 memory model: x86-tso</title>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theorem Proving in Higher Order Logics</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="391" to="407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A promising semantics for relaxed-memory concurrency</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Lahav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dreyer</surname></persName>
		</author>
		<idno type="DOI">10.1145/3009837.3009850</idno>
		<ptr target="http://doi.acm.org/10.1145/3009837.3009850" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages</title>
		<meeting>the 44th ACM SIGPLAN Symposium on Principles of Programming Languages<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017. 2017</date>
			<biblScope unit="page" from="175" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Outlawing ghosts: Avoiding out-of-thin-air results</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Demsky</surname></persName>
		</author>
		<idno type="DOI">10.1145/2618128.2618134</idno>
		<ptr target="http://doi.acm.org/10.1145/2618128.2618134" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Memory Systems Performance and Correctness, ser. MSPC &apos;14</title>
		<meeting>the Workshop on Memory Systems Performance and Correctness, ser. MSPC &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Weak ordering a new definition</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="2" to="14" />
			<date type="published" when="1990">1990</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Two techniques to enhance the performance of memory consistency models</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Hennessy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1991 International Conference on Parallel Processing</title>
		<meeting>the 1991 International Conference on Parallel Processing</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="355" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Using speculative retirement and larger instruction windows to narrow the performance gap between memory consistency models</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ninth annual ACM symposium on Parallel algorithms and architectures</title>
		<meeting>the ninth annual ACM symposium on Parallel algorithms and architectures</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="199" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Is sc+ ilp= rc?&quot; in Computer Architecture</title>
		<author>
			<persName><forename type="first">C</forename><surname>Guiady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Vijaykumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Symposium on</title>
		<meeting>the 26th International Symposium on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="page" from="162" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Speculative sequential consistency with little custom storage</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gniady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="page" from="179" to="188" />
		</imprint>
	</monogr>
	<note>Proceedings. 2002 International Conference on</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Bulksc: bulk enforcement of sequential consistency</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tuck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Montesinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="278" to="289" />
			<date type="published" when="2007">2007</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Mechanisms for store-wait-free multiprocessors</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moshovos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="266" to="277" />
			<date type="published" when="2007">2007</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Invisifence: performance-transparent memory ordering in conventional multiprocessors</title>
		<author>
			<persName><forename type="first">C</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="233" to="244" />
			<date type="published" when="2009">2009</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">End-to-end sequential consistency</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="524" to="535" />
			<date type="published" when="2012">2012</date>
			<publisher>IEEE Computer Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Efficient sequential consistency via conflict ordering</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nagarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rajaram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="273" to="286" />
			<date type="published" when="2012">2012</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Atomic sc for simple in-order processors</title>
		<author>
			<persName><forename type="first">D</forename><surname>Gope</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High Performance Computer Architecture (HPCA), 2014 IEEE 20th International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="404" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The semantics of x86-cc multiprocessor machine code</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">Z</forename><surname>Nardelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Braibant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Myreen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Alglave</surname></persName>
		</author>
		<idno type="DOI">10.1145/1594834.1480929</idno>
		<ptr target="http://doi.acm.org/10.1145/1594834.1480929" />
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="379" to="391" />
			<date type="published" when="2009-01">Jan. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Cache consistency and sequential consistency</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Goodman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>University of Wisconsin-Madison, Computer Sciences Department</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Memory access buffering in multiprocessors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Scheurich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Briggs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="434" to="442" />
			<date type="published" when="1986">1986</date>
			<publisher>IEEE Computer Society Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Commit-reconcile and fences (crf): A new memory model for architects and compiler writers</title>
		<author>
			<persName><forename type="first">X</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Symposium on</title>
		<meeting>the 26th International Symposium on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="page" from="150" to="161" />
		</imprint>
	</monogr>
	<note>Computer Architecture</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Memory model = instruction reordering + store atomicity</title>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J.-W</forename><surname>Maessen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="29" to="40" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>IEEE Computer Society</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">ARM Architecture Reference Manual</title>
		<author>
			<persName><surname>Arm</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>ARMv7-A and ARMv7-R edition</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Shared memory consistency models: A tutorial</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gharachorloo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">computer</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="66" to="76" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">A tutorial introduction to the arm and power relaxed memory models</title>
		<author>
			<persName><forename type="first">L</forename><surname>Maranget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<ptr target="http://www.cl.cam.ac.uk/?pes20/ppc-supplemental/test7.pdf" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Working Draft, Standard for Programming Language C++</title>
		<author>
			<persName><forename type="first">R</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ed</forename></persName>
		</author>
		<ptr target="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf" />
		<imprint>
			<date type="published" when="2015-05">May 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Foundations of the c++ concurrency memory model</title>
		<author>
			<persName><forename type="first">H.-J</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="68" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Mathematizing c++ concurrency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Batty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="66" />
			<date type="published" when="2011">2011</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Overhauling sc atomics in c11 and opencl</title>
		<author>
			<persName><forename type="first">M</forename><surname>Batty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Donaldson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wickerson</surname></persName>
		</author>
		<idno type="DOI">10.1145/2914770.2837637</idno>
		<ptr target="http://doi.acm.org/10.1145/2914770.2837637" />
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="634" to="648" />
			<date type="published" when="2016-01">Jan. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">The java memory model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Manson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Pugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<idno type="DOI">10.1145/1040305.1040336</idno>
		<ptr target="http://doi.acm.org/10.1145/1040305.1040336" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32Nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, ser. POPL &apos;05</title>
		<meeting>the 32Nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, ser. POPL &apos;05<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="378" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">The java memory model: Operationally, denotationally, axiomatically</title>
		<author>
			<persName><forename type="first">P</forename><surname>Cenciarelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Knapp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sibilio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="page" from="331" to="346" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Improving the java memory model using crf</title>
		<author>
			<persName><forename type="first">J.-W</forename><surname>Maessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Arvind</surname></persName>
		</author>
		<author>
			<persName><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Wwc+addrs test result in power processors</title>
		<ptr target="http://www.cl.cam.ac.uk/?pes20/ppc-supplemental/ppc051.html#toc11" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">The complexity of verifying memory coherence</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Cantin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fifteenth annual ACM symposium on Parallel algorithms and architectures</title>
		<meeting>the fifteenth annual ACM symposium on Parallel algorithms and architectures</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="254" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Weak memory models: Balancing definitional simplicity and implementation flexibility</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vijayaraghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename></persName>
		</author>
		<idno type="arXiv">arXiv:1707.05923</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Clarifying and compiling c/c++ concurrency: from c++ 11 to power</title>
		<author>
			<persName><forename type="first">M</forename><surname>Batty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Memarian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sewell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="509" to="520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Vijayaraghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chlipala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Arvind</surname></persName>
		</author>
		<author>
			<persName><surname>Dave</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-21668-37</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-319-21668-37" />
		<title level="m">ch. Modular Deductive Verification of Multiprocessor Hardware Designs</title>
		<meeting><address><addrLine>San Francisco, CA, USA; Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2015">July 18-24, 2015. 2015</date>
			<biblScope unit="page" from="109" to="127" />
		</imprint>
	</monogr>
	<note>Computer Aided Verification: 27th International Conference, CAV 2015</note>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">A primer on memory consistency and cache coherence</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Computer Architecture</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="212" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">The splash-2 programs: Characterization and methodological considerations</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ohara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Torrie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="24" to="36" />
			<date type="published" when="1995">1995</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">Splash-2x benchmarks</title>
		<ptr target="http://parsec.cs.princeton.edu/parsec3-doc.htm#splash2x" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Esesc: A fast multicore simulator using time-based sampling</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">K</forename><surname>Ardestani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Renau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">High Performance Computer Architecture (HPCA2013)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="448" to="459" />
		</imprint>
	</monogr>
	<note>IEEE 19th International Symposium on</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
