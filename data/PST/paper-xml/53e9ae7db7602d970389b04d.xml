<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Method for Making Password-Based Key Exchange Resilient to Server Compromise</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Craig</forename><surname>Gentry</surname></persName>
							<email>cgentry@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<settlement>Palo Alto</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Philip</forename><surname>Mackenzie</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Google, Inc</orgName>
								<address>
									<settlement>Mountain View</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zulfikar</forename><surname>Ramzan</surname></persName>
							<email>ramzan@symantec.com</email>
							<affiliation key="aff2">
								<orgName type="institution">Symantec, Inc</orgName>
								<address>
									<settlement>Redwood City</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Method for Making Password-Based Key Exchange Resilient to Server Compromise</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E1ED6C37B8D1994FCE20582DC54B8C98</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T07:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper considers the problem of password-authenticated key exchange (PAKE) in a client-server setting, where the server authenticates using a stored password file, and it is desirable to maintain some degree of security even if the server is compromised. A PAKE scheme is said to be resilient to server compromise if an adversary who compromises the server must at least perform an offline dictionary attack to gain any advantage in impersonating a client. (Of course, offline dictionary attacks should be infeasible in the absence of server compromise.) One can see that this is the best security possible, since by definition the password file has enough information to allow one to play the role of the server, and thus to verify passwords in an offline dictionary attack.</p><p>While some previous PAKE schemes have been proven resilient to server compromise, there was no known general technique to take an arbitrary PAKE scheme and make it provably resilient to server compromise. This paper presents a practical technique for doing so which requires essentially one extra round of communication and one signature computation/ verification. We prove security in the universal composability framework by (1) defining a new functionality for PAKE with resilience to server compromise, (2) specifying a protocol combining this technique with a (basic) PAKE functionality, and (3) proving (in the random oracle model) that this protocol securely realizes the new functionality. This work was carried out while all the authors were at DoCoMo USA Labs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The Basic Problem. We start by describing the basic problem of setting up a secure channel between two parties, Alice and Bob, who only share a short secret password. Neither of them knows a public key corresponding to the other party, and neither has a certified public key (i.e., a public key whose certificate can be verified by the other party). If Alice and Bob shared a high-strength cryptographic key (i.e., a long secret), then this problem could be solved using standard solutions for setting up a secure channel, such as the protocol of Bellare and Rogaway <ref type="bibr" target="#b4">[5]</ref>. However, since Alice and Bob only share a short secret password, they must also be concerned with offline dictionary attacks. An offline dictionary attack occurs when an attacker obtains some information that can be used to perform offline verification of password guesses. We will call this password verification information. For a specific example, consider the following. Say Alice and Bob share a password π, and say an attacker somehow obtained a hash of the password h(π), where h is some common cryptographic hash function such as SHA-1 <ref type="bibr" target="#b40">[41]</ref>. Then an attacker could go offline and run through a dictionary of possible passwords {π 1 , π 2 , . . .}, testing each one against h(π). For instance, to test if π i is the correct password, the attacker computes h(π i ) and checks if h(π i ) = h(π). In general, the password verification information obtained by the attacker may not be as simple as a hash of a password, and an attacker may not always be able to test all possible passwords against the password verification information, but if he can test a significant number of passwords, this is still considered an offline dictionary attack. For some fairly recent demonstrations of how effective an offline dictionary attack can be, see <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b49">50]</ref>. So the problem remains: how do Alice and Bob set up a secure channel? In other words: how do Alice and Bob bootstrap a short secret (the password) into a long secret (a cryptographic key) that can be used to provide a secure channel?</p><p>A protocol to solve this problem is called a password-authenticated key exchange (PAKE) protocol. Informally, a PAKE protocol is secure if the only feasible way to attack the protocol is to run a trivial online dictionary attack of simply iteratively guessing passwords and attempting to impersonate one of the parties. (Note that this type of attack can generally be detected and stopped by well-known methods.) The problem of designing a secure PAKE protocol was proposed by Bellovin and Merritt <ref type="bibr" target="#b6">[7]</ref> and by Gong et al. <ref type="bibr" target="#b23">[24]</ref>, and has since been studied extensively. Below we discuss the many techniques that have been proposed.</p><p>Resilience to Server Compromise. Consider a PAKE protocol run in a client-server setting, where the client device receives a password input by a user, but where the server stores a "password file" that contains data that can be used to authenticate each user. In this scenario it is natural to be concerned about the security of this password file, since an adversary that compromises the server could obtain this password file. <ref type="foot" target="#foot_0">1</ref> In the case of many existing PAKE protocols, the consequences of an adversary obtaining the server's password file are disastrous, with the adversary obtaining enough information to impersonate a client. That is why there has been a significant amount of work on making PAKE schemes "as secure as possible" even if the server gets compromised. Naturally, if an adversary obtains a server password file, he possesses password verification information, so he can always mount an offline dictionary attack. The goal, therefore, in improving resilience to server compromise is to make the offline dictionary attack the best he can do.</p><p>In the remainder of the paper, a symmetric PAKE scheme refers to one in which the two parties use identical strings corresponding to the same password (and which, consequently is trivially insecure in the client-server setting when the server is compromised). An asymmetric PAKE scheme refers to one which is designed to maintain security (as discussed above) despite a server compromise. In particular, this implies that the server does not store the plaintext password.</p><p>Related Work. Since the PAKE problem was introduced, it has been studied extensively, and many PAKE protocols have been proposed, e.g., <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b31">32]</ref>. Many of these protocols have been shown to be insecure <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b44">45]</ref>. More recent protocols, e.g., <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b18">19]</ref>, have proofs of security, based on certain well-known cryptographic assumptions, in the random oracle and/or ideal cipher models. Other PAKE protocols have been proven secure in the common reference string (CRS) model, e.g., <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b13">14]</ref>. Finally the PAKE protocols in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b41">42]</ref> were proven secure based on a general assumption (trapdoor permutations) without any setup assumptions, but with a restriction that concurrent sessions with the same password are prohibited.</p><p>The problem of PAKE with resilience to server compromise has also been studied extensively, and many protocols have been proposed, e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b32">33]</ref>. <ref type="foot" target="#foot_1">2</ref> Some more recent protocols also have proofs of security based on well-known cryptographic assumptions, in the random oracle model, e.g., <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b34">35]</ref>. Although these protocols (along with the protocols of <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b26">27]</ref>) are based on symmetric PAKE protocols, and the techniques used to convert the symmetric PAKE protocols into asymmetric PAKE protocols seem somewhat modular, no modular versions were ever presented, and there were no attempts to prove (in a modular way) anything about the techniques themselves. Each asymmetric PAKE protocol was presented in its entirety, and was proven secure from scratch. Note that no protocols for PAKE with resilience to server compromise have yet been proven secure without relying on random oracles.</p><p>Results. We were inspired by the PAK-Z protocol from MacKenzie <ref type="bibr" target="#b35">[36]</ref>, which is essentially the PAK protocol from <ref type="bibr" target="#b9">[10]</ref> modified using the "Z-method" to be resilient to server compromise. <ref type="foot" target="#foot_2">3</ref> While the Z-method was claimed to be a general technique, it was only described and analyzed with respect to the PAK protocol. We first show that the general Z-method does not provide resilience to server compromise by exhibiting an attack that exploits any instantiation using discrete-log based signature schemes. Next, we present a new method, called the Ω-method, that fixes the critical flaw in the Z-method. The Ω-method is the first general and modular technique that takes any secure symmetric PAKE scheme as a building block and converts it into one that is resilient to server compromise. The Ω-method is efficient and practical, essentially adding one extra round of communication and one signature generation/verification to the underlying symmetric PAKE scheme. <ref type="foot" target="#foot_3">4</ref>We prove security in the universal composability (UC) framework <ref type="bibr" target="#b10">[11]</ref> (in the random oracle model). A symmetric PAKE functionality F pwKE was recently introduced in <ref type="bibr" target="#b13">[14]</ref>. Our original plan was to (1) extend F pwKE into an asymmetric PAKE functionality F apwKE , and (2) prove that a protocol based on the Ω-method (which we call the Ω-protocol) securely realizes F apwKE in the F pwKEhybrid model. This would imply, by the universal composition theorem <ref type="bibr" target="#b10">[11]</ref>, that the Ω-protocol would be secure when instantiated with any secure symmetric PAKE scheme. For step <ref type="bibr" target="#b0">(1)</ref> we added notions of a server setting up a password record for the client and using that password record for each session, the notion of stealing the password file, and the notion of explicitly aborting. <ref type="foot" target="#foot_4">5</ref> Unfortunately, step (2) was problematic, since the Ω-method relies on the notion of a protocol transcript, which does not exist in the symmetric PAKE functionality of <ref type="bibr" target="#b13">[14]</ref>. Therefore, we added the notion of a transcript to the symmetric PAKE functionality to make a revised symmetric PAKE functionality F rpwKE , and completed step (2) using the F rpwKE -hybrid model. In Section 4 we discuss why adding this notion of a transcript is natural and does not have any substantial effect on whether a protocol securely realizes the functionality.</p><p>Applicability. Currently there is only one PAKE protocol that has been shown to securely realize the symmetric PAKE functionality F pwKE in the UC framework, specifically, the one of Canetti et al. <ref type="bibr" target="#b13">[14]</ref>. However, we conjecture that many of the PAKE protocols cited above that were proven secure in the random oracle model, but not in the UC framework, could also be proven secure in the UC framework. Since the Ω-protocol relies on the random oracle model anyway, it would make sense to combine it with these symmetric PAKE protocols to achieve (very efficient) asymmetric PAKE protocols. Thus the results of this paper should have wide applicability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Symmetric Encryption Schemes. A symmetric encryption scheme E is a pair (E, D) of algorithms, both running in polynomial time. E takes a symmetric key k and a message m as input and outputs an encryption c for m; we denote this c ← E k (m). D takes a ciphertext c and a symmetric key k as input and returns either a message m such that c is a valid encryption of m, if such an m exists, and otherwise returns ⊥.</p><p>We will use specific symmetric encryption schemes based on hash functions and one-time pads. <ref type="foot" target="#foot_5">6</ref> The first scheme is E k (m) = H(k) ⊕ m, where H() is a hash function with output that is the same length as m (and assumed to behave like a random oracle -see below) and where ⊕ is taken as a bit-wise exclusive OR operation. Note that this encryption scheme is inherently malleable. For instance, given a ciphertext c of an unknown message m under an unknown key k, one can construct a ciphertext c = c ⊕ 00 • • • 001 of a related message m = m⊕ 00 • • • 001 (i.e., m with the last bit flipped), without determining m.</p><p>The second scheme is</p><formula xml:id="formula_0">E k (m) = H(k) ⊕ m|H (m)</formula><p>, for a hash function H () (assumed to be one-way and to behave like a random oracle). The second hash protects against malleability since modifying the one-time pad portion requires recomputing the hash with the correct message, implying the message has been determined.</p><p>Hash functions. Cryptographic hash functions will be used for key generation and for producing verification values. Here we assume these functions are random oracles [4],<ref type="foot" target="#foot_6">7</ref> i.e., they behave like black-box perfectly random functions. In practice, one would need to verify that the actual hash function used is suitable to be used as a random oracle. See <ref type="bibr" target="#b3">[4]</ref> for a discussion on how to instantiate random oracles, and see <ref type="bibr" target="#b24">[25]</ref> for a discussion on key generation functions.</p><p>Signature schemes. A signature scheme S is a triple (Gen, Sig, Verify) of algorithms, the first two being probabilistic, and all running in (probabilistic) polynomial time. Gen S takes as input the security parameter (usually denoted as κ and represented in unary format, i.e., 1 κ ) and outputs a public-key pair (pk, sk), i.e., (pk, sk) ← Gen S (1 κ ). Sign takes a message m and a secret key sk as input and outputs a signature σ for m, i.e., σ ← Sig sk (m). Verify takes a message m, a public key pk, and a candidate signature σ for m as input and returns the bit b = 1 if σ is a valid signature for m for the corresponding private key, and otherwise returns the bit b = 0. That is, b ← Verify pk (m, σ ). Naturally, if σ ← Sig sk (m), then Verify pk (m, σ) = 1. We require signature schemes that are existentially unforgeable against chosen message attacks in the sense of <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Ω-Method</head><p>Basic Idea of the Ω-Method. Similar to some previous work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b35">36]</ref>, the Ω-method constructs an asymmetric PAKE protocol Ω by enhancing a symmetric PAKE protocol P as follows. First, the server only stores the output of a one-way function of the password, i.e., a value f (π) that is easy to compute from the password, but from which the password is difficult to compute. Then the protocol operates by first running the protocol P using f (π) in place of π, <ref type="foot" target="#foot_7">8</ref>and second having the client somehow prove knowledge of a π such that f (π) is the server's stored value.</p><p>The Ω-method uses the following specific instantiation of this basic idea. <ref type="foot" target="#foot_8">9</ref> The server stores a hash of the password H(π) to be used for the protocol P . The server also stores a public/secret key pair for a secure signature scheme, with the secret key encrypted using the specific encryption scheme (E , D ) defined above in which the key to the encryption scheme is the password. (Recall that this encryption scheme is a one-time pad concatenated to a cryptographic hash.) In all, the server stores (H(π), pk, E π (sk)). The protocol Ω first runs P (using H(π)). Once P is finished and has derived a cryptographically strong shared key K, the server uses a temporary session key K derived from K to securely send E π (sk) to the client, using the specific encryption scheme (E, D) defined above. (Recall that this encryption scheme is simply a one-time pad.) The client uses K and π to derive the appropriate keys, performs the necessary decryptions to obtain sk, and then creates a signature with sk on the transcript of P . In effect, this proves that the client (the one communicating with the server in protocol P ) knows π. The final output of Ω is another key K derived from K.</p><p>The Ω-method is very similar to the Z-method in <ref type="bibr" target="#b35">[36]</ref>. However, the Z-method specifies that both encryption schemes be simple one-time pads, which, as discussed previously, are malleable. Because of this, it can be shown that the Zmethod is insecure for certain signature schemes and in particular, for certain representations of the private key generated in certain signature schemes. In fact, the Z-method is not known to be secure for any signature scheme. In contrast, the Ω-method is secure for every signature scheme.</p><p>High-level description. A high-level description of the Ω-method is shown in Figure <ref type="figure" target="#fig_0">1</ref>, with some details given here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Client Part 1:</head><p>The client computes H(π) and performs its part in the symmetric PAKE protocol P using H(π), obtaining a shared cryptographic key K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Server Part 1:</head><p>The server performs its part in the symmetric PAKE protocol P using the value H(π) it had stored, obtaining a shared cryptographic key K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Server Part 2, Step 1:</head><p>The server first derives key K = H (K) and then sends E K (E π (sk)) to the client.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Client Part 2:</head><p>The client receives the value E K (E π (sk)) sent by the server, computes K = H (K), and decrypts using K and π to obtain sk. (If the decryption fails when checking the hash, the client aborts.) Then the client signs the transcript of P , using sk, i.e., it computes σ = Sig sk (transcript), and sends the result σ to the server. The client also derives a session key K from K (e.g., by using a cryptographic hash function K = H (K)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Server Part 2,</head><p>Step 2: Once it receives the signature σ, the server computes b = Verify pk (transcript, σ). If b = 1, then the server derives a session key K = H (K) and outputs it. Otherwise it aborts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Client(π)</head><p>S e r v e r ( H(π), (pk, E π (sk)))</p><p>Compute H(π) The advantage of the Ω-method over the Z-method was discussed above. The advantage of the Ω-method over other asymmetric PAKE protocols is that it is modular and general. The Ω-method allows an asymmetric PAKE protocol to be constructed using any PAKE protocol and any signature scheme, and these could be chosen based on which cryptographic assumptions are used to prove their security. For instance, one could choose a PAKE protocol and a signature scheme that are based on the same cryptographic assumption. Notice also that as opposed to asymmetric PAKE protocols in which the password is used to derive the secret key of a signature scheme, e.g., <ref type="bibr" target="#b34">[35]</ref>, the Ω-method has the advantage that the secret key does not need to be computed online by the client, a potentially expensive operation.</p><formula xml:id="formula_1">Symmetric PAKE: H(π) - Output: K Output: K Generate keys K and Generate keys K and K from K K from K Let c = E π (sk) sk ← D π (D K (c )) c c ← E K (c) s ← Sig sk (transcript) s -If ¬Verify pk (transcript, s), abort.</formula><p>As for efficiency, this method adds one extra round of communication along with a few hash operations, a signature calculation by the client, and a signature verification by the server, to the PAKE protocol P . The extra round of communication can often be piggybacked on actual protocol messages, as was shown for the PAK-Z protocol in <ref type="bibr" target="#b35">[36]</ref>. But there is still the extra computation involved with the signature. Some asymmetric PAKE protocols have been designed specifically to avoid this extra computation. SRP <ref type="bibr" target="#b48">[49]</ref> and AMP <ref type="bibr" target="#b32">[33]</ref> are two such protocols, but neither has a proof of security, even in the random oracle model.</p><p>The Z-Method and An Attack. The Z-method <ref type="bibr" target="#b35">[36]</ref> looks exactly like the Ωmethod, except that the encryption functions E and E are simply one-time pads. That is, E K (c) = K ⊕ c and E π (sk) = H(π) ⊕ sk. One problem with a one-time pad encryption scheme is that in the absence of an explicit integrity-verification mechanism, the resulting ciphertext is malleable. This leads to an attack on the PAKE protocol. In particular, suppose that the Z-method is instantiated using a discrete logarithm based signature scheme (e.g., Schnorr, DSS, El-Gamal, signature schemes based on bilinear pairings, etc.). In a typical instantiation of such a scheme, we would have (sk, pk) = (x, y) be the signing and verification keys respectively, where y = g x and g is a generator for a (multiplicative) group in which the discrete logarithm problem is believed to be intractable. Now, consider an active adversary who flips the least significant bit of the server's response c . When the client decrypts, he will either compute that sk = x + 1 (if the least significant bit of x were a 0) or x -1 (or if the least significant bit of x were a 1). The client signs the transcript using the computed signing key. The adversary verifies the signature using yg as the public verification key. If it verifies correctly, then he deduces that the least significant bit of x was 0; otherwise he deduces that it is 1. The adversary can repeat an analogous procedure |x| times to determine the remaining bits of x. Since |x| is typically much smaller than the dictionary of possible passwords, we violate the security requirements of the protocol.</p><p>Evaluation of Security. We wish to prove that the Ω-method can be combined with any (symmetric) PAKE protocol to yield an asymmetric PAKE protocol. It is often very difficult to prove such general statements. However, by using the Universal Composability (UC) framework of Canetti <ref type="bibr" target="#b10">[11]</ref>, this type of proof, while still very complicated, becomes much easier. We assume the reader is familiar with the UC framework. We remark that we focus on static adversaries that cannot corrupt parties during the execution.<ref type="foot" target="#foot_9">10</ref> (However, our asymmetric PAKE functionality includes a notion of an adversary stealing a password file.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Password-Based Key Exchange Functionalities</head><p>The original symmetric PAKE functionality. We first consider the original symmetric PAKE functionality F pwKE from Canetti et al. <ref type="bibr" target="#b13">[14]</ref> and presented in Figure <ref type="figure">2</ref>. <ref type="foot" target="#foot_10">11</ref> The functionality is similar to that of the standard key exchange functionality F KE given in Canetti <ref type="bibr" target="#b10">[11]</ref>. In the F KE functionality, the parties that start a session receive the same uniformly-distributed session key, except when one of the parties is corrupted, in which case the adversary has the power to set the session key. In the F pwKE functionality, each party starting a session is given a password as input from the environment, and the power to set the session key for a party is also given to the adversary if it succeeds in guessing the password used by that party. When the adversary guesses the password, the party's session is marked compromised. An additional property of the definition is that a failed attempt at guessing a party's password is detected. This results in the session being marked interrupted and the party receiving an independent uniformly-distributed session key.</p><p>A session that is neither compromised nor interrupted (and is still in progress) is considered fresh. Such sessions (between honest parties) conclude with both parties receiving the same, uniformly-distributed session key if they were given the same password as input from the environment, and otherwise with the parties receiving independent uniformly-distributed session keys. In any case, once a party receives a session key, that session is marked completed.</p><p>Two enhancements to the original symmetric PAKE functionality. We describe two enhancements, transcripts and explicit authentication, to the original F pwKE functionality <ref type="bibr" target="#b13">[14]</ref>.</p><p>Transcripts. The main problem with building a secure asymmetric PAKE protocol using the F pwKE functionality is that there is no way to indicate to the environment through the F pwKE functionality whether the two sessions (one for each party) involved in the key exchange are both fresh. <ref type="foot" target="#foot_11">12</ref> Note that extending the functionality with queries that output the state of each session (i.e., fresh or compromised) is ineffective since a real party would not know individually if its session was fresh or compromised, and thus could not output such an indication. <ref type="foot" target="#foot_12">13</ref> Thus allowing such a query in the ideal world makes it distinguishable from the real world.</p><p>Instead, we extend the functionality in the following way. Once a session is complete, the adversary may query the functionality with an extra value tr, which is output to the party as long as it meets the following condition: If either of the two sessions in the key exchange is not fresh, then the tr values output to each party must not be equal.</p><p>Since the query is not mandatory, any protocol that securely realizes F pwKE will securely realize the functionality extended in this way. We conjecture something stronger, in that any protocol that securely realizes F pwKE and in which each party is fresh and outputs a key if the adversary simply forwards messages between two parties in a session, and a party is not fresh if the adversary sends a message not output as the next message by the other party in a session, can be modified to securely realize the extended F pwKE functionality, in which each party outputs the tr value immediately after it outputs a key. The modification is to simply have each party output its transcript as tr once it has completed. Assuming the ideal adversary simulates the real protocol by running</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functionality F pwKE</head><p>The functionality F pwKE is parameterized by a security parameter κ. It interacts with an adversary S and a set of parties via the following queries:</p><p>Upon receiving a query (NewSession, sid, Pi, Pj , π, role) from party Pi:</p><p>Send (NewSession, sid, Pi, Pj , role) to S. In addition, if this is the first NewSession query, or if this is the second NewSession query and there is a record (Pj , Pi, π ), then store record (Pi, Pj, π) and mark this record fresh. Upon receiving a query (TestPwd, sid, Pi, π ) from the adversary S:</p><p>If there is a record of the form (Pi, Pj , π) which is fresh, then do: If π = π , mark the record compromised and reply to S with "correct guess". If π = π , mark the record interrupted and reply with "wrong guess". Upon receiving a query (NewKey, sid, Pi, k) from S, where |k| = κ:</p><p>If there is a record of the form (Pi, Pj , π), and this is the first NewKey query for Pi, then:</p><p>• If this record is compromised, or either Pi or Pj is corrupted, then output (sid, k) to player Pi.</p><p>• If this record is fresh, and there is a record (Pj, Pi, π ) with π = π, and a key k was sent to Pj , and (Pj , Pi, π) was fresh at the time, then output (sid, k ) to Pi.</p><p>• Any other case: pick new random key k (|k | = κ); send (sid, k ) to Pi.</p><p>Either way, mark the record (Pi, Pj, π) as completed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. The password-based key-exchange functionality F pwKE</head><p>a simulated real protocol with the real adversary, the ideal adversary could also output the transcript of a simulated session, and this obviously would preserve indistinguishability between the ideal world and real world.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Explicit Authentication.</head><p>Although not critical to building an asymmetric PAKE functionality, the F pwKE functionality has another limitation in that it does not allow for some common types of explicit authentication. Specifically, a protocol that performs explicit authentication and aborts if the authentication fails, and otherwise sends one more message, will not securely realize the F pwKE functionality. Intuitively this is because an ideal adversary could not learn from the functionality whether the explicit authentication should be successful, and so could only guess whether to send the final message. (This would be easily distinguishable from the real protocol.) To allow for this type of authentication, one can add a new "test abort" query that tests whether the authentication would fail, informs the simulator, and informs the environment that the session is aborting in case of an authentication failure. A feature similar to this is mentioned in <ref type="bibr" target="#b13">[14]</ref>, in which the ideal adversary is notified if passwords for the two parties in a session do not match. This is claimed (rightly so) to weaken the definition, especially since an eavesdropper may not learn this. However, we are interested only in the case where the eavesdropper does learn this information, by noticing whether the protocol aborts or not. Thus in some sense we also "weaken" the definition of PAKE, but in a way that makes sense and allows some natural PAKE protocols (secure according to, say, an indistinguishability-based definition of PAKE) to securely realize the (extended) PAKE functionality. As above, since the "test abort" query is not mandatory, any protocol that securely realizes F pwKE will securely realize the functionality extended in this way; i.e., this extended functionality does not imply a protocol must have explicit authentication, but only allows for it.</p><p>The Revised Symmetric PAKE Functionality. Figure <ref type="figure" target="#fig_2">3</ref> describes our revised symmetric password-based key exchange functionality called F rpwKE that includes a transcript query as discussed above, but not a test abort query. <ref type="foot" target="#foot_13">14</ref> More specifically, the revised functionality F rpwKE is exactly F pwKE (with a minor wording change in NewKey that has no effect on the F pwKE ), but with NewTranscript queries added. We note that it is possible to prove that a protocol securely realizing F rpwKE also is secure according to the definition of <ref type="bibr" target="#b2">[3]</ref>.</p><p>Asymmetric PAKE functionalities. Now we discuss our asymmetric PAKE functionality F apwKE , which is presented in Figure <ref type="figure">4</ref>. At a high level, this functionality expands on the F pwKE functionality to allow a server to store password data, and then use this stored password data for authentication instead of a password received as input from the environment. This functionality also accounts for the possibility that password data may be stolen by the adversary.</p><p>As discussed above, this allows the adversary to perform an offline dictionary attack. <ref type="foot" target="#foot_14">15</ref> It also allows the adversary to impersonate the server, but not the client. In more detail, the changes are as follows.</p><p>-The F pwKE functionality was a single-session functionality. However, asymmetric PAKE requires that a password file be used across multiple sessions, so we define the F apwKE functionality as a multiple-session functionality.</p><p>Note that this cannot be accomplished simply using "composition with joint state" <ref type="bibr" target="#b14">[15]</ref> because the functionality itself requires shared state that needs to be maintained between sessions.</p><p>-In F pwKE , sessions are started by sending NewSession queries to two parties, including a password in each query. In F apwKE , these queries are replaced with CltSession and SvrSession queries. The CltSession queries include a password, but the SvrSession queries do not. The server password is taken from the password file, which is placed on the server using a StorePWfile query that includes the password. Note that if the server is corrupted when it receives</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functionality F rpwKE</head><p>The functionality F rpwKE is parameterized by a security parameter κ. It interacts with an adversary S and a set of parties via the following queries:</p><p>Upon receiving a query (NewSession, sid, Pi, Pj , π, role) from party Pi: Send (NewSession, sid, Pi, Pj , role) to S. In addition, if this is the first NewSession query, or if this is the second NewSession query and there is a record (Pj, Pi, π ), then record (Pi, Pj , π) and mark this record fresh. Upon receiving a query (TestPwd, sid, Pi, π ) from the adversary S:</p><p>If there is a record of the form (Pi, Pj , π) which is fresh, then do: If π = π , mark the record compromised and reply to S with "correct guess". If π = π , mark the record interrupted and reply with "wrong guess". Upon receiving a query (NewKey, sid, Pi, k) from S, where |k| = κ:</p><p>If there is a record of the form (Pi, Pj, π) that is not marked completed, then:</p><p>• If this record is compromised, or either Pi or Pj is corrupted, then output (sid, k) to player Pi.</p><p>• If this record is fresh, and there is a record (Pj, Pi, π ) with π = π, and a key k was sent to Pj , and (Pj , Pi, π) was fresh at the time, then output (sid, k ) to Pi.</p><p>• In any other case, pick a new random key sk of length κ and send (sid, k ) to Pi.</p><p>Either way, mark the record (Pi, Pj, π) as completed. Upon receiving a query (NewTranscript, sid, Pi, tr) from S:</p><p>If there is a record of the form (Pi, Pj, π) that is marked completed, then:</p><p>• If (1) there is a record (Pj, Pi, π ) for which tuple (transcript, sid, tr ) was sent to Pj , (2) either (Pi, Pj , π) or (Pj , Pi, π ) was ever compromised or interrupted, and (3) tr = tr , ignore the query.</p><p>• In any other case, send (transcript, sid, tr) to Pi.</p><p>Fig. <ref type="figure" target="#fig_2">3</ref>. The revised password-based key-exchange functionality F rpwKE this query, then the adversary learns the password. However, a trusted initial setup between the client and server is generally assumed, so this would not be a problem. 16 -In F apwKE , the adversary may "steal" the server's password data using a StealPWfile query. No actual data is sent to the adversary, but after this the adversary may make queries to test passwords using OfflineTestPwd queries. These queries are "offline" as they do not correspond to any sessions. The OfflineTestPwd queries may actually be made either before or after the StealPWfile query, but queries made before are not answered until the StealPWfile query is made. Specifically, when a StealPWfile query is made, if way Corrupt queries are accounted for. <ref type="foot" target="#foot_16">17</ref> Specifically, a StealPWfile query by the adversary is not allowed until the environment sends a StealPWfile message to the adversary, <ref type="foot" target="#foot_17">18</ref> and similarly, each OfflineTestPwd query by the adversary is not allowed until the environment sends an OfflineTestPwd message to the adversary. It is easy to see that the composition theorem holds despite these changes. <ref type="foot" target="#foot_18">19</ref>-In F apwKE , in addition to TestPwd queries, an adversary can also make an Impersonate query to compromise a client session without supplying a password. This will succeed if there has already been a StealPWfile query. -We add the TestAbort query to F apwKE . The main reason is that our asymmetric PAKE protocol specifies some verifications, where an instance will abort if a verification fails. As discussed above, the F pwKE would need an extension to handle this type of protocol. -In contrast to F rpwKE , we did not include a transcript query in F apwKEprimarily because our proofs did not need it. The query could be added, and our asymmetric PAKE protocol could be modified to output a transcript.</p><p>Finally, in F apwKE , we assume that a given sid is unique to a given client/server pair for which the server stores a password. We also assume that a given(sid, ssid) pair is unique to a given session between the client and server corresponding to sid. These assumptions are valid in the UC framework, as discussed in <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">The Ω Protocol and Its Security</head><p>We present the Ω-protocol in the UC framework in Figure <ref type="figure" target="#fig_3">6</ref>. It uses the revised password-based key exchange functionality F rpwKE defined in Figure <ref type="figure" target="#fig_2">3</ref> and the random oracle functionality F RO defined in Figure <ref type="figure" target="#fig_1">5</ref>. <ref type="foot" target="#foot_19">20</ref> The random</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functionality F RO</head><p>The functionality F RO is parameterized by an (implicit) output length .</p><p>Upon receiving query (Hash, sid, msg) from any party P or adversary S: If a tuple (msg, r) is stored, return r; else, generate r R ← {0, 1} . Record (msg, r) and return r. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol Steps:</head><p>1. When Pj receives input (SvrSession, sid, ssid, Pi), he obtains r from the tuple stored in file[sid] (aborting if this value is not properly defined), sends (NewSession, sid, ssid , Pj , Pi, r, server) to the F rpwKE functionality, and awaits a response. 2. When Pi receives input (CltSession, sid, ssid, Pj, w), he sends (Hash, sid, 1 , w) to the functionality F RO and obtains the response r. He then sends (NewSession, sid, ssid , Pi, Pj , r, client) to the F rpwKE functionality and awaits a response. to the F RO functionality, and receives the response kw. He computes sk = kw ⊕ c1, sends (Hash, sid, 3 , sk) to F RO , receives response h sk , and verifies that h sk = c2. If not, he outputs (abort, sid, ssid ) and terminates the session. Otherwise he computes s = Sig sk ( sid, ssid, tr ), sends (flow-one, sid, ssid, s) to Pj, outputs (sid, ssid, k ), and terminates the session. 6. When Pj receives a message (flow-one, sid, ssid, s), he checks that Verify pk ( sid, ssid, tr , s) = 1. If not, he outputs (abort, sid, ssid ) and terminates the session. Otherwise, he outputs (sid, ssid, k ), and terminates the session.</p><p>Stealing the password file: When Pj (who is a server) receives a message (StealPWfile, sid, Pj, Pi), from the adversary A, if file[sid] is defined, Pj sends it to A. oracle functionality is parameterized by an output length , and for simplicity, this argument is implicit (albeit different depending on how the random oracle is being used). In particular if the arguments are sid, 1 , sid, 3 , sid, ssid, 2 , then the output length = κ. If the arguments are sid, 2 , then = |sk|. Finally, if the arguments are sid, ssid, 1 , then = |c| (i.e., the size of the ciphertext being encrypted). When applying the Ω-method in the UC framework to obtain the protocol Ω, there were some issues that needed to be addressed.</p><p>-In the Ω-protocol, one must use (sid, ssid, tr) in place of the transcript of the symmetric PAKE protocol. This pair (sid, ssid) is unique to a given pair of client/server instances, and these two instances only generate the same tr if they are fresh and use the same password. This is exactly what is needed in the proof of security, in particular, to ensure that a signature produced by a client cannot be used to impersonate a client in another session. -We had wanted to use an ideal signature functionality instead of an explicit signature scheme. However, this does not seem possible, since the Ω-protocol explicitly encrypts and hashes the signing key, but the ideal signature functionality doesn't have any notion of a secret key. -Similarly, it does not seem possible to use an ideal secure channel functionality in place of the symmetric encryptions, because keys are generated using a hash function. The ideal secure channel functionality does not have any notion of a secret key.</p><p>The following theorem characterizes the security of the Ω protocol and is proven in the full version of this paper.</p><p>Theorem 1. Assume that S is an existentially unforgeable signature scheme. Then protocol Ω of Figure <ref type="figure" target="#fig_3">6</ref> securely realizes the F apwKE functionality in the F rpwKE , F RO -hybrid model, in the presence of static-corruption adversaries.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1.The Ω-method: Augmenting a PAKE protocol to make it resilient to server compromise</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. The random oracle functionality</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>3 .</head><label>3</label><figDesc>When Pj (who is a server and is awaiting a response from F rpwKE ) receives responses ( sid, ssid , k) and (transcript, sid, ssid , tr), he does the following. First he sends (Hash, sid, ssid, d , k) for d ∈ {1, 2} to receive responses k and k respectively. Then he retrieves c from the tuple file[sid]. He encrypts c = k ⊕ c and sends the message (flow-zero, sid, ssid, c ) to Pi. 4. When Pi (who is a client and is also awaiting a response from F rpwKE ) receives responses ( sid, ssid , k) and (transcript, sid, ssid , tr), he sends (Hash, sid, ssid, d , k) for d ∈ {1, 2} to the F RO functionality, and receives responses k and k respectively. 5. When Pi receives a message (flow-zero, sid, ssid, c ) he computes the decryption c = k ⊕c , and parses c = (c1, c2). He then sends (Hash, sid, 2 , w)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. The UC Asymmetric PAKE Protocol Using the Ω-method</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>From the many recent reports of theft of credit cards and other personal information from e-commerce servers, it seems that compromise of a server is a real threat.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>There has also been work on protecting the server password file using threshold techniques, e.g.,<ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b37">38]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Previous to PAK-Z, there were PAK-X and PAK-Y protocols, with their own methods for modifying PAK to be resilient to server compromise.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>As a result of this work, the PAK-Z protocol in the IEEE P1363.2 (Password-based Public-Key Cryptography) proposed standard has had the Z-method replaced with the Ω-method to provide resilience to server compromise.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>We do not consider the notion of explicitly aborting to be necessary for an asymmetric PAKE functionality, but it is very convenient and allows some natural protocols (including our protocol) to securely realize the functionality. There is more discussion on this notion in Section 4.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Proving security using generic encryption schemes is left as an open problem.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>We stress that whether schemes proven secure in the random oracle model can be instantiated securely in the real world (i.e., with polynomial-time computable functions in place of random oracles) is uncertain<ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b38">39]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>We always assume a password protocol takes an arbitrary length password string, and thus would work correctly with f (π) in place of π.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>Note that for security we require that the hash and encryption functions used by the Ω-method are not used by the underlying symmetric PAKE protocol P .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>Nevertheless, as was shown in<ref type="bibr" target="#b13">[14]</ref>, this implies the "weak corruption" model of<ref type="bibr" target="#b2">[3]</ref> in which passwords can be adaptively obtained.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>Note that the variable names in the functionality have been slightly modified for consistency with protocols that we present later.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>This seems critical, since after a password file compromise, it seems the adversary could compromise both client and server sessions in any symmetric PAKE functionality using the information obtained from the password file. (According to the F pwKE functionality, this would even allow the adversary to set the session keys between himself and each party to be the same.) As a man-in-the middle, he could simply forward the remaining messages between client and server sessions to complete the asymmetric PAKE protocol.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_12"><p><ref type="bibr" target="#b12">13</ref> A party may know if its session "succeeded" or not, but both fresh and compromised sessions may be successful.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_13"><p>The test abort query is omitted since it is not integral to our result. A test abort query is included in our asymmetric PAKE functionality because it is necessary there to handle explicit aborting in our Ω-protocol. However, the transcript query is omitted there because it is not integral to our result.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_14"><p>Note that because this functionality accounts for each offline password guess individually, it seems to require the random oracle model (or some similar idealized model) to be securely realized.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_15"><p>If one is concerned about this, then one could possibly change the StorePWfile to contain some data (perhaps a one-way function of the password), along with a way to verify passwords against this data. Our work focuses on the issue of password file compromise, so we did not explore these other issues.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_16"><p>In fact, we could define these queries as Corrupt queries with certain parameters, which are handled by the functionality in certain specific ways, but we felt it was more clear to make them separate queries.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_17"><p>Technically, this is enforced by the "control function" (see<ref type="bibr" target="#b10">[11]</ref>).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="19" xml:id="foot_18"><p>This is assuming that these messages are based on sid values, and the sid values used in the original and emulating protocol somehow correspond. This is the case, but we need to define it explicitly.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="20" xml:id="foot_19"><p>Note in particular that F rpwKE has no access to F RO , and thus a protocol securely realizing F rpwKE should have no access to F RO .</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Functionality F apwKE</head><p>The functionality F apwKE is parameterized by a security parameter κ. It interacts with an adversary S and a set of parties via the following queries: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Password storage and authentication sessions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Stealing password data</head><p>Upon receiving a query (StealPWfile, sid) from adversary S:</p><p>If there is no password data record, reply to S with "no password file". Otherwise, do the following. If the password data record (file, Pi, Pj , π) is marked uncompromised, mark it as compromised. If there is a tuple (offline, π ) stored with π = π , send π to S, otherwise reply to S with "password file stolen". Upon receiving a query (OfflineTestPwd, sid, π ) from adversary S:</p><p>If there is no password data record, or if there is a password data record (file, Pi, Pj , π) that is marked uncompromised, then store (offline, π ). Otherwise, do: If π = π , reply to S with "correct guess". If π = π , reply with "wrong guess".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Active session attacks</head><p>Upon receiving a query (TestPwd, sid, ssid, P, π ) from adversary S:</p><p>If there is a session record of the form (ssid, P, P , π) which is fresh, then do: If π = π , mark the record compromised and reply to S with "correct guess". Otherwise, mark the record interrupted and reply with "wrong guess". Upon receiving a query (Impersonate, sid, ssid) from adversary S:</p><p>If there is a session record of the form (ssid, Pi, Pj , π) which is fresh, then do: If there is a password data record (file, Pi, Pj , π) that is marked compromised, mark the session record compromised and reply to S with "correct guess", else mark the session record interrupted and reply with "wrong guess".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Key Generation and Authentication</head><p>Upon receiving a query (NewKey, sid, ssid, P, k) from S, where |k| = κ: If there is a record of the form (ssid, P, P , π) that is not marked completed, then:</p><p>• If this record is compromised, or either P or P is corrupted, then output (sid, ssid, k) to P .</p><p>• If this record is fresh, there is a session record (ssid, P , P, π ), π = π, a key k was sent to P , and (ssid, P , P, π) was fresh at the time, then let k = k , else pick a random key k of length κ. Output (sid, ssid, k ) to P .</p><p>• In any other case, pick a random key k of length κ and output (sid, ssid, k ) to P . Finally, mark the record (ssid, P, P , π) as completed. Upon receiving a query (TestAbort, sid, ssid, P ) from S:</p><p>If there is a record of the form (ssid, P, P , π) that is not marked completed, then:</p><p>• If this record is fresh, there is a record (ssid, P , P, π ), and π = π, let b = succ.</p><p>•  We also change the UC framework slightly to allow the queries StealPWfile and OfflineTestPwd to be accounted for by the environment, similar to the</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Simple Password-Based Encrypted Key Exchange Protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abdalla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RSA Conference, Cryptographer&apos;s Track</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="191" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Protocol initialization for the framework of universal composability</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="m">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2004">2004/006. 2004</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Authenticated key exchange secure against dictionary attacks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="139" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1st ACM Conference on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Entity authentication and key distribution</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="232" to="249" />
		</imprint>
		<respStmt>
			<orgName>CRYPTO</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Uninstantiable Random-Oracle-Model Scheme for a Hybrid-Encryption Problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Palacio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="171" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Encrypted key exchange: Password-based protocols secure against dictionary attacks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Bellovin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Merritt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symp. on Research in Security and Privacy</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="72" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Augmented encrypted key exchange: A passwordbased protocol secure against dictionary attacks and password file compromise</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Bellovin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Merritt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1st ACM Conf. on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="244" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Bleichenbacher</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Personal communication</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Provably secure password authentication and key exchange using Diffie-Hellman</title>
		<author>
			<persName><forename type="first">V</forename><surname>Boyko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="156" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Universally Composable Security: A New Paradigm for Cryptographic Protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="m">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2000">2000/067. 2005</date>
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the random-oracle methodology as applied to length-restricted signature schemes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography Conference -TCC</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="40" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The random oracle methodology, revisited</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="557" to="594" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Universallycomposable password-based key exchange</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="404" to="421" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Universal Composition with Joint State In CRYPTO</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="265" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Provably Secure Threshold Password Authenticated Key Exchange</title>
		<author>
			<persName><forename type="first">M</forename><surname>Di Raimondo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="507" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Server-assisted generation of a strong secret from a password</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">S</forename><surname>Kaliski</surname><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Framework for Password-Based Authenticated Key Exchange</title>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="524" to="543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Password Authenticated Key Exchange Using Hidden Smooth Subgroups</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ramzan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th ACM Conf. on Computer and Communications Security</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="299" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Session-Key Generation using Human Passwords Only</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="408" to="432" />
		</imprint>
		<respStmt>
			<orgName>CRYPTO</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A digital signature scheme secure against adaptive chosen-message attacks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="1988-04">April 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the (In)security of the Fiat-Shamir Paradigm</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Tauman</forename><surname>Kalai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">44th IEEE Symp. on Foundations of Computer Science (FOCS)</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="102" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimal authentication protocols resistant to password guessing attacks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="24" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Protecting poorly chosen secrets from guessing attacks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M A</forename><surname>Lomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Saltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="648" to="656" />
			<date type="published" when="1993-06">June 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m">IEEE Standard 1363-2000, Standard specifications for public key cryptography</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Strong password-only authenticated key exchange</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jablon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="5" to="20" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
	<note>ACM SIGCOMM</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Extended password key exchange protocols immune to dictionary attack</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jablon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WETICE&apos;97 Workshop on Enterprise Security</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Password authentication using multiple servers</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jablon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. RSA Conference, Cryptographer&apos;s Track</title>
		<meeting>RSA Conference, Cryptographer&apos;s Track</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Password based key exchange with mutual authentication</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Selected Areas of Cryptography (SAC)</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Two-Server Password-Only Authenticated Key Exchange</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taban</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gligor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applied Cryptography and Network Security, 3rd Intl. Conf. (ACNS 2005)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Practical password-authenticated key exchange provably secure under standard assumptions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="475" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">PDM: A New Strong Password-Based Protocol</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Perlman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th Usenix Security Symposium</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Authentication and Key Agreement via Memorable Passwords</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kwon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Internet Society Network and Distributed System Security Symposium (NDSS)</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Open key exchange: How to defeat dictionary attacks without encrypting public keys</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lucks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Workshop on Security Protocols</title>
		<meeting>of the Workshop on Security Protocols</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">More Efficient Password-Authenticated Key Exchange</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RSA Conference, Cryptographer&apos;s Track</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="361" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The PAK suite: Protocols for password-authenticated key exchange</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DIMACS Technical Report</title>
		<imprint>
			<date type="published" when="2002-10-46">2002-46, October, 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Password authenticated key exchange based on RSA</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Swaminathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="599" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Threshold Password-Authenticated Key Exchange</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shrimpton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jakobsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="66" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Indifferentiability, Impossibility Results on Reductions, and Applications to the Random Oracle Methodology</title>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Renner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Holenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography Conference -TCC</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="21" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Fast Dictionary Attacks on Passwords Using Time-Space Tradeoff</title>
		<author>
			<persName><forename type="first">A</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conf. on Computer and Communications Security (CCS)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="364" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Announcing the Secure Hash Standard</title>
	</analytic>
	<monogr>
		<title level="j">FIPS</title>
		<imprint>
			<biblScope unit="volume">180</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1995-04">April, 1995</date>
			<publisher>U.S. Department of Commerce</publisher>
		</imprint>
		<respStmt>
			<orgName>National Institute of Standards and Technology (NIST</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Simpler Session-Key Generation from Short Random Passwords</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography Conference -TCC</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="428" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Separating Random Oracle Proofs from Complexity Theoretic Proofs: The Non-Committing Encryption Case Jesper Buus Nielsen</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Nielsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="111" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Making a faster cryptanalytic time-memory trade-off</title>
		<author>
			<persName><forename type="first">P</forename><surname>Oechslin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="617" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Number theoretic attacks on secure password schemes</title>
		<author>
			<persName><forename type="first">S</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Research in Security and Privacy</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="236" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Security proofs for signature schemes</title>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EURO-CRYPT</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="387" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Efficient identification and signatures for smart cards</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Schnorr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="235" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Refinement and extension of encrypted key exchange</title>
		<author>
			<persName><forename type="first">M</forename><surname>Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Operating System Review</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="22" to="30" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The secure remote password protocol</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Internet Society Network and Distributed System Security Symposium (NDSS)</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="97" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">A real-world analysis of Kerberos password security</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Internet Society Network and Distributed System Security Symposium (NDSS)</title>
		<imprint>
			<date type="published" when="1999-02">February 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">New Approaches to Password Authenticated Key Exchange Based on RSA</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="230" to="244" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
