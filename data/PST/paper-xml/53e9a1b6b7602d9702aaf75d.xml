<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Public-Key Cryptography from Different Assumptions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Benny</forename><surname>Applebaum</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Boaz</forename><surname>Barak</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Avi</forename><surname>Wigderson</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Weizmann Institute of Science Rehovot</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Princeton University</orgName>
								<address>
									<settlement>Princeton</settlement>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Institute for Advanced Study Princeton</orgName>
								<address>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Public-Key Cryptography from Different Assumptions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DF7B36EA0322CE9D1322E128C4BCE730</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Public key cryptosystems; F.2.2 [Nonnumerical Algorithms and Problems]: Computations on discrete structures Algorithms</term>
					<term>Security</term>
					<term>Theory 3LIN</term>
					<term>Densest Subgraph Problem</term>
					<term>Expander Graphs</term>
					<term>Learning Juntas</term>
					<term>Learning Parity with Noise</term>
					<term>NC0</term>
					<term>Public Key Cryptography</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper attempts to broaden the foundations of publickey cryptography. We construct new public-key encryption schemes based on new hardness-on-average assumptions for natural combinatorial NP-hard optimization problems. We consider the following assumptions:</p><p>1. It is infeasible to solve a random set of sparse linear equations mod 2, of which a small fraction is noisy.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>2. It is infeasible to distinguish between a random unbalanced bipartite graph, and such a graph in which we "plant" at random in the large side a set S with only |S|/3 neighbors.</p><p>3. There is a pseudorandom generator in NC 0 where every output depends on a random constant-size subset of the inputs.</p><p>We obtain semantically secure public-key encryption schemes based on several combinations of these assumptions with different parameters. In particular we obtain public-key encryption from Assumption 1 on its own, yielding the first noisy-equations type public-key scheme in which the noise rate is higher than one over the square root of the number of equations. We also obtain public-key encryption based on a combination of Assumptions 2 and 3. These are arguably of more "combinatorial"/"private-key" nature than any assumptions used before for public-key cryptography. Our proof involves novel "search to decision" and "search to prediction" reductions for sparse noisy linear equations.</p><p>The strength of our assumptions raise new algorithmic and pseudorandomness questions (and new parameters for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Public key encryption (PKE) is a central notion in cryptography, and many of the exciting cryptographic applications in theory and practice are based on it. But despite 30+ years of research, very few candidates for such encryptions are known, and these are based on a handful of computational problems of a very structured algebraic or geometric nature, from the areas of number theory, lattices, and errorcorrecting codes (e.g., <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b52">52,</ref><ref type="bibr" target="#b40">40,</ref><ref type="bibr" target="#b3">3]</ref>). This leaves open the troublesome possibility that a new mathematical breakthrough could render them insecure.</p><p>In this aspect public-key cryptography ("cryptomania" in the language of Impagliazzo <ref type="bibr" target="#b29">[29]</ref>) seems very different from private key cryptography ("minicrypt") where many different candidates exist, and can be based on seemingly much less structured combinatorial problems including natural averagecase variants of NP-complete problems such as random 3-SAT <ref type="bibr" target="#b1">[1]</ref>, planted clique <ref type="bibr" target="#b32">[32]</ref>, and learning parity with noise <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b11">11]</ref>. <ref type="foot" target="#foot_0">1</ref> Thus a major goal of cryptography is to base public-key encryption on assumptions that are weaker, or at least different, than those currently used.</p><p>A complete solution to this problem would be obtained by constructing public key encryption based solely on the existence of one-way functions. This is a longstanding open problem, and cannot be achieved via black-box reductions <ref type="bibr" target="#b30">[30]</ref>. Short of that, we believe that major progress would be made by a construction of public key encryption based on a natural and well-studied average-case variant of an NP-complete problem. This paper is a step in this direction.</p><p>In this work we give constructions of a public key encryption based on different assumptions about the hardness of combinatorial problems (e.g., satisfying random local constraints and detecting graph expansion). The proposed systems are not as efficient as some known candidate constructions, and are based on assumptions that are not as wellstudied as, say, the hardness of factoring. For this reason we initiate here a study of the algorithmic and pseudorandomness questions which arise, relate them to known results, and obtain some preliminary new ones.</p><p>The main advantage of the new schemes is the relatively general and unstructured nature of the new assumptions. These include a variant of the planted densest subgraph problem, a pseudorandom generator based on the expander-based one-way function of Goldreich <ref type="bibr" target="#b24">[24]</ref> (a private-key primitive), and the 3LIN problem which can be seen as a sparse variant of the learning parity with noise problem with noise level much higher than those used before in public-key cryptography (in particular larger than 1/ √ m, see Footnote 1). These seem qualitatively different than previous assumptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Structure of the paper.</head><p>Section 2 contain somewhat informal statements of our results and some discussion on their implications and relation to prior works. Section 3 contains a description of our scheme and a high level overview of the proofs of our main results. Section 4 contains formal statements of the main results as well as some proof outlines. A preliminary full version of this paper is available on the authors' home page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">OUR RESULTS AND RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">New cryptosystems</head><p>We say that a bipartite graph G is an (m, n, d)-graph, if it has m vertices on one side (which we call the "top" side), n vertices on the other side (called the "bottom"), and every top vertex has degree d. Similarly, an (m, n, d)-matrix is an m × n matrix over GF <ref type="bibr" target="#b2">(2)</ref>, in which every row has d entries of value 1. Roughly speaking, we consider the following assumptions (see Section 4 for precise statements):</p><formula xml:id="formula_0">Assumption dLIN(m, ε) It is infeasible to recover x from (A, Ax + e),</formula><p>where A is a random (m, n, d) matrix, x is chosen randomly from GF(2) n , and e ∈ GF(2) m is chosen such that ei = 1 with probability ε independently for every i.</p><p>Assumption DUE(m, q, d) (Decisional Unbalanced Expansion) It is infeasible to distinguish between: (a) a ran-This seems to make a qualitative difference. Some evidence for this is the fact that for ε &lt; 1/ √ m LWE can be solved in SZK <ref type="bibr" target="#b25">[25]</ref> and even (a suitable promise problem variant of) NP ∩ coNP <ref type="bibr" target="#b2">[2]</ref>, while in the worst-case these problems are NP-hard for sufficiently large noise <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b20">20]</ref>. dom (m, n, d)-graph and (b) a random (m, n, d) graph in which the edges going out of a random q-sized subset S of the top vertices are modified to ensure S will have only q/3 neighbors. In all of the above, "infeasibility" and "pseudorandomness" are defined with respect to probabilistic polynomial time (PPT) algorithms with some constant success probability (e.g., 0.99). The parameters m, d, q, ε can be functions of n. We construct three public-key encryption schemes each based on a different combination of the above assumptions:</p><formula xml:id="formula_1">Theorem 1. For every constants c &gt; 0 and function m = m(n), d = d(n), if both Assumptions DUE(m, c log n, d)</formula><p>and DSF(m, d) hold then there exists a semantically secure public key encryption.</p><p>Both the DUE and DSF assumptions are arguably much more "combinatorial" and of a "private key" nature than any assumptions used before to construct public-key cryptography. DSF assumes that a variant of Goldreich's candidate one-way function is a pseudorandom generator-a strong assumption but still of a "private key" nature. DUE is closely related to the densest subgraph problem-a combinatorial optimization problem of independent interest <ref type="bibr" target="#b22">[22,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr" target="#b7">7]</ref>.</p><p>Indeed, we can look at an (m, n, d)-graph G as a d-uniform hypergraph H of n vertices and m hyperedges, where the i-th hyperedge of H contains the d neighbors of the i-th top-vertex of G. In this formulation, the DUE assumption is about the hardness of distinguishing hypergraphs that contain a somewhat dense sub-hypergraph -a set T of q ′ = q/3 vertices, such that the induced sub-hypergraph on T has at least q hyperedges-from graphs where the induced subhypergraph of every set of q ′ vertices (for q ′ up to roughly n 0.1 size or some other super-logarithmic bound) has only about q ′ /d edges. Thus DUE is equivalent to the problem of distinguishing between a random fairly sparse hypergraph (m = O(n) hyperedges) and a random hypergraph with a planted somewhat dense (average degree larger than 1) small subgraph. 2  Note that we use DUE with a planted set of size O(log n). While, generally speaking, making the set smaller doesn't necessarily make the problem easier, there is always a brute force attack of time</p><formula xml:id="formula_2">( n q )</formula><p>, and hence the scheme obtained can be at best secure against t O(log t) -time adversaries, where t is the running time of the honest parties. While ideally one would want at least sub-exponential security, we note that the best construction of public key encryption using (even idealized) one-way functions has security at most O(t 2 ) <ref type="bibr" target="#b41">[41,</ref><ref type="bibr" target="#b10">10]</ref> and this is optimal for black-box methods <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b8">8]</ref>. 2 Note however that there is a more "algebraic" view to DUE, since a set of q vertices with &lt; q neighbors will result in a linear relation of length at most q in the rows of the adjacency matrix. So, one can think of DUE also as a shortest codeword problem for the dual code of this matrix. However due to the imbalance, the dual code here has rate so close to 1 that it contains rather short codewords in any case (e.g., of length m 1/c ).</p><p>Theorem 2. There is a constant c so that if Assumption 3LIN(cn 1.4 , n -0.2 /c) holds then there exists a semantically secure public key encryption.</p><p>The 3LIN problem is a central and well studied constraint satisfaction problem. Furthermore, the above parameters seem to resist sub-exponential time algorithms (see Section 2.2.) It should be mentioned that other public key encryption schemes were based on solving (dense) random noisy equations mod 2 and mod p <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr" target="#b47">47]</ref>. Still our assumption seems different from those due to the sparsity and the use of larger noise rate (see Footnote 1 and Section 2.3). Moreover, our assumption is based on the hardness of a search problem (i.e. find an x satisfying most equations) with parameters for which refutation variant of 3LIN (i.e. certify that no such x satisfying most equations exists) is harder than refuting a random 3SAT formula with O(n 1.4 ) clauses. Note that finding an efficient algorithm to refute random 3SAT formulas with o(n 1.5 ) clauses is a longstanding open problem. Random 3SAT is perhaps the prototypical example of a "combinatorial" average-case computational problem. Of course, this connection is not formal, only suggestive, and does not directly shed light on the strength of our assumption, as no reductions are known between the search and refutation versions of random noisy 3XOR. Theorem 3. For every constants d, c and q = q(n), there exists a constant c ′ such that if dLIN(c ′ n log n, 1/(c ′ q))) and DUE(cn, q, 2d) hold then there exists a semantically secure public key encryption.</p><p>Compared to Thm. 2, Thm. 3 allows us much more flexibility in the choice of parameters for 3LIN; specifically, we avoid the parameter range in which <ref type="bibr" target="#b21">[21]</ref>'s non deterministic algorithm for the refutation variant of this problem works. This comes at the expense of using the additional, combinatorial assumption DUE. <ref type="foot" target="#foot_1">3</ref> Again, it seems (see Section 2.2) that the resulting schemes achieves sub-exponential security.</p><p>We stress that we do not claim that our cryptosystems are "better" or "more secure" than previous candidates for public key encryption. Indeed, the integer factoring problem underlying schemes such as <ref type="bibr" target="#b49">[49]</ref> is probably the most well-studied average-case computational problem. Also, lattice based systems such as <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr" target="#b47">47]</ref> have the important advantage of being based on worst-case problems such as gap shortest vector and shortest linearly independent vectors. Nevertheless we believe our constructions do suggest that problems with less algebraic or geometric structure may be useful for public key cryptography.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">More about the assumptions</head><p>We now elaborate on the evidence that support our assumptions and on some of their additional applications. To test the validity of our assumptions, we show unconditionally that they do resist various concrete algorithms, as well as provide some reductions between these and other computational problems. While our primary motivation is to broaden the foundations for public key cryptography, we believe that the computational problems we use are natural and interesting in their own right. <ref type="foot" target="#foot_2">4</ref> They broaden the class of hardness-on-average and pseudorandomness problems studied in the past in both the algorithmic and cryptographic communities, and focus attention on parameters of significance for public-key encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The dLIN problem.</head><p>We show that for the parameters we use, the noisy linear equation problem 3LIN unconditionally resists: (1) "Myopic" attacks that look at the entire matrix but only at some n δ of the "noisy bits", or those that look at linear combinations of these "noisy bits". (2) Attacks that apply low-degree polynomials or AC 0 circuits to the "noisy bits". (3) n δ rounds of the Lasserre hierarchy <ref type="bibr" target="#b36">[36]</ref> of semi-definite programs, for some constant δ &gt; 0. The first item follows similarly to the analysis of Mossel et al <ref type="bibr" target="#b43">[43]</ref>, the second item employs the results of Viola <ref type="bibr" target="#b55">[55]</ref> and Braverman <ref type="bibr" target="#b15">[15]</ref>, and the third item is implied by Schoenebeck <ref type="bibr" target="#b53">[53]</ref>.</p><p>The last item is especially interesting as semidefinite programs seem to be the strongest algorithmic tool that is currently available to attack constraint satisfaction problems. Moreover, the Lasserre hierarchy is strictly stronger than other hierarchies for linear and semidefinite programs such as the Lovasz-Schrijver <ref type="bibr" target="#b39">[39]</ref> hierarchies (LS, and LS+) and the Sherali-Adams <ref type="bibr" target="#b54">[54]</ref> hierarchy <ref type="bibr" target="#b37">[37]</ref>.</p><p>We also obtain a new (average-case) reduction from the dLIN problem into its decisional version (where one needs to distinguish (1 -ε)-satisfiable random equations from completely random ones that will be of course only 1/2 + o(1) satisfiable). A similar reduction (from search to decision) was presented in <ref type="bibr" target="#b11">[11]</ref> for the non-sparse case, however their techniques do not hold in the sparse case which turns to be significantly more challenging. As the sparse case is an important variant of this problem (see <ref type="bibr" target="#b4">[4,</ref><ref type="bibr">5]</ref>), we believe that our reduction is of independent interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The DSF problem.</head><p>We show that the non-linear pseudorandom generator G of the DSF assumption resists some of the above attacks as well. Specifically, its output is n δ -wise independent and fools AC 0 circuits and linear tests over GF <ref type="bibr" target="#b2">(2)</ref>. In fact, we prove a more general result about the security of the following construction of <ref type="bibr" target="#b24">[24]</ref>. For a sequence of m subsets of [n], S = S1, . . . , Sm of size d = O(1) and a d-local predicate P , let GS,P : {0, 1} n → {0, 1} m be the d-local mapping whose i-th output is obtained by applying the predicate P to the input string x restricted to the d indices of the set Si. Goldreich <ref type="bibr" target="#b24">[24]</ref> conjectured that when the mapping is length preserving (i.e., m = n), the function GS,P is oneway for a random choice of the collection S and essentially any non-trivial predicate P . This assumption was supported by both theoretical and practical evidence <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b45">45,</ref><ref type="bibr" target="#b17">17]</ref>. Recently, <ref type="bibr" target="#b14">[14]</ref> showed that if the predicate P is biased towards a linear combination of two of its inputs, then the function becomes vulnerable when the output length m is sufficiently larger than the input length (i.e., m &gt; cn for a constant c = c(d) &gt; 1). We complement this by giving a combinatorial condition on S and P under which the function GS,P is pseudorandom with respect to the above family of nontrivial distinguishers (i.e., n δ -wise independent tests, AC 0 circuits and linear tests over GF(2)) even when m is polynomially larger than n. <ref type="foot" target="#foot_3">5</ref> This suggests that the vulnerability discovered by <ref type="bibr" target="#b14">[14]</ref> only holds for a "bad" choice of the predicate P . Our work also provides a new candidate for an NC 0 pseudorandom generator with polynomial stretch (e.g., from n input bits to n 2 output bits). The existence of such a primitive is an important open question <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr">5,</ref><ref type="bibr">5]</ref> which is also motivated by the ability to achieve highly efficient secure multiparty computation <ref type="bibr" target="#b31">[31]</ref>. The only prior candidate (surviving a similar class of non-trivial attacks) was due to <ref type="bibr" target="#b43">[43]</ref>.</p><p>The DUE problem.</p><p>We also show that the unbalanced expansion (DUE) problem resists "cycle counting" algorithms (a basic and surprisingly useful technique to identify dense subgraphs of a graph by counting the number of small cycles in the graph containing specific vertices <ref type="bibr" target="#b9">[9]</ref>). In addition we show that variants of the DUE assumption are implied by variants of other problems such as small-set vertex expansion in general (not necessarily bipartite) graphs, and the planted clique problem in Gn,p for small p = p(n). Finally, we prove that our third cryptosystem, which is based on a combination of DUE and DSF implies that a k-junta (i.e., a function g : {0, 1} n → {0, 1} which depends in at most k of its variables) cannot be PAC-learned in less than n Ω(k) time. The junta learning problem <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b13">13]</ref> is one of the most central open problems in computational learning theory. <ref type="foot" target="#foot_4">6</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Prior works</head><p>The notion of "structure" in complexity assumptions is necessarily informal but we can still offer below some comparisons of our schemes with previous ones. We do not review all previous assumptions used for candidates for public key encryption; see the survey <ref type="bibr" target="#b57">[57]</ref> and the web site <ref type="bibr" target="#b38">[38]</ref> for more. It seems that currently those candidates that are considered secure can be classified as falling into two broad categories: schemes based on number theoretic or group theoretic problems such as factoring (e.g. <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b52">52]</ref>) and discrete log in various groups (e.g. <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b42">42,</ref><ref type="bibr" target="#b35">35]</ref>) and schemes based on knapsack/lattices/error correcting codes (e.g., <ref type="bibr" target="#b40">[40,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr" target="#b47">47]</ref>).</p><p>Our non-linear scheme (based on DSF and DUE) seems genuinely different from all previous constructions we are aware of. Our linear scheme (based on solely on 3LIN or dLIN and DUE) has some similarities to coding/lattice-based schemes but there are some important differences, which we now discuss.</p><p>Of the coding/lattice based schemes, the McEliece <ref type="bibr" target="#b40">[40]</ref> system seems to use more algebraic structure, in the sense that the underlying assumption is that decoding a "shuffled" Goppa code is as hard as decoding a random linear code.</p><p>A similar observation applies to the Hidden Field Equations (HFE) scheme of Patarin <ref type="bibr" target="#b46">[46]</ref> that implicitly assumes that a shuffled low degree univariate polynomial over GF(p n ) is indistinguishable from a random family of quadratic equations over GF(p) n . More similar to ours are the schemes of Alekhnovich <ref type="bibr" target="#b4">[4]</ref> and Regev <ref type="bibr" target="#b51">[51]</ref>. Regev's scheme (and others such as <ref type="bibr" target="#b48">[48,</ref><ref type="bibr" target="#b47">47]</ref>) is based on the Learning With Error problem that is a mod p analog of the learning parity with noise problem. Specifically, like our 3LIN problem it is the task of recovering x from (A, Ax + e) except A is a random (dense) m × n matrix in GF(p) for p &gt; m, and each coordinate of e is distributed as a discrete Gaussian with standard deviation εp. However, as mentioned in Footnote 1, to make decryption work in all those schemes one needs to take ε ≪ 1/ √ m which seems to make a qualitative difference in the nature of the problem <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b2">2]</ref>. Most similar to ours is Alekhnovich's scheme <ref type="bibr" target="#b4">[4]</ref> <ref type="foot" target="#foot_5">7</ref> that uses the (decisional variant) of the standard (dense) parity with noise problem. However, he too needed to use noise level of less than 1/ √ m. While no analogous results to <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b2">2]</ref> are known for the mod 2 case, it still seems as an important advantage that we are able to handle much higher noise levels (in some cases at the expense of using DUE as well).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">OVERVIEW OF THE TECHNIQUES</head><p>To highlight some of our techniques let us sketch the proofs of Thms. 2 and 3. We define SearchLIN(d, m, ε) to be the problem of recovering x given a random d-sparse m × n matrix M and the vector b = M x + e, where x is chosen at random in GF(2) n and e ∈ GF(2) m is chosen at random so that ei = 1 with probability ε (we call e an εnoise vector). Note that with extremely high probability this x to be recovered is unique. We let Search3LIN(m, ε) = SearchLIN <ref type="bibr">(3, m, ε)</ref>.</p><formula xml:id="formula_3">PKE from 3LIN(Ω(n 1.4 ), O(n -0.2 )).</formula><p>The proof proceeds by a sequence of reductions, ending with showing that under our hardness assumption on the search problem, a related prediction problem is hard as well. This prediction problem gets essentially the same input, a matrix M and a vector b = M x + e except its last bit, and asks to predict that bit. In other words, given the value of m -1 noisy (3-sparse) equations, we are asked to predict the value of another independent equation. A natural way to predict is to solve the search problem, and use the recovered solution x to evaluate the new equation (which will predict it correctly with probability 1 -ϵ). Our reduction shows that essentially this is the only way to go about prediction. If search is hard, so is prediction, even if all we ask for is a constant advantage (say 1/10) over guessing.</p><p>The twist is that the distribution of sparse matrices we use</p><p>The scheme E(D, ε):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Public encryption key:</head><p>A d-sparse matrix M ∈ GF(2) m×n sampled from distribution D. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Private decryption key:</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Our cryptosystem.</head><p>Before explaining the reduction, let us explain how the prediction problem Predict3LIN(D0, ε) can be turned into a public-key system. This system is also described in Figure <ref type="figure" target="#fig_0">1</ref>. The distribution D0 has the property that if M is in the support of D0, then there is a linear relation involving M 's last row and at most q ≪ 1/ε other rows. Moreover, it is possible to efficiently sample a random matrix M from D0 together with such a set S of rows involved in this linear relation. Since qε is small, if we add an ε-noise vector e to M x, then with high probability no equation in S will be noisy, which means that given the value of M x + e on the coordinates in S, one can recover the value of M x on the m th coordinate. Thus, the linear relation can serve as a sort of "trapdoor" for the Predict3LIN(D0, ε) problem. One can turn this observation into a PKE by using relatively standard techniques such as hardness amplification <ref type="bibr" target="#b28">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Search to approximate search.</head><p>To get from Search3LIN(m, ε) to Predict3LIN(D0, ε) we use a chain of three reductions through two intermediate problems. The first is an "approximate search" problem AppSearch3LIN(m, ε), which is the variant of Search3LIN in which the goal is relaxed to only recover a vector x ′ that is close to the true answer x in Hamming distance. We use error correcting properties of sparse equations to show that the two problems are equivalent up to constant loss in the parameters. In essence, we can use O(n lg n) more noisy equations to detect the "errors" in the approximate solution vector x ′ and correct them to recover x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Search to prediction on the uniform distribution.</head><p>The next intermediate problem is Predict3LIN(m, ε) which is the problem Predict3LIN(D, ε) where D is the uniform distribution over (m, n, 3)-matrices -the same distribution on matrices used in Search3LIN(m, ε) and AppSearch3LIN(m, ε). We reduce AppSearch3LIN(m, ε) to Predict3LIN(m+O(n), ε).</p><p>A key observation used in the proof is that by adding two 3sparse random equations that share a common variable, we get a random 4-sparse equation of the form xi+xj +x k +x ℓ = b, and so given such an equation one can turn a predictor for xi + xj + x k into a predictor to x ℓ . By carefully combining many pairs of equations it can be shown that at the end, we will get predictions for a large fraction of the variables, and that most of these predictions will be correct. Hence, together they form a good approximation for x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Prediction on a different distribution.</head><p>The last step is a reduction between the two prediction problems Predict3LIN(m, ε) to Predict3LIN(D0, ε) where D0 is the special distribution above. This step is composed of two stages. First we use the results of Feige, Kim, and Ofek <ref type="bibr" target="#b21">[21]</ref> to argue that small linear relations involving the last row of M will exist in our setting of parameters with some (small) constant probability for the uniform distribution. Therefore the statistical distance between D0 (in which such a relation is sampled first) and the uniform distribution is bounded away from 1. We complete the proof by showing how to turn a good predictor for Predict3LIN(D, ε) into a good predictor A for Predict3LIN(D ′ , ε) for every two distributions D, D ′ over matrices with related parameters whose statistical (or computational!) distance is bounded away from 1. This differs from most proofs of this type, since we want the difference in prediction probability of the two predictors to be much smaller than the statistical (or computationsl) distance of the two distributions! For example, even if A perfectly solves Predict3LIN(D, ε) with no error, it might be a terrible predictor which errs with probability 1/2 when instances are generated according to D ′ . Still, we show how to turn it into a useful predictor with respect to D ′ as well. The idea is to identify (via sampling) the instances on which A is likely to succeed and use it only for these cases. Then, we amplify the success probability by breaking a single instance of Predict3LIN to many smaller instances of the problem. These instances are rerandomized by relying on the symmetry and linearity of the 3-LIN constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Thm. 3: PKE from DUE and dLIN.</head><p>The description above completes the reduction of Thm. 2. For Thm. 3, in which smaller values of m are used, such small linear relations between rows of M will not exist, and hence the distribution D0 as above will be statistically far from the uniform distribution on d-sparse matrices. Here our extra assumption DUE comes to the rescue, basically to prove that computationally its distance from uniform will be bounded away from 1. The next two paragraphs highlight the main ideas in that proof.</p><p>The use of DUE, as well as the extension to large sparsity d &gt; 3 introduce some additional difficulties that we need to overcome. In particular, for our cryptosystem we need DUE to hold even if one of the members of the planted shrinking set is revealed. Hence, to prove security we show that solving this variant of DUE assumption (denoted by DUE1) implies a solution to the original DUE problem.</p><p>In particular, given a random (m, n, d) graph with a planted shrinking set, an algorithm for DUE1 can be used to distinguish with some constant advantage between nodes that participate in the shrinking set to other nodes. This distinguisher allows us to "shave" many nodes of the large side of the graph while preserving the existence of a (smaller) shrinking set. The resulting graph will have m ′ top nodes and n bottom nodes where m ′ &lt; n. (Recall that we started with m &gt; n top nodes.) For this case, we can detect the existence of a shrinking set by using Hall's theorem via a matching based algorithm. This leads directly to a solution for DUE. Note that this argument shows only that, under the DUE assumption, the distribution D0 is not completely computationally-far from the uniform distribution.</p><p>Here again, we need to rely on the strong version of the reduction from PredictLIN(D, ε) to PredictLIN(D ′ , ε).</p><p>Another difficulty arises from the use of a large sparsity d &gt; 3, as in this case the combination of two equations with overlap of one variable does not lead to an equation of sparsity d + 1 as in the d = 3 case. We overcome this problem by employing a different reduction from PredictLIN to AppSearchLIN. Specifically, given an instance of AppSearchLIN with locality d, we combine pairs of equations with no overlap to obtain a 2d-LIN instance. Then, we generate (2d -2)-LIN equations by combining pairs of equations with a common variable. This information, together with a prediction algorithm for 2d-LIN can be used to obtain a 2-LIN equation. By repeating this process we obtain a random 2-LIN (or MAX-CUT) instance. Now we can employ one of the known algorithms (e.g.,the SDP of <ref type="bibr" target="#b23">[23]</ref>) to obtain a solution that satisfies a large fraction of the constraints. Finally, we argue that since the 2-LIN instance is random the resulting assignment is close to the original assignment and therefore it is a valid solution for AppSearchLIN.  <ref type="figure">d,</ref><ref type="figure">m,</ref><ref type="figure">ε</ref>) to be the problem of recovering</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">FORMAL STATEMENTS</head><formula xml:id="formula_4">x from (M, M x + e) where M R ← M m,n,d , x R ← F n 2</formula><p>, and e is chosen at random such that ei = 1 with probability ε. We say that SearchLIN(d, m, ε) is intractable if for every PPT algorithm A, and every sufficiently large n, the probability that A solves SearchLIN(d, m(n), ε(n)) is smaller than 2/3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Indistinguishability. A pair of distribution ensembles</head><p>Xn, Yn are ε-indistinguishable if for every PPT algorithm C,</p><formula xml:id="formula_5">we have | Pr[C(X ) = 1] -Pr[C(Y) = 1]| &lt; ε. An ensemble Xn is ε-pseudorandom if Xn is ε-indistinguishable from Un, the uniform distribution over n-bit strings.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Public-key encryption scheme. A (α(n), β(n))-secure</head><p>public-key bit encryption scheme is a triple (Gen, Enc, Dec) of PPT algorithms such that the algorithm Gen, on input 1 n produces a pair of private and public keys (pk, sk) and the scheme satisfy the following properties: • β-privacy: The random variables (pk, Enc pk (0)) and (pk, Enc pk (1)) are β(n)-indistinguishable, where pk is chosen by Gen(1 n ).</p><formula xml:id="formula_6">• (1 -α)-correctness: For a random bit b R ← {0,</formula><p>If α and β are constants that satisfy α &lt; (1 -√ β)/2, we say that the scheme is a weak PKE. It was shown in <ref type="bibr" target="#b28">[28,</ref><ref type="bibr">Thm. 6</ref>] that a weak PKE can be converted into semantically secure PKE <ref type="bibr" target="#b27">[27]</ref> which supports arbitrary (polynomially) long messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Properties of the scheme E(D, ε)</head><p>Two of our constructions are based on the general bitencryption scheme which is described in Figure <ref type="figure" target="#fig_0">1</ref>. Recall that the public key is matrix M , and the private-key is a short non-trivial linear dependency S among the rows of M which includes the last row. To encrypt the bit σ, one generates an m-bit vector b by perturbing a random vector in the image of M , and then XOR-s the last entry of b with the plaintext σ. The knowledge of the short linear-dependency S allows to decrypt the ciphertext b ′ by summing-up the bits that are indexed by the set S. The following lemma shows that decryption succeeds the noise rate ε is sufficiently small. Lemma 1. For every pair (M, S) of public/private keys, and every plaintext σ ∈ {0, 1}, the decryption errs with probability at most α = 1 2 -1 2 (1-2•ε) q &lt; εq, where the probability is taken over the randomness of the encryption algorithm.</p><p>To prove that the scheme is secure, it should be shown that it is hard to predict the last entry of the ciphertext b. Our main technical theorem shows that as long as M is chosen from a distribution which is not too far from M m,n,d or T m/( n d ),n the scheme is "somewhat" secure assuming that SearchLIN is intractable for related parameters. Formally, Theorem 4. Let 0 &lt; δ &lt; 1 be a constant and d be either 3 or an even number larger than 3, and m(n</p><formula xml:id="formula_7">) = Ω(n lg n), ε = ε(n) ≤ 0.01 be functions. Let D = {Dn} be a distribution ensemble which is (1 -δ)-computationally in- distinguishable from M m,n,d or T m/( n d ),n .</formula><p>Then there exists a constant c which depends only in δ and d such that:</p><formula xml:id="formula_8">1. For d = 3: If SearchLIN(3, cm, ε) is intractable then the public-key encryption scheme E(D, ε) is (1 -δ/2)- private. 2. For d &gt; 3: If SearchLIN(d/2, cm, 1- √ 1-2ε<label>2</label></formula><p>) is intractable then the public-key encryption scheme E(D, ε) is (1δ/2)-private. 8  8 As a special case, the theorem essentially shows that for d-LIN, prediction is as hard as search. By combining this with Yao's theorem <ref type="bibr" target="#b56">[56]</ref>, one can show that the corresponding decision problem (distinguishing a random (1 -ε)-satisfiable instance from a random one) is as hard as search as well (with some loss in the parameters).</p><p>Proof. We will sketch the proof only for the (simpler) case of d = 3. As described in Section 3, we gradually reduce Search3LIN to the task of breaking E(D, ε).</p><p>Step 1: From Search3LIN to AppSearch3LIN. Suppose that we have an algorithm A that solves AppSearch3LIN(m, ε); that is, given a random ε-satisfiable 3-LIN instance (M, b = M x + e) A outputs an assignment x which is 0.1-close to x. We show how to convert A into an algorithm that solves Search3LIN(m + t, ε) with almost the same success probability, where t ≥ Ω(n ln n).</p><formula xml:id="formula_9">Given an input (M, b) ∈ F (m+t)×n 2 × F m+t 2</formula><p>, we invoke the approximation algorithm A on the first m rows of the input, and get an approximation x for x. Then, we use the information given by the last t rows of the input to correct the errors in x as follows. We will recover the i-th bit of x by letting each equation of the form xi + x k + x ℓ = v to vote for the correct value of xi. This vote is simply xk + xℓ + vs, i.e., we compute the value of xi assuming that v is not noisy and that the approximation for xk and xℓ is correct. Finally, we take the majority of all votes. To analyze the algorithm, we show that each index i is likely to participate in many equations and that w.h.p most of these equations will include only indices for which x and x agree, hence, we output xi with probability at least 1 -o(1/n) and therefore (by a union bound) all the indices of x are recovered w.h.p.</p><p>Step 2: From AppSearch3LIN to Predict3LIN. Suppose that we have an algorithm A that solves Predict3LIN(m, ε). That is, given a random input (M, b = M x + e) the algorithm A predicts the value bm without reading it. It will be convenient to parse the input as a tuple (M ′ , b ′ , v) where (M ′ , b ′ ) is the first m -1 rows of (M, b) ("training set"), and v = (i, j, k) is the support of the last row of M ("test triple"). We show how to use A to solve AppSearch3LIN(m + t, ε) for t = Ω(n). Our reduction employs a subroutine B which transforms a random 3-LIN instance with t equations and noise ε into a random 4-LIN instance with t/5 equations and noise ε ′ = 2ε(1 -ε) and the same planted solution. Given B we proceeds as follows.</p><p>We break the 3-LIN instance into two parts: the first m equations (M, b) and the remaining t equations (T, z) which are converted into a random 4-LIN instance (R, y) with t/5 equations via the subroutine B. Then, we invoke the predictor A for t/5 iterations, where the 3-LIN instance (T, z) is being used as the training set in all the iterations, and the test triple of the r-th iteration v = (i, j, k) is randomly chosen from the support of the r-th 4-LIN equation xi + xj + x k + x ℓ = b. We guess the value of the variable x ℓ (which does not appear in v) by XOR-ing A's prediction bit with the LHS b of the 4-LIN equation. Our guess will be correct if the equation is not noisy and the prediction succeeds (or if both events do not happen simultaneously). It can be shown that, if A is a good predictor (e.g., succeeds with probability 0.99) then, with high probability, we will get good guesses for most indices (e.g., 0.9 fraction) and thus obtain a good approximation for x.</p><p>Finally, to implement the subroutine B we partition the 3-LIN equations into pairs that share a single variable xi, and then combine each pair into a 4-LIN equation by simple addition. We make sure that the partition is oblivious to the other entries of the equations by first selecting a random representative from each equation, and then combining pairs that share a common representative. It is not hard to verify that such a strategy results in a random instance of 4-LIN system, and that, except with probability exp(-Ω(t)), we will get enough equations.</p><p>Step 3: Predicting over other distributions. Let D be a distribution ensemble over 3-sparse matrices which is (1 -δ)-computationally close to Mm,n for some constant δ. 9 Suppose that E(D, ε) is not (1 -δ/2)-private. Hence, there exists a (1 -δ/4)-predictor A for the problem Predict3LIN(D, ε) in which the the matrix ( M v ) of the Predict3LIN instance (M, b = M x + e, v) is chosen from D and x and e are chosen as before. We show that A can be converted into an 0.99-predictor B for Predict3LIN(m ′ , ε) (over the the uniform distribution) where m ′ = c(m -1) + 1 and the constant c = c(δ) depends only on δ.</p><p>Let 1 2 &lt; α &lt; β &lt; 1 -δ/4 be constants, we call a pair (M, v) good (resp. bad ) if A succeeds on an instance (M, b = M x+e, v) with probability larger than β (resp., smaller than α) over a random choice of x and ε-noisy e. A proper choice of α and β guarantees that: (1) a random pair selected from Mm,n will be good with some constant probability γ &gt; 0 (by Markov and the closeness of D); and (2) one can efficiently distinguish bad pairs from good pairs by estimating A's success probability (say, via Chernoff bound).</p><p>Let us now describe the algorithm B. Given an input (M, b, v) for Predict3LIN(m ′ , ε) partition the matrix M (resp. , where we write π(R) to denote the matrix R with columns permuted according to π. Note that each of the c instances we created is a random instance of Predict3LIN(m, ε) and, in addition, all the instances are independently distributed. Also, observe that given a good prediction σi for the i-th instance we can compute a good prediction for the original instance (M, v, x) by adding σi (over F2) to ⟨xi, v⟩. Hence, we apply A to each instance, translate its answer into a prediction for (M, v, x) and output the majority over the predictions, ignoring the votes of the entries for which (Ti, vi) are bad. Since 1  2 &lt; α and γ &gt; 0 are constants, a sufficiently large constant c decreases the error probability below 0.01.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">PKE based on 3LIN</head><p>We instantiate the scheme E(D, ε) as follows. Let H 2,3  q,n be the uniform distribution over matrices with n columns and q rows, where each row contains exactly 3 ones and each column contains either 0 or 2 ones. Consider the distribution Tp,n,q which is simply Tp,n conditioned on the event that the matrix T contains a submatrix of rows H ∈ support(H 2,3 q,n ) that includes the last row of T . Since H 2,3  q,n is efficiently samplable (via standard techniques), it is possible to sample a triple (M, H, S) where M R ← Tp,n,q, H R ← H 2,3  q,n and MS = H (i.e., S is a q-size subset of the rows of M which points to the submatrix H). We will use this distribution for our keygeneration algorithm. First, we argue that the distribution Tp,n,q is not too far (in statistical distance) from Tp,n. Lemma 2. There exists a function q = Θ(n 0.2 ) and a con- 9 The proof easily extends to the case where D is close to Tp,n for p = m/ ( n</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head><p>) .</p><p>stant δ &lt; 1 such that the distribution T p=n 1.4 /( n 3 ),n is 1 -δ statistically indistinguishable from Tp,n,q.</p><p>The (omitted) proof relies on the results of Feige, Kim and Ofek <ref type="bibr" target="#b21">[21]</ref>. We can now establish Thm. 2.</p><p>Proof of Thm 2. Let p, q(n) and δ be the parameters obtained from Lemma 2 and let c = c(δ) be the parameter obtained from Thm. 4. Suppose that Search3LIN(cn 1.4 , ε) is intractable for ε = kn -0. 2 where k is a sufficiently small constant that will be determined later. By Lemma 2 and Thm. 4, we get that the scheme E instantiated with the distribution T p=n -1.6 ,n,q and noise rate ε is β = (1 -δ/2)private. Since β is bounded away from 1, and since the error α tends to zero with k (Lemma 1), a sufficiently small constant k will make the error α smaller than (1 -√ β)/2. Hence, we obtain a weak PKE which can be converted to a semantically secure PKE via the transformation of <ref type="bibr" target="#b28">[28]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">PKE based on dLIN and DUE</head><p>In the previous section we constructed a PKE based on the intractability of Search3LIN(n 1.4 , n -0.2 ), our goal in this section is to relax this assumption and replace it with the intractability of solving the SearchLIN problem with a smaller number of equations (m = n log n), and larger noise rate (e.g., ε = n -0.1 ). We do this at the expense of adding the DUE as an additional assumption.</p><p>The DUE problem. In the following we view a d-sparse matrix M ∈ F m×n 2 as a bipartite graph G = ((V Top , V Bot ), E) with m "top" nodes (each node correspond to a row) and n "bottom" nodes (each node correspond to a column) where each top node has degree d. We call such a graph an (m, n, d) graph. Graphs chosen from M m,n,d will be, with high probability, very good expanders. That is, we expect that small sets S of top vertices will have almost d|S| neighbors. The distribution F q n,m,d is a perturbed version of M m,n,d in which we plant a single q-size top subset S with a small ("shrinking") neighborhood. Formally, F q m,n,d is the result of the following random process: choose G from M n,m,d , choose at random subsets S ⊆ V Top and T ⊆ V Bot of sizes q and q/3 respectively, and choose a random graph H R ← M q/3,q,d . Then replace all the d|S| edges in G that are incident to S with the edges from H. In the DUE problem the goal is to distinguish between a random graph sampled from M n,m,d to a graph sampled from F q n,m,d . Let m = m(n), d = d(n) and q = q(n) be some functions of n. We say that DUE(m, q, d)</p><formula xml:id="formula_10">is δ-intractable if the distribution ensembles M n,m(n),d(n) and F q n,m(n),d(n) are δ computationally indistinguishable.</formula><p>The key generation algorithm. Again, we rely on the general bit-encryption of Figure <ref type="figure" target="#fig_0">1</ref>. Our key generation algorithm will be based on the DUE planted distribution. We will sample a pair of private/public-keys as follows. Let M be an d-sparse matrix chosen from F q n,m(n),d and let S be a shrinking set of size q. We say that a row i in S is degenerate if it is spanned by the other rows in S. Go over the rows of S in a random order, until a degenerate row i is found. (Such a row must exist as S is shrinking and therefore the column rank of the rows indexed by S is smaller than q.) Then, permute the i-th row of M with the last row, and set the public-key to be the permuted matrix M ′ , and the private key to be the set S ′ which contains the last row of M ′ and the rows that span it, i.e., ∑ j∈S ′ M ′ j (mod 2) = 0.</p><p>Security. Let K = K q n,m,d denote the distribution of the public key. Our goal now is to show that K is (1 -δ) computationally close to the ensemble M = M n,m,d for some constant δ, and then apply Thm. 4. Recall that the intractability of DUE asserts that the above is true for the distribution F = F q n,m,d , and note that F can be written as a convex combination αK+(1-α)K, where K is essentially F conditioned on the last row being out of the planted shrinking set. In general, this does not necessarily means that a good distinguisher for K, yields a good distinguisher for F . Consider, for example, an algorithm that always output 1 on inputs from K, but will output 0 on inputs from K. Such an algorithm can be a very good distinguisher for K, and still be useless for F (say, if it outputs 1 on the uniform distribution with probability α). The crux of the lemma, is to show that in this case, we can distinguish K from K, and therefore can recover some information regarding the planted shrinking set. This information allows us to certify the "shrinkage" of a noticeable fraction of the graphs in F , and so it leads to a distinguisher for F .</p><formula xml:id="formula_11">Theorem 5. Suppose that DUE(cm, q, d) is 1/2000c 2 in- tractable. Then K q n,m,d is (1 -δ) computationally close to the ensemble M n,m,d where δ = δ(c) is a constant which depends only in the constant c. Proof sketch. Let Kn = K q n,m,d , Fn = F q n,</formula><p>m,d and Mn = M n,m,d . Assume, towards a contradiction, that we have a δ-distinguisher A for Kn and Mn where δ = 1 -1/500c 2 . We use A to break DUE as follows. Given a graph G, create the graph Gi in which the i-th row is permuted with the last row, and invoke A on all the Gi's for i ∈ [m]. Define a graph G ′ by keeping only the rows i of G for which A(Gi) outputs "planted". If the number of remaining rows is larger than n/kc we output "random" where k is some fixed universal constant (e.g., 18). Otherwise, think of G ′ as a bipartite graph with (at most) n/kc left vertices with degree d and n right vertices, and check whether there exists a perfect matching that consists of all left nodes. If so output "random"; otherwise, output "planted".</p><p>We argue that when G R ← Mn the above algorithm outputs "random" with probability 1 -o(1). Indeed, suppose that we outputted "planted". Then, G ′ has no matching that consists of all left vertices, and therefore, by Hall's theorem, G ′ has a shrinking left set. Since G ′ is a subgraph of G, it follows that G has a left set of vertices of size at most n/kc which shrinks. By standard calculations, a random graph G R ← Mn, will have such a set only with probability o <ref type="bibr" target="#b1">(1)</ref>.</p><p>It is left to show that when G R ← Fn the output is "planted" with some fixed constant probability (e.g., 1/20). To prove this we claim that for a typical graph G R ← Kn, we have that A(Gi) outputs (1) "planted" for most rows i in the shrinking set, and (2) "random" for most rows i outside of the shrinking set. Assuming that the claim is true (with the appropriate parameters), we complete the argument by noting that if G satisfies (2) then G ′ has at most n/kc rows, and, in addition by <ref type="bibr" target="#b1">(1)</ref>, at least q/2 rows from the shrinking set appear in G ′ . Since the neighborhood of these rows is at most q/3, the graph G ′ has no perfect matching (by Hall's theorem), and the algorithm outputs "planted".</p><p>It is left to prove the claim. The first part of the claim follows (via Markov) from the fact that A, being a δ distinguisher, outputs "planted" with high probability over G Corollary 1 (Thm. 3 restated). For every constants d, c and function q = o(n), there exist constants a, b for which: if DUE(cn, q, 2d) is 1/2000c 2 intractable as well as SearchLIN(d, an log n, 1/(bq))) is intractable then there exists a semantically secure PKE.</p><p>Proof. Suppose that the assumptions hold with parameters d, q, c and sufficiently large constant a, b &gt; 1. By Thms. 4 and 5, the resulting scheme is β-private for some constant 0 &lt; β &lt; 1 where β does not depend on the constant b. Hence, by taking b to be sufficiently large, we can reduce the decryption error α = 1 2 -1 2 (1 -2 • ε) q (see Lemma 1) below (1 -√ β)/2 and get a PKE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">PKE based on DSF and DUE</head><p>For an (m, n, d) graph G = ((V Top , V Bot ), E), and a predicate f : {0, 1} d → {0, 1}, we define the function G f : {0, 1} n → {0, 1} m obtained by mapping every x ∈ {0, 1} n to (f (x Γ(1) , . . . , f (x Γ(m) ), where Γ(i) denotes the neighbors of the i-th "top" node. We prove that there exists a PKE under the assumption that (1) (Decisional Sparse Function DSF) There exists a function f : {0, 1} d → {0, 1} for which the distribution (G, G f (Un)) is ε-indistinguishable from the distribution (G, Um) where G R ← M m,n,d ; and (2) DUE(m, q, d) is ε intractable for some q ∈ Θ(log n).</p><p>The cryptosystem. The cryptosystem is slightly different than the previous ones, and is inspired by Naor's commitment <ref type="bibr" target="#b44">[44]</ref>. To generate a key choose a graph G R ← F q n,m,d together with a q-size shrinking set S, as well as a random string r R ← Um. The pair (G, r) is the public-key, while the private key consists of the shrinking set S, and the graph H which is the subgraph of G induced by the set S and its neighbors. To encrypt we choose a random x R ← Un. To encrypt the bit 0 output y = G f (x); To encrypt the bit 1, output y = G f (x) + r (mod 2). To decrypt a ciphertext z, we output 0 if and only if zS the restriction of z to the set S is in the image of H f . (This verification can be implemented efficiently by trying all possible 2 q/3 = poly(n) preimages.) It is not hard to prove the following Lemma which establishes Theorem 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3. (1)</head><p>The scheme is errorless with respect to a fraction of 1 -2 -q/3 of the public-keys. ( <ref type="formula" target="#formula_8">2</ref>) Under the assumptions above, the scheme is 4ε private.</p><p>Proof sketch. (1) Fix G, S and H and let v = rS. We show that for all but 2 -q/3 fraction of the v's the scheme is errorless. Indeed, a decryption error can happen only if there are two different preimages w0, w1 ∈ {0, 1} q/3 for which H f (w0) = H f (w1) + v. Hence, the probability of choosing a "bad" v is at most 2 q/3 • 2 q/3 /2 q . (2) Follows by a standard hybrid argument.</p><p>Since our decryption algorithm looks at only O(log m) of the bits of an m-bit ciphertext, and since for most of the keys the scheme is errorless, we can show, via standard techniques <ref type="bibr" target="#b33">[33]</ref>, that there is no efficient algorithm to PAC learn O(log m)-juntas under the same assumptions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Our basic cryptosystem scheme, used in the proofs of Thms. 2 and 3.m, d, q, ε can depend on the security parameter n. The distribution D is over matrices with d 1's per row, in which the last row is a linear combination of q -1 other rows. We show that under certain assumptions the scheme can be instantiated to achieve constant privacy. This can be amplified to full-fledged security using<ref type="bibr" target="#b28">[28]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>4. 1</head><label>1</label><figDesc>Preliminaries The SearchLIN problem. A matrix M is d-sparse if every row has exactly d nonzero elements. The distribution T p,n,d chooses a d-sparse matrix by selecting any of the possible ( n d ) rows with probability p. The distribution M m,n,d picks an m × n d-sparse matrix by choosing each row independently at random (with replacement) from all possible (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>1} and a pair of random keys (pk, sk) R ← Gen(1 n ) we have: Pr[Dec sk (Enc pk (b)) = b] ≥ 1 -α.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>the vector b) to c sub-matrices M1, . . . , Mc (resp. vectors b1, . . . , bc) each with m -1 rows. Rerandomize the i-th instance as follows: choose a random xi R ← Un and a random permutation πi over [n]; Generate the triple (Ti = πi(Mi), ai = bi + Ti • πi(xi), vi = π(v))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>The second part of the claim follows from DUE; as if (2) is violated A(Gi) outputs "planted" with high probability over G R ← Fn and a random i R ← [m], and since A(Hi), where H R ← Mn and i R ← [m], outputs "random" with high probability (by our assumption on A), we break DUE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Assumption DSF(m, d) (Decisional Sparse Function) With high probability, the following d-local, NC 0 mapping G of n to m bits is a pseudorandom generator: every output bit of G(x1, . . . , xn) is MAJ(x ′ , x ′′ , x ′′′ ) where each of x ′ , x ′′ , x ′′′ is the parity of d/3 random coordinate of x.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Learning parity with noise (LPN), as well as the related mod p variant of "learning with errors" (LWE), have been used for public key cryptography as well<ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr" target="#b47">47]</ref>. However, the known public key schemes require noise levels much lower than those needed for private-key cryptography. In particular all of these schemes inherently require noise of magnitude ε &lt; 1/ √ m, where m is the number of equations.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>We note that known algorithms for DUE (i.e., counting small subgraphs) place some restrictions on the value of q for which DUE(cn, q, d) and we'll need q ∈ [n ε , √ n] where ε is some constant depending on c. The actual range of parameters for which our result holds is somewhat broader.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>As an example, following this work, a variant of the DUE assumption was recently used by<ref type="bibr" target="#b7">[7]</ref> (co-authored by the second author) to argue about the complexity of pricing financial derivatives. The DUE assumption also served as partial motivation for<ref type="bibr" target="#b9">[9]</ref>'s recent work on the densest subgraph problem.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>Roughly speaking, our condition requires S to be a good expander and P to satisfy a (stronger) variant of tresiliency<ref type="bibr" target="#b16">[16]</ref>. See full version for details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p><ref type="bibr" target="#b6">6</ref> In addition, the DSF assumption on its own can be formulated as a "dual" version of the junta learning problem in which the target function is not local, but instead the data points given to the learner are "local". More formally, in terms of learning theory, in DSF the learner should learn a function fx, represented by an n-bit vector x, which maps a d-size set S ⊆ [m] to the value P (xS) for some known (randomly chosen) predicate P .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_5"><p>Indeed, as observed by Ron Rivest and Madhu Sudan (personal communication), both our linear scheme and Alekhnovich's have a common generalization, where the public key is a matrix G whose dual subspace has a "planted" short vector, which serves as the private key. Similar structure occurs in many lattice-based cryptosystems such as<ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b50">50]</ref>, where the public key is roughly a generating set for a lattice whose dual lattice has a planted short (in ℓ2) basis.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements.</head><p>We thank Noga Alon, Moses Charikar, Shafi Goldwasser, Thomas Holenstein, Ron Rivest, Madhu Sudan and Salil Vadhan for useful discussions. We also thank Aditya Bhaskara for sharing with us a copy of <ref type="bibr" target="#b9">[9]</ref>.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Supported by NSF grants CNS-0627526, CCF-0426582 and CCF-0832797. † Supported by NSF grants CNS-0627526, CCF-0426582 and CCF-0832797, US-Israel BSF grant 2004288 and Packard and Sloan fellowships. ‡ Supported by NSF Grant CCF-0832797.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Algorithmic barriers from phase transitions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Achlioptas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Coja-Oghlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="793" to="802" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Lattice problems in NP intersect coNP</title>
		<author>
			<persName><forename type="first">D</forename><surname>Aharonov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="749" to="765" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A public-key cryptosystem with worst-case/average-case equivalence</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ajtai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="284" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">More on average case vs approximation complexity</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alekhnovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="298" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Cryptography in NC 0</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="845" to="888" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The hardness of approximate optima in lattices, codes, and systems of linear equations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Babai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Sweedyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="317" to="331" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Computational complexity and information asymmetry in financial products</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Brunnermeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Merkle puzzles are optimal -an O(n 2 ) attack on key exchange from a random oracle</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mahmoody-Ghidary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CRYPTO &apos;09</title>
		<meeting>CRYPTO &apos;09</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Detecting high log-density -an O(n 1/4 )-approximation for densest k-subgraph</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bhaskara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chlamtac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vijayaraghavan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Basing weak public-key cryptography on strong one-way functions</title>
		<author>
			<persName><forename type="first">E</forename><surname>Biham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">J</forename><surname>Goren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4948</biblScope>
			<biblScope unit="page" from="55" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Cryptographic primitives based on hard learning problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Furst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kearns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Lipton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="278" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Relevant examples and relevant features: Thoughts from computational learning theory</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Blum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI Fall Symposium on Relevance</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Selection of relevant features and examples in machine learning</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Langley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="245" to="271" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the security of goldreich&apos;s one-way function</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bogdanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Qiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APPROX-RANDOM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="392" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Poly-logarithmic independence fools AC 0 circuits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Braverman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="3" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The bit extraction problem or t-resilient functions</title>
		<author>
			<persName><forename type="first">Goldreich</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><surname>Hastad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rudich</forename><surname>Freidmann</surname></persName>
		</author>
		<author>
			<persName><surname>Smolensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Goldreich&apos;s one-way function candidate and myopic backtracking algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Etesami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Trevisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On pseudorandom generators in NC 0</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Miltersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 26th MFCS</title>
		<meeting>26th MFCS</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">New directions in cryptography</title>
		<author>
			<persName><forename type="first">W</forename><surname>Diffie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="644" to="654" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Approximating cvp to within almost-polynomial factors is np-hard</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kindler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Raz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Safra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorica</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="205" to="243" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Witnesses for non-satisfiability of dense random 3CNF formulas</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ofek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="497" to="508" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The dense k-subgraph problem</title>
		<author>
			<persName><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kortsarz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="410" to="421" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming</title>
		<author>
			<persName><forename type="first">Williamson</forename><surname>Goemans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Candidate one-way functions based on expander graphs</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
			<affiliation>
				<orgName type="collaboration">Electronic Colloquium on Computational Complexity (ECCC</orgName>
			</affiliation>
		</author>
		<idno>TR00-090</idno>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the limits of nonapproximability of lattice problems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="540" to="563" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On the existence of pseudorandom generators</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page">1163</biblScope>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">One-way secret-key agreement and applications to circuit polarization and immunization of public-key encryption</title>
		<author>
			<persName><forename type="first">T</forename><surname>Holenstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Renner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="478" to="493" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A personal view of average-case complexity</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Structure in Complexity Theory Conference</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="134" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Limits on the provable consequences of one-way permutations</title>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="44" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Cryptography with constant computational overhead</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="433" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Hiding cliques for cryptographic security</title>
		<author>
			<persName><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Designs, Codes and Cryptography</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="269" to="280" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Cryptographic limitations on learning Boolean formulae and finite automata</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kearns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="95" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Ruling out PTAS for graph min-bisection, densest subgraph and bipartite clique</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Elliptic curve cryptosystems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Koblitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Computation</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="203" to="209" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">An explicit exact SDP relaxation for nonlinear 0-1 programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Lasserre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPCO: 8th Integer Programming and Combinatorial Optimization Conference</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A comparison of the Sherali-Adams, Lovasz-Schrijver, and Lasserre relaxations for 0-1 programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Laurent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MOR: Mathematics of Operations Research</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="470" to="496" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Cryptology pointers: Public key cryptography: Concrete systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
		<ptr target="http://www.adastral.ucl.ac.uk/~helger/crypto/link/public/concrete.php" />
	</analytic>
	<monogr>
		<title level="j">Web site</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Cones of matrices and set-functions and 0-1 optimization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lovász</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schrijver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Optimization</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="166" to="190" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">A public-key cryptosystem based on algebraic coding theory</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Mceliece</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<biblScope unit="page" from="42" to="44" />
		</imprint>
	</monogr>
	<note type="report_type">DSN Progress Report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Secure communications over insecure channels</title>
		<author>
			<persName><forename type="first">R</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="294" to="299" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Use of elliptic curves in cryptography</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">218</biblScope>
			<biblScope unit="page" from="417" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">On epsilon-biased generators in NC 0</title>
		<author>
			<persName><forename type="first">E</forename><surname>Mossel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shpilka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Trevisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Random Struct. Algorithms</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="56" to="81" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Bit commitment using pseudorandomness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="151" to="158" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">An experimental evaluation of goldreich&apos;s one-way function</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Panjwani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<pubPlace>Bombay</pubPlace>
		</imprint>
		<respStmt>
			<orgName>IIT</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Hidden fields equations (HFE) and isomorphisms of polynomials (IP): Two new families of asymmetric algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Patarin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="33" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems from the worst-case shortest vector problem</title>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="333" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A framework for efficient and composable oblivious transfer</title>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="554" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Digitalized signatures and public-key functions as intractable as factorization</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<idno>MIT/LCS/TR-212</idno>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">New lattice-based cryptographic constructions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="899" to="942" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">On lattices, learning with errors, random linear codes, and cryptography</title>
		<author>
			<persName><forename type="first">O</forename><surname>Regev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="84" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A method for obtaining digital signatures and public-key cryptosystems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Adelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="120" to="126" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Linear level Lasserre lower bounds for certain k-csps</title>
		<author>
			<persName><forename type="first">G</forename><surname>Schoenebeck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="593" to="602" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A hierarchy of relaxation between the continuous and convex hull representations for zero-one programming problems</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">D</forename><surname>Sherali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Disc. Math</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="411" to="430" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">The sum of d small-bias generators fools polynomials of degree d</title>
		<author>
			<persName><forename type="first">E</forename><surname>Viola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCC</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="124" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Theory and applications of trapdoor functions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="80" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Survey of computational assumptions used in cryptography broken or not by Shor&apos;s algorithm. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>School of Computer Science McGill University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
