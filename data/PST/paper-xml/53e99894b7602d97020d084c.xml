<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Web Question Answering: Is More Always Better?</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Susan</forename><surname>Dumais</surname></persName>
							<email>sdumais@research.microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="department">Microsoft Research One Microsoft Way Redmond</orgName>
								<address>
									<postCode>98052</postCode>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michele</forename><surname>Banko</surname></persName>
							<email>mbanko@research.microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="department">Microsoft Research One Microsoft Way Redmond</orgName>
								<address>
									<postCode>98052</postCode>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eric</forename><surname>Brill</surname></persName>
							<email>brill@research.microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="department">Microsoft Research One Microsoft Way Redmond</orgName>
								<address>
									<postCode>98052</postCode>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jimmy</forename><surname>Lin</surname></persName>
							<email>jimmylin@ai.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Microsoft Research One Microsoft Way Redmond</orgName>
								<address>
									<postCode>98052</postCode>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrew</forename><surname>Ng</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Microsoft Research One Microsoft Way Redmond</orgName>
								<address>
									<postCode>98052</postCode>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Web Question Answering: Is More Always Better?</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">65865FAE259885EBE503C827A83D7B81</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T15:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.3.1. [Content Analysis and Indexing]</term>
					<term>H.3.3 [Information Search and Retrieval] Algorithms</term>
					<term>Experimentation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes a question answering system that is designed to capitalize on the tremendous amount of data that is now available online. Most question answering systems use a wide variety of linguistic resources. We focus instead on the redundancy available in large corpora as an important resource. We use this redundancy to simplify the query rewrites that we need to use, and to support answer mining from returned snippets. Our system performs quite well given the simplicity of the techniques being utilized.</p><p>Experimental results show that question answering accuracy can be greatly improved by analyzing more and more matching passages. Simple passage ranking and n-gram extraction techniques work well in our system making it efficient to use with many backend retrieval engines.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Question answering has recently received attention from the information retrieval, information extraction, machine learning, and natural language processing communities <ref type="bibr" target="#b1">[1]</ref> <ref type="bibr" target="#b3">[3]</ref> <ref type="bibr" target="#b19">[19]</ref> <ref type="bibr" target="#b20">[20]</ref> The goal of a question answering system is to retrieve 'answers' to questions rather than full documents or even best-matching passages as most information retrieval systems currently do. The TREC Question Answering Track which has motivated much of the recent work in the field focuses on fact-based, short-answer questions such as "Who killed Abraham Lincoln?" or "How tall is Mount Everest?". In this paper we focus on this kind of question answering task, although the techniques we propose are more broadly applicable.</p><p>The design of our question answering system is motivated by recent observations in natural language processing that, for many applications, significant improvements in accuracy can be attained simply by increasing the amount of data used for learning. Following the same guiding principle we take advantage of the tremendous data resource that the Web provides as the backbone of our question answering system. Many groups working on question answering have used a variety of linguistic resourcespart-of-speech tagging, syntactic parsing, semantic relations, named entity extraction, dictionaries, WordNet, etc. (e.g., <ref type="bibr" target="#b2">[2]</ref>[8] <ref type="bibr" target="#b11">[11]</ref>[12] <ref type="bibr" target="#b13">[13]</ref>[15] <ref type="bibr" target="#b16">[16]</ref>).We chose instead to focus on the Web as gigantic data repository with tremendous redundancy that can be exploited for question answering. The Web, which is home to billions of pages of electronic text, is orders of magnitude larger than the TREC QA document collection, which consists of fewer than 1 million documents. This is a resource that can be usefully exploited for question answering.</p><p>We view our approach as complimentary to more linguistic approaches, but have chosen to see how far we can get initially by focusing on data per se as a key resource available to drive our system design.</p><p>Automatic QA from a single, small information source is extremely challenging, since there is likely to be only one answer in the source to any user's question. Given a source, such as the TREC corpus, that contains only a relatively small number of formulations of answers to a query, we may be faced with the difficult task of mapping questions to answers by way of uncovering complex lexical, syntactic, or semantic relationships between question string and answer string. The need for anaphor resolution and synonymy, the presence of alternate syntactic formulations, and indirect answers all make answer finding a potentially challenging task. However, the greater the answer redundancy in the source data collection, the more likely it is that we can find an answer that occurs in a simple relation to the question. Therefore, the less likely it is that we will need to resort to solving the aforementioned difficulties facing natural language processing systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">EXPLOITING REDUNDANCY FOR QA</head><p>We take advantage of the redundancy (multiple, differently phrased, answer occurrences) available when considering massive amounts of data in two key ways in our system.</p><p>Enables Simple Query Rewrites. The greater the number of information sources we can draw from, the easier the task of rewriting the question becomes, since the answer is more likely to be expressed in different manners. For example, consider the difficulty of gleaning an answer to the question "Who killed Abraham Lincoln?" from a source which contains only the text "John Wilkes Booth altered history with a bullet. He will forever be known as the man who ended Abraham Lincoln's life," Facilitates Answer Mining. Even when no obvious answer strings can be found in the text, redundancy can improve the efficacy of question answering. For instance, consider the question: "How many times did Bjorn Borg win Wimbledon?" Assume the system is unable to find any obvious answer strings, but does find the following sentences containing "Bjorn Borg" and "Wimbledon", as well as a number:</p><p>(1) Bjorn Borg blah blah Wimbledon blah blah 5 blah</p><p>(2) Wimbledon blah blah blah Bjorn Borg blah 37 blah.</p><p>(3) blah Bjorn Borg blah blah 5 blah blah Wimbledon (4) 5 blah blah Wimbledon blah blah Bjorn Borg.</p><p>By virtue of the fact that the most frequent number in these sentences is 5, we can posit that as the most likely answer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RELATED WORK</head><p>Other researchers have recently looked to the web as a resource for question answering. The Mulder system described by Kwok et al. <ref type="bibr" target="#b14">[14]</ref> is similar to our approach in several respects. For each question, Mulder submits multiple queries to a web search engine and analyzes the results. Mulder does sophisticated parsing of the query and the full-text of retrieved pages, which is far more complex and compute-intensive than our analysis. They also require global idf term weights for answer extraction and selection, which requires local storage of a database of term weights. They have done some interesting user studies of the Mulder interface, but they have not evaluated it with TREC queries nor have they looked at the importance of various system components.</p><p>Clarke et al. <ref type="bibr" target="#b9">[9]</ref>[10] investigated the importance of redundancy in their question answering system. In <ref type="bibr" target="#b9">[9]</ref> they found that the best weighting of passages for question answering involves using both passage frequency (what they call redundancy) and a global idf term weight. They also found that analyzing more top-ranked passages was helpful in some cases and not in others. Their system builds a full-content index of a document collection, in this case TREC. In <ref type="bibr" target="#b10">[10]</ref> they use web data to reinforce the scores of promising candidate answers by providing additional redundancy, with good success. Their implementation requires an auxiliary web corpus be available for full-text analysis and global term weighting. In our work, the web is the primary source of redundancy and we operate without a full-text index of documents or a database of global term weights.</p><p>Buchholz's Shapaqa NLP system <ref type="bibr">[7]</ref> has been evaluated on both TREC and Web collections. Question answering accuracy was higher with the Web collection (although both runs were poor in absolute terms), but few details about the nature of the differences are provided.</p><p>These systems typically perform complex parsing and entity extraction for both queries and best matching web pages ([7] <ref type="bibr" target="#b14">[14]</ref>), which limits the number of web pages that they can analyze in detail. Other systems require term weighting for selecting or ranking the best-matching passages ([10] <ref type="bibr" target="#b14">[14]</ref>) and this requires auxiliary data structures. Our approach is distinguished from these in its simplicity (simple rewrites and string matching) and efficiency in the use of web resources (use of only summaries and simple ranking). We now describe how our system uses redundancy in detail and evaluate this systematically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SYSTEM OVERVIEW</head><p>A flow diagram of our system is shown in Figure <ref type="figure">1</ref>. The system consists of four main components.</p><p>Rewrite Query. Given a question, the system generates a number of rewrite strings, which are likely substrings of declarative answers to the question. To give a simple example, from the question "When was Abraham Lincoln born?" we know that a likely answer formulation takes the form "Abraham Lincoln was born on &lt;DATE&gt;". Therefore, we can look through the collection of documents, searching for such a pattern.</p><p>We first classify the question into one of seven categories, each of which is mapped to a particular set of rewrite rules. Rewrite rule sets range in size from one to five rewrite types. The output of the rewrite module is a set of 3-tuples of the form [string, L/R/-, weight], where "string" is the reformulated search query, "L/R/-" indicates the position in the text where we expect to find the answer with respect to the query string (to the left, right or anywhere) and "weight" reflects how much we prefer answers found with this particular query. The idea behind using a weight is that answers found using a high precision query (e.g., "Abraham Lincoln was born on") are more likely to be correct than those found using a lower precision query (e.g., "Abraham" AND "Lincoln" AND "born").</p><p>We do not use a parser or part-of-speech tagger for query reformulation, but do use a lexicon in order to determine the possible parts-of-speech of a word as well as its morphological variants. We created the rewrite rules and associated weights manually for the current system, although it may be possible to learn query-to-answer reformulations and weights (e.g. see Agichtein et al. <ref type="bibr" target="#b4">[4]</ref>; Radev et al. <ref type="bibr" target="#b17">[17]</ref>).</p><p>The rewrites generated by our system are simple string-based manipulations. For instance, some question types involve query rewrites with possible verb movement; the verb "is" in the question "Where is the Louvre Museum located?" should be moved in formulating the desired rewrite to "The Louvre Museum is located in". While we might be able to determine where to move a verb by analyzing the sentence syntactically, we took a much simpler approach. Given a query such as "Where is w 1 w 2 … w n ", where each of the w i is a word, we generate a rewrite for each possible position the verb could be moved to (e.g. "w 1 is w 2 … w n ", "w 1 w 2 is … w n ", etc). While such an approach results in many nonsensical rewrites (e.g. "The Louvre is Museum located in"), these very rarely result in the retrieval of bad pages, and the proper movement position is guaranteed to be found via exhaustive search. If we instead relied on a parser, we would require fewer query rewrites, but a misparse would result in the proper rewrite not being found.</p><p>For each query we also generate a final rewrite which is a backoff to a simple ANDing of the non-stop words in the query. We could backoff even further to ranking using a best-match retrieval system which doesn't require the presence of all terms and uses differential term weights, but we did not find that this was necessary when using the Web as a source of data. There are an average of 6.7 rewrites for the 500 TREC-9 queries used in the experiments described below.</p><p>As an example, the rewrites for the query "Who created the character of Scrooge?" are: LEFT_5_"created +the character +of Scrooge" RIGHT_5_"+the character +of Scrooge +was created +by" AND_2_"created" AND "+the character" AND "+of Scrooge" AND_1_"created" AND "character" AND "Scrooge"</p><p>To date we have used only simple string matching techniques. Soubbotin and Soubbotin <ref type="bibr" target="#b18">[18]</ref> have used much richer regular expression matching to provide hints about likely answers, with very good success in TREC 2001, and we could certainly incorporate some of these ideas in our rewrites. Note that many of our rewrites require the matching of stop words like "in" and "the", in the above example. In our system stop words are important indicators of likely answers, and we do not ignore them as most ranked retrieval systems do, except in the final backoff AND rewrite.</p><p>The query rewrites are then formulated as search engine queries and sent to a search engine from which page summaries are collected and analyzed.</p><p>Mine N-Grams. From the page summaries returned by the search engine, n-grams are mined. For reasons of efficiency, we use only the returned summaries and not the full-text of the corresponding web page. The returned summaries contain the query terms, usually with a few words of surrounding context. In some cases, this surrounding context has truncated the answer string, which may negatively impact results. The summary text is then processed to retrieve only strings to the left or right of the query string, as specified in the rewrite triple.</p><p>1-, 2-, and 3-grams are extracted from the summaries. An N-gram is scored according the weight of the query rewrite that retrieved it. These scores are summed across the summaries that contain the n-gram (which is the opposite of the usual inverse document frequency component of document/passage ranking schemes). We do not count frequency of occurrence within a summary (the usual tf component in ranking schemes). Thus, the final score for an n-gram is based on the rewrite rules that generated it and the number of unique summaries in which it occurred. When searching for candidate answers, we enforce the constraint that at most one stopword is permitted to appear in any potential n-gram answers.</p><p>The top-ranked n-grams for the Scrooge query are:</p><p>Dickens Filter/Reweight N-Grams. Next, the n-grams are filtered and reweighted according to how well each candidate matches the expected answer-type, as specified by a handful of handwritten filters. The system uses filtering in the following manner. First, the query is analyzed and assigned one of seven question types, such as who-question, what-question, or how-many-question.</p><p>Based on the query type that has been assigned, the system determines what collection of filters to apply to the set of potential answers found during n-gram harvesting. The answers are analyzed for features relevant to the filters, and then rescored according to the presence of such information.</p><p>A collection of approximately 15 filters were developed based on human knowledge about question types and the domain from which their answers can be drawn. These filters used surface string features, such as capitalization or the presence of digits, and consisted of handcrafted regular expression patterns.</p><p>After the system has determined which filters to apply to a pool of candidate answers, the selected filters are applied to each candidate string and used to adjust the score of the string. In most cases, filters are used to boost the score of a potential answer when it has been determined to possess the features relevant to the query type. In other cases, filters are used to remove strings from the candidate list altogether. This type of exclusion was only performed when the set of correct answers was determined to be a closed set (e.g. "Which continent….?") or definable by a set of closed properties (e.g. "How many…?").</p><p>Tile N-Grams. Finally, we applied an answer tiling algorithm, which both merges similar answers and assembles longer answers out of answer fragments. Tiling constructs longer n-grams from sequences of overlapping shorter n-grams. For example, "A B C" and "B C D" is tiled into "A B C D." The algorithm proceeds greedily from the top-scoring candidate -all subsequent candidates (up to a certain cutoff) are checked to see if they can be tiled with the current candidate answer. If so, the higher scoring candidate is replaced with the longer tiled n-gram, and the lower scoring candidate is removed. The algorithm stops only when no n-grams can be further tiled. Our system works most efficiently and naturally with a backend retrieval system that returns best-matching passages or queryrelevant document summaries. We can, of course, post-process the full text of matching documents to extract summaries for ngram mining, but this is inefficient especially in Web applications where the full text of documents would have to be downloaded over the network at query time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTS</head><p>For our experimental evaluations we used the first 500 TREC-9 queries (201-700) <ref type="bibr" target="#b19">[19]</ref>. For simplicity we ignored queries which are syntactic rewrites of earlier queries (701-893), although including them does not change the results in any substantive way. We used the patterns provided by NIST for automatic scoring. A few patterns were slightly modified to accommodate the fact that some of the answer strings returned using the Web were not available for judging in TREC-9. We did this in a very conservative manner allowing for more specific correct answers (e.g., Edward J. Smith vs. Edward Smith) but not more general ones (e.g., Smith vs. Edward Smith), and simple substitutions (e.g., 9 months vs. nine months). These changes influence the absolute scores somewhat but do not change relative performance, which is our focus here.</p><p>Many of the TREC queries are time sensitive -that is, the correct answer depends on when the question is asked. The TREC database covers a period of time more than 10 years ago; the Web is much more current. Because of this mismatch, many correct answers returned from the Web will be scored as incorrect using the TREC answer patterns. 10-20% of the TREC queries have temporal dependencies. E.g., Who is the president of Bolivia? What is the exchange rate between England and the U. S.? We did not modify the answer key to accommodate these time differences, because this is a subjective job and would make comparison with earlier TREC results impossible.</p><p>For the main Web retrieval experiments we used Google as a backend because it provides query-relevant summaries that make our n-gram mining techniques more efficient. Thus we have access to more than 2 billion web pages. For some experiments in TREC retrieval we use the standard QA collection consisting of news documents from Disks 1-5. The TREC collection has just under 1 million documents <ref type="bibr" target="#b19">[19]</ref>.</p><p>All runs are completely automatic, starting with queries and generating a ranked list of 5 candidate answers. Candidate answers are a maximum of 50 bytes long, and typically much shorter than that. We report the Mean Reciprocal Rank (MRR) of the first correct answer, the Number of Questions Correctly Answered (NumCorrect), and the Proportion of Questions Correctly Answered (PropCorrect). Correct answers at any rank are included in the number and proportion correct measures. Most correct answers are at the top of the list --70% of the correct answers occur in the first position and 90% in the first or second positions.</p><p>Using our system with default settings for query rewrite weights, number of summaries returned, etc. we obtain a MRR of 0.507 and answer 61% of the queries. The average answer length was 12 bytes, so the system is really returning short answers not passages. This is very good performance and would place us near the top of 50-byte runs for TREC-9. However, since we did not take part in TREC-9 it is impossible to compare our results precisely with those systems (e.g., we used TREC-9 for tuning our TREC-10 system increasing our score somewhat, but we return several correct answers that were not found in TREC-9 thus decreasing our score somewhat).</p><p>Redundancy is used in two key ways in our data-driven approach.</p><p>First, the occurrence of multiple linguistic formulations of the same answers increases the chances of being able to find an answer that occurs within the context of a simple pattern match with the query. Second, answer redundancy facilitates the process of answer extraction by giving higher weight to answers that occur more often (i.e., in more different document summaries). We now evaluate the contributions of these experimentally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Number of Snippets</head><p>We begin by examining the importance of redundancy in answer extraction. To do this we vary the number of summaries (snippets) that we get back from the search engine and use as input to the n-gram mining process. Our standard system uses 100 snippets. We varied the number of snippets from 1 to 1000. The results are shown in Figure <ref type="figure" target="#fig_0">2</ref>.</p><p>Performance improves sharply as the number of snippets increases from 1 to 50 (0.243 MRR for 1 snippet, 0.370 MRR for 5, 0.423 MRR for 10, and 0.501 for 50), somewhat more slowly after that (peaking 0.514 MRR with 200 snippets), and then falling off somewhat after that as more snippets are included for n-gram analysis. Thus, over quite a wide range, the more snippets we consider in selecting and ranking n-grams the better. We believe that the slight drop at the high end is due to the increasing influence that the weaker rewrites have when many snippets are returned. The most restrictive rewrites return only a few matching documents.</p><p>Increasing the number of snippets increases the number of the least restrictive matches (the AND matches), thus swamping the restrictive matches. In addition, frequent n-grams begin to dominate our rankings at this point.</p><p>An example of failures resulting from too many AND matches is Query 594: What is the longest word in the English language? For this query, there are 40 snippets matching the rewrite "is the longest word in the English language" with weight 5, 40 more snippets matching the rewrite "the longest word in the English language is" with the weight 5, and more than 100 snippets matching the backoff AND query ("longest" AND "word" AND "English" AND "language") with a weight of 1. When 100 snippets are used, the precise rewrites contribute almost as many snippets as the AND rewrite. In this case we find the correct answer, "pneumonoultramicroscopicsilicovolcanokoniosis", in the second rank.</p><p>The first answer, "1909 letters long", which is incorrect, also matches many precise rewrites such as "the longest word in English is ## letters long", and we pick up on this. When 1000 snippets are used, the weaker AND rewrites dominate the matches. In this case, the correct answer falls to seventh on the list after "letters long", "one syllable", "is screeched", "facts", "stewardesses" and "dictionary", all of which occur commonly in results from the least restrictive AND rewrite. A very common AND match contains the phrase "the longest one-syllable word in the English language is screeched", and this accounts for two of our incorrect answers.</p><p>Using differential term weighting of answer terms, as many retrieval systems do, should help overcome this problem to some extent but we would like to avoid maintaining a database of global term weights.</p><p>Alternatively we could refine our weight accumulation scheme to dampen the effects of many weakly restrictive matches by sub-linear accumulation, and we are currently exploring several alternatives for doing this.</p><p>Our main results on snippet redundancy are consistent with those reported by Clarke et al. <ref type="bibr" target="#b9">[9]</ref>, although they worked with the much smaller TREC collection. They examined a subset of the TREC-9 queries requiring a person's name as the answer. They varied the number of passages retrieved (which they call depth) from 25 to 100, and observed some improvements in MRR. When the passages they retrieved were small (250 or 500 bytes) they found improvement, but when the passages were larger (1000 or 2000 bytes) no improvements were observed. The snippets we used are shorter than 250 bytes, so the results are consistent. Clarke et al. <ref type="bibr" target="#b9">[9]</ref> also explored a different notion of redundancy (which they refer to as c i ). c i is the number of different passages that match an answer. Their best performance is achieved when both c i and term weighting are used to rank passages. We too use the number of snippets that an n-gram occurs in. We do not, however, use global term weights, but have tried other techniques for weighting snippets as described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">TREC vs. Web Databases</head><p>Another way to explore the importance of redundancy is to run our system directly on the TREC documents. As noted earlier, there are three orders of magnitude more documents on the Web than in the TREC QA collection.</p><p>Consequently, there will be fewer alternative ways of saying the same thing and fewer matching documents available for mining the candidate n-grams. We suspect that this lack of redundancy will limit the success of our approach when applied directly on TREC documents.</p><p>While corpus size is an obvious and important difference between the TREC and Web collections there are other differences as well. For example, text analysis, ranking, and snippet extraction techniques will all vary somewhat in ways that we can not control. To better isolate the size factor, we also ran our system against another Web search engine.</p><p>For these experiments we used only the AND rewrites and looked at the first 100 snippets. We had to restrict ourselves to AND rewrites because some of the search engines we used do not support the inclusion of stop words in phrases, e.g., "created +the character +of Scrooge".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">TREC Database</head><p>The TREC QA collection consists of just under 1 million documents. We expect much less redundancy here compared to the Web, and suspect that this will limit the success of our approach. An analysis of the TREC-9 query set (201-700) shows that no queries have 100 judged relevant documents. Only 10 of the 500 questions have 50 or more relevant documents, which the results in Figure <ref type="figure" target="#fig_0">2</ref> suggest are required for the good system performance. And a very large number of queries, 325, have fewer than 10 relevant documents.</p><p>We used an Okapi backend retrieval engine for the TREC collection. Since we used only Boolean AND rewrites, we did not take advantage of Okapi's best match ranking algorithm. However, most queries return fewer than 100 documents, so we wind up examining most of the matches anyway.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We developed two snippet extraction techniques to generate query-relevant summaries for use in n-gram mining.</head><p>A Contiguous technique returned the smallest window containing all the query terms along with 10 words of context on either side. Windows that were greater than 500 words were ignored. This approach is similar to passage retrieval techniques albeit without differential term weighting.</p><p>A Non-Contiguous technique returned the union of two word matches along with 10 words of context on either side. Single words not previously covered are included as well. The search engine we used for the initial Web experiments returns both contiguous and non-contiguous snippets. Figure <ref type="figure">3</ref> shows the results of this experiment. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MRR</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AND Rewrites Only, Top 100</head><p>Figure <ref type="figure">3</ref>: Web vs. TREC as data source</p><p>Our baseline system using all rewrites and retrieving 100 snippets achieves 0.507 MRR (Figure <ref type="figure" target="#fig_0">2</ref>). Using only the AND query rewrites results in worse performance for our baseline system with 0.450 MRR (Figure <ref type="figure">3</ref>). More noticeable than this difference is the drop in performance of our system using TREC as a data source compared to using the much larger Web as a data source. MRR drops from 0.450 to 0.186 for contiguous snippets and 0.187 for non-contiguous snippets, and the proportion of questions answered correctly drops from 56% to 23% for contiguous snippets and 26% for non-contiguous snippets. It is worth noting that the TREC MRR scores would still place this system in the top half of the systems for the TREC-9 50-byte task, even though we tuned our system to work on much larger collections. However, we can do much better simply by using more data. The lack of redundancy in the TREC collection accounts for a large part of this drop off in performance. Clarke et al. <ref type="bibr" target="#b10">[10]</ref> have also reported better performance using the Web directly for TREC 2001 questions.</p><p>We expect that the performance difference between TREC and the Web would increase further if all the query rewrites were used. This is because there are so few exact phrase matches in TREC relative to the Web, and the precise matches improve performance by 13% (0.507 vs. 0.450).</p><p>We believe that database size per se (and the associated redundancy) is the most important difference between the TREC and Web collections. As noted above, however, there are other differences between the systems such as text analysis, ranking, and snippet extraction techniques. While we can not control the text analysis and ranking components of Web search engines, we can use the same snippet extraction techniques. We can also use a different Web search engine to mitigate the effects of a specific text analysis and ranking algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Another Web Search Engine</head><p>For these experiments we used the MSNSearch search engine. At the time of our experiments, the summaries returned were independent of the query. So we retrieved the full text of the top 100 web pages and applied the two snippet extraction techniques described above to generate query-relevant summaries. As before, all runs are completely automatic, starting with queries, retrieving web pages, extracting snippets, and generating a ranked list of 5 candidate answers. The results of these experiments are shown in Figure <ref type="figure" target="#fig_1">4</ref>. The original results are referred to as Web1 and the new results as Web2.  The Web2 results are somewhat worse than the Web1 results, but this is expected given that we developed our system using the Web1 backend, and did not do any tuning of our snippet extraction algorithms. In addition, we believe that the Web2 collection indexed somewhat less content than Web1 at the time of our experiments, which should decrease performance in and of itself. More importantly, the Web2 results are much better than the TREC results for both snippet extraction techniques, almost doubling MRR in both cases. Thus, we have shown that QA is more successful using another large Web collection compared to the small TREC collection. The consistency of this result across Web collections points to size and redundancy as the key factors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MRR</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Combining TREC and Web</head><p>Given that the system benefits from having a large text collection from which to search for potential answers, then we would expect that combining both the Web and TREC corpus would result in even greater accuracy. We ran two experiments to test this. Because there was no easy way to merge the two corpora, we instead combined the output of QA system built on each corpus.</p><p>For these experiments we used the original Web1 system and our TREC system. We used only the AND query rewrites, looked at the Top1000 search results for each rewrite, and used a slightly different snippet extraction technique. For these parameter settings, the base TREC-based system had a MRR of .262, the Web-based system had a MRR of .416.</p><p>First, we ran an oracle experiment to assess the potential gain that could be attained by combining the output of the Web-based and TREC-based QA systems. We implemented a "switching oracle", which decides for each question whether to use the output from the Web-based QA system or the TREC-based QA system, based upon which system output had a higher ranking correct answer.</p><p>The switching oracle had a MRR of .468, a 12.5% improvement over the Web-based system. Note that this oracle does not precisely give us an upper bound, as combining algorithms (such as that described below) could re-order the rankings of outputs.</p><p>Next, we implemented a combining algorithm that merged the outputs from the TREC-based and Web-based systems, by having both systems vote on answers, where the vote is the score assigned to a particular answer by the system. For voting, we defined string equivalence such that if a string X is a substring of Y, then a vote for X is also a vote for Y. The combined system achieved a MRR of .433 (a 4.1% improvement over the Webbased system) and answered 283 questions correctly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Snippet Weighting</head><p>Until now, we have focused on the quantity of information available and less on its quality. Snippet weights are used in ranking n-grams. An n-gram weight is the sum of the weights for all snippets in which that n-gram appears.</p><p>Each of our query rewrites has a weight associated with it reflecting how much we prefer answers found with this particular query. The idea behind using a weight is that answers found using a high precision query (e.g., "Abraham Lincoln was born on") are more likely to be correct than those found using a lower precision query (e.g., "Abraham" AND "Lincoln" AND "born"). Our current system has 5 weights. These rewrite weights are the only source of snippet weighting in our system. We explored how important these weight are and considered several other factors that could be used as additional sources of information for snippet weighting. Although we specify Boolean queries, the retrieval engine can provide a ranking, based on factors like link analyses, proximity of terms, location of terms in the document, etc. So, different weights can be assigned to matches at different positions in the ranked list. We also looked at the number of matching terms in the best fixed width window, and the widow size of the smallest matching passage as indicators of passage quality.</p><p>Rewrite Wts uses our heuristically determined rewrite weights as a measure the quality of a snippet. This is the current system default. Equal Wts gives equal weight to all snippets regardless of the rewrite rule that generated them. To the extent that more precise rewrites retrieve better answers, we will see a drop in performance when we make all weights equal. Rank Wts uses the rank of the snippet as a measure of its quality, SnippetWt = (100rank)/100. NMatch Wts uses the number of matching terms in a fixed-width window as the measure of snippet quality. Length Wts uses a measure of the length of the snippet needed to encompass all query terms as the measure of snippet quality. We also look at combinations of these factors. For example, Rewrite+Rank Wts uses both rewrite weight and rank according to the following formula, SnippetWt = RewriteScore + (100rank)/100.</p><p>All of these measures are available from queryrelevant summaries returned by the search engine and do not require analyzing the full text of the document. The results of these experiments are presented in Figure <ref type="figure" target="#fig_1">4</ref>. noted above is an exception. Soubbotin and Soubbotin <ref type="bibr" target="#b18">[18]</ref> mention different weights for different regular expression matches, but they did not describe the mechanism in detail nor did they evaluate how useful it is. Harabagiu et al. <ref type="bibr" target="#b11">[11]</ref> have a kind of backoff strategy for matching which is similar to weighting, but again we do not know of parametric evaluations of its importance in their overall system performance. The question of what kinds of passages can best support answer mining for question answering as opposed to document retrieval is an interesting one that we are pursuing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Weighting</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION AND FUTURE DIRECTIONS</head><p>The design of our question answering system was motivated by the goal of exploiting the large amounts of text data that is available on the Web and elsewhere as a useful resource. While many question answering systems take advantage of linguistic resources, fewer depend primarily on data. Vast amounts of data provide several sources of redundancy that our system capitalizes on.</p><p>Answer redundancy (i.e., multiple, differently phrased, answer occurrences) enables us to use only simple query rewrites for matching, and facilitates the extraction of candidate answers.</p><p>We evaluated the importance of redundancy in our system parametrically. First, we explored the relationship between the number of document snippets examined and question answering accuracy. Accuracy improves sharply as the number of snippets included for n-gram analysis increases from 1 to 50, somewhat more slowly after that peaking at 200 snippets, and then falls off somewhat after that. More is better up to a limit. We believe that we can increase this limit by improving our weight accumulation algorithm so that matches from the least precise rewrites do not dominate. Second, in smaller collections (like TREC), the accuracy of our system drops sharply, although it is still quite reasonable in absolute terms.</p><p>Finally, snippet quality is less important to system performance than snippet quantity. We have a simple 5-level snippet weighting scheme based on the specificity of the query rewrite, and this appears to be sufficient. More complex weighting schemes that we explored were no more useful.</p><p>The performance of our system shows promise for approaches to question answering which makes use of very large text databases even with minimal natural language processing. Our system does not need to maintain its own index nor does it require global term weights, so it can work in conjunction with any backend retrieval engine. Finally, since our system does only simple query transformations and n-gram analysis, it is efficient and scalable.</p><p>One might think that our system has limited applicability, because it works best with large amounts of data. But, this isn't necessarily so. First, we actually perform reasonably well in the smaller TREC collection, and could perhaps tune system parameters to work even better in that environment. More interestingly, Brill et al. <ref type="bibr" target="#b6">[6]</ref> described a projection technique that can be used to combine the wealth of data available on the Web with the reliability of data in smaller sources like TREC or an encyclopedia. The basic idea is to find candidate answers in a large and possibly noisy source, and then expand the query to include likely answers. The expanded queries can then be used on smaller but perhaps more reliable collections -either directly to find support for the answer in the smaller corpus, or indirectly as a new query which is issued and mined as we currently do. This approach appears to be quite promising. Our approach seems least applicable in applications that involve a small amount of proprietary data. In these cases, one might need to do much more sophisticated analyses to map user queries to the exact lexical form that occur in the text collection rather than depend on primarily on redundancy as we have done.</p><p>Although we have pushed the data-driven perspective, more sophisticated language analysis might help as well by providing more effective query rewrites or less noisy data for mining.</p><p>Most question answering systems contain aspects of both -we use some linguistic knowledge in our small query typology and answer filtering, and more sophisticated systems often use simple pattern matching for things like dates, zip codes, etc.</p><p>There are a number of open questions that we hope to explore. In the short term, we would like to look systematically at the contributions of other system components. Brill et al. <ref type="bibr" target="#b5">[5]</ref> have started to explore individual components in more detail, with interesting results. In addition, it is likely that we have made several sub-optimal decisions in our initial implementation (e.g., omitting most stop words from answers, simple linear accumulation of scores over matching snippets) that we would like to improve. Most retrieval engines have been developed with the goal of finding topically relevant documents. Finding accurate answers may require somewhat different matching infrastructure. We are beginning to explore how best to generate snippets for use in answer mining. Finally, time is an interesting issue. We noted earlier how the correct answer to some queries changes over time. Time also has interesting implications for using redundancy. For example, it would take a while for a news or Web collection to correctly answer a question like "Who is the U. S. President?" just after an election.</p><p>An important goal of our work is to get system designers to treat data as a first class resource that is widely available and exploitable. We have made good initial progress, and there are several interesting issues remaining to explore.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. MRR as a function of number of snippets returned. TREC-9, queries 201-700.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Web vs. TREC as data source</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">Mining Answers from Text and Knowledge Bases</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>AAAI Spring Symposium Series</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Answer extraction</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singhal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6 th Applied Natural Language Processing Conference (ANLP 2000)</title>
		<meeting>the 6 th Applied Natural Language Processing Conference (ANLP 2000)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="296" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Workshop on Open-domain Question Answering</title>
		<author>
			<persName><surname>Acl-Eacl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Learning search engine specific query transformations for question answering</title>
		<author>
			<persName><forename type="first">E</forename><surname>Agichtein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lawrence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10 th World Wide Web Conference</title>
		<meeting>the 10 th World Wide Web Conference</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An analysis of the AskMSR question-answering system</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dumais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Banko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2002 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>2002 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Data-intensive question answering</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Banko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dumais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Text REtrieval Conference</title>
		<meeting>the Tenth Text REtrieval Conference</meeting>
		<imprint>
			<date type="published" when="2001">2002. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Using grammatical relations, answer frequencies and the World Wide Web for TREC question answering</title>
		<author>
			<persName><forename type="first">S</forename><surname>Buchholz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Text REtrieval Conference</title>
		<meeting>the Tenth Text REtrieval Conference</meeting>
		<imprint>
			<date type="published" when="2001">2002. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Question answering: CNLP at the TREC-10 question answering track</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Diekema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Taffet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mccracken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Ozgencil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Yilmazel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Liddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Text REtrieval Conference</title>
		<meeting>the Tenth Text REtrieval Conference</meeting>
		<imprint>
			<publisher>TREC</publisher>
			<date type="published" when="2001">2002. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Exploiting redundancy in question answering</title>
		<author>
			<persName><forename type="first">C</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cormack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lyman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24 th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval</title>
		<meeting>the 24 th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval</meeting>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="358" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Web reinforced question answering</title>
		<author>
			<persName><forename type="first">C</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cormack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lynam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Text REtrieval Conference</title>
		<meeting>the Tenth Text REtrieval Conference</meeting>
		<imprint>
			<publisher>TREC</publisher>
			<date type="published" when="2001">2002. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">FALCON: Boosting knowledge for question answering</title>
		<author>
			<persName><forename type="first">S</forename><surname>Harabagiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Moldovan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pasca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mihalcea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Surdeanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bunescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Girju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Morarescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth Text REtrieval Conference</title>
		<meeting>the Ninth Text REtrieval Conference</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="479" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Question answering in Webclopedia</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hovy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gerber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Hermjakob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Junk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth Text REtrieval Conference</title>
		<meeting>the Ninth Text REtrieval Conference</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="655" to="664" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The use of external knowledge in factoid QA</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hovy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Hermjakob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Text REtrieval Conference</title>
		<meeting>the Tenth Text REtrieval Conference</meeting>
		<imprint>
			<date type="published" when="2001">2002. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Scaling question answering to the Web</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kwok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Weld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10 th World Wide Web Conference (WWW&apos;10)</title>
		<meeting>the 10 th World Wide Web Conference (WWW&apos;10)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="150" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">High performance question/answering</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Pasca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Harabagiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24 th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval</title>
		<meeting>the 24 th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval</meeting>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="366" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Question answering by predictive annotation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Prager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Coden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Radev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23 rd Annual International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR&apos;2000)</title>
		<meeting>the 23 rd Annual International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR&apos;2000)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="184" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Mining the web for answers to natural language questions</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Radev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Blair-Goldensohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Prager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 2001 ACM CIKM: Tenth International Conference on Information and Knowledge Management</title>
		<meeting>eeding of the 2001 ACM CIKM: Tenth International Conference on Information and Knowledge Management</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="143" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Patterns and potential answer expressions as clues to the right answers</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Soubbotin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Soubbotin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Text REtrieval Conference</title>
		<meeting>the Tenth Text REtrieval Conference</meeting>
		<imprint>
			<publisher>TREC</publisher>
			<date type="published" when="2001">2002. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth Text REtrieval Conference (TREC-9)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Voorhees</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Harman</surname></persName>
		</editor>
		<meeting>the Ninth Text REtrieval Conference (TREC-9)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="500" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Text REtrieval Conference</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Voorhees</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Harman</surname></persName>
		</editor>
		<meeting>the Tenth Text REtrieval Conference<address><addrLine>TREC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2002. 2001</date>
			<biblScope unit="page" from="500" to="250" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
