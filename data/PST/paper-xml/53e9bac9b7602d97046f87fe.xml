<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On Short Paths Interdiction Problems: Total and Node-Wise Limited Interdiction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-07-10">10 July 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Leonid</forename><surname>Khachiyan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Endre</forename><surname>Boros</surname></persName>
							<email>boros@rutcor.rutgers.edu</email>
						</author>
						<author>
							<persName><forename type="first">Konrad</forename><surname>Borys</surname></persName>
							<email>kborys@rutcor.rutgers.edu</email>
						</author>
						<author>
							<persName><forename type="first">Khaled</forename><surname>Elbassioni</surname></persName>
							<email>elbassio@mpi-sb.mpg.de</email>
						</author>
						<author>
							<persName><forename type="first">Vladimir</forename><surname>Gurvich</surname></persName>
							<email>gurvich@rutcor.rutgers.edu</email>
						</author>
						<author>
							<persName><forename type="first">Gabor</forename><surname>Rudolf</surname></persName>
							<email>grudolf@rutcor.rutgers.edu</email>
						</author>
						<author>
							<persName><forename type="first">Jihui</forename><surname>Zhao</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">RUTCOR</orgName>
								<orgName type="institution" key="instit2">Rutgers University</orgName>
								<address>
									<addrLine>640 Bartholomew Road</addrLine>
									<postCode>08854</postCode>
									<settlement>Piscataway</settlement>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Max-Planck-Institüt für Informatik</orgName>
								<address>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Rutgers University</orgName>
								<address>
									<addrLine>110 Frelinghuysen Road</addrLine>
									<postCode>08854</postCode>
									<settlement>Piscataway</settlement>
									<region>NJ</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On Short Paths Interdiction Problems: Total and Node-Wise Limited Interdiction</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-07-10">10 July 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">AE84BAE2DAEA71810D6C686D6E7E8DB2</idno>
					<idno type="DOI">10.1007/s00224-007-9025-6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Given a directed graph G = (V , A) with a non-negative weight (length) function on its arcs w : A → R + and two terminals s, t ∈ V , our goal is to destroy all short directed paths from s to t in G by eliminating some arcs of A. This is known as the short paths interdiction problem. We consider several versions of it, and in each case analyze two subcases: total limited interdiction, when a fixed number k of arcs can be removed, and node-wise limited interdiction, when for each node v ∈ V a fixed number k(v) of out-going arcs can be removed. Our results indicate that the latter subcase is always easier than the former one. In particular, we show that the short paths</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Node-Wise Limited Interdiction</head><p>Let G = (V , A) be a directed graph (digraph) with given arc-weights w(e), e ∈ A. For each vertex v ∈ V , we are allowed to delete (remove, block, interdict) a subset X(v) of the arcs A(v) = {e ∈ A | e = (v, u)} leaving v. We assume that these arc-sets X(v) ⊆ A(v) are selected for all vertices v ∈ V independently, and we call the collection B(v) of all admissible arc-sets X(v) a blocking system at v. We also assume that for each v, the family B(v) forms an independence system, i.e., if X(v) ∈ B(v) is an admissible arc-set at v, then so is any subset of X(v). Hence, we could replace B(v) by the collection of all inclusion-wise maximal admissible arc-sets. In general, we will only assume that the blocking system B(v) is given by a membership oracle O: (B 0 ) Given a list X(v) of out-going arcs for some vertex v, the oracle can determine whether or not the set of arcs in the list belong to B(v) and hence can be simultaneously deleted.</p><p>A similar formalization of blocking sets via membership oracles is used by Pisaruk <ref type="bibr" target="#b32">[33]</ref>. We will also consider two special types of blocking systems:</p><p>(B 1 ) The blocking system is given by a function k(v) :</p><formula xml:id="formula_0">V → Z + , where k(v) ≤ |A(v)| = out-deg(v).</formula><p>For each vertex v, we can delete any collection of (at most) k(v) arcs leaving v. The numbers k(v) define digraphs with prohibitions considered by Karzanov and Lebedev <ref type="bibr" target="#b26">[27]</ref>. (B 2 ) There are two types of vertices: control vertices, where we can select any outgoing arc e ∈ A(v) and block all the remaining arcs in A(v), and regular vertices, where we can block no arc. This case, considered in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b19">20]</ref>, is a special case of B 1 : k(v) = |A(v)| -1 for control vertices, and k(v) = 0 otherwise.</p><p>We call a digraph G = (V , A ) admissible for G = (V , A) if A ⊆ A is obtained by deleting an admissible subset X(v) ∈ B(v) of outgoing arcs for each vertex v ∈ V .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Interdiction of Directed Cycles</head><p>We proceed with an obvious observation. Let G = (V , A) be a directed graph (digraph) and our goal is to destroy all directed cycles in G. In this case the total limited interdiction problem is stated as follows. Is it possible to destroy all directed cycles of G by eliminating (at most) k arcs of A, or in other words, whether G has a feedback arc set of size (at most) k? In 1972 Karp <ref type="bibr" target="#b24">[25]</ref> proved that this decision problem is NP-hard. Node-wise limited cycle interdiction problem of type B 1 can be stated as follows. Is it possible to destroy all directed cycles in G by deleting for each node v ∈ V (at most) k(v) arcs going from v? This problem is trivial. Indeed, if k(v) &lt; out-deg(v) for each v ∈ V then the answer is negative, since for each v ∈ V at least one outgoing arc will remain and they will form a directed cycle, since G is finite. If k(v) ≥ out-deg(v) for a vertex v ∈ V then obviously all out-going arcs from v should be removed, since after this we can delete the node v itself together with all in-going arcs. Repeating this simple procedure recursively we get a linear time algorithm for the node-wise limited directed cycle interdiction problem. The above algorithm can obviously be generalized for the interdiction of type B 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Interdiction of Negative Directed Cycles and Mean Payoff Games</head><p>Now let us assume that weights may be negative and consider the negative cycle interdiction problem. Clearly, the total limited version of it is NP-hard, since if all weights are negative then all directed cycles are negative too, and we obtain the previous NP-hard problem as a special case.</p><p>In contrast, the node-wise limited negative directed cycles interdiction is equivalent to a famous open problem, solving mean payoff games, <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref>, that is very unlikely NP-hard, since it is known to be in NP ∩ co-NP, <ref type="bibr" target="#b26">[27]</ref>, and there is a sub-exponential algorithm for it, <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr" target="#b22">[23]</ref>.</p><p>A mean payoff game is a zero-sum game played by two players on a finite arcweighted digraph G all vertices of which have positive out-degrees, in other words, there are no dead-ends in G. The vertices of G (positions) are partitioned into two sets controlled by two players, who move a chip along the arcs of the digraph, starting from a given vertex s ∈ V (the initial position). A positional strategy of a player is a mapping which assigns an out-going arc to each of his positions. If both players select positional strategies then the sequence of moves (the play) starts in s and settles on a simple directed cycle of G whose average arc-weight is called the effective payoff corresponding to the selected strategies.</p><p>Ehrenfeucht and Mycielski <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> and Moulin <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref> introduced mean payoff games on bipartite digraphs and proved the existence of the value for such games in positional strategies. Gurvich, Karzanov, and Khachiyan <ref type="bibr" target="#b19">[20]</ref> extended this result to arbitrary digraphs and suggested a potential-reduction algorithm to compute the value and optimal positional strategies of the players. In many respects this algorithm for mean payoff games is similar to the simplex method for linear programming.</p><p>Let us assume that the vertices assigned to the maximizing (respectively, to the minimizing) player are controlled (respectively, regular) vertices for B 2 . Then the determination of an optimal positional strategy for the maximizing player reduces to computing a B 2 -admissible digraph G = (V , A ) that maximizes the minimum average arc-cost for the cycles reachable from the initial position s. Beffara and Vorobyov <ref type="bibr" target="#b3">[4]</ref> report on computational experiments with the potential-reduction algorithm <ref type="bibr" target="#b19">[20]</ref> in which it was used to solve very large instances of mean payoff games. However, for some special instances with exponentially large arc-weights, this algorithm may require exponentially many steps <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b19">20]</ref>. Interestingly, computational experiments <ref type="bibr" target="#b4">[5]</ref> seem to indicate that such hard instances become easily solvable if the game is modified into an equivalent one by a random potential transformation.</p><p>Karzanov and Lebedev <ref type="bibr" target="#b26">[27]</ref> extended the potential-reduction algorithm <ref type="bibr" target="#b19">[20]</ref> to socalled mean payoff games with prohibitions, that is to interdiction of type B 1 . Pisaruk <ref type="bibr" target="#b32">[33]</ref> further extended these results to interdiction of type B 0 defined by an arbitrary membership oracle, and showed that in this general setting, the potential-reduction algorithm <ref type="bibr" target="#b19">[20]</ref> is pseudo-polynomial. Zwick and Paterson <ref type="bibr" target="#b39">[40]</ref> gave another pseudopolynomial algorithm for interdiction of type B 2 .</p><p>As mentioned above, mean payoff games can be reduced to the node-wise limited negative directed cycles interdiction. Indeed, if we fix a start vertex s, then determining whether the value of a mean payoff game on G = (V , A) exceeds some threshold ξ is equivalent to the following decision problem:</p><p>(ξ ) Is there an admissible digraph G such that the average arc-weight of each cycle reachable from s in G is at least ξ ?</p><p>After the substitution w(e) → w(e)ξ , for all e ∈ A, we may assume without loss of generality that ξ = 0. This completes the reduction. Björklund, Sandberg and Vorobyov <ref type="bibr" target="#b5">[6]</ref> recently showed that mean payoff games can be solved in expected sub-exponential time. A deterministic sub-exponential algorithm, for solving an important special case, the so-called parity games, was proposed by Jurdzinski, Paterson, and Zwick <ref type="bibr" target="#b22">[23]</ref>. However, the question as to whether this class of games can be solved in polynomial time remains open, even though the decision problem (ξ ) is in NP ∩ co-NP <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b39">40]</ref>.</p><p>Finally, let us consider a special case when digraph G contains only one negative arc, w(t, s) = -d, where d is a positive threshold. Let us also assume that, except (t, s), there is no other arc going from t and that B(t) = ∅, or in other words, that (t, s) cannot be deleted. It is easy to see that in this case negative directed cycles of G are in one-to-one correspondence with directed paths from s to t that are shorter than d. So we will destroy these paths rather than negative cycles. Since the arc (t, s) becomes irrelevant, we can delete it and get a network with non-negative weights. Thus, we come to the short paths interdiction problem that is studied in the rest of the paper. As usual, we consider two cases: total limited and node-wise limited interdiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Node-Wise Limited Short Paths Interdiction</head><p>Given a digraph G = (V , A) with a non-negative weight function w : A → R + , and a blocking system B, find an admissible digraph G that maximizes the distance from a given start vertex s to a given terminal vertex t:</p><formula xml:id="formula_1">(s, t) def = max{s-t distance in G | G is an admissible digraph for G}.</formula><p>We will see from what follows that, for any fixed terminal vertex t ∈ V , we can select an optimal admissible digraph that simultaneously maximizes the distances from all start vertices s. In other words, there exists an admissible digraph G o such that for all vertices v ∈ V \ {t}, we have</p><formula xml:id="formula_2">(v, t) ≡ v-t distance in G o .</formula><p>For this reason, it is convenient to consider the single-destination version of the above problem: MASPNLAI (Maximizing all shortest paths to a given terminal by node-wise limited arc interdiction) Given an arc-weighted digraph G = (V , A), a non-negative weight function w, a terminal vertex t ∈ V , and a blocking system B, find an optimal admissible digraph G o that maximizes the distances from all vertices v ∈ V \ {t} to t.</p><p>Let us remark however, that if we fix a start vertex s, instead of t, then distinct terminal vertices may require distinct optimal admissible digraphs. For example, consider a graph with three vertices s, t 1 , t 2 and two arcs, from s to both t 1 and t 2 . Assume further, that B allows to delete exactly one arc (going out form s). Clearly, to maximize the distance s-t 1 (respectively, s-t 2 ) one has to delete the arc (s, t 1 ) (respectively, (s, t 2 )). The same happens if we consider in-going rather than out-going arcs.</p><p>In Sect. 2 we show that MASPNLAI can be solved in strongly polynomial time by a natural extension of Dijkstra's algorithm.</p><p>Theorem 1 Given a digraph G = (V , A), a non-negative weight function w : A → R + , and a terminal vertex t ∈ V , (i) The special case of problem MASPNLAI for blocking systems B 1 can be solved in time</p><formula xml:id="formula_3">O |A| + |V | log |V | + v∈V \{t} [out-deg(v) -k(v)] log(k(v) + 1) .</formula><p>In We show parts (ii) and (iii) of the theorem by using an extension of Dijkstra's algorithm and breadth-first search, respectively. As mentioned in the theorem, both of these algorithms employ monotonically increasing membership queries and never de-block a previously blocked arc. This is not the case with the variant of Dijkstra's algorithm used in the proof of part (i). Note also that for blocks of type B 1 and B 2 , the above bounds include the blocking tests overhead, and that the bound stated in (i) for B 2 is as good as the running time of the fastest currently known strongly-polynomial algorithm by Fredman and Tarjan <ref type="bibr" target="#b11">[12]</ref> for the standard shortest path problem, without interdiction.</p><p>Let us also mention that by Theorem 1, problem MASPNLAI can be solved in strongly polynomial time for any digraph G = (V , A) that has no directed cycles of negative total arc-weight. Indeed, Gallai <ref type="bibr" target="#b13">[14]</ref> proved that if G has no negative cycles then all input arc-weights w(v, u) can be made non-negative by a potential transformation w(v, u) → w(v, u) + ε(v)ε(u), where ε : V → R are some vertex weights (potentials); see <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b34">35]</ref>. Clearly, the total weights of all directed cycles remain unchanged and the total weight of a directed path p from s to t is transformed as follows:</p><formula xml:id="formula_4">w(p(s, t)) → w(p(s, t)) + ε(s) -ε(t).</formula><p>Hence, the sets of optimal arc blocks for MASPNLAI remain unchanged, too. Karp <ref type="bibr" target="#b25">[26]</ref> showed that such a potential transformation can be found in O(|A||V |) time.</p><p>We proceed with a negative observation. It is well known that the standard shortest path problem is in NC, that is it can be efficiently solved in parallel. In contrast, problem MASPNLAI is P-complete already for blocking systems of type B 2 and acyclic digraphs G = (V , A) of out-degree 2. This is because determining whether the blocking distance between a pair of vertices s, t is finite: d(s, t) &lt; +∞ includes, as a special case, the well-known monotone circuit value problem <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Total Limited Short Paths Interdiction and Similar Problems</head><p>Given a digraph G = (V , A), terminals s, t ∈ V , a non-negative weight function w : A → R + , and two thresholds k ∈ Z + and d ∈ R + , is it possible to remove k arcs from A so that d(s, t) ≥ d in the remaining digraph? For any constant k this clearly can be accomplished in polynomial time (see e.g., Corley and Shaw <ref type="bibr" target="#b7">[8]</ref>), however, in general the problem is NP-hard, as it was shown by Bar-Noy, Khuller, and Schieber in <ref type="bibr" target="#b2">[3]</ref>. In this paper we strengthen this result by deriving inapproximability bounds. For a given k let us denote by A (G, s, t, k) the maximum of d(s, t) over all digraphs obtainable from G by deleting (at most) k arcs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 It is NP-hard to approximate</head><p>A within a factor smaller than 2, even for bipartite graphs. The inapproximability bound 10 √ 5 -21 ≈ 1.36 was recently obtained by Dinur and Safra <ref type="bibr" target="#b8">[9]</ref> for the Minimum Vertex Cover Problem in graphs improving the previous bound 7/6 ≈ 1.17 given by Håstad <ref type="bibr" target="#b20">[21]</ref>. In our proof we reduce the problem from the Minimum Vertex Cover Problem.</p><p>We prove also that the same bounds 2 and 10 √ 5 -21 ≈ 1.36 hold for undirected graphs and/or vertex interdiction.</p><p>Clearly, the functions A and b A establish an inverse connection between the distance d(s, t) and the number of deleted arcs k: the more arcs we delete, the higher the distance between s and t. In some situations we might be interested to know the tradeoff between the number of deleted arcs and the distance achieved. We can however show that even this tradeoff cannot be approximated arbitrarily well, unless P = NP.</p><p>Let us say that it is NP-hard to distinguish two disjoint subsets of (di)graphs, A and B, if no polynomial time algorithm can accept all graphs G ∈ A and reject all graphs G ∈ B, unless P = NP. Theorem 4 For every fixed &gt; 0 it is NP-hard to distinguish graphs having d(s, t) ≥ d after the removal of some k arcs from those having d(s, t) ≤ 1 2-d in all subgraphs obtained by removing ( 34  33 -)k arcs, where d and k are part of the input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">Multiple Cuts</head><p>Let us next recall that similar sounding problems about multiple cuts can be solved in polynomial time.</p><p>Given a directed graph G(V , A), two terminals s, t ∈ V , a subset A ⊆ A of the arcs is called an -cut, if any s-t directed path contains at least arcs from A . Then, the following problem can be solved in polynomial time:</p><formula xml:id="formula_5">M Given a digraph G = (V , A) with two distinguished vertices s, t ∈ V and positive</formula><p>integers k and , determine whether there exists an -cut A ⊆ A consisting of (at most) k arcs.</p><p>Suppose without loss of generality that t is reachable from s in G, and let A be an arbitrary -cut, that is, |A ∩ P | ≥ for any s-t path P ⊆ A. Then, denoting by V i the set of vertices that can be reached from s by using at most i arcs from A , we conclude that A contains disjoint s-t cuts</p><formula xml:id="formula_6">C i = cut(V i-1 , (V i \ V i-1 )) for i = 1, . . . , , where cut(V i-1 , (V i \ V i-1 )) denotes the set of arcs of A connecting a vertex of V i-1 to a vertex of V i \ V i-1 .</formula><p>Conversely, the union of any arc-disjoint s-t cuts is an -cut separating t from s. Hence problem M can be equivalently stated as follows:</p><formula xml:id="formula_7">M Given a digraph G = (V , A), two distinguished vertices s, t ∈ V ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and positive</head><p>integers k and , determine whether there exist arc-disjoint</p><formula xml:id="formula_8">s-t-cuts C 1 , . . . , C such that |C 1 | + • • • + |C | ≤ k.</formula><p>The latter problem is polynomial. Moreover, Wagner <ref type="bibr" target="#b36">[37]</ref> showed that its weighted optimization version can be solved in strongly polynomial time.</p><p>M w Given a digraph G = (V , A) with two distinguished vertices s, t ∈ V , a weight function w : A → R + , and a positive integer , find arc-disjoint s, t-cuts C 1 , . . . , C of minimum total weight w(C 1 ) + • • • + w(C ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.7">Network Interdiction and Its Applications</head><p>Problem MASPNLAI is a special (polynomially solvable) case of the so-called network interdiction problem. Interdiction (or inhibition) is an attack on arcs to destroy them, or increase their effective lengths, or decrease their capacities. The goal of the interdiction is to utilize a given budget most efficiently, that is to maximize the shortest path or minimize the maximum flow between two given terminals. These problems were originally motivated by military applications, McMasters and Mustin <ref type="bibr" target="#b28">[29]</ref>, Ghare, Montgomery, and Turner <ref type="bibr" target="#b15">[16]</ref>. Later analogous models of pollution and drug interdiction were developed by Wood and Washburn <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b38">39]</ref>. The problem of minimizing the maximum flow was considered by Phillips <ref type="bibr" target="#b31">[32]</ref>, while the maximization of the shortest path was first studied by Fulkerson and Harding <ref type="bibr" target="#b12">[13]</ref> and also by Golden <ref type="bibr" target="#b16">[17]</ref> (see Israeli and Wood <ref type="bibr" target="#b21">[22]</ref> for a short survey). An important special case of the latter problem is the so-called k-most-vital-arcs problem <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b27">28]</ref> in which it is allowed to destroy exactly k arcs. All the above mentioned problems are known to be NP-hard, in general. Problem MASPNLAI is the short paths interdiction problem under the assumption that the budget is node-wise limited. This problem is polynomially solvable.</p><p>To illustrate possible applications of this polynomially solvable case, suppose that for each arc e = (u, v) we are given a probability p(e) that some undesirable transition (for example, contraband smuggling) from u to v can be carried out undetected. Then, assuming independence and letting w(e) =log p(e) ≥ 0, we can interpret problem MASPNLAI as the uniform maximization of interception capabilities for a given target t under limited inspection resources distributed over the nodes of G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Proof of Theorem 1</head><p>We first describe an extension of Dijkstra's algorithm for problem MASPNLAI that uses blocking queues and may temporarily block and then de-block some arcs. This extension, presented in Sect. 2.2, is used to show part (i) of Theorem 1. Then in Sect. 2.4 we present another implementation of the extended algorithm to prove part (ii) of the theorem. Part (iii) is shown in Sect. 2.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Blocking Queues</head><p>Let B be a blocking (i.e. independence) system on a finite set A, for example on the set A(v) of arcs leaving a given vertex v of G. Given a mapping p : A → R, and a set Y ⊆ A, let</p><formula xml:id="formula_9">p B (Y ) = max X∈B min e∈Y \X p(e),<label>(1)</label></formula><p>where, as usual, it is assumed that the minimum over the empty set is +∞. For instance, if Y = {e 1 , e 2 , e 3 , e 4 } and (p(e 1 ), p(e 2 ), p(e 3 ), p(e 4 )) = (1, 3, 3, 5), then</p><formula xml:id="formula_10">p B (Y ) = ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ 1, if {e 1 } / ∈ B; 3, if {e 1 } ∈ B but {e 1 , e 2 , e 3 } / ∈ B; 5, if {e 1 , e 2 , e 3 } ∈ B but Y / ∈ B; +∞, if Y ∈ B.</formula><p>Considering the image {p(e), e ∈ Y } as a set of keys, we define a B-queue as a data structure for maintaining a dynamic set of keys under the following operations:</p><p>1. Make_queue: Create an empty queue Y = ∅; 2. Insert: Expand Y by adding a new element e with a given key value p(e); 3. Return p B (Y ): Compute the right-hand side of (1) for the current key set. Note that when the independence system is trivial, B = {∅}, we obtain the customary definition of a minimum priority queue (modulo the operation delete-min which is not needed in our application).</p><p>When B is a blocking system of type</p><formula xml:id="formula_11">B 1 , that is, X ∈ B whenever |X| ≤ k for some given integer k ≤ |A|, then p B (Y ) = +∞, if |Y | ≤ k; (k + 1) st smallest key of Y, if |Y | ≥ k + 1.</formula><p>Hence, by maintaining a regular maximum priority queue of at most k + 1 elements of A,</p><p>• A sequence of d ≥ k queue operations for an initially empty B 1 -queue can be implemented to run in O(k</p><formula xml:id="formula_12">+ (d -k) log(k + 1)) time.</formula><p>For general blocking systems B, each B-queue operation can be performed in O(log |Y |) time and O(log |Y |) oracle queries. This can be done by using a balanced binary search tree on the set of keys in Y . Specifically, inserting a new key into Y takes O(log |Y |) time and no oracle queries, while computing the value of p B (Y ) can be done by searching for the largest key p in the tree for which the oracle can block the set of all keys smaller than p. Note that each query to the blocking oracle can be specified by a list of keys if we additionally maintain a sorted list of all keys in Y along with pointers from the search tree to the list.</p><p>We close this subsection by defining, for each set Y ⊆ A of keys, a (unique) inclusion-wise minimal blocking set X(Y ) ∈ B such that</p><formula xml:id="formula_13">p B (Y ) = min e∈Y \ X(Y )</formula><p>p(e).</p><p>We will refer to X(Y ) ⊆ Y as the lazy block for Y . For instance, if, as before, Y = {e 1 , e 2 , e 3 , e 4 } and (p(e 1 ), p(e 2 ), p(e 3 ), p(e 4 )) = (1, 3, 3, 5), then </p><formula xml:id="formula_14">X(Y ) = ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ ∅, if {e 1 } ∈ B; {e 1 }, if {e 1 } ∈ B, but {e 1 , e 2 , e 3 } ∈ B; {e 1 , e 2 , e 3 }, if {e 1 , e 2 , e 3 } ∈ B, but Y ∈ B; Y, if Y ∈ B.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Extended Dijkstra's Algorithm for MASPNLAI</head><p>Given a digraph G = (V , A), a non-negative weight function w(v) : A → R + , a vertex t ∈ V , and a blocking system B, we wish to find an admissible graph G o that maximizes the distance from each start vertex v ∈ V to t. In the statement of extended Dijkstra's algorithm below we assume without loss of generality that the outdegree of the terminal vertex t is 0, and the input arc-weights w(e) are all finite. By definition, we let (t, t) = 0. Similarly to the regular Dijkstra's algorithm, the extended version maintains, for each vertex v ∈ V , an upper bound ρ(v) on the blocking v-t distance:  To complete the proof of part (i) it remains to show that the extended algorithm is correct.</p><formula xml:id="formula_15">ρ(v) ≥ (v, t) def = max G admissible {distance from v to t in G }.</formula><formula xml:id="formula_16">(v) ⊆ Y 1 (v) ⊆ • • • ⊆ Y n (v), the values of ρ i (v) = p B (Y i (v)) are monotonically non-increasing: +∞ = ρ 0 (v) ≥ ρ 1 (v) ≥ • • • ≥ ρ n (v).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Correctness of Extended Dijkstra's Algorithm</head><p>Let us show that upon the termination of the extended Dijkstra's algorithm,</p><formula xml:id="formula_17">• ρ(v) = (v, t) def = max G admissible {distance from v to t in G } for all vertices v ∈ V , and • The digraph G o = (V , A \ v∈V \{t} X(Y (v)</formula><p>obtained by deleting the lazy blocking sets of arcs X(Y (v)) is an optimal admissible digraph for all vertices:</p><formula xml:id="formula_18">(v, t) ≡ v-t distance in G o .</formula><p>Let S i and T i = V \ S i be the vertex partition maintained by the algorithm for i = 0, 1, . . . , n ≤ |V | -1. We have</p><formula xml:id="formula_19">S 0 = V ⊃ S 1 = V \ {t} ⊃ • • • ⊃ S n-1 ⊇ S n</formula><p>, where S n-1 = S n if and only if the algorithm terminates due to the stopping criterion in line 6. For the given arc weights w(e), e ∈ A, consider the following weight functions w i : A → R + ∪ {+∞}:</p><formula xml:id="formula_20">w i (e) =</formula><p>+∞, if both endpoints of e are in S i , w(e), otherwise.</p><p>(</p><p>Clearly, we have</p><formula xml:id="formula_22">w 0 (e) = +∞ ≥ w 1 (e) ≥ • • • ≥ w n (e) ≥ w(e). Let i (v, t) def = max G admissible {w i -distance from vto t in G }, then 0 (v, t) = +∞ ≥ 1 (v, t) ≥ • • • ≥ n (v, t) ≥ (v, t) for all v ∈ V \ {t}.</formula><p>The correctness of the algorithm will follow from the following two invariants: for all i = 0, 1, . . . , n,</p><formula xml:id="formula_23">I S i : ρ i (v) = i (v, t) for all vertices v ∈ S i ; I T i : If v ∈ T i = V \S i , then ρ i (v) = (v, t) and the admissible digraph G o i = (V , A\ v∈V \{t} X(Y i (v))) is an optimal blocking digraph for v. Moreover, min{ρ i (v), v ∈ S i } ≥ max{ (v, t), v ∈ T i } and for each vertex v ∈ T i there exists a shortest v-t path in G o</formula><p>i which lies entirely in T i . Note that by I T i , the algorithm removes vertices from S and determines their blocking distances in non-decreasing order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of invariants I S</head><p>i and I T i is similar to that for the regular Dijkstra's algorithm. Since T 0 = ∅, invariant I T 0 holds trivially. I S 0 follows from the initialization steps of the algorithm: for S 0 = V we have w 0 (e) ≡ +∞, and hence ρ 0 (t) = 0 (t, t) = 0 and ρ 0 (v) = 0 (v, t) = +∞ for all vertices v ∈ V \ {t}.</p><p>In order to prove by induction that I S i+1 and I T i+1 follow from I S i and I T i , let us first suppose that the ith iteration loop breaks due to the stopping criterion in line 6: min{ρ i (v), v ∈ S i } = +∞. Then i = n -1 and S n-1 = S n , which means that n (v, t) ≡ n-1 (v, t) and ρ n (v) ≡ ρ n-1 (v). Consequently, the statements of I S n and I T n become identical to I S n-1 and I T n-1 , and we have nothing to prove. Moreover, as all vertices of S n are disconnected from t in G o = G o n , invariant I T n also shows that the algorithm correctly computes the blocking distances and the optimal blocking digraph G o for all vertices.</p><p>We may assume henceforth that n = |V | -1 and |S n | = 1. Consider the vertex u that moves from S i to T i+1 at iteration i:</p><formula xml:id="formula_24">ρ i (u) = min{ρ i (v), v ∈ S i } &lt; +∞.<label>(3)</label></formula><p>To show that ρ i (u) = (u, t), observe that by I S i , ρ i (u) = i (u, t) ≥ (u, t). In other words, ρ i (u) is an upper bound on the w-cost of reaching t from u, regardless of any admissible blocks selected by the adversary. So we will have ρ i (u) = (u, t) if we can find an admissible digraph G such that</p><formula xml:id="formula_25">ρ i (u) = w-distance from u to t in G . (<label>4</label></formula><formula xml:id="formula_26">)</formula><p>Let G = G o i be the admissible digraph defined in I T i . Then (4) follows from I T i , the non-negativity of the input arc-weights, and the fact that ρ i (u) = p(e * ) = w(e * ) + ρ i <ref type="bibr">(v)</ref>, where e * = (u, v) ∈ A is the arc with the smallest key value in the (S i , T i )-cut of G .</p><p>After u gets into T i+1 , the value of ρ(u) never changes. Hence ρ i+1 (u) = (u, t), as stated in I T i+1 . Note that (3) and invariant I T i also tell us that min{ρ i (v), v ∈ S i } = (u, t) ≥ max{ (v, t), v ∈ T i }. Let us now show that after the algorithm updates ρ(v) on S i+1 , we still have</p><formula xml:id="formula_27">min{ρ i+1 (v), v ∈ S i+1 } ≥ (u, t) = max{ (v, t), v ∈ T i+1 },<label>(5)</label></formula><p>again as stated in I T i+1 . Suppose to the contrary, that ρ i+1 (v) &lt; (u, t) = ρ i (u) for some vertex v ∈ S i+1 . Then from (3) it would follow that e = (v, u) is an arc of G = (V , A) and consequently Y i+1 (v) = Y i (v) ∪ {e}. Moreover, we must have e ∈ X(Y i+1 (v)), for otherwise the value of ρ i+1 (v) = p B (Y i+1 (v)) could not have dropped below the minimum of ρ i (v) and p(e) = w(v, u) + (u, t), which is at least</p><formula xml:id="formula_28">(u, t). But if e ∈ X(Y i+1 (v)) then again p B (Y i+1 (v)) ≥ p(e), contradiction.</formula><p>To complete the proof of I T i+1 , it remains to show that G o i+1 is an optimal admissible digraph for each vertex v ∈ T i+1 , and that some shortest v-t path in G o i+1 lies in T i+1 . This readily follows from ( <ref type="formula" target="#formula_27">5</ref>) and the fact that the sub-graphs of G o i and G o i+1 induced by T i+1 are identical. Finally, I S i+1 follows from the updates ρ i+1 (v) ← p B (Y i+1 (v)) performed by the algorithm in lines 8-11.</p><p>Since we could assume in the above proof that n = |V | -1 and |S n | = 1, the correctness of the algorithm readily follows from I S n and I T n . When S n is a singleton s ∈ V , then w n (e) ≡ w(e), see <ref type="bibr" target="#b1">(2)</ref>. Hence n (v, t) ≡ (v, t), and I S n yields ρ n (s) = n (s, t) = (s, t). By I T n , we also have ρ n (v) = (v, t) for the remaining vertices v ∈ T n = V \ {s}. Invariant I T n also guarantees that G o = G o n is an optimal admissible digraph for all vertices v ∈ V .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Modified Dijkstra's Algorithm</head><p>In this section we prove part (ii) of Theorem 1 by modifying the algorithm stated in Sect. 2.2.</p><p>The modified algorithm keeps all arcs across the current (S, T )-cut in a minimum priority queue A, implemented as a binary heap. As in the previous algorithm, each arc e = (v, v ) across the cut is assigned the key value p(e) = w(e) + ρ(v ), where ρ(v ) = (v , t) for all vertices v ∈ T . In addition to the arcs in the current cut, A may also contain some arcs e = (v, v ) for which both endpoints v, v are in T . In order to compute the vertex u to be moved from S to T , we repeatedly extract the minimum-key arc e from A, and check whether e = (v, v ) belongs to the current cut and can be blocked along with the arcs that have already been blocked at v. The first arc e = (v, v ) in the cut that cannot be blocked defines the vertex u = v. We then move u to T , insert all arcs e = (v, u) ∈ A for which v ∈ S into A, and iterate.</p><p>The outputs of the modified algorithm and the extended Dijkstra's algorithm presented in Sect. 2.2 are identical. It is also easy to see that the running time and the number of membership tests required by the modified algorithm satisfy the bounds stated in part (ii) of Theorem 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Unit Arc-Weights</head><p>When w(e) = 1 for all e ∈ A, and the blocking systems B(v) are all empty, the singledestination shortest path problem can be solved in linear time by breadth-first search. The extended Dijkstra's algorithm for problem MASPNLAI can be similarly simplified to prove part (iii) of Theorem 1.</p><p>The above algorithm runs in at most |A| iterations. It follows by induction on (v, t) that it correctly computes the blocking distances and that the admissible digraph G o = (V , A \ v∈V \{t} X(v)) is optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Inapproximability Bounds</head><p>In the rest of the paper we prove the inapproximability results for total limited short paths interdiction stated in the introduction, and a few analogous claims for vertex interdiction and/or undirected graphs. Let us first give precise formulations for these results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problems and Results</head><p>We consider a graph (or digraph) G = (V , E) with a nonnegative length associated with every edge (or arc), two distinct vertices s and t, and a threshold d ∈ Z + , and denote this input by (G, s, t, d).</p><p>A vertex blocker of (G, s, t, d) is a set of vertices different from s and t whose removal increases the s-t distance to at least d. We define the Minimum Vertex Blocker to Short Paths Problem (MVBP) as follows:</p><p>Theorem 5 It is NP-hard to approximate the size of the smallest vertex blocker within a factor smaller than 10 √ 5 -21 ≈ 1.36, even for bipartite graphs.</p><p>An edge blocker of (G, s, t, d) is a set of edges (arcs) whose removal increases the s-t distance to at least d. We define the Minimum Edge Blocker to Short Paths Problem (MEBP) as follows:</p><p>The next statement is similar to Theorem 5 above and it is a reformulation of Theorem 3 stated in the introduction: Theorem 6 It is NP-hard to approximate the size of the smallest edge blocker within a factor smaller than 10 √ 5 -21 ≈ 1.36, even for bipartite graphs.</p><p>The Most Vital Vertices Problem (MVVP) is defined as follows:</p><p>Theorem 7 It is NP-hard to approximate V within a factor smaller than 2, even for bipartite graphs.</p><p>The Most Vital Edges Problem (MVEP) is defined as follows:</p><p>Then, Theorem 2 can be reformulated as follows:</p><p>Theorem 8 It is NP-hard to approximate E within a factor smaller than 2, even for bipartite graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Restricted Problems</head><p>In this section we define restricted versions of the above problems by introducing the assumption that some vertices (edges) cannot be removed. We call these vertices (edges) fixed. The remaining vertices (edges) are called removable.</p><p>We obtain restricted-MVBP and restricted-MVVP from MVBP and MVVP, respectively, by fixing some vertices (in addition to s and t). Similarly we obtain restricted-MEBP and restricted-MVEP from MEBP and MVEP, respectively, by fixing some edges.</p><p>For a graph G, two vertices s, t, a set of fixed vertices V (or a set of fixed edges E ) and thresholds d and k, let b V ( <ref type="figure">G, s, t, V , d), b E (G, s, t, E , d), V (G, s, t, V , k)</ref> and<ref type="figure">E (G, s, t, E , k</ref>) denote the solutions to restricted-MVBP, restricted-MEBP, restricted-MVVP and restricted-MVEP, respectively.  <ref type="figure">(G,</ref><ref type="figure">s,</ref><ref type="figure">t,</ref><ref type="figure">V ,</ref><ref type="figure">d</ref>) of restricted-MVBP we assume that all removable vertices form a vertex blocker. Similarly given an instance (G, s, t, E , k) of restricted-MEBP we assume that all removable edges form an edge blocker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Inapproximability of Minimum Vertex Cover</head><p>In this section we recall previously known results on which the proofs of our results are based. A vertex cover of an undirected graph G is a subset of vertices incident to every edge. Let τ (G) denote the size of the smallest vertex cover of G.</p><p>Deciding if G has a vertex cover of size at most k is NP-hard <ref type="bibr" target="#b14">[15]</ref>, even for tripartite graphs <ref type="bibr" target="#b33">[34]</ref>. However, τ (G) can be easily approximated within a factor 2, since the vertex cover consisting of both vertices of edges belonging to a maximal matching has size at most 2τ (G). Improving this simple 2-approximation algorithm has been a major open problem. The best known approximation algorithm has a factor of 2 -</p><formula xml:id="formula_29">( 1 √ log n ),</formula><p>where n is the number of vertices <ref type="bibr" target="#b23">[24]</ref>. On the other hand, in 1997 Håstad <ref type="bibr" target="#b20">[21]</ref> proved that it is NP-hard to approximate τ (G) within a factor smaller than 7  6 ≈ 1.17. Recently Dinur and Safra <ref type="bibr" target="#b8">[9]</ref> obtained the better inapproximability factor of 10 √ 5 -21 ≈ 1.36. For tripartite graphs it is NP-hard to approximate τ (G) within a factor smaller than 34  33 ≈ 1.03 <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Proof of Theorem 5</head><p>In this section we prove Theorem 5 by reducing the minimum vertex cover problem to restricted-MVBP. As will be shown in Sects. 7 and 7.1, for each instance of restricted-MVBP, we can construct an instance of MVBP with the same optimal value and a bipartite input graph. Therefore Theorem 9 below implies Theorem 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 9</head><p>It is NP-hard to approximate b V within a factor smaller than 10 √ 5 -21 ≈ 1.36.</p><p>Proof Let G be an undirected graph with vertices v 1 , . . . , v n (see Fig. <ref type="figure" target="#fig_4">1</ref>). We construct an instance of restricted-MVBP. We obtain an undirected graph H from G by adding to it a path su 1 u 2 . . . u n t and connecting v i to u i for i = 1, . . . , n (see Fig. <ref type="figure">2</ref>). Let W denote the vertex set of H . We assign length 1 to edges {u 1 , u 2 }, {u 2 , u 3 }, . . . , {u n-1 , u n } and 0 to all other edges. Let V = {u 1 , . . . , u n } be the set of Recall that τ (G) denotes the size of the smallest vertex cover of G.</p><formula xml:id="formula_30">Claim 1 τ (G) = b V (H, s, t, V , n -1).</formula><p>Proof Let U ⊆ {v 1 , . . . , v n } be a set of removable vertices. We show that U is a vertex cover of G if and only if U is a vertex blocker of (H, s, t, n -1). Suppose U is a vertex cover of G. Since V U is an independent set of G, there is only one s-t path, su 1 u 2 . . . u n t, in H [W U ] and the length of this path is -1 (see Fig. <ref type="figure" target="#fig_0">3</ref>).</p><p>Conversely, suppose U is a vertex blocker of (H, s, t, n -1). Note that for every i &lt; j there is no edge between vertices v i and v j in H [W U ], since otherwise there would exist a path su 1 . . . u i v i v j u j . . . u n t in H [W U ] shorter than n -1. Thus U is a vertex cover of G. Since it is NP-hard to approximate the minimum vertex cover within a factor smaller than 10 √ 5 -21 ≈ 1.36 <ref type="bibr" target="#b8">[9]</ref>, Theorem 9 follows. We can similarly reduce the minimum vertex cover problem to restricted-MVBP for directed graphs. Let H be a digraph obtained from G by replacing every edge {v i , v j }, i &lt; j, of G by an arc (v i , v j ), adding to it a dipath su 1 u 2 . . . u n t and connecting v i to u i with two arcs (v i , u i ) and (u i , v i ) for i = 1, . . . , n (see Fig. <ref type="figure" target="#fig_6">4</ref>).</p><p>As before we assign length 1 to arcs (u 1 , u 2 ), (u 2 , u 3 ), . . . , (u n-1 , u n ) and 0 to all other arcs, vertices u 1 , . . . , u n are fixed and the threshold is n -1. The proof that τ (G) = b V (H, s, t, V , n -1) is analogous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Proof of Theorem 6</head><p>In this section we prove Theorem 6 similarly to the proof of Theorem 5. We reduce the minimum vertex cover problem to restricted-MEBP. As will be shown in Sects. 7 and 7.2, for each instance of restricted-MEBP we can construct an instance of MEBP with the same optimal value and a bipartite input graph. Therefore Theorem 10 below implies Theorem 6.</p><p>In the proof of Theorem 10, we use a gadget similar to the one used in <ref type="bibr" target="#b2">[3]</ref> to prove NP-hardness of the Most Vital Edges Problem. Proof Let G be an undirected graph with vertices v 1 , . . . , v n (see Fig. <ref type="figure" target="#fig_4">1</ref>). We construct an instance of restricted-MEBP. We obtain an undirected graph H from G by • Replacing every vertex v i of G by two vertices v i and v i connected by an edge {v i , v i } of length 1 for i = 1, . . . , n, • Replacing every edge {v i , v j }, i &lt; j, of G by {v i , v j } of length 5(ji) -2,</p><p>• Adding to it a path P = su 1 u 1 u 2 u 2 . . . u n u n t, where {u i , u i } has length 5 for i = 1, . . . , n and other edges have length 0, • Adding two edges {v i , u i } and {v i , u i } of length 2 for i = 1, . . . , n (see Fig. <ref type="figure" target="#fig_8">5</ref>).</p><p>All edges except {v 1 , v 1 }, . . . , {v n , v n } are fixed. We denote the set of fixed edges by E . The threshold is 5n. Note that the set of all removable edges forms an edge blocker. Let W and E denote the vertex and edge sets of H , respectively. Let x ∈ {u i , u i }, y ∈ {u j , u j }, where i = j . We call the subpath of P from x to y an x-y line. An x-y detour is an x-y path D in H , where no vertices of D, apart from the first and the last, belong to P . An i-j shortcut is the path v i v i v j v j (see Fig. <ref type="figure" target="#fig_9">6</ref>).</p><p>Let length(Q) denote the length of a path Q.</p><p>Claim 2 If x-y detour D contains no shortcuts then length(D) ≥ length(x-y line).</p><p>Proof For integers i, j, r ≥ 1, with i &lt; j, let us denote by Q r (v i , v j ) a path v i 0 , v j 1 , v i 1 , v j 2 , v i 2 , v j 3 , . . . , v i r-1 , v j r in H , where i 0 = i, j r = j , i &lt; j 1 , and i k &lt; min{j k , j k+1 } for k = 1, . . . , r -1. Note that Q r (i, j ) does not contain a shortcut, and</p><formula xml:id="formula_31">length(Q r (v i , v j )) = 10 r-1 l=1 (j l -i l ) + 5(j -i) -4r + 2 ≥ 5(j -i) + 6r -8. (<label>6</label></formula><formula xml:id="formula_32">)</formula><p>Let us next consider a path in H , consisting of the concatenation of k ≥ 0 of such paths</p><formula xml:id="formula_33">P k (v j 0 , v j k ) = Q r 1 (v j 0 , v j 1 )Q r 2 (v j 1 , v j 2 ) • • • Q r k (v j k-1 , v j k )</formula><p>, and note by <ref type="bibr" target="#b5">(6)</ref> and telescoping that</p><formula xml:id="formula_34">length(P k (v j 0 , v j k )) ≥ 5(j k -j 0 ) + 6 k i=1 r i -7k -1. (<label>7</label></formula><formula xml:id="formula_35">)</formula><p>Note that for k = 1 and r 1 = 1, P k (v j 0 , v j k ) is just the edge {v j 0 , v j k } and hence <ref type="bibr" target="#b6">(7)</ref> is tight in this case. Furthermore, assuming that P k (v j 0 , v j k ) does not contain a shortcut, we must have r i ≥ 2 for i = 2, . . . , k -1. In particular, and for k ≥ 3, we have length(P k (v j 0 , v j k )) ≥ 5(j kj 0 ) + 2. Similarly, for k = 2 and r 1 + r 2 ≥ 3, we have length(P k (v j 0 , v j k )) ≥ 5(j kj 0 ) + 3 by ( <ref type="formula" target="#formula_36">8</ref>), while for k = 1 and r 1 ≥ 2, we have length(P k (v j 0 , v j k )) ≥ 5(j kj 0 ) + 4 by <ref type="bibr" target="#b6">(7)</ref>. Thus, except for the cases k = 2, r 1 = r 2 = 1 and k = 1, r 1 = 1, we have length(P k (v j 0 , v j k )) ≥ 5(j kj 0 ) + 2, and generally we have length(P k (v j 0 , v j k )) ≥ 5(j kj 0 ) -3 for k ≥ 1.</p><formula xml:id="formula_36">length(P k (v j 0 , v j k )) ≥ 5(j k -j 0 ) + 6(r 1 + r k ) + 5k -25,<label>(8)</label></formula><p>There are six possible kinds of x-y detours containing no shortcuts: Case 1: u i v i P k (v i , v j )v j u j , for i ≤ j and k ≥ 0. Then length(x-y line) = 5(ji) + 5. If k = 0, then i = j and length(detour(x, y)) = 5. If k = r 1 = 1 or k = 2 and r 1 = r 2 = 1, we have a shortcut. Otherwise, length(detour(x, y)) = 6 + length(P k (v i , v j )) ≥ 5(ji) + 8.</p><p>Case 2: u i v i P k (v i , v j )u j , for i &lt; j and k ≥ 1. Then length(x-y line) = 5(ji) and length(detour(x, y)) = 5 + length(P k (v i , v j )) ≥ 5(ji) + 2.</p><p>Case 3: u i P k (v i , v j )u j , for i &lt; j and k ≥ 1. Then length(x-y line) = 5(ji -1) and length(detour(x, y)) = 4 + length(P k (v i , v j )) ≥ 5(ji) + 1.</p><p>Case 4: u i P k (v i , v j )v j u j , for i &lt; j. Then length(x-y line) = 5(ji) and length(detour(x, y)) = 5 + length(P k (v i , v j )) ≥ 5(ji) + 2.</p><p>Case 5:</p><formula xml:id="formula_37">u i v i P k (v i , v j )v k v k u k , for i &lt; k &lt; j and k ≥ 1. Then length(x-y line) = 5(k -i) and length(detour(x, y)) = 6 + length(P k (v i , v j )) + 5(j -k) -2 ≥ 1 + 5(2j -i -k) &gt; 5(k -i).</formula><p>Case 6:</p><formula xml:id="formula_38">u i P k (v i , v j )v k v k u k , for i &lt; k &lt; j and k ≥ 1. Then length(x-y line) = 5(k -i -1) and length(detour(x, y)) = 5 + length(P k (v i , v j )) + 5(j -k) -2 ≥ 5(2j -i -k) &gt; 5(k -i -1).</formula><p>Thus all six kinds of x-y detours are at least as long as the corresponding x-y line.</p><p>Claim 3 Let Q be an s-t path in H . If for every detour D contained in Q length(D) ≥ length(x-y line), where x and y are ends of D, then the length of Q is at least 5n. Proof Note that Q starts with the edge {s, u 1 } and ends with the edge {u n , t}. Thus we can decompose Q into an alternating sequence of lines and detours the s-1 line, an 1 -r 1 detour D 1 , the r 1 -2 line, an 2 -r 2 detour D 2 , . . . , an m -r m detour D m , the r m -t line (see Fig. <ref type="figure" target="#fig_9">6</ref>). Since no x-y detour is shorter than the x-y line, we have length(Q) ≥ length(P ) = 5n.</p><p>Recall that τ (G) denotes the size of the smallest vertex cover of G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim 4 τ (G) = b E (H, s, t, E , 5n).</head><p>Proof Let F be a subset of removable edges. We show that {v i | {v i , v i } ∈ F } is a vertex cover of G if and only if F is an edge blocker of (H, s, t, E , 5n).</p><p>Suppose</p><formula xml:id="formula_39">{v i | {v i , v i } ∈ F } is a vertex cover of G.</formula><p>Thus there is no shortcut in the graph (W, E F ). By Claim 2 all x-y detours are longer than x-y lines, which by Claim 3 implies that every s-t path has length at least 5n.</p><p>Conversely, suppose F is an edge blocker of (H, s, t, E , 5n) and suppose that {v i , v i }, {v j , v j } / ∈ F , for some edge v i v j of G. Then F does not block the path consisting of the s-u i line, the u i -u j detour u i v i v i v j v j u j and the u j -t line which has a total length 5n -1, a contradiction.</p><p>Since it is NP-hard to approximate the minimum vertex cover within a factor smaller than 10 √ 5 -21 ≈ 1.36 <ref type="bibr" target="#b8">[9]</ref>, Theorem 10 follows. Note that we can similarly reduce the Minimum Vertex Cover Problem to restricted-MEBP for directed graphs. Let H be a digraph obtained from G by • Replacing every vertex v i of G by two vertices v i and v i connected by an arc (v i , v i ) of length 0 for i = 1, . . . , n, • Replacing every edge {v i , v j }, i &lt; j, of G by (v i , v j ) of length 0, • Adding to it a dipath su 1 u 2 . . . u n t, where arcs (u 1 , u 2 ), (u 2 , u 3 ), . . . , (u n-1 , u n )</p><p>have length 1 and all other arcs have length 0, • Adding two arcs (u i , v i ) and (v i , u i ) of length 0 for i = 1, . . . , n (see Fig. <ref type="figure" target="#fig_10">7</ref>).</p><p>As before, all arcs except (v 1 , v 1 ), . . . , (v n , v n ) are fixed, we denote the set of fixed arcs by E and the threshold is n -1.</p><p>Analogously to proof of Claim 1 we can show that τ (G) = b E (H, s, t, E , n -1), implying the theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Proof of Theorem 7</head><p>In this section we prove Theorem 7 by reducing the problem of deciding whether a tripartite graph has a vertex cover of size at most k, which is known to be NPhard <ref type="bibr" target="#b33">[34]</ref>, to restricted-MVVP. As shown in Sects. 7 and 7.3, for each instance of restricted-MVVP we can construct an instance of MVVP with the same optimal value and a bipartite input graph. Therefore Theorem 11 below implies Theorem 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 11</head><p>It is NP-hard to approximate l V within a factor smaller than 2.</p><p>Proof We will show that a (2 -)-approximation algorithm, where &gt; 0, can decide whether a tripartite graph has a vertex cover of size k in polynomial time.</p><p>Let G be a tripartite graph with vertex set</p><formula xml:id="formula_40">V = V 1 ∪ V 2 ∪ V 3 ,</formula><p>where V 1 , V 2 and V 3 are independent sets (see Fig. <ref type="figure" target="#fig_11">8</ref>). We construct an instance of restricted-MVVP. We obtain an undirected graph H from G by adding to it a path su 1 u 2 u 3 t and connecting every v ∈ V i to u i , for i = 1, 2, 3 (see Fig. <ref type="figure" target="#fig_12">9</ref>). Let W denote the vertex set of H . We assign length 1 to edges {u 1 , u 2 }, {u 2 , u 3 } and 0 to all other edges. Vertices u 1 , u 2 , u 3 are fixed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim 5 (i) If G has a vertex cover of size at most k then</head><formula xml:id="formula_41">V (H, s, t, V , k) = 2.</formula><p>(ii) If G does not have a vertex cover of size at most k then V (H, s, t, V , k) ≤ 1.  </p><formula xml:id="formula_42">Proof (i) Let U be a vertex cover of G such that |U | ≤ k. Since V U is an inde- pendent set in G,</formula><formula xml:id="formula_43">1: x ∈ V 1 , y ∈ V 2 . Then su 1 xyu 2 u 3 t is an s-t path of length 1. Case 2: x ∈ V 1 , y ∈ V 3 . Then su 1 xyu 3 t is an s-t path of length 0. Case 3: x ∈ V 2 , y ∈ V 3 .</formula><p>Then su 1 u 2 xyu 3 t is an s-t path of length 1. Thus the s-t distance in H [W U ] is 0 or 1 for every k-element set U of removable vertices.</p><p>Since a (2 -)-approximation algorithm, when run on H , must produce a solution less than or equal to 1 when V (H, s, t, V , k) ∈ {0, 1} and a solution strictly greater than 1 (and hence is exactly 2) when l V (H, s, t, V , k) = 2, such an algorithm could distinguish graphs that have a vertex cover of size k from graphs that do not.</p><p>We can similarly reduce the Most Vital Vertices Problem to restricted-MVVP for directed graphs. We obtain a directed graph H from G by replacing every edge {v, w}, where v ∈ V i , w ∈ V j , i &lt; j, of G by an arc (v, w), adding to it a dipath su 1 u 2 u 3 t and two arcs (v, u i ) and (u i , v) for every v ∈ V i , for i = 1, 2, 3 (see Fig. <ref type="figure" target="#fig_7">10</ref>). We assign length 1 to arcs (u 1 , u 2 ), (u 2 , u 3 ) and 0 to all other arcs. Vertices u 1 , u 2 , u 3 are fixed. The proof of Claim 5 is essentially the same as in the undirected case.  For an undirected graph we define the operation of splitting a vertex x into n copies as follows: we replace x by vertices x 1 , . . . , x n and each edge {x, y} of length l by edges {x 1 , y}, . . . , {x n , y} of length l (see Fig. <ref type="figure" target="#fig_14">11</ref>). We call vertices x 1 , . . . , x n split vertices of x.</p><p>Analogously, for a directed graph we define the operation of splitting a vertex x into n copies as follows: we replace x by vertices x 1 , . . . , x n , each arc (x, y) of For a graph (digraph) we define the operation of splitting an edge (arc) {x, y} into n copies as follows: we add vertices z 1 , . . . , z n , then replace the edge (arc) {x, y} of length l by edges (arcs) {x, z 1 }, . . . , {x, z n } of length l and edges (arcs) {z 1 , y}, . . . , {z n , y} of length 0 (see Fig. <ref type="figure" target="#fig_4">13</ref>). We call vertices z 1 , . . . , z n division vertices of {x, y}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Reduction from Restricted-MVBP to MVBP</head><p>For each instance of restricted-MVBP we construct in polynomial time an instance of MVBP with the same size of the minimum vertex blocker.</p><p>Let (G, s, t, V , d) be an instance of restricted-MVBP. Recall that we assume that all removable vertices form a vertex blocker. Let n be the number of vertices of G. We obtain a graph H from G by consecutively splitting every fixed vertex x ∈ V into n copies. Let W denote the vertex set of H . Observation 1 Let U be a subset of removable vertices. Then U is a vertex blocker of (H, s, t, d) if and only if U is a vertex blocker of (G, s, t, V , d).</p><p>Let (G, s, t, V , k) be an instance of restricted-MVEP. We construct an instance (H, s, t, k) as in Sect. 7.2. Similarly to Proposition 1 we can show that the maximum of s-t distances in all graphs obtained from G by removing k edges and the maximum of s-t distances in all graphs obtained from H by removing k edges are equal.</p><p>Proposition 4 E (G, s, t, E , k) = E (H, s, t, k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Reduction to Bipartite Graphs</head><p>In this section for each instance of an original problem we construct in polynomial time an instance with a bipartite input graph and the same optimal value.</p><p>Let G = (V , E) be a graph (digraph). We construct a graph (digraph) H by splitting every edge of G into 1 copy, where the operation of edge splitting was defined in Sect. 7. Let W be the set of newly added division vertices. Note that the graph H is bipartite, since every edge of H has one endpoint in V and the other in W . Analogously to Proposition 1, we can prove that b E (G, s, t, d) = b E (H, s, t, d) and E (G, s, t, k) = E (H, s, t, k).</p><p>We next obtain a graph (digraph) H from H by splitting every vertex of W into |V | copies, where the operation of vertex splitting was defined in Sect. 6. Note that H is still bipartite, and we can prove that b V (G, s, t, d) = b V (H , s, t, d) and V (G, s, t, k) = V (H , s, t, k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Decision Problems</head><p>Using the well known connection between optimization and decision problems (see Chap. 29 in <ref type="bibr" target="#b35">[36]</ref>) we can restate Theorems 5, 6, 7 and 8 as follows:</p><p>Proposition 5 (Reformulation of Theorems 5 and 6) It is NP-hard to distinguish instances of MVBP having a vertex (edge) blocker of size k to paths of length at most d from those having all vertex (edge) blockers of size greater than 1.36 k to paths of length at most d, where k is also a part of the input. Proposition 6 (Reformulation of Theorems 7 and 8) For every &gt; 0 it is NP-hard to distinguish instances of MVVP having s-t distance d after removing some k vertices (edges) from those having s-t distance less than 1  2-d in all induced subgraphs obtained by removing k vertices (edges), where k is also a part of the input.</p><p>Note that Theorem 4 is the strengthening of Proposition 6. Similarly it can be viewed as a two-sided generalization of Proposition 5, although the corresponding factor is worse.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Theorem 3</head><label>3</label><figDesc>Given a positive integer d, let us denote by b A (G, s, t, d) the smallest integer k such that d(s, t) ≥ d after k appropriate arcs are deleted from G. It is NP-hard to approximate b A within a factor smaller than 10 √ 5 -21 ≈ 1.36, even for bipartite graphs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>For</head><label></label><figDesc>an unsorted list of keys {p(e), e ∈ Y }, the lazy block X(Y ) can be computed in O(|Y |) time and O(log |Y |) oracle queries by recursively splitting the keys around the median. For blocking systems B 1 this computation takes O(|Y |) time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Initially, we let</head><label></label><figDesc>ρ(t) = 0 and ρ(v) = +∞ for all vertices v ∈ V \ {t}. As the regular Dijkstra's algorithm, the extended version runs in at most |V | -1 iterations and (implicitly) partitions V into two subsets S and T = V \ S such that ρ(v) = (v, t) for all v ∈ T . We iteratively grow the initial set T = ∅ by removing, at each iteration, the vertex u with the smallest value of ρ(v) from S and adding it to T . For this reason, the values of ρ(v), v ∈ S are stored in a minimum priority queue, e.g., in a Fibonacci heap. Once we remove the minimum-key vertex u from S (and thus implicitly declare that ρ(u) = (u, t)), we update ρ(v) for all those vertices v ∈ S that are connected to u by an arc in G. Recall that the regular version of Dijkstra's algorithm uses updates of the form ρ(v) ← min{ρ(v), w(v, u) + ρ(u)}. The updates performed by the extended version use blocking queues Y (v) maintained at all vertices v ∈ V \ {t}. Initially, all these B(v)-queues are empty, and when the value of ρ(v) needs to be updated for some vertex v ∈ S such that e = (v, u) ∈ A, we first insert arc e with the key value p(e) = w(v, u) + ρ(u) into Y (v), and thenlet ρ(v) ← p B (Y (v)) def = max X∈B(v) min e∈Y (v)\X p(e).In particular, for the standard shortest path problem, we obtain the regular updates.Finally, as the regular Dijkstra's algorithm, the extended version terminates as soon as ρ(u) = min{ρ(v), v ∈ S} = +∞ or |S| = 1.Bounds on Running Time for Blocks of TypeB 1 Line 12 and the initialization steps in lines 1-4 take linear time O(|V | + |A|). Let n ≤ |V | -1 be the number of iterations performed by the algorithm. Denote by Y i (v) (the set of key values in) the blocking queue at a fixed vertex v ∈ V \ {t} after the execution of iteration i = 1, . . . , n, and let Y 0 (v) = ∅ be the initial queue at v. As Y 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Since S is a (minimum) Fibonacci heap, the decrease-key operations in line 11 can be executed in constant amortized time per iteration, provided that the values of p B (Y i (v)) are known. Lines 6 and 7 take O(1) and O(log |V |) time per iteration, respectively. In view of the bounds on the B 1 -queue operations 10-11 stated in Sect. 2.1, the overall running time of the algorithm is thus within the bound stated in part (i) of Theorem 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1 Graph G</figDesc><graphic coords="17,166.59,52.93,220.44,76.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 2 Fig. 3</head><label>23</label><figDesc>Fig. 2 Graph H . Squares are fixed vertices</figDesc><graphic coords="18,60.53,52.92,317.28,136.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4</head><label>4</label><figDesc>Fig. 4 Digraph H . Squares are fixed vertices</figDesc><graphic coords="19,60.53,52.94,317.28,135.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Theorem 10</head><label>10</label><figDesc>It is NP-hard to approximate b E within a factor smaller than 10 √ 5 -21 ≈ 1.36.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 5</head><label>5</label><figDesc>Fig. 5 Graph H . Solid lines are fixed edges</figDesc><graphic coords="20,52.18,52.91,334.08,124.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6 Thick lines are edges of the s-t path consisting of the s-u 1 line, a u 1 -u 2 detour D 1 , the u 2 -u 3 line, a u 3 -u 4 detour D 2 and the u 4 -t line. Note that the detour D 1 contains the 1-2 shortcut</figDesc><graphic coords="21,51.75,52.93,334.92,124.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 7</head><label>7</label><figDesc>Fig. 7 Digraph H . Solid lines are fixed arcs</figDesc><graphic coords="22,60.53,52.94,317.28,174.18" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8</head><label>8</label><figDesc>Fig. 8 Tripartite graph G</figDesc><graphic coords="23,202.46,52.94,149.04,135.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 9</head><label>9</label><figDesc>Fig. 9 Graph H . Squares are fixed vertices</figDesc><graphic coords="24,62.50,52.93,313.44,220.62" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 10</head><label>10</label><figDesc>Fig. 10 Digraph H . Squares are fixed vertices</figDesc><graphic coords="25,62.55,52.93,313.32,220.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 11</head><label>11</label><figDesc>Fig. 11 Operation of splitting x into n copies</figDesc><graphic coords="25,60.12,310.53,318.12,139.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 12 Fig. 13</head><label>1213</label><figDesc>Fig. 12 Operation of splitting x into n copies in directed graphs</figDesc><graphic coords="26,61.31,52.93,315.72,138.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="14,52.18,52.93,334.08,232.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="14,52.18,426.83,334.08,178.02" type="bitmap" /></figure>
		</body>
		<back>

			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Preprints DTR-2005-04 and DTR-2006-13 are available at http://dimacs.rutgers.edu/TechnicalReports/2005.html and http://dimacs.rutgers.edu/TechnicalReports/2006/html. Our co-author Leonid Khachiyan passed away with tragic suddenness on April 29th, 2005.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research was supported in part by NSF grant IIS-0118635 and by DIMACS, the NSF Center for Discrete Mathematics &amp; Theoretical Computer Science.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim 6</head><p>Let U be a minimum vertex blocker of <ref type="bibr">(H, s, t, d)</ref>. If U contains a split vertex y of some fixed vertex x, then U contains all split vertices of x.</p><p>Proof Since y ∈ U , there is an s-t path in H [(W U)∪y] through y which is shorter than d. Suppose there is a split vertex z of x such that z / ∈ U . Since the neighborhoods of y and z are the same we can replace y by z in this path and obtain a path of the same length in H [(W U)], a contradiction with U being a vertex blocker. Thus all split vertices of x belong to U .</p><p>Proof By Observation 1 every vertex blocker of (G, s, t, V , d) is a vertex blocker of (H, s, t, d).</p><p>Let U be a minimum vertex blocker of (H, s, t, d). Since by our assumption all removable vertices form a vertex blocker of (G, s, t, V , d), we have |U | &lt; n. Thus by Claim 6 U cannot contain split vertices. By Observation 1 U is a vertex blocker of (G, s, t, V , d), a contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Reduction from Restricted-MEBP to MEBP</head><p>For each instance of restricted-MEBP we construct in polynomial time an instance of MEBP with the same size of the minimum edge blocker.</p><p>Let (G, s, t, E , k) be an instance of restricted-MEBP. Recall that we assume that all removable edges (arcs) form an edge blocker. Let m be the number of edges (arcs) of G. We obtain a graph H from G by consecutively splitting every fixed edge (arc) {x, y} ∈ E into m copies.</p><p>Similarly to Proposition 1 we can show that the minimum edge blockers of <ref type="figure">(G, s, t, E , d)</ref> and<ref type="figure">(H, s, t, d</ref>) have the same size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Reduction from Restricted-MVVP to MVVP</head><p>For each instance of restricted-MVVP we construct in polynomial time an instance of MVVP with the same optimal value.</p><p>Let (G, s, t, V , k) be an instance of restricted-MVVP. We construct an instance (H, s, t, k) as in Sect. 7.1 (where we split each fixed vertex now into k copies). Similarly to Proposition 1 we can show that the maximum of s-t distances in all graphs obtained from G by removing k vertices and the maximum of s-t distances in all graphs obtained from H by removing k vertices are equal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Reduction from Restricted-MVEP to MVEP</head><p>For each instance of restricted-MVEP we construct in polynomial time an instance of MVEP with the same optimal value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Proof of Theorem 4</head><p>As shown in <ref type="bibr" target="#b6">[7]</ref>, it is NP-hard to approximate the size of the smallest vertex cover in tripartite graphs within a factor smaller than 34  33 . This can be restated as follows: for every fixed &gt; 0 it is NP-hard to distinguish tripartite graphs having a vertex cover of size k from those having all vertex covers of size greater than ( </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Ahuja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Magnanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Orlin</surname></persName>
		</author>
		<title level="m">Network Flows: Theory, Algorithms, and Applications</title>
		<meeting><address><addrLine>New Jersey</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Finding the most vital arcs in a network</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Golden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Vohra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res. Lett</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="73" to="76" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The complexity of finding most vital arcs and nodes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bar-Noy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khuller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schieber</surname></persName>
		</author>
		<idno>CS-TR-3539</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
			<pubPlace>College Park, MD</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Maryland, Institute of Advanced Computer Studies</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Adapting Gurvich-Karzanov-Khachiyan&apos;s algorithm for parity games: implementation and experimentation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Beffara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vorobyov</surname></persName>
		</author>
		<idno>020</idno>
		<ptr target="http://www.it.uu.se/research/reports/#2001" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Department of Information Technology, Uppsala University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Is randomized Gurvich-Karzanov-Khachiyan&apos;s algorithm for parity games polynomial?</title>
		<author>
			<persName><forename type="first">E</forename><surname>Beffara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vorobyov</surname></persName>
		</author>
		<idno>025</idno>
		<ptr target="http://www.it.uu.se/research/reports/#2001" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Department of Information Technology, Uppsala University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A combinatorial strongly subexponential strategy improvement algorithm for mean payoff games</title>
		<author>
			<persName><forename type="first">H</forename><surname>Björklund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sandberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vorobyov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discret. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="210" to="229" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">On the complexity of approximating colored-graph problems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E F</forename><surname>Clementi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Crescenzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rossi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="281" to="290" />
		</imprint>
		<respStmt>
			<orgName>COCOON</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Most vital links and nodes in weighted networks</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Corely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Y</forename><surname>Shaw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res. Lett</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="157" to="160" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the hardness of approximating minimum vertex cover</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Safra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math</title>
		<imprint>
			<biblScope unit="volume">162</biblScope>
			<biblScope unit="page" from="439" to="485" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Positional games over a graph</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ehrenfeucht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mycielski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Not. Am. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page">334</biblScope>
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Positional strategies for mean payoff games</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ehrenfeucht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mycielski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Game Theory</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="109" to="113" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fibonacci heaps and their uses in improved network optimization algorithms</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Fredman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="596" to="615" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Maximizing the minimum source-sink path subject to a budget constraint</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Fulkerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Harding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Program</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="116" to="118" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Maximum-minimum Sätze über Graphen</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gallai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Math. Acad. Sci. Hung</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="395" to="434" />
			<date type="published" when="1958">1958</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979">1979</date>
			<pubPlace>Freeman, San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimal interdiction policy for a flow network</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Ghare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Montgomery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nav. Res. Logist. Q</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="37" to="45" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A problem in network interdiction</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Golden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nav. Res. Logist. Q</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="711" to="713" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The monotone and planar circuit value problem are log space complete for P</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Goldschlager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="25" to="29" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Limits to Parallel Computation: P-Completeness Theory</title>
		<author>
			<persName><forename type="first">R</forename><surname>Greenlaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hoover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Ruzzo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Oxford University Press</publisher>
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Cyclic games and an algorithm to find minimax cycle means in directed graphs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gurvich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karzanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Khachiyan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">USSR Comput. Math. Math. Phys</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="85" to="91" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Some optimal inapproximability results</title>
		<author>
			<persName><forename type="first">J</forename><surname>Håstad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC &apos;97: Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Shortest-path network interdiction</title>
		<author>
			<persName><forename type="first">E</forename><surname>Israely</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="97" to="111" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A deterministic subexponential algorithm for solving parity games</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jurdzinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Zwick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA 2006</title>
		<imprint>
			<biblScope unit="page" from="117" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A better approximation ratio for the vertex cover problem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karakostas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICALP</title>
		<imprint>
			<biblScope unit="page" from="1043" to="1050" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Reducibility among combinatorial problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<editor>Miller, R.E., Thatcher, J.W.</editor>
		<imprint>
			<date type="published" when="1972">1972</date>
			<publisher>Plenum</publisher>
			<biblScope unit="page" from="85" to="103" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
	<note>Complexity of Computer Computations</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A characterization of the minimum cycle mean in a digraph</title>
		<author>
			<persName><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discret. Math</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="309" to="311" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Cyclical games with prohibition</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Karzanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Lebedev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Program</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="277" to="293" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The k most vital arcs in the shortest path problem</title>
		<author>
			<persName><forename type="first">K</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mittal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res. Lett</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="223" to="227" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Optimal interdiction of a supply networks</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Mcmasters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Mustin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nav. Res. Logist. Q</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="261" to="268" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Prolongement des jeux à deux joueurs de somme nulle</title>
		<author>
			<persName><forename type="first">H</forename><surname>Moulin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bull. Soc. Math. France, Memoire</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Extension of two person zero sum games</title>
		<author>
			<persName><forename type="first">H</forename><surname>Moulin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Math. Anal. Appl</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="490" to="507" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The network inhibition problem</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Phillips</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Annual ACM Symposium on the Theory of Computing</title>
		<meeting>the 25th Annual ACM Symposium on the Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="776" to="785" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Mean cost cyclical games</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">N</forename><surname>Pisaruk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="817" to="828" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A note on the stable sets and coloring of graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Poljak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comment. Math. Univ. Carol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="307" to="309" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Combinatorial Optimization: Polyhedra and Efficiency</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schrijver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms and Combinatorics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<date type="published" when="2003">2003</date>
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Approximation Algorithms</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vazirani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Disjoint (s, t)-cuts in a network</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">K</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="361" to="371" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Two-person zero-sum games for network interdiction</title>
		<author>
			<persName><forename type="first">A</forename><surname>Washburn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="243" to="251" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Deterministic network interdiction</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput. Model</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1" to="18" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The complexity of mean payoff games on graphs</title>
		<author>
			<persName><forename type="first">U</forename><surname>Zwick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">158</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="343" to="359" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
