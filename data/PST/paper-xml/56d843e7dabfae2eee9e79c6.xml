<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SecKit: a Model-based Security Toolkitfor the Internet of Things</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2015-05-15">May 15, 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ricardo</forename><surname>Neisse</surname></persName>
							<email>ricardo.neisse@jrc.ec.europa.eu</email>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gary</forename><surname>Steri</surname></persName>
							<email>gary.steri@jrc.ec.europa.eu</email>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Igor</forename><forename type="middle">Nai</forename><surname>Fovino</surname></persName>
							<email>igor.nai-fovino@jrc.ec.europa.eu</email>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gianmarco</forename><surname>Baldini</surname></persName>
							<email>gianmarco.baldini@jrc.ec.europa.eu</email>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">European Commission Joint Research Centre</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SecKit: a Model-based Security Toolkitfor the Internet of Things</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-05-15">May 15, 2015</date>
						</imprint>
					</monogr>
					<idno type="MD5">66548BC0B3CA057B98C6C037E1C48BF1</idno>
					<idno type="DOI">10.1016/j.cose.2015.06.002</idno>
					<note type="submission">Received Date: 5 February 2015 Revised Date: 15 May 2015 Accepted Date: 12 June 2015 Preprint submitted to Computers &amp; Security</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Computers &amp; Security Model-based</term>
					<term>Security</term>
					<term>Management</term>
					<term>Usage control</term>
					<term>Internet of Things</term>
					<term>Policy-based management</term>
					<term>Trust management</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The control and protection of user data is a very important aspect in the design and deployment of the Internet of Things (IoT). The heterogeneity of IoT technologies, the large number of devices and systems, and the different types of users and roles create important challenges in this context. In particular, requirements of scalability, interoperability, trust and privacy are difficult to address even with the considerable amount of existing work both in the research and standardization community. In this paper we propose a Model-based Security Toolkit, which is integrated in a management framework for IoT devices, and supports specification and efficient evaluation of security policies to enable the protection of user data. Our framework is applied to a Smart City scenario in order to demonstrate its feasibility and performance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In this paper we adopt the IoT definition from <ref type="bibr" target="#b0">[1]</ref>: IoT links the objects of the real world with the virtual world, thus enabling anytime, anyplace connectivity for anything and not only for anyone. It refers to a world where physical objects and beings, as well as virtual data and environments, all interact with each other in the same space and time. These things should be able to exchange information and provide services through different means and from different places.</p><p>For the purposes of this paper, we consider the extended realm of smart devices interconnected through the Internet. The heterogeneity of technologies, devices, and applications domains with their specific requirements and boundary conditions makes the design of a generic framework for IoT extremely complex. In this context, new challenges raise under the cyber-security perspective as information is exchanged among things with different capabilities and users with different roles and data usage permissions.</p><p>The research problems we address in this paper are a) hot to ensure that user needs for security and privacy are validated in the evolution of internet</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>towards IoT and b) how trust relationships can be established and managed between the IoT technology and the individuals who use such technology <ref type="bibr" target="#b1">[2]</ref>. In comparison to Internet, IoT will increase the synergy between the real and the digital world. The amount of data collected by IoT sensors will be much larger than in the current Internet and the data itself will be more detailed and related to the daily activities of the citizen. For example, connected wearable sensors may send information to remote servers at any time of the day and their information could be linked to the specific actions of the citizen like shopping in a mall (e.g., interaction with commercial Location Based Services in an areas). This flow of information can have serious privacy issues unless it is not controlled properly and in accordance to the wishes and preferences of the citizen. The anonymization of data during data collection in the IoT device could be one of the approaches to mitigate privacy risks. In addition, privacy risks can be increased by the digital divide phenomenon. Users with more technical knowledge have usually a better perception of the risks when using IoT devices and applications, and also are more capable of protecting themselves.</p><p>New tools and technologies like the one presented in this paper should address the presence of the digital divide and support the individual in his/her interaction with the IoT. Beyond privacy, security issues are likely to be more important in IoT than Internet. IoT actuators can impact the safety of the citizen if a malicious attacker take them over or send wrong information to impair their decision process. There is the need for a tool or technology which enforces policies for IoT actuators to avoid the execution of actions, which impact safety. Another aspect to be addressed for the design and deployment of security and privacy solutions in IoT is the dynamic context where IoT devices must operate. Should the IoT sensor worn by an individual, implement the same policies for security and privacy at home or in an office environment? In the case of a natural disaster, can IoT devices implement specific policies to support the personnel involved in disaster response (e.g., provide real-time data to them). It is needed that security and privacy solutions designed for IoT support dynamic context.</p><p>In this paper, we propose a Model-based Security Toolkit named SecKit <ref type="bibr" target="#b2">[3]</ref> in order to address the challenges described above. The SecKit supports integrated modeling of the IoT system design and runtime viewpoints to allow an integrated specification of security requirements, threat scenarios, trust relationships, and usage control policies <ref type="bibr" target="#b3">[4]</ref> <ref type="bibr" target="#b4">[5]</ref>. The SecKit integrates previously published approaches for policy refinement <ref type="bibr" target="#b5">[6]</ref>, policy enforcement technology at different levels of abstraction with strong guarantees <ref type="bibr" target="#b6">[7]</ref>, context-based policy specification <ref type="bibr" target="#b7">[8]</ref>, and trust management <ref type="bibr" target="#b8">[9]</ref>. In contrast to existing general purpose and IoT-focused security approaches, which address some punctual security issues such as access control, risk, or trust without considering details and interrelations between these issues, the SecKit proposes an Enterprise Architecture <ref type="bibr" target="#b9">[10]</ref> approach for security engineering. Moreover, SecKit has been conceived with the ultimate scope to give to the end-user the possibility to design and enforce a set of security and privacy policies completely customized; in other words, it is the end-user that decides the desirable trade-off between</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>information disclosure, privacy and security.</p><p>SecKit has been integrated with the iCore Framework, which is a generic framework for IoT management. We demonstrate the feasibility of the SecKit components embedded in the iCore Framework and we provide results of simulations to support our theoretical foundation. In contrast to our previous publication that already introduces the iCore Framework including the SecKit approach and prototype implementation <ref type="bibr" target="#b2">[3]</ref>, in this paper we show the formalization of some of the SecKit metamodels and we also provide extensions to our policy rule language allowing the management of trust relationships . As a consequence, we build up on our SecKit solution towards a more complete coverage of the main challenges in the existing IoT frameworks with a special focus on data protection, trust, and privacy issues.</p><p>This paper is organized as follows: Section 2 describes the IoT framework we adopt and extend in this paper. Section 3 presents the formalization of the SecKit design and runtime metamodels. Section 4 introduces the proposed architecture and enforcement components implemented in the SecKit. In Section 5 our extended IoT framework is applied to a Smart City case study with an illustration of the flexibility to address the dynamic security aspects of this scenario including performance evaluation results of our implementation. Section 6 compares our framework with other approaches from IoT standards and research literature. Finally, Section 7 presents the conclusions and future developments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Internet of Things Framework</head><p>The work proposed in this paper derives from the iCore Project, which has the goal to mitigate the complexity and heterogeneity of different objects and technologies while maximizing the exploitation and provision of IoT objects and their services. The iCore Project proposes the abstraction of IoT using the Service concept, which is further refined in Composite Virtual Objects (CVOs) and Virtual Objects (VOs). A VO is a virtual representation of any real-world object (RWO) or digital object. A car, for example, can be represented as a CVO consisting of an engine, various sensors, and a communication system, which are all represented by VOs. Finally, a complete system or device can provide access to their capabilities represented by a Service. The overall architecture of the iCore Framework based VO, CVO and Service layers is described in Figure <ref type="figure" target="#fig_0">1</ref>, see <ref type="bibr" target="#b10">[11]</ref> for a detailed description.</p><p>The Security Management layer is indeed the layer where SecKit is deployed. It consists of the cross-layer components provided by the SecKit for authentication and security policy evaluation. The Identity Provider component is responsible for the user authentication, which can be achieved using different technical solutions. The specification of policy rules referencing identities is done using an abstract identity design model that can be mapped to the specific technical choice. The evaluation of the policies by the PDP is done using events signaled by the Policy Enforcement Point (PEP) deployed at the different layers of the framework. The SecKit components are described more in detail in Section 4. In this section, we describe a Model-based Security Toolkit (SecKit) to address the IoT challenges for security and privacy described in the introduction and which are summarized again in the following list. In the rest of the paper, we will refer to this list and these challenges to highlight how each specific feature of the Toolkit mitigate one or more challenges and the overall toolkit support a trustful relationship between IoT technologies and users. </p><formula xml:id="formula_0">M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>and have more granularity than the current informed content approach based on End-User License Agreement; 5. Control of the actions of IoT actuators: Regardless of the design and implementation of IoT actuators (e.g., IoT devices, which execute actions in the real world), security solutions should prevent specific actions which could be harmful to the safety of the user; 6. Anonymization of data: Solution for privacy in IoT should support anonymization of the data collected and distributed by the IoT devices. For example, the identity of the user could be replaced by pseudonyms generated to protect the privacy of the user.</p><p>In a world where IoT objects are more and more interacting and exchanging data, it is extremely important to be able to define and impose "rules of conduct" through mechanisms allowing to identify the most suitable security policies to be applied in a given scenario, to define the level of trust of the counterpart, and to regulate the information flows. The SecKit aims at achieving these objectives supporting integrated policy specification and enforcement at the Service, CVO, and VO layers of the iCore Framework. The SecKit foundation is a collection of metamodels that provides the basis for security engineering tooling, add-ons, runtime components, and extensions to address security, data protection, trust, and privacy requirements. In contrast to other approaches, the SecKit precisely specifies the relation between the security concepts and other security-relevant system concepts. Furthermore, the SecKit metamodels can be used as a abstract reference for conceptual agreements between different domains contributing to the interoperability alignment between them. The metamodels defined include Data, Time, Identity, Role, Context, Structure, Behavior, Risk, Trust, and Rule metamodels implemented using the Eclipse Modeling Framework (EMF) <ref type="bibr" target="#b11">[12]</ref> to support the specification of types, instantiations, and instances of the various concepts. All the Java classes generated from the metamodels and supporting runtime components are available as an open source project at https://github.com/r-neisse/SecKit.</p><p>In a nutshell, the Time metamodel specifies time units, timestamps, time durations, and time intervals. The Rule metamodel specifies abstract Event-Condition-Action (ECA) rule templates and configurations. The Data metamodel specifies data types mapped one-to-one to the iCore metamodel. The Identity metamodel specifies identity types and attributes. The Role metamodel specifies role types and hierarchy. The Context metamodel specifies context information, context situations, and Quality-of-Context attributes. The Trust metamodel specifies trust relationships related to specific trust aspects. The Structure metamodel specifies entities and interaction point mechanisms. The Behavior metamodel specifies behavior and activities (actions and interactions). Finally, the Risk metamodel specifies assets, vulnerabilities, threats, risk, and countermeasures mapped to rules or trust relationships.</p><p>SecKit can be used to specify and enforce policy rules for anoymization, confidentiality, data retention (e.g., delete data in 30 days), user consent, access control, non-repudiation, and trust management. Our focus in this paper is</p><formula xml:id="formula_1">M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>on the support provided by SecKit for the specification and enforcement of trust management and usage control policy rules. The policy rules in SecKit, consisting of authorizations and obligations, are specified as ECA enforcement rules. These rules use as a reference the set of inter-related design models, conforming to their respective metamodels, representing the different aspects of the IoT system. These design models are used as input by the runtime models and components in the SecKit enforcement platform, enabling monitoring of ECA rules and execution of enforcement behavior.</p><p>In the following subsections we present parts of the formal specification of our design metamodels using the Z language. Screenshots of the SecKit Graphical User Interface (GUI) implementation for all the different models are presented in a previous publication <ref type="bibr" target="#b2">[3]</ref>. The association of the ECA rules with these design models allows for checking of policy consistency with respect to the IoT system design models and the precise identification of policy enforcement points. All the metamodels introduced in the following subsections are connected to the policy rule language described in the last subsection by means of events, event patterns, and specific pattern matching operators. The Time and Risk models are not described in detail since the first is a trivial supporting metamodel and the latter is part of our ongoing work. The time metamodel introduces the Timestamp, TimeDuration, TimeInterval , and TimeUnit types that are used in the following specifications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Data</head><p>Our formalization of the system starts with the specification of the set of available data types, identified by name (DataTypeName). We model a set of available primitive types (PrimitiveType) defined using the primitive data types (EmfType) of EMF <ref type="bibr" target="#b11">[12]</ref>. Data type names can be used in the specification of composite data type (CompositeType) attributes (Attribute), which may also reference recursively by name other composite data types. Composite types may be defined as a subtype of other composite types, using the transitive, irreflexive, and asymmetric inheritance mapping getSuperTypeOf of a composite data type with the set of its super types. Sets of data types are associated to data type packages (DataTypePackage).</p><p>Data types can be used to declare data instantiations (DataInst) at design time. Data instances (Data) are created dynamically at runtime or statically at design time making reference to the defined data instantiations. Since we use a shared set of data type names we define constraints to prevent duplicate names. We also define a constraint using the transitive closure of getSuperTypeOf that forbids a composite type to be indirectly a subclass of itself, which is in alignment with the specifications of the EMF metamodel. Data instantiations (DataInst) are used to specify identity types and also to specify the data instantiations established by activities in the behavior model. </p><formula xml:id="formula_2">== P DataTypeName DataInst == DataInstName × DataTypeName × ArrayFlag Data == DataId × DataInst × DataValue ∀ pt1, pt2 : PrimitiveType • pt1.1 = pt2.1 ∀ ct1, ct2 : CompositeType • ct1.1 = ct2.1 ∀ pt : PrimitiveType, ct : CompositeType • pt.1 = ct.1 ∀ ct : CompositeType • ct → ct / ∈ getSuperTypeOf +</formula><p>In our security policy rule language patterns can be specified in policy rules to match data instances at runtime in the rule conditions. The following specification introduces the DataPattern type, which is used to match instances of a specific data instantiation (DataInstPattern), data type name (DataTypePattern), and that match a specific data instance value according to the data value pattern (DataValuePattern). We support in our implementation the interpretation of data values as regular expressions, XPath expressions, or static literal patterns.</p><p>Patterns may include variables in order to enable configurable security policy rule templates. Our strategy is to define the type DataVarDecl representing a named variable declaration that can be used in place of the respective type in the pattern specification. We follow the same strategy in the specification of patterns for identities, context situations, roles, structural and behavioral elements.</p><p>We define below the pattern matching for data instances. For every pattern matching relation we have a choice of evaluating a static pattern or a parametrized pattern with a variable, which is a simple match of the variable value. It is important to notice that data types and instantiations are matched by name even for the variables, while data values are matched by the Data type when variables are used. A data instance matches a pattern if they refer to the same instantiation and if the evaluation of the data value against an expression using the function eval is satisfied. The eval function evaluates a Regular expression, an XPath expression in the context of the data pattern definition, or performs a simple string comparison of the static data value defined in the data pattern for the given value in the data instance. We allow the specification of data patterns that match more than one data instance using the reserved typed wildcard any for data type and instantiation names. In our metamodel we relate data instantiations and data instances with a set of data concepts (DataConcept). An ontology of data concepts is useful in the specification of abstract security policy rules that apply to a concept independently of the system activity that handles the data. The definition of a data ontology, tracking static information flow analysis at design time, and dynamic information flow tracking at runtime are out of the scope of this paper.</p><p>Data types are instantiated in the specification of identity types, context information types, and activity types to represent their data input and output. The data model also supports inheritance, which enables specification of security policy rules for abstract data types. For example, an enforcement template defined for the PersonProfile is also applicable for a SocialNetworkProfile if the latter is a subtype of the former. Data types can be imported from an ECore model specified using the standard Eclipse EMF tooling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Identity</head><p>Our model of identity types follow a simple attribute-based approach, where the subject name and identity attributes are part of the data instantiation set. An identity type is defined by a name (IdentityTypeName), a mandatory subject name (SubjectName) of the string EmfType, and a set of identity attribute declarations (IdentityAttributeType). Identity instantiations (IdentityInst) are used in conjunction with data instantiations to model the results of activities in the behavior model. An identity instance includes an identifier of the identity and one of the identity issuer (IdentityId ×IdentityId ), allowing for self signed and 3rd party certified identities. Identity patterns (IdentityPattern) are also supported for both types of identities in our security policy rule language, as specified below.</p><p>[IdentityTypeName, IdentityInstName, IdentityId, IdentityValue] IdentityType == IdentityTypeName × SubjectName × P IdentityAttributeType</p><formula xml:id="formula_3">IdentityTypePackage == P IdentityType IdentityInst == IdentityInstName × IdentityTypeName Identity == IdentityInst × SubjectValue × P Data × IdentityId × IdentityId IdentityInstPattern == IdentityInstName × IdentityTypeName IdentityPattern == CertifiedIdentityPattern IdentityPattern × IdentityPattern | SelfSignedIdentityPattern IdentityInstPattern × SubjectPattern × P DataPattern ∀ idt1, idt2 : IdentityType • idt1.1 = idt2.1 ∀ s : SubjectName • s.1 = subjectName ∧ s.2 = string ∧ s.3 = isSingle ∀ idt : IdentityType; at1, at2 : IdentityAttributeType • at1 ∈ idt.3 ∧ at2 ∈ idt.3 ∧ at1.1 = at2.1 IdentityAttributeType ⊆ DataInst SubjectName ∈ IdentityAttributeType SubjectValue ⊆ Data SubjectPattern ⊆ DataPattern M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>We define the matchesIdentityInst and matchesIdentity relations between identity instantiations and instances using the data pattern satisfaction relation as a building block. An identity instance matches an identity pattern if the instantiation is a match, if the subject is a match, and if all the attributes are a match for the pattern. Furthermore, for certified identity patterns the identity issuer may also be matched. Similar to data patterns, we support the specification of identity patterns that match more then one identity type, using the any wildcard for identity type and instantiation names.</p><p>The identity model specifies the identity types and their respective identity attributes. Our model abstracts from specific technical details of the adopted identity management solutions, it only provides a high-level description of the identity types and attributes that can be used in the specification of security policy rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Roles</head><p>The role model specifies the role types and the role hierarchy with a possible inheritance of membership from role types. Identities are assigned to role types and the isSubRoleOf relation maps a role type to a parent role, with the added constraint to prevent cycles in the role hierarchy definition. A role pattern is trivially the specification of a type that should match a specific role, or indirectly a parent role, and an identity pattern that should be contained in the matching role type hierarchy. In our security policy rule language role patterns can be specified in policy rules to match role membership at runtime in the rule conditions. A role pattern can be used to allow or deny the execution of an activity depending on the assigned role. For example, Doctor and Nurse are both sub roles of the HealthProfessional role, where entities assigned to the child roles are also members of the parent role. The assignment of identities to role types is done in the runtime model specification in the SecKit.</p><p>[RoleType] getAssignedRoles :</p><formula xml:id="formula_4">Identity → P RoleType RolePattern == RoleType × IdentityPattern isSubRoleOf : RoleType ↔ RoleType ∀ r 1, r 2 : RoleType • r 1 isSubRoleOf r 2 ⇔ r 1 → r 1 / ∈ isSubRoleOf +</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Context</head><p>A Context Information is a simple type of information about one entity that is acquired at a particular moment in time, and Context Situation is a complex type that models a specific condition that begins and finishes at specific moments in time <ref type="bibr" target="#b12">[13]</ref>. For example, the Global Positioning System (GPS) location is an example of a context information type, while Fever and In One Kilometer Range are examples of situations where a patient has a temperature above 37 degrees Celsius, or a target entity has a set of nearby entities not further than one</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>kilometer away. Patient and target entity are the roles of the different entities in that specific situation. A context information type (ContextInformationType) is definned as a mapping from a name to a data instantiation. A context situation type (ContextSituationType) is defined as a mapping from a name to a set of situation role names (SituationRoleName). We plan to integrate in the SecKit the approach proposed by Dockhorn Costa et al. <ref type="bibr" target="#b12">[13]</ref>.</p><p>The formalization of context information and situation instances is out of the scope of this paper. We allow in our security policy rule language situation events and situation event patterns to detect the beginning and end of a context situation. In our trust model we define the PersonalTrust and SituationalTrust types that specify trust relationships valid for a set of entities in a specific situation. With our context metamodel we address the challenge Support for Dynamic Context identified in the list of challenges introduced in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Behavior and Structure</head><p>The SecKit Structure and Behavior metamodels are inspired by an existing generic design language to represent the architecture of a distributed system across application domains and successive levels of abstraction called Interaction System Design Language (ISDL) <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>. The system design in ISDL is divided into two domains named entity domain and behavior domain, with an assignment relation between entities and behaviors. In the entity domain the designer specifies entities and interaction points between entities representing the communication mechanisms. In the behavior domain the behavior of each of the entities is detailed including actions, interactions, causality relations, and information attributes. The idea behind the SecKit models inspired by ISDL is to provide a minimal set of concepts that supports the design of the IoT Services, CVOs, and VOs from the iCore Framework described in Section 2. Furthermore, one important feature of ISDL that justifies our choice for this language is the support for refinement relations, which has being applied in previous work to support the automated refinement of security policy rules <ref type="bibr" target="#b5">[6]</ref>. Figure <ref type="figure">2</ref> shows an example structure and behavior design model at one arbitrary abstraction level. In this example the Smart Home entity interacts with the MedicalCenter through an Interaction Point. The interaction type and the information exchanged are depicted in the behavior model, which in this example is the Access heart rate interaction, which exchanges the heart rate data (hr). The contribution of each behavior type to the interaction is depicted by a half circle, and represents the role of the behavior in the interaction. A contained behavior represents a VO, and the container behavior a CVO.</p><p>In our behavior metamodel we define the possible activity types (actions and interactions), instantiations, and instances. Activities are data consumers and producers that are enabled to be executed by means of causality relations. Here we consider only the specification of behaviors and activities that are relevant for specification of security policy rules.</p><p>An interaction type (InteractionType) is defined with a name, a set of interaction contribution types (InteractionContributionType), a set of data instantiations, and a set of identity instantiations representing the values established after an occurrence of an interaction of this type. We also define interaction instantiations (InteractionInst) contained in behavior types at design time, and interaction instances (Interaction) contained in behavior instances at runtime. An interaction contribution type specifies a behavior role and a set of data and identity instantiation names that are the input of the specific role for the interaction type they participate in. For example, in Figure <ref type="figure">2</ref> the Smart Home Behavior assumes the home role and contributes with the hr data to the Access Heart Rate interaction. Interaction types can be mapped to service specifications, where typical roles are providers and consumers. However, in our model abstract interactions may define more than two roles in an interaction. Interaction contribution types are instantiated by behavior types and behavior instantiations (BehaviorType, BehaviorInst). Interaction contribution instantiations of a behavior type define possible contributions of a type that are instantiated for all instantiations of the behavior type (InteractionContributionOfInst). An interaction instantiation (InteractionInst) connects two or more interaction contribution instantiations to define a concrete interaction possibility between behaviors.</p><formula xml:id="formula_5">M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>In our policy rule language we define activity events and event patterns that match activities defined in the behavior model, and may also include patterns to match the data and identity produced by the activity. For example, a security policy rule can be specified to deny all network interactions of a specific behavior instance when there is a possibility that personal data may be exchanged. The following specification defines behavior types, instantiations, and instances.</p><formula xml:id="formula_6">[BehaviorTypeName, ActionInst, InteractionInst, CausalityRelation] BehaviorType = BehaviorTypeName × P ActionInst × P InteractionInst × P FlowPointInst × P InteractionContributionOfInst × P CausalityRelation BehaviorInst = BehaviorInstName → BehaviorTypeName Behavior = BehaviorId × BehaviorInst</formula><p>In addition to interaction instantiations, behavior types also specify the contained action instantiations, flow point instantiations, and the causality relations between them. Even tough we include in our metamodels the causality relations</p><formula xml:id="formula_7">M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>they are not needed to support the specification of policy rules. Causality relations are useful to generate executable behavior specifications, for simulation, and to support information flow analysis, which is part of our future work.</p><p>The security policy rules proposed by us are evaluated considering events that represent the execution of activities defined in our behavior model. In order to support the specification of these policy rules we define behavior and activity pattern matching relations. Interaction patterns match an interaction of a specific instantiation, type, and that establish specific data and identity results. In addition, an interaction can also be matched considering the pattern of interaction contributions participating in the interaction. For example, a privacy protection policy rule can be defined to deny a data request interaction (type) defined between a weather station and a cloud service (instantiation) if the identity of the station owner is provided by the weather station (contribution). The following specification introduces the patterns specified for behaviors, entities, interaction contributions, and interactions.</p><formula xml:id="formula_8">BehaviorPattern = BehaviorTypeName × BehaviorInstName × BehaviorId EntityPattern = RoleType × IdentityPattern × TrustRelationshipPattern × EntityId InteractionContributionPattern = InteractionRoleName × P DataPattern × P IdentityPattern InteractionPattern = P InteractionContributionPattern × P DataPattern × P IdentityPattern</formula><p>In the matching of entities and behaviors we also allow the use of trust relationship patterns that are introduced in the next subsection. Similar to our pattern specification approach for data and identities we also support the typed any wildcard to match all behavior types, instantiations, and instances (e.g., any <ref type="bibr">[BehaviorTypeName]</ref>). This flexibility in our pattern matching approach allows very specific policy rules to be specified, for example, all interactions contained in an IoT system, where a specific smart home interacts with any other entity. To the best of our knowledge fine-grained constraints considering the participants of an interaction cannot be expressed in any other security policy languages. Examples of the structure and behavior design model GUI are shown in our case study in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6.">Trust</head><p>In our trust model we adopt the widely accepted definition of trust as relationship between a Trustor and a Trustee <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>. We define trust as the measurement of the belief from a trusting party point of view (trustor) with respect to a trusted party (trustee) focused on a specific trust aspect that possibly implies a benefit or a risk <ref type="bibr" target="#b8">[9]</ref>. For example, Bob (Trustor) may trust to a high degree (measurement) his Weather Station (Trustee) concerning its competence to provide accurate weather information (trust aspect). The benefit or risk implication is only present when Bob accepts to depend on the weather information for some activity and may be impaired by inaccuracies, for example, leave his</p><formula xml:id="formula_9">M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>umbrella at home and arrive wet for an important meeting. As defined below, a trust relationship (TrustRelationship) is defined from a trustor perspective (referenced using an identity) for a specific trustee scope, it has an abstract likelihood measurement and it is defined for a specific trust aspect. Trust relationships can be specified directly based on a trustor's arbitrary opinion or considering previously observed positive/belief or negative/disbelief evidence about a specific trust aspect. Indirect trust is specified using the concept of fusion operators that combine a set of trust relationships that match a specific pattern. For example, a reputation trust value can be defined by a combination of recommendations from many entities or a community. Positive and negative evidence are translated for each trust aspect to an opinion using the formula illustrated in <ref type="bibr" target="#b8">[9]</ref> (p. 91).</p><p>The seminal work on trust done by Mayer <ref type="bibr" target="#b17">[18]</ref> defines the social trust concept of Trust Beliefs, which is equivalent to a TrustRelationship in our model. Mayer also defines different scopes for a trust relationship, namely System Trust, Dispositional Trust, and Situational Trust. Dispositional Trust is the intrinsic/inherent disposition of a trustor to trust any trustee in the absence of evidence or previous experiences, which can be used for bootstrapping of trust relationships. System Trust is the impersonal trust assigned by a trustor for a system as a whole without considering a particular target trustee. Situational Trust represents the trust assigned to a particular context situation. Finally, Personal Trust is the trust assigned to a specific trustee in a specific context situation, represented by an identity pattern. An identity pattern example is a trust relationship defined for all trustees owning an identity containing the attribute issued by with value European Commission.</p><p>Different likelihood measurement approaches can be adopted: in our work we chose to use the Subjective Logic (SL) <ref type="bibr" target="#b18">[19]</ref>, which is a probabilistic logic capable of explicitly expressing uncertainty about the probability values. In SL an</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>opinion is represented by the belief (b), disbelief (d), and uncertainty (u) where b +d +u = 1. We adopt a discrete mapping of an SL opinion to a set of five trustworthiness values defined in the LikelihoodMeasurement type previously proposed by some of the co-authors in a previous publication: when the uncertainty is lower than the belief/disbelief this represents a very trustworthy/untrustworthy opinion <ref type="bibr" target="#b8">[9]</ref>.</p><p>The objective of a trust aspect definition is to have a precise specification of what is the intended meaning of a trust relationship, including issues related to the provisioning of trust recommendations, structural, behavior, data, and identity qualities. The Recommendation Quality aspect is associated to an entity to provide trust recommendations. For example, someone may be trusted to recommend a good car mechanic but not to recommend a restaurant. The Structural Quality aspect relates to properties of elements in the entity domain of our system model that are independent of the behavior like, for example, physical tamper resistance. This trust aspect is related to entity types (e.g., Weather Station) and interaction point types (e.g., Wi-Fi). The Behavior Quality aspect is the quality aspect of an entity behavior that can be specified considering the quality of the service (e.g., response time), experience (e.g., usability), or protection (e.g. privacy enforcement). This trust aspect is related to activity types (e.g., Update firmware) and interaction contribution roles (e.g., manufacturer ). The Data Quality aspect is associated to the capability of an entity to provide data according to a specified quality level. In an IoT scenario this can be associated to the precision of sensor information (e.g., temperature). The Identity Quality aspect is a specialized type of Data Quality trust related to the level of assurance (LoA) of the identities provided by an entity. This trust aspect is usually associated to identity providers and the quality of identity attributes used in the identities issued by them (e.g., attributes verified face-to-face).</p><p>Trust aspects may overlap when trust relationships are specified for data or identity provisioning services, which in this case are assigned respectively to data and identity quality trust aspects and the specified interaction type may be omitted. Some trust models associate trust relationships with an isolated or combined measurement of the concepts of honesty, credibility, reputation, usability, competence, fit for purpose, reliability, and quality <ref type="bibr" target="#b19">[20]</ref> <ref type="bibr" target="#b16">[17]</ref>. Our trust model captures precisely all this different concepts with the definition of the different trust types, recommendations, and trust aspects. With our trust metamodel we address the challenge Support for Trust Management identified in the list of challenges introduced in Section 3.</p><p>The following specifications define the trust pattern types, which allows matching of trust relationships and recommendations considering a specific trust aspect, degree, trustor, trustee scope, time interval, and recommenders' identities. Using this flexible model of combination of trust based on patterns, it is possible to infer derived trust relationships from different aspects: for example, privacy enforcement and identity provisioning trust could be combined in a more general service provisioning trust relationship. The matchesTrust evaluates a trust relationship pattern with respect to the available trust relationships in the trust database. Trust assessments are useful in our policy rule language to define conditions, for example, allowing a specific activity only if a minimum likelihood measurement is met. We define below three assessment operators exactly, atLeast, and atMost, which are evaluated by the evalTrust relation between a likelihood measurement and a trust query. Trust queries evaluated using the query relation, using the previously defined pattern matching relations for trust relationships and recommendations, consider the trust relationships from one trustor point of view or the trust recommendations received from other trustors' point of views. We only support one concrete example of a fusion operator in our policy rule language, the Consensus trust query element, which is mapped to the SL consensus operator <ref type="bibr" target="#b18">[19]</ref> and implemented in the SL API <ref type="bibr" target="#b20">[21]</ref>. The result of this operator is increased uncertainty if the combined likelihood measurement values in the received trust recommendations contradict each other. </p><formula xml:id="formula_10">∼ lm2 = TrustDegree ∼ lm1)) ∨ (op = atLeast ∧ (TrustDegree ∼ lm2 ≥ TrustDegree ∼ lm1)) ∨ (op = atMost ∧ (TrustDegree ∼ lm2 ≤ TrustDegree ∼ lm1)))</formula><p>We only consider exact matches of patterns and we require patterns and relationships to be specified without missing parameters or duplicate trust relationships for the same aspect, trustee scope, etc. It is part of our future work</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>to consider the support for matching of trust relationships and patterns with undefined parameters where a pattern can match a set of trust relationships that must be combined using a fusion operator (e.g., more specific vs. generic match of trust relationship for the pattern).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.">Policy Rules</head><p>The specification of policy rules in SecKit is done using policy rule templates that must be explicitly configured. A policy rule template follows an ECA structure, evaluated over a discrete trace of sets of events with the following semantics: when the trigger event (E) is observed, and the condition (C) evaluates to true, the action (A) is executed. Rule templates reference to the design models of the system data, identity, role, context, structure, behavior, and trust. In this subsection we show the formalization of events, event patterns, the operators supported in the condition of a policy rule, and the formalization of policy rule templates and configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.1.">Events</head><p>Events in the SecKit represent context situation changes and activities (actions and interactions) between VOs, CVOs, and Services in the iCore Framework. We model the start of an activity, ongoing activities, and the completion of an activity with the event indexes: start, ongoing, completed. To support enforcement of usage control policies including authorization decisions we model tentative and actual events. A tentative event is generated when an activity is ready to be started by the iCore Framework but has not started yet, giving the opportunity for the execution of enforcement actions to allow or deny the execution of the activity.</p><p>The following specification models the supported event types (Event) representing the lifecycle of system activities or context situations. Event modalities are only used for activity events because context situations are only detected and no enforcement can take place to allow or deny situations, they are simply observed. With the combination of the ongoing index with a tentative modality we are able to model ongoing activities that can be stopped by the policy rules. A discrete event trace is represented as a mapping of time steps N in a TimeStepWindow , which contains a set of observed events.</p><p>We also support events to represent the lifecycle (instantiation and disposal) of system entities, behaviors, identities, context information, and data. Due to space restrictions we do not show the detailed formalization of these types of events, we focus on the specification of interaction events. The formalization of actions, flow points, context situations, and lifecycle events are done in a similar way. Interaction events reference instances of the respective interaction instance, which contains details about the activity being executed. Event patterns are specified for all event types and also for a special event that denotes the end of a discrete time step named TimestepEvent. Interaction event patterns include patterns for the interactions contributions, data and identity established by the interaction, behavior where the activity is contained, and for the entity that executes the behavior. Interaction contribution patterns also include behavior and entity patterns to match the participants of the interaction. In our policy rules we define conditions based on the occurrence of events, and to specify this conditions we define event pattern types with a |=pattern satisfaction relation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.2.">Operators</head><p>The condition part of a rule template is a formula Φ, which consists of constants, event patterns, trust patterns, propositional, temporal, and cardinality operators. The abstract syntax of a formula is defined as:</p><formula xml:id="formula_11">Φ ::= true | false | EventPattern | TrustAssessment not Φ | or Φ × Φ | and Φ × Φ | implies Φ × Φ | always Φ | eventually Φ | since Φ × Φ | before N × Φ | within N × Φ | during N × Φ | repSince N × Φ × Φ | repLim N × N × N × Φ</formula><p>Informally, the semantics of the temporal operators is: for always the operand must have been true in all previous time steps; for eventually the operand must have been true at least once in all previous time steps; for since the first operand must have been true in all time steps since the second operand was true, or the second operand has always been true (weak since from LTL); for before, within, and during the formula operand must have been true at a exact number of time steps ago, at least once for a bounded number of previous time steps, or during all bounded number of previous time steps; for repSince is the same as since with an additional upper bound number of times that the first formula may have been true; for repLim the formula must have been true during a bounded number of previous time steps according to a lower and upper bound for the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>number of occurrences. The formal semantics of the temporal and cardinality operators is based on past time Linear Temporal Logic (LTL) and is already described by Hilty et al. <ref type="bibr" target="#b21">[22]</ref>. The formal semantics of the EventPattern and TrustAssessment was introduced by us in this Section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7.3.">Rule Templates</head><p>The specification of authorization and obligation policy rules is done in SecKit using a model containing rule templates (RuleTemplate) that must be explicitly instantiated using rule template configurations (TemplateConfiguration). Templates are parametrized with variables that are instantiated by the template configuration. When the rule is configured it is also possible to specify when the rule should be disposed, after it is triggered the first time, never, or also when a particular Event-Condition is observed. By introducing templates we address the challenge Support for the Digital Divide identified in the list of challenges introduced in Section 3, allowing to less knowledgeable users the selection of existing templates instead of specifying their own. The event part of a rule template is called the trigger event, and is an event pattern matching operator that is also supported in the condition part. An event includes the details about the activity being executed such as identity and roles of the entities performing the activity, and information attributes produced by the activity itself. For action events we can trigger rules considering the entity executing the action, for interaction events we can observe who are the interaction participants and perform the respective enforcement. We also support patterns of events capturing context information and context situation changes, and lifecycle events for entity, behavior, and data types.</p><p>The action part of an enforcement template consists of an enforcement and an execution part. The enforcement part refers to the trigger event of the rule template and may allow or deny the execution of the respective activity. If the activity is allowed, it is also possible to specify an optional modification or</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>delay of the activity execution, for example, anonymizing activity data before the activity takes place. The anonymization could be the simple modification of a name identity attribute to an empty string. The execution part of an enforcement template may trigger the execution of additional activities, for example, notifications or logging of information. With the addition of these different enforcement and execution options in our policy rules we address the challenges Control of the data flow from IoT Device, Control of the actions of IoT actuators, and Anonymization of data identified in the list of challenges introduced in Section 3.</p><p>In addition to enforcement templates we also support instantiation templates, disposal templates, and condition templates, in order to maximize re-use of enforcement rules and to allow efficient monitoring of parametrized templates. The action part of these templates implicitly instantiate and dispose other rule templates when the event and condition parts evaluates to true.</p><p>When composite enforcement templates are specified, a combining strategy must be also specified in case multiple rules are triggered resulting in a conflicting decision similar to the XACML approach <ref type="bibr" target="#b22">[23]</ref>, such as allow overrides, deny overrides, or first applicable rule. Furthermore, child/contained templates must specify a refined trigger event in relation to its parent, which informally means that the trigger pattern of child templates inherit the patterns specified in the trigger of the parent rules. The general idea is to support the re-use of the instantiation template to other enforcement templates without loss of generality.</p><p>At runtime, all template configurations will be instantiated using the variable assignments defined, resulting in a set of rules. Our combining algorithm always select the modification or delay to apply considering the enforcement chosen according to the strategy definition. The semantics of the combining algorithm is recursive, where contained rules that contain nested rules themselves are first evaluated and the resulting enforcement is combined with the parent rule for a unique enforcement result in a rule hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Architecture</head><p>Figure <ref type="figure" target="#fig_4">3</ref> shows the SecKit enforcement components. In our enforcement architecture the IoT System implementing the iCore Framework is monitored by a technology specific Policy Enforcement Point (PEP), which observes and intercepts service, CVO, and VO invocations taking into account event subscriptions by the Policy Decision Point (PDP). The PEP component signals these events to the PDP, and receives enforcement actions in case a tentative event is signaled. If required for policy evaluation the PDP may implement custom actions to retrieve status information of VOs and CVOs, and subscribe to context information and situation events with the Context Manager component, both using existing functionality provided by the iCore Framework.</p><p>The subscription and signaling of events between the PDP and PEP is done using JavaScript Object Notation (JSON) format and HTTP. In the iCore Framework we implemented a PEP component <ref type="bibr" target="#b23">[24]</ref> embedded in the Message</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IoT System</head><p>Actual or tentative event (subscribe/notify) Enforcement behavior (allow, deny, modify, or delay)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Save policy</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notify policy updates</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Policy Decision</head><p>Point (PDP)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Containers</head><p>Execute behavior</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Policy Server (PS)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Policy Management GUI</head><p>Update policies</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Context Manager</head><p>Context information and situation events (subscribe/notify)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Context monitoring</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Services, CVOs, and VOs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Role Manager</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Check role assignments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Policy Repository (PR)</head><p>Retrieve policies</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Update role assignments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Policy Enforcement</head><p>Point (PEP) Queue Telemetry Transport (MQTT) message broker that is used as a middleware to enable the communication between VOs, CVOs, and services. The PEP component functions as reference monitor and it is implemented using runtime monitoring techniques targeting the specific IoT technology in place. When multiple technologies are used to enable the communication and execution of VOs, CVOs, and services more PEP components would have to be implemented to monitor and generate events to the PDP component (see Figure <ref type="figure" target="#fig_0">1</ref>). In order to maximize the efficiency and load distribution in policy evaluation multiple PDP components may also be required, with a distribution of policies considering their scope. For example, if a set of policies only references events generated by the Smart Home behavior, a PDP component could be instantiated to monitor exclusively this set of policies. Specific architecture design issues and policy distribution are out of the scope of this paper.</p><p>Using the events signaled by the PEP, the PDP evaluates the rule template configurations and rule instances. The current set of policies (rule templates and configurations) deployed in the PDP component is retrieved from a Policy Repository component when the activation of the rules is signaled by the Policy Server component. The Policy Management GUI component includes an interface for authoring and management of policy deployment integrated in the SecKit runtime GUI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Policy Rule Evaluation</head><p>Figure <ref type="figure" target="#fig_10">4</ref> shows the monitoring approach we adopt for the template configuration and enforcement rules evaluation. Rules are instantiated by a Rule Template Configuration at a particular moment in time, and an enforcement rule instance is created. Each rule is configured with a time step size, which indicates the granularity of the enforcement and events are observed for each time step window according to this granularity. Our PDP component is a rule</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>engine that keeps track of all time step granularities for the existing rule instances, observes the events, and evaluates the rules at the end of each time step window.  The PDP monitoring approach does not store all events observed, only the events in the current and previous time step windows are kept following an approach similar to Meredith et al. <ref type="bibr" target="#b24">[25]</ref>. It uses simple three-value boolean states for all operators, counters for the cardinality operators, and a circular buffer of n boolean states for the time bounded operators supported in our language like before(n, ϕ), which requires only the storage of the truth value of ϕ for the n previous time step windows.</p><p>It is known that it is non-trivial to generate efficient runtime monitors for parametrized specifications <ref type="bibr" target="#b24">[25]</ref>, which is the case of rule templates. Monitoring of parametrized templates is difficult to be realized because the number of parameter bindings can be very large, and there are only domain-specific solutions to handle this problem. In our approach we specify explicitly the instantiation and disposal of rule templates with variables to enable the efficient generation of monitors. By using the explicit instantiation of parametrized templates we avoid the overhead of monitoring all possible combinations of observed variable values, which may be practical for a small set of variable values, but it easily becomes intractable due to the large number of combinations <ref type="bibr" target="#b25">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Smart Home Case Study</head><p>In order to show the feasibility of our approach we show the application of the SecKit prototype to an IoT case study. We chose a smart home scenario in which many IoT devices may collaborate to control and automate functions like access control to main gate and rooms, lights and heating adjustment, perimeter surveillance, remote access to the devices and their content, etc. Figure <ref type="figure" target="#fig_11">5</ref> shows a diagram representing our case study behaviors, actions, and interactions.</p><p>In Figure <ref type="figure" target="#fig_11">5</ref>, the Home Owner Device behavior interacts through the Retrieve Temperature interaction with the Weather Station behavior contained in the Smart Home. The temperature value in this interaction is established by the Weather Station, and it is used internally by the Home Owner Device as an input for the Display temperature action. The interaction contributions (half circles) between contained behaviors are drawn over the border of the container behavior, which is a simplification to represent a delegated interaction of the  The diagram in Figure <ref type="figure" target="#fig_11">5</ref> also shows an interaction that enbles a Manufacturer System to update the firmware of the weather station, and a Maintenance Employee to unlock a Smart Lock by providing his/her identity information (e). Finally, the Medical Center interacts with the Heart Rate Sensor in order to retrieve the current heart rate of the Home Owner. We identified different types of data protection and trust requirements in this scenario. Some interactions are only allowed to take place for a specific amount of time or when a specific situation occurs, for example, during a health emergency.</p><formula xml:id="formula_12">M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>Concretely, in our case study we address a failure situation that requires both a physical repair and a software firmware update of a home IoT device. In this hypothetical situation we assume the home owner is on holidays in another country and he/she cannot directly intervene on the system. However, the manufacturer of the broken product offers him/her full assistance by on site repair through an outsourcing company and by remote update of the firmware of the repaired device.</p><p>Figure <ref type="figure" target="#fig_11">5</ref> shows the behavior model we have specified and implemented using the SecKit GUI based on the diagram shown in Figure <ref type="figure">6</ref>. This models represent the behaviors and entities of the iCore Framework including VOs, CVOs, Services, and their respective container entities. The behavior types are assigned to the entity types, for example, the IoT system behavior (see status bar in Figure <ref type="figure">6</ref>) is assigned to a CVO entity.</p><p>Considering this scenario, trust is required to allow physical access to the house (or part of the house) by the maintenance employee of the outsourcing company, and to allow the firmware update by the manufacturer company. As a consequence, the repair should be allowed only if both trust levels satisfy the requirements imposed by the owner. Indeed, the external company could have</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>Figure <ref type="figure">6</ref>: Behavior model specification a bad reputation in terms of trustworthiness of their technicians, who should not enter alone in the house, or a bad reputation to not complete the service as agreed. The device manufacturer, on the other hand, may have a bad reputation for quality of the firmware updates performed, which could (intentionally) embed malicious components able to endanger both physical and digital integrity of the smart home. All the operations can be logged and even recorded for auditing purposes by the home owner, but his/her intervention is necessary only in case of anomalies or exceptions to allow actions considered unsafe by the system.</p><p>Figure <ref type="figure" target="#fig_13">7</ref> illustrates the three trust management rule templates considered in our case study scenario. The first rule template allows the maintenance employee to unlock the door (i.e. tentative event) if the home owner trusts the company to complete the service as agreed, and if the consensus of trust recommendations received indicates a disbelief with respect to employee theft of home items for this company. We assume the company is the issuer of the employee identity, which is assigned to the variable employee-company with the expression \event\e\issuer. This rule illustrates an untrustworthy opinion that in fact has a positive interpretation: the employees of the companies are not trustworthy to steal items.</p><p>The second rule allows the firmware update if the consensus of the recommendations for the manufacturer in the interaction provide a secure firmware is at least trustworthy. The trust relationships defined in our model focus on the trustworthiness of an entity to participate in an interaction assuming a particular role. The third rule updates the trust relationship of the maintenance company if the home owner executes the Positive Service Feedback action, which  has the employee identity as a parameter, as illustrated in the behavior model in Figure <ref type="figure">6</ref>. The instantiation of variables referring to the trigger event of the rule templates uses XPath or Regular Expressions to assign values dynamically at rule evaluation time.</p><p>To illustrate the specification of a complex rule template we show another example from our case study in Figure <ref type="figure">8</ref>. In this example a composite rule template is specified to deny by default access when any entity tries to access the heart rate information of a specific home owner. However, access is allowed if within n timesteps (e.g., 3 hours) a In health emergency context situation involving the home owner is detected. Access is also allowed if the entity trying to access to the heart rate is a member of the Doctor role type. This example illustrates the nesting of enforcement template configurations in rule templates to maximize re-use and the selection of a conflict resolution strategy with the Allow overrides combining algorithm. amount assigning old experiences or recommendations a lower weight. An interesting application is also the implementation of alternative behaviors to require explicit consent to allow other people inside the house in addition to the trustbased decisions if home owner is on holidays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Performance Evaluation</head><p>We designed using the extended version of the iCore Framework integrated with our SecKit a model of a Smart City scenario, and used this model as input for the simulation of our Policy Decision Point (PDP) component. The PDP component is implemented as a rule engine that evaluates the rule configurations and instantiates templates. Figure <ref type="figure">9</ref> (left side) shows the sequence diagram describing the simulation we implemented to evaluate the performance and scalability of the PDP rule evaluation algorithm.</p><p>When the Demo Scenario starts, it creates all the design models using the SecKit libraries, instantiates a new PDP component, and subscribes to this PDP as an event provider PEP. After the initialization, the design models are deployed, and the PDP component instantiates the rule configurations specified in the rule model. The instantiation of the rule configurations triggers the subscription to events, which are notified by the Demo Scenario component to the PDP in order to generate event notifications.</p><p>In our simulation we deployed at the start 3000 sets of the example policy templates and configuration shown in Figure <ref type="figure">8</ref> with a time step granularity of 2 seconds for monitoring. The Demo Scenario generated every 2 seconds simulated events matching all event subscriptions, and we performed measurements of elapsed clock time for notification of all events resulting in an update of all deployed rule instances. In the enforcement template we used in our simulation we have a composite enforcement rule template with two nested rules, and a total of four event subscriptions. This gives a ratio of four event subscriptions for three rule instances, while the instantiation template specifies one event</p><formula xml:id="formula_13">M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</formula><p>subscription, and it is the only template configured at start. With this configuration, our simulation starts with 3000 instances of the instantiation template that is triggered at every time step and incrementally instantiates 3000 new enforcement rules. The newly instantiated enforcement rules at each time step increase incrementally the load of the PDP component.</p><p>Figure <ref type="figure">9</ref> (right side) shows the result graph of the clock time taken by the Demo Scenario to notify all events versus the number of event states needed to be updated for each event subscription in the PDP memory. For almost 250 thousand event states, the clock time to update all rule instances was around 700 milliseconds. The update time is very efficient because in our implementation we use hash map associations considering the subscribed events and the states in the rule instances that should be updated for each event subscription. Each notified event triggers a search in the hash table that contains the list of states to be checked for update. We run our simulation for 20 time steps and the total number of rule instances under the maximum load was around 156 thousand.</p><p>Our simulation does not consider performance issues in a distributed setting such as the encoding and decoding of events, network communication, and overhead for mutual authentication and session management. Our objective was the evaluation of the core policy rule evaluation and event matching functionalities of our PDP component when a significant number of rules are monitored. The complexity of the evaluation also depends on the structure of the enforcement rules, the number of variable instantiations using XPath expressions, and on the number of triggered rules in a time step that must be handled by the PDP. In our simulation all rules are triggered in all time steps, which is by far an overestimation but shows the PDP has a good performance to handle the triggering of rules.</p><p>The average memory usage in our simulation was 750MB for 3 runs. This amount includes the requirements of the SecKit design models and Demo Scenario simulation with the instantiation of all events and rules. The implementation of SecKit and the demo scenario was done in Java with (meta)models implemented using the Eclipse Modeling Framework (EMF). All simulations were executed in a CPU Intel Core i7-2600 3.4GHz with 8GB of physical memory running Windows 7 Professional. This powerful machine configuration may not seem realistic in an IoT scenario. However, in our current IoT architecture and implementation, the evaluation of policies is never done in the end devices, which act only as PEPs in our IoT architecture. The evaluation is done by the PDP component due to processing, memory, and battery constraints of this end devices and also to prevent a communication overhead, since the evaluation of policies may require external information (e.g., context) that would have to be distributed to all devices for policy evaluation.</p><p>In the second part of our evaluation we measured the performance of a PEP component implemented by us as a security plug-in of the Mosquitto open source MQTT broker <ref type="bibr" target="#b26">[27]</ref>. This evaluation considers the overhead of the PEP component independently of the delay introduced by the PDP to process the events, which depends on the number of event subscription and active policies. In this scenario two IoT boards were used as MQTT publishers an subscribers</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>exchanging GPS location information. The two boards are equipped with a 400 MHz ARM9 processor and 256 MB of RAM, running a Linux Debian operating system. The MQTT broker was deployed in a Raspberry Pi version 1 model B+ with a 700 MHz ARM11 processor and 512 MB of RAM, also running a Linux Debian operating system. All the boards were connect using WiFi and the communication with the PDP via a wired Ethernet connection.</p><p>In our performance evaluations we measured the delay in the exchange of MQTT messages with and without the PEP in order to measure the delay introduced with the policy enforcement. The average delay introduced in the exchange of 1200 messages was of 13 ms, increasing from 513 ms with the PEP disabled to 529 ms with the PEP enabled. These results are nearly the same considering our previous measurements <ref type="bibr" target="#b23">[24]</ref>, where a more powerful machine was used as MQTT broker and the average delays were of 515 ms and 525 ms with the PEP disabled and enabled respectively. In this average time of around 500 ms per event the PEP embedded in the MQTT broker signals two events to the PDP, one event when the message is published and one event when the message is delivered to the subscriber.</p><p>The PEP notifies the PDP with events when clients connect, subscribe/publish messages in the topics, and when clients disconnect. For tentative events where enforcement actions may take place, the PDP sends back to the PEP the encoded actions to allow, deny, modify, or delay the execution. The size of the events and of the enforcement action encoded using JSON is in the order of hundreds of bytes depending on the number of attributes of the message. For example, in the event where the client publishes the GPS location in the topic, the data published is also included in the event sent to the PDP and the event size is 225 bytes. The size of the PDP enforcement simply allowing the operation is of 63 bytes.</p><p>We also evaluated the case where the PEP component is not integrated in the MQTT broker but directly runs as a native program in the Raspberry Pi board itself. In this experiment we configured our PEP to send 100 event notifications in order to measure the amount of CPU taken to send the events and receive the answer from the PDP component. The total time taken was of around 800 ms of real time for all 100 events, with an average of 80 ms real time and 34 ms CPU time per event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>After having analyzed existing approaches for security and privacy in IoT platforms we have not found any holistic approach similar to the SecKit that considers in an integrated way identities, context, trust, and complex policy rules. Therefore, we present in this section existing approaches for trust management of IoT scenarios and for specification and enforcement of security policies in IoT and Body Area Networks (BAN) that are not as comprehensive as the SecKit.</p><p>Paul et al. <ref type="bibr" target="#b27">[28]</ref> provide a survey of architectures for the future networks and internet. The survey is quite extensive and describe a wide range of projects, architecture frameworks, and technical solutions from different sources. We</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>focus on the specific area of data protection and privacy, where their survey indicates that a correct representation and definition of the relationships in the systems is key to mitigate security threats and improve the robustness of the system. Relationships can be (at least) composed by the information of the identity of their members, their features, which translates to the roles in the relationship and the policies that can be applied to the relationships. Their survey paper does not describe in detail the technical solutions or approaches, which can be adopted to support the definition of the relationships. This paper proposes a toolkit that can be used to model these relationship and support the consistent specification and enforcement of authorization and obligation policies.</p><p>Traditional access control mechanisms like ABAC or RBAC are often not scalable for complex IoT scenarios considering the amount of data that is processed. Gusmeroli et al. <ref type="bibr" target="#b28">[29]</ref> acknowledge these limitations of ABAC and RBAC and describe a capability based access control system that users can use to manage their own access control processes to services and information. Their proposed mechanism supports rights delegation and the customization of the access control configuration without support for complex obligations with a rich policy language, which are supported by our toolkit.</p><p>Hernndez-Ramos et al. <ref type="bibr" target="#b29">[30]</ref> builds up on the capability-based approach and proposes a distributed version using capability tokens for CoAP Resources signed with the Elliptic Curve Digital Signature Algorithm (ECDSA) in order to ensure end-to-end authentication, integrity and non-repudiation. This solution allows IoT devices to take policy decisions without contacting a central Policy Decision Point (PDP) component, which is sufficient with policies that do not require external information. The authors also show a solution where a central PDP component is used to support context-based policies but no details are presented about the language and structure of these policies. Considering that revocation of tokens are needed in the capability-based solutions, in order to prevent unauthorized access the IoT devices always have to contact a revocation authority to verify if tokens are still valid. Furthermore, policies with complex context-based or trust-based conditions would require more processing power from IoT devices and queries to external information (e.g., context managers) in order to decide if the access should be allowed or not. A subset of our policy language with simple conditions and improved expressiveness could be used in capability tokens still with the benefit of allowing delays and modifications in addition to allow or deny access to an IoT device. An important result of this work is the performance analysis in very constrained devices with respect to the use of ECDSA.</p><p>In the context of Body Area Networks (BAN), Keoh et al. <ref type="bibr" target="#b30">[31]</ref> provide an implementation of a PDP component for the Ponder2 policy language in the TinyOS platform. From a policy language expressiveness point of view, Ponder2 supports ECA rules with simple propositional conditions without support for context-based, trust-based, temporal, and cardinality operators. The authors present performance results for policy evaluation in the order of 50 ms for simple policies with one event and a simple action without taking into consideration the distribution of components. Our performance results are not comparable</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>since our policy language is more expressive and we consider the distribution of PEPs and PDPs, without evaluation policies directly in the constrainted IoT devices.</p><p>The ETSI Technical Committee (TC) for Machine to Machine (M2M) proposes an architecture suitable as a horizontal platform for use by many M2M verticals (e.g., Smart Cars). Security aspects are also investigated, but are limited to message integrity, authentication, and/or signer authentication services <ref type="bibr" target="#b31">[32]</ref> <ref type="bibr" target="#b32">[33]</ref>. The toolkit proposed in this paper proposes concepts, which are very similar to what proposed by ETSI TC M2M, but our framework defines more sophisticated solutions for the specification and enforcement of the policies and the management of dynamic contexts that are complimentary to this standard.The M2M access control is relatively simple and it does not support changes in the context or complex policies.</p><p>The Open Mobile Alliance (OMA) envisions the communication, access and exchange of information over any network and through any user device, regardless of the service being used. In particular, the OMA Lightweight M2M (LWM2M) protocol is an approach for a new standard for remote management of M2M devices and application management based on the LWM2M Server and Client concepts. Regarding security aspects, the LWM2M technical specification document <ref type="bibr" target="#b33">[34]</ref> addresses access control issues, which are also supported by our toolkit. In addition, OMA has developed specifications to protect the digital content through a Digital Rights Management (DRM) approach described by Irwin <ref type="bibr" target="#b34">[35]</ref>. The OMA solution strongly relies on cryptography and policies, simply considering the authorization to share data over multiple devices without support for complex policy conditions and obligations.</p><p>The XACML policy language <ref type="bibr" target="#b22">[23]</ref> is a rule-based language with attribute assertion operators that supports authorization request and response messages. In contrast to XACML, our rule metamodel specified in the SecKit is eventbased, and allows specification of general purpose enforcement rules including authorizations and obligations using a common ECA format. XACML supports only propositional operators (e.g., and/or ) in their rule constructs and simple string/propositional obligations that must be fulfilled when the access is granted. The condition part of the rules supported by SecKit includes propositional, temporal, and cardinality operators. A simple policy stating that an account should be blocked after 3 failed logins or an obligation to delete VO 3 hours after emergency situation has finished can not be expressed with standard XACML. Our rule model also supports modification and delay enforcement behaviors in addition to allow and deny, and the re-use of rules and modular specification with rule templates. The integrated approach adopted by the SecKit also considers the precise relation of policy rules to the system design models in order to check policy consistency, and allows the identification of PEP locations considering the events of interest referenced in the policies.</p><p>The concept of trust as belief in a "correct" behavior of the system is related to the concept of reputation, which can be considered as the distributed measure of trust among different entities. Trust and reputation systems are then the starting point for all trust management models, including the ones in IoT. Trust</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M A N U S C R I P T A C C E P T E D ACCEPTED MANUSCRIPT</head><p>management mechanisms have been already adopted for P2P and grid systems, first with the basic goal of assigning and managing trust ratings <ref type="bibr" target="#b35">[36]</ref>, and then with more advanced features like reputation and risk evaluation as a prediction for short-term behavior <ref type="bibr" target="#b36">[37]</ref>. These kind of approaches have been the basis for one of the first formal trust management control mechanism in IoT <ref type="bibr" target="#b37">[38]</ref>, in which the IoT architecture is modeled in sensor, core and application layer. Each layer is controlled by a specialized trust management mechanism which delivers information for decisions made by a service requester also according to policy rules. Our trust model is not limited to three architectural layers and has a more precise and expressive approach for modeling of trust relationships and security policy rules.</p><p>Bao and Chen present in <ref type="bibr" target="#b38">[39]</ref> a trust management protocol for IoT with the emphasis on social relationships. Considering some trust properties, trust evaluation is performed by objects on a limited set of both direct and indirect observations. The result is a trade-off between trust assessment accuracy and trust convergence time, compared to the performances obtained using a global knowledge. In a similar way, the same authors in <ref type="bibr" target="#b39">[40]</ref>, show scalability and adaptiveness of a trust management protocol in case of limited storage space, i.e. where the objects keep trust information only about a subset of other objects meeting their interest, allowing to perform minimum computation to update trust. Also in this case, they show how performances are comparable to the ones obtained using unlimited storage capacity. The focus of these approaches are on computation and convergence of trust measurements without considering the semantics of the trust values, which are clearly defined in our trust model.</p><p>Other approaches to trust management, initially developed for semantic web <ref type="bibr" target="#b40">[41]</ref>, express trust and reputation information using ontologies, with an association between trust values and algorithms (trust metrics) to make trust decisions. Nevertheless ontologies in IoT have been proposed to face more general challenges, like heterogeneity and scalability of the devices <ref type="bibr" target="#b41">[42]</ref>. Our system and trust metamodels can be used as a reference ontology, filling the gap for the specific challenge of trust in IoT.</p><p>More general purpose trust management approaches <ref type="bibr" target="#b42">[43]</ref> model trust without considering the model of the system (e.g., activities, data, and identities), and as a consequence, it is unclear how trust relationships should be associated with IoT devices considering their interactions and different trust aspects. The combination of trust relationships using rules presented in this paper is a generic model of the work on trust assessment in context-aware service platforms done by Neisse et al. <ref type="bibr" target="#b8">[9]</ref>. To the best of our knowledge we are the first to propose a trust model that is associated to a reference system model and is integrated with a security policy language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions and Future Work</head><p>In this paper we presented a Model-based Security Toolkit (SecKit) integrated in the framework proposed by the iCore Project that enables usage control and protection of user data. We show the application of the SecKit in a M A N U S C R I P T</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A C C E P T E D ACCEPTED MANUSCRIPT</head><p>Smart City scenario to evaluate its feasibility and performance. Our case study demonstrates the flexibility and efficiency of SecKit to support the specification and evaluation of security policies specified using rule templates. We have released the SecKit as an open source project and our goal is to enable community driven specification of policy templates and implementation of technology specific add-ons focusing on enforcement components for different IoT target technologies and application domains. The adoption of SecKit by many stakeholders has the potential to enable and improve cross-domain security alignment and interoperability.</p><p>The trust model we proposed allows the specification of different types of trust relationships and aspects to govern the trust relationships in the IoT interactions. This model considers the reference system model for definition of trust aspects and it supports the design of expressive trust-based security policy rules. The feasibility of our model and the specification of trust management rule templates is also shown in our case study and prototype implementation.</p><p>Considering the positive evaluation results of our implementation in Java we intend to implement a native binary version (e.g., in C/C++) to target resource constrained devices including mobile phones and low-power/cost platforms such as the PandaBoard or Raspberry PI platforms that could act as PDP nodes in addition to PEP nodes as described in this paper. An interesting outcome would be an IoT domain security management node capable of evaluating security policies and managing smart home identities in an efficient and secure way, including support for context reasoning, trust relationships, and complex security rules.</p><p>As future work we plan to work towards the integration of trust and risk models following up in the approach introduced by some of the co-authors in <ref type="bibr" target="#b1">[2]</ref>. Furthermore, we plan to investigate more advanced distributed trust reasoning approaches and fusion operators using input from Collaborative Filtering research considering similarity and partial obfuscation of the trustors' identities and profiles. Finally, an important aspect is the analysis of static and dynamic information flow considering the causality relations specified in the behavior models and runtime events. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: iCore Framework overall architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>AttributeName, DataInstName, DataId, DataValue] ArrayFlag :== isSingle | isArray EmfType :== byte | short | int | long | float | double | char | boolean | string PrimitiveType == DataTypeName × EmfType Attribute == (AttributeName → DataTypeName) × ArrayFlag CompositeType == DataTypeName × P Attribute getSuperTypeOf : CompositeType → P CompositeType DataTypePackage</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>matchesData:</head><label></label><figDesc>DataPattern ↔ Data ∀ d : Data; p : DataPattern • d matchesData p ⇔ (p.1 matchesDataType d.1) ∧ (p.2 matchesDataInst d.2) ∧ (p.3 matchesDataValue d)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>[</head><label></label><figDesc>ArbitraryTrust, IndirectTrust, EvidenceDescription] LikelihoodMeasurement :== VeryUntrustworthy | Untrustworthy | Uncertain | Trustworthy | VeryTrustworthy DirectTrustType :== ArbitraryTrust | ExperienceTrust IndirectTrustType :== CombinedTrust | RecommendationTrust TrustType = DirectTrustType ∪ IndirectTrustType TrustRelationship = TrustType × Identity × TrusteeScope × TrustAspect ×LikelihoodMeasurement × Timestamp Evidence :== positive EvidenceDescription | negative EvidenceDescription ExperienceTrust : P Evidence → TrustRelationship TrustRecommendation == Identity × TrustRelationship Trustor ⊆ Identity LikelihoodMeasurement ⊆ SubjectiveOpinion Our model supports the specification and reasoning about different types of trust relationships (TrustType) and recommendations (TrustRecommendation).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>TrustRelationshipPattern 3 ∧</head><label>3</label><figDesc>== TrustType × IdentityPattern × TrusteeScope ×TrustAspect × LikelihoodMeasurement TrustRecommendationPattern == IdentityPattern × TrustRelationshipPattern matchesTrust : TrustRelationshipPattern ↔ TrustRelationship ∀ tp : TrustRelationshipPattern; tr : TrustRelationship • tp matchesTrust tr ⇔ tr .1 = tp.1 ∧ tr .2 matchesIdentity tp.2 ∧ tr .3 = tp.tr .4 = tp.4 ∧ tr .5 exactly tp.5 matchesRecommendation : TrustRecommendationPattern ↔ TrustRecommendation ∀ tp : TrustRecommendationPattern; tr : TrustRecommendation • tp matchesRecommendation tr ⇔ tp.1 matchesIdentity tr .1 ∧ tp.2 matchesTrust tr .2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>TrustQuery :== TrustRelationshipPattern | Consensus TrustRecommendationPattern TrustAssessment :== AtLeast LikelihoodMeasurement × TrustQuery | atMost LikelihoodMeasurement × TrustQuery | Exactly LikelihoodMeasurement × TrustQuery evalTrust : TrustAssessment ↔ (LikelihoodMeasurement × TrustQuery) ∀ ta : TrustAssessment; lm1 : LikelihoodMeasurement; tq : TrustQuery • tq evalTrust (lm, tq) ⇔ ∃ lm2 : LikelihoodMeasurement • tq query lm2 ∧ ((op = exactly ∧ (TrustDegree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>EventIndex</head><label></label><figDesc>== {start, ongoing, finished} EventModality == {tentative, actual} Event :== TimestepEvent | InteractionEvent EventIndex × EventModality × P InteractionContribution ×Interaction × Behavior × Entity TimeStepWindow = P Events EventTrace = N → TimeStepWindow</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>|=pattern : EventPattern ↔ Event ∀ e : Event; p : EventPattern • e |=pattern p ⇔ e = TimestepEvent ∧ p = TimestepEventPattern ∨ e = InteractionEvent ∧ p = InteractionEventPattern ∧ p |= interaction e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>AuthorizationResponse == Allow , Deny Modify == DataInst → NewValue Delay == TimeAmount × TimeUnit Enforcement == AuthorizationResponse × P Modify × Delay RuleTemplate ::= P VarDecl × EventPattern × Φ× Enforcement × P TrustUpdate × P BehaviorInst CombiningAlgorithm ::= FirstApplicable | AllowOverrides | DenyOverrides TemplateConfiguration ::= MonolithicConfiguration P(VarAssign × RuleTemplate × RuleTemplate) | RecursiveConfiguration CombiningAlgorithm × seqTemplateConfiguration RulePackage == P RuleTemplate × P TemplateConfiguration ∀ e : Event; ep1, ep2 : EventPattern • rulenestedrule ⇔ (ep1 matches e) ∧ (ep2 matches e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Usage control enforcement architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Enforcement rule monitoring approach</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Case study behavior model: (c)vos and interactions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Trust-based authorization and update rule templates</figDesc><graphic coords="25,176.73,124.80,257.80,147.77" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: Role and Context-based rule templates</figDesc><graphic coords="25,168.14,492.74,274.97,107.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Support for the Digital Divide: Users have different knowledge and capabilities in accessing IoT devices and applications. Depending on their level of technical proficiency, users have different level of perceptions of the privacy risks and knowledge of the technical solutions to address them. The design of security and privacy solutions should address the digital divide of the different categories of users; 4. Control of the data flow from IoT Device: The user should be able to define the type and amount of data, which is transmitted out of the IoT device. For usability, the control on the flow of data should be automatic</figDesc><table /><note><p>1. Support for Dynamic Context: Design for Security and Privacy in IoT should include support for Dynamic Context to ensure that the security and privacy requirements are satisfied when there are changes in the context (e.g., home vs office), where the IoT devices must operate; 2. Support for Trust Management: Security policy rules in IoT scenarios should consider trust relationships established by users with IoT devices and operators. In order to be meaningful, the precise scope and semantics of the trust relationship should be explicitly defined, specifying what the entity should be trusted for (e.g., privacy protection and identity provisioning); 3.</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgment. This work was supported by the EU-funded project Internet Connected Objects for Reconfigurable Ecosystem (iCore).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Visions and challenges for realising the internet of things, cluster of European Research Projects on the Internet-of-Things</title>
		<author>
			<persName><forename type="first">H</forename><surname>Sundmaeker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guillemin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Friess</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Woelffl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>CERP-IoT</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Building trust in the human-internet of things relationship, Technology and Society Magazine</title>
		<author>
			<persName><forename type="first">I</forename><surname>Kounelis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Baldini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tallacchini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Guimaraes</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="73" to="80" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">N</forename><surname>Fovino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Baldini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Stavroulaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vlacheas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Giaffreda</surname></persName>
		</author>
		<title level="m">A model-based security toolkit for the internet of things, The 9th International Conference on Availability, Reliability and Security</title>
		<imprint>
			<publisher>ARES</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A trustworthy usage control enforcement framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pretschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 6th International Conference on Availability, Reliability and Security</title>
		<meeting>6th International Conference on Availability, Reliability and Security</meeting>
		<imprint>
			<publisher>ARES</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A trustworthy usage control enforcement framework</title>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pretschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Mobile Computing and Multimedia Communications</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Model-based specification and refinement of usage control policies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doerr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International Conf. on Privacy, Security and Trust</title>
		<imprint>
			<biblScope unit="page">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Implementing trust in cloud infrastructures, 11th IEEE</title>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Holling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pretschner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Symposium on Cluster, Cloud and Grid Computing</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wegdam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Sinderen</surname></persName>
		</author>
		<title level="m">An information model and architecture for context-aware management domains, in: 9th IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="162" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Trust management support for context-aware service platforms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wegdam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Sinderen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Social Networks</title>
		<imprint>
			<biblScope unit="page" from="75" to="106" />
			<date type="published" when="2014">2014</date>
			<publisher>Springer International</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Schafrik</surname></persName>
		</author>
		<ptr target="http://www.ibm.com/developerworks/rational/library/enterprise-architecture-maximum-value/" />
		<title level="m">A practical guide to developing enterprise architecture</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Internet connected objects for reconfigurable ecosystems</title>
		<ptr target="http://www.iot-icore.eu" />
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="https://www.eclipse.org/modeling/emf" />
		<title level="m">Eclipse modeling framework project</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">A modeldriven approach to situations: Situation modeling and rule-based situation detection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">T</forename><surname>Mielke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P A</forename><surname>Almeida</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="154" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Action relations -basic design concepts for behaviour modelling and refinement</title>
		<author>
			<persName><forename type="first">D</forename><surname>Quartel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
		<respStmt>
			<orgName>University of Twente</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A conceptual framework for service modelling and refinement</title>
		<author>
			<persName><forename type="first">D</forename><surname>Quartel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pokraev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sinderen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cosmo</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems Frontiers</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="225" to="244" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A survey of trust in internet application</title>
		<author>
			<persName><forename type="first">T</forename><surname>Grandison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sloman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Trust meta-policies for flexible and dynamic policy based trust management</title>
		<author>
			<persName><forename type="first">K</forename><surname>Quinn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>O'sullivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Wade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Seventh IEEE Int. Workshop on Policies for Distributed Systems and Networks (POLICY)</title>
		<meeting>of the Seventh IEEE Int. Workshop on Policies for Distributed Systems and Networks (POLICY)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An integrative model of organizational trust</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">F</forename><surname>Schoorman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">the Academy of Management Review</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="709" to="734" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Evidential reasoning with subjective logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jøsang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th International Conference on Information Fusion</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The meanings of trust</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Mcknight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">L</forename><surname>Chervany</surname></persName>
		</author>
		<ptr target="http://misrc.umn.edu/wpaper/WorkingPapers/9604.pdf" />
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Pope</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hird</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Davey</surname></persName>
		</author>
		<ptr target="http://folk.uio.no/josang/sl/Op.html" />
		<title level="m">Subjective logic java applet and api</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A policy language for distributed usage control</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hilty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pretschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Walter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Security ESORICS 2007</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4734</biblScope>
			<biblScope unit="page" from="531" to="546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">E</forename><surname>Rissanen</surname></persName>
		</author>
		<ptr target="http://docs.oasis-open.org" />
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Neisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Steri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Baldini</surname></persName>
		</author>
		<title level="m">Enforcement of security policy rules for the internet of things, 3rd International Workshop on Internet of Things Communications and Technologies (IoT-CT)</title>
		<imprint/>
	</monogr>
	<note>in conjunction with The 10th IEEE WiMob</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An overview of the mop runtime verification framework</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">O</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Griffith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rosu</surname></persName>
		</author>
		<ptr target="http://fsl.cs.uiuc.edu" />
	</analytic>
	<monogr>
		<title level="j">Int. J. Softw. Tools for Technol. Transf</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Making runtime monitoring of parametric properties practical</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012-08">August 2012</date>
		</imprint>
		<respStmt>
			<orgName>University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">An open source mqtt v3.1/v3.1.1 broker</title>
		<author>
			<persName><surname>Mosquitto</surname></persName>
		</author>
		<ptr target="http://mosquitto.org" />
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Architectures for the future networks and the next generation internet: A survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jain</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.comcom.2010.08.001</idno>
		<ptr target="http://dx.doi.org/10.1016/j.comcom.2010.08.001" />
	</analytic>
	<monogr>
		<title level="j">Computer Communications</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2" to="42" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A capability-based security approach to manage access control in the internet of things</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gusmeroli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Piccione</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rotondi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical and Computer Modelling</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1189" to="1205" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Distributed capability-based access control for the internet of things</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Hernandez-Ramos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Jara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Marn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Skarmeta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Internet Services and Information Security (JISIS)</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3/4</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Policy-based management for body-sensor networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Keoh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International Workshop on Wearable and Implantable Body Sensor Networks (BSN 2007)</title>
		<imprint>
			<publisher>Springer Berlin Heidelberg</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Machine-to-machine communications (m2m): Functional architecture (ts 102 690</title>
		<author>
			<persName><surname>Etsi</surname></persName>
		</author>
		<ptr target="http://www.etsi.org" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Machine-to-machine communications (m2m); mia, dia and mid interfaces</title>
		<author>
			<persName><surname>Etsi</surname></persName>
		</author>
		<ptr target="hhttp://www.etsi.org" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>ts 102 921), Available at</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Lightweight machine to machine technical specification oma ts lightweightm2m id 20130717</title>
		<author>
			<persName><surname>Oma</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>draft version 1.0, OMA</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Digital rights management: The open mobile alliance {DRM} specifications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Irwin</surname></persName>
		</author>
		<idno type="DOI">10.1016/S1363-4127(05)70037-6</idno>
		<ptr target="http://dx.doi.org/10.1016/S1363-4127(05)70037-6" />
	</analytic>
	<monogr>
		<title level="j">Information Security Technical Report</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="22" to="31" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Trustme: anonymous management of trust relationships in decentralized p2p systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<idno type="DOI">10.1109/PTP.2003.1231514</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Int. Conf. on Peer-to-Peer Computing</title>
		<meeting>Third Int. Conf. on Peer-to-Peer Computing</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="142" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Pet: A personalized trust model with reputation and risk evaluation for p2p resource sharing</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shi</surname></persName>
		</author>
		<idno type="DOI">10.1109/HICSS.2005.493</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 38th Annual Hawaii Int. Conf. on System Sciences (HICSS)</title>
		<meeting>of the 38th Annual Hawaii Int. Conf. on System Sciences (HICSS)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Trust management mechanism for internet of things</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lize</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jingpei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bin</surname></persName>
		</author>
		<idno type="DOI">10.1109/CC.2014.6821746</idno>
	</analytic>
	<monogr>
		<title level="j">Communications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="148" to="156" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>China</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Trust management for the internet of things and its application to service composition</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-R</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1109/WoWMoM.2012.6263792</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Int. Symp. on a World of Wireless, Mobile and Multimedia Networks (WoWMoM)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Scalable, adaptive and survivable trust management for community of interest based internet of things systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Eleventh Int. Symp. on Autonomous Decentralized Systems (ISADS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Inferring reputation on the semantic web</title>
		<author>
			<persName><forename type="first">J</forename><surname>Golbeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International World Wide Web Conference</title>
		<meeting>the 13th International World Wide Web Conference</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Ontologies for the internet of things</title>
		<author>
			<persName><forename type="first">S</forename><surname>Hachem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Issarny</surname></persName>
		</author>
		<idno type="DOI">10.1145/2093190.2093193</idno>
		<ptr target="http://doi.acm.org/10.1145/2093190.2093193" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Middleware Doctoral Symposium, MDS &apos;11, ACM</title>
		<meeting>the 8th Middleware Doctoral Symposium, MDS &apos;11, ACM<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>3:1-3:6</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">An adaptable distributed trust management framework for large-scale secure service-based systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Buduru</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00607-013-0354-9</idno>
		<ptr target="http://dx.doi.org/10.1007/s00607-013-0354-9" />
	</analytic>
	<monogr>
		<title level="j">Computing</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="925" to="949" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
