<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Identication of Robust Dependent Path Delay Faults</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">U</forename><surname>Sparmann</surname></persName>
						</author>
						<author>
							<persName><forename type="first">D</forename><surname>Luxenburger</surname></persName>
						</author>
						<author>
							<persName><forename type="first">K.-T</forename><surname>Cheng</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of ECE</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>93106</postCode>
									<settlement>Santa Barbara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of ECE</orgName>
								<orgName type="institution">University o f I o w a</orgName>
								<address>
									<postCode>52242</postCode>
									<settlement>Iowa City</settlement>
									<region>IA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Dept</orgName>
								<orgName type="institution">University of Saarland</orgName>
								<address>
									<postCode>D 66041</postCode>
									<settlement>Saarbr ucken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fast Identication of Robust Dependent Path Delay Faults</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8578A67A065DCBB1F455D4CE58EC74E3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T02:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>| Recently, it has been shown in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b1">[2]</ref> that in order to verify the correct timing of a manufactured circuit not all of its paths need to be considered for delay testing. In this paper, a theory is developed which puts the work of these papers into a common framework, thus allowing for a better understanding of their relation. In addition, we consider the computational problem of identifying large sets of such not-necessary-to-test paths. Since the approach of [1] can only be applied for small scale circuits, we develop a new algorithm which trades quality o f the result against computation time, and allows handling of large circuits with tens of millions of paths. Experimental results show that enormous improvements in running time are only paid for by a small decrease in quality.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>The purpose of delay testing is to ascertain that a manufactured digital circuit meets its timing specications. Two fault models have been proposed in this context, namely gate delay <ref type="bibr" target="#b2">[3]</ref> and path delay faults <ref type="bibr" target="#b3">[4]</ref>. In this paper we will focus on path delay faults, which are more powerful since they also model distributed defects. Test generation and fault simulation methods with respect to this fault model have been studied considerably in the literature. (See for example <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>.)</p><p>A major problem in path delay fault testing is that the number of paths in a circuit is often extremely large. Thus, the question of whether all of these paths must be tested in order to verify the temporal correctness of a manufactured circuit is of great interest. Two important results with respect to this question have been reported recently. In <ref type="bibr" target="#b0">[1]</ref> ( <ref type="bibr" target="#b1">[2]</ref>) the class of robust dependent (functionally unsensitizable) paths has been introduced, and it has been shown that these paths need not be considered for the purpose of delay testing.</p><p>The contribution of this paper with respect to the above work is twofold. First, a theory is developed that enables us to put the results of <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b1">[2]</ref> into a common framework, and thus, helps for a better understanding of their relation. Our approach is based on the idea of choosing for each input vector v to circuit C a `stabilizing system', i.e. a subcircuit Sv of C which can stabilize the primary outputs of C on their This work has been supported by D F G, SFB 124-\VLSI Entwurfsmethoden und Parallelit at" and Grant No. Sp431/1-1. nal (stable) values under v independent of the circuitry of C not included in Sv. For a complete delay test of C, it can be shown that it is sucient t o only check the logical paths included in these stabilizing systems robustly. The remaining paths which need not be tested form a robust dependent path set (RD-set) as computed by the approach of <ref type="bibr" target="#b0">[1]</ref>. They include the functionally unsensitizable paths of <ref type="bibr" target="#b1">[2]</ref> as a subset.</p><p>Usually, there is a huge number of dierent possibilities for choosing the stabilizing system Sv for a given input v. Thus, we arrive at the optimization problem of selecting Sv for every input v such that the overall set of logical paths which need to be tested is minimized (the corresponding RD-set is maximized). The second major contribution of this paper is motivated by the fact that the procedure of <ref type="bibr" target="#b0">[1]</ref> for identifying a near maximum RD-set is very time and space consuming, and thus, can only be applied for small scale circuits. (As an example, for circuit c499 of the ISCAS85 benchmarks <ref type="bibr" target="#b12">[13]</ref> this algorithm was not able to complete in a running time of 69 hours on a SUN SPARC 1 0 w orkstation.) We will show that the approach of <ref type="bibr" target="#b1">[2]</ref> can be generalized leading to a much faster algorithm for identifying large RD-sets. (For circuit c499 our new algorithm runs less than 4 minutes, which corresponds to a speed-up factor of over 1000 compared to the method of <ref type="bibr" target="#b0">[1]</ref>.) This speed-up is achieved by considering only a restricted search space for selection of the RD-set, and applying an approximation method for computing the elements of this set. As a consequence, the savings in computation time are paid by a decrease in quality of the result, i.e. size of the identied RD-set. Experimental results show that this loss in quality i s only small.</p><p>The paper is organized as follows: In Section II some basic denitions concerning delay testing are reviewed. The theoretical framework allowing for an easy comparison of the results presented in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b1">[2]</ref> is developed in Section III. Section IV shows how to generalize the methodology of <ref type="bibr" target="#b1">[2]</ref> for fast RDset identication. Heuristics for improving the quality of this approach are discussed in Section V. Section VI gives experimental results and compares them to the approach of <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Basic Definitions</head><p>We will restrict to single output combinational circuits in the following. For multi output circuits the theory is applied for each output cone separately. In our model a combinational circuit C consists of leads and gates. As gate types we will consider simple gates (And, Or, Nand, Nor, and Not), as well as primary inputs (Pis) and primary outputs (Pos). A lead is a wire connecting two gate pins with each other.</p><p>A physical path P = ( g 0 ; l 0 ; g 1 ; : : : ; l m 1 ; g m ) i n C is an alternating sequence of gates and leads (lead li connects the output pin of gate gi to some input pin of gate gi+1) leading from a Pi g0 to a Po gm of C. The primary input g0 of P is denoted by PI(P ). As usual in delay fault test generation we will associate two logical paths with each p h ysical path. A logical path is given as a tuple (P;t) with t = x! x; x 2 B = f0; 1g, being a transition at the primary input PI(P ).</p><p>A manufactured implementation of circuit C is denoted by Cm. We assume that Cm has the gate level structure of C, but the delays of its gates and lines may take arbitrary values due to variations of the fabrication process or manufacturing defects. Let be the required operation time (clock period) for Cm. Cm is said to have a delay fault &gt; on logical path (P;t) i its delay for propagating t over P exceeds . A robust test for (P;t) <ref type="bibr" target="#b13">[14]</ref> is a two pattern sequence which can be used to measure the delay of (P;t) in any implementation Cm of C. From the fact that Cm does (does not) operate correctly for this test sequence under clock period it can be concluded that the delay o f C m for propagating t over P is (&gt; ).</p><p>In <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref> it has been shown that in order to guarantee that the delay of a manufactured circuit meets its specication not all logical paths need to be checked robustly. Denition 1 ( <ref type="bibr" target="#b0">[1]</ref>) Let LP (C) be the set of all logical paths in a circuit C and R a subset of LP (C).</p><p>R is said to be a robust dependent set (RD-set) if and only if for all implementations Cm of C and all clock periods the following holds: The absence of delay faults &gt; on the logical paths from LP (C) n R implies the delay of Cm is .</p><p>From Denition 1 and the above stated property of robust tests it follows directly: For verifying that the delay o f C m does not exceed the clock period it is sucient t o c heck all non-RD paths (LP(C) n R ) with robust tests. (The notion `robust dependent' has been introduced in <ref type="bibr" target="#b0">[1]</ref> to emphasize the fact that the paths from R need not be checked if all paths from LP (C) n R are tested robustly.)</p><p>In <ref type="bibr" target="#b0">[1]</ref> the authors reduce the problem of identifying a (maximum) RD-set R to the problem of nding (maximum) redundant m ultiple stuck-at-0 (stuck-at-1) faults in the leaf-dag of C. Since the leaf-dag is the `unfolded' version of C with fanout only allowed at the Pis, its size is exponential in the size of C for circuits with large amount o f i n ternal fan-out.</p><p>To cope with this problem, a heuristic is developed in <ref type="bibr" target="#b0">[1]</ref> which gradually unfolds the circuit, searches for redundant single stuck-at faults, and removes them to reduce the size of the unfolded circuit. But even this heuristic algorithm has very large running times and may result in a circuit of exponential size. Thus, it can only be applied for small scale circuits.</p><p>The purpose of this paper is to develop an algorithm for the computation of large RD-sets which is based on <ref type="bibr" target="#b1">[2]</ref>, and does not rely on unfolding the circuit. As will be seen, this approach i s m uch faster than the heuristic of <ref type="bibr" target="#b0">[1]</ref>. In order to develop our new algorithm for RD-set identication, we rst have t o i n troduce the notions of stabilizing system and complete stabilizing assignment. These notions will also be helpful for a better understanding of the results in <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref> and their relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. Stabilizing Systems</head><p>Consider a circuit C realizing function f. For a given input vector v 2 B n we ask for a subcircuit S of C which can stabilize the Po on its nal (stable) value f(v) independent o f the circuitry of C not included in S. Such a subcircuit will be called a stabilizing system of C for input v. (Note, that a stabilizing system normally only constitutes a small portion of the overall circuit. For example to stabilize the output of an Or gate to logic 1 it is sucient to stabilize one of its inputs to 1.) There can exist many dierent stabilizing systems for v. Such a system can be computed as follows:</p><p>Algorithm 1 / computes stabilizing system S for v 2 B n / Include the Po of C and the lead connecting to it in S. While there exists a gate g of C which is not included in S and drives a lead already belonging to S:</p><p>(1) If g is a Not gate:</p><p>Include g and its input lead in S. (2) If g is a And, Or, Nand, Nor gate:</p><p>(a) If the stable (nal) input values of g under v are all non-controlling 1 , then include g and all of its input leads in S. (b) If a set L = fl1 ; : : : ; l k g , k 1, of the input leads of g has controlling stable values under v, then include g and an arbitrary lead from L in S. (3) If g is a Pi: Include g in S.</p><p>2</p><p>Denition 2 A stabilizing system S of circuit C for input v is a subcircuit of C computed b y A lgorithm 1.</p><p>The set of logical paths of stabilizing system S for input v is given by: LP (v;S) : = f ( P;x!x)j(P path from Pi to Po in S)</p><p>and (x value of PI(P ) under v)g Note, that a stabilizing system S computed by Algorithm 1 is minimum in the following sense: If any lead is removed from S then the property of stabilizing the output of C independent of the values on leads not included in S is not guaranteed any more. This is due to the fact that only one input of set L is picked in Step 2(b) of Algorithm 1.</p><p>Usually, there are many possible stabilizing systems for v depending on which input of set L is selected in Step 2(b). This fact is illustrated by the following example.</p><p>Example 1 Figure <ref type="figure" target="#fig_0">1</ref> shows three possible stabilizing systems (indicated by the lines drawn in bold) for input v = 111 in an example circuit taken from <ref type="bibr" target="#b0">[1]</ref>. Denition 3 A complete stabilizing assignment is a mapping which assigns to each input vector v 2 B n a stabilizing system for v, denoted b y ( v ) .</p><p>1 The non-controlling value for an And, Nand (Or, Nor) gate is 1 (0). The controlling value is the complement of the non-controlling one. The set of all logical paths corresponding to the stabilizing systems selected b y is given by:</p><formula xml:id="formula_0">LP () : = [ v 2 B n LP (v;(v))</formula><p>From Example 1 it becomes clear that there is usually a huge number of possible complete stabilizing assignments for a given circuit, depending on which stabilizing system is selected for each input vector.</p><p>The following theorem shows that it is sucient to only test the logical paths from LP () robustly. Proof:</p><p>It follows directly from Denition 1 that any subset of an RDset is again an RD-set. Thus, it suces to show that RD() is an RD-set, i.e. we m ust prove that for all implementations Cm of C and all clock periods it holds that: The absence of delay faults &gt; on the logical paths from LP () implies the delay o f C m is . Let v be an arbitrary input vector to Cm. Consider the stabilizing system (v) which is assigned to v by . From the denition of stabilizing system it directly follows that it is sucient to switch the lines included in (v) in order to stabilize the output of Cm on f(v) for input vector v. The delay for switching (v) i s bounded by the maximum of the delays of all logical paths in LP (v;(v)). Since by assumption the delay of all these logical paths is in Cm, it follows that the output of Cm stabilizes in time for input v.</p><p>Example 2 Figure <ref type="figure" target="#fig_1">2</ref> gives a possible choice o f for the circuit of Example 1. The circuit leads belonging to a stabilizing system are d r awn in bold. The two leftmost stabilizing systems are assigned t o m o r e than one input combination, i.e. all input combinations which set the leftmost Pi to 1 (resp. the leftmost Pi to 0 and the rightmost Pi to 1).</p><p>From Theorem 1 it follows that it is not necessary to test all 8 logical paths of the example circuit. Instead it is sucient to only test the 6 logical paths from LP () robustly in order to verify the temporal correctness of the circuit. (Note, that the logical path indicated by the dashed line in the rightmost stabilizing system is the only element from LP () which can not be tested r obustly.) Before considering how to compute a complete stabilizing assignment and its associated RD-set RD(), let us rst compare the above theory with the results of <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b0">[1]</ref>.</p><p>In <ref type="bibr" target="#b1">[2]</ref> the notion of functionally sensitizable paths has been introduced. It has been shown, that functionally unsensitizable paths are redundant, and need not be considered for delay testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Denition 4 ([2]</head><p>) A l o gical path (P;x!x)is called functionally sensitizable. ( ) There exists an input vector v such that: (FU1) v sets PI(P ) to x, and (FU2) for each gate g on P with its on-path input having a non-controlling stable value under v, all the side-inputs of g have non-controlling stable values for v. It is interesting to compare the above dention to the criterion for non-robust testability given in <ref type="bibr" target="#b5">[6]</ref>. <ref type="bibr">Denition 5 ([6]</ref>) A logical path (P;x!x) is non-robustly testable. ( ) There exists an input vector v such that: (NR1) v sets PI(P ) to x, and (NR2) for each gate g on P all the side-inputs of g have noncontrolling stable values for v.</p><p>Remark 1 For the original criterion of <ref type="bibr" target="#b5">[6]</ref> the existence o f a two pattern sequence &lt; v 1 ; v 2 &gt; is claimed. v1 sets the primary input of P to x and v2 fullls the conditions (NR1) and (NR2) given above. Since the existence o f v 1 is always guaranteed for a circuit without input space restrictions, this condition has been omitted here and we only claim the existence o f v = v 2 .</p><p>Denition 6 Let C be a c ombinational circuit.</p><p>(a) The set of logical paths from LP (C) which are functionally sensitizable is denoted b y F S ( C ) . (b) The set of logical paths from LP (C) which are non-robustly testable is denoted b y T ( C ) . Since the conditions for non-robust testability are more restrictive than those for functional sensitizability, it follows that T (C) F S ( C ). The following lemma classies the logical path sets selected by choosing a complete stabilizing assignment with respect to this hierarchy. Let (P;x!x) be a non-robustly testable logical path in circuit C. By Denition 5 there exists an input vector v for C fullling conditions (NR1) and (NR2). We will show that P is included in any stabilizing system S for v computed by Algorithm 1. The proof is done inductively: Clearly, the Po of P is included in S. Let g be the next gate of P , and l its on-path input. If g is a Not then g and l will be included in S. If g 2 fAnd; Or; Nand; Norg two cases must distinguished: If the stable value of l under v is non-controlling, then by condition (NR2) all side-inputs of l have non-controlling stable values too, and thus, in Step 2(a) of Algorithm 1 all input leads of g will be included in S. If the stable value of l under v is controlling, it follows from condition (NR2) that l is the only element of set L in Step 2(b) of Algorithm 1, and thus, will be selected for S.</p><p>LP () F S ( C ): Consider an arbitrary logical path (P;x!x) 2 LP (v;(v)). We will show that (P;x!x) is functionally sensitized by v. From the denition of LP (v;(v)) it follows that v sets PI(P ) to x, i.e. condition (FU1) is fullled. For a gate g, Algorithm 1 only includes an input lead of g with non-controlling stable value in (v), if all other input leads of g have non-controlling stable values under v (see Step 2(a)). Thus, all paths from (v) also fulll condition (FU2) from the denition of functional sensitizability for input v.</p><p>Thus, by c hoosing a complete stabilizing assignment we are selecting a subset LP () of the functionally sensitizable logical paths F S ( C )which includes all robustly and nonrobustly testable logical paths T (C). The corresponding situation is illustrated in Figure <ref type="figure">3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LP (C)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FS(C) T (C) LP σ ( )</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 3. Hierarchy of logical path sets</head><p>Comparing Theorem 1 to the methodology developed in <ref type="bibr" target="#b0">[1]</ref> for identifying RD-sets, it can be shown that both approaches are equivalent. More exactly:</p><p>The RD-sets characterized by Theorem 1 are the same as those which can be obtained by applying Theorems 2.1 and 2.2 of <ref type="bibr" target="#b0">[1]</ref>. For brevity w e omit the proof of the above fact which can be found in <ref type="bibr" target="#b14">[15]</ref>.</p><p>After having compared our approach to previous results from the literature, let us now concentrate on the question of how t o c hoose a complete stabilizing assignment . Here, we arrive at the following optimization goal: \Choose such that the size of LP () is minimum." Choosing LP () as small as possible, minimizes the number of paths which need to be considered for test generation. In addition, it maximizes the fault coverage, which b y Theorem 1 is given as the numberof testable logical paths divided by jLP ()j. Finally, it helps to reduce design for testability o v erhead, since the logical paths from LP () which are not testable must be considered for design for testability modications. The following example illustrates the above facts. <ref type="bibr">Example 3</ref> In Example 2 a p ossible complete stabilizing assignment has been given for our example circuit (see Figure <ref type="figure" target="#fig_1">2</ref>). LP () consists of 6 logical paths from which only 5 are robustly testable. The 6-th logical path (indicated by the dashed line in Figure <ref type="figure" target="#fig_1">2</ref>) is neither robustly nor non-robustly testable. Thus, the fault coverage for this example would only be 5  6 100%, and the dashed path would have to be c onsidered for design for testability modications.</p><p>Figure <ref type="figure" target="#fig_4">4</ref> shows a dierent choice of the stabilizing system for input (0; 0; 0). The set of logical paths for the resulting complete stabilizing assignment 0 consists only of the ve logical paths of C which are r obustly testable. Thus, the actual fault coverage when testing these ve paths is 100%, and no design for testability modications are n e c essary. As already mentioned, the heuristic of <ref type="bibr" target="#b0">[1]</ref> for computing a minimum RD-set gradually unfolds the circuit and searches for stuck-at redundancies (corresponding to sets of RD-paths). In this section a new methodology is developed which a v oids unfolding of the circuit. <ref type="bibr">Denition 7</ref> An input sort of a circuit C is a mapping which orders the inputs of each gate g of C completely, i.e. for each gate g its input leads are numbered f r om 1 to fan-in(g). For an input lead l of gate g, (g;l)denotes the position of l with respect to the input sort of g.</p><p>Given an input sort we can x a complete stabilizing assignment as follows:</p><p>For an input vector v the corresponding stabilizing system (v) is obtained by applying Algorithm 1 with the following restriction: In Step 2(b) always choose the input lead l 2 L with minimum (g;l). Now instead of considering all possible choices for complete stabilizing assignments only the assignments from f j arbitrary input sortg will be considered. This restricts the search space but will allow u s t o w ork more eciently.</p><p>Example 4 Figure <ref type="figure" target="#fig_5">5</ref> gives a possible input sort for our example circuit. The corresponding complete stabilizing assignment is the optimum assignment of Example 3. Thus, for this circuit the restricted search space still contains the optimum solution. Let us assume that a good input sort is given. (The problem of how t o b e s t c hoose such a sort will be discussed later.) The logical path set to (the corresponding RD-set RD( )) can be computed based on the following lemma: Lemma 2 For a circuit C, let be an input sort, and (P;x!x) a l o gical path in C.</p><p>(P;x!x)2 L P ( ) ( ) There exists an input vector v 2 B n such that:</p><p>(1) v sets PI(P ) to x, <ref type="bibr" target="#b1">(2)</ref> for each gate g of P such that its on-path input has a non-controlling stable value under v, all the side-inputs of g have non-controlling stable values under v, (3) for each gate g of P such that its on-path input l has a controlling stable value under v, all low-order 2 sideinputs of l have non-controlling stable values under v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>It suces to show that: v satises conditions ( <ref type="formula">1</ref>)-( <ref type="formula">3</ref>) for path P ( ) (P;x!x)2 L P ( v; (v)). \)": Let v be an input vector fullling conditions ( <ref type="formula">1</ref>)-( <ref type="formula">3</ref>) for path P . We inductively show that P will be included in (v): Clearly, the Po of P is included in (v). Let g be the next gate of P , and l its on-path input. If g is a Not then g and l will be included in (v). If g 2 f And; Or; Nand; Norg two cases must be distinguished: If the stable value of l under v is non-controlling, then by condition (2) all side-inputs of l have non-controlling stable values too, and thus, all input leads of g are included in (v) b y Algorithm 1. If the stable value of l under v is controlling, then by condition (3) all low-order side-inputs of l have non-controlling stable values. Thus, in Step 2(b) of Algorithm 1 l is the element of set L with lowest sort number and will be selected for (v). \(": Since this direction is proven analogously, it is omitted here for brevity.</p><p>Remark 2 If condition (3) of Lemma 2 is omitted, we obtain the conditions of Denition 4 for functionally sensitizable paths.</p><p>In <ref type="bibr" target="#b1">[2]</ref> an algorithm has been given to determine which logical paths are functionally sensitizable. In order to save running time, this algorithm does not compute the actual set F S ( C ) but a small superset F S sup (C)which gives a very good approximation of F S ( C ). Based on the similarity of their characterizations, the same methodology can also be applied for approximating LP ( ) for a given input sort : 2 Let g be a gate and l an input to g. The low-order side-inputs of l are all inputs l 0 to g with (g;l 0 )&lt; ( g;l). Algorithm 2 All logical paths of the circuit are implicitly<ref type="foot" target="#foot_0">3</ref> enumerated. For each logical path (P;x!x) w e c heck whether there exists an input vector v satisfying conditions (1)-( <ref type="formula">3</ref>). If such an input vector exists, then (P;x!x) 2 L P ( ). In order to speed-up the computation process, the above c heck i s not performed exactly. As suggested in <ref type="bibr" target="#b1">[2]</ref>, only the local implications induced by conditions (1)-( <ref type="formula">3</ref>) are performed to see whether they result in a contradiction. If there is no contradiction, the logical path is assumed to be an element o f LP ( ). Thus, the algorithm actually computes a superset LP sup ( ) of LP ( ) (subset RD sub ( ) := LP (C) n L P sup ( ) of RD( )). As will be seen in the experimental results of Section VI, the quality o f the approximation LP sup ( ) i s v ery good.</p><p>Since the generalizations of the procedure given in <ref type="bibr" target="#b1">[2]</ref> are straight forward, we omit details here for brevity. 2</p><p>Remark 3 The procedure of <ref type="bibr" target="#b1">[2]</ref> can also be applied to compute a superset T sup (C) approximating the set T (C) of all non-robustly testable logical paths. This is done by (implicitly) enumerating all logical paths, and checking for each logical path whether there exists an input vector v fullling the conditions of Denition 5.</p><p>V. How to choose the input sort?</p><p>Let us now turn to the optimization problem of choosing the input sort such that LP ( ) is minimized. Since solving this problem exactly is too time consuming, we will focus on fast heuristics computing a near optimum solution.</p><p>Denition 8 Let l be an input lead to a gate g in circuit C.</p><p>(a) The set of all physical (logical) paths of C going through l is denoted b y P ( l ) ( LP (l)). (b) The set of logical paths from LP (l) such that the transition at l has as nal value the controlling value of g is denoted by LP c(l).</p><p>Remark 4 Clearly, jLP c(l)j = 1 2 jLP (l)j = jP (l)j. Consider a gate g with two inputs l1 and l2 as an example. By chosing the input sort for g we can guide Algorithm 1 which input to select in Step (2)(b) if both inputs have controlling stable values. As a consequence, we can control whether paths from LP c(l1) o r LP c(l2) are prefered for inclusion in LP ( ). Now let us assume that jLP c(l1)j &lt; jLP c(l2)j. Since we w ant to minimize the size of LP ( ), it is a good idea to preferably include paths from LP c(l1) i n LP ( ). Our rst heuristic for choosing the input sort is based on this observation.</p><p>Heuristic 1 Choose such that for any two input leads l and l 0 of a gate g in C:</p><p>jLP c(l)j &lt; jLP c(l 0 )j =) (g;l)&lt; ( g;l 0 ) If jLP c(l)j = jLP c(l 0 )j, the corresponding inputs can be o r dered arbitrarily.</p><p>Since jLP c(l)j = jP (l)j, computation of such an input sort simply corresponds to path counting and thus, can be done in linear time with respect to circuit size.</p><p>The strategy of Heuristic 1 can be improved based on the following observation: From Lemma 1 it follows that logical paths which are nonrobustly testable (not functionally sensitizable) will always (never) be included in LP ( ). Thus, LP c(l)\(F S ( C ) n T ( C )) gives a better measure for input sorting than LP c(l).</p><p>Heuristic 2 Let Tc (l) (F S c ( l ) )denote the set of all logical paths from LP c(l) which are non-robustly testable (functionally sensitizable). Choose such that for any two input leads l and l 0 of a gate g in C:</p><p>jF S c(l) n T c ( l ) j &lt; jF S c(l 0 ) n T c ( l 0 ) j = ) ( g;l)&lt; ( g;l 0 ) Again, if jF S c(l) n T c ( l ) j = jF S c(l 0 ) n T c ( l 0 ) j , the corresponding inputs are o r dered r andomly.</p><p>An exact computation of the cost measure jF S c(l) n T c ( l ) j , applied in Heuristic 2 for input sorting, would be too time consuming. Based on the algorithm of <ref type="bibr" target="#b1">[2]</ref> and Remark 3, the following method can be used for approximating the cost measure: Algorithm 3 / approximate computation of cost measure for Heuristic 2 / (1) Run the algorithm of <ref type="bibr" target="#b1">[2]</ref> for the criterion of Denition 4 to determine the approximation F S sup c (l) F S c ( l ) for all lines l of C. (2) Run the algorithm of <ref type="bibr" target="#b1">[2]</ref> for the criterion of Denition 5 to determine the approximation T sup c (l) T c ( l ) for all lines l of C. (3) Choose the input sort such that: jF S sup c (l) n T sup c (l)j &lt; jF S sup c (l 0 ) n T sup c (l 0 )j =) (g;l)&lt; ( g;l 0 ) 2 Clearly, the above method for input sorting is much more time consuming than Heuristic 1. But, as will be seen in the experimental results, it also increases the quality o f the sort function (i.e. the size of the computed RD-set) considerably.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. Experimental Results</head><p>This section evaluates the eectiveness of the proposed approach with respect to quality of the result, i.e. size of the identied RD-set, and CPU-time (measured on a SUN SPARC 1 0 w orkstation).</p><p>Table <ref type="table" target="#tab_0">I</ref> shows results for the ISCAS85 benchmark set. The run for c6288 could not be completed in reasonable time, since this circuit has more than 1:9 10 20 logical paths <ref type="bibr" target="#b15">[16]</ref>. The percentage of logical paths which can be identied as functionally unsensitizable <ref type="bibr" target="#b1">[2]</ref> is given in column FUS. From Lemma 1 it follows that any RD-set obtained by applying Theorem 1 contains these paths as a subset. Columns Heu1 (Heu2) give the percentage of logical paths which were identied RD by Heuristic 1 (resp. Heuristic 2). For most circuits these numbers are considerably larger than the percentage of functionally unsensitizable paths. The increase varies from 2:26% for circuit c880 up to 42:3% for circuit c1908. Comparing the results of columns Heu1 and Heu2, it can be seen that Heuristic 2 gives always better results than Heuristic 1. The average improvement in percentage of RD-paths is 2:51%. Column Heu2 of Table <ref type="table" target="#tab_0">I</ref> gives RD-set sizes obtained by c hoosing the input sort inversely to Heuristic 2. The fact that the percentage of paths which can be classied RD reduces dramatically indicates that our heuristics for choosing the input sort aim in the right direction.  <ref type="table" target="#tab_0">II</ref> gives the number of logical paths and the running times of Heuristics 1 and 2 for each of the ISCAS85 benchmarks. As can be seen, our approach even handles circuit c3540 which has over 57 million logical paths in less than 15 hours. The enormous improvements in running time compared to the approach of <ref type="bibr" target="#b0">[1]</ref> are illustrated by the fact that for circuit c499 this algorithm had not nished after a running time of 69 hours, i.e. even Heuristic 2 is more than 1000 times faster for this circuit. Comparing the CPU-times of Heuristics 1 and 2, an increase by factor 3 or more can be observed for most of the circuits. This is due to the fact that the procedure of <ref type="bibr" target="#b1">[2]</ref> has to be executed three times for Heuristic 2, two times for computing the priority function (see Algorithm 3) and once for the actual RD-set computation. Our improvements in running time compared to the approach of <ref type="bibr" target="#b0">[1]</ref> come from two facts: First, we consider a restricted search space (complete stabilizing assignments which are given by a n input sort ), and second, LP ( ) i s not computed exactly but approximated by an upper bound. To estimate the average loss in quality due to the above restrictions we did the following experiment:</p><p>We synthesized multi-level implementations for all of the twolevel MCNC benchmarks <ref type="foot" target="#foot_1">4</ref> . We then ran the algorithm of <ref type="bibr" target="#b0">[1]</ref>  and Heuristic 2 for all circuits which could be handled by the approach of <ref type="bibr" target="#b0">[1]</ref> and which h a v e a non-empty RD-set. On the average the percentage of RD-paths which w ere identied by our approach w as only 2:05% less than for the solution of <ref type="bibr" target="#b0">[1]</ref>.</p><p>Table <ref type="table" target="#tab_2">III</ref> gives the exact results for the largest of these benchmarks. It shows that, while the quality of our approximation is very good for most of the circuits, there are still few designs (misex3 and seq) with a considerable dierence.</p><p>For circuits with huge path numbers, like for example c3540 of the ISCAS85 benchmark set, even after RD identication the number of non-RD paths might b e t o o large in order to test all of them. In this situation strategies for selecting only a subset of paths for testing purposes <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref> must be applied. As already noted in <ref type="bibr" target="#b1">[2]</ref>, these strategies can be easily adapted to take advantage of RD-set identication. As an example, if we restrict to only checking paths with expected delay greater than a given threshold, then among these paths only those which are non-RD should be considered for testing. Analogously, if for each line of the circuit we c hoose to only test a limited number of logical paths going through it, then it is sucient to only consider non-RD paths for this selection process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. Conclusion</head><p>In this paper we h a v e studied the problem of which paths actually need to be tested in order to check that a manufactured circuit meets its timing specicatons. A theory has been developed which puts previous results <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref> in a common framework, thus allowing for a better understanding of their relation. Since the approach of <ref type="bibr" target="#b0">[1]</ref> is too time consuming to be run on large circuits, we h a v e proposed a new methodology for RD-set computation which trades running time against quality of the result. Experimental results have shown that with only a small loss in accuracy huge improvements in running time can be achieved.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Stabilizing systems for input 111</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Complete stabilizing assignment</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 1</head><label>1</label><figDesc>Let LP (C) denote the set of all logical paths in C, and consider an arbitrary complete stabilizing assigment for C. Then: Every subset from RD() : = LP (C) n L P ( ) is an RD-set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Lemma 1</head><label>1</label><figDesc>Let be an arbitrary complete stabilizing assignment for circuit C. Then: T (C) L P ( ) F S ( C ) Proof: T (C) L P ( ):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Stabilizing system for input 000 IV. RD-set identification without circuit unfolding</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Optimum input sort</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I</head><label>I</label><figDesc></figDesc><table><row><cell></cell><cell cols="3">Results for ISCAS85 benchmarks</cell><cell></cell></row><row><cell>circuit</cell><cell>FUS</cell><cell>Heu1</cell><cell>Heu2</cell><cell>Heu2</cell></row><row><cell cols="5">c432 64.25 % 90.12 % 91.12 % 84.29 % c499 30.05 % 39.50 % 53.79 % 30.05 % c880 0.94 % 1.81 % 3.20 % 0.94 % c1355 81.19 % 83.27 % 86.70 % 81.19 % c1908 32.79 % 74.95 % 75.09 % 33.34 % c2670 77.26 % 81.27 % 82.42 % 77.79 % c3540 72.16 % 94.89 % 94.99 % 83.33 % c5315 78.05 % 83.79 % 83.80 % 81.74 % c7552 68.78 % 75.63 % 76.70 % 72.18 %</cell></row><row><cell>Table</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE III Comparison</head><label>III</label><figDesc>of Heuristic 2 to the approach of[LSBSV93]    </figDesc><table><row><cell cols="2">circuit no. of logical paths</cell><cell cols="4">approach of [1] % of RD-paths CPU-time % of RD-paths CPU-time new approach (Heuristic 2)</cell></row><row><cell>apex1 Z5xp1 apex5 bw apex3 misex3 seq misex3c</cell><cell>13,756 20,102 23,836 24,380 35,270 40,578 52,886 1,856,452</cell><cell>8.52 % 94.75 % 60.63 % 91.37 % 71.53 % 67.25 % 63.35 % 99.53 %</cell><cell>46:39 3:44 16:15 8:01 1:02:54 1:39:40 3:59:35 7:54:22</cell><cell>7.89 % 94.14 % 59.43 % 89.68 % 70.95 % 63.78 % 57.81 % 99.29 %</cell><cell>0:30 0:05 0:18 0:09 0:38 0:31 0:42 4:13</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>By applying the concept of `prime segments'<ref type="bibr" target="#b1">[2]</ref> the number of paths which m ust be considered can be reduced drastically, i.e. we take advantage of the fact that all extensions of a logical path segment which d o e s not fulll the conditions of Lemma 2 are elements of RD( ).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>Each circuit was synthesized by applying script.rugged in the SIS system<ref type="bibr" target="#b16">[17]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>The authors want to thank G. Hotz, B. Becker, and A. Saldanha for their support and helpful discussions. In addition, we thank R.K. Brayton, W.K. Lam, A. Saldanha, and A.L. Sangiovanni-Vincentelli for providing their RD-set identication program.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Delay fault coverage and performance tradeos</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saldanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th Design Automation Conference</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="446" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Delay testing for non-robust untestable circuits</title>
		<author>
			<persName><forename type="first">K.-T</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-C</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Test Conference</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="954" to="961" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Comparision of AC self-testing procedures</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Barzilai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Test Conference</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="89" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Model for delay faults based upon paths</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Test Conference</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">342</biblScope>
			<biblScope unit="page">349</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An automatic test pattern generator for the detection of path delay faults</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on CAD</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="284" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Parallel pattern fault simulation for path delay faults</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fuchs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th Design Automation Conference</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="357" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Timing analysis and delay fault test generation using path-recursive functions</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Mcgeer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Saldanha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Stephan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on CAD-91</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="180" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Delay fault test generation for scan/hold circuits using boolean expressions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bhattacharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th Design Automation Conference</title>
		<imprint>
			<date type="published" when="1992-06">June 1992</date>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="page">164</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">NEST: A nonenumerative test generation method for path delay faults in combinational circuits</title>
		<author>
			<persName><forename type="first">I</forename><surname>Pomeranz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Uppaluri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th Design Automation Conference</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="439" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Path hashing to accelerate delay fault simulation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Henftling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Wittmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Antreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st Design Automation Conference</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="522" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Generation of high quality non-robust tests for path delay faults</title>
		<author>
			<persName><forename type="first">K.-T</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-C</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st Design Automation Conference</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="365" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">RESIST: A recursive test generation algorithm for path delay faults considering various test classes</title>
		<author>
			<persName><forename type="first">K</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pabst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Ossel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on CAD</title>
		<imprint>
			<biblScope unit="page" from="1550" to="1562" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A neutral netlist of 10 combinational benchmark circuits and a target translator in Fortran</title>
		<author>
			<persName><forename type="first">F</forename><surname>Brglez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fujiwara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IEEE International Symposium on Circuits and Systems</title>
		<meeting>IEEE International Symposium on Circuits and Systems</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">On delay fault testing in logic circuits</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on CAD</title>
		<imprint>
			<biblScope unit="volume">694</biblScope>
			<biblScope unit="page">703</biblScope>
			<date type="published" when="1987-09">September 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">F ast identication of robust dependent path delay faults</title>
		<author>
			<persName><forename type="first">U</forename><surname>Sparmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Luxenburger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">T</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
		<idno>SFB 124 08/1994</idno>
	</analytic>
	<monogr>
		<title level="m">Computer Science Department, Universit at des Saarlandes, D 66041 Saarbr ucken</title>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An ecient non-enumerative method to estimate the path delay fault coverage in combinational circuits</title>
		<author>
			<persName><forename type="first">I</forename><surname>Pomeranz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on CAD</title>
		<imprint>
			<biblScope unit="page" from="240" to="250" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Sequential circuit design using synthesis and optimization</title>
		<author>
			<persName><forename type="first">E</forename><surname>Sentovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Savo J</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brayton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Design</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="328" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">T esting for timing failures in synchronous sequential integrated circuits</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">K</forename><surname>Malaiya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Narayanswamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Test Conference</title>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="560" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On path selection in combinational logic circuits</title>
		<author>
			<persName><forename type="first">W.-N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Sahni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on CAD</title>
		<imprint>
			<biblScope unit="page" from="56" to="63" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
