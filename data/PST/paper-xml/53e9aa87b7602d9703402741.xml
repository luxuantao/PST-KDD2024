<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Mining of Iterative Patterns for Software Specification Discovery</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><surname>Lo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Siau-Cheng</forename><surname>Khoo</surname></persName>
							<email>khoosc@comp.nus.edu.sg</email>
						</author>
						<author>
							<persName><forename type="first">Chao</forename><surname>Liu</surname></persName>
							<email>chaoliu@cs.uiuc.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois-UC</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<settlement>San Jose</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Mining of Iterative Patterns for Software Specification Discovery</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">51D2C504DCE3B12052FF7DB503C62F5E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:58+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.8 [Database Management]: Database Applications-Data Mining; D.2.1 [Software Engineering]: Requirements/Specifications-Tools Algorithms</term>
					<term>Performance</term>
					<term>Experimentation Closed Iterative Patterns</term>
					<term>Software Specification Discovery</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Studies have shown that program comprehension takes up to 45% of software development costs. Such high costs are caused by the lack-of documented specification and further aggravated by the phenomenon of software evolution. There is a need for automated tools to extract specifications to aid program comprehension. In this paper, a novel technique to efficiently mine common software temporal patterns from traces is proposed. These patterns shed light on program behaviors, and are termed iterative patterns. They capture unique characteristic of software traces, typically not found in arbitrary sequences. Specifically, due to loops, interesting iterative patterns can occur multiple times within a trace. Furthermore, an occurrence of an iterative pattern in a trace can extend across a sequence of indefinite length.Since a program behavior can be manifested in numerous ways, analyzing a single trace will not be sufficient. Iterative pattern mining extends sequential pattern and episode minings to discover frequent iterative patterns which occur repetitively both within a program trace and across multiple traces. In this paper, we present CLIPER (CLosed Iterative Pattern minER) to efficiently mine a closed set of iterative patterns. A performance study on several simulated and real datasets shows the efficiency of our mining algorithm and effectiveness of our pruning strategy. Our case study on JBoss Application Server confirms the usefulness of mined patterns in discovering interesting software behavioral specification.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">MOTIVATION AND BACKGROUND</head><p>It's best if all programs and software projects are developed with clear, precise and documented specifications. However, due to hard deadlines and 'short-time-to-market' requirement <ref type="bibr" target="#b6">[6]</ref>, software products often come with poor, incomplete and even without any documented specifications. This situation is further aggravated by a phenomenon termed as software evolution <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b21">21]</ref>. As software evolves the documented specification is often not updated. This might render the original documented specification of little use after several cycles of program evolution <ref type="bibr" target="#b10">[10]</ref>.</p><p>The above factors has contributed to high software maintenance costs. It has been investigated that up to 90% of software cost is due to maintenance <ref type="bibr" target="#b12">[12]</ref> and 50% of the maintenance cost is due to comprehending or understanding the code base <ref type="bibr" target="#b27">[27]</ref> (see also <ref type="bibr" target="#b5">[5]</ref>). Hence, approximately 45% of software cost is due to difficulty in comprehending an existing code base. This is especially true for software developed by many developers over a long period of time.</p><p>The above needs motivate work on building automated tools to extract or mine specifications from programs. An interesting form of specifications to be mined is patterns of software temporal behaviors.</p><p>Our motivating application is in the emerging area of dynamic analysis where program traces (each being a series of method invocations) are analyzed in order to infer or mine temporal program properties or patterns of behavior. Some existing work in this domain includes: <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b22">22]</ref>, which mine temporal program behavioral model expressed as an automata. In this paper, we propose mining interesting program temporal properties expressed as patterns rather than an automata. These patterns are intuitive and commonly found in software documentations, such as:</p><p>1. Resource Locking Protocol : lock, unlock 2. Telecommunication Protocol (c.f., <ref type="bibr" target="#b16">[16]</ref>):</p><p>off hook, dial tone on, dial tone off, seizure int, ring tone, answer, connection on 3. Java Authentication and Authorization Service (JAAS)</p><p>Authorization Enforcer Strategy Pattern (c.f., <ref type="bibr" target="#b28">[28]</ref>): Subject.getP rincipal, P rivilegedAction.create, Subject.doAsP rivileged, JAAS M odule.invoke, P olicy.-getP ermission, Subject.getP ublicCredential, P rivile-gedAction.run 4. Java Transaction Architecture (JTA) Protocol (c.f., <ref type="bibr" target="#b26">[26]</ref>): T xM anager.begin, T xM anager.commit , T xM anager.begin, T xM anager.rollback , etc.</p><p>Each of these patterns reflecting interesting program behavior can be mined by analyzing a set of program traces -each being a series of method invocations. These traces can in turn be generated through running a test suite. From data mining viewpoint, each trace can be considered a sequence. A pattern (e.g., lock-unlock) can appear a repeated number of times within a sequence. Each event can be separated by an arbitrary number of unrelated events (e.g., lock → resource use → . . . → unlock). Since a program behavior can be manifested in numerous ways, analyzing a single trace will not be sufficient. Usually, a set of test cases satisfying certain code coverage (i.e., every statements are executed) or branch coverage (i.e., every branch decision is taken) criterion (c.f., <ref type="bibr" target="#b3">[3]</ref>) is required to test the correctness of a software system. Running this test suite over an instrumented software will generate the desired traces.</p><p>To mine software temporal patterns having the above characteristics from traces, iterative pattern mining is proposed. It leverages the techniques found in sequential pattern mining and episode mining to handle software specification mining.</p><p>Sequential pattern mining first addressed by Agrawal and Srikant in <ref type="bibr" target="#b1">[1]</ref> discovers temporal patterns that are supported by a significant number of sequences. A pattern is supported by a sequence if it is a sub-sequence of it. It has application in many areas, from analysis of market data to gene sequences. On the other hand, Mannila et al. perform episode mining to discover frequent episodes within a sequence of events <ref type="bibr" target="#b23">[23]</ref>. An episode is defined as a series of events occurring relatively close to one another (i.e. they occur at the same window). An episode is supported by a window if it is a sub-sequence of the series of events appearing in the window. Episode mining focuses on mining from a single sequence of events, and has its application in analyzing events from telecommunication alarm management system.</p><p>Iterative pattern is a series of events supported by a significant number of instances repeated within and across sequences. Similar to sequential pattern mining, we consider a database of sequences rather than a single sequence. However, we also mine patterns occurring repeatedly within a sequence. This is similar in spirit to episode mining, but we remove the restriction that related events must happen in the same window.</p><p>Due to looping, a trace can contain repeated occurrences of interesting patterns. In fact, a series of events in an alarm management system used by Manilla et al. is similar to a series of system calls in a software system. However, there are 2 notable differences.</p><p>First, program properties are often inferred from a set of traces instead of a single trace. These are either produced by executing a test suite <ref type="bibr" target="#b32">[32]</ref> or generated statically from the source code <ref type="bibr" target="#b30">[30]</ref>. Secondly, important patterns for verification, such as, lock acquire and release or stream open and close (c.f <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b7">7]</ref>) often have their events occur at some arbitrary distance away from each other in a program trace. Hence, there is a need to 'break' the 'window barrier' in order to capture these patterns of interest. Interestingly, these two notable differences between analysis of events from an alarm management system and program traces are observed by sequential pattern miner first introduced in <ref type="bibr" target="#b1">[1]</ref>.</p><p>To support iterative pattern mining, we need a clear definition and semantics of iterative pattern different from episodes and sequential patterns. Our definition of iterative pat-tern is inspired by the common languages for specifying software behavioral requirements, namely Message Sequence Chart (MSC) <ref type="bibr" target="#b16">[16]</ref> and Live Sequence Chart (LSC) <ref type="bibr">[9]</ref>.</p><p>MSC and LSC are variants of sequence diagram specifying how a system should behave. An example of such chart is a simplified telephone switching protocol (c.f., <ref type="bibr" target="#b16">[16]</ref>). Abstracting caller and callee information, it can be represented as a pattern: off hook, dial tone on, dial tone off, seizure int, ring tone, answer, connection on . Such protocol must possess a total-ordering property and satisfy oneto-one correspondence requirements between events in the chart and events in a trace segment satisfying the chart. (Please refer to Section 3.2 for detail.)</p><p>The full language of MSC/LSC is complicated and it is not our intention to mine MSC/LSC. In this paper, iterative pattern mined abstracts away the caller and callee information but ensures total-ordering property and one-to-one correspondence between a pattern and its instance (i.e., a segment of a trace).</p><p>Pattern mining in general is an NP-hard problem. For it to be practical, efficient search space pruning strategies need to be employed. One of the most important property to help in ensuring scalability is the apriori property. There are several variants of it. Iterative pattern obeys the following apriori property utilized by depth-first search sequential pattern miners (e.g., FreeSpan <ref type="bibr" target="#b14">[14]</ref> and PrefixSpan <ref type="bibr" target="#b25">[25]</ref>) which states:</p><p>If P is not frequent then P + +evs (where evs is a series of events) is also not frequent.</p><p>Apriori property holds for both sequential patterns and episodes. To ensure efficiency, it is desirable to maintain this property for iterative patterns. Fortunately, the formulation of iterative pattern guarantees this property as described in Section 3.</p><p>Due to possibly combinatorial number of frequent subsequences of a long pattern, it's best to mine a closed set of patterns (c.f., <ref type="bibr" target="#b31">[31]</ref> &amp; <ref type="bibr" target="#b29">[29]</ref>). Closed pattern mining discovers patterns without any super-sequence having corresponding set of instances. Resultant pattern set is likely to be more compact and yet still complete (i.e. every frequent pattern is represented by a closed pattern). Closed pattern mining can also lead to more efficient pattern mining strategy. Early identification and pruning of non-closed patterns can reduce the runtime significantly.</p><p>In this paper, we mine a closed set of iterative patterns. A search space pruning strategy employed by early identification and pruning of non-closed patterns is used to mine a closed set of iterative patterns efficiently. Our performance study on synthetic and real-world datasets shows the major success of our pruning strategy: it runs with over an order of magnitude speedup especially on low support thresholds or when the frequent patterns are long.</p><p>As a case study we experimented with traces collected from transaction sub-component of JBoss Application Server. Our mined patterns highlight important design patterns shedding light on program behavior.</p><p>The contributions of this work are as follows:</p><p>1. We propose an efficient algorithm to mine a closed set of software iterative patterns from program execution traces. 2. We present a novel formulation of iterative pattern inspired by standards adopted for specifying software behavioral requirements (i.e., MSC and LSC).</p><p>3. We extend episode mining by: (1) analyzing multiple sequences, (2) removing the 'window' barrier and (3) extracting a closed set of patterns for software specification mining purpose. 4. We extend closed pattern mining by considering repeated pattern occurrences within a sequence and across multiple sequences for software specification mining purpose. The outline of the paper is as follows: We present related work in Section 2. Section 3 provides an in-depth discussion on semantics of iterative pattern. Section 4 presents the principles behind the generation of closed iterative patterns and its associated pruning strategy. Section 5 describes our closed pattern mining algorithm. Section 6 presents the results of our performance study. Section 7 discusses a case study on mining program behavioral design from traces of JBoss Application Server. We conclude in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">RELATED WORK</head><p>Our work is a variant of sequential pattern mining, which was originated by Agrawal and Srikant <ref type="bibr" target="#b1">[1]</ref>. To remove redundant patterns, closed sequential pattern mining was proposed by Yan et al. <ref type="bibr" target="#b31">[31]</ref> and later improved by Wang and Han <ref type="bibr" target="#b29">[29]</ref>. Different from sequential pattern, our pattern capture multiple occurrences of pattern not only across multiple sequences but also those repeated within each sequence. In this aspect, iterative pattern mining resembles episode mining initiated by Mannila et al. <ref type="bibr" target="#b23">[23]</ref> which was later extended by Casas-Garriga to replace a fixed-window size with a gap constraint between one event to the next in an episode <ref type="bibr" target="#b13">[13]</ref>. Both versions of episode mining mine events occurring close to one another, expressed by "window size" and gap constraint respectively. This is different with iterative pattern mining, which does not have the notion of "episode". This deviation is significant, since important program behavioral patterns, for example: lock acquire and release or file open and close (c.f <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b7">7]</ref>), often have their events occur at some arbitrary distance away from one another in a trace. In addition, both versions of episode mining handle only one single sequence, whereas iterative pattern mining operates over a set of sequences.</p><p>In mining DNA sequences, Zhang et al. introduced the idea of "gap requirement" in mining periodic patterns from sequences <ref type="bibr" target="#b33">[33]</ref>. Similar to ours, they detect repeated occurrences of patterns within a sequence and across multiple sequences. However, the gap requirement used there does not always hold for other purposes. Consider analyzing software traces, the useful patterns of lock acquire followed-by lock release can be separated by any number of events, and will violate the gap requirement. In addition, the pattern definition proposed in <ref type="bibr" target="#b33">[33]</ref> does not follow apriori property and hence potentially reduces the efficiency of the mining process. Lastly, the method only guarantees the mining of a complete set of patterns, all with length less than n, where n is a user defined parameter. The appropriate value of this parameter n might not be obvious to the user.</p><p>In the software engineering domain, Yang et al. mined a restricted form of two-event temporal rules, instead of patterns, from program traces <ref type="bibr" target="#b32">[32]</ref>. To handle more than two events, they proposed concatenation of 2-event rules to form longer ones. Unfortunately, this method is not sound as only an approximation to significance values of reported rules is made. It is also not complete since potentially many of the more-than-two-event rules cannot be generated by simple concatenation of 2-event rules.</p><p>In a similar domain, El-Ramly et al. mined user-usage scenarios of GUI based program composed of screens -these scenarios are termed as interaction patterns <ref type="bibr" target="#b11">[11]</ref>. Given a set of series of screen ids, frequent patterns of user interactions are obtained. Similar to ours, interaction pattern mining takes as an input a set of sequences and discover patterns occurring repeatedly within sequences.</p><p>However, due to differences in the nature of data mined, there are significant differences between interaction and iterative pattern mining.</p><p>Firstly, the semantics of the patterns mined are different. Iterative pattern adheres to the semantics of MSC/LSC specification language in describing software behavioral requirements, whereas interaction pattern does not. Consequently, the apriori property is not observed by interaction patterns -a pattern can have a larger support than its subsequences. In contrast, iterative patterns observe the apriori property.</p><p>Secondly, for each pattern instance, interaction pattern imposes a limit on the number of 'insertions' between one event to the next by a fixed constant. For many useful software temporal patterns (e.g. lock, unlock ) the number of 'insertions' is irrelevant -events can be separated by an arbitrary number of events; iterative patterns capture such "behavior" well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">ITERATIVE PATTERNS</head><p>In this section, we define formally iterative pattern, and provide the reasoning behind its semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Basic Definitions</head><p>Let I be a set of distinct events. Let a sequence S be an ordered list of events. We denote S as e1, e2, . . . , e end where each ei is an event from I. We refer to the ith event in the sequence S as S[i]. The sequence database under consideration is denoted by SeqDB.</p><p>A pattern P1 ( e1, e2, . . . , en ) is considered a subsequence of another pattern P2 ( f1, f2, . . . , fm ) if there exist integers</p><formula xml:id="formula_0">1 ≤ i1 &lt; i2 &lt; i3 &lt; i4 . . . &lt; in ≤ m where e1 = fi 1 , e2 = fi 2 , • • • , en = fi n .</formula><p>Notation-wise, we write this relation as P1 P2. We also say that P2 is a super-sequence of P1. We use the notations first (P ) and last(P ) to denote the first event and the last event of P respectively. Reference to the database is omitted if it refers to the input sequence database SeqDB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.1 (Concatenation and Truncation).</head><p>Concatenation of two patterns P1 ( a1, . . ., an ) and P2 ( b1, . . ., bm ) will result in a longer pattern P3 ( a1, . . . , an, b1, . . . , bm ). Truncation operation is only applicable between a pattern and its suffix. Truncation of a pattern P3 ( a1, . . . , an, b1, . . . , bm ) and a suffix P2 ( b1, . . . , bm ) will result in the pattern P1 ( a1, . . . , an ). Patterns concatenation is denoted by + +, while pattern truncation is denoted by --.</p><p>Another important operation used in this work is the erasure operation, as defined below. Definition 3.2 (Erasure Operator). Given a pattern P ( p1, p2, . . . , pn ) and a string S ( s1, s2, . . . , sm ), the erasure of S wrt. P , denoted by erasure(S, P ), is defined as a new string S erased formed from S where all events occurring in P are removed from S. Formally, S erased is defined as ( se1, se2, . . . , se k ) such that (1) ∀i.sei ∈ P and (2) there exists a set of integers {i1 . .</p><formula xml:id="formula_1">. i k } with 1 ≤ i1 &lt; i2 &lt; i3 &lt; i4 . . . &lt; i k ≤ m and se1 = si 1 , se2 = si 2 , • • • , se k = si k and ∀j ∈ {i1 . . . i k }, sj ∈ P .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Semantics of Iterative Patterns</head><p>Our definition of iterative pattern is inspired by the common languages for specifying software behavioral requirement: Message Sequence Chart (MSC) (a standard of International Telecommunication Union (ITU) <ref type="bibr" target="#b16">[16]</ref>) and its extension, Live Sequence Chart (LSC) <ref type="bibr">[9]</ref>.</p><p>MSC and LSC is a variant of the well known UML sequence diagram describing behavioral requirement of software. Not only does they specify system interaction through ordering of method invocation, but they also specifies caller and callee information. An example of such charts is a simplified telephone switching protocol (c.f., <ref type="bibr" target="#b16">[16]</ref>): abstracting caller and callee information, the protocol can be represented as a pattern: off hook, dial tone on, dial tone off, seizure int, ring tone, answer, connection on .</p><p>In verifying traces for conformance to an event sequence specified in MSC/LSC, the sub-trace manifesting the event sequence must satify the total-ordering property: Given an event evi in an MSC/LSC, the occurrence of evi in the subtrace occurs before the occurrence of every evj where j &gt; i and after ev k where k &lt; i <ref type="bibr" target="#b16">[16]</ref>. Kugler et al. strengthened the above requirement to include a one-to-one correspondence between events in a pattern and events in any subtrace satisfying it <ref type="bibr" target="#b20">[20]</ref>. Basically, this requirement ensures that, if an event appears in the pattern, then it appears as many times in the pattern as it appears in the sub-trace. For the telephone switching example, the following traces are not in conformance to the protocol: off hook, seizure int, ring tone, answer,ring tone, connection on off hook, seizure int, ring tone, answer, answer, answer, connection on The first trace above doesn't satisfy the total-ordering requirement due to the out-of-order second occurrence of ring-tone event. The second doesn't satisfy the one-to-one correspondence requirement due to multiple occurrences of answer event.</p><p>The full language of MSC/LSC is complicated and it is not our intention to mine MSC/LSC. Iterative pattern abstracts away the caller and callee information but retains the uniqueness and total ordering requirements.</p><p>The pattern instance definition capturing the total-ordering and one-to-one correspondence between events in the pattern and its instance can be expressed unambiguously in the form of Quantified Regular Expression (QRE) <ref type="bibr" target="#b24">[24]</ref>. Quantified regular expression is very similar to standard regular expression with ';' as concatenation operator, '[-]' as exclusion operator (i.e. [-P,S] means any event except P and S) and * as the standard kleene-star. Operationally we use an equivalent definition of pattern instance described using the erasure operation: Definition 3.4 (Iterative Pattern Instance). Given a pattern P (p1p2 . . . pn), a substring SB (sb1sb2 . . . sbm) of a sequence S in SeqDB is an iterative pattern instance of P iff ( <ref type="formula">1</ref>) first(P ) = first(SB), (2) last(P ) = last(SB) and ( <ref type="formula">3</ref>) the following erasure constraint holds: erasure(SB, erasure(SB, P )) = P.</p><p>We use the term "pattern instance" and "iterative pattern instance" interchangeably in this paper. The operation erasure(SB, erasure(SB, P )) basically removes all events that occur in SB but not in P . An iterative pattern is thus identified by a set of iterative pattern instances, which can occur repeatedly in a sequence as well as across sequences. We also use the term "pattern" and "iterative pattern" interchangeably.</p><p>An instance is denoted compactly by a triple (s idx , istart, i end ) where s idx refers to the sequence index of a sequence S in the database while istart and i end refer to the starting point and ending point of a substring in S. By default, all indices start from 1. With the compact notation, an instance is both a string and a triple -the representations are used interchangeably. The set of all instances of a pattern P in a database DB is denoted as Inst(P, DB). Reference to the database is omitted if it refers to the input sequence database.</p><p>As an example, consider a pattern P ( A, B ) and a database consisting of two sequences:</p><formula xml:id="formula_2">Identifier Sequence S1 D, B, A, B, A, B, C, E S2 D, B, A, B, B, B, A, B</formula><p>The set Inst(P ) is the set of triples { <ref type="bibr" target="#b1">(1,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b4">4)</ref>, <ref type="bibr" target="#b1">(1,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b6">6)</ref>, <ref type="bibr" target="#b2">(2,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b4">4)</ref>, (2,7,8)}.</p><p>There is a one-to-one ordered correspondence between events in the pattern and events in its instance. This oneto-one correspondence can be captured by the concept of pattern instance landmarks defined below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.5 ( Pattern Instance Landmarks ).</head><p>Given a pattern P (p1p2 . . . pn), an instance I (s1s2 . . . sm) of pattern P has the following landmarks: l1, l2, . . . ln where 1 ≤ l1 &lt; l2 &lt; . . . &lt; ln ≤ m and s l 1 = p1, s l 2 = p2, . . . , s ln = pn. Due to erasure constraint, for each instance there is only one such set of landmarks. The landmarks of an instance I is denoted as Lnd(I). The ith member of the set Lnd(I) is called the ith landmark.</p><p>The support of a pattern wrt. to a sequence database SeqDB is the number of its instances in SeqDB. A pattern P is considered frequent when its support, sup(P ), exceeds a certain threshold (min s-sup).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Apriori Property and Closed Pattern</head><p>Iterative patterns possess the following 'apriori' property used in PrefixSpan <ref type="bibr" target="#b25">[25]</ref>:</p><p>Theorem 1 (Apriori Property -PrefixSpan). If P is not frequent then its extensions (P + +evs or evs+ +P ) (where evs is a series of events) are also not frequent.</p><p>In general, iterative pattern does not possess the apriori property used in GSP <ref type="bibr" target="#b1">[1]</ref>: if a pattern is frequent so does its sub-sequences. However, considering patterns having corresponding instances as described in Definition 3.6 below, the GSP apriori property holds. It is restated in Theorem 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.6 ( Corresponding Pattern Insts ).</head><p>Consider a pattern P and its super-sequence Q. Instance IP (seqP , startP , endP ) of P corresponds to an instance IQ (seqQ, startQ, endQ) of Q iff seqP = seqQ and startP ≥ startQ and endP ≤ endQ.</p><p>Theorem 2 (Apriori Property -GSP-Like). If a pattern Q is frequent and P is a sub-sequence of Q, then either P is frequent or every instance of Q do not correspond to any instance of P (and vice versa). Definition 3.7 (Closed Pattern). A frequent pattern P is closed if there exists no super-sequence Q s.t.:</p><p>1.</p><p>P and Q has the same support 2.</p><p>Every instance of P corresponds to a unique instance of Q. An instance of P (seqP , startP , endP ) corresponds to an instance of Q(seqQ, startQ, endQ) iff seqP = seqQ and startP ≥ startQ and endP ≤ endQ.</p><p>The second condition of the above definition is to prevent the following case from happening.</p><formula xml:id="formula_3">Identifier Sequence S1 A, B, B, A S2 A, B, A</formula><p>Consider the above sequence database. The only instance of the pattern A, B, A is (2,1,3), while the only instance of pattern A, B, B, A is (1,1,4). Both have the same support. However, since their instances match different segments of the sequences they should be reported separately. A, B, A is not "absorbed" by A, B, B, A and is thus closed.</p><p>Notation-wise, we denote the full set of closed iterative patterns mined from SeqDB by Closed . We consider the following problem: Given a sequence database, find a closed set of iterative patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.GENERATION OF ITERATIVE PATTERNS</head><p>Iterative pattern instances can be mined using depth first pattern growth and prune strategy (c.f., FreeSpan <ref type="bibr" target="#b14">[14]</ref> and PrefixSpan <ref type="bibr" target="#b25">[25]</ref>). However, rather than using the usual projection that extracts sequential patterns, we perform a different type of projection outlined below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.1 (Projected-all). A database SeqDB</head><p>projected-all on a pattern P results in a set of pairings and is denoted as SeqDB all P . It is defined recursively as follows.</p><p>Base Case: if P is a single event ev {(ev, sx) | ∃s ∈ SeqDB , ev+ +sx is a suffix of s} Inductive Case: if P is multi-events {(ox+ +px+ +last(P ), sx) | ∃(ox, (px+ +last(P )+ +sx)) ∈ SeqDB all P --last(P ) . ((last(P ) ∈ erasure(ox, P --last(P ))) ∧ (∀ev ∈ P, ev ∈ px))}</p><p>The definition of projected-all database captures pattern instances that possibly occur repeatedly within a sequence and across multiple sequences. The first element of the pairings corresponds to pattern instances in string format. The second element corresponds to the remaining part of the sequence providing the context from which the pattern can still be extended. Support of a pattern P is equal to the number of instances supporting P , denoted as |Inst(P, SeqDB)|. In turn, |Inst(P, SeqDB)| is equal to the size of the projected database |SeqDB all P |. The instances of a length-1 pattern e1 is simply the occurrences of event e1 throughout the sequences in SeqDB. The instances of a length-k e1, . . . , e k pattern can be found from instances of length-(k-1) e1, . . . , e k-1 pattern.</p><p>Instances of a length-2 pattern e1, e2 can be formed by extending instance pairings of e1 , (ox, ss) in SeqDB all e 1 , on the condition: ∃i.ss[i] = e2 ∧ ∀j &lt; i, ss[j] ∈ {p1, p2}. This condition corresponds to the second conjunctive clause of the inductive case of Definition 4.1. The first conjunctive clause in the definition is trivially satisfied since the erasure of a length-1 pattern instance is an empty string.</p><p>Similarly, instances of a length-3 pattern e1, e2, e3 can be formed by extending instance pairings of e1, e2 , (ox, ss) in SeqDB all e 1 ,e 2 , on the conditions:(1) e3 ∈ erasure(ox, e1, e2 ) and (2) ∃i.ss[i] = e3 ∧ ∀j &lt; i, ss[j] ∈ {e1, e2}. The first and second conditions correspond respectively to the two conjunctive clauses of the inductive case. The first condition is necessary since a substring instance ox of a length-2 pattern e1, e2 only obeys the erasure constraint for the original pattern -ox might contain e3.</p><p>Generalizing the above, instances of a length-k pattern can be formed from instances of a length-(k-1) pattern, by following the inductive case of Definition 4.1.</p><p>A simple depth-first algorithm to generate a full-set of iterative patterns is as follows. First, generate a set of length-1 patterns where the support of each is greater than the min sup threshold. A projected-all database can then be created from the set of frequent length-1 patterns according to the base case of Definition 4.1. Instances of a length-2 pattern can then be obtained by performing the inductive step of Definition 4.1 to the corresponding length-1 pattern projected database. Pattern not satisfying min sup will be pruned. Since patterns obey apriori property, we can stop extending pruned patterns. Length-(i+1) patterns can be obtained from length-(i) patterns accordingly.</p><p>For ease of explanation, let's represent the inductive step of Definition 4.1 with the following Projected-first projection and the related Seq operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.2 (Projected-first &amp; Seq). A projected database SeqDB all</head><p>P can be projected-first on an event e resulting in a set of pairings and denoted as (SeqDB all P ) f st e . It is defined as the following set.</p><p>{(ox+ +px+ +e, sx) | ∃(ox, (px+ +e+ +sx)) ∈ SeqDB all P . (e ∈ erasure(ox, P )) ∧ (∀ev ∈ (P + +e), ev ∈ px))} We denote the size of (SeqDB all P ) f st e as Seq(e, SeqDB all P ).</p><p>The above operation locates the first instance of an event e in the projected database -hence the name projected-first. It computes the sequences in projected database supporting event e -hence the name Seq operator. However, constraints corresponding to the inductive step of Definition 4.1 is also added to ensure (SeqDB all P ) f st e = SeqDB all P + +e . We also define the following two operations of equivalence of projected databases and inclusion of an event in a projected database.  The projected database SeqDB all A,B can then be constructed from SeqDB all A using the inductive step of Definition 4.1. Equivalently, we are applying the projected-first operation to the SeqDB all A with respect to event B. The result is shown below in Table <ref type="table" target="#tab_2">3</ref>.  The support of A, B, C is then given by the size of SeqDB all A,B,C which is 4: one from S1, two from S3 and another one from S4 in SeqDB.</p><formula xml:id="formula_4">Instance Remainder of Sequence (1, 1, 2) A, B, A, B, C, D, E (1, 3, 4) A, B, C, D, E (1, 5, 6) C, D, E (2, 1, 2) B, B, B (3, 1, 2) C, A, D, E, B, C (3, 4, 7) C (4, 1, 2) C, C, A, B (4, 5, 6)</formula><p>Generating a full-set of iterative patterns results in many "redundancies". As all subsequences of a frequent iterative pattern P having corresponding instances are frequent, the number of frequent patterns is potentially exponential to the maximum length of the iterative patterns. Mining for closed patterns is an effective solution. Besides reducing the final number of patterns, closed pattern mining can usually reduce run-time by pruning the search space. Definition 4.4 (Prefix Extension Events). For a pattern P , its set of prefix extension events is defined as the set of length-1 items e where sup(e+ +P ) = sup(P ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.5 (Infix Extension Events).</head><p>An event e is an infix extension of a pattern P iff ∃ a super-sequence Q where: <ref type="bibr" target="#b1">(1)</ref>  <ref type="formula">2</ref>) first(P) = first(Q), ( <ref type="formula">3</ref>) ∀ event ev1 ∈ erasure(Q, P ). ev1 = e, (4) sup(P ) = sup(Q), and ( <ref type="formula">5</ref>) Every instance of P corresponds to a unique instance of Q. Definition 4.6 (Suffix Extension Events). For a pattern P , its set of suffix extension events is defined as the set of length-1 items e where sup(P + +e) = sup(P ).</p><formula xml:id="formula_5">SeqDB all P = SeqDB all Q , (</formula><p>Prefix/ suffix extension events define events that can be added as prefix/ suffix (of length 1) to a pattern and results in another pattern having the same support 1 . Infix extension events define events that can be added as infix to a pattern and results in another pattern having the same support and corresponding instances.</p><p>As an example, consider the sample database in Table <ref type="table" target="#tab_0">1</ref>. For pattern D , its set of prefix extension events is { A, B, C }. For pattern A, C , its set of infix extension events is { B }. For pattern A , its set of suffix extension events is { B }.</p><p>The above definitions are used in the next two theorems, which are then used for incremental and early detection of closed patterns and early pruning of search space.</p><p>Theorem 3 (Extension Closure Checks). If there exists no prefix, infix and suffix extension event w.r.t. a pattern P , P must be a closed pattern; otherwise P must be non-closed.</p><p>Proof. Part 1: If there exists a prefix, infix or suffix extension event, then P must be non-closed.</p><p>Consider a pattern P (where |P | = n). If there exists a suffix extension event e, there exists another pattern Q (P + +e) having the same support and a corresponding set of instances as P .</p><p>Patterns P and Q have corresponding set of instances due to the following. The region from the 1st to the n th landmark of an instance of Q is an instance of P . Hence, every instance of Q matches an instance of P . Also, if sup(P ) = sup(P + +e), we have every instance of P matches an instance of Q as well. They have corresponding instances.</p><p>Similarly, if there exists a prefix extension event e, there exists another pattern Q (e+ +P ) having the same support and a corresponding set of instances as P . Hence, if there exists a prefix or suffix extension event for P , we can create a super-sequence of P having the same support and a corresponding set of instances (i.e. P is not closed). 1 Patterns e+ +P and P + +e will have corresponding instances as P iff sup(e+ +P ) = sup(P ) and sup(P + +e) = sup(P ) respectively -see proof of Theorem 3 Consider a pattern P . If there exists an infix extension event e, we can create another pattern Q super-sequence of P having the same support and corresponding instances. Hence, P is not closed. Part 2: If there exists no prefix, suffix and infix extension event P must be closed.</p><p>We can only grow a pattern by adding prefix, infix and suffix to it. Hence, if we cannot find a prefix, infix and suffix extension event of a pattern P resulting in its super-sequence having the same support, P must be closed.</p><p>It is enough to consider a single event extension since apriori property holds for patterns having corresponding instances.</p><p>As an example, consider the sample database in Table <ref type="table" target="#tab_0">1</ref>. For pattern A, B, C , its sets of prefix, suffix and infix extension events are empty. We can conclude that the pattern A, B, C is closed. On the other hand, for pattern A , its set of suffix extension events is not empty. Hence it is not closed since there exists a pattern A, B which is a supersequence of A with the same support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4 (InfixScan Search Space Pruning).</head><p>Given a pattern P , if there exists an infix extension event e w.r.t. a pattern P and e ∈ SeqDB all P , we can safely stop growing pattern P .</p><p>Proof. From Definition 4.5, if a pattern P has an infix extension event e, there exists a super-sequence pattern Q where: (1) SeqDB all P = SeqDB all Q , (2) ∀ event ev1 ∈ erasure(Q, P ). ev1 = e, (3) sup(P ) = sup(Q), and (4) Every instance of P corresponds to a unique instance of Q.</p><p>Since SeqDB all P = SeqDB all Q , if we can extend an instance sx in Inst(P ) (and also in Inst(Q)) with a substring sext where erasure(sx+ +sext, erasure(sx+ +sext, P + +sext)) = P + +sext, erasure(sx+ +sext,erasure(sx+ +sext, Q+ +sext)) will also be equal to Q+ +sext.</p><p>Since e is not in SeqDB all P , whenever P + +sext violate erasure constraint so does Q+ +sext.</p><p>Thus, given an arbitrary series of events sext, if P + +sext is frequent, there exists another pattern Q+ +sext having the same support and corresponding instances. Hence, any pattern having P as prefix will not be closed. We can stop growing pattern P .</p><p>As an example, consider the sample database in Table <ref type="table" target="#tab_0">1</ref>. For pattern A, C , its set of infix extension events is {B}. There is no point extending pattern A, C further. Take for example pattern A, C, D of support 1. It is not closed since, there exists pattern A, B, C, D which is a supersequence and has the same support and corresponding instances as the pattern A, C, D .</p><p>The next section outlines our algorithm utilizing the above closure checks and InfixScan search space pruning for efficient memory and time utilization and for pruning of redundant search space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">ALGORITHM</head><p>Our CLIPER (CLosed Iterative Pattern minER) algorithm is shown in Figure <ref type="figure" target="#fig_3">1</ref> Procedure MinePatterns will first find patterns of length one whose instances are more than or equal to min sup  The recursive algorithm MineRecurse, shown at the bottom of Figure <ref type="figure" target="#fig_3">1</ref>, will have as inputs the pattern prefix computed so far (P at), the projected-all sequence database (SeqDB all P at ), the support threshold, the data structure containing current set of closed patterns (Closed) and the set of frequent events.</p><p>The algorithm will first find length-1 event e where P at+ +e is frequent. Given the input pattern P at and an event e, the number of instances of P at+ +e is equivalent to the number of pairings (px, sx) in SeqDB all P at where we can extend px to an instance of P at+ +e. The above is equivalent to Seq(e, SeqDB all P at ). A set of prefix extension events of P at is the set of such event e where sup(e+ +P at) = sup(P at). A set of suffix extension events of P at is the set of such event e where sup(P at+ +e) = sup(P at).</p><p>Only such pattern P at without any infix extension events will be an input to the recursive algorithm. Hence, it is only necessary to check for the existence of any suffix and prefix extension events. If there isn't any, by Theorem 3, we can add the pattern P at to the set Closed.</p><p>Next, for any frequent pattern P at+ +e, following Theorem 4, we check for its infix extension events. If there is an infix extension event which does not appear in SeqDB all P at+ +e , we do not need to grow the pattern P at+ +e anymore.</p><p>Growing patterns is performed recursively. At each step, given an extension event e, the projected-all database of SeqDB all P at+ +e need to be computed. It can be computed incrementally by taking the projected-first database of SeqDB all P at (i.e. (SeqDB all P at ) f st e ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">PERFORMANCE STUDY</head><p>Experiments had been performed on both synthetic and real datasets to evaluate the scalability of our mining algorithm and the effectiveness of our pruning strategy. Similar to work in closed sequential pattern mining <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b29">29]</ref>, low support thresholds are utilized to test for scalability. Datasets. We use three datasets in our experiments: a synthetic and two real datasets. Synthetic data generator provided by IBM was used with modification to ensure generation of sequences of events. The generators accept a set of parameters. The parameters D, C, N and S correspond respectively to the number of sequences (in 1000s), the average number of events per sequence, the number of different events (in 1000s) and the average number of events in the maximal sequences. We experimented with the dataset D5C20N10S20.</p><p>We also experimented on click stream dataset (i.e., Gazelle dataset) from KDD Cup 2000 <ref type="bibr" target="#b19">[19]</ref> which was also used to evaluate CloSpan <ref type="bibr" target="#b31">[31]</ref> and BIDE <ref type="bibr" target="#b29">[29]</ref>. It contains 29369 sequences with an average length of 3 and a maximum length of 651.</p><p>To evaluate our algorithm performance on mining from program traces, we generate traces from a simple Traffic alert and Collision Avoidance System (TCAS) from the Siemens Test Suite <ref type="bibr" target="#b15">[15]</ref>, which has been used as one of the benchmarks for research in error localization (e.g., <ref type="bibr" target="#b8">[8]</ref>). The test suite comes with 1578 correct test cases. We run these test cases to obtain 1578 traces.</p><p>To test for scalability, instead of tracing method invocations, we trace executions of basic blocks of TCAS's control flow graph. A basic block is a maximal sequence of statements such that the execution of one statement will always results in the execution of the subsequent statements in the sequence. Each trace of basic block ids is treated as a sequence. The sequences are of average length of 36 and maximum length of 70. It contains 75 different events -the events are the basic block ids of the control flow graph of TCAS. We call this dataset the TCAS dataset. For the experiments we tested our pattern miner on two configurations to test the effectiveness of our pruning strategy. The first mines a closed set of iterative patterns while another mines a full set of iterative patterns. Let's refer the earlier as closed iterative pattern miner and the latter as full-set iterative pattern miner. Experiment Results and Analysis. The results of experiments performed on the D5C20N10S20, Gazelle and Siemens dataset using closed and full-set iterative pattern miners are shown in Figures <ref type="figure">2, 3</ref> &amp;<ref type="figure"></ref> 4 respectively. The Y-axis (in logscale) corresponds to the runtime taken or the number of generated patterns. The X-axis corresponds to the minimum support thresholds. The thresholds are reported rela-tive to the number of sequences in the database. Note that, different from sequential patterns, due to repeated patterns within a sequence this number can exceed 1.  From the plotted results it is noted that the pruning strategy significantly reduces the runtime and the number of patterns mined especially on low support threshold and when the reported patterns are long. Admittedly, when the numbers of closed and full-set of patterns differ by only a small factor, the overhead of mining closed patterns may result in longer runtime as compared to mining a full-set of patterns.</p><p>However, when the length of the patterns is long, the number of closed patterns is likely to be much less than that of a full-set of patterns.</p><p>For all datasets, even at very low support, closed pattern miner is able to complete within less than 17 minutes. TCAS dataset especially highlights performance benefit of our pruning strategy. Closed iterative pattern miner is able to run even at the lowest possible support threshold (at 1 instance) within less than 17 minutes. On the other hand, full-set iterative pattern miner runs with excessive runtime (&gt; 6 hours) even at a relatively high support threshold of 867 instances.</p><p>The above shows that our miner can efficiently perform its task on various benchmark data. Comparison of performance results of closed and full-set pattern miner highlights the benefit and effectiveness of our pruning strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CASE STUDY: JBOSS APP. SERVER</head><p>A case study was performed on the transaction component of JBoss Application Server (JBoss AS) <ref type="bibr" target="#b17">[17]</ref>. JBoss AS is the most commonly used J2EE application server. It contains over 100,000 lines of code and comments. The transaction component alone contains over 5,000 lines of code and comments. The purpose of this case study is to show the usefulness of the mined patterns by discovering iterative patterns describing behavior of the transaction sub-component of JBoss AS.</p><p>Traces are obtained by running JBoss-AOP <ref type="bibr" target="#b18">[18]</ref> over JUnit and Ant on a regression test of the JBoss AS transaction manager. We trace invocations of methods within the transaction component of JBoss AS (i.e., org.jboss.tm package). This produces 28 traces of a total of 2551 events and an average of 91 events. The longest trace is of 125 events. There are 64 unique events. Using min sup of 65%, the closed iterative pattern mining algorithm runs in less than a minute (29s). Full-set pattern mining doesn't terminate even after running for more than 8 hours and produces more than 5 GB of patterns.</p><p>There are a total of 44 patterns resulting from the following post-processing step after iterative pattern mining: 1. Density. Only report patterns whose number of unique events is &gt; 80% of its length. 2. Subsumption. Only report pattern P if none of its supersequences is frequent. 3. Ranking. Order them according to length and support values.</p><p>We found at least 5 interesting software patterns of behavior resulting from mining the traces. These correspond to the patterns of longest length and highest support. Their abstracted representations are as follows: The first 4 patterns correspond to the few of the longest patterns, the last pattern on lock and unlock events corresponds to the pattern with the highest support of 313. The actual mined pattern for the first pattern shown above, which is the longest pattern mined (of length 32), is shown in Figure <ref type="figure">5</ref>.</p><p>The first two patterns specify that a series of set up events is always followed by a series of termination events. The first pattern specifies a common behavior where: a connection is first set up to the server, the transaction manager is set up, the transaction is set up, the transaction is committed and the transaction is finally disposed. The second pattern specifies a similar behavior except that the transaction is being roll-backed.</p><p>The third and fourth patterns specify the pattern observed when the actual work is being performed. A resource need to be enlisted to the transaction and the transaction execution then take place. At the end of the execution, the transaction can either be committed or roll-backed. Note that there can be one or more resource enlistments and transaction executions before a commit. Hence the pattern is not included in the body of the first 2 patterns.</p><p>The fifth pattern corresponds to a more fine grained iterative pattern occurring most often, namely lock and unlock.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSION</head><p>In this paper, we propose iterative patterns -iterative patterns are commonly occurring series of events exhibited repeatedly within a sequence and across multiple sequences. We extend sequential pattern mining to consider repeated occurrences of pattern instances within sequences. We extend episode pattern mining by removing the constraint on window size and consider a database of sequences rather than a single sequence. To mine iterative pattern efficiently, we present CLosed Iterative Pattern MinER (CLIPER).</p><p>The motivation of our work comes from the emerging field of dynamic analysis where a set of program traces are analyzed to mine interesting software properties. Due to looping similar patterns occur within a sequence and across multiple sequences. Mining interesting patterns should take into account both multiple sequences, and multiple occurrences of patterns within a sequence. Also, since important patterns like lock acquire followed-by lock-release and file open followed-by file close (c.f., <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b7">7]</ref>) are often separated by a considerable number of events, we need to remove the window size constraint of frequent episode mining.</p><p>To reduce the number of reported patterns and improve efficiency, we mine for the set of closed iterative patterns. This reduces the run-time needed for mining patterns and aids user in analyzing important patterns by sifting out patterns "absorbed" by another.</p><p>Our performance study shows the efficiency of our method in both real-world and synthetic datasets. The effectiveness of our pruning strategy to mine closed patterns is evident by comparing the runtime and the number of patterns generated before and after the pruning strategy is employed. The set of interesting patterns mined from JBoss Application Server transaction component confirms the usefulness of our method in discovering software specifications in iterative pattern form.</p><p>Besides mining software behavioral pattern, we believe the proposed mining technique can potentially be applied to other knowledge discovery domains.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 3 . 3 (</head><label>33</label><figDesc>Pattern Instance -QRE). Given a pattern P (p1p2 . . . pn), a substring SB (sb1sb2 . . . sbm) of a sequence S in SeqDB is an instance of P iff it is of the following QRE expression p1; [-p1, . . . , pn] * ; p2; . . . ; [-p1, . . . , pn] * ; pn.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 4 . 3 (</head><label>43</label><figDesc>Operations on Projected DB). Projected databases DB1 and DB2 are equivalent (denoted as DB1 = DB2) iff |DB1| = |DB2| and ∀ (p1, s1)∈ DB1. ∃ (p2, s2) ∈ DB2. s1 = s2. Also, an event e is in a projected database DB (denoted as e ∈ DB) iff ∃(p, s) ∈ DB. e is an event in s. Consider the following running example. Let us have the following sequence database SeqDB shown</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>. The main procedure to compute the closed set of iterative patterns: MinePatterns, is shown at the top of the figure. It will call a recursive procedure MineRecurse shown at the bottom of the figure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: CLIPER Algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Environment and Pattern Miners. All experiments were performed on a Pentium 4 3.0GHz PC with 2GB main memory running Windows XP Professional. Algorithms were written using Visual C#.Net running under .Net Framework 2.0 with generics compiled with the release option using Visual Studio.Net 2005.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: Performance results of varying min sup for D5C20N10S20 dataset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Performance results of varying min sup for TCAS dataset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>in Table1. Sample SeqDB Support of pattern A, B, C can be found by first constructing the projected database of A . This is shown below in Table2</figDesc><table><row><cell cols="2">Identifier Sequence</cell></row><row><cell>S1</cell><cell>A, B, A, B, A, B, C, D, E</cell></row><row><cell>S2</cell><cell>A, B, B, B, B</cell></row><row><cell>S3</cell><cell>A, B, C, A, D, E, B, C</cell></row><row><cell>S4</cell><cell>A, B, C, C, A, B</cell></row><row><cell cols="2">Instance Remainder of Sequence</cell></row><row><cell>(1, 1, 1)</cell><cell>B, A, B, A, B, C, D, E</cell></row><row><cell>(1, 3, 3)</cell><cell>B, A, B, C, D, E</cell></row><row><cell>(1, 5, 5)</cell><cell>B, C, D, E</cell></row><row><cell>(2, 1, 1)</cell><cell>B, B, B, B</cell></row><row><cell>(3, 1, 1)</cell><cell>B, C, A, D, E, B, C</cell></row><row><cell>(3, 4, 4)</cell><cell>D, E, B, C</cell></row><row><cell>(4, 1, 1)</cell><cell>B, C, C, A, B</cell></row><row><cell>(4, 5, 5)</cell><cell>B</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Sample SeqDB all A</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 : Sample SeqDB all</head><label>3</label><figDesc></figDesc><table><row><cell>A,B</cell></row><row><cell>Finally, performing the inductive step of Definition 4.1 to</cell></row><row><cell>SeqDB all A,B will result in SeqDB all A,B,C from which sup-</cell></row><row><cell>port of A, B, C can be found. Equivalently, we apply</cell></row><row><cell>the projected-first projection to SeqDB all A,B with respect</cell></row><row><cell>to event C. The projected database is as shown below in</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 .</head><label>4</label><figDesc></figDesc><table><row><cell cols="2">Instance Remainder of Sequence</cell></row><row><cell>(1, 5, 7)</cell><cell>D, E</cell></row><row><cell>(3, 1, 3)</cell><cell>A, D, E, B, C</cell></row><row><cell>(3, 4, 8)</cell><cell></cell></row><row><cell>(4, 1, 3)</cell><cell>C, A, B</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 :</head><label>4</label><figDesc>Sample SeqDB all</figDesc><table /><note><p>A,B,C</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>1. Connection Set Up Evs, TxManager Set Up Evs, Transaction Set Up Evs, Transaction Commit Evs, Transaction Disposal Evs 2. Connection Set Up Evs, TxManager Set Up Evs, Transaction Set Up Evs, Transaction Rollback Evs, Transaction Disposal Evs 3. Resource Enlistment Evs, Transaction Execution Evs, Transaction Commit Evs, Transaction Disposal Evs 4. Resource Enlistment Evs, Transaction Execution Evs, Transaction Rollback Evs, Transaction Disposal Evs 5. Lock-Unlock Evs</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement. We would like to thank Jiawei Han and Shahar Maoz for their valuable comments. We wish to thank Blue Martini Software for contributing the KDD Cup 2000 data. This research is partially supported by an NUS research grant R-252-000-250-112, NSF ITR/CCR-0325603, IIS-05-13678, NSF BDI-05-15813, and IIS-02-42840.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mining sequential patterns</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Mining specification</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ammons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN POPL</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Testing Object-Oriented Systems Models, Patterns, and Tools</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Binder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Software Engineering Economics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981">1981</date>
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Software Maintenance, volume 1 of Handbook of Software Engineering and Knowledge Engineering</title>
		<author>
			<persName><forename type="first">G</forename><surname>Canfora</surname></persName>
		</author>
		<author>
			<persName><surname>Cimitile</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="page" from="91" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Light-weight product-lines for evolution and maintenance of web sites</title>
		<author>
			<persName><forename type="first">R</forename><surname>Capilla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Duenas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSMR</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Verifying safety policies with size properties and alias controls</title>
		<author>
			<persName><forename type="first">W-N</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S-C</forename><surname>Khoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Popeea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SOBER: statistical model-based bug localization</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Midkiff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGSOFT ESEC-FSE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">LSCs: Breathing life into message sequence charts</title>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="45" to="80" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Experiences in software product families: Problems and issues during product derivation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Deelstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sinnema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPLC</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">From run-time behavior to usage scenarios: an interaction-pattern mining approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>El-Ramly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Stroulia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sorenson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Leveraging legacy system dollars for e-business</title>
		<author>
			<persName><forename type="first">E</forename><surname>Erlikh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>IEEE IT Pro</publisher>
			<biblScope unit="page" from="17" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Discovering unbounded episodes in sequential data</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">C</forename><surname>Garriga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKDD</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Freespan: Frequent pattern-projected sequential pattern mining</title>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mortazavi-Asl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M-C</forename><surname>Hsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Experiments on the effectiveness of dataflow-and control-flow-based test adequacy criteria</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hutchins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Goradia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ostrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">Itu-T</forename><surname>Itu-T Recommendation</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename></persName>
		</author>
		<title level="m">Message Sequence Chart (MSC)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">120</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="http://www.jboss.org" />
		<title level="m">JBoss</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
		<ptr target="http://labs.jboss.com/jbossaop/" />
	</analytic>
	<monogr>
		<title level="j">JBoss AOP</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Kohavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Brodley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Frasca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zheng</surname></persName>
		</author>
		<title level="m">KDD-Cup 2000 organizers&apos; report: Peeling the onion. SIGKDD Explorations</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="86" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Temporal logic for scenario-based specifications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kugler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bontemps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Program Evolution -Processes of Software Change</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Belady</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">SMArTIC: Toward building an accurate, robust and scalable specification miner</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S-C</forename><surname>Khoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGSOFT FSE</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Discovery of frequent episodes in event sequences</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">I</forename><surname>Verkamo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DMKD</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="259" to="289" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cecil: A sequencing constraint language for automatic static analysis generation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Olender</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Osterweil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TSE</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="268" to="280" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Prefixspan: Mining sequential patterns efficiently by prefix-projected pattern growth</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Mortazavi-Asl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-C</forename><surname>Hsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Java</forename><surname>Trans</surname></persName>
		</author>
		<author>
			<persName><surname>Spec</surname></persName>
		</author>
		<ptr target="java.sun.com/products/jta/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An essay on software reuse</title>
		<author>
			<persName><forename type="first">T</forename><surname>Standish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TSE</title>
		<imprint>
			<biblScope unit="page" from="494" to="497" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Steel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nagappan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lai</surname></persName>
		</author>
		<title level="m">Core Security Patterns. Sun Microsystem</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">BIDE: Efficient mining of frequent closed sequences</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Mining temporal specifications for error detection</title>
		<author>
			<persName><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">CloSpan: Mining closed sequential patterns in large datasets</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Afhar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SDM</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Perracotta: Mining temporal API rules from imperfect traces</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bhat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Mining periodic patterns with gap requirement from sequences</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Y</forename><surname>Yip</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
