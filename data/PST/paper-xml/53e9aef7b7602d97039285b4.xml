<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ownership Transfer in Universe Types</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Peter</forename><surname>Müller</surname></persName>
							<email>mueller@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Microsoft Research</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Arsenii</forename><surname>Rudich</surname></persName>
							<email>arsenii.rudich@inf.ethz.ch</email>
							<affiliation key="aff1">
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Ownership Transfer in Universe Types</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5094CA192C788540D247D1D9FB7B6882</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:59+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D3.3 [Programming Languages]: Language Constructs General Terms Languages</term>
					<term>Verification Universe Types</term>
					<term>Ownership Transfer</term>
					<term>Aliasing</term>
					<term>Uniqueness</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Ownership simplifies reasoning about object-oriented programs by controlling aliasing and modifications of objects. Several type systems have been proposed to express and check ownership statically.</p><p>For ownership systems to be practical, they must allow objects to migrate from one owner to another. This ownership transfer is common and occurs, for instance, during the initialization of data structures and when data structures are merged. However, existing ownership type systems either do not support ownership transfer at all or they are too restrictive, give rather weak static guarantees, or require a high annotation overhead.</p><p>In this paper, we present UTT, an extension of Universe Types that supports ownership transfer. UTT combines ownership type checking with a modular static analysis to control references to transferable objects. UTT is very flexible because it permits temporary aliases, even across certain method calls. Nevertheless, it guarantees statically that a cluster of objects is externally-unique when it is transferred and, thus, that ownership transfer is type safe. UTT provides the same encapsulation as Universe Types and requires only negligible annotation overhead.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Ownership allows programmers to structure the object store and to control aliasing and modifications of objects. The ownership structure makes programs easier to understand, to maintain, and to reason about. Ownership has been used to Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA '07 October 21-25, Montréal, Québec, Canada. Copyright c ACM 978-1-59593-786-5/07/0010. . . $5.00 verify object invariants <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b33">34]</ref>, to show the absence of data races in multi-threaded programs <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b25">26]</ref>, to facilitate memory management for real-time programs <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9]</ref>, to check object immutability <ref type="bibr" target="#b23">[24]</ref>, and to prove representation independence <ref type="bibr" target="#b3">[4]</ref>.</p><p>In the existing ownership systems, each object has at most one owner object. The ownership relation is a tree order. We call the set of all objects with the same owner a context. The root context is the set of objects with no owner. Ownership type systems allow programmers to express and check ownership properties statically. In these type systems, a type conveys information about the class of an object as well as the object's owner. Besides the ownership topology, ownership type systems also enforce restrictions on references between objects in different contexts.</p><p>The owner of an object is first determined when the object is created. In many common designs, the owner is not fixed throughout an object's lifetime, but changes dynamically. The need for this ownership transfer is illustrated by the following examples:</p><p>• Merging data structures: data structures such as lists are merged efficiently by transferring the internal representation of one structure to the context of the other <ref type="bibr" target="#b14">[15]</ref>.</p><p>• Object initialization: constructors often take an existing object as parameter and then capture this object, that is, transfer ownership to the object being constructed <ref type="bibr" target="#b16">[17]</ref>. A special case of object initialization is the Factory pattern, where product objects are created in the context of a global factory and then transferred to the client <ref type="bibr" target="#b35">[36]</ref>.</p><p>• Work flow systems: tasks in work flow systems are transferred repeatedly from processor to processor.</p><p>The first example is illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>. A list consists of a main object of class List and a doubly-linked cyclic structure of Node objects. The node referenced by the List's first field is a dummy node to simplify the handling of empty lists. In our example, a List object owns its nodes. Therefore, efficient merging of two lists requires ownership transfer. We assume here that all nodes of a context are transferred together. The resulting structure is shown in Fig. <ref type="figure" target="#fig_13">2</ref>. Static type safety of an ownership type system means essentially that the static type of an expression e correctly reflects the owner of the object e evaluates to. Consequently,  Ownership structure after the nodes of List object 1 have been transferred to List object 4 and the two node structures have been merged. To preserve type safety, the first field of List object 1 is set to a fresh node in its context (object 8). The dummy Node object 2 is not reachable after the merge operation and will be garbage collected. in the presence of ownership transfer, objects may change their type dynamically. For instance, Node object 2 in Fig. <ref type="figure" target="#fig_0">1</ref> is owned by List object 1. This is reflected in the type of List's field first. In Universe Types <ref type="bibr" target="#b19">[20]</ref>, this field has type rep Node, where the rep modifier indicates that the referenced object is owned by this. However, after the transfer (Fig. <ref type="figure" target="#fig_13">2</ref>) Node object 2 is owned by List object 4.</p><p>Therefore, the rep modifier of the first field of List 1 does no longer reflect the owner of the referenced Node correctly. This is type safe only if the transfer sets the first field of List object 1 to a different value, for instance, a new dummy node, before the field is accessed again.</p><p>In general, type safety requires that the well-typedness of each variable (local variable, method parameter, or field) that is affected by an ownership transfer is re-established before the next access to the variable. To enforce this condition, an ownership type system must be able to determine statically all stack and heap locations that reference a transferred ob- ject. In general, this requires knowledge of the whole call stack-because method executions in progress may have local variables that point to the transferred objects-and knowledge of all subclasses-because a subclass may contain fields that point to the transferred objects.</p><p>For instance, consider an execution of method retain (Fig. <ref type="figure" target="#fig_2">3</ref>) with List object 1 as receiver and List object 4 as parameter. In the state before calling merge (illustrated by Fig. <ref type="figure" target="#fig_0">1</ref>), local variable node3 holds a reference to Node object 3. The well-typedness of node3 is violated when merge transfers the nodes of this to list4. In the state after the call (Fig. <ref type="figure" target="#fig_13">2</ref>), node3 points to an object owned by list4, even though its rep modifier indicates that the object is owned by this. Method retain exploits the illtypedness of node3 to destroy the link structure of list4's nodes by setting the next field of node3 to null. To avoid this problem, node3's well-typedness must be re-established after the call to merge. However, this cannot be done by method merge because node3 is not in the stack frame of merge.</p><p>To prevent the problem of ill-typed aliases on transferred objects, existing type systems for ownership transfer use uniqueness <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b31">32]</ref> to control the possible references to objects that may be transferred. A reference is unique if the referenced object is not aliased. Unique variables may only hold unique references and the null value. Therefore, trans- ferring an object using a unique variable does not affect any other stack or heap locations, and it suffices to assign a new value to the unique variable. If all objects of a context are transferred together, it even suffices to guarantee that there is only one reference from the owner into the whole context, whereas aliasing within the context is not restricted. This notion of external uniqueness <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b41">42]</ref> is far more expressive. For instance, the first references in Fig. <ref type="figure" target="#fig_0">1</ref> are not unique in the strict sense because the nodes are also referenced by their neighbor nodes. However, they are externally-unique because all other references to Node objects come from objects within the context.</p><p>The problem with method retain is caused by the fact that the first field of List object 1 is not externally-unique when the lists are merged because the local variable node3 holds a second reference into the context of List 1.</p><p>Although (external) uniqueness enables type-safe ownership transfer, the existing techniques building on (external) uniqueness have severe shortcomings: (1) They impose a high annotation overhead on programmers. (2) Even external uniqueness is too restrictive for common implementations. For instance, when a list stores references to its first and last node, these references are not externally-unique. (3) Some of the techniques provide encapsulation that is too weak for certain applications of ownership such as the verification of object invariants. We explain these shortcomings in more detail in the next section.</p><p>In this paper, we present an extension of Universe Types <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref> that supports ownership transfer. Our system combines ownership type checking with a static analysis to enforce an alias invariant that is even less restrictive than external uniqueness. This alias invariant permits temporary aliases on transferable objects. In particular, a context need not be externally-unique while a method executes on an object inside this context. This provides flexibility that is needed in many implementations. On the other hand, our alias invariant is strong enough to obtain an externallyunique reference on a cluster of objects and to transfer the cluster in a type-safe way. The alias invariant is enforced by a modular, intraprocedural static analysis. This analysis makes each variable that is potentially affected by a transfer unusable and enforces that it is assigned a new value before it is accessed. For instance, our static analysis would make the variable node3 in method retain (Fig. <ref type="figure" target="#fig_2">3</ref>) unusable, thereby preventing its abuse after the transfer.</p><p>Our approach solves the shortcomings of the existing approaches based on uniqueness. The main contributions are:</p><p>• An alias invariant that is less restrictive than external uniqueness, but strong enough to enable type-safe ownership transfer. In particular, it permits several external references on transferable objects.</p><p>• A modular static analysis to enforce the alias invariant. This analysis requires only negligible annotation overhead.</p><p>• An extension of Universe Types to support ownership transfer. The extended type system can handle almost all common examples for ownership transfer. Like Universe Types, it enforces the owner-as-modifier discipline, which enables the verification of object invariants <ref type="bibr" target="#b33">[34]</ref>.</p><p>Outline. In the next section, we discuss existing work on (external) uniqueness. Sec. 3 provides the background on Universe Types that is needed in the rest of the paper. Our approach to ownership transfer in explained in Sec. 4 and formalized in Sec. 5. Sec. 6 illustrates our technique by examples. We present an informal soundness theorem in Sec. 7. We describe our implementation in Sec. 8, discuss related work in Sec. 9, and offer conclusions in Sec. 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background on Uniqueness</head><p>A very strong notion of uniqueness is to enforce that unique variables hold unique references (or null) in all execution states. This is typically achieved using destructive reads, which assign null to a unique variable when it is read <ref type="bibr" target="#b24">[25]</ref>.</p><p>Enforcing uniqueness in all execution states is overly restrictive. For instance, calling a method on the unique field f creates a temporary alias on the stack and, therefore, nullifies f . This is cumbersome since the caller has to restore the value of f after the call. Moreover, destructive reads suffer from several problems <ref type="bibr" target="#b10">[11]</ref>: (1) They require a change of the language semantics, which is unintuitive for programmers. ( <ref type="formula">2</ref>) They make it difficult to query information about the unique object, especially in side-effect free methods.</p><p>(3) They are not compatible with non-null type systems <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b22">23]</ref>.</p><p>A more practical approach is to permit unique objects to be temporarily aliased from stack locations. Temporary aliases enable method calls on unique variables without nullifying the receiver. Techniques that allow temporary aliases on unique objects have to address two problems:</p><p>1. Callbacks: If a method with receiver o calls another method m while o's unique fields are temporary aliased, m must be prevented from calling back into o under the false assumption that o's unique fields are actually unique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Capturing:</head><p>A method that receives a temporary alias of a unique object must be prevented from storing this reference in a field, which would create a permanent alias from a heap location.</p><p>In the following, we discuss how existing approaches solve these problems. Clarke and Wrigstad <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b41">42]</ref> enforce external uniqueness, but permit temporary aliases. They use borrowing to handle callbacks and capturing. borrow blocks permit temporary aliases on unique objects. When a unique field f is borrowed, its value is copied into a non-unique local variable l, which can then be used in method calls. The callback problem is prevented by nullifying f at the beginning of the borrow block. Therefore, callbacks do not find the external uniqueness invariant violated. Capturing is prevented by giving l a fresh owner such that storing the reference in a field is prevented by the ownership type system. At the end of a borrow block, the value of f is restored. Borrowing permits temporary aliases on unique objects in a safe way. However, it introduces annotation overhead and requires ownerpolymorphic methods to support the fresh owner of a borrowed object. Moreover, assigning null to the borrowed variable leads to similar problems as destructive reads.</p><p>AliasJava <ref type="bibr" target="#b1">[2]</ref> permits temporary aliases through lent references. A lent reference may point to unique objects in any ownership context. The types of lent references do not convey ownership information. Therefore, lent references do not compromise the type safety of ownership transfer. Lent references are the only temporary aliases to an otherwise unique object. Assigning a unique variable to a non-lent variable makes the unique variable unusable. To prevent the callback problem, a new unique value must be assigned to each unusable unique field before the next method call. Capturing is prevented by disallowing lent references to be stored in fields. Lent references permit type-safe ownership transfer. However, they weaken encapsulation drastically because they may point to arbitrary ownership contexts and may be used to modify objects. For instance, method retain (Fig. <ref type="figure" target="#fig_2">3</ref>) type checks in AliasJava if node3 is declared lent. This lent variable is used to break list4's encapsulation and to destroy its link structure. It is unclear how to maintain object invariants in the presence of lent references <ref type="bibr" target="#b33">[34]</ref>.</p><p>Alias burying <ref type="bibr" target="#b9">[10]</ref> relies on a static analysis to track temporary aliases on unique objects. Whenever a unique variable is read, all existing aliases become unusable. Therefore, a unique variable effectively behaves as if it was actually unique even though unusable aliases may exist. To prevent capturing, unique variables may be passed to methods only as borrowed parameters. Like lent variables in Alias-Java, borrowed parameters cannot be stored in fields. To handle callbacks, methods are annotated with read effects. If a method potentially reads a unique field f , all temporary aliases of f are made unusable before the method is called. Therefore, every field read by a method is effectively unique, including fields that are read during callbacks. Alias burying permits temporary aliasing without destructive reads and borrowing. However, it has major drawbacks. Its expressiveness is limited by the underlying static analysis. Moreover, borrowed annotations and read effects cause a high annotation overhead.</p><p>Capabilities systems <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b21">22]</ref> model uniqueness through universal capabilities, which permit arbitrary access to an object. Callbacks are handled by annotating methods with the capabilities they expect. Therefore, a method expecting a field f to be unique cannot be called while f is aliased because the caller cannot provide the expected capabilities. Capturing is handled by passing capabilities. If a caller of a method m passes the capabilities of an argument p to m then the caller will not consider p to be unique after the call unless m returns the capabilities back to the caller. If the capabilities are not retained by m, m can capture the argument, but not use it since it does not have the necessary capabilities. While capabilities systems are very flexible, they require a large overhead because methods have to be annotated with the capabilities they expect and return. Moreover, capabilities have not been integrated with ownership type systems and external uniqueness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Background on Universe Types</head><p>Universe Types <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref> is an ownership type system that permits arbitrary aliasing, but restricts modifications of ob-  jects. In this section, we explain the main concepts of Universe Types by an example. A formalization of non-generic Universe Types in Isabelle is given in <ref type="bibr" target="#b26">[27]</ref>, and a formalization of Generic Universe Types is presented in <ref type="bibr" target="#b17">[18]</ref>.</p><p>Ownership Modifiers. A type consists of an ownership modifier and a class name. The ownership modifier expresses object ownership relative to the current receiver object this<ref type="foot" target="#foot_0">1</ref> . Programs may contain the ownership modifiers peer, rep, and any. peer expresses that an object has the same owner as the this object, rep expresses that an object is owned by this, and any expresses that an object may have any owner. any types are supertypes of the rep and peer types with the same class because they convey less specific ownership information.</p><p>The use of ownership modifiers is illustrated by classes List (Fig. <ref type="figure" target="#fig_3">4</ref>) and Node (Fig. <ref type="figure" target="#fig_4">5</ref>), which implement a doublylinked list of objects. For simplicity, we omit access modifiers from all examples. A List object owns its Node objects since they form the internal representation of the list and should, therefore, be protected from unwanted modifications. This ownership relation is expressed by the rep modifier of List's field first, which points to the dummy node of the list. All nodes of a list have the same owner, therefore, the prev and next fields of Node have a peer modifier. Finally, the elements stored in the list may have any owner, which is indicated by the any modifier of Node's elem field.</p><p>Owner-as-Modifier Discipline. Universe Types allow an object o to be referenced by any other object, but reference chains that do not pass through o's owner must not be used to modify o. This allows owner objects to control modifications of owned objects, for instance, to maintain invariants. This owner-as-modifier discipline is enforced by disallowing modifications of objects through any references. That is, an expression of an any type may be used as receiver of field reads and calls to side-effect free (pure) methods, but not of field updates or calls to non-pure methods. To check Viewpoint Adaptation. Since ownership modifiers express ownership relative to this, they have to be adapted when this "viewpoint" changes. Consider the second parameter of Node's second constructor. The peer modifier expresses that the parameter object must have the same owner as the receiver of the constructor. On the other hand, List's method add calls the constructor on a rep receiver, that is, an object that is owned by this. Therefore, the second parameter of the constructor call also has to be owned by this. This means that from this particular call's viewpoint, the second parameter needs a rep modifier, although it is declared with a peer modifier. In the type system, this viewpoint adaptation is done by combining the modifier of the receiver of a call (here, rep) with the modifier of the formal parameter (here, peer). This combination yields the argument modifier from the caller's point of view (here, rep).</p><p>Field accesses and calls on receiver this do not require any viewpoint adaptation, because the viewpoint does not change. We model this behavior by an additional ownership modifier this, which is used internally by the type system for the this variable. Combining the this modifier with any modifier u yields u. In particular, for a rep field f , the field access this.f has a rep type, whereas for any other receiver p, the field access p.f has an any type. This allows us to keep the contexts of different objects separate.</p><p>Runtime Model. Each object stores a reference to its owner. The owner of an object is determined by the creation expression. For instance, the rep modifier in the initialization of List's first field (Fig. <ref type="figure" target="#fig_3">4</ref>) indicates that the new object is owned by this. The runtime ownership information is used to check downcasts from any to rep or peer types as well as to evaluate instanceof expressions.</p><p>Universe Invariant. Universe Types guarantee the following properties <ref type="bibr" target="#b26">[27]</ref>:</p><p>1. Type safety: The ownership modifier of the type of a welltyped expression e correctly reflects the owner of the object e evaluates to.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Tree order:</head><p>In all execution states of a well-typed program, the ownership relation among the objects in the heap is a tree order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Owner-as-modifier:</head><p>The evaluation of a well-typed expression modifies only those objects that are (transitively)</p><p>owned by the owner of this.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Ownership Transfer</head><p>Our solution to ownership transfer builds on external uniqueness <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b41">42]</ref>. Like in Clarke and Wrigstad's work, we transfer whole groups of objects, for instance, all nodes of a doubly-linked list. We call such a group a cluster.</p><p>We provide a release statement to obtain an externallyunique reference into a cluster. A capture statement uses an externally-unique reference to transfer the cluster.</p><p>In this section, we extend Universe Types to support clusters, present the release and capture statements, and discuss the alias invariant that enables type-safe ownership transfer. The type rules and static analysis to maintain this alias invariant are presented in Sec. 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Clusters</head><p>Clusters can be handled by a simple extension of Universe Types. We call the extended type system Universe Types with Transfer or UTT for short. We explain the extensions in the following.</p><p>Clusters are declared explicitly by a class member declaration of the form cluster cn, where cn is a globally unique cluster name. We illustrate the use of clusters by a revised version of the doubly-linked list (class MList in Fig. <ref type="figure" target="#fig_5">6</ref>). This list implementation declares a cluster R to store the nodes.</p><p>In UTT, an object is owned by a pair consisting of an owner object and a cluster name. This pair uniquely identifies a cluster. Objects in the root context are owned by &lt;null, root&gt;. We use the phrase the cluster cn of an object o to refer to the cluster of objects owned by &lt;o, cn&gt;.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.1 (External reference). A reference is an external reference into the cluster cn of an object o if and only if the following conditions hold:</head><p>1. The origin of the reference is external to the cluster, that is, the variable holding the reference is either a field of an object that is not (transitively) owned by &lt;o, cn&gt; or a stack location of a stack frame whose receiver object is not (transitively) owned by &lt;o, cn&gt;. 2. The target of the reference is internal to the cluster, that is, the reference points to an object (transitively) owned by &lt;o, cn&gt;.</p><p>3. The reference is not an any reference.</p><p>Since any references do not convey any ownership information, they are not affected by ownership transfer and, thus, are not considered external. Type safety guarantees that the variable holding the external reference into o's cn cluster is a field of o or a variable in a stack frame for a method execution on receiver o.</p><p>We use a static analysis to control external references into clusters. As explained in Sec. 5.4, this analysis makes certain variables unusable, that is, enforces that new values are assigned to these variables before they are accessed. We say that a reference is unusable if it is held by an unusable variable.   Type-safe ownership transfer requires restrictions on the external references into a cluster. Since these restrictions are not met by all implementations, it is useful to distinguish between transferable and non-transferable clusters. External references into non-transferable clusters need not be restricted beyond the encapsulation of Universe Types. To simplify the presentation, we do not consider non-transferable clusters in this paper. However, our implementation <ref type="bibr" target="#b40">[41]</ref> and the formalization in our technical report <ref type="bibr" target="#b34">[35]</ref> support them.</p><p>Ownership Modifiers. The peer modifier indicates that two objects belong to the same cluster, that is, have the same owner object and cluster name. Like in Universe Types, the any modifier does not provide any ownership information, neither about owner objects nor about cluster names.</p><p>We replace the rep modifier of Universe Types by a para- metric version rep cn that specifies a cluster name. For instance, the modifier rep R in the declaration of MList's field first indicates that the node is in the R cluster of this. The modifier rep cn may be used in the class C that declares cn and its subclasses. However, we impose an additional restriction on field declarations: Fields with the modifier rep cn may be declared only in class C, but not in C's subclasses. This restriction guarantees that the only fields that are affected by a transfer of cluster cn are declared in class C and, thus, can be found by a modular analysis.</p><p>The ownership modifier free indicates that a reference is externally-unique. In our system, external uniqueness is enforced at the time a cluster is transferred, but typically not maintained over many execution states because every access to a free variable destroys its external uniqueness. Conse- quently, we disallow the free modifier in the declaration of a field. Accessing a field or calling a method on a free receiver yields an any reference, unless the modifier of the method is free. This ensures that the receiver reference stays externally-unique. Calling a method with a free return type yields a free reference, independent of the modifier of the receiver. For instance, the call l.getNodes() in MList's method merge has type free Node.</p><p>Runtime Model. Besides its owner object, each object stores the name of the cluster it belongs to. The cluster information is used to check downcasts from any to rep cn types. Like the owner object, the cluster name is first determined when the object is created. For instance, the dummy node created in the initializer of first (Fig. <ref type="figure" target="#fig_5">6</ref>) is owned by &lt;this, R&gt;. A new object of type free T is put into a new free cluster. A cluster is free if the objects in the cluster are owned by &lt;null, cf &gt;, where cf is a fresh cluster name that is not used in the program. In the following, we use cf as cluster name for free clusters and cn for non-free clusters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Release and Capture</head><p>Ownership transfer is performed by a combination of two polymorphic statements, release and capture. The release statement takes an argument of type rep cn T and transfers all objects in the cn cluster of this to a new free cluster. The release operation returns its argument, but with static type free T . Our static analysis ensures that the reference is actually externally-unique by making all other external references unusable.</p><p>The capture statement takes an argument y of type free T and an ownership modifier u. It transfers the objects in the free cluster containing y to the owner indicated by u. The modifier u must be peer or rep cn , because any and free do not indicate an owner. The capture operation returns y, but with static type u T .</p><p>MList's method getNodes uses the release statement to obtain an externally-unique reference res to the dummy node. Fig. <ref type="figure" target="#fig_9">8</ref> shows the object structure after releasing the R cluster of MList object 1. The field first still references the dummy node. However, to enforce that res is externally-unique, our static analysis makes first unusable. Method getNodes returns an externally-unique reference into the free cluster after setting first to a new dummy node. Method merge calls getNodes to obtain a free reference to the first node of list l. It then uses capture to transfer l's nodes to the R cluster of this. After the capture, the nodes of both lists are in the same cluster and can be merged.</p><p>Note that the release statement can be used to release clusters of this, but not of any other object. For instance, method merge cannot directly release l's nodes because the field access l.first has an any type, whereas the release statement expects a rep cn argument. Therefore, merge must call method getNodes on l to release the nodes. This restriction of release improves encapsulation because it prevents objects from "stealing" another object's cluster.</p><p>release and capture change the owner of the objects in the released and captured clusters. Therefore, both statements have side-effects and must not be used in pure methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Alias Invariant</head><p>UTT restricts external references into clusters as described by the following confinement property. When the this object is confined, a static analysis can determine modularly all variables that point into a cluster of this and to make them unusable when the cluster is released. For Case 1, we know that v is declared in the class C that declares cn because field declarations may only mention cluster names declared in the enclosing class. Therefore, we can determine all variables affected by releasing cn by inspecting the fields of C and local variables and parameters of the enclosing method. Note that the confinement property does not restrict any references since we do not consider any references to be external references (see Def. 4.1).</p><p>The capturing problem described in Sec. 2 violates confinement by storing an external reference into o's cn cluster in a field of an object different from o. In our system, this is prevented by viewpoint adaptation. Consider a method call x.m(p) where p is a temporary alias into a cluster of the current receiver o. We may assume that p has modifier This definition allows confinement to be violated in two situations. First, while a pure method is executed; since pure methods must not perform release statements, they do not rely on confinement. Second, for a (transitive) owner object o of the current receiver. This is possible because m can neither release a cluster of o (because o is different from this) nor call a non-pure method of o to perform the release. Therefore, it does not rely on o being confined. MList object 1 is not confined since p holds a reference into the R cluster, but is not a local variable of the current method execution. This violation is permitted because the MList object 1 is the owner object of the current receiver, Node object 2.</p><p>Permitting (transitive) owners of this not to be confined enables a very natural programming style as we illustrate by method reverse of class MList (Fig. <ref type="figure" target="#fig_5">6</ref>). Let's assume that reverse is executed on receiver x. The first assignment to p creates an additional external reference into the R cluster of x. During the execution of flip, x is not confined because p holds an external reference into the R cluster of x, but is not a variable of the current method execution (see Fig. <ref type="figure" target="#fig_11">9</ref>). This violation is permitted by the alias invariant because x is the owner of p. Therefore, p need not be made unusable before the call to flip. When the call terminates, x is confined again and we know that p still points into the R cluster of x because this cluster cannot be transferred by flip.</p><p>The treatment of temporary aliases and calls on owned objects is one of the key virtues of our technique. We need neither borrowing <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b41">42]</ref> nor read effects <ref type="bibr" target="#b9">[10]</ref> to handle the call to p.flip because callbacks are prevented by the type system. We also do not have to prevent flip from storing its receiver in a field because this would not create an external reference. In contrast to alias burying <ref type="bibr" target="#b9">[10]</ref>, our static analysis does not make p unusable when the field first is read in the condition of the loop. This is because we do not enforce external uniqueness when a variable is read, but only at the time of a transfer.</p><p>In summary, our alias invariant:</p><p>• does not restrict references within a cluster (since we use external uniqueness),</p><p>• does not restrict references from any variables (which are not considered external references),</p><p>• does not require the owner objects of the current receiver to be confined (since our type system prevents callbacks to these objects via non-pure methods), and</p><p>• does not require confinedness while a pure method is executed (since pure methods must not transfer objects).</p><p>Each of these exceptions to the standard notion of uniqueness makes our system more flexible without losing static type safety.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Formalization</head><p>In this section, we present the UTT rules for a subset of Java including classes and inheritance, instance fields, dynamically-bound methods, and the usual operations on objects (allocation, field read, field update, casts). For simplicity, we omit several features of Java such as interfaces, exceptions, constructors, static fields and methods, inner classes, primitive types and the corresponding expressions, and all statements for control flow. We do not expect that any of these features is difficult to handle. We only show the static rules here. A full formalization including the runtime model, operational semantics, and proofs is presented in our technical report <ref type="bibr" target="#b34">[35]</ref>.</p><p>Judgments. Our formalization uses the following two main judgments. A type judgment has the form Γ; U s and expresses that statement s is well-typed in a declaration environment Γ. U is the set of unusable variables before the execution of s as defined by the static analysis in Sec. 5.4.</p><p>The judgment Γ; U s : U expresses that U is the set of unusable variables after statement s if U is the set of unusable variables before s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Programming Language</head><p>Fig. <ref type="figure" target="#fig_12">10</ref> summarizes the syntax of our language. We assume that all identifiers of a program are globally unique except for this as well as method and parameter names of overrid- den methods. This can be achieved easily by preceding each identifier with the class or method name of its declaration (but we omit this prefix in our examples). T denotes a sequence of T s. In such a sequence, we denote the i-th element by T i . We sometimes use sequences of tuples S = X T as maps and use a function-like notation to access an element S(X i ) = T i .</p><p>A program P consists of a sequence of classes. We keep the current program implicit in the notations. Each class Cls has a class identifier C, a superclass C , a list of cluster declarations cn, a list of field declarations T f , and a list of method declarations M . F ieldId is the set of all field identifiers. A type T consists of an ownership modifier u and a class identifier C.</p><p>A method M consists of a result type T , a method name m, exactly one formal parameter T x, a list of local variable declarations T x, and a statement s. The method returns the value of the predefined local variable res. V arId is the set of variable names containing this, the explicit formal method parameter, and all local variables including res. For simplicity, we do not support pure methods in our formalization, but we include them in the discussion. An extension to pure methods is straightforward and does not reveal any interesting aspects.</p><p>The set of statements includes assignment, field read, field update, method call, object creation, cast, sequential composition, release, and capture. We provide the usual expressions in the form of assignment statements because our static analysis depends on the modifier of the variable a value is assigned to. For instance, reading a free variable does not create an external reference if the value is assigned to an any variable. This form is obtained by introducing auxiliary variables for sub-expressions. These variables have the static types (including the ownership modifiers) of the corresponding sub-expressions. For simplicity, we omit all literals including null.</p><p>A declaration environment Γ maps this, the formal method parameter, and all local variables to their types.  A method m is well-formed in a class C if the statement s constituting its body is well-typed in the environment Γ. The types of the parameter, result, and local variables must be well-formed in Γ, and m must respect the rule for overriding, see below. Γ maps m's formal parameter and declared local variables to their declared types, this to the type this C, and the result variable res to m's result type (WF-METHOD). Moreover, after the method body s, neither the result variable nor any field is unusable. Method m respects the rule for overriding if it does not override a method or if all overridden methods have the identical signature (WF-OVERRIDE). Function mType yields the signature of a method m in a class C, and is undefined if C does not contain a method m.</p><formula xml:id="formula_0">WF-TYPE u = rep cn ⇒ Γ(this) = this C0∧ ∧cn ∈ clusters(C 0 ) Γ wf u C WF-OVERRIDE (∀C : C ≤ C ⇒ mType(C , m) is undefined ∨ mType(C, m) = mType(C , m)) override(C, m) WF-METHOD Γ = p T p , y T , this (this C), res T r Γ wf T p , T , T r override(C, m) Γ; ∅ s Γ; ∅ s : U (F ieldId ∪ {res}) ∩ U = ∅ C wf T r m(T p p) {T y; s} WF-CLASS C wf M Ti = ui Ci ui = free (ui = rep cn ⇒ cn ∈ cn) wf class C extends C {cn; T f ; M }</formula><p>A class C is well-formed if all of its methods are wellformed, none of the fields has ownership modifier free, and all cluster names used in field declarations are declared in C (WF-CLASS). As discussed in Sec. 4.3, the last constraint allows us to determine all fields affected by a release statement by inspecting the fields that are declared in the same class as the released cluster. In particular, this analysis does not have to consider fields of subclasses, which is important for modularity.</p><p>Well-formed programs do not contain the ownership modifier this. We do not make this requirement explicit in our rules. The this modifier is used implicitly for the this variable as shown by the definition of Γ in WF-TYPE and WF-METHOD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Type Rules</head><p>Two types u 1 C 1 and u 2 C 2 are subtypes (denoted by</p><formula xml:id="formula_1">u 1 C 1 ≤ u 2 C 2 ) if (1) C 1 is a subclass of C 2 according</formula><p>to the rules of Java and (2) the ownership modifiers are identical, u 2 is any, or u 1 is this and u 2 is peer.</p><p>The type rules are presented in Fig. <ref type="figure" target="#fig_13">12</ref>. The judgment Γ; U s expresses that statement s is well-typed in environment Γ and unusable-set U. Our type rules implicitly require types to be well-formed, that is, a type rule is applicable only if all types involved in the rule are well-formed in the respective environment. All rules require that no unusable parameter, local variable, or field of this is read. Our type rules implicitly require types to be well-formed in the respective environment.</p><p>The rules for assignment (T-ASSIGN), object creation (T-NEW), and sequential composition (T-COMP) are straightforward. As explained in Sec. 3, the ownership modifier of a field access is determined by combining the modifier of the receiver and the modifier of the field (T-READ). The function fType(C, f ) yields the declared type of a field f that is declared in or inherited by class C.</p><p>For a field update, the right-hand side variable must be a subtype of the viewpoint-adapted field type (T-WRITE). The rule is analogous to field read, but has two additional requirements. First, the modifier of the receiver variable must not be any or free. any is forbidden to enforce the owner-as-modifier discipline. It would be type safe to permit updates of any fields on free receivers, but we forbid this for simplicity. Second, a rep cn field f must be updated through receiver this. Otherwise, the viewpoint adaptation u£u f yields any, but it is obviously unsafe to update f with an object with an arbitrary owner.</p><p>The rule for method calls (T-CALL) is in many ways similar to field reads (for result passing) and updates (for argument passing). The last antecedent of T-CALL requires that the unusable set does not contain any fields. This is necessary to ensure that the invoked method may assume all fields to be usable.</p><p>T-CAST could be strengthened to prevent more cast errors statically, but we omit this check since it is not strictly needed. Casts from any types to free types are forbidden because we cannot ensure efficiently that the right-hand side reference is actually externally-unique.</p><p>T-RELEASE requires the argument y to have a rep cn type. It yields a free reference. T-CAPTURE requires the captured variable to have a free type. The ownership modifier u must determine an owner, that is, must be peer or rep cn .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Static Analysis</head><p>In this subsection, we present a modular, intraprocedural static analysis to determine unusable variables. The static analysis makes the following variables unusable: First, free variables if it is not statically guaranteed that the reference held by the free variable is actually externally-unique. Second, variables of rep cn types if the cluster is potentially transferred. Our static analysis computes for each program point a set U of unusable variables. U is a subset of the fields declared in or inherited by the enclosing class as well as the parameters and local variables of the enclosing method. The rules of the static analysis are presented in Fig. <ref type="figure" target="#fig_15">13</ref>. The judgment Γ; U s : U expresses that in an environment Γ, U is the unusable-set after the statement s if U is the unusable-set before the statement.</p><formula xml:id="formula_2">T-ASSIGN Γ(y) ≤ Γ(x) y / ∈ U Γ; U x := y T-NEW u = any u C ≤ Γ(x) Γ; U x := new u C T-COMP Γ; U s1 Γ; U s2 Γ; U s1 : U Γ; U s1 s2 T-READ Γ(y) = u C u f C f = fType(C, f ) (u £ u f ) C f ≤ Γ(x) y / ∈ U y = this ⇒ f / ∈ U Γ; U x := y.f T-WRITE Γ(x) = u C u f C f = fType(C, f ) Γ(y) ≤ (u £ u f ) C f u ∈ {any, free} u f = rep cn ⇒ x = this x, y / ∈ U Γ; U x.f := y T-CALL Γ(y) = u C mType(C, m) = up Cp → ur Cr Γ(z) ≤ (u £ u p ) C p (u £ u r ) C r ≤ Γ(x) u ∈ {any, free} u p = rep cn ⇒ y = this y, z / ∈ U F ieldId ∩ U = ∅ Γ; U x := y.m(z) T-CAST Γ(y) = u y C y u C ≤ Γ(x) u C ≤ u y C y u = free ⇒ u y = free y / ∈ U Γ; U x := (u C) y T-RELEASE Γ(x) = free C Γ(y) = rep cn C y / ∈ U Γ; U x := release(y) T-CAPTURE Γ(x) = u C Γ(y) = free C u ∈ {peer, rep cn } y / ∈ U Γ; U x := capture(y,u) Figure 12. Type rules. U-ASSIGN Γ(x) = ux Cx Γ(y) = uy Cy U = if (ux = any ∨ uy = free) then U else U ∪ {y} Γ; U x := y : U \ {x} U-NEW Γ; U x := new T : U \ {x} U-COMP Γ; U s1 : U1 Γ; U1 s2 : U2 Γ; U s 1 ; s 2 : U 2 U-READ Γ; U x := y.f : U \ {x} U-WRITE U = if (x = this) then U \ {f } else U Γ; U x.f := y : U U-CALL mType(Cy, m) = up Cp → Tr Γ(y) = uy Cy Γ(z) = uz Cz U 1 = if (u p = any ∨ u z = free) then U else U ∪ {z} U 2 = if (u y / ∈ {peer, this}) then U 1 else U 1 ∪ {v ∈ dom(Γ) | Γ(v) = rep C v } Γ; U x := y.m(z) : U 2 \ {x} U-CAST Γ(x) = u x C x Γ(y) = u y C y U = if (u x = any ∨ u y = free) then U else U ∪ {y} Γ; U x := (T ) y : U \ {x} U-RELEASE Γ(y) = u y C y Γ(this) = this C 0 U = U ∪ {v ∈ dom(Γ) | Γ(v) = u y C v } ∪ {f ∈ fields(C 0 ) | fType(C 0 , f ) = u y C f } Γ; U x := release(y) : U \ {x} U-CAPTURE U = U ∪ {y} Γ; U x := capture(y,u) : U \ {x}</formula><p>Assigning to a variable x removes x from the unusable set (U-ASSIGN). The right-hand side variable y becomes unusable if it has a free type and x does not have an any type. Under this condition, the assignment creates an external reference into the cluster into which y points such that y is no longer externally-unique and, thus, must become unusable.</p><p>Creating a new object makes the left-hand side variable x usable (U-NEW). The rule for sequential composition is straightforward (U-COMP).</p><p>Field read (U-READ) is similar to assignment, but simpler because the field f and, therefore, the right-hand side cannot have a free type. Updating a field removes it from the unusable set if the receiver is this. Since the static analysis only tracks fields of this, there is no effect for other receivers.</p><p>The most interesting rule handles method calls (U-CALL). Analogously to assignments, the actual argument z becomes unusable if it has modifier free and is passed to a non-any parameter. If the receiver has a peer or this modifier then all parameters and local variables with a rep modifier become unusable. These variables hold external references into clusters that are potentially transferred by the called method if this method is executed on receiver this or calls back into this. Therefore, we conservatively make these variables unusable. Note that this is only done for peer or this receivers. For rep cn receivers, UTT prevents callbacks into this via non-pure methods. Even in the presence of pure methods, this rule is sufficient because pure methods must not release any cluster.</p><p>Even though our treatment of calls on receivers with a peer or this modifier is conservative, it is not a severe restriction in practice. Local variables with a peer or any modifier remain usable after the call (as do variables pointing into non-transferable clusters <ref type="bibr" target="#b34">[35]</ref>). Moreover, the value of a variable with a rep cn modifier can be carried over by assigning it to an any variable before the call and casting it back to a rep cn modifier after the call. The runtime check associated with the cast fails if the cluster has been transferred by the call. This allows programmers to by-pass our conservative type rules in cases they know that a certain cluster is not transferred by a method call. Casts are completely analogous to assignments (U-CAST). A release(y) operation makes all variables un- usable that point into the released cluster. These are the parameters and local variables with the same ownership modifier as y as well as all fields declared in or inherited by the enclosing class with this modifier. This guarantees that the reference returned by the release is externally-unique. capture makes the captured variables unusable because it is no longer externally-unique. Note that the static analysis only tracks parameters and locals of the enclosing method as well as fields of the enclosing class and its superclasses. Therefore, the analysis is fully modular and intraprocedural. An interprocedural analysis would permit a less conservative call rule for receivers with modifier peer and this. However, in the presence of dynamic method binding, interprocedural analyses are inherently non-modular because they require knowledge of all method overrides.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Examples</head><p>In this section, we illustrate UTT by four examples: the merging of data structures, object initialization, the Factory pattern, and a work flow system. In the examples, we use a Java-like syntax with constructors and expressions. A trans- lation into the language subset supported by UTT is straightforward: constructors can be replaced by initialization methods and expressions can be eliminated using temporary variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">List Merging</head><p>In this subsection, we revisit the implementation of class MList (Fig. <ref type="figure" target="#fig_5">6</ref>). It is easy to see that reverse is well-formed (WF-METHOD, Fig. <ref type="figure" target="#fig_14">11</ref>). First, throughout the method body, the set of unusable variables U is empty. Second, the method body type checks because all expressions except for the loop condition have type rep&lt;R&gt; Node and no unusable variables are accessed.</p><p>Method getNodes illustrates the release statement.</p><p>Releasing first makes all local variables and fields with modifier rep&lt;R&gt; unusable. WF-METHOD requires that upon termination, all fields are usable. This is achieved by setting first to a new node. Without this field update, getNodes would not be well-formed.</p><p>Method merge performs the actual ownership transfer. By capturing un, this variable becomes unusable because it is no longer externally-unique. However, we need not assign a new value to un because it dies when the method terminates. Like in alias burying <ref type="bibr" target="#b9">[10]</ref>, we defer the update of a variable until it is used, and the update is not necessary for local variables that are never used again.</p><p>The MList example illustrates that our technique requires very little overhead beyond the Universe annotations. In particular, methods that do not perform transfers, such as reverse, can be written like in standard Universe Types.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Object Initialization</head><p>The example in Fig. <ref type="figure" target="#fig_16">14</ref> is adapted from <ref type="bibr" target="#b16">[17]</ref>. It illustrates how our system supports object initialization. The constructor of class Lexer expects a free InputStream, which is captured by the lexer. That is, it is transferred to the S cluster of this and then stored in a field.</p><p>Method main of class Client creates a Lexer. It first creates an InputStream in cluster T and then releases it.</p><p>We do not create a free InputStream here, because a constructor call corresponds to a method call, and our system does not permit calls on free receivers. The input stream is then passed to the constructor of the Lexer, where it is captured. The release(s) operation makes all variables with modifier rep T unusable. This prevents the following statements from using s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Factory Pattern</head><p>Fig. <ref type="figure" target="#fig_17">15</ref> shows an implementation of the Factory pattern. The create method of Factory creates a new product, releases it, and returns it. Like in Client's main method (Fig. <ref type="figure" target="#fig_16">14</ref>), we do not create a free object to be able to call a constructor. Since create does not modify any existing objects, we declared it pure. This allows getProduct to call it on the any receiver f. After obtaining a free Product from the factory, getProduct transfers it to cluster P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Work Flow</head><p>The examples we considered so far transfer either the whole internal representation of a data structure (MList) or newly created objects (Lexer and Factory). The next example repeatedly transfers ownership of a single object. This pattern occurs for instance for packets in a communication system or tasks in a work flow application. It can be implemented in UTT using multiple clusters. Fig. <ref type="figure" target="#fig_5">16</ref> shows the implementation of a simple work flow system, where a dispatcher (class Dispatcher) sends orders (class Order) through a pipeline of processors (abstract class Processor). As illustrated by method process of Processor, each processor captures the order in cluster O, stores it in the field current, performs its operations, and releases the order again.</p><p>Note that our implementation does not maintain external uniqueness of Order objects throughout the work flow. Orders are temporarily stored in the field current to reduce parameter passing for more complex implementations of doWork. Capturing the order also allows processors to modify it. Nevertheless, we can release the Order object again for the transfer to the next processor.</p><p>Concrete implementations of a processor (such as class Pricer) may declare additional clusters to store local data. For instance, Pricer maintains a collection of special offers in its P cluster. The local data could also contain any references to orders in cluster O, for instance, to maintain a cache or statistical information. Using a separate cluster for local data allows method process to release the order without making the local data unusable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Soundness</head><p>In this section, we summarize the properties guaranteed by UTT. The formalization and proof of these properties is beyond the scope of this paper, but see our technical report <ref type="bibr" target="#b34">[35]</ref>. The static guarantees provided by UTT are summarized by the following soundness theorem: Type safety is restricted to usable variables. It includes, in particular, that a usable free variable references an object in a free cluster. In combination with external uniqueness, this implies that free variables hold externally-unique ref- erences. The owner-as-modifier property permits modifications of objects in a free cluster. These modifications occur For this, the local variables and parameters with ownership modifier rep for any cluster name become unusable (U-CALL). Because of type safety, these are the only variables that hold external references into a cluster of this.</p><p>There are no usable external references into a cluster of y before control is passed. If y and this hold different references, this property follows from the alias invariant before the call. If y and this reference the same object, this is the case because the local variables with ownership modifier rep are unusable. Therefore, after parameter passing, the only local variables and parameters that hold external references into a cluster of y belong to the execution of the callee method.</p><p>In summary, the alias invariant holds after control has been passed to the callee method. By the induction hypothesis, it is preserved by the method body. When control returns to the caller, the top stack frame is removed, which trivially preserves the alias invariant by reducing the number of variables. Assigning the result value to x preserves the alias invariant because x is a local variable of the caller.</p><p>Case ( <ref type="formula">2</ref>): y has ownership modifier rep cn . By type safety, we know that the owner object of y is this. Therefore, this need not be confined while the callee method executes. By the alias invariant before the call, we know that the alias invariant holds after passing control to the callee.</p><p>By the induction hypothesis, the alias invariant is preserved by the method body. By the owner-as-modifier property, the callee method does not change fields of this. Be- cause of type safety, these are the only fields that hold external references into a cluster of this. Moreover, if the callee transfers objects into a cluster of this, then we know that these objects are not referenced from the stack. This is the case because the callee can transfer either free clusters (in this case, we use external uniqueness) or clusters released by the callee (in this case, the clusters are transitively owned by y; therefore, their owner object is confined before the call). Consequently, the method body also preserves confinement of this.</p><p>Removing the stack frame for the callee does not affect the local variables and parameters of the caller. Finally, assigning the result value to x preserves the alias invariant because x is a local variable of the caller. P</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Implementation</head><p>We implemented UTT as part of the MultiJava compiler <ref type="bibr" target="#b40">[41]</ref>. In this section, we highlight the most interesting aspects of this implementation, namely runtime support, inference of release and capture statements, and inference of cluster information for local variables.</p><p>Runtime Support. As explained in Sec. 4.1, conceptually each object stores a reference to its owner object and the name of the cluster it belongs to. In the implementation, we represent the owner of an object by a designated pseudo owner object. The objects in one cluster can have different pseudo owners, which are organized in a union find structure.</p><p>The indirection through pseudo owners enables an efficient implementation of release and capture. Capturing a cluster is implemented by connecting the union find structures of pseudo owners for the involved clusters. Releasing a cluster is implemented by setting the owner reference in the union find structure of pseudo owners for that cluster to null. Both operations require amortized constant time.</p><p>Inference of Release and Capture. To reduce the annotation overhead, our implementation infers release and capture statements through the following simple rules. Whenever a program attempts to assign a rep cn expression to a free variable, a release is performed. Whenever a program attempts to assign a free expression to a rep cn or peer variable, a capture is performed.</p><p>For instance in method getNodes of class MList (Fig. <ref type="figure" target="#fig_5">6</ref>), our implementation permits the assignment free Node res = first, and infers the release. Similarly, the capture in method merge is inferred.</p><p>Inference of Cluster Information. To further reduce the annotation overhead, we also infer the clusters of local rep variables from the clusters declared for fields, method parameters, and method results. This inference is done by a data flow analysis that keeps track of all possible clusters a variable may point to at each program point.</p><p>For most of our examples, the inference seems trivial because there is only one cluster in each class. However, our implementation also supports an implicitly declared nontransferable cluster. Therefore, the inference has to choose at least among two clusters. For instance in method reverse (Fig. <ref type="figure" target="#fig_5">6</ref>), our implementation allows programmers to omit the cluster information for the local variable p. The data flow analysis determines from the declarations of the fields first and prev that p points to the R cluster throughout the method body. In method merge, we infer from the various field updates that local variable rn points to cluster R. This cluster is then used for the inferred capture statement.</p><p>The inference of release and capture statements as well as of clusters for local variables eliminates almost all annotation overhead of UTT over Universe Types. Programmers merely have to declare clusters and annotate field declarations and method signatures with cluster information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Related Work</head><p>We discussed uniqueness and capabilities in Sec. 2. In this section, we discuss related work on ownership. The existing ownership type systems enforce different forms of encapsulation. Ownership type systems following the owner-as-dominator discipline <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b41">42]</ref> require that all reference chains from an object in the root context to an object o in a different context go through o's owner. This restriction on aliasing allows owners to control all accesses to owned objects, for instance, to guarantee representation independence. UTT enforces the owner-asmodifier discipline. Since this discipline does not restrict aliasing, it can handle some patterns that are not supported by the owner-as-dominator discipline such as collections with iterators or the Flyweight pattern <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b35">36]</ref>. The owneras-modifier discipline is also used in Universe Types <ref type="bibr" target="#b19">[20]</ref>, Generic Universe Types <ref type="bibr" target="#b18">[19]</ref>, and Lu and Potter's work <ref type="bibr" target="#b29">[30]</ref>.</p><p>Most existing ownership type systems do not support transfer <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b37">38]</ref>, but could adopt the technique presented in this paper. Our technique requires that a method cannot call non-pure methods on (transitive) owners of its receiver. This requirement is not enforced by the existing owner-as-dominator systems, but an adaptation is straightforward.</p><p>Hogg's islands <ref type="bibr" target="#b24">[25]</ref> use (strictly) unique variables with destructive reads to permit transfer. We have discussed the problems of this approach in Sec. 2. Our system solves these problems by building on external uniqueness and by permitting temporary aliases. Flexible alias protection <ref type="bibr" target="#b36">[37]</ref> offers a free mode for (strictly) unique references, but does not provide a technique to enforce uniqueness.</p><p>Clarke and Wrigstad <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b41">42]</ref> permit ownership transfer using external uniqueness, destructive reads, and borrowing. While our system builds on their idea of external uniqueness, it requires less annotation overhead. Clarke and Wrigstad's type system is owner-parametric. Therefore, they have to enforce that an object o is transferred only to contexts where o's ownership parameters are available. In our system, objects can be transferred to any context. SafeJava <ref type="bibr" target="#b5">[6]</ref> adopted Clarke and Wrigstad's approach. A notion similar to external uniqueness was also proposed by Banerjee and Naumann <ref type="bibr" target="#b4">[5]</ref>, but without details of how to enforce it.</p><p>AliasJava <ref type="bibr" target="#b1">[2]</ref> supports ownership transfer using destructive field reads and lent variables. As discussed in Sec. 2, lent variables compromise encapsulation, whereas our any references preserve encapsulation because they cannot be used for modifications. Making lent variables in AliasJava read-only would be too restrictive since they allow the only temporary aliases on unique objects in AliasJava. Therefore, passing a unique reference to a non-pure method would be as cumbersome as without temporary aliases. Ownership domains <ref type="bibr" target="#b0">[1]</ref> adopt ideas from AliasJava, but use external uniqueness, although the paper does not describe how it is enforced. Our clusters are a restricted version of ownership domains. In particular, we do not provide public clusters and links between clusters.</p><p>Our confinement property was inspired by our verification methodology for ownership-based object invariants <ref type="bibr" target="#b33">[34]</ref>. The treatment of callbacks is analogous: Both confinement and object invariants need not hold for the (transitive) owners of the current receiver object because callbacks via non-pure methods are prevented by Universe Types. The ownership-based invariant of this is checked before peer calls to avoid problems with callbacks, just like confinement is enforced before peer calls by making local variables and parameters unusable.</p><p>Spec# <ref type="bibr" target="#b28">[29]</ref> uses a dynamic encoding of ownership via a ghost field owner and object invariants. With dynamic ownership, transfer amounts to an update of the owner field. Like in our system, the invariants of the transitive owners of an object o may be temporarily violated when o is transferred. While dynamic ownership is very flexible, it requires program verification to check ownership properties, whereas our system permits syntactic checking.</p><p>In Sing# <ref type="bibr" target="#b20">[21]</ref>, processes can own data in a designated exchange heap. Ownership is transferred when the data is sent to another process. A static data-flow analysis enforces that a process only accesses data it owns. To track local aliases, Sing# builds on capabilities <ref type="bibr" target="#b21">[22]</ref>, which we discussed in Sec. 2. Sing# does not support deep (hierarchic) ownership, and the use of a designated exchange heap is too restrictive for general object-oriented programming.</p><p>Shape analysis <ref type="bibr" target="#b39">[40]</ref> can be used to infer alias structures. However, most shape analyses are whole-program analyses, whereas our technique is fully modular. Rinetzky et al. <ref type="bibr" target="#b38">[39]</ref> present a technique to realize modular shape analyses based on dynamic ownership. Their system supports ownership transfer using constraints and annotations similar to Clarke and Wrigstad's work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b41">42]</ref>. We expect that our work can be combined with the modular shape analysis to overcome the shortcomings of destructive reads and to reduce the annotation overhead.</p><p>Role analysis <ref type="bibr" target="#b27">[28]</ref> is a general technique to describe aliasing relationships between objects via types. It requires programmers to provide role descriptions, role specifications for method signatures, as well as read and write effects for methods. UTT expresses simpler properties, but requires significantly less annotation overhead. Role analysis does not provide encapsulation, which is one of the main motivations of our work. In both role analysis and UTT, the reconfiguration of object structures changes the types of objects to reflect a change of roles or ownership, respectively. Role analysis permits objects referenced from the stack to violate their type; dangerous callbacks are detected by an interprocedural, non-modular analysis. UTT enforces modularly that all potential receivers of calls to non-pure methods are confined; therefore, ownership transfer cannot violate type safety.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusions</head><p>We presented UTT, an extension of Universe Types that supports clusters and ownership transfer. Even though many references may point into a cluster, our modular static analysis enforces that a cluster is externally-unique at the time of transfer. UTT is very flexible because is permits temporary aliases, several fields pointing into one cluster, and any ref- erences. UTT can handle most ownership transfer examples. An example it cannot handle is the splitting of lists because we have no operation to split a cluster into two. Such an operation in general requires a whole-program analysis or reference counting to ensure that the alias invariant is preserved by the split.</p><p>As future work, we plan to use our implementation to assess the expressiveness of UTT in case studies. Two extensions seem particularly useful. First, Universe Types provide very limited support for static fields; type-safety requires that all static fields have any modifiers, which prevents modification of global data. We will investigate an extension of UTT where static fields are free such that methods can capture the global data, modify it, and release it again.</p><p>Second, when releasing a cluster, UTT makes all external references except for one unusable. To retain several usable references, for instance, to the first and last node of a list, programmers have to introduce artificial bridge objects. A bridge object sits in the same cluster as the nodes and holds peer references to the first and last node. Releasing the cluster yields a free reference to the bridge object, which can be captured and then accessed to obtain usable references to the first and last node. We are working on an extension of UTT that can release a cluster while retaining several usable external references, without requiring bridge objects.</p><p>Finally, we are working on an extension of the type inference for local variables to infer all ownership modifiers for locals. This will further reduce the annotation overhead.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Ownership structure of two lists. Each List object owns its Node objects. Objects are depicted by boxes; references are depicted by arrows, which are labeled with the name of the field holding the reference. Rounded boxes delimit ownership contexts. The owner sits atop the context it owns.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Figure 2. Ownership structure after the nodes of List object 1 have been transferred to List object 4 and the two node structures have been merged. To preserve type safety, the first field of List object 1 is set to a fresh node in its context (object 8). The dummy Node object 2 is not reachable after the merge operation and will be garbage collected.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>}Figure 3 .</head><label>3</label><figDesc>Figure 3. Unsafe method of class List. The last statement destroys the node structure of list4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Implementation of a list in Universe Types. List objects own their Node objects, as indicated by the rep modifier in all occurrences of class Node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Nodes form the internal representation of lists. Method flip is used to reverse the list as we discuss later.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. A list implementation using the cluster R to store the nodes. Class Node is presented in Fig.5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Object structure of an MList. Clusters are depicted by dashed boxes. The reference from the Iter object to Node object 3 is an any reference.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Definition 4 . 2 (</head><label>42</label><figDesc>External uniqueness). A reference to an object o is externally-unique if it is the only usable external reference into the cluster containing o.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7</head><label>7</label><figDesc>Fig.7shows an instance of class MList with two nodes. The reference held by the first field is an external reference into the cluster R of MList object 1. It is externally-unique provided that no stack variable points to one of the nodes by a non-any reference.Type-safe ownership transfer requires restrictions on the external references into a cluster. Since these restrictions are not met by all implementations, it is useful to distinguish between transferable and non-transferable clusters. External references into non-transferable clusters need not be restricted beyond the encapsulation of Universe Types. To simplify the presentation, we do not consider non-transferable clusters in this paper. However, our implementation<ref type="bibr" target="#b40">[41]</ref> and the formalization in our technical report<ref type="bibr" target="#b34">[35]</ref> support them.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. The object structure from Fig.7after releasing the R cluster of the MList object. The first field is unusable because it is ill-typed after the release. The welltypedness of the any reference from the Iter object is not affected by the release.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Definition 4 . 4 (</head><label>44</label><figDesc>rep cn . If the receiver x is this, confinement of o is preserved because o and x are the same object. If x has modifier rep cn , then x and p point into the same cluster, and storing p does not create an external reference. For all other modifiers of x, m receives an any reference to p, which can- not be used to create an external reference.Since Universe Types prevent callbacks via non-pure methods into the (transitive) owners of this (see Sec. 3), not all objects need to be confined in all execution states. The following alias invariant defines when objects must be confined. It holds in all execution states of a well-typed program. Alias invariant). Each object o is confined unless the method currently executing is pure or o is one of the (transitive) owner objects of the current receiver object.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Object structure of an MList during the execution of p.flip. The box on the left-hand side depicts the call stack. MList object 1 is not confined since p holds a reference into the R cluster, but is not a local variable of the current method execution. This violation is permitted because the MList object 1 is the owner object of the current receiver, Node object 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>PFigure 10 .</head><label>10</label><figDesc>Figure 10. Syntax and declaration environment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>5. 2</head><label>2</label><figDesc>Well-FormednessThe well-formedness rules for types, methods, and classes are presented in Fig.11. If a type u C has a rep cn modifier then u C is well-formed in an environment Γ only if cn is declared in a (not necessarily proper) superclass of the enclosing class. The enclosing class is the class of this in Γ (WF-TYPE). The function clusters(C 0 ) yields the names of all clusters declared in class C 0 and its superclasses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Well-formedness rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Rules of static analysis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Example of an object initialization. Lexer's constructor captures its parameter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 15 .</head><label>15</label><figDesc>Figure 15. Implementation of the Factory pattern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Theorem 7 . 1 ( 1 . 4 .</head><label>7114</label><figDesc>Soundness). In each execution state of a wellformed program, the following properties hold: Type safety: The ownership modifier of the type of a usable variable v reflects the owner of the object referenced by v.2. Tree order: The ownership relation among the objects inthe heap is a tree order.3. External uniqueness:There is at most one external reference into each free cluster. Alias invariant: The alias invariant (Def. 4.4) holds.Moreover, the following property holds for each well-typed statement s:5. Owner-as-modifier: The execution of s modifies only fields and ownership of those objects that, in the state before executing s, are (transitively) owned by the owner of this or by an object in a free cluster.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>class MList { cluster R ; rep &lt;R &gt; Node first = new rep &lt;R &gt; Node ();</figDesc><table><row><cell>void reverse () {</cell></row><row><cell>rep &lt;R &gt; Node p = first ;</cell></row><row><cell>do {</cell></row><row><cell>p . flip ();</cell></row><row><cell>p = p . prev ;</cell></row><row><cell>} while(p != first );</cell></row><row><cell>}</cell></row><row><cell>free Node getNodes () {</cell></row><row><cell>free Node res = release( first );</cell></row><row><cell>first = new rep &lt;R &gt; Node ();</cell></row><row><cell>return res ;</cell></row></table><note><p>} void merge ( peer MList l ) { free Node un = l . getNodes (); rep &lt;R &gt; Node rn = capture(un , rep &lt;R &gt;); first . prev . next = rn . next ; rn . next . prev = first . prev ; rn . prev . next = first ; first . prev = rn . prev ; } // constructors and other methods omitted . }</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>However, a field of an object o can nevertheless point to transferable objects in o's clusters if it is declared with a rep modifier. rep cn types and free types are subtypes of the any types with the same class. For different cluster names cn 1 and cn 2 , rep cn 1 and rep cn 2 types are incomparable because they refer to different clusters. Viewpoint Adaptation. The viewpoint adaptation operator £ of UTT is defined by the following table. The first argument (rows) is the ownership modifier of the receiver. The second argument (columns) is the ownership modifier of the field, method parameter, or method result to be viewpoint-</figDesc><table><row><cell>£</cell><cell>peer</cell><cell>rep cn 2</cell><cell>any free</cell></row><row><cell>this</cell><cell>peer</cell><cell>rep cn2</cell><cell>any free</cell></row><row><cell>peer</cell><cell>peer</cell><cell>any</cell><cell>any free</cell></row><row><cell>rep cn1</cell><cell>rep cn1</cell><cell>any</cell><cell>any free</cell></row><row><cell>any</cell><cell>any</cell><cell>any</cell><cell>any free</cell></row><row><cell>free</cell><cell>any</cell><cell>any</cell><cell>any free</cell></row></table><note><p>adapted. For instance, the modifier of the access p.prev in MList's method reverse is determined by combining the modifier of the receiver p (rep R ) with the modifier of field prev (peer), which yields rep R .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Definition 4.3 (Confinement). An object o is confined if and only if each external reference into a cluster cn of o is held by a variable v that satisfies at least one of the following conditions: 1. v is a field of o. 2. v is a local variable or parameter of the current method execution, and o is the receiver of this method. 3. v is unusable.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We ignore static methods in this paper, but an extension is possible<ref type="bibr" target="#b32">[33]</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Thanks to Werner Dietl, James Noble, and Joseph Ruskiewicz for insightful discussions and suggestions, and to the anonymous reviewers for their helpful comments. This work was funded in part by the Information Society Technologies program of the European Commission, Future and Emerging Technologies under the IST-2005-015905 MO-BIUS project. Müller's work was carried out at ETH Zurich.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We proved the conjunction of all properties of Theorem 7.1 by rule induction on an operational semantics <ref type="bibr" target="#b34">[35]</ref>. The base case covers all primitive statements; the induction step covers sequential composition and method calls. The execution of each statement preserves properties 1-4 and satisfies property 5. We only sketch the proofs of the most interesting cases here.</p><p>External uniqueness for release. Consider the statement x := release(y). By T-RELEASE, y has ownership modifier rep cn . The statement transfers all objects owned by &lt;this, cn&gt; to a new free cluster. By type safety before the release, we know that no usable free variable v references one of the transferred objects. Since these objects are transferred to a new cluster, v remains externallyunique. It remains to show that x is externally-unique after the release.</p><p>Since the alias invariant holds for this before the release, we know that all usable external references to objects owned by &lt;this, cn&gt; are held by fields of this that are declared in the same class as cn (WF-CLASS and type safety) or by local variables or parameters of the current method execution. According to U-RELEASE, these variables are unusable after the release. Therefore, x holds the only usable external reference into the released cluster.</p><p>Type safety for capture. Consider the statement x := capture(y,u). The statement transfers all objects in the cluster referenced by y to a non-free cluster described by u.</p><p>By T-CAPTURE, y is usable and has ownership modifier free. By external-uniqueness, y holds the only usable ex- ternal reference to a transferred object. Consequently, y is the only variable whose type safety is potentially affected by the capturing. In particular, the type safety of peer variables is not affected because all objects in the captured cluster are transferred together, that is, they remain peers. Since y is unusable after the capture (U-CAPTURE), type safety is preserved. Variable x is well-typed because it has the ownership modifier u (T-CAPTURE).</p><p>Alias invariant for method calls. Consider the call x := y.m(z). By T-CALL, we know that y has modifier this, peer, or rep cn . We continue by case distinction.</p><p>Case (1): y has ownership modifier this or peer. By type safety, this and y have the same owner. Therefore, the same set of objects S must be confined in the caller and the callee method.</p><p>First, we show that passing control to the callee preserves the alias invariant. For all objects o ∈ S other than the objects referenced by this and y, confinement is preserved by passing control because fields are unchanged and unusable variables remain unusable.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Ownership domains: Separating aliasing policy from mechanism</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3086</biblScope>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Alias annotations for program understanding</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kostadinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-oriented programming, systems, languages, and applications (OOPSLA)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="311" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Scoped types and aspects for real-time systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Andrea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Coady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gibbs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Thomas</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4067</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Representation independence, confinement, and access control</title>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Programming Languages (POPL)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="166" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Ownership: transfer, sharing, and encapsulation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Techniques for Java-like Programs</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Eisenbach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Poetzsch-Heffter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SafeJava: A Unified Type System for Safe Programming</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Ownership types for safe programming: Preventing data races and deadlocks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="211" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Ownership types for object encapsulation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shrira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Programming Languages (POPL)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Ownership types for safe region-based memory management in real-time Java</title>
		<author>
			<persName><forename type="first">C</forename><surname>Boyapati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Salcianu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Beebee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming language design and implementation (PLDI)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="324" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Alias burying: unique variables without destructive reads. Software-Practice and Experience</title>
		<author>
			<persName><forename type="first">J</forename><surname>Boyland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="533" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Connecting effects and uniqueness with adoption</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Boyland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Retert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of programming languages (POPL)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="283" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Non-null references by default in Java: Alleviating the nullity annotation burden</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chalin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>James</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming (ECOOP)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Ernst</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Object Ownership and Containment</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>University of New South Wales</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Ownership, encapsulation and the disjointness of type and effect</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming, Systems, Languages, and Applications (OOP-SLA)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="292" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">External uniqueness is unique enough</title>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wrigstad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Cardelli</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2743</biblScope>
			<biblScope unit="page" from="176" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ownership types for flexible alias protection</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Potter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)</title>
		<imprint>
			<publisher>ACM SIGPLAN Notices</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">33</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Wrestling with rep exposure</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Detlefs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Report</title>
		<imprint>
			<biblScope unit="volume">156</biblScope>
			<date type="published" when="1998">1998</date>
			<publisher>Digital Systems Research Center</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Formalization of Generic Universe Types</title>
		<author>
			<persName><forename type="first">W</forename><surname>Dietl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
		<idno>532</idno>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>ETH Zurich</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>sct.inf.ethz.ch/publications</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Generic Universe Types</title>
		<author>
			<persName><forename type="first">W</forename><surname>Dietl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Drossopoulou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming (ECOOP)</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Ernst</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Universes: Lightweight ownership for JML</title>
		<author>
			<persName><forename type="first">W</forename><surname>Dietl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object Technology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Language support for fast and reliable message-based communication in Singularity OS</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hodson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Levi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys &apos;06</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="177" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Adoption and focus: practical linear types for imperative programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Deline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming language design and implementation (PLDI)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Declaring and checking non-null types in an object-oriented language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fähndrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Objectoriented programing, systems, languages, and applications (OOPSLA)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="302" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Immutable objects for a Java-like language</title>
		<author>
			<persName><forename type="first">C</forename><surname>Haack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schäfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schubert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Programming</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Nicola</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4421</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Islands: Aliasing protection in object-oriented languages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hogg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-oriented programming systems, languages, and applications (OOPSLA)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="271" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Safe concurrency for aggregate objects with invariants</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering and Formal Methods (SEFM)</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="137" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">An Isabelle formalization of the Universe Type System. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Klebermaß</surname></persName>
		</author>
		<ptr target="sct.inf.ethz.ch/projects/student_docs/Martin_Klebermass" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Technische Universität München</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Role analysis</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of programming languages (POPL)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="17" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Object invariants in dynamic contexts</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Odersky</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3086</biblScope>
			<biblScope unit="page" from="491" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Protecting representation with effect encapsulation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of programming languages (POPL)</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="359" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Object Invariants and Effects</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Potter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming (ECOOP)</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Towards alias-free pointers</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H</forename><surname>Minsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">P. Cointe, editor, European Conference on Object-Oriented Programming</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1098</biblScope>
			<biblScope unit="page" from="189" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Modular Specification and Verification of Object-Oriented programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">2262</biblScope>
			<date type="published" when="2002">2002</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Modular invariants for layered object structures</title>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poetzsch-Heffter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="253" to="286" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Formalization of ownership transfer in Universe Types</title>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rudich</surname></persName>
		</author>
		<idno>556</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>ETH Zurich</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>sct.inf.ethz.ch/publications</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Ownership in design patterns. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nägeli</surname></persName>
		</author>
		<ptr target="sct.inf.ethz.ch/projects/student_docs/Stefan_Naegeli" />
		<imprint>
			<date type="published" when="2006">2006</date>
			<pubPlace>ETH Zurich</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Flexible alias protection</title>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vitek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Potter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Jul</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1445</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Generic ownership for generic Java</title>
		<author>
			<persName><forename type="first">A</forename><surname>Potanin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Noble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Biddle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="311" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Modular shape analysis for dynamically encapsulated programs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Rinetzky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poetzsch-Heffter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ramalingam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Programming</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Nicola</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4421</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Parametric shape analysis via 3-valued logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="217" to="298" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Implementing uniqueness and ownership transfer in the Universe Type System. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Takano</surname></persName>
		</author>
		<ptr target="sct.inf.ethz.ch/projects/student_docs/Yoshimi_Takano" />
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>ETH Zurich</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Ownership-Based Alias Management</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wrigstad</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Royal Institute of Technology Stockholm</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
