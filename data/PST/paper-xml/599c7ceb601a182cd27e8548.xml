<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Model Ensemble for Click Prediction in Bing Search Ads</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Xiaoliang</forename><surname>Ling</surname></persName>
							<email>xiaoling@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Weiwei</forename><surname>Deng</surname></persName>
							<email>dedeng@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Chen</forename><surname>Gu</surname></persName>
							<email>chengu@microsoft.com</email>
						</author>
						<author>
							<persName><forename type="first">Hucheng</forename><surname>Zhou</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Cui</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Feng</forename><surname>Sun</surname></persName>
							<email>fengsun@microsoft.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<addrLine>Microsoft Bing No. 5 Dan Ling Street</addrLine>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<addrLine>Microsoft Bing No. 5 Dan Ling Street</addrLine>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<addrLine>Microsoft Bing No. 5 Dan Ling Street</addrLine>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="laboratory">Microsoft Research No</orgName>
								<address>
									<addrLine>5 Dan Ling Street</addrLine>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="laboratory">Microsoft Research No</orgName>
								<address>
									<addrLine>5 Dan Ling Street</addrLine>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<address>
									<addrLine>Microsoft Bing No. 5 Dan Ling Street</addrLine>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Model Ensemble for Click Prediction in Bing Search Ads</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1CFB35002C037DC8E4B2FDE2D1B60611</idno>
					<idno type="DOI">10.1145/3041021.3054192</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>click prediction</term>
					<term>DNN</term>
					<term>GBDT</term>
					<term>model ensemble</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Accurate estimation of the click-through rate (CTR) in sponsored ads significantly impacts the user search experience and businesses' revenue, even 0.1% of accuracy improvement would yield greater earnings in the hundreds of millions of dollars. CTR prediction is generally formulated as a supervised classification problem. In this paper, we share our experience and learning on model ensemble design and our innovation. Specifically, we present 8 ensemble methods and evaluate them on our production data. Boosting neural networks with gradient boosting decision trees turns out to be the best. With larger training data, there is a nearly 0.9% AUC improvement in offline testing and significant click yield gains in online traffic. In addition, we share our experience and learning on improving the quality of training.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Search engine advertising has become a significant element of the web browsing experience. Choosing the right ads for a query and the order in which they are displayed greatly affects the probability that a user will see and click on each ad. Accurately estimating the click-through rate (CTR) of ads <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b12">12]</ref> has a vital impact on the revenue of search businesses; even a 0.1% accuracy improvement in our production would yield hundreds of millions of dollars in additional earnings. An ad's CTR is usually modeled as a classification problem, and thus can be estimated by machine learning models. The training data is collected from historical ads impressions and the corresponding clicks. Because of the simplicity, scalability and online learning capability, logistic regression (LR) is the most widely used model that has been studied by Google <ref type="bibr" target="#b21">[21]</ref>, Facebook <ref type="bibr" target="#b14">[14]</ref> and Yahoo! <ref type="bibr" target="#b3">[3]</ref>. Recently, factorization machines (FMs) <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b5">5,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b17">17]</ref>, gradient boosting decision trees (GBDTs) <ref type="bibr" target="#b25">[25]</ref> and deep neural networks (DNNs) <ref type="bibr" target="#b29">[29]</ref> have also been evaluated and gradually adopted in industry.</p><p>A single model would lead to suboptimal accuracy, and the abovementioned models all have various different advantages and disadvantages. They are usually ensembled together in an industry setting (or even machine learning competition like Kaggle <ref type="bibr" target="#b15">[15]</ref>) to achieve better prediction accuracy. For instance, apps recommendation in Google adopts Wide&amp;Deep <ref type="bibr" target="#b7">[7]</ref> that co-trains LR (wide) and DNN (deep) together; ad CTR in Facebook <ref type="bibr" target="#b14">[14]</ref> uses GBDT for non-linear feature transformation and feeds them to LR for the final prediction; Yandex <ref type="bibr" target="#b25">[25]</ref> boosts LR with GBDT for CTR prediction; and there also exists work <ref type="bibr" target="#b29">[29]</ref> on ads CTR that feeds the FM embedding learned from sparse features to DNN. Simply replicating them does not yield the best possible level of accuracy. In this paper, we share our experience and learning on designing and optimizing model ensembles to improve the CTR prediction in Microsoft Bing Ads.</p><p>The challenge lies in the large design space: which models are ensembled together; which ensemble techniques are used; and which ensemble design would achieve the best accuracy? In this paper, we present 8 ensemble variants and evaluate them in our system. The ensemble that boosts the NN with GBDT, i.e., initializes the sample target for GBDT with the prediction score of NN, is considered to be the best in our setting. With larger training data, it shows near 0.9% AUC improvement in offline testing and significant click yield gains in online traffic. To push this new ensemble design into the system also brings system challenges on a fast and accurate trainer, considering that multiple models are trained and each trainer must have good scalability and accuracy. We share our experience with identifying accuracy-critical factors in training.</p><p>The rest of the paper is organized as follows. We first provide a brief primer on the ad system in Microsoft Bing Ads in Section 2.</p><p>We then present several model ensemble design in detail in Section 3, followed by the corresponding evaluation against production data. The means of improving model accuracy and system performance is described in Section 5. Related work is listed in Section 6 and we conclude in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">ADS CTR OVERVIEW</head><p>In this section, we will describe the overview of the ad system in Microsoft Bing Ads and the basic models and features we use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Ads System Overview</head><p>Sponsored search typically uses keyword based auction. Advertisers bid on a list of keywords for their ad campaigns. When a user searches with a query, the search engine matches the user query with bidding keywords, and then selects and shows proper ads to the user. When a user clicks any of the ads, the advertiser will be charged with a fee based on the generalized second price <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b1">1]</ref>. A typical system involves several steps including selection, relevance filtration, CTR prediction, ranking and allocation. The input query from the user is first used to retrieve a list of candidate ads (selection). Specifically, the selection system parses the query, expands it to relevant ad keywords and then retrieves the ads from advertisers' campaigns according to their bidding keywords. For each selected ad candidate, a relevance model estimates the relevance score between query and ad, and further filters out the least relevant ones (relevance filtration). The remaining ads are estimated by the click model to predict the click probability (pClick) given the query and context information (click prediction). In addition, a ranking score is calculated for each ad candidate by bid * pClick where bid is the corresponding bidding price. These candidates are then sorted by their ranking score (ranking). Finally, the top ads with a ranking score larger than the given threshold are allocated for impression (allocation), such that the number of impressions is limited by total available slots. The click probability is thus a key factor used to rank the ads in appropriate order, place the ads in different locations on the page, and even to determine the price that will be charged to the advertiser if a click occurs. Therefore, ad click prediction is a core component of the sponsored search system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Models</head><formula xml:id="formula_0">Consider a training data set D = {(x i , y i )} with n examples (i.e., |D| = n),</formula><p>where each sample has m features x i ∈ R m with observed label y i ∈ {0, 1}. We formulate click prediction as a supervised learning problem, and binary classification models are often used for click probability estimation p(click = 1|user, query, ad). Given the observed label y ∈ {0, 1}, the prediction p gets the resulting LogLoss (logistic loss), given as:</p><formula xml:id="formula_1">(p) = -y • log p -(1 -y) • log (1 -p),<label>(1)</label></formula><p>which means the negative log-likelihood of y given p. In the following, we will give a brief description on two basic models used in our production. Logistic Regression. LR predicts the click probability as p = σ (w•x +b), where w is the feature weight, b is the bias, and σ (a) = </p><formula xml:id="formula_2">∇ (w) = (σ (w • x) -y) • x = (p -y) •</formula><p>x that is used in an optimization process like SGD. The left part in Figure <ref type="figure" target="#fig_0">1</ref> depicts the LR model structure. LR is a generalized linear model that memorizes the frequent co-occurrence between feature and label, with the advantages of simplicity, interpretability and scalability. LR essentially works by memorization that can be achieved effectively using cross-product transformations over sparse features. For instance, the term co-occurrence between the query and ad can be cross combined to capture their correlation, e.g., the binary feature "AND(car, vehicle)" has value 1 if "car" occurs in the query and "vehicle" occurs in the ad title. This explains how the cooccurrence of a crossed feature correlates with the target label. However, since the LR model itself can only model the linear relation among features, the non-linear relation has to be combined manually. Even worse, memorization does not generalize to queryad pairs that have never occurred in the past. Deep Neural Network. DNN generalizes to previously unseen query-ad feature pairs by learning a low-dimensional dense embedding vector for both query and ad features, with less burden of feature engineering. The middle model in Figure <ref type="figure" target="#fig_0">1</ref> depicts four layers of the DNN structure, including two hidden layers each with u neuron units, one input layer with m features and one output layer with one single output. With a top-down description, the output unit is a real number p ∈ (0, 1) as the predicted CTR with</p><formula xml:id="formula_3">p = σ (w 2 • x 2 + b 2 ), where σ (a) = 1 1+exp(-a)</formula><p>is the logistic activation function. w 2 ∈ R 1×u is the parameter matrix between output layer and the connected hidden layer, b 2 ∈ R is the bias. x 2 ∈ R u is the activation output of the last hidden layer computed as</p><formula xml:id="formula_4">x 2 = σ (w 1 • x 1 + b 1 ), where w 1 ∈ R u×u , b 1 ∈ R u , x 1 ∈ R u . Similarly, x 1 = σ (w 0 • x 0 + b 0 ) where w 0 ∈ R u×m , b 0 ∈ R u and x 0 ∈ R m</formula><p>is the input sample. Different hidden layers can be regarded as different internal functions capturing different forms of representations of a data instance. Compared with the linear model, DNN thus has better for catching intrinsic data patterns and leads to better generalization. The sigmoid activation can be replaced as a tanh or ReLU <ref type="bibr" target="#b19">[19]</ref> function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Training data</head><p>The training data is collected from an ad impressions log, that each sample (x i , y i ) represents whether or not the impressed ad allocated by the ad system has been clicked by a user. The output variable y i is 1 if the ad has been clicked, and y i is 0 otherwise. The input features x i consist of different sources that describe different domains of an impression. 1). query features that include query term, query classification, query length, etc. 2). ad features that include ad ID, advertiser ID, campaign ID, and the corresponding terms in ad keyword, title, body, URL domain, etc. 3). user features that include user ID, demographics, and user click propensity <ref type="bibr" target="#b6">[6]</ref>, etc. 4). context features that describe date, and location. and 5). crossing features among them, e.g., QueryId_X_AdId (X means crossing) that cross the user ID with the ad ID in an example. One-Hot Encoding Features. These features can be simply represented as one-hot encoding, e.g., QueryId_X_AdId is 1 if the user-ad pair occurs in the example. Consider that there would be hundreds of million of users and ads, as well as millions of terms, and even more crossing features. The feature space has extremely high dimensionality, and they are meanwhile extremely sparse in a sample. This high dimensionality and sparsity introduces constraints on the model design and also introduces challenges on the corresponding model training and serving. Statistic Features. They can be classified into three types: 1). Counting features that include statistics like the number of clicks, the number of impressions, and the historical CTR over different domains (basic and crossing). e.g., QueryId_X_adId_Click_6M, and QueryId_X_AdId_Impression_6M that counts the number of clicks for specific (QueryId, AdId) pair in last six months. To account for this display position bias <ref type="bibr">[9]</ref>, we use position-normalized statistics such as expected clicks (ECs) and clicks over expected clicks (COEC) <ref type="bibr" target="#b6">[6]</ref>:</p><formula xml:id="formula_5">COEC = ∑ R r=1 c r ∑ R r=1 i r • EC r (2)</formula><p>where the numerator is the total number of clicks received by a query-ad pair; the denominator can be interpreted as the expected clicks (ECs) that an average ad would receive after being impressed i r times at rank r, and EC r is the average CTR for each position in the result page (up to R), computed over all pairs of query and ad. We thus can obtain COEC statistics for specific query-ad pairs. The counting feature is essential to convert huge amounts of discrete one-hot encoding features (billions) to only hundreds of dense real-valued features. A hash table is used to store the statistics and they are looked up online through the key likes "iPhone case_Ad3735". The statistics are refreshed regularly with a moving time window. 2). For some lookup keys (e.g., the long tail ones), there are too few impressions and clicks thus the statistics are pretty noisy. However, they still occupy a large amount of hash table storage. The solution is to assign these low impression/click data to a "garbage group", and the statistic that corresponds to this group is the default value if the key is missing in the hash table . A garbage feature with a binary value thus indicates whether or not current sample is in garbage group. 3). Semantic feature such as BM25. We also have a query/ad term based logistic regression model to capture the semantic relationship between the query term and ad term. The prediction output is treated as a feature.</p><p>Position Feature. We also record the specific position in which an ad is impressed. A search result page view (SRPV) may contain multiple ads at different positions, either in the mainline right after the search bar or in the right sidebar. Position feature w.r.t a specific position is the expected CTR based on a portion of traffic with randomized ad order. The specialty of position feature is that it never interacts with other statistic features (during feature engineering and model learning), but separates them out independently.</p><p>The underlying consideration lies in the displayed position and the ad quality being two independent factors that affect the final click probability. Actually, we treat the position feature as a position prior as p(click = 1|ad, position) ∝ p(click = 1|ad) • p(position). This separation of position features and other features is also validated by our experiments where it outperforms the model that interacts with them together. Since we do not know the position where the ad will be displayed, a default position (ML-1) is used to predict click probability online. In this way, we mainly compare the ad quality in the click prediction stage, i.e., all ads are set with the same value for position feature, and the specific position is finally determined in the ads allocation stage. Note that we still collect the click log into training data even when the corresponding clicked position is not ML1, as this is helpful for enriching the training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Baseline Model</head><p>Figure <ref type="figure">2</ref> depicts the baseline model we use, where several LRs and a NN model are ensembled together. Several LR models are first trained 1 so that each is fitted based on the one-hot features (with up to billions), and their prediction scores are treated as statistic features. Combined with the statistic and position feature listed above (Section 2.3), they are then fed into an NN model. NN is a "special" DNN with one single hidden layer. NN rather than DNN is selected since adding more layers and more units would have substantial offline gain, but the online gain is poor and not stable. 1 We adopt FTRL ("Follow The (Proximally) Regularized Leader") <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b20">20]</ref> or L1 regularization <ref type="bibr" target="#b11">[11]</ref> to produce sparse model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>... statistic features position bias LR scores</head><p>Figure <ref type="figure">2</ref>: NN model used in production. There are three parts in input features: 1). the predicted scores of LRs; 2). statistic features; 3). position bias.</p><p>Besides, DNN introduces much more system costs in both training and serving. The postilion bias is only connected to a special hidden unit of NN to avoid the interaction. This cascading ensemble (stacking) shows good offline and online accuracy, and is considered the baseline that is compared with several novel ensembles described in Section 3.</p><p>On the one hand, we do not use a single model like LR and combine one-hot features and statistics features together, since it is hard to fit a good linear model with comparable cost, consider that there are a large number (1B) of sparse features and a small number of (100-500) dense features. Moreover, since the historical correlation in one-hot features is represented as the corresponding weights (parameters), thus the corresponding model needs to be updated frequently even with online learning to fit the latest trends. As a comparison, the statistic feature is updated in real-time that the corresponding model does not need to be re-trained frequently, e.g., the historical CTR of an advertiser can be updated as soon as a click or an impression of that advertiser occurs<ref type="foot" target="#foot_0">2</ref> . Lastly, the dimensionality of statistic features is much less than one-hot features, posing less challenge to offline training and online serving. Based on these factors, we choose to use NN as the baseline model that is fit from these statistic features. Note that all features including position features are first normalized by means of x-min max-min . On the other hand, however, if we only keep the statistic feature, the tail cases could have poor prediction accuracy, since there are few impressions in training data and they will fall into the garbage group. Therefore, the NN model trained from the statistic features has no discrimination among these rare cases, thus leads to over-generalize and make less accurate prediction <ref type="bibr" target="#b7">[7]</ref>. As a comparison, with more fine-grained term-level one-hot features with cross-product feature transformations, linear models (LRs) can memorize these "exception rules" and can learn different term-crossing weight <ref type="foot" target="#foot_1">3</ref> . Two LR models are ensembled, one is trained from older dataset and another is trained from the latest dataset. To mitigate the potential loss, our solution thus resorts to ensemble LR and NN together.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MODEL ENSEMBLE DESIGN</head><p>Different models can complement each other, and a model ensemble that combines multiple models into one model is a common practice in an industry setting to achieve better accuracy. In this section, we describe the different model ensemble designs and the cor-responding design consideration, which aim to provide better prediction accuracy than the baseline model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Ensemble</head><p>Ensemble approaches. There are different ensemble <ref type="bibr" target="#b26">[26]</ref> techniques that aim to decrease variance and bias, improve predictive accuracy (stacking), etc. The following is a short description of these methods: 1). Bagging stands for bootstrap aggregation. The idea behind bagging is that an overfitted model would have high variance but low bias in bias/variance tradeoff. Bagging decreases the variance of prediction by generating additional data from the original dataset using sampling with repetitions. 2). Boosting works with the under-fitted model that has high bias and low variance, i.e., the model cannot completely describe the inherent relationship in the data. With the insight that the model residuals still contain useful information, boosting at its heart repeatedly fits a new model on the remaining residuals. The final result is predicted by summing all models together. GBDT is the most widely used boosting model. 3). Stacking also first applies several models to the original data and the final prediction is the linear combination of these models. It introduces a meta-level and uses another model or approach to estimate the weight of each model, i.e., to determine which model performs well given these input data. 4). Cascading model A to model B means the results of model A are treated as new features to model B. Compared with stacking, cascading is more like joint training <ref type="bibr" target="#b7">[7]</ref>, with the difference that the cascaded models are not trained together but are trained separately without knowing each other. In contrast, joint training optimizes all parameters simultaneously by taking parameters of all models as well as the weights of their sum into account at training time. To simplify the description, we represent cascading A to B as A2B and boosting A with B as A + B.</p><p>There are still questions regarding specific ensemble design that remain unanswered. Which models are ensembled together? Which ensemble techniques are used? Which ensemble design would achieve the best accuracy? Sometimes bagging or boosting works great, sometimes one or the other approach is mediocre or even negative. To answer them in our setting, we will present 8 ensemble variants in the next part.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Ensemble design</head><p>Design principles. There are several principled rules taken into consideration when we design the ensemble: 1). We do not consider the bagging approach since the variance of DNN is not significant especially if we regularize the model complexity, e.g., NN instead of DNN is used in production. The gain from bagging would be marginal. 2). Diversity is key to ensemble design. Nonparametric models such as decision trees are introduced to increase diversity since it differs largely with parametric models such as LR and DNN. Parametric models are usually optimized with gradient descent, while non-parametric models are fitted by greedily distinguishing the examples via clustering (K-Means) or splitting (decision tree). We believe the ensemble among non-parametric and parametric models would get more complementary benefits for accuracy. Boosting is commonly associated with gradient boosting decision trees (GBDTs). 3). Co-training between non-parametric models such as GBDT and parametric models such as LR/DNN is difficult even infeasible thus we do not consider joint training in this paper. Note that it is not easy to co-train multiple parametric models when they are optimized with different optimizers (FTRL of LR VS. AdaGrad of DNN) with different mini-batches and different asynchronization requirements. 4). We skip the ensemble of DNN and LR on statistic features. Our baseline model actu-ally has the ensemble between DNN and LR already on one-hot features. However, in the last prediction stage, there are only statistic features. In this situation, the ensemble between DNN and LR is unnecessary since DNN is considered more powerful than LR such that for any given LR model there is always a DNN that has the same or larger representation capability. 5). Cascading is also emphasized. On the one hand, it is considered to have the benefits of co-training. <ref type="foot" target="#foot_2">4</ref> On the other hand, unlike co-training, it can ensemble the parametric and non-parametric models together. In the next, we will describe 9 ensemble variants that are all based on the same training data as our baseline model.</p><p>GBDT. The Gradient-Boosted Decision Tree (GBDT) is the ensemble of decision trees, and is widely used as it can model non-linear correlation, obtain interpretable results and does not need extra feature preprocessing such as normalization. GBDT iteratively trains T decision trees in order to minimize a loss function. During each iteration, the algorithm uses the current ensemble to predict the label of each sample and then compare the prediction with the true label. The dataset is re-labeled with the corresponding "residual" to put more emphasis on training instances with poor predictions. Thus, in the next iteration, a new decision tree will be fitted to correct for previous mistakes. The specific mechanism for re-labeling instances is defined by a loss function. Specifically, the t-th tree ( f t ) is added to minimize the following objective:</p><formula xml:id="formula_6">t = n ∑ i=1 (y i , y t-1 i + f t (x i )), where f t ∈ Γ<label>(3)</label></formula><p>where y t i is the prediction of the i-th instance at the t-th iteration. Γ = { f (x) = w q(x) }, (q : R m → L, w ∈ R L ) is the structure space of decision trees. Here q represents the tree structure that maps a sample to the corresponding index of exit leaf (q(x)). Each leaf has a score (w). L is the number of leaves in the tree. Given sample x, GBDT uses T additive functions to predict the output, each subtree corresponds to a scoring function f t and a shrinkage rate γ t :</p><formula xml:id="formula_7">p = σ ( ȳ); ȳ = T ∑ t=1 γ t • f t (x)<label>(4)</label></formula><p>The right part of Figure <ref type="figure" target="#fig_0">1</ref> depicts a GBDT model where nodes in blue color are the exit leaves. The specialty of our design is that the sample score in the first tree is initialized as the corresponding position bias whose value is roughly the expected CTR of all samples collected from an bucket traffic with randomized ad order. Note that we use the inverse position bias, i.e., given pb = σ (x), we use x instead of pb. As pointed out in Section 2 that position bias cannot be crossed with other features, thus we never split position feature during training. GBDT2LR: Cascading GBDT to LR. As pointed out by He, et al. <ref type="bibr" target="#b14">[14]</ref>, GBDT is a powerful way to implement non-linear and crossing transformations on input features. Specifically, we treat each individual tree as a categorical feature that takes as feature value the index of the leaf where a sample falls in. They are represented as one-hot encoding. These newly transformed features are then fed into LR as input feature. Essentially, GBDT based transformation is considered a supervised feature encoding that converts a real-valued feature vector into a compact binary-valued vector. A traversal from the root node to a leaf node represents a rule on the splitting features along the path. Fitting a linear classifier on the resulting binary vector is to learn the weights for these rules.</p><p>LR2GBDT: Cascading LR to GBDT. Conversely, we can also cascade LR to GBDT (with T subtrees). It first trains an LR model and uses as an input feature the prediction score of LR to a GBDT model. Given a sample x, the specific scoring formula is as follows:</p><formula xml:id="formula_8">p = σ ( ȳ); ȳ = T ∑ t=1 γ t • f t (x, σ (y lr ))<label>(5)</label></formula><p>Position bias here is only used in LR and never used in GBDT. LR has better accuracy if we use the inverse position bias rather than the normalized value. This is because the position bias is the expected CTR, i.e., the expected value of LR prediction, and the linear combination of non-position features (i.e., logit) can be regarded as the adjustment to the expected CTR. The inverse position bias is essentially to convert the position feature to the expected logit. GBDT2DNN: Cascading GBDT to DNN. This is a cascading ensemble that first trains a GBDT model, and the predicting score of GBDT is fed as input feature (x gbdt ) into a DNN model. Given a sample x, the specific scoring formula is as follows:</p><formula xml:id="formula_9">p = σ ( ȳ); ȳ = σ (w 1 • x 1 + b 1 ); x 1 = σ (w 0 • (x 0 , x gbdt ) + b 0 )<label>(6)</label></formula><p>The position feature is only used to initialize the GBDT and not used in DNN to avoid the cross interaction. DNN here has only one hidden layer to simplify the description. Unlike GBDT2LR, we do not feed the transformed categorical features from GBDT to DNN, since DNN resorts to embedding to deal with the categorical features. Considering that we have a large number of trees and each tree has a large number of leaves, this introduces scalability issue on the DNN trainer. 5 DNN2GBDT: Cascading DNN to GBDT. The opposite direction that cascades DNN to GBDT also should be tried. Specifically, it first trains a DNN model, and the DNN's predicting score is then fed as an input feature to a GBDT model. Given a sample x, the specific scoring formula is as follows:</p><formula xml:id="formula_10">p = σ ( ȳ); ȳ = T ∑ t=1 γ t • f t (x, y dnn )<label>(7)</label></formula><p>Here position feature is used normally in DNN and GBDT training, however, the predicting score of DNN (input feature to GBDT) does not count the position bias to avoid cross interaction, i.e., the weight of position bias is set to 0 during prediction. GBDT+DNN: stacking GBDT and DNN. DNN and GBDT are first trained separately used the same training data. Given a sample x, the final result is the average of prediction scores, with the following formula:</p><formula xml:id="formula_11">p = σ ( ȳ); ȳ = 1 2 • y dnn + y gbdt (<label>8</label></formula><formula xml:id="formula_12">)</formula><p>We do not average the final predicted probability directly, instead the scores are averaged first and then input to sigmoid that returns the final probability.</p><p>LR+GBDT: Boosting LR with GBDT. It initializes the GBDT with a linear combination of input features learned by the LR. In other word, the pseudo target of a sample is initialized as the "residual" between the prediction score of LR and the real target before fitting the first tree f 1 (x). Although LR is a quite simple model, its prediction result has already good accuracy, i.e., the residual is quite small. Therefore, it is much easier to train compared with the original GBDT. The prediction scores of these T weak learners are 5 Wide&amp;Deep <ref type="bibr" target="#b7">[7]</ref> can train heterogenous feature combination with both sparse features and dense embedding. </p><formula xml:id="formula_13">y gbdt = γ 1 • f 1 (x) + T ∑ t=2 γ t • f t (x); f 1 (x) = arg min f N ∑ i=1 (y i , y lri + f (x i ));<label>(9)</label></formula><p>Yandex <ref type="bibr" target="#b25">[25]</ref> has adopted this boosting design for their ads CTR prediction. Instead of adding the predicted probability of LR directly, we actually add the logit computed by LR (w • x + b) first and then apply the sigmoid to get the final prediction. Position feature (or inverse position bias) is only used in LR, we do not use it in GBDT to avoid the interaction between position feature and other features. DNN+GBDT: boosting DNN with GBDT. Lastly, like LR+GBDT, DNN can also be boosted by GBDT. It first trains a DNN model, and the prediction score is used to initialize the GBDT (with T subtrees), i.e., the GBDT try to fit the residual between the optimal solution and DNN's result . Similarly, the prediction score of these T weak learners are added (boosted) sequentially to the prediction score of DNN, and feed the sum to sigmoid that returns the final probability. Given a sample x, the specific ensemble formula is as follows: p = σ (y dnn + y gbdt );</p><formula xml:id="formula_14">y gbdt = γ 1 • f 1 (x) + T ∑ t=2 γ t • f t (x); f 1 (x) = arg min f n ∑ i=1 (y i , y dnni + f (x i ));<label>(10)</label></formula><p>Figure <ref type="figure" target="#fig_1">3</ref> depicts the model structure, where the position feature is only used in DNN with the normalized (rather than reversed) value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EVALUATION</head><p>We have compared these model ensembles against our baseline setting, and DNN+GBDT turns out to have the best accuracy in terms of offline testing AUC and click yields in online traffic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Evaluation setup</head><p>Datasets. Training data used in this study consists of 56M examples which are randomly sampled from the logs generated in one month. For each sample, there are several hundreds of statistic features. To reduce the training cost, non-click cases are further down-sampled with a 50% sampling ratio. Each non-click sample is thus weighted by 2 such that the distribution is unchanged during the training. The model predicting accuracy is tested against dataset with 40M samples that are randomly drawn from the log generated in next week right after the training log. Without explicit description, all experiments have been applied to this dataset.</p><p>Accuracy Metric. The Area under Receiver Operating Characteristic Curve (AUC) <ref type="bibr" target="#b8">[8]</ref> and Relative Information Gain (RIG) <ref type="bibr" target="#b14">[14]</ref> are computed against the testing data to evaluate offline prediction accuracy. We calculate AUC normally, but with a small difference in RIG calculation that is defined as:</p><formula xml:id="formula_15">LL predict = - 1 N N ∑ i=1 y i • log p i + (1 -y i ) • log (1 -p i ), LL empirical = - 1 N N ∑ i=1 y i • log p e + (1 -y i ) • log (1 -p e ) RIG = LL predict LL empirical -1<label>(11)</label></formula><p>where y i is the observed label of testing sample i, p i is the predicted probability, and p e is the empirical CTR that is calculated by #clicks #impressions in testing set. LL predict represents the mean cross entropy (i.e., the average log-loss per impression), and LL empirical is the average log-loss per impression if the CTR is predicted by a naive model that always predicts with the average empirical CTR. Dividing by LL empirical makes RIG insensitive to the average empirical CTR. AUC essentially evaluates the rank order and RIG measures the goodness of predicted value. For example, if we apply a global multiplier 0.5 to all predicted values, RIG will change even though AUC remains the same. Modelling with higher AUC and RIG value is considered to have better accuracy. Note that we compute AUC or RIG both at position=ALL and position=ML1, position=ALL is computed against the entire testing set, while po-sition=ML1 is computed against a testing subset that consists of all samples impressed at ML1. In production, we care about AUC at position=ML1 more since the ads ranking, allocation and bidding are all based ML1 position, and in our experience, an AUC gain of 0.03% is statistically significant that exceeds the normal AUC variance and should not be neglected as noise.</p><p>The ensemble with significant offline accuracy will be picked for online A/B testing where we schedule two randomly sampled traffic buckets from full traffic as control and treatment. These two traffics have the same configuration settings through the whole serving stack except the click prediction model. We draw conclusion only when the online KPIs are statistic significant. We use the normalized click yield (CY) which removes the impact from the difference of impression yield. Configuration of Model Ensembles. The evaluated model ensembles are described in Table <ref type="table" target="#tab_1">1</ref>, respectively. All model ensembles are trained and tested using the same dataset. Note that position features are handled differently in different ensembles (Section 3). In this section, DNN is configured to share the same configuration as our baseline model (Figure <ref type="figure">2</ref>), i.e., a simple NN that has only one single hidden layer with 30 hidden units, and the activation is a sigmoid function. All features fed to LR and NN are first normalized by means of x-min max-min to ensure the value in [0,1]. The learning rate in DNN training starts from 0.005 and multiply by 0.2 every 4 iterations. The number of iterations (epoches) is 20 to avoid over-fitting based on the AUC gain trending on a validation set. Mini-batch size is 1 by default. LR is trained in full batch with LBFGS since the data size is small. There are 300 trees and each tree has 200 leaf nodes in GBDT, and the shrinkage ratio is 0.05 by default. The evaluation on different hyperparameter settings will be described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Experiment Results</head><p>The experiment results of various ensembles are listed in Table <ref type="table" target="#tab_1">1</ref>. All the results are compared with the baseline NN model. We care much more about the accuracy at the ML1 position, but the results at ML=ALL are still listed for reference. We can draw the observations and the corresponding explanations as follows: 1). The GBDT model has the best predictive accuracy among single models that has AUC lift 0.14% and RIG lift 0.36% than baseline NN, while LR is the worst with about 1.81% AUC loss. 2). LR is always weaker than NN, which is validated by the results that LR &lt; NN, LR2GBDT &lt; NN2GBDT , GBDT 2LR &lt; GBDT 2NN, and LR + GBDT &lt; NN + GBDT . This is within our expectations.</p><p>3). Almost all ensembles are better than the corresponding single model, with the only exception on GBDT2LR and LR+GBDT that are even worse than GBDT only. This indicates that boosting is better than cascading (will be described in the next part). It is noteworthy that GBDT2LR and LR+GBDT have been presented by Facebook <ref type="bibr" target="#b14">[14]</ref> and Yandex <ref type="bibr" target="#b25">[25]</ref>, respectively. They behaved poorly was probably because Facebook mainly works for feed ads and the position feature may be not as important as with search ads.</p><p>4). Boosting is powerful that it can even further boost a nonweak model such as NN, e.g., LR + GBDTV 2 &gt; LR, and NN + GBDT &gt; NN, and it is generally better than cascading/stacking. 5). Lastly, NN+GBDT that boosts NN with GBDT turns out to be the best with 0.40% AUC gain and 2.81% RIG gain, respectively. The online A/B testing indicates that it has 1.3% click gains in online traffic. With larger training data, it can bring additional 0.5% AUC gains. Besides the A/B testing, we also have holdout flight that validates the effectiveness of NN+GBDT. i.e, we have the same online gain after mainstreaming into production.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Findings and Insights</head><p>The importance of Position Feature. The right treatment of position feature actually plays a critical role in prediction accuracy. First, position feature should be used in inverted form rather than the normalized one for LR, given that LRV 2 &gt; LR, LR+GBDTV 2 &gt; LR + GBDT and LR2GBDTV 2 &gt; LR2GBDT . We need the inversed form because the final sigmoid will convert it back to position CTR which is empirical CTR. Second, position feature is the key factor in GBDT initialization and the boosting accuracy largely depends on the specific initialization. This is a key reason why NN + GBDT &gt; NN2GBDT &gt; GBDT &gt; LR + GBDT . In GBDT, we have the freedom to apply any kind of transformation on the position feature before initialization, while afterward, it is never changed and never used for splitting trees to avoid the interaction among position and other features. Single GBDT (GBDT ) and the cascaded GBDT (LR2GBDT and NN2GBDT ) are initialized with the manually-designed inverse transformation on position bias. However, it is hard to design a good transformation for a position feature, and the manual design usually leads to suboptimal accuracy. As a comparison, in boosting approach (NN + GBDT and LR + GBDT ), the transformation on position feature is automatically learned. For instance, in neutral net (shown in Figure <ref type="figure">2</ref>), the weight of position feature to the hidden unit and the weight of that hidden unit to output can be learned together with other weights of the statistic feature during training. NN + GBDT is better than LR + GBDT because NN is considered better than LR. Boosting is better than cascading. Most features in our setting are statistic features, they are updated frequently with dynamically changed value, e.g., for same &lt; query, ad &gt; pair, the feature values are dynamic with different values at different time interval. Therefore, there might be a split-point shift issue that the split point learned at one day may not suitable for some days later. In cascading ensembles (NN2GBDT and LR2GBDT ), the split points in the first tree are learned from scratch and the split points of the same feature may vary significantly. mode (NN + GBDT and LR + GBDT ), the split point shift issue is much less serious than cascading, since the GBDT starts from the result of NN and LR and just focuses on fitting the residual. We observe this issue at A/B testing when experimenting NN + GBDT and GBDT 2LR where NN is the baseline. During the entire 7 weeks, NN + GBDT and NN show stable and consistent prediction error, while the average click probability of GBDT 2LR is unstable and drops significantly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">TRAINING OPTIMIZATIONS</head><p>The next challenge is to optimize the performance and accuracy in offline training. The detailed specific design and implementation is beyond the scope of this paper. In this section, we will share several accuracy-critical factors and optimizations that have proven effective for GBDT and DNN, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Hyper-parameter tuning in GBDT</head><p>Data size and tree number. We first show that the accuracy of GBDT improves as we increase the training data and number of trees, as shown in Figure <ref type="figure" target="#fig_2">4</ref>. It is shown in the Figure <ref type="figure" target="#fig_3">4a</ref> that as training data increases from 30M samples to 500M samples, AUC improves from 0.40% to 0.49%, and the RIG improves from 2.8% to 3.6%. We then fix the training data with 30M samples to evaluate the impacts of tree number. Figure <ref type="figure" target="#fig_2">4b</ref> depicts that AUC improves from 0.29% to 0.52% and RIG improves from 2.1% to 3.2% when the number of trees increases from 100 to 2,400. RIG starts to degrade and AUC is saturated when tree number exceeds 2,000, which may be due to over-fitting. Note that accuracy gain can also been increased as we increase the number of leaf nodes (less than 400) in a single tree. This accuracy improvement is continuous but becomes smaller until over-fitting as we add more trees. We envision that more trees are required given more training data. Bin Number and Feature Sampling. The feature value is first prebinned <ref type="bibr" target="#b4">[4]</ref> to reduce the number of split candidates, thus smaller bins lead to faster training. However, the number of bins would affect the final prediction accuracy. Figure <ref type="figure" target="#fig_4">5a</ref> illustrates that 64 bins has the best accuracy and 16 bins has the worst accuracy, further increasing the bins does not improve the accuracy but with a little bit loss. We also perform stochastic boosting that randomly samples some features (or samples) to fit a tree. Figure <ref type="figure" target="#fig_4">5b</ref> shows that we can get the best accuracy with 60% sample rate, this roughly means that we can nearly save 40% of training time 6 . 6 The saving depends on the specific training implementation.</p><p>Shrinkage Rate. The accuracy also depends on the proper hyperparameter such as shrinkage rate. Shrinkage is a kind of tree regularization. The impacts on accuracy on ML1 position with different shrinkage (η) are shown in Figure <ref type="figure">6</ref>. For the small training set with 27M samples (Figure <ref type="figure" target="#fig_3">6a</ref>), there is little AUC difference for different shrinkage when tree number is less than 300. However, when the tree number increases from 300 to 2,400, the testing AUC decreases as we increase the shrinkage. As a comparison for the large training set with 470M samples (Figure <ref type="figure">6b</ref>), AUC makes continuous improvements for large shrinkage as we increase the tree number. This indicates that a large training set can afford a larger shrinkage. One possible reason is that a large amount of shrinkage for small training data tends to cause over-fitting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Accuracy Tuning for GBDT</head><p>Second Order Gradient. Inspired by XGBoost <ref type="bibr" target="#b4">[4]</ref>, we use second order Taylor expansion to approximate the loss function. Accordingly, the split gains and leaf scores are computed by considering the second order gradient. The difference on the split gain computing is shown in Table <ref type="table">2</ref>, where g(</p><formula xml:id="formula_16">x i ) = ∂ f t-1 (x i ) (y i , f (x i )) and h(x i ) = ∂ 2 f t-1 (x i ) (y i , f (x i ))</formula><p>are the first and second-order gradient on the loss function. For logloss, this second-order gradient based algorithm makes the model converge faster since the splitting gain calculation aims to reduce the global loss directly, rather than reduce the local loss of current tree that fits the pseudo residual (i.e., gradient). Figure <ref type="figure" target="#fig_6">7</ref> depicts the effectiveness of second-order gradient based training. Compared with the first-order method, AUC gain improves up to 0.05%. This will increase the training time by 20%-30%, since it introduces more computation in the split gain calculation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Method</head><p>Split-Gain Calculation first-order</p><formula xml:id="formula_17">gain s = (∑ x i ≤s g(x i )) 2 ∑x i ≤s 1 + (∑ x i &gt;s g(x i )) 2 ∑x i &gt;s 1 - (∑ parent g(x i )) 2 ∑parent 1 second-order gain s = (∑ x i ≤s g(x i )) 2 ∑x i ≤s h(x i ) + (∑ x i &gt;s g(x i )) 2 ∑x i &gt;s h(x i ) - (∑ parent g(x i )) 2 ∑parent h(x i )</formula><p>Table <ref type="table">2</ref>: Second-order gradient based split gain computation.</p><p>Negative Down-Sampling. A full day of Bing ads impression data can contain a huge amount of instances. On the one hand, more samples would achieve a better model. On the other hand, more samples will slowdown the training. Negative down-sampling <ref type="bibr" target="#b14">[14]</ref>, that keeps all positive (clicked) instances while performing uniform down-sampling for negative instances, has proven to be an effec- tive in speeding up the training. We re-weight the sample rather than re-calibrate the model <ref type="bibr" target="#b14">[14]</ref> to ensure the same average CTR after down-sampling. For instance, the negative samples are reweighted by 2 if the down-sampling rate is 50%. Experiments show that 50% sampling can save almost half the training time while the metrics are almost neutral (-0.01%/+0.02% AUC/RIG for ML1 position). Standard down-sampling does not consider the inherent imbalance in domains such as position. For instance, assume there are 40 positive and 60 negative samples at ML1 position, and 10 positive and 90 negative samples at ML4, after 50% down-sampling, the negative number becomes 30 and 45 at ML1 and ML4, respectively. Compared with the corresponding positive number, there are too few negative samples at ML1 while there are too many at ML4. In other words, the different positions should have different down-sampling rates. We have actually evaluated other sampling strategies that keep all positive/negative cases for clicked SRPV, and for non-clicked SRPV we either do uniform down-sampling, SRPV-wise down-sampling or position-wise down-sampling. The comparison among 4 different down-sampling methods against 120M data (after 50% down-sampling) indicates that position-wise negative down-sampling achieves the best accuracy.</p><p>Local Case-Control Sampling. We also evaluate the local casecontrol (LCC) <ref type="bibr" target="#b27">[27]</ref> sampling that does down-sampling for both positive and negative instances. The sampling is different for different instances. Specifically, whether or not a sample is added depends on the absolute prediction error from a pilot model (p(x)  </p><p>After LCC sampling, the ratio of instances, which have been learned well in NN as a pilot model, will drop and the ratio of poor learned cases will increase. GBDT then focuses more on these poorly learned cases with LCC sampling.   model with 30 hidden units. We can see that an increase in the complexity of DNN will have marginal gain, e.g., with only 0.02% extra gain when increase the units from 30 to 90. However, the AUC will not improve as we further increase the unit number, with even AUC and RIG loss when the unit number is 270. Similarly, if each hidden layer has 30 units, adding more hidden layers does not help and even cause loss; if each hidden layer has 120 units, 3 hidden layers is better than 2 hidden layers, but, adding more layers only brings marginal gain until it gets saturated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Sponsored search advertising relies heavily on the accurate, scalable and quick prediction of ad click-through rates. Click predic-  tion has received much attention from both industry and academia <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b16">16]</ref>. The majority of large scale models in industry make use of logistic regression <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b14">14]</ref> for its scalability and online learning capability. Google <ref type="bibr" target="#b21">[21]</ref> trains LR using an FTRL-Proximal online learning algorithm in order to increase model sparsity and memory saving. Microsoft <ref type="bibr" target="#b13">[13]</ref> develops a Bayesian online learning algorithm for sponsored search advertising in Bing Search Engine. Yahoo Criteo <ref type="bibr" target="#b3">[3]</ref> uses Bayesian logistic regression with hashing one-hot encoding features to predict clicks for advertising. The model updates with a new batch of data by leveraging the posterior distribution of a previously trained model as the prior for the new model. Facebook <ref type="bibr" target="#b14">[14]</ref> combines decision trees with logistic regression. Decision trees transform each sample into the 1-of-K coding of the index of the leaf it ends up falling in each tree.</p><p>Another trend of models for predicting click-through rate focuses on neural networks in order to improve the accuracy. Most of these works <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b23">23]</ref> focus on engineering the transformation of raw features. <ref type="bibr" target="#b29">[29]</ref> deploys factorization machines, or a samplingbased restricted Boltzmann machine or denoising autoencoder as the bottom layer of a deep neural framework in order to reduce dimensions from one-hot sparse features to dense continuous features. The deep crossing model <ref type="bibr" target="#b23">[23]</ref> uses a single layer of the neural network as the embedding layer for each individual feature in order to avoid handcrafting combinatorial features. The output embedding is then concatenated as the input to a residual network. Deep-Intent <ref type="bibr" target="#b28">[28]</ref> uses RNNs to model the word sequence in queries and ads. On top of RNN, they propose attention based pooling to represent a sequence by a weighted sum of the vector representations of all time steps. The work <ref type="bibr" target="#b30">[30]</ref> leverages the temporal dependency in user's behavior sequence through RNNs. However, these deep neural networks have marginal gains in real production. This is why we adopt a shallow neural network empowered by boosting tree ensembles to capture efficiency and accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION AND FUTURE WORK</head><p>In this paper, we share our experience on designing and optimizing the model ensembles to improve ads CTR prediction in Microsoft Bing Ads. The ensemble that boosts NN with the GBDT turns out to be the best in our setting. We also share the experience in accelerating the training performance and improving the training accuracy. We believe the model ensemble is a promising direction; meanwhile, as indicated by position feature, the domain knowledge is also indispensable in the ensemble design. In the future, we will experiment different feature separation and different ensemble designs to push the limit of accuracy, e.g., we will experiment different DNN architectures such as the RNNs as well as different learning algorithms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Graphical illustration of basic models: LR, DNN and GBDT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: DNN+GBDT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: GBDT accuracy is improved by increasing the size of training data and the number of trees.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>( a )</head><label>a</label><figDesc>Impacts on bin number. (b) Impacts on feature sampling rate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Impacts of hyper-parameter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>5. 3 Figure 6 :</head><label>36</label><figDesc>Figure 6: Impacts of learning rate on 27M training data (a), 470M training data (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Effectiveness of second-order gradient.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Impacts of different DNN layers and units.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>As a comparison, in boosting Comparisons among different model ensembles. The result is ordered by the AUC gain at ML1. NN+GBDT turns to be the best, and we can see the RIG is generally consistent with the AUC.</figDesc><table><row><cell>Models</cell><cell cols="4">Position=ML1 AUC Gain RIG Gain AUC Gain RIG Gain Position=ALL</cell><cell>Description</cell></row><row><cell>NN</cell><cell>0.00%</cell><cell>0.00%</cell><cell>0.00%</cell><cell>0.00%</cell><cell>NN with 1 hidden layer and 30 hidden units (baseline model)</cell></row><row><cell>LR</cell><cell>-1.97%</cell><cell>-16.14%</cell><cell>-1.46%</cell><cell>-10.01%</cell><cell>LR with normalized position bias</cell></row><row><cell>LR V2</cell><cell>-1.81%</cell><cell>-10.68%</cell><cell>-0.91%</cell><cell>-5.13%</cell><cell>LR with inversed position bias</cell></row><row><cell>GBDT2LR</cell><cell>0.06%</cell><cell>-0.17%</cell><cell>0.05%</cell><cell>0.44%</cell><cell>Cascade leaf index in GBDT as categorical feature to LR (used in Facebook [14])</cell></row><row><cell>LR+GBDT</cell><cell>0.12%</cell><cell>-1.87%</cell><cell>-0.33%</cell><cell>-1.93%</cell><cell>Boost LR with GBDT (used in Yandex [25])</cell></row><row><cell cols="2">LR2GBDT V2 0.13%</cell><cell>-0.14%</cell><cell>0.03%</cell><cell>0.67%</cell><cell>Cascade LR with inversed position bias to GBDT</cell></row><row><cell>GBDT</cell><cell>0.14%</cell><cell>0.36%</cell><cell>0.03%</cell><cell>0.91%</cell><cell>GBDT initialized with inversed position bias</cell></row><row><cell>LR2GBDT</cell><cell>0.14%</cell><cell>-0.27%</cell><cell>0.01%</cell><cell>0.50%</cell><cell>Cascade LR with normalized position bias to GBDT</cell></row><row><cell>GBDT2NN</cell><cell>0.16%</cell><cell>1.29%</cell><cell>0.04%</cell><cell>1.32%</cell><cell>Cascade GBDT to NN</cell></row><row><cell cols="2">LR+GBDT V2 0.24%</cell><cell>1.36%</cell><cell>0.07%</cell><cell>1.04%</cell><cell>Boost LR (inversed position bias) with GBDT</cell></row><row><cell>NN2GBDT</cell><cell>0.25%</cell><cell>0.15%</cell><cell>0.08%</cell><cell>0.72%</cell><cell>Cascade NN to GBDT</cell></row><row><cell>GBDT+DNN</cell><cell>0.25%</cell><cell>1.33%</cell><cell>0.15%</cell><cell>1.52%</cell><cell>Average NN and GBDT</cell></row><row><cell>NN+GBDT</cell><cell>0.40%</cell><cell>2.81%</cell><cell>0.15%</cell><cell>1.30%</cell><cell>Boost NN with GBDT</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3</head><label>3</label><figDesc></figDesc><table><row><cell>depicts the evalua-</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Offline metrics for lcc-sampling.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>We actually have long term and real-time counting feature, the long term ones are updated per day and the real time ones are updated in seconds.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p><ref type="bibr" target="#b3">3</ref> We can record these term-level counts as statistic features but with more overheads. One feasible approach is to feed the dense embedding of these sparse term-crossing features to DNN, and we treat it as future work.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>It has part of the benefit since only one model's parameters are changed.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We thank Pavel Serdyukov to invite this paper in the Industry Track. We are grateful the anonymous reviewers for their insightful comments. We thank Eren Manavoglu who kindly reviewed our paper and gave us valuable suggestions. Lastly, we would also like to show our gratitude to Lintao Zhang for his continued support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Internet advertising and the generalized second-price auction: Selling billions of dollars worth of keywords</title>
		<author>
			<persName><forename type="first">E</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michael</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The American economic review</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="242" to="259" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Empirical analysis of search advertising strategies</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">B C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vacha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Saikat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IMC</title>
		<imprint>
			<biblScope unit="page" from="79" to="91" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Simple and scalable response prediction for display advertising</title>
		<author>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Manavoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosales</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Intell. Syst. Technol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="61" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">XGBoost: A scalable tree boosting system</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<idno>CoRR, abs/1603.02754</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Factor modeling for advertisement targeting</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kapralov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Canny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">Y</forename><surname>Pavlov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="324" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Personalized click prediction in sponsored search</title>
		<author>
			<persName><forename type="first">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Cantú-Paz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WSDM</title>
		<imprint>
			<biblScope unit="page" from="351" to="360" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Wide &amp; deep learning for recommender systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Koc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Harmsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shaked</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Aradhye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ispir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Anil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Haque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Shah</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Auc optimization vs. error rate minimization</title>
		<author>
			<persName><forename type="first">C</forename><surname>Corinna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mehryar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIPS</title>
		<imprint>
			<biblScope unit="page" from="313" to="320" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An experimental comparison of click position-bias models</title>
		<author>
			<persName><forename type="first">N</forename><surname>Craswell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Zoeter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ramsey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="87" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Sponsored search: A brief history</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Fain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">O</forename><surname>Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of the American Society for Information Science and Technology</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="12" to="13" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable training of l1-regularized log-linear models</title>
		<author>
			<persName><forename type="first">A</forename><surname>Galen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Jianfeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICML</title>
		<imprint>
			<biblScope unit="page" from="33" to="40" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Web-scale bayesian click-through rate prediction for sponsored search advertising in Microsoft&apos;s Bing search engine</title>
		<author>
			<persName><forename type="first">T</forename><surname>Graepel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Q</forename><surname>Candela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Borchert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Herbrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Web-scale bayesian click-through rate prediction for sponsored search advertising in Microsoft&apos;s bing search engine</title>
		<author>
			<persName><forename type="first">T</forename><surname>Graepel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Q</forename><surname>Candela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Borchert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Herbrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Practical lessons from predicting clicks on ads at facebook</title>
		<author>
			<persName><forename type="first">X</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Atallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Herbrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bowers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Q N</forename><surname>Candela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ADKDD</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="5" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Welcome to kaggle competitions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Inc</surname></persName>
		</author>
		<ptr target="https://www.kaggle.com/competitions" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Sponsored search: an overview of the concept, history, and technology</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Jansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mullen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Electronic Business</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="114" to="131" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Field-aware factorization machines in a real-world online advertising system</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Juan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lafortier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Field-aware factorization machines for CTR prediction</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Juan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-J</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RecSys</title>
		<imprint>
			<biblScope unit="page" from="43" to="50" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Rectifier nonlinearities improve neural network acoustic models</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Hannun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICML</title>
		<meeting>ICML</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">30</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Follow-the-regularized-leader and mirror descent: Equivalence theorems and l1 regularization</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Mcmahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AISTATS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Ad click prediction: a view from the trenches</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Mcmahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sculley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ebner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grady</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Nie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Davydov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Golovin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chikkerur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Hrafnkelsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Boulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Predicting clicks: Estimating the click-through rate for new ads</title>
		<author>
			<persName><forename type="first">M</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Dominowska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ragno</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Deep Crossing: Web-scale modeling without manually crafted combinatorial features</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Hoens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<biblScope unit="page" from="255" to="262" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Factorization machines with follow-the-regularized-leader for CTR prediction in display advertising</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Big Data</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2889" to="2891" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Using boosted trees for click-through rate prediction for sponsored search</title>
		<author>
			<persName><forename type="first">I</forename><surname>Trofimov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kornetova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Topinskiy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ADKDD</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1" to="2" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title/>
		<ptr target="https://en.wikipedia.org/wiki/Ensemble_learning" />
	</analytic>
	<monogr>
		<title level="j">Wikipedia. Ensemble learning</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Local case-control sampling: Efficient subsampling in imbalanced data sets</title>
		<author>
			<persName><forename type="first">F</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Trevor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of statistics</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">1693</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">DeepIntent: Learning attentions for online advertising with recurrent neural networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>-H. Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KDD</title>
		<imprint>
			<biblScope unit="page" from="1295" to="1304" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Deep Learning over Multi-field Categorical Data</title>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="45" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Sequential click prediction for sponsored search with recurrent neural networks</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AAAI</title>
		<imprint>
			<biblScope unit="page" from="1369" to="1375" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
