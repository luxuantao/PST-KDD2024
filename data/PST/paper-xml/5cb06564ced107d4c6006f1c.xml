<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Identifying SDC-Causing Instructions Based on Random Forests Algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2019-03-31">March 31 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Liping</forename><surname>Liu</surname></persName>
							<email>liuliping_bit@163.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Linlin</forename><surname>Ci</surname></persName>
							<email>cilinlin_bit@126.com</email>
							<affiliation key="aff1">
								<orgName type="department">Computer department</orgName>
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei</forename><surname>Liu</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Computer department</orgName>
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hui</forename><surname>Yang</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Computer department</orgName>
								<orgName type="institution">Beijing Institute of Technology Beijing China</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Identifying SDC-Causing Instructions Based on Random Forests Algorithm</title>
					</analytic>
					<monogr>
						<idno type="ISSN">1976-7277</idno>
						<imprint>
							<date type="published" when="2019-03-31">March 31 2019</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.3837/tiis.2019.03.025</idno>
					<note type="submission">Received December 15, 2017; revised April 14, 2018; revised June 16, 2018; accepted July 15, 2018;</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-01-01T13:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Fault tolerance</term>
					<term>Error detection</term>
					<term>Reliability</term>
					<term>SDC-Causing instructions</term>
					<term>Random forests</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Silent Data Corruptions (SDCs) is a serious reliability issue in many domains of computer system. The identification and protection of the program instructions that cause SDCs is one of the research hotspots in computer reliability field at present. A lot of solutions have already been proposed to solve this problem. However, many of them are hard to be applied widely due to time-consuming and expensive costs. This paper proposes an intelligent approach named SDCPredictor to identify the instructions that cause SDCs. SDCPredictor identifies SDC-causing Instructions depending on analyzing the static and dynamic features of instructions rather than fault injections. The experimental results demonstrate that SDCPredictor is highly accurate in predicting the SDCs proneness. It can achieve higher fault coverage than previous similar techniques in a moderate time cost.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>With the processor design trends towards smaller transistor size, lower core voltage and higher frequency, the threat of soft errors becomes more and more serious. <ref type="bibr" target="#b0">[1]</ref>. Soft errors could lead to silent data corruption (SDC) which are difficult to be detected. When SDCs occur, the program executes normally, but the outputs of program are incorrect. Thus, with the sustained effect of Moore's Law, more and more transistors will be integrated into the chips, so that soft errors of hardware will occur more and more frequently <ref type="bibr" target="#b1">[2]</ref>.Therefore, necessary protection measures should be adopted to prevent SDC errors.</p><p>Hardware-based solutions such as triple modular redundant and dual modular redundancy increase the equipment cost greatly. Software-based solutions can also handle soft errors of hardware without any additional cost on hardware. Due to the advantages of cost savings, hardware-independent design, flexibility and implementation simplicity, software-based detection methods are being paid more and more attention in soft error mitigation research <ref type="bibr" target="#b2">[3]</ref>. To date some of these methods have already been applied to many fields including astronautics and high performance computing <ref type="bibr" target="#b3">[4]</ref>.</p><p>Compared with the hardware-based techniques, software-based techniques can save more hardware resources; nevertheless, they occurs significant performance overhead. Reducing performance overhead has become to be the top issue of such techniques. To reduce performance overheads, recent works tend to protect these SDC-prone instructions selectively <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref>.</p><p>It was recently reported that a small part of programs' instructions are responsible for most of SDCs, and protect these instructions selectively can achieve high coverage against SDCs <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>. These instructions are called SDC-prone instructions. Therefore, how to identify the SDC-prone instructions becomes a key problem.</p><p>Recently, a lot of works <ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref> try to improve the static injection framework. CriticalFault <ref type="bibr" target="#b9">[10]</ref> applies vulnerability analysis to avoid the derated fault injections. Relyzer <ref type="bibr" target="#b10">[11]</ref> employs pruning techniques to decrease the quantity of fault injections by predicting the outcomes of faults. Although the quantity of fault injections is reduced, the statistical fault injection (SFI) experiments are still time-consuming. SmartInjector <ref type="bibr" target="#b11">[12]</ref> proposes an intelligent fault injection framework to identify the SDC-prone instructions. It firstly decreases the quantity of fault injections by predicting the outcomes of faults, and then reduces the time for a single fault simulation by predicting the fault outcome prediction technique. Shoestring <ref type="bibr" target="#b12">[13]</ref> leverages compiler to analyze and identify the statistically vulnerable instructions. The time cost of Shoestring is low because it does not rely on any SFI injections. However, the compiler analysis technology is static and lack of dynamic analysis of program instructions, resulting in lower error coverage. SymPLIFIED <ref type="bibr" target="#b13">[14]</ref> identifies SDC-prone instructions using symbolic execution, which enumerates all potential hardware errors.</p><p>The work <ref type="bibr" target="#b15">[16]</ref> presents a selective protection technique that allows users to selectively protect these SDC-prone data. The main idea of work <ref type="bibr" target="#b15">[16]</ref> is predicting the SDC proneness of a program's data firstly, then selectively protects the most SDC-prone instructions of the program for the user-specified overhead bound. Since the prediction model is built based on the Classification and Regression Tree (CART) algorithm, the process of prediction do not need to perform fault injections. Therefore, it is more time-saving than fault injection based method. However, CART algorithm is easy to cause the over fitting which leads to a poor stability and low accuracy.</p><p>In this paper, by employing random regression forest algorithm, an ensemble regression prediction scheme, we propose a novel prediction model, SDCPredictor, to predict the SDC proneness of program instructions. SDCPredictor identifies SDC-causing Instructions depending on analyzing the static and dynamic features of instructions rather than fault injections, thus it can save a lot of time and manpower. Our experimental results demonstrate that SDCPredictor is more accurate in predicting the SDCs proneness than previous similar techniques in a moderate time cost. To summarize, our contributions are as follows:</p><p> We propose an intelligent approach named SDCPredictor to identify the instructions that cause SDCs. SDCPredictor identifies SDC-causing Instructions depending on analyzing the static and dynamic features of instructions rather than fault injections.</p><p> Our method assumes that different features are not equally important. To strengthen the generalization error of SDCPredictor, we employ weight value to represent the importance of the features. That means features with larger weights have high probability to be selected. In order to improve the prediction accuracy, we screen all trees by evaluating their quality. Those trees whose accuracy is lower will be excluded.</p><p>Only the trees whose accuracy is high enough will be reserved.</p><p> We evaluate the efficiency of proposed approach. The experimental results demonstrate that the proposed approach can acquire higher fault coverage at the same performance overhead bound than previous similar approaches.</p><p>The remainder of this paper is organized as follows. We review in brief the works related to identifying SDC-prone instructions in Section 2, while fault model of the proposed approach is presented in Section 3. In Section 4 we introduce the proposed approach. The results of the experiments are reported and analyzed in section 5, and finally section 6 summarizes the paper and points out the field of research in future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related Work</head><p>Considerable research efforts have been done to identify the SDC-causing instructions. A typical technique is modeling the SDC rate of SDC-causing instructions by performing fault injections. CriticalFault <ref type="bibr" target="#b9">[10]</ref> make use of vulnerability analysis to avoid derated injections. Relyzer <ref type="bibr" target="#b10">[11]</ref> employs pruning techniques to decrease the quantity of fault injections by predicting the outcomes of faults. Hardware faults with similar behavior are deemed to be equivalent faults and fall into one group. Only one representative fault is selected to implement fault injection for each group. SmartInjector <ref type="bibr" target="#b11">[12]</ref> proposes an intelligent fault injection framework to identify the SDC-prone instructions. It firstly decreases the quantity of fault injections by predicting the outcomes of faults, and then reduces the time consumption for an individual fault simulation by predicting the fault outcome prediction technique.</p><p>Instructions vulnerability analysis is another important solution to identify SDC-causing instructions. Shoestring <ref type="bibr" target="#b12">[13]</ref> uses a static compiler analysis technology to identify SDC-causing instructions, and protect them by inserting redundant instructions. Shoestring only considers the instructions which are possible to cause user-visible errors. These instructions which are possible to lead to SDC errors are left unprotected. Although Shoestring is time-saving, the SDC coverage is low. SymPLIFIED <ref type="bibr" target="#b13">[14]</ref> identifies SDC-prone instructions using symbolic execution, which enumerates all potential hardware errors. This might cost more time than SFI due to the state explosion problem caused by symbolic execution.</p><p>The work <ref type="bibr" target="#b14">[15]</ref> employs genetic algorithm (GA) to identify the most vulnerable sections of a program. By analyzing the dynamic dependencies between the program blocks, the proposed method can identify the most vulnerable basic blocks of a program precisely. However, some instructions of vulnerable blocks may make no contributions to the outputs of program. Protecting these instructions will incur high and unnecessary performance overhead. The work process of work <ref type="bibr" target="#b14">[15]</ref> is shown in Fig. <ref type="figure" target="#fig_0">1</ref>. The step 1 converts a program to a smaller and executable one. In step 2, the most vulnerable blocks of the input program are selected by GA.</p><p>Step 3 strengthens the identified vulnerable blocks. The work <ref type="bibr" target="#b15">[16]</ref> introduces a prediction model named SDCAuto to predict the SDC proneness of a program's instructions. SDCAuto is built using CART algorithm, requiring little to no human intervention. Therefore, it is no need to perform fault injections in the process of instructions selective protection against SDC-causing errors. Fig. <ref type="figure" target="#fig_1">2</ref> illustrates the diagram of the work <ref type="bibr" target="#b15">[16]</ref>. The work <ref type="bibr" target="#b15">[16]</ref> first compiles the source code into LLVM IR, and extracts instruction features based on LLVM IR file. Then, it obtains the SDC proneness for each instruction with the help of SDCAuto model. Finally, detectors are inserted into the source code for protecting the most SDC-prone instructions for the user-specified overhead bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Fault Model</head><p>SEU-induced soft errors fall into two categories: user-visible errors and user-invisible errors. User-visible errors usually cause architecture-level symptoms such as program crash or hang, which can be detected by symptom-based detection techniques. When the user-invisible errors occurs, the program executes normally and do not cause any abnormal symptoms. Nevertheless, the outputs of program are incorrect, i.e. SDC errors. These errors cannot be handled by symptom-based detection techniques. Therefore, we focus on SDC errors in this paper.</p><p>Faults in memory and caches are not considered, since these devices are usually protected with ECC. We focus on the faults that occur in processors' functional units and registers, which are not protected by fault-tolerant techniques due to performance reasons. Faults occur in processors' functional units and registers can lead to control flow errors and data flow errors.</p><p>We focus only data flow errors and assume that control flow errors are detected by control-flow checking techniques. Faults in the instruction opcode are also not considered, since it always causes illegal opcode exception rather than SDC.</p><p>Finally, as in work <ref type="bibr" target="#b15">[16]</ref>, we assume that at most one fault occurs during a program's execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Proposed method</head><p>SDCPredictor aims to build a intelligent prediction model which can predict the SDC proneness of program instructions accurately without faults injection. For this purpose, we extract some dynamic and static features of instructions and create training data set with the help of faults injection experiments. Based on the training data set, our prediction model is built using random regression forests.</p><p>To understand this paper better, some useful definitions which are used in this paper are presented.</p><p>SDC coverage: The SDC coverage is defined as the rate of SDC causing errors detected by error detection technology.</p><p>SDC proneness per instruction: This is the probability that a fault in instruction leads to an SDC. This is denoted as . Dynamic count ratio: This is the ratio of the number of dynamic instances of instruction executed to the total number of dynamic instructions in the program. This is denoted as . To understand our proposed method on a macro level, we give a brief presentation about its work process. The flow diagram of the proposed method is shown in Fig. <ref type="figure" target="#fig_2">3</ref>. Details of each element are as follows. We first introduces the extracted program features of instructions that highly correlated with SDC-prone. We then explain the implement of faults injection experiments on selected benchmark programs to generate training data set. Finally, we describe how to build our prediction model and design protected code. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Feature extraction</head><p>We extract features of instructions according to our analysis and prior work <ref type="bibr">[12, 13, 16, 17 and 18]</ref>. In all, 72 features are extracted. These features of instructions fall into nine categories shown in Table <ref type="table" target="#tab_0">1</ref>. Detailed categories results are as follows: Sub-word operations such as left shift operation and right shift operation often discard some bits of registers. Bit-flipping errors occurred in the discarded bits will be derated and will not cause SDCs. Thus, SDC proneness of the instruction operands will be reduced. (4) Logical operations related features. Logical operations such as AND operations and OR operations are possible to mask errors that occurred in corresponding bit of operands. For example, if a bit value of AND instruction operand is 1, then the bit-flipping errors occurred in the corresponding bit of other instruction operand will be masked. ( <ref type="formula" target="#formula_5">5</ref>) Successor instruction related features. When an error occurs, the error will propagate along the data dependency chain. When a SDC-masked instruction is encountered, the error is possible to be masked; otherwise it will propagate to the end points of data dependency chain and leads to an incorrect output. Therefore, the SDC proneness of precursor instructions in data dependency chain is affected by the successor instructions. ( <ref type="formula">6</ref>) Type of end points of data dependency chains related features. Different end points of data dependency chains have different effects on the outputs of program. <ref type="bibr" target="#b6">(7)</ref> Code structure related features. The SDC proneness of instructions is highly correlated with the execution probability of run-time. Thus, instructions on the hot paths of the program have higher SDC proneness due to the higher execution probability of run-time. (8) Data width related features. Data width is the effective number of bits of instruction operands. The higher the data width, the higher the SDCs rate of instructions will be. ( <ref type="formula">9</ref>) Execution time related features. Instructions executed with a higher frequency read and write resisters frequently. Corrupted data of resisters are most likely to be used by these instructions. Therefore, these instructions usually have a higher SDC proneness. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Fault injection and training data generation</head><p>In order to acquire high-quality training samples, we create training data set with the help of faults injection experiments. We use the famous fault injection tool PINFI <ref type="bibr" target="#b18">[19]</ref> to implement fault injection experiment. PINFI is built with Intel Pin <ref type="bibr" target="#b19">[20]</ref> and uses the API exposed by Pin to inject faults. We select 15 benchmarks which are drawn from SPEC benchmarks <ref type="bibr" target="#b20">[21]</ref>, NAS parallel benchmarks <ref type="bibr" target="#b21">[22]</ref>, Stanford benchmarks <ref type="bibr" target="#b22">[23]</ref>, Parboil benchmarks <ref type="bibr" target="#b23">[24]</ref> and PARSEC benchmarks <ref type="bibr" target="#b24">[25]</ref>. These benchmarks are divided into two groups randomly: training group and testing group. Table <ref type="table" target="#tab_1">2</ref> and Table <ref type="table" target="#tab_2">3</ref> provide a brief description of these benchmarks. We compile these benchmarks using LLVM compiler and provide the executable file to PINFI after linking.</p><p>Foregone studies showed that data dependencies among the instructions are important influence factors to SDC proneness and a large part of program instructions have no influence to the outputs of program. To simplify these programs, static-slicing technique <ref type="bibr" target="#b25">[26]</ref> are utilized to convert a program to a smaller and executable one. Converted program eliminates those instructions that have no influence to the outputs of program and can be executed normally.</p><p>First, we select some instructions as fault injection targets by running PINFI on each converted program.</p><p>Second, we inject faults into these selected instructions with the aid of statistical fault injection like Relyzer <ref type="bibr" target="#b10">[11]</ref>. To simulate the data corruption faults, we flip one certain bit of instruction's source operand register and each bit flips one time. In each run, a fault, i.e., a single bit flip, is injected into the operands register of the dynamic instruction instance. The outcome of the fault is compared with the fault-free outcome. The fault-free outcome is obtained by executing the original executable program with the same input. The outcome are divided into four categories by program execution results: (1) Crash, the program terminate unexpectedly and threw an exception, (2) SDC, when SDCs occur, the program executes normally, but the outputs of program are incorrect, (3) Hang, which means the execution time of program is much longer than a fault-free execution, and (4) Benign, which means the faults are derated or masked inherently by the program and the outputs of program are correct.</p><p>Third, the SDC proneness ) (SDC P of each instruction is obtained through the equation ( <ref type="formula">1</ref>)</p><formula xml:id="formula_0">) ( ) ( I D N N SDC P fault SDC × = (1)</formula><p>where SDC N is the SDC count caused by instruction I , fault N is the total number of initial faults attributed to the instruction I , D(I) is the dynamic count ratio of the instruction I . Finally, a sample } , { C F is generated, where F is the extracted features vector, and C is the annotated class label (i.e., SDC proneness).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Regression model training</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Selecting the classification algorithm</head><p>In order to better meet the requirements of our data and problem space, the machine learning algorithm must be selected carefully. We choose the Random Forest (RF) algorithm for the following three reasons:  Some features we extracted are boolean data types, e.g., is_ stack_push, is_load and is_cmp, while some other features are numerical, e.g., bb_length and data_width. Other regression algorithms might not support such a hybrid data types. RF is competent to such a hybrid data types.  Other regression models, such as deep neural network and support vector machine (SVM), need to normalize the input data. Besides, In order to achieve accurate prediction results many parameters need to be adjusted. While, RF requires little data preparation and parameters adjustment. denote the labeled regression values of the training samples (i.e., SDC proneness). We build the trees compliance with the random forest framework <ref type="bibr" target="#b26">[27]</ref>. For each tree in the random forest, we use the bootstrap resampling from the training samples to select the training subset. For each node split for building the tree, we select the random selection as the node split strategy.</p><p>Different features are not equally important. In other words, the importance of the different features to the SDC proneness of instructions is different. The more important the feature is, the more influence on the prediction results it has. Therefore, important features should have high probability to be selected. To do this, we employ weight value to represent the importance of the features. That means features with larger weights have high probability to be selected. We calculate the feature weight using the formula presented in <ref type="bibr" target="#b27">[28]</ref>. The formula for calculation the feature weight as follows:</p><formula xml:id="formula_1">2 2 2 1 1 ( ) m ij ij i j ij o e e χ = = − = ∑ ∑ (<label>2</label></formula><formula xml:id="formula_2">)</formula><p>where m is the number of feature A , ij o is the count of joint event ( i A , j C ), defined as:</p><formula xml:id="formula_3">( ) ij i j o count A a C c = = =  (3) ij e</formula><p>is the expected value of joint event ( i A , j C ), defined as:</p><formula xml:id="formula_4">( ) ( ) i j ij count A a count C c e N = × = = (4)</formula><p>where N is the number of training samples, count(A = i a ) is the number of samples whose value of feature A is i a , and count(C = j c ) is the number of samples whose value of the class feature is j c . An 2 χ statistic weight is calculated for each feature. From the weights, we select only different subsets of features with high weights to build individual decision trees.</p><p>In order to improve the prediction accuracy, we screen all trees by evaluating their quality. Those trees whose accuracy is lower will be excluded. Only the trees whose accuracy is high enough will be reserved. As previously described, we use the bootstrap resampling from the training samples to select the training subset. Samples selected for building a tree are called in-of-bag (IOB) data, while the rest is called out-of-bag (OOB) data. When a tree is built, we exploit the OOB data to evaluate its prediction accuracy through calculating the mean square error (MSE). The mean square error for a given regressor ( )</p><formula xml:id="formula_5">k h x is defined as: 2 1 ( ( ) ) s N N k i i i s h x C MSE N N − = − = − ∑<label>(5)</label></formula><p>where i x is a sample in the OOB data and i C is the class label of the sample i x . It can be seen from the formula: the smaller MSE of a tree, the higher accuracy is. Hence, we only retain trees whose MSE are below the predetermined threshold. Thus, the prediction accuracy of our random regression forests is increased.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">SDC proneness prediction</head><p>Once the random forest is built from training data-set, we can use it to estimate the SDC proneness of each instruction of the testing programs. The higher SDC proneness indicates higher SDC probability and greater importance. Therefore, the instructions with high SDC proneness should be given high priority. According to the importance of the instruction, the instructions selective duplication algorithm designs the detector to protect the most SDC-prone instructions for the user-specified overhead bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.4">Choose the instructions to protect and design detector</head><p>Based on the instruction's SDC proneness, we then select instructions to maximize the SDC coverage for the user-specified overhead bound through a standard dynamic programming algorithm <ref type="bibr" target="#b28">[29]</ref>. To protect these protected instructions, we need to insert duplicated instructions and check instructions, which we called detectors. These instructions are inserted immediately after the protected instructions. Our detectors use new registers and memory spaces and do not interfere with the original program semantics. By comparing the original value computed by the protected instruction with the value computed by the duplicated instructions, detectors can detect the errors occurred in protected instructions. If they match, it means that no errors occurred; otherwise, it means that an error has been detected and the control flow of program will be transferred to error handling routine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experimental evaluation</head><p>In this section experiments are designed to evaluate the effectiveness of the proposed approach, we choose five programs, namely Gzip, Ferret, Queens, CG and LBM, which are chosen form SPEC benchmarks <ref type="bibr" target="#b20">[21]</ref>, NAS parallel benchmarks <ref type="bibr" target="#b21">[22]</ref>, Stanford benchmarks <ref type="bibr" target="#b22">[23]</ref>, Parboil benchmarks <ref type="bibr" target="#b23">[24]</ref> and PARSEC benchmarks <ref type="bibr" target="#b24">[25]</ref> mentioned in section 4.2.</p><p>We compile these benchmarks using LLVM compiler and provide and run them in a single threaded mode. It should note that the proposed approach is not only applicable to single threaded mode. We conduct the evaluation experiment on an Intel i7 machine, with 8 GB of RAM and 400 GB Hard drive running Debian Linux Version 6.0. SDC proneness accuracy, SDC coverage and time efficiency are important metrics for evaluating our approach. Therefore, we carry out a detailed test and analysis to these metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">SDC proneness accuracy</head><p>Prediction the SDC proneness of instructions is the key of machine learning based selective protection technique. The prediction accuracy determines the error detection rate. To acquire an accurate prediction effect, parameters of prediction model need to be tuned. For random regression forests model, three parameters play determinative roles in improving the prediction accuracy: (1) maximum number of features in individual tree, and (2) number of trees, and (3) minimum sample leaf size of an individual tree. Setting a reasonable value for the first parameter can maintain the diversity of the trees and increase the generalization ability of prediction model. We set it to the recommended value n , where n is the total number of features. The second parameter is a decisive parameter for the prediction accuracy. In order to find the optimal value, we gradually increased it from 50 with a step-size 2 until the prediction accuracy becomes stable or decreasing. Finally, we set the optimal value to 215. Setting a reasonable value for the third parameter can avoid over-fitting problem. According to our experimental scene, we set the value to 100.</p><p>We evaluate the predicting accuracy of our prediction model by calculating the average squared errors of testing data-set and the accuracy (the percentage of the samples whose SDC proneness estimation error is less than 10%) of SDC proneness estimation. The MSE and accuracy are shown in Table <ref type="table" target="#tab_4">4</ref>. From the Table <ref type="table" target="#tab_4">4</ref> it can be seen that our model achieve high prediction accuracy of SDCs proneness. The high accuracy benefits from the following aspects. Firstly, we give different selection probability to features with different weight. This enhances the generalizing ability of each tree of random forests. Besides, we create training data set with the help of faults injection experiments which acquires high-quality training samples. In addition, the process of optimizing parameters improves the prediction accuracy. More importantly, the extended features such as data propagation distance and the type of SDC-masked instructions included in the successor instructions make a great contribution to the prediction accuracy. Therefore, the proposed approach can guide error detection mechanism to make the best detector placement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">SDC coverage</head><p>In this paper we define the SDC coverage as the rate of errors detected by our error detection technology. We apply our approach to predict the SDC proneness for each instructions of a program. Under the user-specified overhead bound, we select these instructions with the highest SDC proneness, and expand the set of protected instructions under the performance overhead constrains. We inject faults into these protected instructions with the aid of statistical fault injection like Relyzer <ref type="bibr" target="#b10">[11]</ref>, and then collect the number of errors detected by our error detection technology. Finally, we calculate the SDC coverage according the results calculated. We also compare our results with the work <ref type="bibr" target="#b14">[15]</ref> and SDCAuto presented in work <ref type="bibr" target="#b15">[16]</ref>. We use our approach to maximize SDC coverage under the user-specified performance overhead.</p><p>By computing the SDC coverage of each program under the same performance overhead bound, we compare our method with work <ref type="bibr" target="#b14">[15]</ref> and SDCAuto. We select three performance overhead bounds: 10%, 20% and 30%. Fig. <ref type="figure" target="#fig_4">4</ref> shows the statistical results obtained by our approach (SCDPredictor), work <ref type="bibr" target="#b14">[15]</ref> and SDCAuto for each benchmark. As it can be seen in Fig. <ref type="figure" target="#fig_4">4</ref>, the averages SDC coverage for SCDPredictor, Work <ref type="bibr" target="#b14">[15]</ref> and SDCAuto are 34.68%, 25.84% and 32.3% respectively for the 10% performance overhead bound, the corresponding averages SDC coverage are 51.4%, 40.4% and 47.8% for the 20% performance overhead bound, and 69.0%, 56.04% and 62.16% for the 30% performance overhead bound. It can be seen that the SCDPredictor acquires highest SDC coverage at the same performance overhead bound. That came out of work <ref type="bibr" target="#b14">[15]</ref> uses genetic algorithm (GA) to identify the most vulnerable blocks of a program. However, not all the instructions of vulnerable blocks make contributions to the outputs of program and need to be protected. Protecting these instructions will incur high performance overhead. The models of SCDPredictor and SDCAuto are built using machine learning approaches. These models can predict the SDC proneness of each instruction. Instructions with highly SDC proneness are duplicated and protected. Thus, SCDPredictor and SDCAuto obtain higher SDC coverage than work <ref type="bibr" target="#b14">[15]</ref>. Since SDCAuto is built using CART, which is easy to cause the over fitting, it is lack of prediction robustness and stability. Unlike SDCAuto, SCDPredictor is built using random regression forests, which hardly cause over-fitting and are insensitive to noisy data due to it constructs a number of weak learners. More importantly, SCDPredictor can obtain higher accuracy in predicting the SDCs proneness than SDCAuto. Therefore, SCDPredictor acquires highest SDC coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Time efficiency</head><p>In this subsection, the time efficiency of the proposed method is evaluated. The time efficiency is defined as the time consumed for identifying the program instructions which need to be protected. We record the consuming time for identifying instructions of each benchmark under a user-specified overhead bound. The results in Fig. <ref type="figure" target="#fig_5">5</ref> show that the average consuming times for SCDPredictor, Work <ref type="bibr" target="#b14">[15]</ref> and SDCAuto are 0.67h, 1.60h and 0.6h respectively for the 10% performance overhead bound, the corresponding average consuming times are 0.86h, and 0.79h for the 20% performance overhead bound, and 1.14h, 3.32h and 1.09h for the 30% performance overhead bound.</p><p>We observe that the SCDPredictor model performs worse than the SDCAuto model, but still manages to outperform Work <ref type="bibr" target="#b14">[15]</ref> in terms of time efficiency. For SCDPredictor and SDCAuto, most of the times are spent on the feature extraction, SDC proneness prediction and selection algorithm. Feature extraction needs to traverse all instructions of application. Some features also need to execute application multiple times. Thus, the complexity of feature extraction can be approximated as ( ) O mn , where m is the total number of features and n is the total number of instructions. The prediction model of SDCAuto is built using CART, which has a complexity of ( )</p><p>O n , where n is the depth of tree. While, the prediction model of SCDPredictor is built using random forests. The complexity of random forests is ( ) O kn , where k is the total number of trees and n is the depth of tree. The complexity of selection algorithm can be approximated as ( ) O n .Therefore, the consuming time gap between SCDPredictor and SDCAuto is mainly due to the process of SDC proneness prediction.</p><p>Work <ref type="bibr" target="#b14">[15]</ref> exploits the genetic algorithm (GA) to identify the most vulnerable blocks of a program. In Work <ref type="bibr" target="#b14">[15]</ref>, the BB subsequence in code execution path which is selected in the control flow graph is treated as a chromosome. In order to evaluate the fitness of a chromosome, BBs of the chromosome are several times. Thus, the complexity of Work <ref type="bibr" target="#b14">[15]</ref> can be approximated as ( ln )</p><p>O n n , where n is the total number of BBs. Therefore, the Work <ref type="bibr" target="#b14">[15]</ref> is the most time-consuming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions and Future Research</head><p>In order to overcome the shortcomings of instruction selective recalculation, such as huge time cost and low error coverage, a prediction model named SDCPredictor based on random forests is proposed. SDCPredictor does not need to perform fault injections to predict the SDC proneness of each instruction. In order to strengthen the generalization error of SDCPredictor, we choose features according to their weights when building the individual tree of random forests. To acquire high-quality training samples, we create training data set with the help of faults injection experiments. Besides, for better prediction accuracy, we screen all trees by evaluating their quality. Those trees whose accuracy is lower will be discarded. Only those trees whose accuracy is high enough will be kept. Thus, SDCPredictor obtains higher prediction accuracy of SDC proneness for each instruction. We assess the effectiveness of SDCPredictor from three metrics: SDC proneness accuracy, SDC coverage and time efficiency. The experimental results demonstrate that SDCPredictor is highly accurate in predicting the SDCs proneness. It can achieve higher fault coverage than previous similar techniques in a moderate time cost.</p><p>Invariant based detection techniques incur lower overhead than duplication-based detection techniques. Existing invariant based detection techniques have drawbacks in terms of false alarm and low error coverage, which have affected their application. Therefore, developing efficient invariant based detection techniques are the further research directions for our research group.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Block diagram of the work [15]</figDesc><graphic url="image-1.png" coords="4,142.67,248.52,335.55,77.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Block diagram of the work<ref type="bibr" target="#b15">[16]</ref> </figDesc><graphic url="image-2.png" coords="4,99.47,451.07,380.15,79.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Flow diagram of the proposed method</figDesc><graphic url="image-7.png" coords="5,116.27,495.97,387.35,72.95" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>( 1 )</head><label>1</label><figDesc>Comparison operations related features. Comparison operations may cause the control flow deviation, which cannot be detected by existing control flow checking techniques because such comparison operations are resilient. Some errors may be masked by comparison operations. (2)Memory address calculation related features. Accessed memory address must be in legal address space. If the accessed memory address exceeds the legal bound, this operation will lead to a segmentation fault. If not, the operation is possible to cause SDCs. (3) Sub-word operations related features.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The comparison of SDC coverage under different overhead bounds: 10%, 20% and 30%</figDesc><graphic url="image-10.png" coords="12,207.76,375.76,194.40,128.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. The comparison of time efficiency under different performance overhead bounds: 10%, 20% and 30%</figDesc><graphic url="image-13.png" coords="13,200.31,528.16,209.55,148.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Some features extracted for Model Building</figDesc><table><row><cell>Feature group</cell><cell>Feature</cell><cell>Description</cell></row><row><cell>Comparison</cell><cell>is_cmp</cell><cell>whether the operation is a comparison operation</cell></row><row><cell>operations related</cell><cell>is_loop_terminator</cell><cell>whether the comparison result can determine the</cell></row><row><cell>features</cell><cell></cell><cell>time of loop execution</cell></row><row><cell></cell><cell>is_cmp_with_zero</cell><cell>whether the comparison is made with zero</cell></row><row><cell></cell><cell>is_cmp_with_address</cell><cell>whether memory address is exist in the operands</cell></row><row><cell></cell><cell></cell><cell>of comparison operation</cell></row><row><cell>Memory access</cell><cell>is_read</cell><cell>whether the operation read data from memory</cell></row><row><cell>and addressing</cell><cell>is_memory_addressing</cell><cell>whether the result of operation is used to address</cell></row><row><cell>related features</cell><cell></cell><cell>memory</cell></row><row><cell></cell><cell>is_write</cell><cell>whether the operation write data to memory</cell></row><row><cell>Sub-word</cell><cell>is_shl</cell><cell>whether the instruction is a left shift operation</cell></row><row><cell>operations related features</cell><cell>is_shr</cell><cell>whether the instruction is a right shift operation</cell></row><row><cell>Logical</cell><cell>is_and</cell><cell>whether the instruction is a logic "and" operation</cell></row><row><cell>operations related</cell><cell>is_or</cell><cell>whether the instruction is a logic "or" operation</cell></row><row><cell>features</cell><cell>is_xor</cell><cell>whether the instruction is a logic "xor" operation</cell></row><row><cell>Successor</cell><cell>shl_instructions_count</cell><cell>The number of left shift instructions contained in</cell></row><row><cell>instruction related</cell><cell></cell><cell>successor instruction</cell></row><row><cell>features</cell><cell>shr_instructions_count</cell><cell>The number of right shift instructions contained in</cell></row><row><cell></cell><cell></cell><cell>successor instruction</cell></row><row><cell>Type of end</cell><cell>is_global</cell><cell>whether the operation modify the value of global</cell></row><row><cell>points of data</cell><cell></cell><cell>variable</cell></row><row><cell>dependency</cell><cell>is_stack_push</cell><cell>whether the operation push a value to stack</cell></row><row><cell>chains related</cell><cell>is_function_call</cell><cell>whether the operation call a function</cell></row><row><cell>features</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Characteristics of the training benchmarks.</figDesc><table><row><cell>Program</cell><cell>Description</cell><cell>Benchmark suite</cell></row><row><cell>Bzip2</cell><cell>program File compression and decompression</cell><cell>SPEC benchmarks</cell></row><row><cell>Perlbench</cell><cell>SPEC benchmark for perl interpreter</cell><cell>SPEC benchmarks</cell></row><row><cell cols="2">Blackscholes Financial analysis program</cell><cell>PARSEC benchmarks</cell></row><row><cell>Swaptions</cell><cell>Price portfolio of swaptions</cell><cell>PARSEC benchmarks</cell></row><row><cell>TSP</cell><cell>Solving the TSP problem by genetic algorithms</cell><cell>Stanford benchmarks</cell></row><row><cell>Qsort</cell><cell>quick-sort algorithm</cell><cell>Stanford benchmarks</cell></row><row><cell>IS</cell><cell>Integer sorting, random memory access</cell><cell>NAS benchmarks</cell></row><row><cell>EP</cell><cell>Embarrassingly Parallel</cell><cell>NAS benchmarks</cell></row><row><cell>BFS</cell><cell>Breadth-First search</cell><cell>Parboil benchmarks</cell></row><row><cell>MM</cell><cell>Dense Matrix-Matrix Multiply</cell><cell>Parboil benchmarks</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 .</head><label>3</label><figDesc>Characteristics of the testing benchmarks.</figDesc><table><row><cell>Program</cell><cell>Description</cell><cell>Benchmark suite</cell></row><row><cell>Gzip</cell><cell>File compression program</cell><cell>SPEC benchmarks</cell></row><row><cell>Ferret</cell><cell>Similarity search program</cell><cell>PARSEC benchmarks</cell></row><row><cell>Queens</cell><cell>Solving the classic n-queens problem</cell><cell>Stanford benchmarks</cell></row><row><cell>CG</cell><cell>access and communication Conjugate Gradient, irregular memory</cell><cell>NAS benchmarks</cell></row><row><cell>LBM</cell><cell>Fluid dynamics computing program</cell><cell>Parboil benchmarks</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>In recent years, more and more research results prove that RF is one of the most accurate techniques and is currently regarded as the most advanced prediction method. A random regression forest is an ensemble of regression methods which consisting of multiple decision trees. A single decision tree could cause over fitting, while this problem can be largely avoided by multiple randomly trained decision trees. RF can give estimates of what variables are important in the classification. It also can effectively estimate missing data and maintain accuracy.Our prediction model based of random regression forests is trained by samples with 72 feature vectors. The full training samples have 10000 training instructions. Our random regression forest is constructed based on these training instructions. In classification, random forest uses voting mechanism to determine the classification result. In regression, the regression value of forest is obtained by computing the average value of the individual tree predictions. Let</figDesc><table><row><cell cols="7">4.3.2 Training random regression forests</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>F</cell><cell>= {</cell><cell>f</cell><cell>i</cell><cell>∈</cell><cell>| = 1, 2, . . . , N} R i</cell><cell>denote the feature vectors, and let</cell><cell>C</cell><cell>=</cell><cell>, 1 c {</cell><cell>c</cell><cell>, 2</cell><cell>.</cell><cell>.</cell><cell>.</cell><cell>,</cell><cell>} N c</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 .</head><label>4</label><figDesc>The MSE and accuracy of the testing programs.</figDesc><table><row><cell>Program</cell><cell>MSE</cell><cell>Accuracy</cell></row><row><cell>Gzip</cell><cell>0.00548</cell><cell>88.77%</cell></row><row><cell>Ferret</cell><cell>0.00249</cell><cell>94.55%</cell></row><row><cell>Queens</cell><cell>0.00179</cell><cell>95.29%</cell></row><row><cell>CG</cell><cell>0.00362</cell><cell>91.65%</cell></row><row><cell>LBM</cell><cell>0.00428</cell><cell>90.13%</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>This research was supported by the National Natural Science Foundation of China under grant No. 61370134, the National High Technology Research and Development Program of China (863 Program) under grant No. 2013AA013901.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Novel Approach for Reduction of Soft Errors in Logic Circuits</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bhattacharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName><surname>Radjam</surname></persName>
		</author>
		<idno type="DOI">10.1109/VLSI.Design.2009.76</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2009 22nd International Conference on VLSI Design</title>
				<meeting>of 2009 22nd International Conference on VLSI Design</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="453" to="458" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Perturbation-based Fault Screening</title>
		<author>
			<persName><forename type="first">P</forename><surname>Racunas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Constantinides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Manne</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2007.346195</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2007 IEEE 13th International Symposium on High Performance Computer Architecture</title>
				<meeting>of 2007 IEEE 13th International Symposium on High Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">SWIFT: software implemented fault tolerance</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Reis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vachharajani</surname></persName>
		</author>
		<idno type="DOI">10.1109/CGO.2005.34</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Symposium on Code Generation and Optimization</title>
				<meeting>of International Symposium on Code Generation and Optimization</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="243" to="254" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Selective SWIFT-R: A flexible software-based technique for soft error mitigation in low-cost embedded systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Restrepocalle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Martnezlvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cuencaasensi</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPCA.2007.346195</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Electronic Testing</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="825" to="838" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Evaluating Redundancy in Data-flow Software-based Techniques</title>
		<author>
			<persName><forename type="first">E</forename><surname>Chielle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Azambuja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R S</forename><surname>Barth</surname></persName>
		</author>
		<idno type="DOI">10.1109/TNS.2013.2266917</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Radiation and ITS Effects on Components and Systems. Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Assuring application-level correctness against soft errors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gururaj</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICCAD.2011.6105319</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2011 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)</title>
				<meeting>of 2011 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="150" to="157" />
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient fault tolerance in multi-media applications through selective instruction replication</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aakel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lockhart</surname></persName>
		</author>
		<idno type="DOI">10.1145/1366224.1366227</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of The Workshop on Radiation Effects and Fault Tolerance in Nanometer Technologies, ACM</title>
				<meeting>of The Workshop on Radiation Effects and Fault Tolerance in Nanometer Technologies, ACM</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="339" to="346" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Low-cost program-level detectors for reducing silent data corruptions</title>
		<author>
			<persName><forename type="first">S K S</forename><surname>Hari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Naeimi</surname></persName>
		</author>
		<idno type="DOI">10.1109/DSN.2012.6263960</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2012</title>
				<meeting>of IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2012</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Error detector placement for soft computation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pattabiraman</surname></persName>
		</author>
		<idno type="DOI">10.1109/DSN.2013.6575353</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2013 43rd Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)</title>
				<meeting>of 2013 43rd Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Understanding soft error propagation using Efficient vulnerability-driven fault injection</title>
		<author>
			<persName><forename type="first">X</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Li</surname></persName>
		</author>
		<idno type="DOI">10.1109/DSN.2012.6263923</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2012)</title>
				<meeting>of IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2012)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Relyzer: Application Resiliency Analyzer for Transient Faults</title>
		<author>
			<persName><forename type="first">S K S</forename><surname>Hari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Naeimi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2189750.2150990</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="58" to="66" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">SmartInjector: Exploiting intelligent fault injection for SDC rate analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Tan</surname></persName>
		</author>
		<idno type="DOI">10.1109/DFT.2013.6653612</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE International Symposium on Defect and Fault Tolerance in Vlsi and Nanotechnology Systems</title>
				<meeting>of IEEE International Symposium on Defect and Fault Tolerance in Vlsi and Nanotechnology Systems</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="236" to="242" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Shoestring: probabilistic soft error reliability on the cheap</title>
		<author>
			<persName><forename type="first">S</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ansari</surname></persName>
		</author>
		<idno type="DOI">10.1145/1735970.1736063</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems</title>
				<meeting>of Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="385" to="396" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SymPLFIED: Symbolic Program-Level Fault Injection and Error Detection Framework</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pattabiraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Nakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z T</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<idno type="DOI">10.1109/TC.2012.219</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2292" to="2307" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An efficient vulnerability-driven method for hardening a program against soft-error using genetic algorithm</title>
		<author>
			<persName><forename type="first">B</forename><surname>Arasteh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bouyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pirahesh</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.compeleceng.2015.09.020</idno>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Electrical Engineering</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="25" to="43" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Configurable Detection of SDC-causing Errors in Programs</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rivers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J A</forename><surname>Rivers</surname></persName>
		</author>
		<idno type="DOI">10.1145/3014586</idno>
	</analytic>
	<monogr>
		<title level="j">Acm Transactions on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">88</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>Article. CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Characterization of Instruction-level Error Derating and its Implications for Error Detection</title>
		<author>
			<persName><forename type="first">J J</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zilles</surname></persName>
		</author>
		<idno type="DOI">10.1109/DSN.2008.4630119</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2008 IEEE International Conference on Dependable Systems and Networks With FTCS and DCC (DSN)</title>
				<meeting>of 2008 IEEE International Conference on Dependable Systems and Networks With FTCS and DCC (DSN)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="482" to="491" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">IPAS: Intelligent protection against silent output corruption in scientific applications</title>
		<author>
			<persName><forename type="first">I</forename><surname>Laguna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D F</forename><surname>Richards</surname></persName>
		</author>
		<idno type="DOI">10.1145/2854038.2854059</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE/ACM International Symposium on Code Generation and Optimization</title>
				<meeting>of IEEE/ACM International Symposium on Code Generation and Optimization</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="227" to="238" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Quantifying the Accuracy of High-Level Fault Injection Techniques for Hardware Faults</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<idno type="DOI">10.1109/DSN.2014.2</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE/IFIP International Conference on Dependable Systems and Networks</title>
				<meeting>of IEEE/IFIP International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="375" to="382" />
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Pin:building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<idno type="DOI">10.1145/1064978.1065034</idno>
	</analytic>
	<monogr>
		<title level="j">Acm Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="190" to="200" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note>Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">SPEC CPU2006 benchmark descriptions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Henning</surname></persName>
		</author>
		<idno type="DOI">10.1145/1186736.1186737</idno>
	</analytic>
	<monogr>
		<title level="j">Acm Sigarch Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>CrossRef Link</orgName>
		</respStmt>
	</monogr>
	<note>Article</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The NAS parallel benchmarks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bailey</surname></persName>
		</author>
		<idno type="DOI">10.1177/109434209100500306</idno>
	</analytic>
	<monogr>
		<title level="j">International Journal of Supercomputer Applications</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="158" to="165" />
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>CrossRef Link</orgName>
		</respStmt>
	</monogr>
	<note>Article</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Fault injection techniques and Computer</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hsueh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T K</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename></persName>
		</author>
		<idno type="DOI">10.1109/2.585157</idno>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Article (CrossRef Link</publisher>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Parboil: A Revised Benchmark Suite for Scientific and Commercial Throughput Computing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Stratton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rodrigrues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I.-J</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Obeid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-M</forename><forename type="middle">W</forename><surname>Hwu</surname></persName>
		</author>
		<idno>IMPACT-12-01</idno>
	</analytic>
	<monogr>
		<title level="j">UIUC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The PARSEC benchmark suite:characterization and architectural implications</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bienia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J P</forename><surname>Singh</surname></persName>
		</author>
		<idno type="DOI">10.1145/1454115.1454128</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of International Conference on Parallel Architectures and Compilation Techniques</title>
				<meeting>of International Conference on Parallel Architectures and Compilation Techniques</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="72" to="81" />
		</imprint>
	</monogr>
	<note>CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Program slicing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weiser</surname></persName>
		</author>
		<idno type="DOI">10.1109/TSE.1984.5010248</idno>
		<idno>SE-10</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="352" to="357" />
			<date type="published" when="1984">1984</date>
			<publisher>Article (CrossRef Link</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Random Forests</title>
		<author>
			<persName><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4419-9326-7_5</idno>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
				<imprint>
			<publisher>Article (CrossRef Link</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="5" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Feature Weighting Random Forest for Detection of Hidden Web Search Interfaces</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Deng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Computational Linguistics and Chinese Language Processing</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="387" to="404" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Handbook of Combinatorial Optimization</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pisinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4613-0303-9_5</idno>
		<imprint/>
	</monogr>
	<note>Knapsack Problems. 4 n.1(5):xx, 1998. Article (CrossRef Link</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Currently, he is studying for his PhD Degree at Computer Science in Beijing Institute of Technology. His current research interests include Secure Wireless Sensor Networks,Pattern Recognition, and Trusted Computing</title>
		<imprint>
			<date type="published" when="1985">2008 and 2011. 1985</date>
			<pubPlace>China; China</pubPlace>
		</imprint>
		<respStmt>
			<orgName>North University of China from Dept. of Computer Science ; of Computer Science from Beijing Institute of Technology, China ; of Computer Science from Northwestern Polytechnical University</orgName>
		</respStmt>
	</monogr>
	<note>Currently, he is professor and doctoral supervisor in computer application. His research areas include Secure Wireless Sensor Networks, Pattern Recognition, and Trusted Computing</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Currently, he is studying for his PhD Degree at Computer Science in Beijing Institute of Technology. His current research interests include Secure Wireless Sensor Networks</title>
		<imprint>
			<date type="published" when="2008">2008 and 2011</date>
			<pubPlace>China</pubPlace>
		</imprint>
		<respStmt>
			<orgName>North University of China from Dept. of Computer Science</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Currently, he is studying for his PhD Degree at Computer Science in Beijing Institute of Technology. His current research interests include Secure Wireless Sensor Networks</title>
		<imprint>
			<date type="published" when="2008">2008 and 2011</date>
			<pubPlace>China</pubPlace>
		</imprint>
		<respStmt>
			<orgName>North University of China from Dept. of Computer Science</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
