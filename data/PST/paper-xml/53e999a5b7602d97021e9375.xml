<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A New Bluetooth Scatternet Formation Protocol *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ching</forename><surname>Law</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<address>
									<addrLine>305 Memorial Drive, Cam-bridge</addrLine>
									<postCode>02139</postCode>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amar</forename><forename type="middle">K</forename><surname>Mehta</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kai-Yeung</forename><surname>Siu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A New Bluetooth Scatternet Formation Protocol *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0C3B94FD41935872011F2A63414AA9C9</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Bluetooth</term>
					<term>ad hoc networks</term>
					<term>resource discovery</term>
					<term>topology construction</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A Bluetooth ad hoc network can be formed by interconnecting piconets into scatternets. The constraints and properties of Bluetooth scatternets present special challenges in forming an ad hoc network efficiently. In this paper, we present and analyze a new randomized distributed protocol for Bluetooth scatternet formation. We prove that our protocol achieves O(log n) time complexity and O(n) message complexity. The scatternets formed by our protocol have the following properties: (1) any device is a member of at most two piconets, and (2) the number of piconets is close to be optimal. These properties can help prevent overloading of any single device and lead to low interference between piconets. We validate the theoretical results by simulations, which also show that the scatternets formed have O(log n) diameter. As an essential part of the scatternet formation protocol, we study the problem of device discovery: establishing multiple connections simultaneously with many Bluetooth devices. We investigate the collision rate and time requirement of the inquiry and page processes. Our simulation results indicate that the total number of packets sent is O(n) and that the maximum number of packets sent by any single device is O(log n).</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Bluetooth <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b21">22]</ref> is an emerging low-cost and low-power short-range radio technology. Many useful applications can be supported by an ad hoc network over Bluetooth. For example, in a conference room, a special announcement can be broadcast to the Bluetooth-enabled mobile phones and handheld computers through an ad hoc network. Bluetooth ad hoc networks can also be used for rapid deployment of EMID (electromagnetic identification) readers <ref type="bibr" target="#b1">[2]</ref>.</p><p>The area of ad hoc networking has gathered significant research interests in recent years. Many studies have concentrated on the routing issues of ad hoc networks <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b22">23]</ref>. These studies usually assume that any two in-range nodes can communicate with each other. Therefore, an ad hoc network can be modeled as a graph such that the in-range nodes are adjacent. For example, simulation-based studies <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> of ad hoc routing protocols have been conducted with a link-layer model based on or similar to the IEEE 802.11b standard.</p><p>An ad hoc network based on Bluetooth, however, brings new challenges. There are specific Bluetooth constraints not present in other wireless networks. For example, a Bluetooth network is composed of piconets. Each piconet contains one master and up to seven slaves. Piconets can be connected into a larger scatternet (figure <ref type="figure">1</ref>) by sharing slaves. As shown by Miklos et al. <ref type="bibr" target="#b13">[14]</ref> and Zurbes <ref type="bibr" target="#b25">[26]</ref>, the configuration of a scatternet has significant impact on the performance of the network. For instance, when a scatternet contains more piconets, the rate of packet collisions increases. Before we can make effective use of Bluetooth ad hoc networking, we must first devise an efficient protocol to form a scatternet from isolated Bluetooth devices.</p><p>In this paper, we study the problem of scatternet formation in the situation where the devices are in-range of one another. The communication range is at least 10 meters according to the current Bluetooth specification. This means that our formation algorithm should work when the maximum distance between any two devices is at most 10 meters. We will discuss in section 8 how the algorithm should adapt if the assumption is not satisfied.</p><p>We adopt a two-layer approach to this problem. First, we investigate how these devices can be organized into scatternets. We design and evaluate the performance of a new scatternet formation protocol. Second, as a subroutine of the formation protocol, we study how the devices can discover each other efficiently.</p><p>This paper is organized as follows. In section 2, we discuss the related research on Bluetooth scatternets. To get a better understanding of how our results differ from prior work, readers may skip this section and come back to it after going through the results of this paper. In section 3, we introduce the problem of scatternet formation. Our new scatternet formation protocol is presented in section 4. We present the-Figure <ref type="figure">1</ref>. A Bluetooth scatternet. oretical analyses and simulation results of our protocol in section 5. We discuss device discovery with simulation results in section 6. In section 7 we estimate the overall performance of the protocol. We discuss several variations and extensions to our protocol in section 8 and conclude in section 9. Theoretical results in this paper have appeared in a conference paper <ref type="bibr" target="#b11">[12]</ref>. Simulation results in this paper have appeared in a conference paper <ref type="bibr" target="#b9">[10]</ref> and a thesis <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>Miklos et al. <ref type="bibr" target="#b13">[14]</ref> apply heuristics to generate scatternets with some desirable properties. They evaluate these scatternets of different characteristics through simulations. Johansson et al. <ref type="bibr" target="#b8">[9]</ref> perform link-layer simulations of piconets. Raman, Bhagwat, and Seshan <ref type="bibr" target="#b16">[17]</ref> argue for cross-layer optimization in Bluetooth Scatternets.</p><p>Aggarwal et al. <ref type="bibr" target="#b0">[1]</ref> introduce a scatternet formation algorithm. Their algorithm first partitions the network into independent piconets, and then elects a "super-master" that knows about all the nodes. However, the resulting network is not a scatternet, because the piconets are not inter-connected. A separate phase of re-organization is required.</p><p>Salonidis et al. <ref type="bibr" target="#b17">[18]</ref> discuss the issues of symmetric connection between a pair of Bluetooth devices. In their symmetric protocol, the devices switch states (INQUIRY and INQUIRY SCAN) with a random schedule. In contrast, in our work, the devices switch states periodically, but pick the states randomly.</p><p>Salonidis et al. <ref type="bibr" target="#b18">[19]</ref> introduce a scatternet formation algorithm -Bluetooth Topology Construction Protocol (BTCP). BTCP has three phases: (1) a coordinator is elected with a complete knowledge of all devices, (2) this coordinator determines and tells other masters how a scatternet should be formed, and (3) the scatternet is formed according to the instructions. A formation scheme is presented in <ref type="bibr" target="#b18">[19]</ref> for up to 36 devices. In contrast, our algorithm has only one phase. Since the topology is decided by a single device (the coordinator), BTCP has more flexibility in constructing the scatternet. However, if the coordinator fails, the formation protocol has to be restarted. BTCP's timeout value for the first phase would affect the probability that a scatternet is formed. Our protocol's timeout value for each round only affects the overall performance of the protocol -the scatternet will be formed with certainty. In addition, BTCP is not suitable for dynamic environments where devices can join and leave after the scatternet is formed.</p><p>The algorithms in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">19]</ref> depend on a single device to design the scatternet topology and notify other devices. Therefore these algorithms will have time complexity (n/k), where n is the number of nodes, and k is the maximum number of slaves in a piconet. In comparison, our algorithm consists of a single phase and has O(log n) time complexity. However, as pointed out in <ref type="bibr" target="#b18">[19]</ref>, the coordinator election phase dominates the total time requirement. Thus, the advantage of our protocol's O(log n) time complexity might not be relevant in practice unless the number of devices is very large. Moreover, we note that at least the phase II of BTCP can be modified to run in O(log n) time, if the topological information is distributed along a tree. However, a tree-based distribution scheme will increase the complexity of the protocol.</p><p>Tan <ref type="bibr" target="#b20">[21]</ref> gives a distributed Tree Scatternet Formation (TSF) protocol. The extensive simulation results indicate relatively short scatternet formation latency. However, TSF is not designed to minimize the number of piconets. The simulation results suggest that each master usually has fewer than 3 slaves. In comparison, our protocol guarantees that all but one of masters have at least 6 slaves.</p><p>Bluetree <ref type="bibr" target="#b24">[25]</ref> and Bluenet <ref type="bibr" target="#b23">[24]</ref> are scatternet formation protocols for larger-scale Bluetooth networks, in which the devices can be out of range with one another. Simulation results of the routing properties of the scatternets were presented in <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref>. However, there were no simulation or theoretical analyses on the performance of the scatternet formation process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Preliminaries</head><p>In this section we introduce some terminologies and performance measures for the scatternet formation problem.</p><p>Bluetooth devices share 79 channels of 1 MHz bandwidth in the 2.4 GHz band using frequency hopping. When two Bluetooth devices are connected, one of the devices acts as a master and the other device acts as a slave. Any Bluetooth device can perform the role of a master or a slave.</p><p>A Bluetooth device can discover other devices by the inquiry process. A master in INQUIRY state hops 3,200 times per second according to a 32-channel inquiry hopping sequence. At the same time, a slave in INQUIRY SCAN state changes its listening frequency every 1.28 seconds, along the same sequence.</p><p>If the inquiry process succeeds, the master learns the address (which is unique for each Bluetooth device) and the clock of the slave. Then the master and the slave can be connected with the page process. In the page process, the master in PAGE state contacts the slave with a 32-channel page hopping sequence, which is a function of the slave's address and (estimated) clock. Similarly, the PAGE SCAN slave hops with the period of 1.28 seconds along the same sequence. After the master and the slave are connected, they communicate with a hopping sequence over all 79 channels at the rate of 1600 hops per second. This hopping sequence is determined by the master's clock and address.</p><p>A piconet consists of 1 master and 1-k active slaves. <ref type="foot" target="#foot_0">1</ref> All packets are exchanged between a master and its slaves within a piconet. There is no direct master-master or slave-slave communication. A device can be a slave in several piconets but be a master in only one piconet. The degree of a device is the number of piconets to which the device belongs. A device is unshared if its degree is 0 or 1. Otherwise, it is shared.</p><p>A scatternet is a set of piconets connected through shared devices.</p><p>The problem of scatternet formation: How does a collection of isolated devices form a scatternet? The devices are isolated in the beginning; each device is not aware of the other devices. Therefore, the scatternet formation protocol must be distributed. We assume that the devices are in the communication range of each other. Thus, potentially, any two devices can be connected directly.</p><p>A scatternet formation protocol has two major performance measures:</p><p>• Time complexity -amount of time to form a scatternet.</p><p>A scatternet should be formed as fast as possible to minimize the delay experienced by the users. • Message complexity -number of messages sent between the devices. This is important because Bluetooth devices usually operate with limited power. By reducing the number of messages sent, power consumption is conserved.</p><p>Futhermore, it is also crucial to have scatternets of good quality. It is not very useful to have scatternets leading to poor communication performance. Thus, we should aim to form a scatternet that facilitates inter-piconet communications. It is not easy to quantify the quality of a scatternet, but we believe the following measures are good indicators:</p><p>• Number of piconets -a measurement of a scatternet's efficiency. Since all piconets share the same set of 79 channels, there will be more collisions when there are more piconets. As shown in <ref type="bibr" target="#b25">[26]</ref>, the burst failure rate increases with the number of piconets. • Maximum degree of the devices -the maximum number of piconets that any device belongs to. Since the piconets communicate through shared slaves, if a slave belongs to many piconets, then this slave could become the bottleneck of inter-piconet communications. A shared slave has to be time multiplexed between the piconets that it belongs to. Therefore, a shared slave of high degree could become overloaded. • Network diameter -maximum number of hops between any pair of devices. This will provide us with an estimation of the maximum routing delay of the scatternet.</p><p>A good balance among the quality measures is desirable. Consider, for example, a star topology: a single "central" slave is shared by all piconets. In such a scatternet of n devices with every piconet containing k slaves, there are (n -1)/k piconets. Although the number of piconets is minimized, minimized (see remark 1), this scatternet probably would not perform very well in practice because the shared slave will be overwhelmed, unless the network is small. Remark 1. Let k be the maximum number of slaves in a piconet. A scatternet of n devices must contain at least (n -1)/k piconets.</p><p>Proof. See appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Scatternet formation</head><p>In this section, we first present our scatternet formation protocol and then evaluate its performance and properties by analyses and simulations. The development of this algorithm was inspired by our research on resource discovery algorithms in general networks <ref type="bibr" target="#b10">[11]</ref>. The main idea is to merge pairs of connected components until one component is left. Each component has a leader. In each round, a leader either tries to contact another component or waits to be contacted. The decision of each leader is random and independent. Our protocol in <ref type="bibr" target="#b10">[11]</ref> forms a complete graph in O(log n) rounds. In this paper, we apply the same idea to connect Bluetooth devices in O(log n) rounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Algorithm</head><p>Initially, we are given a set of isolated but in-range devices. During the execution of the algorithm, the devices are partitioned into components. A component is a set of interconnected devices, and can be a single device, a piconet, or a scatternet. There is one leader in each component. For a single-device component, the only member is the leader. For a piconet, the master is the leader. For a scatternet, one of the masters is the leader. When a leader retires, it stops being a leader and will be inactive for the rest of the algorithm (unless it becomes a leader again). For any device v, let S(v) be the set of v's slaves. If v is not a master or has no slaves, then S(v) = ∅. Let k 2 be the maximum number of slaves allowed in a piconet. Thus S(v) k for any v.</p><p>In lemma 2, we will prove the following invariants for the algorithm:</p><p>• Each leader either has no slave, or has at least one unshared slave in its piconet. • Each leader has fewer than k slaves in its piconet, i.e., |S(u)| &lt; k for any leader u.</p><p>All leaders execute procedure MAIN in the beginning of each round. We assume a constant δ, such that procedure MAIN and the procedures called by it can be completed in δ seconds. A good choice of δ can be found by simulations (see section 6) and by prototyping. We assume that all leaders call procedure MAIN at time t 0 + iδ, for i = 0, 1, . . . , where t 0 is the start time.</p><p>In the beginning, all devices are leaders. In procedure MAIN, a leader calls SEEK with probability p ∈ (1/3, 2/3). Otherwise, the leader calls SCAN or asks an unshared slave to call SCAN. During each round, only one device in each component should call SEEK or SCAN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MAIN(leader u)</head><formula xml:id="formula_0">1 x ← a random number in [0, 1) 2 if x &lt; p (1/3 &lt; p &lt; 2/3) 3 then SEEK(u) 4 else if S(u) = ∅ 5 then SCAN(u) 6 else v ← an unshared slave of u 7 S CAN(v)</formula><p>When a leader executes SEEK, it tries to acquire a new slave (which is running SCAN). However, the leader may not always succeed, because, in any given round, the number of devices running SCAN can be smaller than the number of devices running SEEK. Therefore, if a leader is not able to contact a slave after certain time, it should give up and run MAIN again in the next round. Similarly, SCAN might also fail in any given round. During each round, a matching is found between the SEEK devices and SCAN devices. The number of connections established (size of the matching) is the smaller of the number of SEEK devices and the number of SCAN devices.</p><formula xml:id="formula_1">SEEK(u) 1 u performs INQUIRY 2 if a slave v is found 3 then u connects to slave v by PAGE 4 / / S(u) ← S(u) ∪ {v} 5 C ONNECTED(u, v) SCAN(v) 1 v performs INQUIRY SCAN 2 if v is contacted by a master u 3 then v waits for u in PAGE SCAN</formula><p>We note that SEEK and SCAN devices will go into PAGE and PAGE SCAN modes, respectively, after all inquiries are completed. The amount of time required is investigated in section 6. In general, we make sure that each master is matched to only one slave, and vice versa. When a leader u running SEEK connects to a slave v running SCAN, procedure CONNECTED(u, v) is called.</p><p>Procedure CONNECTED(u, v) merges the component of u and the component of v. There are several cases:</p><p>1. If v is an isolated leader, then v would become a slave of u unless the piconet of u has become full, in which case a new piconet with master v and unshared slave y is created, as shown in figure <ref type="figure" target="#fig_0">2</ref>. This is necessary because otherwise u's piconet would be full, violating the second invariant.</p><p>To satisfy the first invariant, we also need to give the new master v an unshared slave y.</p><p>2. If v is not an isolated leader, then let w be the master of v.</p><p>(a) If the piconet of u and the piconet of w can fit into a single piconet (with at most k -1 slaves because of the second invariant), then w and its slaves join the piconet of u, as shown in figure <ref type="figure" target="#fig_1">3</ref>.</p><p>(b) Otherwise, we cannot merge the two piconets, and thus we should let w retire.</p><p>(i) If u was an isolated master, u would not have an unshared slave. Thus, we will let u become the slave of retiring master w and let v become an unshared slave of u (figure <ref type="figure" target="#fig_2">4</ref>).</p><p>(ii) If the merged piconet is just full, violating the second invariant, we will need to let v become a master and give it an unshared slave y (figure <ref type="figure" target="#fig_4">5</ref>). (iii) Otherwise, we will just try to move as many nodes allowed by the invariants as possible from the piconet of u to the piconet of retiring master w, so as to reduce the overall number of piconets (figure <ref type="figure" target="#fig_5">6</ref>).</p><p>CONNECTED(leader u, slave v)   Procedure MERGE(u, v, w) makes w and all its slaves become u's slaves. MIGRATE(master u, slave v, master w)</p><formula xml:id="formula_2">1 if v is a leader 2 then //v</formula><formula xml:id="formula_3">1 i ← min(k -|S(w)|, |S(u)| -2) 2 //i is the number of slaves to migrate 3 if i &gt; 0 4</formula><p>then y ← an unshared slave of u   • Each leader has either no slave, or has at least one unshared slave. • Each leader has fewer than k slaves.</p><p>Proof. We will prove the invariants by induction.</p><p>In the beginning, all devices are leaders without slaves. So our invariants are satisfied.</p><p>Assuming a state satisfying the claim, we only have to make sure that CONNECTED and its calls to MERGE, MI-GRATE, and MOVE preserve the invariants, because no piconet is formed or modified in MAIN, SEEK, and SCAN.</p><p>Let S (u) and S (v) be the slaves of u and v after CON-NECTED(u, v) is returned.</p><p>First, we consider the case that v is a leader (lines 1-7). If v is a leader, it means that v does not have any slave. If |S(u)| &lt; k (lines 3, 4), v would become an unshared slave of u. If u has exactly k slaves (lines 5-7), then one unshared slave y is moved from S(u) to S(v). Thus, S (v) contains an unshared slave. In this case, u is retired so that it does not need an unshared slave.</p><p>Second, we consider the case that v is a slave of a leader w. Master w will no longer be a leader, so it does not have to satisfy the invariants. There are four cases: v is unshared because it was w's unshared slave.</p><formula xml:id="formula_4">• (|S(u) ∪ S(w)| + 1 &lt; k).</formula><formula xml:id="formula_5">• (|S(u) ∪ S(w)| + 1 = k).</formula><p>In this case, u retires so it does not need to satisfy the invariants. When slave v becomes a leader, it obtains an unshared slave y from u. • (Default). Slaves in S(u) are migrated to S (w) until |S (w)| is k or S (u) contains only two slaves (one of them is v). Procedure MIGRATE will always reserve an unshared slave y for S (u). By assumption, w had at most k -1 slaves before CONNECTED is called. Therefore, we can move at least one slave from S(u) to S (w). Therefore, |S (u)| is at most k -1, because at least one slave is removed after u has obtained slave v.</p><p>This algorithm does not minimize the absolute number of messages passed between the devices. This is not crucial in practice, as section 6 will show that most of the packets are sent during the inquiry processes. The current design is a compromise between simplicity of the algorithm and the constant factors of the message complexity of the algorithm.</p><p>The last leader will keep calling MAIN even after the scatternet is formed. It is because the leader cannot be certain that all devices are already connected unless it knows the total number of devices. In practice, we can let the leader stop after it has failed to find any device for certain number of rounds.</p><p>The probability that n leaders fail to make any connections for l rounds is (p n + (1p) n ) l , which is less than (5/9) l for n 2 and 1/3 &lt; p &lt; 2/3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Performance and properties</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Theoretical results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1.">Scatternet properties</head><p>We show that the scatternet formed possesses two useful properties: small degrees for shared devices and small number of piconets. Lemma 3. At most one piconet in the scatternet formed by the algorithm contains fewer than k -1 slaves.</p><p>Proof. When a scatternet is formed, only one component is left. Therefore, except for one piconet, the masters of the other piconets have retired. We will show that a retired master has at least k -1 slaves. Therefore, when the scatternet is formed, all but one of the masters have at least k -1 slaves.</p><p>We only need to make sure that if a leader becomes a retired master in a round, it should have at least k -1 slaves, because a retired master will not lose any slave in subsequent rounds. There are four places in CONNECTED that a leader is retired:</p><p>• line 4: v becomes a slave. Proof. Consider a scatternet produced by the algorithm. Let n be the number of devices and m be the number of piconets. By lemma 3, at most one piconet has size less than k. (A piconet has size less than k if and only if it has fewer than k -1 slaves.) Such piconet has size at least 2. By lemma 4, m -1 devices have degree 2 and the rest of the devices have degree 1. Therefore, we can conclude that the scatternet contains at least</p><formula xml:id="formula_6">k(m -1) + 2 -(m -1) = (k -1)(m -1) + 2 devices. Thus, n (k -1)(m -1) + 2. Since m is an integer, m (n -2)/(k -1) + 1.</formula><p>Comparing theorem 5's upper bound (n -2)/(k -1) + 1 with remark 1's lower bound (n -1)/k , we note that our bound is very close to be optimal. For example, when n = 100 and k = 7, our algorithm forms a scatternet containing at most 17 piconets, while the lower bound requires 15 piconets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2.">Asymptotic complexities</head><p>We first derive the algorithm's time complexity and then its message complexity. Lemma 6. During a round with at least 2 leaders, the number of leaders is reduced by a constant fraction with a constant probability.</p><p>Proof. Let m 2 be the number of leaders. Let p be the probability that a leader chooses to run SEEK. The algorithm specifies that 1/3 &lt; p &lt; 2/3. We will assume p 1/2, because if p &gt; 1/2, we can switch the roles of SEEK and SCAN and the proof follows similarly.</p><p>During each round, we have a matching between the SEEK devices and the SCAN devices. Let random variable X be the number of SEEK devices in a given round. Since X is distributed binomially with parameter p, we have E[X] = pm and Var[X] = mp(1p).</p><p>Let α be a real number between 0 and 1. If (1α)pm X</p><p>(1 + α)pm, then at least (1α)pm connections are made between the SEEK devices and SCAN devices because: (1) there are at least (1α)pm SEEK devices; and (2) there are at least</p><formula xml:id="formula_7">m -(1 + α)pm = (1 -p -αp)m (1 -α)pm SCAN devices since (1 -p) p if p 1/2.</formula><p>Thus, the probability of having at least (1α)pm connections (size of the matching between SEEK devices and SCAN devices) is</p><formula xml:id="formula_8">Pr at least (1 -α)pm connections = Pr (1 -α)pm X (1 + α)pm = Pr |X -pm| αpm = 1 -Pr |X -pm| &gt; αpm .</formula><p>The Chebyshev's inequality states that Pr</p><formula xml:id="formula_9">X -E[X] &gt; t &lt; t -2 Var[X].</formula><p>By setting t = αpm, E[X] = pm, and Var[X] = mp(1p), we have</p><formula xml:id="formula_10">Pr |X -pm| &gt; αpm &lt; mp(1 -p) (αpm) 2 = 1 -p mα 2 p .</formula><p>Since m 2 and p &gt; 1/3, we have (1p)/pm &lt; 1. Thus we can pick α so that α 2 &gt; (1p)/2p (1p)/mp. Then c = (1p)/(2α 2 p) is a constant smaller than 1. Therefore,</p><formula xml:id="formula_11">Pr at least (1 -α)pm connections &gt; 1 -c.</formula><p>Each connection reduces the number of leaders by 1. Therefore, with probability at least 1c, the number of leaders is reduced by a fraction (1α)p.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 7. The algorithm forms a scatternet in O(log n)</head><p>rounds with probability at least 1 -1/n (1) , Proof. We note that a scatternet is formed when there is only one leader left. By lemma 6, when there are at least two leaders, the number of leaders is reduced by a fraction with some probability q. The probability that the algorithm takes more than O(log n) rounds to reduce the number of leaders to 1 is at most q (log n) = 1/n (1) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 8. The expected message complexity of the algorithm is O(kn).</head><p>Proof. See appendix C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 9. If k is a constant, then the message complexity of the algorithm is O(n).</head><p>We note that O(n) is the optimal asymptotic message complexity because each device needs to send at least one message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Simulation results</head><p>In this subsection, we investigate the properties and performance of our scatternet formation protocol.</p><p>We simulate our scatternet formation algorithm with simjava <ref type="bibr" target="#b7">[8]</ref>, a discrete event simulation package for Java. The probability p that each leader chooses to execute SEEK in each round is 1/2 in our simulations. Following the Bluetooth specification, we set k = 7. We start with 2, 4, and 8 nodes, and then increase by increments of 8 nodes, up to 128 nodes. This allows us to present the results against the number of nodes in linear scale and in logarithmic scale. Each data point in the graphs of this section represents an average of 50 trials.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1.">Scatternet properties</head><p>First, we found that the maximum degree of the scatternet formed is 1 when there are fewer than 8 nodes and is 2 when there are at least 8 nodes. This means that the maximum degree is optimal except when there are 8 nodes, in which case a maximum degree of 1 is possible.</p><p>As we discussed in section 3, it is important to minimize the number of piconets because piconets interfere with each other. Figure <ref type="figure" target="#fig_9">7</ref> shows that the number of piconets formed lies between the protocol's theoretical upper bound (n -2)/(k -1) + 1 and the universal lower bound (n -1)/k . The largest difference between our simulation result and the lower bound is 2.2 piconets.</p><p>The network diameter, which is the maximum shortest path length between any pair of devices, captures the maximum routing delay between any pair of nodes in the scatternet. Although we do not have a theoretical analysis of the network diameter, figure <ref type="figure" target="#fig_10">8</ref> shows that the network diameter grows about logarithmically with the number of devices (x axis is in logarithmic scale).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2.">Performance</head><p>First, it is crucial that the scatternet is formed as fast as possible, because this translates to the latency experienced by the users. In figure <ref type="figure" target="#fig_11">9</ref>, we can see that the number of rounds required to form the scatternet is around 1.2 log 2 n + 2. This validates the O(log n) time complexity theoretical result. In section 6, we will investigate the amount of time required in each round.</p><p>Second, as most mobile Bluetooth devices are expected to run on batteries, it is important to minimize the number of messages sent in order to conserve battery power. We can put the messages into three categories:  Figure <ref type="figure" target="#fig_12">10</ref> presents the total number of the Algorithmic Messages, Inquiries, and Pages. We can verify that the numbers of all three types of messages increase linearly with the number of devices. This agrees with the O(n) message complexity theoretical result.  In figure <ref type="figure" target="#fig_13">11</ref>, we can see that the maximum number of messages sent by any device increases logarithmically with the number of nodes. This implies that the power requirement of the "unluckiest" device is O(log n). A likely candidate of such unlucky device is the last remaining leader in the protocol. Since the last leader is not retired, the number of messages sent by this leader is (log n).</p><p>In the next section, we will find out how long it takes to finish one round of inquiry and page. We will also see how many packets are sent during the inquiry and page processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Device discovery</head><p>In this section, we investigate the performance of the device discovery protocol used during each round of the scatternet formation algorithm.</p><p>During scatternet formation, there are many devices trying to get connected at the same time, so the inquiry and page processes will interfere with each other. We call this the problem of device discovery when a set of in-range devices try to connect with each other. In the following, we discuss our approach and present the simulation results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Protocol</head><p>We describe a simple randomized protocol for the problem of device discovery. This protocol is repeated during each round of the scatternet formation algorithm introduced in section 4. We are given n devices that are not aware of each other. Our goal is to establish as many connections as possible. We are not concerned with exactly which of the devices are connected.</p><p>First, each device independently decides to be a SEEK node (with probability p) or a SCAN node (with probability 1p).</p><p>The protocol contains two phases -the inquiry phase and the page phase. In the inquiry phase, all the SCAN devices stay in the INQUIRY SCAN state. Each SEEK device will try to contact a SCAN device. However, a SEEK device may not always succeed in finding a slave because the number of SCAN devices can be smaller than the number of SEEK devices. Therefore, if a SEEK device is not able to contact a slave after certain amount of time, it will simply give up. Similarly, a SCAN device might also fail to be connected. In the page phase, the already paired devices are connected with PAGE and PAGE SCAN.</p><p>This protocol makes sure that each SEEK device is connected to at most one SCAN device and each SCAN device is connected to at most one SEEK device. In other words, we obtain a one-to-one matching between the SCAN devices and SEEK devices. The number of connections established is the smaller of the number of SEEK devices and the number of SCAN devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Simulation results</head><p>We also used simjava <ref type="bibr" target="#b7">[8]</ref> to simulate this protocol. <ref type="foot" target="#foot_1">2</ref> Each Bluetooth device is simulated by a thread. In each time slot, all devices first send messages, which include the frequency channel numbers, to a special object Air. Object Air detects the collisions in each of the 79 frequency channels, and only delivers the uncollided messages to those devices listening on the respective frequency channels. Inquiry and page frequency hopping sequences are implemented according to the Bluetooth specification. Since the overall time scale of the simulation is small, we did not simulate the clock drift. Each data point in the figures of this section is an average of 10 trials. In each trial, the devices are assigned addresses and clocks randomly.</p><p>Figure <ref type="figure" target="#fig_6">12</ref> shows the running time of the inquiry phase with three different master-to-slave ratios. For example, when there are 16 devices in total, a 50%-50% split leads to 8 masters and 8 slaves, and a 25%-75% split leads to 4 masters and 12 slaves. In the simulations of our algorithm in section 5.2, we set p to 1/2. Thus, we expect to see 50% masters and 50% slaves in each round. The actual outcomes at each round are distributed according to the binomial distribution. For more <ref type="bibr">Figure 12</ref>. Running time of the inquiry phase with three master-to-slave ratios.</p><p>Figure <ref type="figure" target="#fig_1">13</ref>. Percentage of packet collisions (over all packets sent) when there are 50% masters and 50% slaves.</p><p>than 8 devices, the 25%-75% split and 75%-25% split encompass at least 2 standard deviations around the expectation. We observe that the inquiry time of the 50%-50% split case increases sharply when there are around 64 devices. Since all SEEK devices follow the same inquiry hopping sequence (the phase depends on the device's clock), packet collision is a major problem when there are many devices. From the collision graph (figure <ref type="figure" target="#fig_1">13</ref>) on the 50%-50% split case, we can deduce that collisions start to hurt the performance severely when there are around 64 devices.</p><p>In figure <ref type="figure" target="#fig_14">14</ref>, we observe that, for up to 64 devices, the time consumed by the page phase is below 0.02 seconds, which is insignificant compared to the time required for the inquiry phase. This is because the SEEK devices already know the addresses and clocks of their target SCAN devices, thus they are able to contact the SCAN devices quickly. In addition, since they have different hopping sequences, the amount of collisions is lower in this case.</p><p>Figure <ref type="figure" target="#fig_15">15</ref> shows the total number of packets sent. Again the number of packets sent rises sharply around the 64-device case, due to collisions. However, we can see that the total number of packets is around (10000/32)n for n = 32, 64,  and 128. This means that the total number of packets sent increases roughly linearly with the number of devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Overall performance</head><p>We now estimate the overall performance of our protocol, using the results of sections 5.2 and 6.2. In section 5.2, we learned that the number of Inquiries, Pages, and Algorithmic Messages all increase linearly with the number of devices. And in section 6.2, we found that the number of packets sent during a single round of the protocol increases linearly with the number of devices. Therefore, we can conclude that overall message complexity of the protocol is linear. This means that the average power consumed by a device remains constant when the number of devices increases. In section 5.2, we also showed that the number of Inquiries, Pages, and Algorihtmic Messages of any single device increases logarithmically. Thus, our protocol does not cause a very high load on any single device.</p><p>To estimate the total time taken by the protocol, we can multiply the number of rounds (figure <ref type="figure" target="#fig_11">9</ref>) by the time required for each round. The time taken in each round the sum of the time required for the inquiry phase (figure <ref type="figure" target="#fig_6">12</ref>), the page phase (figure <ref type="figure" target="#fig_14">14</ref>), and the procedure CONNECTED.</p><p>We can estimate the time required for CONNECTED. During each round, each device will perform either PAGE or PAGE SCAN at most once as a result of procedure CONNECTED. Procedure CONNECTED does not cause any INQUIRY because the clocks and addresses of the devices are already known. Therefore, the time required for the PAGEs caused by CONNECTED should be more than the time required in the 50%-50% case of the page phase (figure <ref type="figure" target="#fig_14">14</ref>). In addition, O(k) messages need to be exchanged among leader u, slave v, and leader w in procedure CONNECTED. The amount of information to be passed is small, and thus the time required to pass these messages is insignificant compared to the time required for the INQUIRYs and PAGEs.</p><p>For example, according to our simulation results, for up to 32 devices, we expect that 1.39 + 0.02 • 2 = 1.43 seconds are required for each round. The protocol takes on the average 7.7 rounds to form the scatternet. Thus, the total time requirement is about 7.7 • 1.43 &lt; 11.1 seconds. Similarly, the estimated total time required for 16 devices and 64 devices are at most 10.2 seconds and 30.3 seconds, respectively. Section 8 discusses how the overall performance can be improved with an asynchronous version of our protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Variations and extensions</head><p>In the following, we discuss several limitations of our protocol and suggest techniques for overcoming them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1.">Inquiry collisions</head><p>When there are many devices, packet collisions among IN- QUIRY devices can adversely affect the performance. In particular, if two INQUIRY devices happen to have their clocks in phase so that their inquiry sequences are synchronized, then their inquiry packets will collide repeatedly. This effect was observed in our simulations in those cases with large numbers of devices. It is conceivable that this problem can be alleviated if the INQUIRY devices back off randomly during a heavycollision situation. We note that this back-off by the INQUIRY device is not related to the random back-off by an INQUIRY SCAN device after receiving an inquiry packet, as specified in Bluetooth 1.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2.">Asynchronous protocol</head><p>The overall time requirement estimated in section 7 is longer than the phase I of BTCP <ref type="bibr" target="#b18">[19]</ref>. To improve the performance, we should consider an asynchronous version of our protocol. We believe that the overall time requirement can be reduced because of the following observations:</p><p>• The worst-case time required per round happens when there is a perfect split between the masters and slaves. However, if this happens frequently, the total number of rounds required is small. For example, if there is a perfect split every round, the protocol will only need log 2 32 = 5 rounds to form a scatternet of 32 nodes. • The number of active leaders decreases rapidly. Thus, the device discovery processes in the later rounds can be completed faster.</p><p>We can consider an asynchronous version of our protocol with the following change: once CONNECTED returns, the remaining leader can proceed to MAIN immediately. The synchronized nature of the current protocol is useful for the theoretical analyses of the performance. In practice, it is not necessary for all devices to execute CONNECTED at the same time. The overall performance of the asynchronous version should be better than the synchronous version. Moreover, the analyses on the degrees of devices (lemma 4) and the number of piconets (theorem 5) remain valid in the asynchronous version. We note that it is not necessary for the devices to start at the same time in practice. Even in the synchronous version, a device can join the scatternet in a later round (see section 8.4 for a discussion of dynamic environments).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3.">Out of range devices</head><p>In some scenarios, some of the Bluetooth devices might be out of range of one another. Given arbitrary device connectivity, it is not possible to maintain the performance and scatternet properties guarantees. Despite such limitations, we can augment the protocol to try to form a scatternet whenever possible. Procedures SEEK and SCAN will not need to be modified because two devices will be connected only if they are in-range. We note that, other than SEEK, the only place that master-slave connections are established (by PAGE and PAGE SCAN) is in procedure MOVE. Therefore, procedure MOVE might fail. Let us consider the places in CONNECTED where MOVE is called:</p><p>• lines 5-7 (figure <ref type="figure" target="#fig_0">2</ref>). If y cannot be connected to v, then we can try to use other unshared slaves of u. If all unshared slaves of u are not able to connect to v, then v should become a retired master and have u as its only slave. • lines 11, 12 (figure <ref type="figure" target="#fig_1">3</ref>). The MERGE call might fail. In this case, we can let w retire with its smaller piconet. • lines 13-15 (figure <ref type="figure" target="#fig_2">4</ref>). If u cannot be connected to w, then we can let u be the slave of v. This will be similar to the original outcome except that v will be the new leader, instead of u. • lines 16-21 (figure <ref type="figure" target="#fig_4">5</ref>). If MERGE fails, we will just let w retire. • lines 22, 23 (figure <ref type="figure" target="#fig_5">6</ref>). The MIGRATE procedure should move as many devices to the retiring master w as allowed by the underlying connectivity.</p><p>The above modifications, except the one on lines 5-7, only affect the total number of piconets of the scatternet formed, but not the maximum degree of any device in the scatternet formed.</p><p>Each execution of modified lines 5-7 might increase the degree of u by one. Without a distribution assumption of device locations, we cannot bound the probability of such event. However, we can provide some reasons that such event is unlikely. Given that v was still an isolated device before the connection, we can show that it is unlikely that u has more than one shared slaves. If u has at least two shared slaves, then the component led by u has at least k + (k -1) + (k -1) devices, because each retired piconet has at least k -1 slaves. This implies that at least log 2 (3k -2) rounds have passed before v is able to make a connection. If p = 1/2, v has a probability of at least 1/2 to make a connection in each round. Thus, if k = 7, then the probability that v is not connected for log 2 19 = 5 rounds and then connect to u as a slave is at most (1/32)(1/2) = 1/64. When u has no more than 1 shared slave, it is unlikely that the k -1 or k -2 unshared slaves are all out of range with v.</p><p>Depending on the underlying connectivity of the devices, the piconets are likely to have smaller sizes, implying a larger number of piconets in the scatternet formed. Unless the situation discussed in the previous paragraph happens, the maximum degree of any device in the scatternet will still be two.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4.">Joins, leaves, and faults</head><p>Our protocol can be easily extended to work with dynamic environments (with devices joining and leaving the scatternet) and device failures. Our current protocol already handles the events of devices joining -the new devices can simply start as leaders and thus discover or be discovered by other devices. Additional work is required to deal with the case of devices leaving or failing. We give an outline in the following:</p><p>• If a master fails (or leaves the network), then a new master can be elected from the slaves. If the failed master was shared, then the new master should become a leader and merge with the rest of the scatternet by the protocol. • If a shared slave fails, its older master (the master who connected to this slave first) should become a leader again and then it will be connected to the rest of the scatternet by the protocol. • Nothing needs to be done when an unshared slave fails, unless it is the only unshared slave of an active leader. • In general, if we end up with a leader u with no unshared slave, then this leader has to disconnect from its shared slaves. Other masters of those shared slaves should now become leaders again. This will allow the protocol to proceed as usual. Fortunately, this expensive reorganization should occur rarely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Concluding remarks</head><p>In this paper, we introduced a new Bluetooth scatternet formation protocol. We presented both theoretical and simulation results to show that our protocol has O(log n) time complexity and O(n) message complexity.</p><p>We have shown that the algorithm produces scatternet with desirable properties: small number of piconets for minimizing inter-piconet interference, and small degrees for the devices for avoiding network bottlenecks. In addition, according to the simulations, the diameter of the scatternet, which corresponds to the maximum routing distance between nodes, is about O(log n). At last, we also demonstrated that no single device is particularly exhausted by the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Proof of remark 1</head><p>We need to show that a scatternet of n devices has at least (n -1)/k piconets. Let p(n) be the minimum number of piconets for a scatternet of n devices. We will show that p(n) (n -1)/k by induction on p(n). First, if p(n) = 1, then n k + 1 by our assumption that each piconet can have at most k + 1 devices. Therefore</p><formula xml:id="formula_12">p(n) = 1 = k k (n -1) k .</formula><p>Next, assume that if p(n) m, then p(n) (n -1)/k . Then we consider the case that p(n ) = m + 1. Given a scatternet of n devices, we pick a master and remove its piconet so that the rest of the scatternet is still connected. We can at most remove k devices because this piconet was connected with the rest of the scatternet. Therefore, after this removal, we are left with m piconets, and at least nk devices. By the inductive hypothesis, we have p</p><formula xml:id="formula_13">(n) (n -1)/k if p(n) m. Since n n -k, we have p(n) (n -k -1)/k = (n -1)/k -1. Thus, p(n ) p(n) + 1 (n -1)/k .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Proof of lemma 4</head><p>First, we will show that any device has maximum degree 2. We will verify that the shared slaves and shared masters have degrees at most 2.</p><p>Shared slaves. We observe that only unshared slaves may participate in SCAN. Thus, a shared slave will not be shared again through SCAN. A shared save might become unshared in a MERGE or become a degree-2 shared master in lines 16-21 of procedure CONNECTED.</p><p>Shared masters. A shared master can only be a slave of a retired master. Therefore, a shared master will never be shared again with another master through SCAN. In addition, a shared master v is always created from an unshared slave or an isolated master. This means that v had no slave before becoming a shared master. Therefore, a device can only become a shared master once.</p><p>We can now consider the topological graph of the scatternet, in which each piconet is a node and each degree-2 device is an edge. We can show that this topological graph is a tree. Initially, each component is a tree (a single node).</p><p>During each CONNECTED call, at most one edge is created between the two merging components. And since each component only participates in one CONNECTED process during each round, the components remain trees throughout the protocol.</p><p>In a tree of m nodes, there are exactly m -1 edges. Therefore, there are m-1 degree-2 devices, and n-(m-1) degree-1 devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C. Proof of theorem 8</head><p>We first consider the message complexity of each invocation of the procedures. We note that each of the procedures MAIN, SCAN, SEEK, CONNECTED, MERGE, MIGRATE sends O(1) messages. Procedure MOVE moves at most k devices. Thus it sends O(k) messages.</p><p>To analyze the message complexity of MAIN, SEEK, and SCAN, it is sufficient to find the expected number of times that MAIN is called, because each call to MAIN leads to a call to SEEK or a call to SCAN.</p><p>First, we can assume that when a leader w chooses SCAN such that if it or its slave is contacted by another leader u, then w will retire. This is true except that if u has k slaves, then u will retire instead. See lines 5-7 in procedure CONNECTED. However, for simplicity of the analysis, we can assume that w retires instead of u. In other words, we can assume that w and u swap their identities whenever we are in this case. This will not affect our result because we only care about the total number of messages sent by these leaders. The highlevel algorithm does not rely on an identifier of the device. (Device address is used by low-level Bluetooth INQUIRY and PAGE. But these processes are independent between different rounds in the algorithm.)</p><p>During any round, each leader chooses SCAN with probability 1p. Assume that a leader w has chosen SCAN. Leader w or w's unshared slave will definitely be contacted by another leader if the total number of SCAN devices is not more than the number of SEEK devices.</p><p>Let X i be the random variable of the number of SCAN devices over i components. Thus, [X i ] = (1p)i. Let m 2 be the number of components. We now assume that p 1/2 because if otherwise, we can switch the roles of SCAN and SEEK. Assume w has chosen SCAN: Pr{w or w's slave is contacted by a leader}</p><formula xml:id="formula_14">= Pr X m-1 m 2 -1 .</formula><p>By Markov inequality, we have</p><formula xml:id="formula_15">Pr X m-1 &gt; m 2 -1 = Pr X m-1 m 2 - 1<label>2</label></formula><formula xml:id="formula_16">E[X m-1 ] m/2 -1/2 = 2(1 -p).</formula><p>Thus,</p><formula xml:id="formula_17">Pr X m-1 m 2 -1 1 -2(1 -p) = 2p -1.</formula><p>Thus, each leader retires with probability at least (1p) (2p -1), which is positive except when p = 1/2. We now consider the case where p = 1/2. In the proof of lemma 6, we have Pr at least (1α)pm connections &gt; 1 -1p α 2 pm .</p><p>Let p = 1/2, α = 1/2 and m 5, then Pr{at least m/4 connections} &gt; 1/5.</p><p>Therefore, with probability at least 1/5, at least m/4 connections are made. And when that happens, each device has a probability of at least 1/4 to be the slave of a connection being made. This proves our argument for m 5. The cases where m = 2, 3, 4 can be easily verified.</p><p>We have shown that any leader has a constant probability of retiring during each round. This means that each leader is active for O(1) rounds. Thus MAIN is called O(n) times in total, and the overall message complexity for procedures MAIN, SEEK, SCAN is O(n).</p><p>Procedure CONNECTED is called exactly n -1 times. Thus, the message complexity of CONNECTED is O(n). Each call to CONNECTED could result in at most 1 call to MERGE, at most 1 call to MIGRATE, and at most 3 calls to MOVE. Thus the overall message complexity of MERGE and MI-GRATE is O(n), and the overall message complexity of MOVE is O(kn).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Lines 5-7 in procedure CONNECTED for k = 7.</figDesc><graphic coords="4,359.19,78.63,133.00,252.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Lines 11-12 (|S(u) ∪ S(w)| + 1 &lt; k) in procedure CONNECTED for k = 7.</figDesc><graphic coords="5,69.51,78.63,201.00,205.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Lines 13-15 (|S(u)| = 1) in procedure CONNECTED for k = 7.</figDesc><graphic coords="5,81.99,328.09,176.00,207.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>MERGE(master u, slave v, master w 1 v disconnects from w 2 MOVE(S(w) \ v, w, u) 3 MOVE({w}, NIL, u) Procedure MIGRATE(u, v, w) moves slaves from S(u) to S(w) until S(w) is full or when only two slaves are left in S(u).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Lines 16-21 (|S(u) ∪ S(w)| + 1 = k) in procedure CONNECTED for k = 7.</figDesc><graphic coords="5,325.23,78.63,201.00,227.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Lines 22-23 (default) in procedure CONNECTED for k = 7.</figDesc><graphic coords="5,322.35,355.46,206.50,208.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 2 .</head><label>2</label><figDesc>During the execution of the algorithm, the following invariants hold:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>All devices in S(w) become slaves of u. Device v was an unshared slave in S(w). After the merge, u is the only master of v, so v becomes an unshared slave of u. Also, we note that |S (u)| = |S(u) ∪ S(w)| + 1 is smaller than k by assumption.• (|S(u)| = 1). Leader u will have v as its only slave. Slave</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>• line 5 :Lemma 4 .Theorem 5 .</head><label>545</label><figDesc>The test |S(u)| &lt; k is false. Thus u had at least k slaves before line 7: MOVE({y}, u, v), which reduces the number of u's slaves by 1. Thus u would have k -1 slaves when retired.• line 9: We must show that for all the four cases in lines 11-23, w will have at least k -1 slaves when CONNECTED returns if w remains a master. In the first and third cases, w loses all of its slaves in the procedure MERGE and becomes a slave itself. In the second case (lines 13-15), we have|S(u)| = 1 but |S(u) ∪ S(w)| + 1k because the condition of the first case is not satisfied. Since u and w share one slave, we have|S(u)| + |S(w)| -1 + 1 k. Thus, S(w) k -1 before MOVE is called.Master w loses slave v, but gains a new slave u, so w still has at least k -1 slaves when procedure CONNECTED returns. In the last case (lines 22-23), we have |S(u) ∪ S(w)| + 1 k + 1, and MIGRATE will move all devices in the piconet of u to the piconet of w until w has k slaves or u has only 2 slaves left. In the latter case, only one slave in S(u) ∪ S(w) will not become a slave of w. Thus w would have at least k -1 slaves after the MIGRATE operation.• line 17: All slaves of w and w itself become slaves of u in line 19. We note that u and w had k -1 slaves in total (line 16), thus u should have k slaves after MERGE (line 19). MOVE (line 20) would remove one slave from u. Therefore, u still has k -1 slaves when CONNECTED returns. The algorithm forms a scatternet with m -1 devices of degree 2 and nm + 1 devices of degree 1, where n is the number of devices and m is the number of piconets.Proof. See appendix B. The scatternet formed by the algorithm contains at most (n -2)/(k -1) + 1 piconets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Number of piconets in the scatternet formed, compared to upper bound (n -2)/(k -1) + 1 and lower bound (n -1)/k , where k = 7.</figDesc><graphic coords="8,303.63,296.90,243.84,131.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Network diameter of the scatternet formed.</figDesc><graphic coords="8,303.63,464.31,243.84,130.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Number of rounds to form a scatternet.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Total number of Algorithmic Messages, Pages, and Inquiries.</figDesc><graphic coords="9,47.91,78.63,243.84,153.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Maximum number of Algorithmic Messages, Pages, and Inquiries sent by any single node.</figDesc><graphic coords="9,47.91,268.82,243.84,150.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Running time of the page phase with three master-to-slave ratios.</figDesc><graphic coords="10,303.63,278.54,243.84,168.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 15 .</head><label>15</label><figDesc>Figure 15. Total number of packets sent when there are 50% masters and 50% slaves.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>k = 7 in Bluetooth Specification 1.1<ref type="bibr" target="#b19">[20]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>IBM's BlueHoc simulator<ref type="bibr" target="#b2">[3]</ref> is not used because we began implementing our simulator before BlueHoc was released in public.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Clustering algorithms for wireless ad hoc networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kapoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ramachandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sarkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications</title>
		<meeting>the 4th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-08">August 2000</date>
			<biblScope unit="page" from="54" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Auto-Id</forename><surname>Center</surname></persName>
		</author>
		<ptr target="http://autoidcenter.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><surname>Bluehoc</surname></persName>
		</author>
		<ptr target="http://oss.software.ibm.com/developerworks/opensource/bluehoc/" />
		<title level="m">Bluetooth performance evaluation tool</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Bray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Sturman</surname></persName>
		</author>
		<author>
			<persName><surname>Bluetooth</surname></persName>
		</author>
		<title level="m">Connect Without Cables</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A performance comparison of multi-hop wireless ad hoc network routing protocols</title>
		<author>
			<persName><forename type="first">J</forename><surname>Broch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Maltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jetcheva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Mobile Computing and Networking</publisher>
			<biblScope unit="page" from="85" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Simulation-based performance evaluation of routing protocols for mobile ad hoc networks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Castañeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mobile Networks and Applications</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="179" to="189" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Bluetooth -the universal radio interface for ad hoc, wireless connectivity</title>
		<author>
			<persName><forename type="first">J</forename><surname>Haartsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ericsson Review</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="110" to="117" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mcnab</surname></persName>
		</author>
		<title level="m">Proceedings of International Conference on Web-Based Modeling and Simulation, International Society for Computer Simulation</title>
		<meeting>International Conference on Web-Based Modeling and Simulation, International Society for Computer Simulation</meeting>
		<imprint>
			<date type="published" when="1998-01">January 1998</date>
		</imprint>
	</monogr>
	<note>simjava: A discrete event simulation library for Java</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Short range radio based ad-hoc networking: performance and properties</title>
		<author>
			<persName><forename type="first">P</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Korner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Elg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Svennarp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Communications</title>
		<meeting>the IEEE International Conference on Communications</meeting>
		<imprint>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1414" to="1420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Performance of a new Bluetooth scatternet formation protocol</title>
		<author>
			<persName><forename type="first">C</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-Y</forename><surname>Siu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Mobile Ad Hoc Networking and Computing</title>
		<meeting>the ACM Symposium on Mobile Ad Hoc Networking and Computing<address><addrLine>Long Beach, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-10">2001. October 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An O(log n) randomized resource discovery algorithm</title>
		<author>
			<persName><forename type="first">C</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-Y</forename><surname>Siu</surname></persName>
		</author>
		<idno>No. FIM/110.1/DLSIIS/2000</idno>
	</analytic>
	<monogr>
		<title level="m">Brief Announcements of the 14th International Symposium on Distributed Computing</title>
		<imprint>
			<date type="published" when="2000-10">October 2000</date>
			<biblScope unit="page" from="5" to="8" />
		</imprint>
		<respStmt>
			<orgName>Technical University of Madrid</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Bluetooth scatternet formation algorithm</title>
		<author>
			<persName><forename type="first">C</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-Y</forename><surname>Siu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Ad Hoc Wireless Networks</title>
		<meeting>the IEEE Symposium on Ad Hoc Wireless Networks<address><addrLine>San Antonio, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-11">2001. November 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Ad-hoc network formation using Bluetooth scatternets</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Mehta</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s Thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Performance aspects of Bluetooth scatternet formation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Miklos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Racz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Turanyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Valko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Johansson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The First Annual Workshop on Mobile Ad Hoc Networking and Computing</title>
		<meeting>The First Annual Workshop on Mobile Ad Hoc Networking and Computing</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Bluetooth Revealed: The Insider&apos;s Guide to an Open Specification for Global Wireless Communications</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bisdikian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Prentice Hall</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Perkins</surname></persName>
		</author>
		<title level="m">Ad Hoc Networking</title>
		<meeting><address><addrLine>Reading, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Arguments for cross-layer optimizations in Bluetooth scatternets</title>
		<author>
			<persName><forename type="first">B</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bhagwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Symposium on Applications and the Internet</title>
		<meeting>Symposium on Applications and the Internet</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="176" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Proximity awareness and fast connection establishment in Bluetooth</title>
		<author>
			<persName><forename type="first">T</forename><surname>Salonidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bhagwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tassiulas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First Annual Workshop on Mobile and Ad Hoc Networking and Computing</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="141" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Distributed topology construction of Bluetooth personal area networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Salonidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bhagwat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tassiulas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lamaire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth Annual Joint Conference of the</title>
		<meeting>the Twentieth Annual Joint Conference of the</meeting>
		<imprint>
			<publisher>IEEE Computer and Communications Societies</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Specification of the Bluetooth System, Version</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2001-02">February 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Self-organizing Bluetooth scatternets</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s Thesis</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title/>
		<ptr target="http://www.bluetooth.com" />
	</analytic>
	<monogr>
		<title level="j">The Bluetooth Special Interest Group</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Toh</surname></persName>
		</author>
		<title level="m">Ad Hoc Mobile Wireless Networks: Protocols and Systems</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Bluenet -a new scatternet formation scheme</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Haas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual Hawaii International Conference on System Sciences</title>
		<meeting>the 35th Annual Hawaii International Conference on System Sciences</meeting>
		<imprint>
			<date type="published" when="2002-01">January 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Bluetrees-scatternet formation to enable Bluetooth-based ad hoc networks</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">V</forename><surname>Záruba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Basagni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Chlamtac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Communications</title>
		<meeting>IEEE International Conference on Communications</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="273" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Considerations on link and system throughput of Bluetooth networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zurbes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th IEEE International Symposium on Personal, Indoor and Mobile Radio Communications</title>
		<meeting>the 11th IEEE International Symposium on Personal, Indoor and Mobile Radio Communications</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1315" to="1319" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
