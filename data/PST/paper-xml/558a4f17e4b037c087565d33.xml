<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Formal Test-case Generation for UML Statecharts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stefania</forename><surname>Gnesi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CNR/ISTI</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>I56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">ITALY</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">CNR/ISTI</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>I56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">ITALY</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Mieke.Massink¢ @isti.cnr</roleName><forename type="first">Diego</forename><surname>Latella</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CNR/ISTI</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>I56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">ITALY</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">CNR/ISTI</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>I56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">ITALY</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mieke</forename><surname>Massink</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CNR/ISTI</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>I56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">ITALY</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>It</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CNR/ISTI</orgName>
								<address>
									<addrLine>Via Moruzzi 1</addrLine>
									<postCode>I56124</postCode>
									<settlement>Pisa</settlement>
									<country key="IT">ITALY</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Formal Test-case Generation for UML Statecharts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">58BD930B4AF560BA7BFAE63DD018A695</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The Unified Modeling Language has been introduced as a notation for modeling and reasoning about large and complex systems, and their design, across a wide range of application domains. System modeling and analysis techniques, especially those based on formal methods, are more and more used for enhancing traditional System Engineering techniques for improving system quality. In particular this holds for model-based formal test case derivation using formal conformance testing. The contribution of the present paper is to provide a solid mathematical basis for conformance testing and automatic test case generation for UML Statecharts (UMLSCs). We propose a formal conformancetesting relation for input-enabled transition systems with transitions labeled by input/output-pairs (IOLTSs). IOLTSs provide a suitable semantic model for a behavioral subset of UMLSCs. We also provide an algorithm which, for a UMLSC specification and the alphabet of implementations, generates a test suite. The algorithm is proven exhaustive and sound w.r.t. the conformance relation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction and Related Work</head><p>Modern societies strongly depend, for their functioning as well as for the protection of their citizens, on systems of highly interconnected and interdependent infrastructures, which are increasingly based on computer systems. The complexity of such systems, and those of the near future, will be higher than that of any artifact which has been built so far. In recent years, the Unified Modeling Language (UML) <ref type="bibr" target="#b18">[18]</ref> has been introduced as a notation for modeling and reasoning about large and complex systems, and their design, across a wide range of application domains. Moreover system modeling and analysis tech-£ This work has been carried out under the Agreement between CNR CNUCE/IEIand GMD in the frame of the Project "Formal Test Cases Derivation for UML Statechart Diagrams Specifications". It has been partially funded by projects EU-IST IST-2001-32747 (AGILE) and MIUR/SP4. niques, especially those based on formal methods, are more and more used for enhancing traditional System Engineering techniques for improving system quality. In particular this holds for model-based formal test case derivation using formal conformance testing, of which the present paper addresses the theoretical foundations.</p><p>Testing and conformance relations in the context of labeled transition systems (LTSs) have been thoroughly investigated in the literature. Broadly speaking, conformance testing refers to a field of theory, methodology and applications for testing that a given implementation of a system conforms to its abstract specification, where a proper conformance relation is defined using the formal semantics of the notation(s) at hand. An account of the major results in the area of testing and conformance relations can be found in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b21">22]</ref>. The theory has been developed mainly in the context of process algebras and input/output transition systems.</p><p>In <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14]</ref> and in this paper we set the theoretical basis for testing and conformance theories for UML Statecharts (UMLSCs, for short), thus making them available for practitioners in industry where the Unified Modeling Language has become a de facto standard, in particular for the development of complex systems <ref type="foot" target="#foot_0">1</ref> . The UML consists of a number of diagrammatic specification languages, among which UMLSCs, that are intended for the specification of behavioral aspects of software systems. This diagrammatic notation differs considerably from process algebraic notations. In UMLSCs, transitions are labeled by input/output-pairs (i/o-pairs), where the relation between input and output is maintained at the level of the single transitions. This is neither the case in traditional testing theories, like <ref type="bibr" target="#b8">[9]</ref>, where no distinction is made between input and output, nor for the input/output transition systems used in standard conformance testing theory <ref type="bibr" target="#b21">[22]</ref>. In our approach we use LTSs labelled over i/o-pairs where a generic transition models a step of the associated statechart (step-transition). Preserving the atomicity of input acquisition and output generation in a single step has two important advantages. First of all, this reflects in a more direct way the semantics of UMLSCs steps; each step, according to <ref type="bibr" target="#b18">[18]</ref>, is triggered by an input event and causes both a change in the current configuration and the execution of certain actions such as those that generate output events. The use of LTSs with separate input and output events <ref type="bibr" target="#b21">[22]</ref> would require the introduction of additional, intermediate, global states and transitions at the semantics level, thus breaking the neat correspondence between the notion of step of the statechart and that of steptransition of its associated LTS. Secondly, a testing theory based on i/o-pairs preserves the compatibility of the testing models with the rest of the semantics framework that we have developed for UMLSCs (e.g. <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b7">8]</ref>) and that is based on re-use of a basic set of deduction rules (the "core semantics") leading to a high degree of homogeneity, modularity and re-use.</p><p>Our LTSs labelled over i/o-pairs are very similar to Finite State Machines (FSMs), in particular Mealy Machines. A considerable number of studies in the field of testing FSMs are available in the literature. An excellent survey can be found in <ref type="bibr" target="#b16">[16]</ref>. Many such proposals deal with test case generation but mainly in the context of deterministic machines. In some proposals, like the one in <ref type="bibr" target="#b2">[3]</ref>, further restrictions on the machines are introduced, requiring that they must be strongly connected.</p><p>To our knowledge, the study of conformance relations, and of testing theory in general, in the context of nondeterministic machines, or LTSs over i/o-pairs, has received scant attention. On the other hand, non-determinism is a key notion in the area of formal approaches to system modeling and verification and, in fact, it is a central notion in traditional testing theories for LTSs <ref type="bibr" target="#b8">[9]</ref> and their variants for systems with inputs and outputs <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b17">17]</ref>.</p><p>In this paper we propose a formal conformance testing relation and a test case generation algorithm for input enabled labeled transition systems over i/o-pairs (IOLTSs). IOLTSs are LTSs where each state has (at least) one outgoing transition for each element of the input alphabet of the transition system. Intuitively, such transition systems cannot refuse any of the specified input events, in the sense that they cannot deadlock when such events are offered to them by the external environment. Whenever a machine, in a given state, does not react on a given input, its modeling IOLTS has a specific loop-transition from the corresponding state to itself, labelled by that input and a special "stuttering" output-label.</p><p>IOLTSs have been used as semantic model for a behavioral subset of UMLSCs <ref type="bibr" target="#b6">[7]</ref>. In this paper, we will assume that system specifications are given as UMLSCs and we will concentrate on their associated IOLTSs. IOLTSs are suitable also for modeling implementations of systems specified by such diagrams. Modeling implementations as input enabled transition systems is common practice in the context of formal conformance testing -see e.g. <ref type="bibr" target="#b21">[22]</ref>. We focus on conformance testing and the soundness and exhaustiveness properties of a test case generation algorithm relative to a conformance relation for IOLTSs. The conformance relation we define is similar to the one of Tretmans <ref type="bibr" target="#b21">[22]</ref>, with adaptations which take care of our semantic framework for UMLSCs. As a by-product of our work, we also define and propose a specific test case language.</p><p>In <ref type="bibr" target="#b13">[13]</ref> we defined a general testing theory for UMLSCs, using a framework similar to that proposed in <ref type="bibr" target="#b17">[17]</ref>, which was in turn inspired by the work of Hennessy for traditional LTSs <ref type="bibr" target="#b8">[9]</ref>. The general approach of the above mentioned theories is based on the well known notions of MAY and MUST preorders and related equivalences. Intuitively, for systems and ¡ , £¢ ¤ ¦¥ ¨ § © ¡ means that if a generic experimenter (i.e. test case) has a successful test run while testing , then has also a successful test run when testing ¡ . On the other hand, ¢ ¤ ¥ ¡ means that if all test runs of a generic experimenter are successful when testing , then it must be the case that all test runs of are successful when testing ¡ . It can be shown that ¢ ¤ ¥ § © concides with trace inclusion and that</p><formula xml:id="formula_0">¢ ¤ ¥ ! ¡ implies ¡ ¢ ¤ ¦¥ § "©</formula><p>. Thus, the testing preorders focus essentially on the observable behaviour of systems and are strongly related to their internal non-determinism and deadlock capabilities; intuitively, if both #¢ ¤ ¥ § "© ¡ and $¢ ¤ ¥ ! ¡ hold, then is "more non-deterministic" than ¡ and can generate more deadlocks than ¡ can, when tested by an experimenter. Finally, if also the reverse preorders hold, i.e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>¡ ¢ ¤ ¥ § "© %</head><p>and ¡ ¢ ¤ ¥ &amp; as well, then and ¡ are test- ing equivalent since no experimenter can distinguish them.</p><p>The main semantic assumptions in <ref type="bibr" target="#b8">[9]</ref> are that (i) system interaction is modeled by action-synchronization rather than input/output exchanges, and (ii) absence of reaction from a system to a stimulus presented by an experimenter results in a deadlock affecting both the system and the experimenter. In <ref type="bibr" target="#b17">[17]</ref>, and later in <ref type="bibr" target="#b13">[13]</ref> specifically for UMLSCs, assumption (i) has been replaced by modeling system interaction as input/output exchanges, but assumption (ii) remained unchanged. In particular, in <ref type="bibr" target="#b13">[13]</ref>, absence of reaction of a given state ' on a given input ( is represented by the absence of any transition with such an input ( from ' , in a way which is typical of the process-algebraic approach. We refer to the resulting semantic model as the "non-stuttering" one, as opposed to input enabled IOLTS, i.e. the "stuttering" semantics, used in the present paper. The above two different ways of dealing with absence of reaction, and in particular, the ability for experimenters to explicitly detect absence of reaction turns out to be of major importance for determining the relative expressive power of the various semantics. More specifically, in <ref type="bibr" target="#b14">[14]</ref> we defined MAY and MUST preorders also for the stuttering semantics and we provided a formal comparison between the Hennessy-like, non-stuttering semantics <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b8">9]</ref>, and the stuttering seman-tics w.r.t. testing and conformance ordering relations; we showed that if two UMLSCs, say and ¡ , are in confor- mance relation (i.e. conforms to ¡ ) in the stuttering se- mantics, then they are also in MAY and in the reverse-MUST relations (i.e.</p><p>¢ ¤ ¥ ¨ § © ¡ and ¡ ¢ ¤ ¦¥</p><p>) in the nonstuttering semantics, but not vice-versa. This shows that the Hennessy-like, non-stuttering, semantics <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b8">9]</ref> is not adequate for reasoning about issues of conformance, since the detection of absence of reaction, explicitly modeled only in the stuttering semantics, plays a major role when dealing with conformance. Accordingly, the following results have been proven: the conformance relation coincides with the MAY preorder in the stuttering semantics. Moreover, in the stuttering semantics, nice substitutivity properties hold; for instance, testing equivalent implementations conform to the same specifications and implementations conform to testing equivalent specifications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work on automatic test generation based on</head><p>UMLSCs is being developed in the context of the Agedis project <ref type="bibr">[20]</ref>. In that approach a system model, composed of class, object and statechart diagrams is translated into a model expressed in an intermediate format suitable as input for model checking and test generation tools. It follows a pragmatic, industrial approach with a clear focus on the test selection problem, but with less emphasis on UML formal semantics. In contrast, we follow a 'Semantics-first' approach (also) with respect to conformance testing. Similarly, in <ref type="bibr" target="#b15">[15]</ref> emphasis is put primarily on support tool implementation. Other approaches to automatic test generation include <ref type="bibr" target="#b19">[19]</ref> that describes the use of the CASE tool AutoFocus. The authors emphasize the need for a formally defined semantics and use state transition diagrams that resemble a subset of the UML-RT, but it seems there is no formal relation between their diagrams and the subset of the UML-RT. Automated test generation has been developed also for classical Harel statechart diagrams, e.g. <ref type="bibr" target="#b1">[2]</ref>, which semantically differ considerably from UMLSCs (e.g., a different priority schema as well as a different semantics for the input queues are used).</p><p>The paper is organized as follows: in Sect. 2 IOLTSs are defined and a running example is introduced showing how IOLTSs can be used as semantic model for UMLSCs. The notion of conformance and the formal definition of the conformance relation are given in Sect. 3, together with the formal definition of the notion of test case and an account of what it formally means for a system to pass a test case and/or a test suite. The test case generation algorithm is defined in Sect. 4 where its completeness theorem is also provided. The application of the algorithm is illustrated by the derivation of some test cases for the example of Sect. 2. Some conclusions and lines for future research are discussed in Sect. 5. The proofs of the results presented in this paper can be found in <ref type="bibr" target="#b6">[7]</ref>, where all technical details of the operational semantics definition are given as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">IOLTSs and UMLSCs</head><p>In this section we summarize the basic definitions concerning IOLTSs, which are necessary for developing the notions of conformance and conformance testing. The example of Fig. <ref type="figure">1</ref> shows the IOLTS (b) of a simple UMLSC (a). It will be briefly discussed in Sect. 2.1 and will be used as the running example throughout the paper. The formal definition of the operational semantics of UMLSCs based on IOLTSs is outside the scope of this paper. The interested reader is referred to <ref type="bibr" target="#b6">[7]</ref>. Here we only point out that the IOLTSs semantics of UMLSCs is essentially the same as that proposed in <ref type="bibr" target="#b13">[13]</ref>. The only difference from <ref type="bibr" target="#b13">[13]</ref> is the way stuttering is dealt with. In the context of UMLSCs, stuttering occurs when no transition of the UMLSC is enabled by the current event ¡ in the current (global) state ¢ of the underlying state-machine. In the semantics proposed in <ref type="bibr" target="#b13">[13]</ref> no step-transition with input label ¡ leaves ¢ . Thus, the absence of reaction on input ¡ is modeled implicitly by the absence of corresponding transitions. This approach is quite standard in the context of general testing theory. In the IOLTSs semantics proposed in <ref type="bibr" target="#b6">[7]</ref>, instead, stuttering is modeled explicitly: in the above situation, a step-transition, with input label ¡ and a special output symbol £ , denoting stuttering, leaves ¢ and points back to ¢ 2 .</p><p>As in <ref type="bibr" target="#b13">[13]</ref>, we consider a subset of UMLSCs, which includes all the interesting conceptual issues related to concurrency in dynamic behavior-like sequentialisation, nondeterminism and parallelism-as well as UMLSCs specific issues-like state refinement, transition priorities, interlevel/join/fork transitions. More specifically, we do not consider history, action and activity states; we restrict events to signals without parameters (actually we do not interpret events at all); time and change events, object creation and destruction events, and deferred events are not considered neither are branch transitions; also variables and data are not allowed so that actions are required to be just (sequences of) events. We also abstract from entry and exit actions of states. The definition of a sound "basic" kernel of a notation, to be extended only after its main features have been investigated, has already proven to be a valuable and fruitful methodology and is often standard practice in many fields of concurrency theory, like process-algebra. We refer to e.g. <ref type="bibr" target="#b10">[11]</ref> for a deeper discussion on such "basic-notation-first" and "semantics-first" versus "full-notation-first" issue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Basic definitions</head><p>In the following we give the basic definitions of LTS and IOLTS and we briefly discuss the example of Fig. <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1 (LTS) A LTS</head><p>is a tuple ¡ £¢ ¥¤ ¢ §¦ ¨¤ © ¤ where ¢ is the set of states with ¢ §¦ ¢ being the initial state, © is the set of (transition) labels and ! #" $¢ &amp;% '© (% )¢ is the transition relation of the LTS. 0 For ¡ ¢ 1¤ 2 3¤ ¢ §4 5 6 7 1 we write ¢ 8 ¢ §4 . The notation ¢ 8 1 will be a shorthand for 9 ¢ @4 BA ¢ 8 ¢ §4 . Some standard definitions are given below 3 . In this paper we will use LTSs where the labels in © are i/o-pairs, i.e. © xC y© % H© , for some input set © and output set © . For such LTSs the following auxiliary definitions apply:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.2 For LTS</head><formula xml:id="formula_1">DC ¡ £¢ ¥¤ ¢ §¦ ¨¤ © ¤ , ¢ 1¤ ¢ §4 E¤ ¢ §4 4 § F¢</formula><formula xml:id="formula_2">Definition 2.3 For LTS C ¡ £¢ ¥¤ ¢ §¦ ¨¤ © Y ¥% d© Y¤ ! x , ¢ ( F¢ , ( u &amp;© Y , I F &amp;© Q and set " ¢ : S the output of on ( is the set ¡ f rp ) ( uC y B td 7b fe &amp; &amp;© c ¢ §4 )g ih Bj k fl e ;</formula><p>we let ¡ £m n po ¢ qI ( be the set ¡ f rp '¡ ¢ &amp;g ¨i ¨p pq s dI @ ( ;</p><formula xml:id="formula_3">S is input enabled iff r ¢ §4 1 F¢ ¥¤ ( u &amp;© A s9 se &amp; &amp;© A ¢ §4 g ih Bj k fl ! .</formula><p>We need similar operators as g ¨i ¨p pq ts and m n po also for sets of traces over ¡ B© % P© Q . S the output of t on ( is the set</p><formula xml:id="formula_4">¡ f rp t</formula><p>( uC b e &amp; H© Dc 9 ¨I ¥A w¡ ( x¤ e 1 yI F qt e ; we let ¡ £m n po t I ( be the set ¡ £ z rp ¡ vt {g ¨i ¨p pq s I @ ( . 0 3 In this paper we will freely use a functional programming like notation where currying will be used in function application, i.e.</p><formula xml:id="formula_5">| } } f ! 3 3 1}</formula><p>will be used instead of</p><formula xml:id="formula_6">| ¨ } z f} E} s</formula><p>and function application will be considered left-associative. Moreover, for set , the set of finite sequences over will be denoted by ; for we let denote also the sequence in composed by the single element , while for we let the juxtaposition of with denote their concatenation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.5 (IOLTS)</head><formula xml:id="formula_7">An IOLTS labeled over © % (© is a LTS ¡ f¢ ¥¤ ¢ 1¦ ¨¤ © % P© ¤ ! which is input enabled. 0</formula><p>The operational semantics of a UMLSC is defined in <ref type="bibr" target="#b6">[7]</ref> as a IOLTS, where transitions are characterized by the steprelation. Every step-transition models the collective firing of a maximal set of enabled non-conflicting transitions of the UMLSC which do not violate transition priority constraints <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b7">8]</ref>.</p><p>The input component of the i/o-pair of a step-transition is a single event which represents the stimulus for the transitions to fire while the output component is a collection of events that the UMLSC returns to the environment as (part of) the reaction to the stimulus (the other part being represented by the change in its global state). When stuttering occurs, the output component is the special symbol £ . Thus, in the remainder of this paper we will focus on IOLTSs labeled over © % © where £ , with £ y© , may belong to © . In the following we will often use the word 'transition' both for those of UMLSCs and for the step-transitions of their associated semantics.</p><p>In the official definition of the UML <ref type="bibr" target="#b18">[18]</ref>, the dispatching policy of events to state machines by their external environment is not specified. In our proposals for the formal semantics of UMLSCs we used a parametric abstract data type approach for modeling the environment policy. As a consequence, also the collections of events generated by (the parallel execution of) more than one transition within a step have been represented by instances of such data-types.</p><p>For the sake of simplicity, in the following examples we will model such collections of events simply as sets, since the dispatching policy is of no conceptual influence for formal test case generation.</p><p>A sample UMLSC, , is shown in Fig. <ref type="figure">1</ref> (a). The set of input events of is © C b fX ! t¤ X r r¤ ¡ t¤ ¡ r¤ x ¤ x § r¤ 3 s t¤ 3 z e . The IOLTS of , as obtained by applying the formal operational semantics definition presented in <ref type="bibr" target="#b6">[7]</ref>, is shown in Fig. <ref type="figure">1</ref>  . Notice that more than one output event can be generated by a single step, as a consequence of internal parallelism in . For instance, in the transition from state to state of the IOLTS events ¡ and ¡ are both generated as a reaction to receiving ¡ . State of the IOLTS corresponds to configuration b ' f w¤ ' t ¤ ' r¤ ' f p¤ ' t e of . The reader can easily check that the LTS is indeed input enabled over © ¡% ¢© R , where set © R is We close this section remarking that the LTSs generated according to the UMLSCs semantics definition proposed in <ref type="bibr" target="#b6">[7]</ref> are finite: the number of their states is finite as well as their number of transitions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Pragmatics</head><p>In the context of the present work, we assume that a specification of system behavior is given in the form of a UMLSC and we make reference mainly to its semantics, namely a IOLTS labeled over © C #© % h© for proper © and © , which we denote by ¡ £¢ ¥¤ §¦ ©¨ . An implementation for will be modeled by an IOLTS labeled over © Y4 GC {© Y4 % (© 4 (with © 4 not necessarily equal to © ). Under the above assumptions, for simplicity, we often speak of specifications over © and implementations over © 4 . We remind the reader that</p><formula xml:id="formula_8">£ v &amp;© © Y4 is assumed while £ H© R (resp. £ u© 4</formula><p>) represents stuttering of the specification (resp. implementation). Notice that we do not require that IOLTSs modeling implementations are necessarily generated from UMLSCs. Any such a model can be obtained by any means, obviously including, but not limited to the case in which the implementation is itself a UMLSC. The above assumptions are quite standard in the context of formal conformance theory and its application <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Conformance Testing and the Conformance Relation</head><p>As we briefly discussed in the previous section, from our point of view, both specifications and implementations are modeled as IOLTSs. A discussion on the adequacy of LTSs as models for specifications and implementations is outside the scope of the present paper. The interested reader is referred to <ref type="bibr" target="#b21">[22]</ref>.</p><p>Under the above modeling assumption, one of the most successful formal conformance relations is the ioco relation proposed by Tretmans <ref type="bibr" target="#b21">[22]</ref>. Informally, for specification and implementation 4 , 4 ioco means that 4 can never produce an output which could not be produced by "in the same situation", i.e. after the same sequence of steps.</p><p>In <ref type="bibr" target="#b21">[22]</ref>, inputs and outputs are "irregularly" scattered throughout the LTS, and a "quiescence" transition from a state means that in this particular state no output is produced by the system. We remark that, in such an approach, input is not (always) required in order to produce some output. In our setting, there is a clear causal relation between input and related output. They both appear in the same transition. A stuttering transition in a given state-actually a stuttering loop-is labelled by ¡ ( x¤ £ , which means that in that state the system produces no output, or better, does not react at all, on input ( . On the basis of the above considerations, with particular reference to the role played by the input events of transitions, we give the following definition of our conformance relation. We define it for generic LTSs over i/o-pairs, although we will use it only for input-enabled ones. Finally, we point out that we actually define a class of conformance relations, in a similar way as in <ref type="bibr" target="#b20">[21]</ref>. The class is indexed by a set t of traces which determines the discriminatory power of the relation. Such a parametric definition turns out to be of technical help in the definition of the test case generation algorithm in the next section and in the proof of its properties. The definition of the Conformance Relation follows: Definition 3.1 For LTSs xC ¡ f¢ 7¤ ¢ §¦ t¤ © Y d% H© ¤ x , 4 1C ¡ f¢ 74 f¤ ¢ 1¦ 4 ¤ © Y4 % d© 4 ¤ ! 4 and t ¢" v¡ B© 7% © Q : 4 iff r I F qt P¤ ( P© A sm n po ¢ 1¦ 4 I ( Y" m n po ¢ 1¦ RI ( <ref type="formula">0</ref>In the following we will let (i.e. "conforms to") denote g "! $# &amp;% l -we remind that © X t` denotes the language of -and we will mainly focus on . Intuitively, 4 ' means that 4 can never produce an output which could not be produced by in the same situation, i.e. after the same i/o sequence and the same input. In general, it is not required that © C y© 4 : for partial specifications we have that © " u© Y4 , while for incomplete implementations we have that © 4 " $© ; The case that © ¡ © 4 C #£ does not make so much sense. Notice that when £ &amp;© 6 the above definition implies that 4 may produce no output at all due to stuttering only if can do so. This is also the case in <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref> but its technical definition has been adapted here for UMLSCs.</p><p>In the next section we will define the test case generation algorithm. Before we can proceed, however, we need to define precisely what a test case is and what testing an implementation against such a test case means. The remainder of this section will be devoted to these definitions, which are inspired by those given in <ref type="bibr" target="#b13">[13]</ref>. The basic notions behind them have been introduced in <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b17">[17]</ref>.</p><p>Intuitively, a test case is a specially customized 'environment' which interacts with the implementation under test by providing it with an event, collecting all the output generated by the implementation as a reaction to that event, analyzing its output and behaving accordingly: in particular it may (i) report success and/or (ii) provide the implementation with a new event and wait for the new related output and so on, or (iii) decide to stop testing. It is important to point out that, after providing the implementation with an event, the test case must be prepared to receive any possible outcome of the machine. If the implementation is an IOLTS over © % P© , such outcome can be any element of © .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.2 (Test Case)</head><formula xml:id="formula_9">A Test Case ¢ over © % © is a tuple ¡ ¤£ ¤ ¦¥ !¦ ¤ §£ ¤ © ¤ © ¤ x</formula><p>where £ is the set of output states, with ¥ 1¦ ¡ ¨£ being the initial (output) state, £ " u© © £ is the set of input states, each in- put state being a total function from © to output states. Finally ! " ¡ £ % © % £ (¡ £ % (b p¤ § e % £ is the transition relation, with ¡ B© P© b w¤ ¦ e C #£ . 0 A test case is similar to a transition system where some states-namely the input states, i.e. states in which the test case is supposed to get some output from the implementation-are actually total functions from © to output states. Totality guarantees that any output of the implementation is accepted by the test case for analysis in that state and, on the basis of the particular value received, the test case will move to the next output state. Notice that £ © makes test cases able to detect stuttering. It is also worth pointing out here that, although for generality in the above definition an input state is a function in © © £ w , for any practical purposes it is sufficient to con- sider finite functions <ref type="bibr" target="#b13">[13]</ref>. Output states are those in which the test case can (i) produce specific events to be delivered to the implementation, or (ii) silently move, via , to other (output) states-thus a test case can be internally non-deterministic-or (iii) produce the special action by which the test case reports success. We say that a test case ¢ is finite whenever £ , £ and are fi- nite sets.</p><p>Testing an IOLTS over © @% © against test case ¢ amounts to the Experimental System they characterize:</p><formula xml:id="formula_10">Definition 3.3 (Experimental System) For IOLTS C ¡ £¢ ¥¤ ¢ 1¦ ¨¤ © % © ¤ ! x</formula><p>and test case</p><formula xml:id="formula_11">¢ C ¡ £ ¤ ¦¥ !¦ ¤ §£ ¤ © ¤ © ¤ ! x , the experimental system ¢ a¤ is the transition system ¡ ¤£ % ¢ 7¤ ¡ ¥ !¦ ¨¤ ¢ 1¦ f ¤ "! v . The transition relation ! {" ¡ ¤£ % u¢ u x% ¡ £ % ¢ u</formula><p>is the smallest relation induced by the deduction system below where ¢ 1¤ ¢ @4 v¢ , ¥ G¤ §¥ !4 #£ , $ a %£ and for ¡ 3¡ ¤¥ G¤ ¢ @ ¤ ¡ ¤¥ !4 £¤ ¢ §4 &amp;! we write ¥ c c ¢ '! (¥ 14 c c ¢ §4</p><p>) 10 2 43 65 87 @9 BA 0 DC E F 2 43 69 7 ¡G 5 IH &amp;P RQ ) ) S TS 9 VU ) S WS <ref type="formula">9</ref>) YX 2 43 ) ) `S WS 9 aU ) S WS 9</p><p>The Success set of the experimental system is the set b b¥ x £ w c 9 c¥ !4 § d£ w A e¥ gf 1 ¥ !4 e 0 Notice that in the first rule in the above definition function $ is applied to e to obtain the next (output) state of ¥ , namely ¥ 4 . The effect of silent moves of test cases is defined by the second rule. Test runs are modeled by computations:</p><formula xml:id="formula_12">Definition 3.4 (Computations) A computation of experi- mental system ¢ ¤ h is a sequence of the form: ¥ ¦ c c ¢ ¦ ! (¥ c c ¢ ! (¥ &amp;i c c ¢ pi q! A A A r¥ c c ¢ ! A A A</formula><p>which is maximal, i.e. either it is infinite or it is finite with</p><formula xml:id="formula_13">terminal element ¥ # c c ¢ # which has the property that ¥ # c c ¢ # ! s¥ !4 c c ¢ §4</formula><p>for no pair ¥ 14 , ¢ §4 . ¥ ¦ and ¢ ¦ are the initial states of ¢ and . 0 We let t vu xw y w¡ "¢ a¤ 3 denote the set of all computations of ¢ ¤ h . A computation is successful iff ¥ Success for some B .</p><p>A verdict is the result of testing a system against a test case ¢ . The test is passed if all computations are success- ful:  </p><formula xml:id="formula_14">Definition 3.5 (Verdict)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Automatic Test Case Generation</head><p>In this section we define the test case generation algorithm. The algorithm generates test cases written in a language introduced in <ref type="bibr" target="#b13">[13]</ref>, which is a mix of process algebra (guarded action prefix, choice, and process definition/instantiation) and a simplified version of the lambdacalculus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">The test language</head><p>Let ¡ be a set of events and ¢ ¢ be a set of possible out- puts such that</p><formula xml:id="formula_15">£ £¢ ¢ ¥¤ ¡ and ¡ ¡ ¦¢ ¢ u b b p¤ ¦ e C y£ .</formula><p>The abstract syntax of output test expressions § , resp. input test expressions ¨, of the language is given below, where ¡ ¡ is an event, © yb b p¤ ¦ e , " ¢ ¢ , and are test and input variables respectively, is a boolean expression of the form " C " for ¢ ¢ or " " for " ¢ ¢ . The notion of free (input) variable is the same as in lambda-calculus. Brackets as well as proper indentation will be used whenever necessary.</p><formula xml:id="formula_16">§ "! #! C %$ c ¡ '&amp; ¨c © &amp; § c ¥( ) § c § 10 2 § c</formula><p>3! 4! C 65 7 8! ' RA § A test case specification consists of a pair ¡ 4 § )¤ 9 where § is an output test expression and " @¢ ¢ . We will require that no input variable occurs free in § and that a proper test definition is associated with any test variable occurring in § in the context where the test case specification is used. Moreover, all input test sub-expressions of § must use the same set in their defining lambda-expression. The test $ performs no action. Expression ¡ '&amp; ¨offers event ¡ and then behaves like ¨which is an input test expression, namely a function. Such a function will be applied to the output produced by an implementation under test in an experimental system (see Def.3.3 in Sect. 3). The specific (output) state resulting from the application is obtained according to the semantics of input test expressions, as given by the following rewrite rule for function application:</p><formula xml:id="formula_17">¡ A5 B 8! ' RA § C (C D § ¥E F HG ¡ '&amp; ¨I ! ¨© &amp; § P § § Q SR § T0 U § d4 Q ! VR § Q ! SR § d4 '0 U § Q VR § Q ! SR £ XW ¦ Y( ) § Q SR `! C D § )¤ a § Q bR Q ! VR Figure 2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Test Expressions Operational Semantics</head><p>where § ¥E F HG denotes § where all free occurrences of are simultaneously replaced by . Notice that the above rule is a simplification of c -reduction of the lambda-calculus since is just an element of ¢ ¢ : It cannot contain variables or lambda-expressions. Expression © &amp; § produces © and then behaves like § . Notice that © can be either or the success action , so no interaction with implementations can take place (see again Def.3.3 in Sect. 3). In order for a guarded action prefix to proceed it is necessary that the guard evaluates to true. The choice expression § R d0 D § i behaves as § or § i . Finally, if ! C 3 § is the definition for , behaves like § .</p><p>The operational semantics of test case specifications is given in a similar way as for process algebra, by means of the Structural Operational Semantics rules of Fig. <ref type="figure" target="#fig_0">2</ref> where e ¡ b w¤ ¦ e and R stands both for output and for in- put test expressions.</p><p>In order to formally derive the test case denoted by a test case specification we first need a couple of auxiliary definitions where by f 7 § Q gR we mean that § Q ! hR is deriv- able using the rules of Fig. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>! C Q</head><p>Non-deterministically choose between options (1) and (2) below 1) generate "" $# &amp;% '# )( " 2) generate "0 1# 32 54 76 1¥ £8 4 Q @9 BA DC uẼ . . . E 4 Q @9 GF A HC F E 4 BI P RQ 9 ~7 8 S8 T8 7 )9 F VU A ( " where:</p><formula xml:id="formula_18">0 is non-deterministically chosen in ¥ ¦ XW ¥ ¦ such that Y acb d0 Q Q 9 ~7 8 e8 e8 7 )9 GF U I</formula><p>Q gf , and C ih P p C G dq sr 1b 1t Vu G 0 7 )9 h P 8P for v Q xw 7 8 e8 e8 7 )y The above important result means that if a test case generated by the algorithm for a certain specification reports a failure when running against an implementation, then we can be sure that the latter does not conform to the specification ; moreover, if an implementation does not conform to specification , then a test case can be generated by the algorithm which will report failure when executed against such an implementation.</p><p>We close this section with an application of test cases derivation to our running example. Let us consider again the specification of Fig. <ref type="figure">1</ref>   , and this can be checked using the test case § ¦¥ shown in Fig. <ref type="figure">6</ref>, which is also derived using the algorithm.</p><p>Clearly 8 § ¡¥ 4 C fail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusions and Future Work</head><p>In this paper we proposed a formal conformance testing relation for UMLSCs and an automatic test case generation algorithm. The algorithm has been proven complete, i.e. sound and exhaustive. § £¥ ! C &amp; 5 H 8! 4 A ¡ 3¡ HC vb fX p e ( ) § £¢ i0 h¡ b b fX p e te ( V$ z 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 6. Another test case generated from the running example</head><p>The conformance relation and its test case generation algorithm are based on an operational semantics for UMLSCs which has been proven to fulfill major behavioral requirements stated in the official UML definition <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7]</ref>. As we already pointed out, the main contribution of the present paper is to set the theoretical basis for test case generation in a conformance testing setting. In order to use the test generation algorithm in practice proper test selection strategies are needed which will be a subject of our future work. Some work on test selection in a formal test derivation framework is already present in the literature (see, e.g. <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b5">6]</ref>), and in particular random test case selection seems to be a promising option. In fact it nicely fits with the structure of our algorithm; what is needed is to replace non-deterministic choices with random, coin-flipping, ones. Moreover, random test selection is receiving more and more attention due to the high coverage that it can provide, using efficient automated tools. Another promising line of research is the use of model-checking techniques for enhancing automatic test case generation, which we are currently investigating <ref type="bibr" target="#b4">[5]</ref>. Tightly connected to the above research lines is the area of efficient implementation of test generation and selection algorithms. There are already tools available to that purpose, e.g. AutoFocus <ref type="bibr" target="#b19">[19]</ref> and TGV/AGEDIS [20], and one of our next steps will be an investigation on the possibility of connecting our work with such tools.</p><p>In the present paper we made no assumption on how test cases are "implemented", i.e. on their actual presentation. They might be represented again as UMLSCs or as UML Sequence Diagrams or just as code in a proper programming language. This last possibility could allow for the implementation of test runs using proper automatic tools, to be integrated with the test case generation tools, which is our ultimate goal.</p><p>Another line of future research deals with the extension of the subset of UMLSCs we take into consideration. One necessary extension consists in allowing the use of UML specifications consisting of collections of UMLSCs interacting via queues, which brings to distributed testing. The use of a test language like the one proposed in the present paper, which is easy to extend in order to allow control communication between the experimenters to take place, greatly facilitates the task of specifying complex distributed test cases and to developing a suitable extension of testing theory to the distributed case.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>, 2 G</head><label>2</label><figDesc>H© , I ( P© RQ S The transition relation T ! over finite sequences is defined in the obvious way: (a) ¢ U ¢ and (b) if ¢ VT 1 ¢ §4 and ¢ §4 8 ! ¢ §4 4 , then ¢ WT 8 ¢ §4 4 ; S The language of is the set of all its traces: © YX ¨à C b I F &amp;© Q dc 9 ¢ 4 A ¢ ¦ T ! ¢ 4 fe ; S The states of ¢ after I is the set ¡ ¢ hg ¨i ¨p rq ts RI @ uC vb ¢ 4 wc ¢ T ¢ 4 fe . 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 2 . 4</head><label>24</label><figDesc>For t u" © RQ , ( u &amp;© , I F &amp;© RQ S the traces of t after I is the set ¡ vt yg ¨i ¨p pq ts I § uC vb I §4 c I !I 14 1 Ht e ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(b); labels ¡ ( x¤ 3e § are drawn as ( 3 e in the pic- ture. For simplicity, several stuttering loops from/to the same state, labeled by ( £ ¤ A A A ¤ ( £ have been collapsed to a single loop labeled by ( ¤ A A A ¤ ( z £</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>b X ! e ¤ b fX r e ¤ b ¡ e ¤ b ¡ e ¤ b G e ¤ b s e ¤ b z e ¤ b ¡ z¤ ¡ e e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 .Lemma 4 . 1 (( 3 Theorem 4 . 1 Figure 4 .Figure 5 .</head><label>34134145</label><figDesc>Figure 3. The Test Case Generation Algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>and the implementation R4over © 4 % © 4 with © 4 C b X p f¤ ¡ ¤ ¡ i ¤ 3 ¤ i ze and © 4 C b £ ¤ b X p e ¤ b ¡e ¤ b i ze e given in Fig.4, which is obviously an incomplete one. We can apply the algorithm in order to obtain, among others, the test case § R shown in Fig.5.It is easy to see that 8 § R 4 !C pass. On the other hand,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>4</head><label>4</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The verdict of ¢ on is defined Given specification and test suite £ ¢ S £ ¢ is sound w.r.t. and iff 4 implies £ ¢ F 4 !C pass, for all implementations R4 ; S £ ¢ is exhaustive w.r.t. and iff £ ¢ 4 §C pass implies 4 , for all implementations R4 . We say that a test suite is complete if it is both exhaustive and sound.</figDesc><table><row><cell>Definition 3.6 (Soundness and Completeness)</cell><cell></cell></row><row><cell>as follows:</cell><cell></cell></row><row><cell>¢ C</cell><cell>pass if t vu xw y w¡ "¢ a¤ 3 contains only successful computations</cell></row><row><cell></cell><cell>fail otherwise</cell></row><row><cell></cell><cell>0</cell></row><row><cell cols="2">A test suite is a set of test cases. The verdict function is extended to test suites in the obvious way; for test suite £ ¢</cell></row><row><cell cols="2">r ¢ { d£ ¢ ¥A e ¢ y DC pass fail otherwise £ ¢ F xC ¨ pass if</cell></row><row><cell cols="2">The following definition relates test suites to specifications</cell></row><row><cell cols="2">using conformance relations and introduces the notions of</cell></row><row><cell cols="2">sound and exhaustive test suites.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The test case associated with test case specification ¡ 4 § )¤ 9 is the test case over © xC #© YX yx ¡ # § % w with output states the output test expressions in pIn the sequel we will omit set in test case specification ¡ 4 § )¤ 9 when is clear from the context. Moreover we will identify ¡ 4 § )¤ i with the test case it denotes. A A A ¤ are the expected correct values for the output of the implementation under test as reaction to input ¡ . Consequently, a test case is generated which first sends ¡ to the implementation and then, if the output of the implementation does not match any of the expected values u ¤ A A A ¤ G , it stops without reporting success, otherwise, assuming that the output of the implementation is £¢ , it continues as § ¤¢ . Notice that test case § ¤¢ is generated by a recursive call of ¥ Q ¥ §¦ ©¥ and ¥ Q ¥ ¦ ¥ we define the follow- ing non-deterministic algorithm which, given set ¥ , after a finite number of recursive calls, returns a test case in the test language.</figDesc><table><row><cell>We can now formally define the test case associated with test case specification ¡ 4 § )¤ 9 :</cell><cell></cell></row><row><cell>Definition 4.3 g rq ¥j tial state being  § , input states the input test expressions l , the ini-in p g rq ¥j l and transition relation b s¡ 4 § 4 ¤ e ¤ R G c  § 4 ¤ R p g uq j l ¤ 9f t § d4 @Q 1 SR e 0</cell><cell></cell></row><row><cell>The following is an example of a very simple test case over ¡ % , where ¡ C b f e and vC vb £ ¤ b fX p e ¤ b ¡ e ¤ b i e e</cell><cell></cell></row><row><cell>which starts by sending z to the implementation under test</cell><cell></cell></row><row><cell>and then, if the latter responds with b fX e it reports success,</cell><cell></cell></row><row><cell>otherwise it stops without reporting success:</cell><cell></cell></row><row><cell>&amp; 5 H 2! ' RA U qC vb X r e ( &amp; &amp; $ 0 b tb fX e te ( b$</cell><cell></cell></row><row><cell>4.2. The Test Case Generation Algorithm</cell><cell></cell></row><row><cell cols="2">The definition of the test case generation algorithm £ ¡ is given in Fig.3. Note that £ ¡ is non-deterministic. Given</cell></row><row><cell>© C © % © ter a finite number of recursive calls, £ and © 4 C © 4 % © 4 and t " © Q , af-¡ returns a test case  § in the test case language. The intuitive behaviour</cell><cell></cell></row><row><cell>of the algorithm is rather simple; at each call, the algo-</cell><cell></cell></row><row><cell>rithm generates a single test case. In particular, at each</cell><cell></cell></row><row><cell>call, it may (non-deterministically) either generate the test which always reports success ( &amp; &amp; $ ), after which it ter-minates, or generate a test case as follows. An event ¡ is</cell><cell>2,</cell></row><row><cell>(non-deterministically) chosen which belongs both to the input alphabet of the specification (© ) and to that of the implementation (© 4 ) and such that the set rp t ¡ C b ¤ A A A ¤ G e is non-empty (notice that such an ¡ exists when dealing with IOLTSs associated to UMLSCs, due to input-enabledness; see detailed proofs in [7]). Intuitively,</cell><cell>Definition 4.1 (Derivatives) The derivatives of test case specification ¡ 4 § )¤ i is the smallest set p g rq ¥j l of test ex-pressions which satisfies the following three conditions: 1.  § sp g rq ¥j l ; 2. if output test expression  § 4 is in p g rq ¥j l and f t § d4 @Q g uq j l ; 3. if input test expression ¨is in p g rq ¥j l p g rq ¥j l for all e F w . then ¡ v¨e 1 is in R then also R is in p</cell></row><row><cell>the algorithm.</cell><cell></cell></row><row><cell>The set of all test cases which can be generated from t , © and © 4 by repeated application of £ ¡ is denoted by j ¡ £ ¡ t .</cell><cell></cell></row></table><note><p><p>¤</p>For</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Although we refer to UML 1.5, the main features of the notation of interest for our work have not changed in later versions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This notion of stuttering is the UMLSCs analogous of quiescence in the context of LTSs with separate input and output label sets, like in<ref type="bibr" target="#b20">[21]</ref>. Explicit representation of quiescence is common practice in the study of formal conformance relations.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Another useful extension is the introduction of data values and variables in UMLSCs. We have already a semantics definition for such an extension, fully developed in the context of the the PRIDE project <ref type="bibr" target="#b9">[10]</ref>. Of course (infinite) data sets pose further problems in the test selection procedures.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A metric based theory of test selection and coverage</title>
		<author>
			<persName><forename type="first">J</forename><surname>Alilovic-Curgus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vuong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Protocol Specification, Testing, and Verification</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Danthine</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Leduc</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename></persName>
		</editor>
		<imprint>
			<publisher>North-Holland Publishing Company</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">XII</biblScope>
			<biblScope unit="page" from="289" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automated test set generation for Statecharts</title>
		<author>
			<persName><forename type="first">K</forename><surname>Bogdanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Holcombe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Applied Formal Methods</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Hutter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Stephan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Traverso</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Ullmann</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1641</biblScope>
			<biblScope unit="page" from="107" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Finite state machines based formal methods in protocol conformance testing: from theory to implementation. Computer Networks and ISDN Systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bosik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Ümit</forename><surname>Uyar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="7" to="33" />
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A framework for test selection</title>
		<author>
			<persName><forename type="first">E</forename><surname>Brinksma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tretmans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Verhaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Protocol Specification, Testing, and Verification</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Jonsson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Parrow</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Pehrson</surname></persName>
		</editor>
		<imprint>
			<publisher>North-Holland Publishing Company</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">XI</biblScope>
			<biblScope unit="page" from="289" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Enhancing test coverage by back-tracing model-checker counterexamples</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fantechi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gnesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maggiore</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Test selection, trace distance and heuristics</title>
		<author>
			<persName><forename type="first">L</forename><surname>Feijs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tretmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFIP 14th International Conference on Testing of Communicating Systems</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Formal conformance testing UML Statechart Diagrams Behaviours: From theory to automatic test generation</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gnesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Latella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Massink</surname></persName>
		</author>
		<idno>CNUCE- B04-2001-16</idno>
	</analytic>
	<monogr>
		<title level="j">Consiglio Nazionale delle Ricerche, Istituto CNUCE</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Full version</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Modular semantics for a UML Statechart Diagrams kernel and its extension to Multicharts and Branching Time Model Checking. The Journal of Logic and Algebraic Programming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gnesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Latella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Massink</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Elsevier Science</publisher>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="43" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Algebraic Theory of Processes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hennessy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">PRIDE Definition of Changes in UML Notation</title>
		<author>
			<persName><forename type="first">Cnr-Cnuce</forename><surname>Intecs</surname></persName>
		</author>
		<idno>PRIDE Deliverable 1.2</idno>
		<imprint>
			<publisher>PRIDE</publisher>
			<biblScope unit="page">2</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic verification of a behavioural subset of UML statechart diagrams using the SPIN model-checker. Formal Aspects of Computing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Latella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Majzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Massink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The International Journal of Formal Methods</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="637" to="664" />
			<date type="published" when="1999">1999</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Towards a formal operational semantics of UML statechart diagrams</title>
		<author>
			<persName><forename type="first">D</forename><surname>Latella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Majzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Massink</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">In</forename><forename type="middle">P</forename><surname>Ciancarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fantechi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
		<title level="m">IFIP TC6/WG6.1 Third International Conference on Formal Methods for Open Object-Oriented Distributed Systems</title>
		<imprint>
			<publisher>Kluwer Academic Publishers</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="331" to="347" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A formal testing framework for UML Statechart Diagrams behaviours: From theory to automatic verification</title>
		<author>
			<persName><forename type="first">D</forename><surname>Latella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Massink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Sixth IEEE International High-Assurance Systems Engineering Symposium</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Jacobs</surname></persName>
		</editor>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="11" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On testing and conformance relations of UML Statechart Diagrams Behaviours</title>
		<author>
			<persName><forename type="first">D</forename><surname>Latella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Massink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGSOFT 2002 International Symposium on Software Testing and Analysis</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Frankl</surname></persName>
		</editor>
		<meeting>the ACM SIGSOFT 2002 International Symposium on Software Testing and Analysis</meeting>
		<imprint>
			<publisher>Association for Computing Machinery -ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="144" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">System test synthesis from UML models of distributed software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Le Traon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jeron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jezequel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pickin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Le</forename><surname>Guennec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Techniques for Networked and Distributed Systems -FORTE 2002</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2529</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Principles and Methods of Testing Finite State Machines -A Survey</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1090" to="1123" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Functional Techniques in Concurrency</title>
		<author>
			<persName><forename type="first">M</forename><surname>Massink</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-02">Feb. 1996</date>
		</imprint>
		<respStmt>
			<orgName>University of Nijmegen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">OMG Unified Modeling Language Specification -version 1</title>
		<ptr target="http://www.omg.org/cgi-bin/doc?formal/03-03-01" />
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Object Management Group, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Model based testing for real: The Inhouse Card study</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pretschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Slotosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lötzbeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Aiglstorfer</surname></persName>
		</author>
		<ptr target="http://www.agedis.de/index.shtml" />
	</analytic>
	<monogr>
		<title level="m">th International ERCIM Workshop on Formal Methods for Industrial Critical Systems</title>
		<title level="s">20] The Agedis Project. The Agedis Home Page</title>
		<meeting><address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001. 2003</date>
			<biblScope unit="page" from="79" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Test generation with inputs, outputs and repetitive quiescence</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tretmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software -Concepts and Tools</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="103" to="120" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Testing concurrent systems: A formal approach</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tretmans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Concur &apos;99</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Baeten</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1664</biblScope>
			<biblScope unit="page" from="46" to="65" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
