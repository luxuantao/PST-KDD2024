<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">pTunes: Runtime Parameter Adaptation for Low-power MAC Protocols</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marco</forename><surname>Zimmerling</surname></persName>
							<email>zimmerling@tik.ee.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Engineering</orgName>
								<orgName type="laboratory">Networks Laboratory</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Federico</forename><surname>Ferrari</surname></persName>
							<email>ferrari@tik.ee.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Engineering</orgName>
								<orgName type="laboratory">Networks Laboratory</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Luca</forename><surname>Mottola</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Swedish Institute of Computer Science (SICS)</orgName>
								<address>
									<settlement>Kista</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thiemo</forename><surname>Voigt</surname></persName>
							<email>thiemo@sics.se</email>
							<affiliation key="aff1">
								<orgName type="institution">Swedish Institute of Computer Science (SICS)</orgName>
								<address>
									<settlement>Kista</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lothar</forename><surname>Thiele</surname></persName>
							<email>thiele@tik.ee.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Engineering</orgName>
								<orgName type="laboratory">Networks Laboratory</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">pTunes: Runtime Parameter Adaptation for Low-power MAC Protocols</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">840E45441357857AA328C30BA317FC7A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.2 [Computer-Communication Networks]: Network Protocols; C.2.1 [Computer-Communication Networks]: Network Architecture and Design-wireless communication Design</term>
					<term>Experimentation</term>
					<term>Performance Runtime adaptation</term>
					<term>parameter optimization</term>
					<term>MAC protocol</term>
					<term>multi-objective</term>
					<term>centralized</term>
					<term>end-to-end</term>
					<term>sensor network</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present pTunes, a framework for runtime adaptation of low-power MAC protocol parameters. The MAC operating parameters bear great influence on the system performance, yet their optimal choice is a function of the current network state. Based on application requirements expressed as network lifetime, end-to-end latency, and end-to-end reliability, pTunes automatically determines optimized parameter values to adapt to link, topology, and traffic dynamics. To this end, we introduce a flexible modeling approach, separating protocol-dependent from protocol-independent aspects, which facilitates using pTunes with different MAC protocols, and design an efficient system support that integrates smoothly with the application. To demonstrate its effectiveness, we apply pTunes to X-MAC and LPP. In a 44-node testbed, pTunes achieves up to three-fold lifetime gains over static MAC parameters optimized for peak traffic, the latter being current-and almost unavoidable-practice in real deployments. pTunes promptly reacts to changes in traffic load and link quality, reducing packet loss by 80 % during periods of controlled wireless interference. Moreover, pTunes helps the routing protocol recover quickly from critical network changes, reducing packet loss by 70 % in a scenario where multiple core routing nodes fail.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Media access control (MAC) protocols play a key role in determining the performance and reliability of low-power wireless networks, but very few of the many proposed solutions have been adopted in real deployments <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b33">34]</ref>. Challenges. There exists a large conceptual gap between the high-level application requirements and the low-level MAC protocol operation <ref type="bibr" target="#b22">[23]</ref>. In particular, it requires expert knowledge to find MAC operating parameters whose performance satisfies given application requirements.</p><p>In most deployments today, the choice of MAC parameters is based on experience and rules of thumb involving a coarsegrained analysis of expected network load and topology dynamics. This can yield a performance far off the application requirements <ref type="bibr" target="#b23">[24]</ref>. Alternatively, system designers perform several field trials to identify suitable MAC parameters <ref type="bibr" target="#b7">[8]</ref>. This time-consuming and deployment-specific practice, however, is hardly sustainable in the long term.</p><p>Even if the MAC parameters are appropriate at one time, they are likely to perform poorly when the network state changes. Wireless link quality varies significantly over time, leading to unpredictable packet loss <ref type="bibr" target="#b40">[41]</ref>; harsh environmental conditions cause nodes to be temporarily disconnected or to fail <ref type="bibr" target="#b1">[2]</ref>; and changes in the routing topology or the sensing activity result in traffic fluctuations. Statically configured MAC protocols cannot cope with these dynamics.</p><p>To perform efficiently, MAC protocols must adapt their operating parameters at runtime. One way to approach this problem is to embed adaptivity within the protocol operation <ref type="bibr" target="#b20">[21]</ref>. This, however, hard-codes the adaptation decisions and thus limits their applicability. Instead, separating adaptivity from the protocol operation enables higher-layer services to dynamically adjust the operating parameters <ref type="bibr" target="#b31">[32]</ref>. Although a few mechanisms utilize such control knobs, they focus either on a single metric-typically energy <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b27">28]</ref>or consider only local metrics, such as per-hop latency <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b30">31]</ref>. Real-world applications, however, often require to balance multiple conflicting needs such as reliability, energy, and latency, expressed on a network-wide scale <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b37">38]</ref>. Contributions and road-map. To tackle the issues above, we present pTunes, a framework for runtime adaptation of low-power MAC protocol parameters. In pTunes, users specify application requirements in terms of network lifetime, end-to-end reliability, and end-to-end latency-key performance metrics in real-world applications <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref>. Using information about the current network state, pTunes automatically determines optimized MAC parameters whose performance meets the requirements specification. This paper makes the following contributions: â€¢ We introduce the pTunes framework, targeting data collection systems using tree-shaped routing topologies atop low-power MAC protocols. As shown in Fig. <ref type="figure" target="#fig_0">1</ref>, the base station collects reports on the network state, such as topology and link quality information, required to evaluate the network-wide metrics we target. The optimization trigger decides when to carry out the parameter optimization, based on a periodic timer or a mechanism that uses the network-wide performance model to check if the application requirements are violated under the current network state. The solver determines a vector of optimized MAC parameters, which is disseminated in the network and installed on all nodes. Sec. 2 further characterizes the multiobjective parameter optimization problem in pTunes. â€¢ We design a well-structured modeling framework to solve the parameter optimization problem. Our layered modeling approach, described in Sec. <ref type="bibr" target="#b2">3</ref>, separates applicationlevel, protocol-independent, and protocol-dependent quantities. This increases generality and flexibility, as it cleanly determines what needs to be changed to account for a different MAC protocol. We apply this modeling approach to two state-of-the-art protocols, X-MAC <ref type="bibr" target="#b4">[5]</ref> and LPP <ref type="bibr" target="#b28">[29]</ref>, based on their implementations in Contiki. We leverage these models throughout the rest of the paper, ultimately demonstrating that they are both practical and accurate. â€¢ We present the design and implementation of an efficient system support to meet the system-level challenges arising in pTunes. These include, for instance, the timely collection of accurate network state with little energy overhead and minimum disruption for the application operation. As described in Sec. <ref type="bibr" target="#b3">4</ref>, unlike most approaches in the literature, we meet these requirements with a novel solution for collecting network state and disseminating new MAC parameters independent of other protocols running concurrently. Our approach utilizes fast and reliable Glossy network floods <ref type="bibr" target="#b15">[16]</ref>, allowing pTunes to collect consistent network state snapshots, taken with microsecond accuracy at all nodes simultaneously, with very low energy cost.</p><p>After illustrating implementation details in Sec. 5, we evaluate pTunes in Sec. 6 using experiments with X-MAC and LPP on a 44-node testbed. For instance, we find that adapting their parameters using pTunes enables up to threefold lifetime gains over static MAC parameters optimized for peak traffic, the latter being current practice in many real deployments <ref type="bibr" target="#b22">[23]</ref>. pTunes promptly reacts to changes in traffic load and link quality, meeting application-level requirements through an 80 % reduction in packet loss during periods of controlled wireless interference. Moreover, we find that pTunes helps the routing protocol recover from critical network changes, reducing the total number of parent switches and settling quickly on a stable, high-quality rout-ing topology. This reduces packet loss by 70% in a scenario where multiple core routing nodes fail simultaneously.</p><p>We discuss design trade-offs of pTunes in Sec. 7, review related work in Sec. 8, and conclude the paper in Sec. 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">OPTIMIZATION PROBLEM</head><p>In pTunes, we simultaneously consider three key performance metrics of real-world applications <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref>: network lifetime T , end-to-end reliability R, and end-to-end latency L. The MAC parameter optimization problem thus becomes a multi-objective optimization problem (MOP). This involves optimizing the objective functions T (c), R(c), and L(c), where c is a vector of MAC parameters, or MAC configuration for short. There may exist not one unique optimal solution to this MOP, but rather a set of solutions that are optimal in the sense that no other solution is superior in all objectives. These are known as Pareto-optimal solutions and represent different optimal trade-offs among T , R, and L.</p><p>Given the many Pareto-optimal solutions, a natural question is which solution best serves the application demands. pTunes needs to make this decision at runtime in an automated fashion, without involving the user (e.g., to manually select a solution from a set of candidates). With this requirement in mind, we adopt from among the many MOP solving techniques an approach inspired by the epsilon-constraint method <ref type="bibr" target="#b19">[20]</ref>. This method treats all but one objective as constraints, and thus provides a natural interface for specifying typical requirements of low-power wireless systems such as "batteries should last for at least 6 months." Using this approach, pTunes solves the MOP by optimizing one objective subject to constraints on the remaining objectives</p><formula xml:id="formula_0">Maximize/Minimize M1(c) Subject to M2(c) â‰¥, â‰¤ C1 M3(c) â‰¥, â‰¤ C2<label>(1)</label></formula><p>where each Mi is one among {T, R, L} and {C1, C2} are soft requirements to be satisfied in the long run, corresponding to the best-effort operation of many data collection systems <ref type="bibr" target="#b17">[18]</ref>. By varying {C1, C2}, all Pareto-optimal solutions can be generated. Based on concrete values for {C1, C2} set by the user on some objectives, pTunes translates the application requirements into a solution that optimizes the remaining objective. The resulting solution is Pareto-optimal while representing the trade-off provided by the user.</p><p>As an example, in long-term structural monitoring the major concern is typically system lifetime, but domain experts also require a certain reliability in delivering sensed data <ref type="bibr" target="#b6">[7]</ref>. Based on (1), maximizing network lifetime subject to a minimum end-to-end reliability is specified as</p><formula xml:id="formula_1">Maximize T (c) Subject to R(c) â‰¥ Rmin<label>(2)</label></formula><p>In addition, we may impose a constraint on end-to-end latency, L(c) â‰¤ Lmax, if timely data delivery is relevant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MODELING FRAMEWORK</head><p>To facilitate using pTunes with different low-power MAC protocols, we break up the modeling into three distinct layers, as shown in the model frame in Fig. <ref type="figure">2</ref>. The upper layer defines application-level metrics (R, L, T ) as functions of link and node-specific metrics (R l , L l , Tn). The middle layer expresses these metrics in a protocol-independent manner,</p><formula xml:id="formula_2">Network State MAC Parameters transmission p l R l T n L l D rx ,n D tx ,n T ftx ,l T stx ,l p s,l N ftx ,l Protocol- independent Protocol-</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applicationlevel</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Probability of successful dependent</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MAC configuration c</head><p>Topology N , M, L</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Packet generation rate F n</head><p>Network-wide Performance Model</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R T L</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model Output</head><p>Figure <ref type="figure">2</ref>: Modeling framework with inputs, output, and mapping between modeling layers. Only the protocol-dependent layer must be changed to prepare the network-wide performance model for another MAC protocol. and provides the entry point for the modeling of a concrete MAC protocol by exposing six terms to the lower protocoldependent layer. Binding these terms to concrete protocolspecific expressions is sufficient to adapt the network-wide performance model in pTunes to a given MAC protocol.</p><p>Model inputs are the MAC parameters and the network state, comprising information about routing topology, traffic volumes, and link qualities. As a measure of the latter, we take the probability of successful transmission p l over the link to the parent in the routing tree. To keep our models simple and practical, we assume the delivery of individual packets to be independent of their size, of the delivery of any other packet, and of the link direction they travel along. As illustrated in Sec. 4, our runtime evaluation of p l captures the impact of channel contention on link quality, allowing us not to consider it explicitly in our models. Testbed experiments in Sec. 6.2 show that this approach results in highly accurate models for both X-MAC and LPP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Application-level Metrics</head><p>In a typical data collection scenario with static nodes, a tree-shaped routing topology provides a unique path from every sensor node to a sink node. These paths are generally time-varying, as the routing protocol adapts them according to link quality estimates among other things <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b32">33]</ref>. In the following, we use N to denote the set of all nodes in the network excluding the sink, and M âŠ† N to denote the set of source nodes generating packets. We also indicate with L the set of communication links that form the current routing tree. The path Pn âŠ† L originating at node n âˆˆ M includes all intermediate links that connect node n to the sink. Table <ref type="table">1</ref> lists these and other modeling terms we use to denote network state and protocol-dependent quantities. End-to-end reliability and latency. The reliability RP n of path Pn is the expected fraction of packets delivered from node n âˆˆ M to the sink along Pn. Thus, RP n is the product of per-hop reliabilities R l , l âˆˆ Pn. We define the end-to-end reliability R as the average reliability of all paths Pn.</p><formula xml:id="formula_3">R = 1 |M| nâˆˆM RP n = 1 |M| nâˆˆM lâˆˆPn R l<label>(3)</label></formula><p>Likewise, the latency LP n of path Pn is the expected time between the first transmission of a packet at node n âˆˆ M and its reception at the sink. Thus, LP n is the sum of perhop latencies L l , l âˆˆ Pn. Similar to (3), we define the endto-end latency L for successfully delivered packets as the average latency of all paths Pn, and omit the formula. Probability of successful unicast transm. over link l N ftx ,l No. of failed unicast transm. before success over link l T ftx ,l Time for a failed unicast transmission over link l T stx ,l Time for a successful unicast transmission over link l Drx,n Fraction of time radio is in receive mode at node n Dtx,n Fraction of time radio is in transmit mode at node n Table <ref type="table">1</ref>: Glossary of modeling terms used to denote network state and protocol-dependent quantities.</p><p>We define R and L as averages of all source-sink paths since the global, long-term performance is of ultimate interest for most data collection systems <ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref>. Local, shortterm deviations from the requirements are usually tolerated, provided they are compensated in the long run. In other scenarios (e.g., industrial settings), it might be more appropriate to define R and L as the minimum reliability and the maximum latency among all source-sink paths, which would only require modifying the two definitions above. Network lifetime. Similar to prior work <ref type="bibr" target="#b26">[27]</ref>, we define the network lifetime T as the expected shortest node lifetime Tn, n âˆˆ N . We assume the sink has infinite energy supply.</p><formula xml:id="formula_4">T = min nâˆˆN (Tn)<label>(4)</label></formula><p>This choice is motivated by the fact that a single node failure can lead to network partition and service interruption. It is also possible to express other notions of network lifetime in pTunes, such as the time until some fraction of nodes fails, again requiring only to modify the definition in (4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Protocol-independent Modeling</head><p>The section above expressed the application-level metrics R, L, and T as functions of per-hop reliability R l , per-hop latency L l , and node lifetime Tn (see Fig. <ref type="figure">2</ref>). We now define the latter three in a protocol-independent manner, which increases flexibility and generality by isolating protocol-dependent quantities. We omit a few explicit expressions and refer to an extended report <ref type="bibr" target="#b41">[42]</ref> where applicable. Per-hop reliability and latency. Several factors influence these metrics: (i) the MAC operation when transmitting packets, (ii) packet queuing throughout the network stack due to insufficient bandwidth, and (iii) applicationlevel buffering (e.g., to perform in-network processing). The MAC parameters control (i) and may avoid the occurrence of (ii), provided a MAC configuration exists that provides sufficient bandwidth. Application-specific in-network functionality akin to (iii) is out of the scope of this work.</p><p>We present next expressions for per-hop reliability and latency due to the MAC operation, corresponding to (i). Additionally, pTunes includes models to detect situations akin to (ii) <ref type="bibr" target="#b41">[42]</ref>. In fact, as we show in Sec. 6.2, pTunes automatically adjusts the MAC parameters to provide higher bandwidth against increased traffic, thus avoiding the occurrence of local packet queuing until the network capacity attainable in our experimental setting is fully exhausted.</p><p>We define the per-hop reliability R l of link l âˆˆ L, which connects node n âˆˆ N to its parent m in the routing tree, as the probability that n successfully transmits a packet to m.</p><formula xml:id="formula_5">R l = 1 -(1 -p s,l ) N +1<label>(5)</label></formula><p>Here, p s,l represents the MAC-dependent probability that a single unicast transmission over link l succeeds, and N is the maximum number of retransmissions per packet, modeling automatic repeat request (ARQ) mechanisms used by many low-power MAC protocols to improve reliability. Furthermore, we define the per-hop latency L l of link l as the time for node n to deliver a message to its parent m.</p><formula xml:id="formula_6">L l = N ftx ,l â€¢ T ftx ,l + T stx ,l<label>(6)</label></formula><p>T ftx ,l and T stx ,l are the MAC-dependent times spent for each failed and the final successful transmission. The expected number of failed transmissions N ftx ,l depends on p s,l and N , and the retransmission policy of the MAC protocol <ref type="bibr" target="#b41">[42]</ref>.</p><p>Node lifetime. Sensor nodes consume energy by communicating, sensing, processing, and storing data. Adapting the MAC parameters has no significant impact on the latter three, but affects energy expenditures on communication to a large extent, as the radio is typically the major energy consumer. Given a battery capacity Q, we define the node lifetime Tn of node n âˆˆ N as</p><formula xml:id="formula_7">Tn = Q/(Dtx,n â€¢ Itx + Drx,n â€¢ Irx + D idle,n â€¢ I idle )<label>(7)</label></formula><p>where Itx , Irx , and Ii are the current draws of the radio in transmit, receive, and idle mode. Tn is thus the expected node lifetime based on the fractions of time in each mode Dtx,n, Drx,n, and D idle,n = 1 -Dtx,n -Drx,n, which depend on the MAC protocol and the traffic volume at node n.</p><p>The traffic volume is the rate at which nodes send and receive packets. A node n âˆˆ N generates packets at rate Fn and receives packets from its children Cn âŠ† N in the routing tree, if any. The rate of packet reception depends on each child's packet transmission rate Ftx,c and the individual per-hop reliabilities R lc of links lc, c âˆˆ Cn, connecting each child c with n. Thus, node n transmits packets at rate</p><formula xml:id="formula_8">Ftx,n = (N rtx ,l + 1) â€¢ Fn + câˆˆCn Ftx,c â€¢ R lc<label>(8)</label></formula><p>N rtx ,l is the expected number of retransmissions per packet over link l, which is a function of N and the MAC-dependent probability that a retransmission occurs <ref type="bibr" target="#b41">[42]</ref>.</p><p>We demonstrate next the modeling of a concrete MAC protocol. This requires to find expressions for six protocolspecific terms, as shown in Fig. <ref type="figure">2</ref> and described in Table <ref type="table">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Protocol-specific Modeling</head><p>We use two state-of-the-art MAC protocols to exemplify the protocol-specific modeling. X-MAC <ref type="bibr" target="#b4">[5]</ref> is representative of many sender-initiated MAC protocols based on low-power listening (LPL) <ref type="bibr" target="#b31">[32]</ref> that proved viable in real-world deployments <ref type="bibr" target="#b22">[23]</ref>. Recent work focuses on receiver-initiated MAC protocols such as low-power probing (LPP) <ref type="bibr" target="#b28">[29]</ref>. In the following, we refer to implementations of X-MAC and LPP in Contiki 2.3, which we also use in our experiments in Sec. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Sender-initiated: X-MAC</head><p>Fig. <ref type="figure" target="#fig_1">3</ref> shows a successful unicast transmission in X-MAC. Nodes wake up periodically for Ton to poll the channel 1 , where T off is the time between two channel polls. To send a packet, a node transmits a sequence of strobes 2 , short</p><formula xml:id="formula_9">T str T sl T d t T sa T off T da</formula><p>Tx mode</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rx mode</head><p>T on 1 2 packets containing the identifier of the receiver. Strobing continues for a period sufficient to make at least one strobe overlap with a receiver wake-up 3 . The receiver replies with a strobe acknowledgment (s-ack) 4 and keeps the radio on awaiting the transmission of the data packet 5 . The sender transmits the data packet upon receiving the s-ack 6 and waits for the data acknowledgment (d-ack) 7 from the receiver. Afterward, both nodes turn off their radios. Failed s-ack, d-ack, and data packet transmissions are handled by timeouts. When a timeout occurs, the sender backs off for a random period and retries beginning with the strobing phase, for at most N times. Broadcasts proceed similarly to unicast transmissions, but the strobing phase lasts for Tm = 2 â€¢ Ton + T off to make a strobe overlap with the wake-up of all neighboring nodes. Nodes receiving a broadcast strobe keep their radio on until they receive the data packet at the end of the sender's strobing phase.</p><p>Several variables are adjustable in the X-MAC implementation we consider. However, three specific parameters affect its performance to a major extent.</p><formula xml:id="formula_10">c = [Ton , T off , N ]<label>(9)</label></formula><p>We let pTunes adapt these parameters at runtime, using the X-MAC-specific models presented next.</p><p>Per-hop reliability. We determine p s,l in (5), the probability that a single unicast from node n to its parent m succeeds. This is the case if m hears a strobe (with probability p str ,l ), the s-ack reaches n, and m receives the data packet. Each of the latter two succeeds with probability p l , collected at runtime as part of the network state (see Sec. 4).</p><formula xml:id="formula_11">p s,l = p str ,l â€¢ p 2 l (<label>10</label></formula><formula xml:id="formula_12">)</formula><p>The probability of receiving at least one strobe is</p><formula xml:id="formula_13">p str ,l = 1 -(1 -p l ) (Ton -T str )/T it<label>(11)</label></formula><p>where Tit = Tstr + T sl is the duration of a strobe iteration at the sender, which includes the length of a strobe transmission Tstr and listening T sl for an s-ack.</p><p>Per-hop latency. We determine T ftx ,l and T stx ,l in (6), the times spent for failed and successful transmissions. T ftx ,l depends on whether node n receives an s-ack. If so, n stops strobing, sends the data packet, and times out after Tout . Otherwise, n sends strobes for Tm . In either case, node n backs off for T b before retransmitting.</p><formula xml:id="formula_14">T ftx ,l = (Nit Tit + T d + Tout )p str ,l + Tm (1 -p str ,l ) + T b (12)</formula><p>Here, Nit = (Ton + T off )/(2 â€¢ Tit ) is the average number of strobe iterations before m possibly replies with an s-ack.</p><p>The time for a successful transmission T stx ,l includes the time to wait for the s-ack and to send the data packet. Node lifetime. We determine Dtx,n and Drx,n in <ref type="bibr" target="#b6">(7)</ref>, the fractions of time spent by the radio in transmit and receive mode. Both quantities depend on the rate F arx ,lc at which node n attempts to receive a packet from child c over link lc</p><formula xml:id="formula_15">T stx ,l = Nit â€¢ Tit + T d<label>(13)</label></formula><formula xml:id="formula_16">F arx ,lc = (N rtx ,lc + 1) â€¢ Ftx,c â€¢ p str ,lc<label>(14)</label></formula><p>where Ftx,c and p str ,lc are given by ( <ref type="formula" target="#formula_8">8</ref>) and <ref type="bibr" target="#b10">(11)</ref>.</p><p>We first consider Dtx,n. Node n transmits during packet receptions from child c (to send s-ack and d-ack) and during packet transmissions to its parent m (to send strobes and data packet). We define T rxt,lc and T txt,l as the average times spent by the radio in transmission mode during receptions over link lc and transmissions over link l <ref type="bibr" target="#b41">[42]</ref>.</p><formula xml:id="formula_17">Dtx,n = Ftx,n â€¢ T txt,l + câˆˆCn F arx ,lc â€¢ T rxt,lc<label>(15)</label></formula><p>Next we consider Drx,n. Node n is in receive mode during packet transmissions to its parent m (to receive s-ack and d-ack) and packet receptions from child c (to receive strobe and data packet). Let T txr ,l and T rxr ,lc be the average times spent by the radio in reception mode during transmissions over link l and receptions over link lc <ref type="bibr" target="#b41">[42]</ref>. The fraction of time in receive mode for actual communication is</p><formula xml:id="formula_18">Drxc,n = Ftx,n â€¢ T txr ,l + câˆˆCn F arx ,lc â€¢ T rxr ,lc<label>(16)</label></formula><p>In addition, n is in receive mode for Fcc = Ton /(Ton + T off ) during channel checks, which leads to</p><formula xml:id="formula_19">Drx,n = Drxc,n + (1 -Drxc,n) â€¢ Fcc (17)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Receiver-initiated: LPP</head><p>Fig. <ref type="figure" target="#fig_2">4</ref> shows a successful unicast transmission in LPP. Nodes periodically turn on their radio for T l and transmit a short probe 1 containing their own identifier. To send a packet, a node turns on its radio 2 and listens for a probe from the intended receiver 3 , for at most Ton . Then the sender transmits the data packet 4 , waits for the d-ack from the receiver 5 , and goes back to sleep 6 . After sending the d-ack, the receiver keeps the radio on until a timeout signals the end of the active phase 7 . Between two active phases nodes sleep for T off . To send a broadcast, the sender keeps its radio on for Tm = 2 â€¢ T l + T off to receive a probe from every neighbor, immediately replying to each received probe with the data packet. We let pTunes adapt the same set of LPP parameters c in (9) as for X-MAC (note that Ton has now a different meaning as explained above). Per-hop reliability. A single LPP unicast from node n to its parent m succeeds if n receives a probe from m (with probability p pr ,l ) and then successfully transmits the data packet (with probability p l ).</p><formula xml:id="formula_20">p s,l = p pr ,l â€¢ p l<label>(18)</label></formula><p>The probability that n receives a probe is given by</p><formula xml:id="formula_21">p pr ,l = 1 -(1 -p l ) k<label>(19)</label></formula><p>where k = (Ton -Tpr )/T is the number of possible probe receptions while node n listens for at most Ton . The term T = T l + T off + Trm /2 denotes the LPP duty cycle period, which is the sum of radio on-time, radio off-time, and a small random quantity with uniform distribution {0, . . . , Trm } to scatter probe transmissions.</p><p>Per-hop latency. We determine the time for a failed transmission. If node n receives a probe after waiting for T pw ,l , it sends the data packet and times out after Tout . Otherwise, n listens for Ton . Node n retransmits after backing off for T b .</p><formula xml:id="formula_22">T ftx ,l = (T pw ,l + T d + Tout )p pr ,l + Ton (1 -p pr ,l ) + T b (20)</formula><p>On average, node n receives a probe from its parent m after</p><formula xml:id="formula_23">T pw ,l = Tpr + k +1 i=1 pi â€¢ Ti (<label>21</label></formula><formula xml:id="formula_24">)</formula><p>where pi is the probability that n receives the i-th probe, and Ti is the expected time to await the i-th probe <ref type="bibr" target="#b41">[42]</ref>.</p><p>The time for a successful transmission includes the time to wait for a probe and to send the data packet.</p><formula xml:id="formula_25">T stx ,l = T pw ,l + T d (<label>22</label></formula><formula xml:id="formula_26">)</formula><p>Node lifetime. We determine the fractions of time in transmit and receive mode. Both depend on the rate F arx ,lc at which node n receives packets from child c over link lc</p><formula xml:id="formula_27">F arx ,lc = (N rtx ,lc + 1) â€¢ Ftx,c â€¢ p s,lc<label>(23)</label></formula><p>where Ftx,c and p s,lc are given by ( <ref type="formula" target="#formula_8">8</ref>) and <ref type="bibr" target="#b17">(18)</ref>.</p><p>Node n transmits a probe every duty cycle period T and sends d-acks to child c with frequency F arx ,lc . Further, n is in transmit mode for T txt,l to send packets to m <ref type="bibr" target="#b41">[42]</ref>.</p><formula xml:id="formula_28">Dtx,n = Tpr /T + T da câˆˆCn F arx ,lc + Ftx,n â€¢ T txt,l<label>(24)</label></formula><p>Node n is in receive mode when the radio is turned on but does not transmit probes or d-acks. Additionally, node n is in receive mode for T txr ,l during packet transmissions <ref type="bibr" target="#b41">[42]</ref>.</p><formula xml:id="formula_29">Drx,n = (T l -Tpr )/T -T da câˆˆCn F arx ,lc + Ftx,n â€¢ T txr ,l (25)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SYSTEM SUPPORT</head><p>pTunes must tackle several system-level challenges to obtain an efficient runtime operation. This section highlights these challenges and presents the system support we design to meet them. This includes a novel approach for collecting network state information and disseminating new MAC parameters, and the techniques and tools we use to solve the parameter optimization problem efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Challenges</head><p>Minimum disruption. pTunes must reduce the amount of disruption perceived by the application, particularly with respect to application data traffic, to avoid influencing its behavior beyond the adaptation of MAC parameters. This is in itself a major challenge in low-power wireless networks <ref type="bibr" target="#b9">[10]</ref>. Timeliness. Timely collection of accurate network state, computation of optimized MAC parameters, and their reliable and rapid dissemination are fundamental to pTunes.</p><p>Only this way pTunes can provide MAC operating parameters that do match the current network state. However, it is difficult to perform the above operations in a timely manner, especially when involving resource-constrained devices. Consistency. pTunes requires consistent snapshots of network state, possibly captured by all nodes at the same time. Otherwise, optimizing MAC parameters based on information different from the actual network conditions may even negatively affect the system performance. Coordinating distributed sensor nodes to achieve consistency is challenging, given their bandwidth and energy limitations. Energy efficiency. pTunes must meet all the previous challenges while introducing only a limited, possibly predictable, energy overhead at the sensor nodes. To be viable, the overhead of pTunes must not outweigh the gains obtained from adapting the MAC parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Collection and Dissemination</head><p>pTunes uses Glossy network floods <ref type="bibr" target="#b15">[16]</ref> to collect network state information and disseminate MAC parameters. In particular, pTunes exploits Glossy's time synchronization service to schedule and execute both operations within short time frames, repeated every collection period Tc. Every frame starts with a Glossy flood initiated by the sink, which serves to time-synchronize the nodes and disseminate new MAC parameters. Following the initial flood by the sink, each of the other nodes initiates a flood in turn within exclusive slots, reporting network state for the subsequent trigger decision and parameter optimization.</p><p>The collection period Tc can range from a few tens of seconds to several minutes depending on network dynamics and application needs, and represents a trade-off between the energy overhead of pTunes and its responsiveness to changes in the network: a shorter Tc permits more frequent parameter updates but increases the energy consumption of the nodes. The efficiency of Glossy allows us to limit the length of the periodic collection and dissemination frames, thus keeping the energy overhead to a minimum. For instance, we measure on a 44-node testbed an average duration of 5.2 ms for a single flood, and an average radio duty cycle of 0.35 % due to pTunes collection and dissemination for Tc = 1 min, which reduces to about 0.07 % for Tc = 5 min. Given that state-of-the-art low-power MAC protocols exhibit duty cycles of 3-7 % in testbed settings comparable to ours <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b17">18]</ref>, the energy overhead of pTunes is marginal.</p><p>An alternative to our approach may be to piggyback network state on application packets and to use a variant of Trickle <ref type="bibr" target="#b24">[25]</ref> to disseminate MAC parameters. We employed this approach at an early stage of this work, but found it inadequate for our purposes. For instance, running Trickle concurrently with data collection increases contention, especially during parameter updates, which degrades application data yield <ref type="bibr" target="#b9">[10]</ref>. Moreover, piggybacking on data packets induces a dependency on the rate and reliability of application traffic. In low-rate applications, it may take a very long time until network state from all nodes becomes available for optimization. Packets may also be generated at different times and experience varying end-to-end delays (e.g., due to contention or routing loops), so the collected network state is likely to be out-of-date and inconsistent. Our approach avoids these problems by temporally decoupling collection and dissemination from application tasks, and by leveraging consistent network state snapshots taken with microsecond accuracy at all nodes independently of application traffic.</p><p>In particular, pTunes collects three pieces of network state from each node: (i) the node id and the id of the routing parent, to allow pTunes to learn about the current routing tree (N , M, L); (ii) the number of packets generated per second Fn, allowing pTunes to determine the traffic volumes; and (iii) the ratio H s,l /H t,l of successful and total number of link-layer handshakes over link l to the routing parent. There are two handshakes in X-MAC, strobe/s-ack and data/d-ack; LPP features only the latter (see Figs. <ref type="figure" target="#fig_1">3</ref> and<ref type="figure" target="#fig_2">4</ref>). To account for parent switches and link dynamics, a node maintains counters H s,l and H t,l in a way similar to an exponentially weighted moving average (EWMA). Based on their ratio received from each node and by taking the square root, pTunes obtains estimates of the probability of successful transmission p l of all links in the current routing tree. The collected information totals 6 bytes per node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Optimization Tools</head><p>Applying the optimization problem in (1) to our X-MAC and LPP models in Sec. 3 leads to a mixed-integer nonlinear program (MINLP) with non-convex objective and constraint functions. To solve it efficiently, we use the ECL i PS e constraint programming system <ref type="bibr" target="#b0">[1]</ref>. Its high-level programming paradigm allows for a succinct modeling of our optimization problem. We use modules to separate protocol-independent from protocol-dependent code; the latter amounts to about 100 lines for each X-MAC and LPP.</p><p>We use the branch-and-bound algorithm coupled with a complete search routine, both provided by the interval constraint (IC) solver of ECL i PS e . The running time of the optimization depends to a large extent on the size of the search space. To reduce it, we exploit the fact that MAC protocols are commonly implemented using hardware timers. The resolution of these timers determines the maximum required granularity of the MAC timing parameters. We therefore discretize the domains of Ton and T off considered for adaptation, letting ECL i PS e determine values with millisecond granularity. Based on the literature and our own experience, we set the upper bounds of N and T off to 10 retransmissions and 1 s; Ton is chosen such that a node listens long enough to overlap with exactly one receiver wake-up in LPP, and with at least one but not more than three strobe transmissions in X-MAC. For these settings and in the scenarios we tested, representative of a large fraction of deployed sensor networks, ECL i PS e finds optimized MAC parameters within a few tens of seconds on a standard laptop computer. Compared with our current approach, which leverages generalpurpose algorithms and off-the-shelf implementations, dedicated solution techniques and implementations are likely to improve significantly on this figure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IMPLEMENTATION DETAILS</head><p>On the sensor nodes, we use Contiki 2.3. We extended the existing X-MAC implementation with link-layer retransmissions and an interface to adjust the parameters in (9) at runtime. Since the existing LPP implementation suffered from performance problems that could bias our results, we re-implemented LPP within the Contiki stack and extended it in the same way as X-MAC. For data collection we use Contiki Collect, which maintains a tree-based routing topology using expected transmissions (ETX) as cost metric.</p><p>The pTunes control application running on the base station is implemented in Java. It retrieves collected network state from the sink, starts the optimization process depending on the trigger decision, and transfers new MAC parameters back to the sink for dissemination.</p><p>An important decision for pTunes is when to trigger the parameter optimization. In general, we want to optimize as often as possible to make the MAC parameters closely match the network state. At the same time, we want to minimize the energy overhead for collection and dissemination, and need to consider that running the solver takes time. Therefore, pTunes provides three basic optimization triggers to decide when to start the solver. Nevertheless, pTunes users can implement their own application-specific triggers using a set of basic interfaces we provide.</p><p>Among the triggers we provide, TimedTrigger optimizes periodically, where the period is typically a multiple of the collection period Tc. In this way, a TimedTrigger may launch the solver immediately after the collection of network state, and pTunes floods the new MAC parameters at the next dissemination. Nevertheless, depending on application-specific requirements and performance goals, users may also combine a TimedTrigger with one of the following two triggers.</p><p>A ConstraintTrigger uses the model to estimate the current network performance based on the collected network state, and launches the solver only if any of the constraints in (1) is violated. A ConstraintTrigger may be implemented to tolerate short-term violations of a constraint, or a violation within some threshold around the constraint. Alternatively, a NetworkStateTrigger can infer directly from the network state if the MAC parameters should be updated. For example, a NetworkStateTrigger may fire if it detects a significant increase in traffic volume, thus starting the solver to find MAC parameters that provide higher bandwidth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTAL RESULTS</head><p>This section uses measurements from a 44-node testbed to study both the effectiveness of pTunes and the interactions of MAC parameter adaptation with the routing protocol. Our experiments reveal the following key findings: â€¢ Validation against measurements shows that our X-MAC and LPP models are highly accurate. â€¢ pTunes automatically determines MAC parameters that provide higher bandwidth when the traffic load increases. This avoids the occurrence of queuing until the network capacity attainable in our setting is fully exhausted. â€¢ In the scenarios we tested, pTunes achieves up to threefold lifetime gains over static MAC parameters optimized for peak traffic volumes. â€¢ In a scenario where the packet rates vary across nodes and fluctuate over time, pTunes satisfies given end-toend latency and reliability requirements at peak traffic while extending the network lifetime at relaxed traffic. â€¢ During phases of controlled wireless interference, pTunes reduces packet loss by 80 % compared to static MAC parameters optimized for the applied traffic without interference, satisfying given end-to-end reliability requirements. â€¢ pTunes helps the routing protocol recover from critical network changes, reducing the number of parent switches and settling quickly on a stable routing topology. This reduces packet loss by 70% in a scenario where multiple core routing nodes fail simultaneously. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Setting and Metrics</head><p>Testbed. Our testbed spans one floor in an ETH building <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14]</ref>. Fig. <ref type="figure" target="#fig_3">5</ref> shows the positions of the 44 Tmote Sky nodes distributed in several offices, passages, and storerooms; two nodes are located outside on the rooftop. The sink is connected to a laptop computer that acts as the base station. Paths between nodes and sink are between 1 to 5 hops in length. Nodes transmit at the highest power setting, using channel 26 to limit the interference with co-located WiFi. Metrics. Our evaluation uses the metrics defined in Sec. 3.1.</p><p>To measure network lifetime, we use Contiki's energy profiler to obtain the fractions of time the radio is in receive, transmit, and idle mode. Then, we compute projected node lifetimes using <ref type="bibr" target="#b6">(7)</ref> and current draws from the CC2420 data sheet, assuming batteries constantly supply 2000 mAh at 3 V. When pTunes is enabled, the measured network lifetime includes the energy overhead of pTunes collection and dissemination, performed every Tc = 1 min in all experiments. We measure end-to-end reliability based on sequence numbers of data packets received at the sink. To measure end-to-end latency, we exploit Glossy's time synchronization service and timestamp data packets at the source.</p><p>Requirements. We consider typical requirements of realworld data collection applications: maximize network lifetime while providing a certain end-to-end reliability <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b36">37]</ref>.</p><p>We also enforce a constraint on end-to-end latency, accounting for applications that require timely delivery <ref type="bibr" target="#b7">[8]</ref>.</p><p>Maximize</p><formula xml:id="formula_30">T (c) Subject to R(c) â‰¥ 95 % and L(c) â‰¤ 1 s (<label>26</label></formula><formula xml:id="formula_31">)</formula><p>pTunes solves (26) at runtime to determine optimized MAC parameters. If there exists no solution because either constraint in ( <ref type="formula" target="#formula_30">26</ref>) is unsatisfiable (e.g., due to extremely low link qualities), pTunes maximizes R without constraints. This policy serves to exemplify the capabilities of pTunes; other application-specific policies can be implemented within the pTunes optimization triggers.</p><p>Methodology. We compare pTunes with several static MAC configurations optimized for a variety of different workloads and application requirements, as listed in Table <ref type="table" target="#tab_2">2</ref>. We found these MAC configurations using pTunes and extensive experiments on our testbed. Existing MAC adaptation approaches, on the other hand, consider only per-link and per-node metrics <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b30">31]</ref> or focus solely on energy <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b27">28]</ref>, rendering the comparison against pTunes purposeless.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Model Validation</head><p>Before evaluating pTunes under traffic fluctuations, wireless interference, and node failures, we validate our models and assumptions from Sec. 3 on real nodes. Scenario. We run experiments in which we let pTunes periodically estimate the application-level metrics based on the collected network state, and compare the model estimation e(Mi) against the actual measurement m(Mi) by computing the absolute model error Î´(Mi) = m(Mi) -e(Mi) for each metric Mi âˆˆ {R, L, T }. Using Î´ we assess the model accuracy depending on MAC configuration and network state.</p><p>To evaluate the dependency on the former, we use three static MAC configurations for each protocol (S1-S3 and S7-S9 in Table <ref type="table" target="#tab_2">2</ref>). We also perform one run with pTunes enabled, using a TimedTrigger to adapt the MAC parameters every 10 min. To evaluate the dependency on network state, in each run we progressively decrease the inter-packet interval (IPI) at all nodes, from 300 s to 180, 60, 30, 20, 10, 5, and 2 s. In this way, we also validate our models against different probabilities of successful transmission p l : a shorter IPI increases contention and thus lowers the link success rates. We conduct repeatable experiments by enforcing the same static routing topology across all runs. Results. Table <ref type="table" target="#tab_4">3</ref> lists average model errors in R, L, and T for X-MAC and LPP. We see that both models are highly accurate in all metrics. For example, with pTunes enabled, our LPP models estimate R, L, and T with average absolute errors of 0.41 %, 0.08 s, and -0.73 days. Note that node dwell times, which are included in the measurements but ignored in the model of L, introduce only a negligible error since pTunes aims at avoiding packet queuing, as explained next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Impact on Bandwidth and Queuing</head><p>Based on the experiments above, we study also the impact of the MAC configuration on bandwidth and local packet queuing. To this end, we analyze queuing statistics collected from the nodes and the goodput measured at the sink (application packets carry 69 bytes of data). Results. Fig. <ref type="figure">6</ref> plots total queue overflows and goodput for X-MAC as the IPI decreases. We can see from Fig. <ref type="figure">6(a)</ref> that pTunes avoids queue overflows up to IPI = 2 s, whereas S1-S3 fail to prevent overflows already at longer IPIs. The increasing traffic requires more and more bandwidth, leading to local packet queuing and ultimately to queue overflows when the bandwidth becomes insufficient. Unlike S1-S3, pTunes tolerates such increasing bandwidth demands by automatically adjusting the MAC parameters to provide higher bandwidth. By doing so, pTunes avoids the occurrence of queuing until even the MAC parameters providing   (b) Goodput. Figure <ref type="figure">6</ref>: Queue overflows across all nodes and goodput at the sink with X-MAC as the traffic increases, using pTunes and three static MAC configurations. pTunes triples the goodput and avoids the occurrence of local packet queuing until the network capacity is fully exhausted.</p><p>the highest bandwidth (S6 in Table <ref type="table" target="#tab_2">2</ref>), based on the settings and X-MAC implementation we use, are insufficient. This is also confirmed by looking at the goodput, shown in Fig. <ref type="figure">6(b)</ref>. First, we note that pTunes achieves a more than three-fold increase in goodput over S1-S3 at IPI = 5 s. When queuing occurs also with pTunes at IPI = 2 s, goodput drops from 4.6 kbps to 3.1 kbps because increased contention leads to more transmission failures and queue overflows. This confirms that the network capacity is fully exhausted at this point. To keep satisfying the requirements in such situations, an application needs to employ higher-layer mechanisms, such as a rate-controlled transport layer that reduces the transmission rate in response to congestion <ref type="bibr" target="#b29">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Lifetime Gain</head><p>In real deployments, it is common practice to overprovision the MAC parameters based on the highest expected traffic load <ref type="bibr" target="#b22">[23]</ref>. The goal is to provide sufficient bandwidth during periods of peak traffic, for example, when an important event causes nodes to temporarily generate more sensor data. However, because such traffic peaks are usually rare and short compared to the total system lifetime, overprovisioning results in a significant waste of resources <ref type="bibr" target="#b23">[24]</ref>. We now analyze how pTunes helps alleviate this problem. Scenario. We conduct two experiments in which nodes gradually increase the IPI from 10 s to 20 s, 30 s, 60 s, 3 min, 5 min, and 20 min. In the first experiment, we use pTunes exactly once at the very beginning to determine MAC parameters optimized for the initial IPI of 10 s, and then keep this overprovisioned MAC configuration until the end of the experiment. In the second experiment, we let pTunes adapt the MAC parameters, using a TimedTrigger with a period of 10 min; pTunes maximizes T subject to R â‰¥ 95 % and no constraint on L. We enforce the same static routing topology in both experiments to factor out effects related to routing topology changes, an aspect we consider in Secs. 6.5 and 6.7. We then compute the lifetime gain as the ratio between the measured network lifetime with and without pTunes. Results. Table <ref type="table">4</ref>: Lifetime gains of pTunes over static MAC parameters optimized for peak traffic depending on baseline traffic and fraction of time at peak traffic. pTunes achieves up to three-fold lifetime gains in settings with extremely rare traffic peaks and low baseline traffic.</p><p>semination phases. We see that the lifetime gain achieved by pTunes increases as (i) the system spends less time at peak traffic (75-0 % from top to bottom), and (ii) the difference between the shortest, overprovisioned IPI of 10 s and the longest, baseline IPI increases (1-20 min from left to right).</p><p>For instance, for a baseline traffic at IPI = 20 min and extremely rare traffic peaks at IPI = 10 s, the lifetime gain is close to 2.77 for X-MAC and close to 3.11 for LPP compared to static MAC parameters overprovisioned for peak traffic. The above experimental results reveal that pTunes enables significant lifetime gains, not least due to its energyefficient system support (see Sec. 4). The following sections examine how pTunes trades possible gains in network lifetime for satisfying end-to-end reliability and latency requirements under varying network conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Adaptation to Traffic Fluctuations</head><p>Traffic fluctuations are characteristic of many sensor network applications, where the data rate often depends on time-varying external stimuli. The following experiments investigate the benefits pTunes brings to these applications. Scenario. All nodes send packets with IPI = 5 min for 5 h. However, during two periods of 30 min each, two clusters of 10 and 5 spatially close nodes (14-23 and 40-44 in Fig. <ref type="figure" target="#fig_3">5</ref>) send packets with IPI = 10 s, emulating the detection of an important event that deserves reporting more sensor data.</p><p>We run three experiments with X-MAC and dynamic routing using Contiki Collect. In the first two experiments, we use static MAC configurations S1 and S5: S1 provides high bandwidth when nodes send more packets, and S5 extends network lifetime at normal traffic (see Table <ref type="table" target="#tab_2">2</ref>). In the third experiment, we let pTunes adapt the MAC parameters according to <ref type="bibr" target="#b25">(26)</ref>. We couple a TimedTrigger with a Network-StateTrigger as follows. When nodes transmit at low rate, the TimedTrigger starts the solver every 10 min. As soon as the NetworkStateTrigger detects the beginning a traffic peak, it starts the solver immediately and adapts the period of the TimedTrigger to 5 min, setting it back to 10 min at the end of a peak. In this way, pTunes reacts promptly to traffic changes, and adapts more frequently during traffic peaks when nodes report important sensor data. Results. Fig. <ref type="figure" target="#fig_6">7</ref> plots performance over time in the three experiments. We see that S5 approximately satisfies the reliability and latency requirements when nodes send at low rate, achieving also a high projected network lifetime. However, as soon as the two node clusters start transmitting at high rate, reliability drops significantly below 75 %. This is because S5 does not provide sufficient bandwidth, leading to high contention and ultimately to packet loss. Similarly, S5 violates the latency requirement during traffic peaks, making L exceed 2 s due to queuing and retransmission delays.  S1, instead, provides sufficient bandwidth and satisfies the end-to-end requirements. However, network lifetime is always below 30 days: the higher bandwidth comes at a huge energy cost, paid also when a lower bandwidth would suffice.</p><p>By contrast, pTunes satisfies the end-to-end requirements under high and low rate. Moreover, when nodes transmit at low rate, the projected network lifetime increases up to 90 days. By adapting the MAC parameters, pTunes always provides a bandwidth sufficient to satisfy the end-to-end requirements without sacrificing lifetime unnecessarily: at the beginning of a traffic peak, pTunes reduces T off from about 300 ms to 120 ms (and slightly adapts Ton and N ), which explains why reliability stays up and latency is halved. Static MAC configurations lack this flexibility; they can only be optimized for a specific workload and thus fail to trade the performance metrics as the traffic conditions change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Adaptation to Changes in Link Quality</head><p>Unpredictable changes in link quality are characteristic of low-power wireless <ref type="bibr" target="#b40">[41]</ref>. Adapting the MAC parameters to these changes is important but non-trivial, as we show next. Scenario. We use the technique by Boano et al. to generate controllable interference patterns <ref type="bibr" target="#b3">[4]</ref>, making the link quality fluctuate in a repeatable manner. To this end, we deploy an additional interferer node in a position where it affects the communication links of at least one fourth of the nodes in our testbed, as shown in Fig. <ref type="figure" target="#fig_3">5</ref>. When active, the interferer transmits a modulated carrier on channel 26 for 1 ms at the highest power setting. Then, it sets the radio to idle mode for 10 ms before transmitting the next carrier.</p><p>All nodes generate packets with IPI = 30 s for 4 h. The interferer is active during two periods of 1 h each. In a first experiment, we use static MAC configuration S4, optimized for IPI = 30 s (see Table <ref type="table" target="#tab_2">2</ref>). We enable pTunes in a second  experiment, using a TimedTrigger with a period of 1 min to adapt the MAC parameters according to <ref type="bibr" target="#b25">(26)</ref>. We deliberately enforce a static routing tree to separate effects related to link quality changes from those related to topology changes. We investigate the latter in detail in Sec. 6.7. Results. Fig. <ref type="figure" target="#fig_8">8</ref> shows end-to-end reliability and the trace of X-MAC parameters. Looking at Fig. <ref type="figure" target="#fig_8">8</ref>(a), we see that S4 and pTunes satisfy the reliability requirement when the interferer is off. When the interferer is on, reliability starts to drop below 95 %. However, as soon as pTunes collects network state, it detects a decrease in link quality and adapts the X-MAC parameters accordingly. In particular, as shown in Fig. <ref type="figure" target="#fig_8">8</ref>(b), pTunes increases N from 3 or 4 to values between 6 and 10. Ton is also increased (from 6 ms to 10-16 ms) to further help satisfy the reliability requirement. Moreover, pTunes decreases T off (from 100 ms to 20-90 ms) to provide more bandwidth and combat increased channel contention, which is a consequence of numerous retransmission attempts over low-quality links. Indeed, these low-quality links make <ref type="bibr" target="#b25">(26)</ref> temporarily unsatisfiable (while Ton = 16 ms in the first interference phase), triggering pTunes to instead maximize R as explained in Sec. 6.1. As a result of these decisions, pTunes achieves an average end-to-end reliability of 95.4 % also in presence of interference.</p><p>S4, instead, fails to satisfy the reliability requirement when the interferer is active: reliability ranges between 70 % and 80 %, and never recovers while the interferer is on. In total, 2252 packets are lost with S4 during interference. pTunes reduces this number to 418-a reduction of more than 80 %.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7">Interaction with Routing</head><p>Several studies emphasize the significance of cross-layer interactions to the overall system performance <ref type="bibr" target="#b11">[12]</ref>. We study this aspect between best-effort tree routing and parameter  adaptation of an underlying low-power MAC protocol with pTunes. To do so, during each of the following experiments, we temporarily remove multiple core routing nodes important for forwarding packets. In this way, we emulate node failures, which are common in deployed systems <ref type="bibr" target="#b1">[2]</ref>, and force the routing protocol to find new routes. Scenario. We run two 4-hour experiments with Contiki Collect and X-MAC. After 30 min, we turn off eight nodes within the sink's neighborhood that forward most packets in the network (1-8 in Fig. <ref type="figure" target="#fig_3">5</ref>). We turn them on again after 60 min, and repeat the on-off pattern after 1 h. Nodes generate packets with IPI = 30 s. In the first experiment, we use static MAC configuration S4, optimized for this traffic load (see Table <ref type="table" target="#tab_2">2</ref>). In the second experiment, we enable pTunes and use a TimedTrigger to solve (26) every minute. Results. Fig. <ref type="figure" target="#fig_10">9</ref>(a) shows end-to-end reliability over time, accounting for packets from nodes that are currently turned on. During the first 30 min, both S4 and pTunes satisfy the reliability requirement. However, when nodes are removed, reliability starts to drop below 70 %. Many packets are indeed lost since children of removed nodes fail to transmit packets: the routing protocol needs to find new routes.</p><p>We see from Fig. <ref type="figure" target="#fig_10">9</ref>(a) that end-to-end reliability recovers much faster when pTunes is enabled. During the two periods when eight nodes are removed, S4 fails to deliver in total 2673 packets from the remaining 35 nodes. pTunes reduces this number to 813-a reduction of 70 %.</p><p>To further investigate this behavior, we plot in Fig. <ref type="figure" target="#fig_10">9</ref>(b) the distribution of parent switches. pTunes reduces the total number of parent switches compared to S4 (from 631 to 165), and shifts them to the beginning of the periods in which nodes are removed. At this point, pTunes quickly realizes a significant drop in link quality, reported by nodes whose parent disappeared. pTunes thus increases Ton and N to improve reliability, and decreases T off to provide more bandwidth for retransmissions and route discovery.</p><p>As a result of increasing the maximum number of retransmissions per packet N , transmission attempts of nodes with a dead parent fail with a higher number of retries. This causes the corresponding ETX values to drop more severely than with S4 (which has a lower N ), and so nodes switch much faster to a new parent. Moreover, the MAC parameters provided by pTunes help deliver packets over the remaining links. Delivering more packets also enables the routing protocol to quickly detect route inconsistencies and eventually settle on a stable topology. As the topology stabilizes, pTunes gradually relaxes the MAC parameters (reduce Ton and N , increase T off ) to extend network lifetime.</p><p>These results demonstrate that, by adapting the MAC parameters, pTunes helps the routing protocol recover faster from critical network changes. Protocols like CTP <ref type="bibr" target="#b17">[18]</ref> and Arbutus <ref type="bibr" target="#b32">[33]</ref> also utilize feedback from unicast transmissions to compute the ETX. In addition, CTP uses data path validation to detect possible loops based on ETX values embedded in data packets <ref type="bibr" target="#b17">[18]</ref>. Our findings with Contiki Collect, which uses similar techniques, suggest that these protocols could also benefit from pTunes.</p><p>Additionally, the results demonstrate the advantage of decoupling network state collection from application packet routing, we argue in Sec. 4.2. As long as the network remains connected, Glossy provides up-to-date network state to the base station with very high reliability <ref type="bibr" target="#b15">[16]</ref>. Changes in the routing tree do no affect network flooding: information about faulty links is collected even when the routing protocol fails to deliver packets from nodes whose parent died, allowing pTunes to react promptly and thus effectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">DISCUSSION</head><p>Designing a MAC adaptation framework involves striking a balance between goals typically at odds with each other. We discuss in this section some of the trade-offs we make in pTunes and the implications of our particular choices. Feasibility vs. scalability. We adopt a centralized approach rather than a likely more scalable distributed solution; in return for this, pTunes allows users to express their requirements in terms of network-wide metrics, which better reflect the way domain experts are used to state performance objectives compared to per-node or per-link metrics. In fact, distributing the tasks of collecting global state information, computing MAC parameters optimized for network-wide objectives, and coordinating the consistent installation of new parameters would hardly be feasible, if at all, on resourceconstrained devices. Instead, pTunes exploits the better resources of a central base station, which is already present in many sensor network deployments <ref type="bibr" target="#b33">[34]</ref>, and achieves simplicity of in-network functionality by moving most of its intelligence out of the nodes and into the base station. Flexibility vs. optimality. We focus on existing MAC protocols rather than on the design or adaptation of crosslayer solutions (e.g., coupling link and network layer) which may, in principle, achieve better performance; in return for this, pTunes allows system designers to choose the MAC and routing protocol independently from existing code bases. In comparison, cross-layer solutions tend to enjoy little generality and flexibility, as they are often designed for very specific scenarios (e.g., periodic, low-rate data collection <ref type="bibr" target="#b5">[6]</ref>). Robustness vs. optimality. We determine network-wide parameters rather than per-node parameters, which may better match the current role of a node in the routing tree (e.g., with respect to traffic load); in return for this, the parameters pTunes provides are much more robust to changes in the routing topology. It is not unlikely that, even in the most benign environment, slight variations in the link qual-ities trigger drastic changes in the routing topology. For instance, Ceriotti et al. observe that nodes serving many children suddenly become leaves in the routing tree <ref type="bibr" target="#b6">[7]</ref>. In such a case, per-node MAC parameters become inappropriate and must be quickly updated. Similar situations can happen frequently, even several times per minute <ref type="bibr" target="#b18">[19]</ref>, which would render per-node parameter adaptation impractical.</p><p>As a consequence of the design decisions above, pTunes represents one particular point in a multi-dimensional design space. Corresponding to this point is a large fraction of deployed low-power wireless networks comprising tens of nodes, leveraging protocols such as X-MAC and LPP, and yet failing to meet the application requirements often due to communication issues ultimately related to inadequate MAC parameter choices and lack of adaptiveness <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b33">34]</ref>. pTunes is directly and immediately applicable in these settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>pTunes uses a model to predict how changes in the MAC parameters affect the network-wide performance given the current network state. Based on iterative runtime optimization, it selects MAC parameters such that the predicted performance satisfies the application requirements. This approach is similar to the concept of model predictive control (MPC) <ref type="bibr" target="#b16">[17]</ref>, with the differences that pTunes computes only the next step of the control law and uses no information about past control steps or measured system responses.</p><p>Several recent systems incorporate centralized control in their design, much like pTunes does. For example, Koala implements a network-wide routing control plane, where the base station computes end-to-end paths used for packet forwarding <ref type="bibr" target="#b28">[29]</ref>. RACNet uses centralized token passing to sequence data downloads <ref type="bibr" target="#b25">[26]</ref>. In RCRT, the sink detects congestion and adapts the rates of individual sources <ref type="bibr" target="#b29">[30]</ref>. PIP determines schedule and channel assignment for each flow centrally at the base station <ref type="bibr" target="#b34">[35]</ref>. Like pTunes, these systems exploit global knowledge and ample resources of the base station to achieve high performance and manageability.</p><p>Looking at the large body of prior work on adaptive lowpower MAC protocols, we find solutions embedding adaptivity or separating adaptivity from the protocol operation.</p><p>In the former category, for instance, Woo and Culler propose an adaptive rate control mechanism, where nodes inject more packets if previous attempts were successful and fewer packets if they failed <ref type="bibr" target="#b38">[39]</ref>. Van Dam and Langendoen introduce an adaptive listen period in T-MAC <ref type="bibr" target="#b10">[11]</ref> to overcome the drawbacks of the fixed duty cycle of S-MAC <ref type="bibr" target="#b39">[40]</ref>. El-Hoiydi and Decotignie adapt radio wake-ups in WiseMAC to shorten the LPL preamble <ref type="bibr" target="#b14">[15]</ref>. More recently, Hurni and Braun propose MaxMAC, which schedules additional X-MAC wake-ups at medium traffic and switches to pure CSMA at high traffic <ref type="bibr" target="#b20">[21]</ref>. Such hard-coded adaptivity mechanisms can be highly effective in specific scenarios, but lack general applicability and bear no direct connection to the high-level application demands. pTunes is more general by adding parameter adaptation atop existing MAC protocols, thus leveraging available implementations, and by explicitly incorporating user-provided application requirements.</p><p>Polastre et al. instead separate adaptivity from the protocol operation and present a model of node lifetime for B-MAC <ref type="bibr" target="#b31">[32]</ref>. Jurdak et al. use this model to dynamically recompute check interval and preamble length, showing substantial energy savings <ref type="bibr" target="#b21">[22]</ref>. Buettner et al. demonstrate en-ergy savings in X-MAC by adapting the wake-up interval to traffic load for one sender-receiver pair <ref type="bibr" target="#b4">[5]</ref>. Meier et al. <ref type="bibr" target="#b27">[28]</ref> and Challen et al. <ref type="bibr" target="#b8">[9]</ref> extend network lifetime by adjusting the wake-up interval to traffic load in a static routing tree. Park et al. present numerical results that indicate the potential of adaptation policies for IEEE 802.15.4 MAC protocols, based on per-link and per-node metrics <ref type="bibr" target="#b30">[31]</ref>. pTunes builds on these foundations but extends them in several ways. First, pTunes considers multiple network-wide metrics and adapts multiple MAC parameters. Second, our modeling is more realistic by accounting for packet loss and ARQ mechanisms, and more flexible by isolating protocoldependent from protocol-independent functionality. Third, we evaluate pTunes in real-world scenarios, including dynamic routing trees, wireless interference, and node failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSIONS</head><p>pTunes provides runtime parameter adaptation for lowpower MAC protocols, automatically translating applicationlevel requirements into MAC parameters that meet these requirements and achieve very good performance across a variety of scenarios, ranging from low traffic to high traffic, from good links to bad links, and wireless interference to node failures. pTunes thus greatly aids in meeting the requirements of real-world sensor network applications by eliminating the need for time-consuming, and yet error-prone, manual MAC configuration when the network conditions change.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The pTunes framework.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Unicast transmission in X-MAC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Unicast transmission in LPP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Testbed layout. Nodes 31 and 32 are located outside on the rooftop; the interferer is only used in Sec. 6.6.</figDesc><graphic coords="7,316.81,53.80,264.84,162.14" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>End-to-end reliability, R â‰¥ 95 %. End-to-end latency, L â‰¤ 1 s. Projected network lifetime.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Performance of pTunes against two static MAC configurations as the traffic volume changes. pTunes satisfies the end-to-end requirements at high traffic while extending network lifetime at low traffic. Static MAC parameters optimized for a specific traffic load fail to meet the application requirements as the traffic conditions change.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>End-to-end reliability, R â‰¥ 95 %. Trace of X-MAC parameters.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>End-to-end reliability and trace of X-MAC parameters as the link quality changes. pTunes reduces packet loss by 80 % during periods of controlled wireless interference in comparison with static MAC parameters optimized for the applied traffic load without interference.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>End-to-end reliability, R â‰¥ 95 %. Distribution of parent switches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>End-to-end reliability and distribution of parent switches when eight core routing nodes fail simultaneously. pTunes helps the routing protocol recover from node failures by settling quickly on a stable routing topology, thus reducing packet loss by 70 % compared with static MAC parameters optimized for the applied traffic load.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Static MAC configurations optimized for different performance trade-offs and workloads.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Average absolute errors of the networkwide performance model in testbed experiments, with pTunes and six static MAC configurations. Our X-MAC and LPP models are highly accurate in all metrics.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Table 4 lists lifetime gains for X-MAC and LPP, including the energy overhead of pTunes collection and dis-</figDesc><table><row><cell>Fraction of time</cell><cell></cell><cell cols="2">X-MAC</cell><cell></cell><cell></cell><cell cols="2">LPP</cell><cell></cell></row><row><cell>at peak traffic</cell><cell cols="4">Baseline IPI [min]</cell><cell cols="4">Baseline IPI [min]</cell></row><row><cell>(IPI = 10 s)</cell><cell>1</cell><cell>3</cell><cell>5</cell><cell>20</cell><cell>1</cell><cell>3</cell><cell>5</cell><cell>20</cell></row><row><cell>75%</cell><cell cols="8">1.05 1.17 1.24 1.43 1.14 1.27 1.35 1.57</cell></row><row><cell>50%</cell><cell cols="8">1.14 1.36 1.50 1.88 1.24 1.50 1.65 2.08</cell></row><row><cell>25%</cell><cell cols="8">1.21 1.55 1.75 2.33 1.33 1.72 1.95 2.60</cell></row><row><cell>0%</cell><cell cols="8">1.29 1.74 2.01 2.77 1.42 1.94 2.24 3.11</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. The authors thank Renato lo Cigno, Kay RÃ¶mer, Olga Saukh, and the anonymous reviewers for their insightful comments. This work was supported by Nano-Tera, the National Competence Center in Research on Mobile Information and Communication Systems under SNSF grant number 5005-67322, the Swedish Foundation for Strategic Research, and the Cooperating Objects Network of Excellence under contract number EU-FP7-2007-2-224053.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Constraint Logic Programming using Eclipse</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Wallace</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">PermaDAQ: A scientific instrument for precision sensing and data recovery under extreme conditions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Beutel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE IPSN</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Poster abstract: The FlockLab testbed architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>Beutel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Making sensornet MAC protocols robust against interference</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Boano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tsiftes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mottola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>RÃ¶mer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zuniga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EWSN</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">X-MAC: A short preamble MAC protocol for duty-cycled wireless sensor networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Buettner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">V</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Dozer: Ultra-low power data gathering in sensor networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Burri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rickenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE IPSN</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Monitoring heritage buildings with wireless sensor networks: The Torre Aquila deployment</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ceriotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE IPSN</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Is there light at the ends of the tunnel? Wireless sensor networks for adaptive lighting in road tunnels</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ceriotti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE IPSN</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">IDEA: Integrated distributed energy awareness for wireless sensor networks</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">W</forename><surname>Challen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MobiSys</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The case for a network protocol isolation layer</title>
		<author>
			<persName><forename type="first">J</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kazandjieva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An adaptive energy-efficient MAC protocol for wireless sensor networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Langendoen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Performance comparison of two on-demand routing protocols for ad hoc networks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Royer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design and evaluation of a versatile and efficient receiver-initiated link layer for low-power wireless</title>
		<author>
			<persName><forename type="first">P</forename><surname>Dutta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dawson-Haggerty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Terzis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Deployment support network: A toolkit for the development of WSNs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EWSN</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">WiseMAC: An ultra low power MAC protocol for multi-hop wireless sensor networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>El-Hoiydi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-D</forename><surname>Decotignie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ALGOSENSORS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficient network flooding and time synchronization with Glossy</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zimmerling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Saukh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE IPSN</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Model predictive control: Theory and practice-a survey</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>GarciÃ¡</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Prett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Morari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automatica</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Collection tree protocol</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gnawali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jamieson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A case for evaluating sensor network protocols concurrently</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gnawali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Guibas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM WiNTECH</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On a bicriterion formulation of the problems of integrated system identification and system optimization</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">Y</forename><surname>Haimes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">S</forename><surname>Lasdon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wismer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Syst., Man, Cybern</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">MaxMAC: A maximally traffic-adaptive MAC protocol for wireless sensor networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hurni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Braun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EWSN</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Adaptive low power listening for wireless sensor networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jurdak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Baldi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Lopes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Mobile Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Medium access control facing the reality of WSN deployments</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kuntz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gallais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Noel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Comp. Comm. Rev</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Analyzing MAC protocols for low data-rate applications</title>
		<author>
			<persName><forename type="first">K</forename><surname>Langendoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Meier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Sens. Netw</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Trickle: A self-regulating algorithm for code propagation and maintenance in wireless sensor networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Levis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX NSDI</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">RACNet: A high-fidelity data center sensing network</title>
		<author>
			<persName><forename type="first">C.-J</forename><forename type="middle">M</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Terzis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Distributed algorithms for maximum lifetime routing in wireless sensor networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Madan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Wireless Commun</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">ZeroCal: Automatic MAC protocol calibration</title>
		<author>
			<persName><forename type="first">A</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woehrle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zimmerling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE DCOSS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Koala: Ultra-low power data retrieval in wireless sensor networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Musaloiu-E</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-J</forename><forename type="middle">M</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Terzis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE IPSN</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">RCRT: Rate-controlled reliable transport for wireless sensor networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Paek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">4 protocol for energy efficient, reliable and timely communications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fischione</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Johansson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE IPSN</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">802</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Versatile low power media access for wireless sensor networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Polastre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Reliable data delivery in large-scale low-power sensor networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Puccinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Haenggi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Sens. Netw</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Censor networks: A critique of &quot;sensor networks&quot; from a systems perspective</title>
		<author>
			<persName><forename type="first">B</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chebrolu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Comp. Comm. Rev</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">PIP: A connection-oriented, multi-hop, multi-channel TDMA-based MAC for high throughput bulk transfer</title>
		<author>
			<persName><forename type="first">B</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chebrolu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bijwe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gabale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An analysis of a large scale habitat monitoring application</title>
		<author>
			<persName><forename type="first">R</forename><surname>Szewczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mainwaring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Polastre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A macroscope in the redwoods</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tolle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Fidelity and yield in a volcano monitoring sensor network</title>
		<author>
			<persName><forename type="first">G</forename><surname>Werner-Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lorincz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX OSDI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A transmission control scheme for media access in sensor networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MobiCom</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">An energy-efficient MAC protocol for wireless sensor networks</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Understanding packet delivery performance in dense wireless sensor networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SenSys</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">pTunes: Runtime parameter adaptation for low-power MAC protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zimmerling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mottola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Thiele</surname></persName>
		</author>
		<idno>325</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ETH Zurich</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
