<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Introducing Dynamic Constraints in B</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Jean-Raymond</forename><surname>Abrial</surname></persName>
							<email>abrial@steria@fr</email>
						</author>
						<author>
							<persName><forename type="first">Louis</forename><surname>Mussat</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Service Central de la S~curit4 des Syst~mes d&apos;Information 18</orgName>
								<address>
									<addrLine>rue du Dr</addrLine>
									<postCode>92 131</postCode>
									<settlement>Zamenhof, Issy-les-Moulineaux</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<addrLine>1 Consultant* 26, rue des Plantes</addrLine>
									<postCode>75 014</postCode>
									<settlement>Paris</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Introducing Dynamic Constraints in B</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">69BB257B0ED06E2AFB72E35CACA687DD</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:04+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In B, the expression of dynamic constraints is notoriously missing. In this paper, we make various proposals for introducing them. They all express, in different complementary ways, how a system is allowed to evolve. Such descriptions are independent of the proposed evolutions of the system, which are defined, as usual, by means of a number of operations. Some proof obligations are thus proposed in order to reconcile the two points of view. We have been very careful to ensure that these proposals are compatible with refinement. They are illustrated by several little examples, and a larger one. In a series of small appendices, we also give some theoretical foundations to our approach. In writing this paper, we have been heavily influenced by the pioneering works of Z. Manna  and A. Pnueli [11], L. Lamport [10], R. Back [5] and M. Butler <ref type="bibr" target="#b5">[6]</ref>.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Background</head><p>This paper is the continuation of a study <ref type="bibr" target="#b1">[2]</ref> that appeared in the First B Conference, where we showed how B could be used for specifying and designing distributed systems. Since then, we have explained, by means of a rather detailed case study <ref type="bibr" target="#b2">[3]</ref>, how the concepts introduced in <ref type="bibr" target="#b1">[2]</ref> could be handled in practice and proved correct with Atelier B <ref type="bibr" target="#b12">[13]</ref>. These two studies also showed that B could be used "as it is", at least to a certain extent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Previous Work</head><p>The main idea conveyed in the mentioned papers is that B abstract machines, normally used to specify and develop software modules, might also be used to model the evolution of certain "global" situations. For instance, the state of such a "machine" might be a complete network. And its "operations" might be simple, so called, events, which may occur "spontaneously" rather than being invoked, as is the case with a normal abstract machine operation. For instance, * Supported by STERIA, SNCF, RATP and INRETS such an event might be a specific action involved in a communication protocol executed by an agent that is situated somewhere in the mentioned network. Rather than being pre-conditioned, each event is guarded by a certain predicate, which states precisely the condition under which the event can be enabled. Finally, new events, which were not explicitly present in an abstraction, _might be introduced in a refinement. Such events are all supposed to refine the nonevent (that modifies nothing) of the abstraction. The gradual introduction of new events in successive refinement steps makes it possible to slowly develop a system by starting from a non-distributed abstraction (describing, say, in one shot, the main goal of a certain protocol) and ending eventually in a completely distributed concrete realization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Purpose of Paper</head><p>As we became more and more familiar with the problems raised by the specification and design of such distributed systems, it clearly appeared that some of their requirements were sometimes elegantly presented informally in terms of certain "dynamic constraints" that are rather difficult to express, prove and refine with B "as it is". The purpose of this paper is thus the following: <ref type="bibr" target="#b0">(1)</ref> to present some simple extensions to B able to handle such constraints, <ref type="bibr" target="#b1">(2)</ref> to show them at work on some examples, (3) to present their theoretical foundations. In doing so, we shall always keep in mind that such extensions must be easily implementable on Atelier B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic Constraints</head><p>Dynamic constraints have been popular among researchers for quite a long time. They have been studied intensively for many years (an excellent survey can be found in <ref type="bibr" target="#b11">[12]</ref>). They appear in the literature under different names such as: temporal logic constraints, liveness constraints, eventuality properties, fairness, deadlock, livelock etc. Unlike a static constraint (an invariant), which expresses that a certain property involving the state variables of a system must hold when the system is in a steady state, a dynamic constraint is a law expressing how the system is allowed to evolve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Handling Dynamic Constraints in B</head><p>Our idea is to practically handle dynamic constraints in B in exactly the same way as we have handled so far static constraints. Let us thus recall in what follows the way we handle static constraints in B. As we know, it is possible to express a number of static properties of a system (in the INVARIANT clause of an abstract machine), and also to define a number of named operations (in the OPERATIONS clause) whose rSle is to describe the evolution of the system (possibly in a very abstract way, which is to be refined later). Once this is done, we are required to prove that the proposed evolution of the system is compatible with the (independently proposed) static properties: these are the so called "proof obligations". As can be seen, our main philosophy is one of separation of concern. Notice that in a specification language such as Z <ref type="bibr" target="#b7">[8]</ref>, the invariant has not to be proved to be maintained, it is automatically incorporated in the before-after expressions defining the dynamics of the specified system.</p><p>It seems then that everything has been said, that there is no room for further properties to be defined. The purpose of this paper is to say, no, everything has not been said: in the same way as we have defined some static properties of the system independently of the operations describing its evolution, we might also define a number of dynamic properties independently of the proposed operations.</p><p>And, as seen above in the case of the static constraints, it will then be required to prove that the proposed operations of the system are compatible with such dynamic constraints. In other words, we want to be sure that the system indeed evolves as it has been allowed to. Notice that in a specification language such as TLA <ref type="bibr" target="#b9">[10]</ref> (like in Z for the invariant, as we have noticed above), the dynamic constraints have not to be proved to be satisfied, they are automatically incorporated in the before-after expressions defining the dynamics of the specified system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Short Examples</head><p>A classical generic example of a dynamic constraint, which can be defined for a system, expresses that, under some conditions, which hold now, a certain state of affair will certainly be reached in the future. In a system involving the control of some requests together with the handling of the corresponding services (such a system is thus modeled with at least two events, one introducing some new request and another honoring some pending request), we might require, as a dynamic constraint, that any pending request will not be pending for ever, that it will be honored eventually. And, again, we are then required to prove that the proposed events gently handle such a dynamic constraint. For instance, we might require of a lift system that any request for a lift at a certain floor will be satisfied in the future. Likewise, we might require that an automatic maintenance system eventually succeeds in repairing what it is supposed to repair at a given moment or explain why it cannot do so. We want to exclude the possibility for the system to do nothing and never report anything.</p><p>Another classical situation is one where, in a system, we require that once a certain property holds it then holds "for ever": that any further evolution of the system will not destroy the property in question. For instance, in a system recording historical information, we might require that a piece of data stays in it for ever once it has been entered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>The Proposal</p><p>None of the proposals we present in what follows is new. They are just new in B and, perhaps, in the way each of them is packaged and integrated in a single language. We have been inspired by the ideas of various researchers on different systems. Certainly the work by Z. Manna and A. Pnueli <ref type="bibr" target="#b10">[11]</ref>, and that of L. Lamport <ref type="bibr" target="#b9">[10]</ref>. But clearly, the work of M. Butler as it is presented in <ref type="bibr" target="#b5">[6]</ref> has been fundamental to us.</p><p>Our proposal is made of five parts. <ref type="bibr" target="#b0">(1)</ref> We first introduce a general notion of abstract system (complementary to that of abstract machine). ( <ref type="formula">2</ref>) Then we present the idea of a variant in an abstract system refinement, whose r61e is to limit the possibilities for new events, introduced in that refinement, to take control for ever. <ref type="bibr" target="#b2">(3)</ref> We then define the concept of a dynamic invariant expressing how data are allowed to evolve in an abstract system. (4) The important notion of modality is then developed, which states how the repeated occurrences of certain events can lead to certain wishful situations. ( <ref type="formula">5</ref>) Finally, we give some rules concerning the problem of deadlock.</p><p>Each of these concepts will more or less be introduced in the same systematic fashion. First, we shall present the concept (sometimes with a short background) together with its linguistic representation in B. Then we shall give (if any) the corresponding proof rules. At this point, we might present a little example illustrating the concept and its proof rules (the proof rules will be recognizable immediately as they will be boxed in a special way). Finally, we shall explain how the concept is influenced by refinement. The latter point is fundamental. We have always to keep in mind that any technique for expressing some (dynamic) properties in the development of a system has to be compatible with some further refinements. Once you have stated a certain property at some point in the construction of a system, you demand that that property is maintained in further refinements. This is certainly part of the very definition of what refining means (the abstract promises should be honored), but dually, this is also part of the semantical definition of any wishful property you want to express. In fact, this gives a primary criterion for considering a property: again, it should be maintained by refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Abstract Systems</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head><p>In order to make a clear distinction between an "ordinary" abstract machine and one that is used to model a global situation driven by some events, we do not call the latter an abstract MACHINE any more, but rather an abstract SYSTEM. Likewise, the OPERATIONS clause of such a system is now called the EVENTS clause. The other clauses are left unchanged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Short Example</head><p>As a toy example, next is a little system with two events:</p><formula xml:id="formula_0">SYSTEM toy VARIABLES x,y INVARIANT x, yEl~xN INITIALIZATION</formula><p>x, y := 0, 0 EVENTS evt_x ~ x:=x+l; evt_y ~ y:=y+l END</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>No Hidden Fairness Assumptions</head><p>In such a description, there is no hidden assumptions concerning the firing of the events: what you get, is only what you read. And what we can read is the following: when the system moves (notice that the "willingness" of the system to move is not our concern), any occurrences of the two events evt_x and evt_y may take place. However, there is no implicit "fairness" assumptions saying that both events must occur infinitely often (as is the case in UNITY <ref type="bibr" target="#b6">[7]</ref>). On the contrary, here it is quite possible that the event evt_x never occur, or occur just once, or many times, and similarly with the event evt_y. In fact, besides the ability of observing any of the two events, we have no extra knowledge concerning the possible sequences of observation we will be able to make.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract Scheduler</head><p>If a more specific behavior is needed, it has to be specified explicitly. For instance, if we want to be sure that no event can occur indefinitely without letting the other occur from time to time, and vice versa, we have to "implement" this explicitly (and we shall also see in section 2.4 how to state this, so that we will be able to prove our "implementation"). Such an implementation is called an abstract scheduler (a variety of such abstract schedulers is discussed in <ref type="bibr" target="#b3">[4]</ref>).</p><p>As will be seen, such an abstract scheduler can be so abstract that it does not commit ourselves to a specific pohcy. As a consequence, any kind of more specific policy can be realized in a refinement. There are various possibilities for defining such abstract schedulers, including one consisting in introducing an explicit scheduler event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An Abstract Scheduler Example</head><p>In what follows, we propose to distribute an abstract (fair) scheduler among the two events evt_x and evt_y incrementing the state variables x and y respectively: As can be seen, the firing of the event evt_x depends on the positive value of a certain variable e. The value of this variable represents, in a given state, the maximum number of time evt_x can be enabled without evt_y being itself executed. Such a variable is decreased by evt_x and, at the same time, evt_x chooses non-deterministically a positive value for a certain variable d handled similarly by the event evt_y. The invariant c &gt; 0 V d &gt; 0 ensures that the system never deadlocks. In section 2.4, it will be shown how to express (and indeed prove) formally that each of these two events is "fair" to the other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract System and Refinement</head><p>We shall postpone the discussion on the effect of refinement on an abstract system until the next section and section 2.5 (where this question will be studied in details). Let us just say for the moment that what is "promised" by an abstract system should not be destroyed by refinement. And what is promised is a number of events which can happen freely within certain (guarded) conditions. We do not want refinement to offer less concerning the occurrence of the events in question. To take the terminology of CSP <ref type="bibr" target="#b8">[9]</ref> and also that of Action Systems as presented by Butler in <ref type="bibr" target="#b5">[6]</ref>, we do not want to restrict in any way the external non-determinism that is offered by an abstract system at the top level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Refining an Abstract System: the VARIANT Clause</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head><p>For refining a SYSTEM, we use a REFINEMENT component whose OPERATIONS clause is also, of course, replaced by an EVENTS clause. This is also the case for a refinement refining a refinement refining itself an abstract system, and so on.</p><p>Besides the events of its abstraction, such a refinement may introduce some new events that are not present in the abstraction. Such new events are all supposed to refine a "virtual" event of the abstraction that does nothing (skip). This is amply described and justified in <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b2">[3]</ref> (this has already been introduced for a long time in TLA <ref type="bibr" target="#b9">[10]</ref> as the "stuttering steps" and also in Action Systems <ref type="bibr" target="#b4">[5]</ref> as the "internal actions"). However, as such a "virtual" skip might, in principle, take control for ever, which is certainly not desirable, we have to assume that the corresponding new event only refines a bounded skip. In order to ensure this limitation, we introduce a new clause: the VARIANT clause. Such a clause contains a natural number expression. A corresponding proof obligation states that each new event decreases that quantity, so that the old events cannot be postponed for ever. Notice that the variant could also be an expression denoting a natural number sequence, in which case each new event is supposed to decrease that quantity lexicographically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof Obligations</head><p>Let 7~ be a new event introduced in a refinement. Suppose that the variant expression stated in the VARIANT clause is V. We have then to prove the following (where v denotes a fresh variable):</p><formula xml:id="formula_1">VEN [v := v] (v &lt; v) (PO_I)</formula><p>Such a proof has to be done, as usual, under the assumptions of the various invariants we depend on in this refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Short Example</head><p>Next is another little system, in which the unique event evt_l non-deterministicMly chooses a number The VARIANT Clause and Refinement Another way to look at the above proof obligation is to consider that the new event 7/ refines a generalized substitution defined by the before-after predicate V' &lt; V, where V' denotes the expression V with each state variable x replaced by its after-value x'. In other words, 7/refines a certain non-deterministic substitution that strictly decreases the quantity V. Since refinement is transitive, we can then conclude that any refinement ofT/still refines the before-after predicate V' &lt; V. In conclusion, the VARIANT clause is compatible with refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Dynamic Invariant: the DYNAMICS Clause</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head><p>A dynamic invariant is a rule stating how certain variables are allowed to evolve. For instance, it might be the case that we are sure that a certain numerical variable cannot be decreased: this is part of what we mean by this variable. It might then be useful to state this explicitly in our specification (subjected, of course, to a proof obligation expressing that each event indeed satisfies this property). We know that, in a sense, this is redundant with the events (hence the proof obligation) but we feel it important to express such redundancies in a specification.</p><p>Such dynamic invariants are defined in a special clause called DYNAMICS. It can be introduced in an abstract system or in any of its refinements. Such a clause contains a number of conjuncted before-after predicates involving certain (before) variables and also some "primed" (after) variables. Each of these beforeafter predicates expresses how variables are allowed to evolve when modified by the events. For instance, given a natural number variable x, the dynamic invariant x &lt; x ~ states that the variable x is not allowed to decrease, only to increase or stay unchanged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof Obligation</head><p>Of course, a proof obligation has to be generated in order to ensure that each event is indeed consistent with the contents of the dynamic invariant. For instance, an event with the substitution x := x + 1 satisfies the dynamic invariant x &lt; x ~ while the substitution x :-x -1 does not.</p><p>In general, given an event E and a dynamic invariant of the form P(x, x') (where x denotes the variables of the considered abstract system), the shape of the proof obligation is the following, where prd,(g) is the before-after predicate associated with the event g (this is described in the B-Book <ref type="bibr" target="#b0">[1]</ref> in section 6.3.1):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(PO_2)</head><p>This has to be proved under the invariant of the abstract system. It exactly says what is meant by the dynamic invariant. Namely, if x and x ~ are related by the before-after predicate corresponding to the event g then the dynamic invariant should also hold between these variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Short Example</head><p>In what follows it is shown how the system toy of section 2.1 can be equipped with a dynamic invariant. evt_y &amp; y:=y+l END As, clearly, the before-after predicate of evt_x is x ~ = x + 1 A y~ = y, and that of evt_y is y~ = y + 1 A x ~ = x, we are led to prove the following which holds trivially:</p><p>x, yENxN</p><formula xml:id="formula_2">A x~=x+l A y~=y ::~ x~x ~ A y~_y~ x, yENxN A y~=y+ l A x~=x ::~ x&lt;_x ~ A y&lt;_y~</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic Invariant and Refinement</head><p>As for the case of the VARIANT clause in the preceding section, we can consider that, in the proof obligation (PO_2), the event S refines a generalized substitution defined by the before-after predicate P(x, x~). And, again, since refinement is transitive, we can then conclude that any refinement of s will still refine the before-after predicate P(x, x~). In conclusion the DYNAMICS clause is compatible with refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Modality Properties: the MODALITIES Clause</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Background</head><p>A variety of temporal operators have been introduced in the literature <ref type="bibr" target="#b10">[11]</ref> for reasoning about the way systems can behave dynamically. The most classical are [] (always), ~ (eventually), ~ (leadsto) and until. In what follows, we shall give a brief informal description of each of them.</p><p>Given a certain predicate P defined on the state variables of an evolving system, then [:]P means that P always holds whatever the evolution of the system. In other words, this clearly means that P is invariant in our terminology.</p><p>Given a certain predicate P, the statement ~P means that P holds at system start up or that it will certainly hold after system start up whatever the evolution of the system. Notice that, once it holds, there is no guarantee that P holds for ever. This operator is rarely used on its own, but rather together with the operator [], as in the statement o OP. This statement means that it is always the case that P holds eventually: in other words, if P does not hold in a certain state then it will certainly hold in some other state that is reachable from the former whatever the evolution of the system.</p><p>Given two predicates P and Q, the statement P ~,~ Q (pronounced P leads to Q) means that it is always the case that once P holds then Q holds eventually. Notice that, once the very process, by which some progress is made towards Q, has started, then P is not required to hold any more (P is only required to hold at the initialization of this process). The statement P ~.z Q can be defined by the following combination of the two previous operators:</p><formula xml:id="formula_3">p~.~ Q ~ D(P ~ OQ)</formula><p>As can be seen, the statement [] OQ is clearly a special case of P ~ Q. Given two predicates P and Q, the statement P until Q means two different things: (1) that P leads to Q, and (2) that P holds as long as Q does not. Notice that it is not required that P still holds when Q just holds. Up to the last evolution, we can say that P is a "local invariant", which holds during the active part of the process by which P "leads to" Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introducing modalities in B</head><p>It seems that a combination of the two operators -~ and until covers most of the "modalities" that one may encounter in practice. In both cases, as we have already mentioned, there is an implicit usage of a certain process that is effectively at work in order to progress from a certain situation characterized by the predicate P to another one characterized by the predicate Q.</p><p>Following what is done in TLA <ref type="bibr" target="#b9">[10]</ref>, we would like to make this process explicit. In other words, we would like to express that P leads to Q only when certain events ~1,"" , ~, do occur.</p><p>For instance, suppose that we would like to express that a certain event evt in a system cannot prevent indefinitely the other events in the system to occur. This is clearly expressed by stating that the guard G of evt leads to -~G and this when the only means of progress is precisely evt. If this is the case then any attempt for evt to take control for ever will fail.</p><p>The "eventuality" aspect of these operators means that the process in question must come to an end. Clearly this can be expressed as the termination of a certain loop whose body is made by the bounded choice of the concerned events and whose guard is the negation of the predicate we want to reach.</p><p>This view of our modality as a loop termination is supported by the small theoretical development that the interested reader can consult in the appendices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description: First Form</head><p>The first form of our modality involves five distinct components (all possibly defined in terms of the state variables x of our abstract system): (1) a predicate P which is our "point of departure", (2) a predicate Q which is our eventual "destination", (3) a non-empty list of event names ~i,..-, ~-n (possibly separated by the keyword oR) that are involved by the loop in progress to go from P to Q (this list is optional, when it is missing then all the events of the system are implicitly involved), (4) an invariant predicate J that must hold during the loop (this predicate is optional) and ( <ref type="formula">5</ref>) a natural number expression V denoting the decreasing variant of our loop (alternatively, an expression denoting a sequence of natural numbers): The termination of this loop, however, may not necessarily lead to a state where Q holds. This is because the loop may terminate before we reach that state. This is due to the fact that the events Yl to .Tn have their own guards. In other words, the effective guard of the loop is not --1Q but rather the following (in the B-Book, the construct grd is called fis in section 6.3.2):</p><p>-~Q ^ (g~d(7~) v ...v g~d(7~))</p><p>Consequently, when the loop terminates we have</p><formula xml:id="formula_4">Q V (-~ grd(~l) A --. A -1 grd(~n))</formula><p>As we certainly do not want to terminate in a state where ( -~ grd (~'1) A ---A -~ grd(Jrn) ) holds whereas Q does not, we require the following condition to hold:</p><p>-~Q ~ grd(J:l) v... v grd(T.)</p><p>When -~ Q is stronger that the disjunction of the guards then the effective guard of the loop is exactly -1Q. When the loop terminates then we certainly are in a state where Q holds (this is justified in Appendix A7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>How to Achieve the until Effect</head><p>The until effect can easily be achieved by means of the following modality:</p><formula xml:id="formula_5">SELECT P LEADSTO Q WHILE ~'~ OR ..-OR -~'n INVARIANT J A (PVQ) VARIANT V END</formula><p>Since the involved loop is, as we know, guarded by --Q, the invariance of P v Q means that inside the loop (where --Q holds) then P holds, whereas at the end of the loop (where Q holds) P may not hold any more: it is then indeed the case "(1) that P leads to Q and (2) that P holds as long as Q does not".</p><p>As a syntactic sugar, we can thus introduce the following construct to replace the special case above:</p><formula xml:id="formula_6">SELECT P UNTIL Q WHILE INVARIANT J VARIANT V END</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof Obligation for First Form</head><p>The following proof obligations (except the last one) constitute a direct derivation of the loop proof rules that one may find in the B-Book in section 9.2.9. Notice that the third and fourth proof obligations have to be repeated for each concerned event. Also notice that we do not have to prove that each of the event maintains the invariant I of the abstract system, since this has clearly been covered by the "standard" proof obligations. Note that the corresponding proofs have to be performed under the assumption of the invariant I. Finally note that the quantification is done on the variable z, which denotes the collection of state variables that are modified in the loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P~J P =r Vz.(I A J =~ VEI~) F ~ Vz.(I A J A -~Q ~ [~i]J)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P ~ Vz.(I A J A -~Q ~ [v:=V][J:i](Y&lt;v)) P ~ Vz.(I A J</head><formula xml:id="formula_7">A -~Q ~ grd(.T'l) V...Vgrd(.Tn)) (PO_3)</formula><p>The first of these proof obligations expresses that the extra invariant is established by the guarding condition P. The second proof obligation expresses that under the invariant and the guard of the loop the variant is indeed a natural number (alternatively, an expression denoting a natural number sequence). The third proof obligation states that the predicate J is indeed an extra "local" invariant of the corresponding event. The fourth proof obligation states that the variant decreases under the corresponding event. The final proof obligation states that -~ Q is the effective guard of our loop.</p><p>Notice the importance of the universal quantification over z (the state variables modified in the loop). This has the effect of separating the context of what is to be proved "dynamically" from the initial condition which does not always hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description: Second Form</head><p>There exists a second form for our "leads to" property. It involves an initial non-deterministic choice. Clearly this second form generalizes the former. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof Obligation for Second Form</head><p>By analogy with those obtained for the first form, next are the proof obligations for the second form of modality. As previously the third and fourth are to be repeated for each of the n concerned events. Notice again that these proofs have to be performed under the assumption of the current invariant I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vy.(P =~ J)</head><p>Vy.(P =~ Vz.(I A J ~ Vel~))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vy.(P ~ Vz.(I A J A ~q ~</head><formula xml:id="formula_8">[2-i]J)) Vy-(P ~ Vz-(I A J A -~Q ~ [v := Y] [~'i] (Y &lt; v) ) )</formula><p>Vy.(P =:&gt; Vz.(I A J A ",Q ::~ grd(.T1) V.--Vgrd(.Tn)))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(PO_4)</head><p>As for the previous case, the variable z is supposed to denote those variables that are modified in the loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Short Example</head><p>As an example, we can now state that in the system toy_with_scheduler of section 2.1, the event evt_x (resp. evt_y) does not keep the control for ever. We have just to say that, provided its guard holds, then the recurrent occurrence of this event leads to a certain state where the guard does not hold any more, formally:</p><formula xml:id="formula_9">SYSTEM toy_with_scheduler_dynamics_and_modality VARIABLES x, y, c, d INVARIANT x,y,c, dEHxNxl~• A (c&gt;0Yd&gt;0) DYNAMICS x&lt;_x' A y&lt;_yl INITIALIZATION x, y := 0, 0 II c, d :E N1 x N 1 EVENTS evt_x ~ SELECT c &gt; 0 THEN x, c :-----x ~-1, c-1 II d :E i~1 END ; evt_y ~ SELECT d ~ 0 THEN y, d := y + 1, d-1 II c :E 1~1 END MODALITIES SELECT c ~ 0 LEADSTO e ----0 WHILE evt-x VARIANT c END ; SELECT d &gt; 0 LEADSTO d = 0 WHILE evt_y VARIANT d END END</formula><p>Notice that since the guard of evt_x is exactly c &gt; 0, we trivially have c &gt; 0 ==~ grd(evt_x) (and the like for evt_y). We can conclude, provided the corresponding proofs are done, that these two events are "fair" to each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Modalities and Refinement</head><p>For each of the two forms of modality we have introduced in this section, the four first proof obligations are clearly maintained by the refinements of the events: this is obvious for the first and second ones that are not concerned by the events; in the third and fourth proof obligations the events, say ~', are only present in subformulae of the form [~r] R for some conditions R. Such statements are maintained by refinement according to the very definition of refinement, which says that if an abstraction jr is such that [~] R holds, and if G refines ~ then [G]-R holds.</p><p>However, the main purpose of the proof obligations was to ensure that the considered loop terminated. The problem is that the implicit concrete loop now contains not only the refined versions of our events but also the new events introduced in the refinement and supposed to refine skip. So that the "body" of our refined implicit loop is now the following:</p><formula xml:id="formula_10">CHOICE ~1 OR "--OR ~n OR ~'~1 OR --" OR ~t~rn END</formula><p>where the Gi are supposed to be the refinements of the more abstract ~'i, and where the 7/j are supposed to be the new events. Fortunately, we know that, thanks to the VARIANT clause introduced in section 2.2, the new events 7/j cannot take control for ever. It just then remains for us to be sure again that the loop does not terminate before its normal abstract end (as we know, refinement may have the effect of strengthening the guard of an event). In fact the following condition, which has been proved (this was a proof obligation)</p><p>-~Q =:~ grd(.T'l) V .-.Vgrd(.T'n)</p><p>is now refined by the condition (to be proved under the assumption of the "gluing" invariant of the refinement):</p><formula xml:id="formula_11">I -~ 0 ==~ grd(Cfil) V--. V grd(Gn) V grd('/'ll) V..-V grd(7"Lrn)</formula><p>which has no reason to be true. We thus impose the following refinement condition (again, to be proved under the assumption of the "gluing" invariant of the refinement), which clearly is sufficient to ensure a correct refinement of each of the fifth proof obligations:</p><p>grd(.T'1) V---V grd(.T'n) grd(G1) V--. V grd(Gn) V grd(7-/1) V.--V grd(nm) (PO_5)</p><p>This condition says that the concrete events Gi (refining the abstract events 5i) together with the new events 7/j do not deadlock more often than the abstract events 5i. As we shall see in the next section, this condition must be maintained along the complete development. This is essentially the "progress condition" introduced in <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Deadlockfreeness</head><p>The Problem</p><p>At the top level, an abstract system "offers" a number of events able to occur "spontaneously" (guard permitting of course). Following the terminology used in CSP <ref type="bibr" target="#b8">[9]</ref> and in Action Systems <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>, such possibilities correspond to a certain external non-determinism that has to be guaranteed. But, as we know, refinement (besides other effects) can strengthen guards, so that it could very well happen that an abstract event, say E, offered at the top level, disappears completely in the refinement because of the following correct refinement SELECT false THEN E END</p><p>In order to prevent this to happen, it seems sufficient to impose that the abstract guard implies the concrete guard. But as the converse certainly holds (because of refinement), this implies that the abstract and concrete guards are identical (under the gluing invariant, of course). This is certainly too drastic a rule in the case where the refinement introduces some new events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof Obligations</head><p>In fact, as we know, an abstract system can be refined by another one introducing new events. And we also know that such events cannot take control for ever because of the VARIANT clause (section 2.2). The idea is to impose a certain "progress condition" <ref type="bibr" target="#b5">[6]</ref> allowing us to relax the above constraint on the refinement of the guard of an event. More precisely, in the case of the first refinement of an abstract system, the law is the following for each abstract event .T refined by G and with the new events ~/1, "'" ,Ttn (this has to be proved under the assumption of the abstract and concrete gluing invariants):</p><formula xml:id="formula_12">II grd(.T) =&gt; grd(G) Vgrd(/-/1)V---Vgrd(/-/n) (PO_5)</formula><p>Such a rule does not disallow the guard of jv to be strengthen in ~, it only gives a certain limitation to this strengthening: it should at least be "absorbed" by the new events. If we perform yet another refinement, we have to prove the following rule which gradually transports the progress condition along the development (again, this has to be proved under the relevant invariant assumptions): grd(~) V grd(7"ll) V--. V grd(7"ln) grd(.A~) V grd(/C1) V-.-V grd(lCn) V grd(Z:l) V-.. V grd(,gm)</p><formula xml:id="formula_13">(POJ)</formula><p>where M is a refinement of G, each K:i is a refinement of the corresponding more abstract event ~/i, and the s are the new events of the refinement. A similar proof obligation has to be generated for each further refinement, and so on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example</head><p>It is easy to check that the above progress condition is satisfied in the case of the refinement anotherztoy_l of anotherJoy_O (section 2.2). We have in the more </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Modalities Revisited</head><p>As we have just done for the guard of an abstract event, the proof obligation presented for the disjunction of the guards of events involved in a modality (section 2.4), has to be extended for any further refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A Larger Example</head><p>In this section, we present a complete example able to illustrate the proposal made above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Informal Presentation</head><p>The problem consists in specifying and refining an event system concerned with requests and services. An agency is supposed to offer n different services (n is thus a positive natural number). Clients of this agency are supposed to issue requests for these services. Once a request for a service is pending, that service cannot be requested again. On the other hand, a pending request cannot be pending for ever. At this stage, we do not require any specific scheduling strategy for honoring the pending requests. In other words, the choice of any future correct strategy must be left open. Again, our only requirement concerning any future implemented strategy is that there cannot be any pending request starvation. Although we do not specify a precise strategy, we nevertheless require a proof guaranteeing that a pending request will be served "some time". The system is then refined in two different ways, which both concerns the scheduling strategy: (1) a FIFO strategy, (2) a LIFT strategy. With the FIFO strategy a request is supposed to be honored according to its arrival: the oldest the first. With the LIFT strategy the n services are supposed to correspond to the n floors of a building. The clients are the passengers of the lift. The requests are issued by clients when they push the floor buttons within the lift, thus asking for the lift to stop at certain floors. The lift strategy is then the following: the lift does not change direction unless it has no more passenger to serve within that direction, and, of course, within a given direction, the lift serves its passengers in the natural order of the requested floors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Developing the Specification</head><p>In what follows, we shall develop our formal treatment of the above problem by means of a gradual approach. Clearly, our final abstract system will have at least two events: one for issuing new requests, another for honoring pending requests. In a first phase however, we shall consider one event only, namely that corresponding to honoring requests. In a subsequent refinement, we shall then introduce the requesting event. And only at this stage shall we be able to state the dynamic constraint stipulating that no pending request can be pending for ever.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Phase 0</head><p>The (very abstract) state of our abstract system at this level, essentially formalizes the "history" of what has happened so far concerning the services that have been honored. This state consists in a "log", named 10, recording which services have been honored and when. It is not our intention to formalize a notion of time in our future system: our point of view is just to consider that our model of the system at this stage consists in saying that certain services have been honored (one at a time) and that, clearly, such services have been honored "at some time".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invariant</head><p>Our variable l0 is then just typed as follows /0EN-4-r(1..n) I This typing invariant must be made a little more precise by expressing that our history being the history "so far" is clearly finite. We write thus the following extra condition: dora(to) e If t is in the domain of 10, this means that the service io(t) has been honored at "time" t. As can be seen, we have used the set of natural number to denote the results of time measurements. Clearly, we do not know what such a time measurement represents in terms of any precise output as given by a real clock (in particular, we are not interested in any time unit). Our only reason for formalizing time measurements with 1N is a pragmatic one. By doing so, we shall be able to compare various time measurements, and thus easily express such concepts as before, after, next, and so on.</p><p>Of course, we could have removed completely any reference to the time by just recording the services in the order in which they have been honored (that is, in the form of a finite sequence). However, as we shall see below, such a "trace" technique is not accurate enough in our case.</p><p>It is also convenient to have a second variable recording the time, named co, of the "youngest" recorded service in the log (when it exists). This variable is typed as follows: co EI~ together with the following invariant (notice that, in this invariant, max(dorn(lo)) is well defined in the place where it appears because dora(/0) is then a finite and non-empty set): l0 # 0 =:~ co = max(dora(/0))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic Invariant</head><p>At this point, it is possible to write down a number of dynamic properties of our state variables, properties expressing that such variables can only be modified according to certain constraints. Such properties will secure the very "raison d'6tre" of these variables, namely to record the history of some "past" events.</p><p>For instance, no service can ever be removed from the log 10, and no time nor any service can be modified either. Likewise, the variable Co can only be incremented: this formalizes that events are recorded in the log l0 as soon as they effectively take place. This results in the following simple dynamic invariant:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>to c ro co &lt; C~o Events</head><p>We are now ready to formalize our unique event, named serve. This event "spontaneously" records in the log l0 that, at an arbitrary time t, necessarily strictly greater than co however, some arbitrary service x has been honored. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>END</head><p>What is important to mention here is that we do not know (and we are not interested in) the "cause" of this event. The only thing we say is that it is possible to observe that, subjected to certain conditions, such an arbitrary event does occur. Of course, the question is now: are we able to always observe that event ? The answer to this question lies in the guard (the enabling condition) of our event, namely</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3(t,x).(t E I~ A x E (1..n) A Co &lt; t)</head><p>As can be seen, this condition is always valid (under the invariant). This means that our event, as we expect, can always be observed. In other words, our system is always ready to honor any service. Notice that, at this point, we have not yet introduced any notion of request. This is precisely the subject of the next phase of our development where it will be clear that honoring a service is not done in a way that is as arbitrary as it appears in the present abstraction. It is not difficult to prove that this event maintains the static as well as the dynamic invariant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Modality</head><p>It is interesting to note that, at this point, we can introduce the following modality expressing that time passes: any "future time" t (strictly greater than co) will eventually be a "past time" (some service will have occurred after it).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ANY t WHERE</head><formula xml:id="formula_14">co &lt;t LEADSTO t &lt;_co VARIANT max({O, t --e0}) END</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Final System</head><p>Next is our complete SYSTEM (in subsequent phases we shall not show our components with all there clauses put together like this):</p><formula xml:id="formula_15">SYSTEM phase_O CONSTANTS n PROPERTIES nEN1 VARIABLES to ~ CO INVARIANT to E N ~ (1..n) A dom(/o) E F(N) A co EI~ A Zo # ~ ~ co = ma• DYNAMICS l0 c l~ A co &lt; c~ INITIALIZATION 1o, Co := 0, 0 EVENTS serve ANY t,X WHERE tEN A x ~ 0..n) A co &lt;t THEN co:=t II lo :--1o U {t ,--r x} END MODALITIES ANY t WHERE co &lt;t LEADSTO t&lt;_ co VARIANT ma• -eo}) END END Phase 1</formula><p>The purpose of this phase is to introduce a requesting event together with some new interesting dynamic constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gluing Invariant</head><p>We first introduce two variables 11 and Cl that are just copies of their corresponding abstractions. For the sake of readability we introduce them explicitly, together with the following trivial gluing invariant:</p><formula xml:id="formula_16">11 = lo C 1 ----C O lnvariant</formula><p>We now introduce a variable which records the various requests that have been made so far. This variable is typed as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>rl ~N-~ (1 ..n)</head><p>As for the log l0 above, we have the extra constraints that rl is finite, namely:</p><formula xml:id="formula_17">I d~ E F(N) ]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic Invariant</head><p>We also have to express, as for 11 above, that rl records the history of the requests. Such an history cannot be modified, it can only be augmented. We have thus the following dynamic invariant:</p><p>rl C_ r~</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invariant Again</head><p>As can be seen, the type of rl is the same as that of 11. Contrary to what one might expect however, the expression rl (t) does not denote a certain service that has been requested at time t. It rather denotes the "knowledge" we suppose to have in this abstraction of the (possibly future) time where the corresponding service has been (or will be) honored. In other words rl is a log as is lt. But this log possibly already records a little of the future of I1 : it anticipates 11. Of course, it seems rather strange that we can guess the future time where a pending request will be honored. We give ourselves the right to do so only because we are still in an abstraction. But, as we shall see below, this right is precisely the least committed way by which we can express that no pending request will be pending for ever. The fact that rl anticipates 11 is clearly described in the following invariant:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>/1~rl I</head><p>As a consequence the pending requests are exactly those requests that are in rl -11. It is time now to express that a service that is pending cannot be requested until it is honored. This is formalized very easily by requiring that the function rl -11 is injective:</p><formula xml:id="formula_18">rl-llEN~-~(1..n) I</formula><p>It remains now for us to express that the guessed times of service of the pending requests (if any) "belong to the future". Taking into account that Cl denotes the time of the youngest honored service (if any), we have thus the following extra invariant:</p><p>rl-~1 r ~ ~ el &lt; min(dom(rl-11))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Variant</head><p>As we shall see, we have a new event, called request. This new event must not have the possibility to be enabled for ever. It has thus to decrease a certain variant, which is, in fact, the following: n-card(r1 -/1) ]</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Events</head><p>We are now ready to define our request event as follows </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THEN rl :----rl U{t ~ y} END</head><p>A It is easy to prove that this event maintains the static as well as the dynamic invariant, that it refines skip, and that it decreases the above variant.</p><p>Next is the refinement of the event serve. As expected, the idea is to now deterministically honor the pending request (if any) whose guessed service time is the smallest. As can be seen the refined version is now completely deterministic. Of course, the guard of the refined event must be stronger than that of the abstraction. This is certainly the case since, as we have already seen, the guard of the abstraction is always valid. The refinement proof also requires that we give some witness values for the arbitrary variables t and x in the abstraction: these are clearly min(dom(rl -11)) and rl(rnin(dom(rl -/1)))-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Modality</head><p>It finally remains for us to express that no pending request will be pending for ever. We have just to say that if any request for the service z is in the range of rl -11 (is waiting to be honored) then, it will not stay there for ever under the recurrent occurrences of the two events request and serve. At some point in the future it should disappear (may be shortly, of course). This is done as follows: END Notice that, in this modality, we have not mentioned any event since both events serve and request are concerned. Also note that our variant is lexicographic. The apparent complexity of the first part of this variant is due to the fact that when z is not a member of ran(rx --11) (at the end of the process), the expression (rx -11) -~ (x) is not defined. On the other hand, the second part of this variant is a mere copy of our VARIANT clause.</p><p>It is easy to prove that both events are compatible with this modality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deadlockfveeness</head><p>According to the outcome of section 2.5, it remains for us to ensure deadlockfreeness. In other words, we have to prove that the abstract guard of event serve implies the disjunction of the concrete guards. This reduces to proving:</p><formula xml:id="formula_19">rl -!1 = 0 =r 3(t,y)-(tEN-dora(r1-/1) AyE (1..n)-ran(rl-ll) ^ c~ &lt;t)</formula><p>Notice that this also proves that our abstract modality is correctly transported within the present refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion</head><p>What we have done in this refinement was not to define a particular scheduler that has been, by any chance, able to satisfy our modality. By using the artifact of the "guessed" service time of a coming request, we have just been able to implement again a very abstract scheduler. As we shall see below, any policy that will not be contradictory with this abstraction will be a correct policy. In other words, we will not have to verify any more in the coming refinements that our modality is satisfied, we will just have to implement a concrete scheduler that refines this very general abstract one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Phase 2</head><p>The second refinement is just a technical phase consisting in throwing away the log 11 that has no purpose any more. The variable ca will thus also disappear. In fact, we are just going to keep the pending requests (corresponding to rl -11) but not with their guessed sewice time, only their guessed waiting time. This results in some drastic simplifications of the model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invariant</head><p>The new variable, named w2, is typed as follows:</p><formula xml:id="formula_20">w 2 9 (1 ..n) ~"~ ~1 I</formula><p>Notice that w2 is injective as expected and that the waiting times are strictly positive as one would also expect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gluing Invar=ant</head><p>This variable is glued as follows to the abstraction:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I w2=(rz-ll)-l;minus(cl) I</head><p>The function minus(c1) is the function that subtracts cz.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Events</head><p>We can now propose the following refinement of the event request: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deadlockfreeness</head><p>The trivial equivalence of the abstract and concrete guards of each event clearly implies the deadlockfreeness condition and the correct transportation of our modalities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Towards some implementations</head><p>In this section, our intention is to propose two different refinements of the above abstract scheduler corresponding to the FIFO and the LIFT policies respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The FIFO Policy</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invariant</head><p>In this policy we are going to reduce the inverse of the previous variable w2 to a mere injective sequence q3. This yields the following typing:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I q3 E iseq(1..n) I</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gluing Invariant</head><p>We have the following gluing invariant:</p><p>q3 ----W21</p><p>Notice that we can deduce the following assertion:</p><formula xml:id="formula_21">w2 :~ 0 =~ rnin(ran(w:~)) = 1</formula><p>As can be seen, the waiting times are now all "dense" (starting at 1): they together form the domain of the sequence q3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Events</head><p>The event request is now very simple (just the appending of the new request in the queue):</p><formula xml:id="formula_22">req uest ANY y WHERE # E (1..n) --ran(q3) THEN q3 := q3 ~ Y END</formula><p>We can fruitfully compare it to its abstraction:</p><formula xml:id="formula_23">request --~ ANY y, W WHERE y E (1..n) -dora(w2) W E 1~1 --ran(w2) THEN w2 := w2U{y~w} END A</formula><p>As can be seen, the guessed waiting "time" of the abstraction is now completely determined as size(q3) + 1. It is precisely this determination that implements the FIFO policy together with the event serve. This event just consists in removing the first element of the queue: We can see how the new version simulates its abstraction: the pair with the smallest index, 1, is removed, and 1 is indeed subtracted from the other indices (this is, in fact, exactly what tail does).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The LIFT Policy</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invariant</head><p>As for the FIFO policy, the LIFT policy will be a refinement of our phase 2 above. In the present case, the n services are supposed to denote the n floors of a building. We shall therefore suppose that there are at least two floors (otherwise there is no point in having a lift at all !).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I n&gt;_2</head><p>This phase will consist in making the waiting time function w2 (now renamed w4) more precise. We already know from phase 2 that it should be injective from 1 .. n to N1. We have the following trivial gluing invariant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I W4 -~-W 2</head><p>We introduce to more variables. First, the lift position 14 (this is a floor) and second the lift direction d4 (up or down). We have thus the following typing invariant:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14G1..n d4 E { up, down }</head><p>We now have an extra invariant stipulating that, when it is at the bottom floor, the lift goes up, whereas it goes down, when it is at the top floor (here it helps to have at least two floors). /4=1 =:&gt; d4=up 14 = n ~ d4 = down Given the position and direction of the lift, our idea is to have a pre-defined function yielding the waiting time for a coming request for floor x. It corresponds to the number of floors the lift has to pass (including the last one x) in order to reach floor x. For instance, next are the two functions corresponding to the lift being at floor 4 (in a building with 7 floors) and going either down or up as</p><formula xml:id="formula_24">f4 = { 7~+9, g4 = { 7~-~3, 6~8, 6~+2, 5~+7, 5~+ 1, 4 ~-~ 6, ~ 4 ~-~ 6, 3~+1, $ 3 ~-~ 7, 2~+2, 2 ~-~ 8, 1~+3 } 1~-+9 } indicated:</formula><p>t</p><p>Next are the formal definitions of these two functions (notice that they are both injective from 1 .. n to 1~1 as required): This means that if we want to terminate within both sets p and q, we better start from within both sets F(p) and F(q). A simple consequence of this property is that our set transformer is monotone. That is, for any two subsets p and q of s, we have p C q ~ F(p) C_ F(q) (4)</p><p>We now define the, so-called, termination set, pre(F), of F as follows (see B-Book, property 6.4.9): pre(F) ~ F(s) <ref type="bibr" target="#b4">(5)</ref> According to this definition, the set pre(F) thus denotes the largest set in which we have to be in order for the event F to "terminate" in a state belonging to s. As "belonging to s" is not adding any constraints on the outcome, the set pre(F) then just denotes the set where we have to be for the event F to simply "terminate". In what follows, we shall suppose (unless otherwise stated) that our termination set is always equal to s itself, that is = s</p><p>We now present the, so called, before-after relation, rel(F), associated with F (see B-Book, property 6.4.9). When a pair (x, x') belongs to this relation, this means that the event F is able to transform the state x into the state x'. It is defined indirectly by means of the image of a subset p of s under rel(F)-l:</p><formula xml:id="formula_26">rel(F)-l[p] ~ F(~)<label>(7)</label></formula><p>In what follows we shall use the letter f to denote the relation rel(F). The domain, dom(f), of the relation f is called the guard, grd(F), of the set transformer F. We have thus:</p><formula xml:id="formula_27">g,d(F) = dora(/) =/-* =<label>(8)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A2. Operations on Conjunctive Set Transformers</head><p>We now present the classical operations applicable to conjunctive set transformers. This is done in the following table, where F, F1, F2 and Fz are conjunctive set transformers built on a certain set s, where p is a subset of s, and t is a set: Notice that in the B-Book the operators ( ], ~ , etc) were supposed to work with predicates and predicate transformers (generalized substitutions). Here they are rather applied to sets and set transformers. This slight shift in the notation leads, we think, to a certain simplification of the formal presentation.</p><p>We have the following definitions yielding the values of the above set transformer constructions for a given subset q of s:</p><formula xml:id="formula_28">skips(q) (p I F)(q) (p ~ F)(q) (F~ I F2)(q) (Izit Fz)(q) p n F(q) U F(q) F1 (q) n (q)</formula><p>N=c~ Fz(q) (F1 ; F2)(q)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FI(F2(q))</head><p>It is easy to prove that each of the above operation transforms conjunctive set transformers into other conjunctive set transformers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A3. Fixpoints of Conjunctive Set Transformers</head><p>As we shall use them in the sequel, we remind in this Appendix the definition and main properties of the fixpoints of conjunctive set transformers. Let fix(F) and FIX(F) be defined as follows:</p><formula xml:id="formula_29">fix(F) = N {PIP C_ s A F(p) C_C_ p} (9) FIX(F) = U{ p Jp c_ s A p_C F(p)} (<label>10</label></formula><formula xml:id="formula_30">)</formula><p>Since F is monotone according to (4), then these definitions indeed lead (Tarski) to fixpoints, that is:</p><formula xml:id="formula_31">F(fix(F)) = fix(F)<label>(11)</label></formula><formula xml:id="formula_32">F(FIX(F)) = FIX(F)<label>(12)</label></formula><p>From ( <ref type="formula">9</ref>) and ( <ref type="formula" target="#formula_29">10</ref>) , we can easily deduce the following, which is valid for any subset p of s:</p><formula xml:id="formula_33">F(p) C_ p :=~ fix(F) C_ p<label>(13)</label></formula><p>p C_ F(p) =~ p C_ FIX(F) (14)</p><p>These laws will be useful to prove certain properties involving the fixpoints. For instance, from them it is easy to prove that fix(F) and FIX(F) are indeed respectively the least and greatest fixpoints of F. So that we have fix(F) C_ FIX(F) (15)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A4. More Operations on Conjunctive Set Transformers: Iterates</head><p>We are now ready to present more operations on conjunctive set transformers. They are all dealing with some form of iteration. This concept is important in our framework since the formal behavior of an abstract system (with events) is intuitively formalized by all the possible iterations one is able to perform with these events. Such operations are introduced in the following table, where F is a conjunctive set transformer, and n is natural number:</p><formula xml:id="formula_34">nth iterate F n Closure F ~ Opening F ^</formula><p>The nth iterate is defined recursively as follows:</p><formula xml:id="formula_35">F ~ skip,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F n+l F ; F n</head><p>The values of the other two at the subset q of s are defined as follows:</p><formula xml:id="formula_36">F~ FIX(q IF)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F^(q)</head><p>fix(q I F)</p><p>The intuitive rationale behind these definitions will appear in the sequel. For the moment, let us just see what kind of property we can derive from these fixpoint definitions. Concerning F ~ we deduce the following, supposed to be valid for any subset q of s:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F~ (qIF)(F~ q r176</head><p>skip,(q) N (F ; F~ (skip, II (F ; F~ As this development could have been performed on F ^ as well, we have thus:</p><formula xml:id="formula_37">F ~ = skip, ~ (F ; F ~ (16) F ^ = skip, [1 (F ; F ^)<label>(17)</label></formula><p>We have obtained the classical unfolding properties. Clearly, such properties show the iteration at work. More precisely, by developing these equations, we obtain something like this: </p><p>It seems then that the two are indeed the same. This would be a wrong conclusion in general: in fact the ".--" are, as usual, misleading. F ~ being defined by a greatest fixpoint, denotes a kind of infinite object, whereas F ^ contains some finiteness requirement in its definition. In fact, the conjunctivity of F allows one to prove the following:</p><formula xml:id="formula_39">e ~ =<label>(20)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F --fix(F) I F~ (21)</head><p>Equality ( <ref type="formula" target="#formula_39">20</ref>) is easily shown by first proving F ~ (q) C_ F n (q) for any natural number n. This is done by mathematical induction. From this, F~ C_ (Dn+xFn)(q) follows immediately. Then the second part of (20), namely (~ne~fFn)(q) C_ F~ is proved using ( <ref type="formula">14</ref>) and (2). Equality ( <ref type="formula" target="#formula_41">21</ref>) is essentially Theorem 9.2.1 of the B-Book.</p><p>As can be seen on ( <ref type="formula" target="#formula_39">20</ref>), F ~ just denotes all the possible iterations without any direct concerns about termination. On the other hand, as can be seen on ( <ref type="formula" target="#formula_41">21</ref>), F ^ is exactly F ~ together with the fundamental terminatzon requirement that one has to start the iterations from within fix(F). Consequently, as we shall see in the next Appendix, no iteration started in fix(F) can be pursued indefinitely: we shall necessarily reach some points where we cannot move further.</p><p>From the definition of the termination set of a set transformer, we deduce easily (B-Book sections 9.1.3 and 9.2.4) the following (since F(s) = s):</p><formula xml:id="formula_40">pre(F n) = s (22) pre(F ~ --s (23) pre(F ^) = fix(F)<label>(24)</label></formula><p>The set fix(F) thus represents the set from which one has to start in order for the iterate F ^ to terminate.</p><p>The before-after relation of this iterators can be calculated easily (B-Book sections 9.1.3 and 9.2.4). We obtain (since F(s) = s) the following:</p><p>re,(F") =/-(2s)</p><formula xml:id="formula_41">rel(F ~ = f* (26) rel(F ^) --:fix(F) x s U f* (<label>21</label></formula><formula xml:id="formula_42">)</formula><p>where f* denotes the transitive and reflexive closure of f. Notice that in case fix(F) is equal to s then rel(F ^) is exactly f*. Finally, we can prove by mathematical induction that, for each natural number n, F" is conjunctive. From this and from (20) and (21) it follows that F ~ and F ^ are also conjunctive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A5. A Property of the Least Fixpoint of a Conjunctive Set Transformer</head><p>We now prove that fix(F) only contains finite chains of points related by the before-after relation f. This finiteness of the chains built within fix(F) nicely supports the idea that we cannot "run" for ever by iterating F from a point of fix(F). The proof is by contradiction. We suppose that there exists a non-empty subset c of fix(F), that is c :~ 0 A c C: fix(F) (28) such that each element of c participates in an infinite chain (included in c) relative to the before-after relation f. Under these assumptions, we are going to prove now that c is necessarily empty. This contradiction indicates that there is no such set c, thus fix(F) only contains finite chains. By definition, for any element z of c, we are sure that there is an element y of c such that z and y are related through f. Thus starting from x we can continue for ever following f while remaining in c. We have thus, by definition</p><formula xml:id="formula_43">Vx.(xEc =:~ 3y.(yEc A (x,y) Ef)) (29)</formula><p>That is, equivalently (by set contraposition and according to (29))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>cO_f-lie] r</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C_ c_ -e</head><p>Consequently, we have (according to ( <ref type="formula" target="#formula_33">13</ref>))</p><p>(30)</p><formula xml:id="formula_44">fix(F) C ~<label>(31)</label></formula><p>According to (31) and the transitivity of set inclusion, it turns out that we havec C_ ~,thusc = $.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A6. Property of the Finite Chains of the Fixpoint</head><p>In this Appendix, we prove that all the finite chains of fix(F) end up in dom(f). This property will be exploited in the next Appendix.</p><p>Since fix(F) is a fixpoint, we have F(fix(F)) = fix(F). Consequently, we also have fix(F) _ F(fix(F)). Thus fix(F) is invariant under F. In other words, when, from any point x of fix(F), we follow the before-after relation f, we stay within fix(F).</p><p>As we have seen in Appendix AS, we have no infinite chain within fix(F). That is, if we start from a point za of fix(F), choosing any point x2 of f[{xl}] (x2 is thus in fix(F)), then any point x3 in f[{x~}] (x3 is thus in fix(F)), and so on, we necessarily reach a certain point xn of fix(F) where we cannot move further because f[{xn}] is empty. In other words, we eventually reach a point lying outside the domain of f, a point of dora(f). In conclusion, all the chains of fix(F) are finite and end up in dora(f).</p><p>In order to be sure that an iteration F^ a!ways terminate (whatever its point of departure) and reaches eventually dora(f), it is thus necessary and sufficient to prove that fix(F) is equal to s. It is well known (see B-Book at section 9.2.8) that for proving this, it is sufficient to show that F "decreases" a certain natural number expression. More generally, it is sufficient to prove that F "decreases" a certain quantity whose value belongs to a set that is well-founded by a certain relation.</p><p>Notice that F ^ not only reaches dom(f) when it terminates but also the various elements obtained after executing skip,, F, F ~, and so on. In order to reach exactly the elements of grd(F), it is necessary to only keep those points lying within grd(F). This can be done by means of the following set transformer:</p><formula xml:id="formula_45">F ^ ; (grd(F) ~ skip,)<label>(32)</label></formula><p>This is just Dijkstra's "do F od" command and also a special form of the WHILE construct introduced in the B-Book in section 9.2.1. However, as far as termination is concerned, both F ^ and F ^ ; (grd(F) ~ skip,) have the same termination set, namely fix(F).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AT. Reachability of any Set</head><p>Notice that, most of the time, an abstract system, whose events are collectively formalized by a conjunctive set transformer F, does not terminate. In general, such systems are constructed to run for ever. Resisting to failures that would force them to stop, is even one of their main requirements. One might then ask why we insisted so much in the preceding Appendices on this question of the termination of the iteration F ^ since, clearly, the corresponding termination set, namely fix(F), is in general empty. In what follows, we shall clarify this point.</p><p>Since an abstract system is supposed to run for ever, it cannot be characterized by a, so-called, final state that it is supposed to reach eventually. This contrasts with the classical view of a computer program supposed to deliver a certain final result. The validation of such a program is ensured by means of a proof establishing that the specified outcome is indeed reached. If such a program is formalized by means of a conjunctive set transformer S together with a termination set p (also called the pre-condition set), and if the outcome is characterized by a certain subset q, then proving p C S(q) means that, provided we start the program within p, then we are sure to obtain the outcome characterized by q. In a sense, a terminating program S is entirely characterized by all the possible permanent outcomes (such as q) we can think of.</p><p>By analogy with a program, an ever running system might be entirely characterized by all the possible temporary outcomes we can think of (this is a thesis).</p><p>In other words, reaching one of these outcomes is not synonymous with system stop as for a program. Such an outcome might be abandoned when the system proceeds further. But what must be proved is that such an outcome can be reached as often as possible, so that it is not the case that one is always outside it. Given a subset p of s (the temporary outcome in question), we study thus in this Appendix the notion of reachability of that set. And this is where the concept of termination will reappear. We are interested in characterizing the subset of s, from which we have to start, in order to be certain to temporarily (but eventually) reach p by following the before-after relation f of the set transformer F defined as above. The idea is to put (just for the reasoning) a supplementary constraint on the events F in the form of the extra guard ft. We are then led to prove that the set transformer (~ ~ F) ^ indeed terminates. In other words, allowing the system to proceed only when it is outside p, forces it to stop (hopefully thus in a state that is within p). If we want this to be always the case then we have to prove that the set fix(~ ~ F) is equal to s. More precisely, we have to prove that the following set transformer does terminate: This leads to the proof obligations (PO_3) and (PO_4) presented in section 2.4.</p><p>Nothing proves however that we have reached p (we only know that we have stopped at points that are outside the guard of p ~ F). In fact, we shall prove that in order to reach p we need the extra condition: p C dam(f). We thus consider the set transformer ~ ==~ F whose definition is (for any subset q of s):</p><p>(~ ~ F)(q) = p U F(q)</p><p>(35)</p><p>The guard of this set transformer can be calculated as follows:</p><p>grd(p ~ F) = (~ ~ F)(0) = pU F(0) = pN F(0) = p n dom(/)</p><p>As a consequence and according to what has been done above in Appendices A5 and A6, the set fix(~ ::::2z F) denotes exactly the set of points from which one can eventually reach the set p U dora(f) by following the before-after relation of ~ F (this is ~ &lt;3 f). If we want to be certain to reach p, it is thus sufficient to require that dora(f) is included in p, that is, alternatively: C_ dam(f) <ref type="bibr">(36)</ref> This corresponds to the last proof obligations of (90_3) and (PO_4) obtained in section 2.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A8. Refining the Reachability Condition</head><p>In this Appendix, we shall study the problem of the refinement of the reachability studied in the preceding Appendix. We shall thus consider that the set transformer F, defined as above, is now refined to a certain set transformer G built on a set t, that is:</p><formula xml:id="formula_46">C 9 ~(t) -~ ~(t)<label>(37)</label></formula><p>We also suppose that the termination set of G is trivial, that is:</p><formula xml:id="formula_47">C(t) = t (<label>38</label></formula><formula xml:id="formula_48">)</formula><p>This refinement is performed by means of a certain total refinement relation rfromttos:</p><formula xml:id="formula_49">r 9</formula><p>A dam(r)=t (39)</p><p>The set transformer F is said to be refined by G by means of the refinement relation r when the following condition holds between their respective beforeafter relations f and g, and between their termination sets (see B-Book in section 11.2.4) r-1 ;gC_f;r-1 (40)</p><p>r-1[pre(F)] C_ pre(e) (41)</p><p>Notice that condition (41) holds trivially. This is because we supposed that pre(F) is equal to s (this is condition ( <ref type="formula" target="#formula_25">6</ref>)), thus r-l[pre(F)] is equal to dom(r), that is t (since r is total according to (3g)), which is certainly included in pre(G) since pre(G) is equal, by definition, to G(t), which was supposed to be equal to t (this is (38)). The set p whose reachability was studied in the previous Appendix is now transformed into the set r-lip] (the image of p through r-i). So that the reachability of r-1 ~v] will now be ensured within the termination set of the set transformer (r -l[p] ~ G)^. What remains to be proved is that the reachability of p in the abstraction indeed ensures that of r-i[p] in the concrete world. For this, we first have to prove that r-l[p] ~ G is a refinement of ~ ~ F. Formally, we have to prove (under the conditions (38) and (39)): </p><p>As we know (according to Appendix A6), the finite chains of fix(r-lip] ~ G) all end up in the set r-lip] U dom(g). In order for the concrete set r-lip] to be reached, we have to prove that dora(g) is included in r-lip], alternatively r-~[p] C_ dora(g). In order to ensure that this is the case, we claim that it is sufficient to have the following extra condition:</p><p>r[dom(g)] C_ dora(f) (44)</p><p>It then remains for us to prove the following (notice that we have supposed condition (36) stating that the set p is indeed reached by the repeated execution ofp =:=&gt; F):</p><p>p C_ dom(f) A r[dom(g)] C_ dom(f) =;&gt; r-lip] C_C -dorn(g) (45)</p><p>The proof of (45) is left to the (favorite theorem prover of the) reader (you will notice that the hypothesis concerning the totality of the refinement relation r is fundamental).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>:= 0, 0 {I c, d:EN1 xN1 EVENTS evt_x ~ SELECT c &gt; 0 THEN x, c :----x -}-1, c--1 {I d :E I~1 END ; evt_y ~ SELECT d &gt; 0 THEN y, d := y + 1, d-1 II c :E N1 END END</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>x and assign it to both variables a and b: ANY x WHERE X E 1~ THEN a, b :---~ x, x END END The idea is to now refine this system as follows: the concrete event evt_l only assigns x to a. The variable b ~, the refined version of b, is set to 0. This new version of evt_l is only enabled when b ~ is equal to a. A new event, named evt_2, gradually transports the content of a to b' by incrementing b ~ while it is strictly smaller than a. The gluing invariant (b' = a) ~ (b' = b) precisely states at which moment the abstract b and the concrete b' do agree: this is indeed when the value of b' has reached that of a. =a =~ b'=b) VARIANT a --b I INITIALIZATION a, b I :--0, 0 EVENTS evt_l ~ ANY X WHERE x E I~ /N b' = a THEN a, b' := x, 0 END ; evt_2 ----~ SELECT b' &lt; a THEN b' := b' + 1 END It is not difficult to prove that the new version of evt_l refines its abstract counterpart, and that evt_2 refines skip. The proof obligations concerning the VARIANT clause reduce to the following, which holds trivially: aEN A b'E(0..a) :=r a-b'El~I aEl~ A b'E (0..a) A b'&lt;a :=~ a-(b'+l)&lt;a-b'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>is, in fact, a proof obligation stipulating that a loop of the form below indeed terminates (where I stands for the invariant of our component): SELECT P THEN WHILE -'1Q Do CHOICE .T" 1 OR "'" OR .Tn END INVARIANT IAJ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>second construct is, as the former, a proof obligation stipulating that a loop of the form below indeed terminates:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>:</head><label></label><figDesc>Ix 9 x E 1~ ~:~ true And in the concrete system grd(evt_l) ~ 3x-(x E N A b' = a) r b' = a grd(evt_2) r b' &lt; a The progress condition reduces to the following (which holds trivially): b'e(0..a) ~ (b'=a) V(b'&lt;a)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>= l 1 U {t ~ rl(t)} END ENDIt is interesting to compare this event with its abstraction:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>(r1 --ll) LEADSTO X ~ ran(r1 --ll) VARIANT [((1..n) • 1Cl} &lt;a(rl -ll)-X)(x)-Cl, n-card(r1 -/1)]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>difficult to prove that it refines its abstraction (the witness for t being clearly cl + w): request ANY t, y WHERE t E 1~ --dorn(rl -/1) A y 9 (1...) -ran(r1 --ll) cl &lt;t THEN rl := rl U {t ~-~ y} END A Next is the proposed refinement of the event serve: = ll U {t I--). rl(t)} END END</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>tail(q3) END Again, it can fruitfully be compared to its abstraction: (w2 ~ {t}) ; minus(t) END END</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>f4 -~ Ax.(x~l..14-1ll4-x) tJ Ax.(x~14..nll4+x-2) g4 -~ Ax.(z~14+l..nlx-14) tJ ~z.(z~l..1412n-(14+x))We put them together in a function h4 parametrized by the direction of the lift:I h4 -Q {down~-+f4, up~-+g4} IIt remains for us to write our main invariant stating that w4 is always included (because not all requests are present in general) in h4(d4):I w4 ~h4(d4) IIt is now very simple to propose the following refinement for request request ANY y WHERE y E (1.. n)--dom(w4) THEN w4 := w4 U {y ~ h4(d4)(y) } END This can be fruitfully compared with its abstraction (clearly the witness for w is h4(d4)(V)):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>F~ ~ F ~ F 2 ~</head><label>2</label><figDesc>... F^= skip, FI F ~ F 2 ~ ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>(</head><label></label><figDesc>~ ===~ F) ^ ; (p ==~ skips) (33) This set transformer is exactly (see B-Book in section 9.2.1): WHILE p DO F END (34)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>This proof is left to the (favorite theorem prover of the) reader. A consequence of this refinement is that the iterate (~ ~ F)^ is refined to the iterate (r-lip] =:::# G) ^ (according to the monotonicity of refinement with respect to opening, see B-Book section 11.2.4). From this, we can deduce (again B-Book section 11.2.4) that the image of the termination set of (~ ==~ F)^ is included into the termination set of (r-l[p] --~ G) ^, that is r-1[fix(~ ~ F)] C_: _ fix(r-lip] ~ G)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments: We thank D. M6ry, L. Lamport, M. Butler, and B. Legeard and his colleagues for a number of discussions and comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDICES</head><p>In the following Appendices, we present a formal model of certain aspects of abstract systems. The r61e of this model is essentially to formalize the concept of "teachability" as described in the linguistic construct LEADSTO introduced in section 2.4 of the main text. In doing so, we shall be able to justify the proof obligations presented in the paper.</p><p>In Appendix A1, we recall the definition and main properties of conjunctive set transformers. In Appendix A2, we quickly present and define the main classical operators applicable to conjunctive set transformers. We recall that these operators maintain conjunctivity. In Appendix A3, we remind the definitions and main properties of the fixpoints of conjunctive set transformers. This allows us to introduce (in Appendix A4) more operators dealing with the concept of iteration. We show that these operators also maintain conjunctivity. We indicate how the least fixpoint of a conjunctive set transformer is connected with the "termination" of the iteration. In Appendices A5 and A6 we give more properties of the least fixpoint, properties supporting this notion of termination. In Appendix A7 we define the notion of reachability of a certain set. This is based on the termination (fixpoint) of a certain conjunctive set transformer. In Appendix A8, we study how the "classical" refinement influences reachability. In Appendix A9, we study the main assumptions concerning the new events that may be introduced in the refinement of an abstract system. Finally, in Appendix A10, our study culminates with the refinement of reachability in the presence of new events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A1. Conjunctive Set Transformers</head><p>The events of an abstract system are formally described by means of conjunctive set transformers (see B-Book in section 6.4.2). Let F be such a set transformer built on a set s (this is the "state" of our abstract system). We have thus:</p><p>In what follows, we shall make the frequent abuse of language consisting in identifying an event with its set transformer. Given a subset p of s, the set F(p)</p><p>denotes, as we know, the largest subset of s in which we have to be, in order for the "event" formalized by F to "terminate" in a state belonging to p. The conjunctivity property of our set transformer F is defined as follows for each non-empty set c~ of subsets of s:</p><p>When specialized to a set cr with two elements, the above condition reduces to the following where p and q are two subsets of s:</p><p>Condition (44) can be transformed equivalently as follows, by set contraposition:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A9. Formal Hypotheses and Results concerning the New Events</head><p>In the next Appendix, we are going to study the problem of reachability of a certain set p when the set transformer F is refined to a concrete set transformer G by means of a certain refinement relation r, as it was studied in Appendix A8, except that this time we shall suppose that we have some extra events formalized by a set transformer H refining skip, and "terminating".</p><p>In this Appendix, we are going to formalize the relevant hypotheses concerning such new events and establish a simple result about them. More precisely, all our extra events are together formalized by means of a set transformer H defined on the set t as is G in (37):</p><p>We also suppose, as usual that H(t) is equal to t. The before-after relation rel(H) associated with H is h. Since H is supposed to refine skips by means of the refinement relation r, we have thus the following, as a special case of the condition (40): r -1 ;hCr -1</p><p>Moreover, we suppose that H ^ always "terminates", this is formalized by stating that the fixpoint of H is exactly the set t:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>fix(H) = t (49)</head><p>This is ensured in the main text by the proof obligation (PO_I). From this, we shall now prove that H ^ indeed refines skip,. The refinement condition to be proved (see B-Book page 520) reduces to:</p><p>For proving this it suffices to prove the following for any natural number n (since h n h* is equal to U,~e,v</p><p>)</p><p>This can easily be proved by mathematical induction, using (48). By extension, it is easy to prove that the set transformer (r-lip] ~ H) ^ also refines skip,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AIO. Refining the Reachabillty Condition in the Presence of New Events</head><p>In this Appendix, we shall prove the central result of our study. It essentially says that, as far as teachability is concerned, a set transformer F can be "simulated" by the set transformer G ~ H where G refines F, and where the set transformer H (as described in Appendix A9) formalizes the new events refining skip,.</p><p>We have written "simulated" rather than "refined". In fact, the simple set transformer r-lip] ~ (G N H) does not refine ~ ~ F. What we shall prove is that (r-lip] ~ (G ~ H)) ^ refines (~ ==~ F) ^. In other words, the repeated "execution" of ~ ~ F is refined by the repeated "execution" of r-lip] (G ~ H). The new events, formalized by H, do not induce any spoiling side effects on the global behavior of our system.</p><p>Let us define F', G' and H' as follows:</p><p>(54)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>that is (H '^ ; G')^(H'^(a)) C (G' ~ H')^(a)</head><p>that is equivMently</p><p>Let q be defined as follows q ~-fix(a I (G' I] H'))</p><p>In order to prove (57), it is sufficient to prove the following (B-Book section 3.2.2):</p><p>that is (since H t~ is conjunctive))</p><p>H'^(anG'(q)) C_ q (51)</p><p>For this it is sufficient to prove (again B-Book section 3.2.2)</p><p>(56)</p><p>We which is obvious since q = a n G'(q) fq H'(q) according to (58).</p><p>We have eventually proved that (~ ~ F) ^ is refined by (r -1 [19] ~, G ~ H) ^ . As above in Appendix AS, we now have to find the condition under which the set r-lip] is reached. By an argument that is very similar to the one developed in Appendix A8, this condition is an extension of condition ( <ref type="formula">45</ref> </p><p>This is essentially a formal setting of the proof obligation PO_5 presented in the main text.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The B-Book: Assigning Programs to Meanings</title>
		<author>
			<persName><forename type="first">J.-R</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Extending B Without Changing it (for Developing Distributed Systems)</title>
		<author>
			<persName><forename type="first">J.-R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First B Conference</title>
		<meeting><address><addrLine>Nantes</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Specification and Design of a Transmission Protocol by Successive Refinements Using B</title>
		<author>
			<persName><forename type="first">J.-R</forename><surname>Abrial</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mussat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Methods in Program Devel</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Schieder</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Proof Rules and Transformations Dealing with Fairness</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-R</forename><surname>Olderog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J R</forename><surname>Back</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kurki-Suonio</surname></persName>
		</author>
		<title level="m">Decentralization of Process Nets with Centralized Control. 2nd ACM SIGACT-SIGOPS Symp. on Principles of Distributed Computing</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Stepwise Refinement of Communicating Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Butler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Parallel Program Design: A Foundation</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Chandy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Misra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">Specification Case Study</title>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Hayes</surname></persName>
		</editor>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Home</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Temporal Logic of Actions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SRC Report</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Adequate Proof Principles for lnvariance and Liveness Properties of Concurrent Systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Udaya Shankar An Introduction to Assertional Reasoning for Concurrent Systems</title>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>ACM Computing Survey</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Steria. Atelier B Version</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
