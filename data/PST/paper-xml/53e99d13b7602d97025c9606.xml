<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Orchestrating the Execution of Stream Programs on Multicore Platforms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Manjunath</forename><surname>Kudlur</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Advanced Computer Architecture Laboratory</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<postCode>48109</postCode>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
							<email>mahlke@umich.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Advanced Computer Architecture Laboratory</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<postCode>48109</postCode>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Orchestrating the Execution of Stream Programs on Multicore Platforms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5715B8B51D45AF6673D891CDCBFB5E98</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T03:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.3.4 [Programming Languages]: Processors Compilers General Terms Languages</term>
					<term>Algorithms</term>
					<term>Performance StreamIt</term>
					<term>Cell processor</term>
					<term>multicore</term>
					<term>stream programming</term>
					<term>software pipelining</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>While multicore hardware has become ubiquitous, explicitly parallel programming models and compiler techniques for exploiting parallelism on these systems have noticeably lagged behind. Stream programming is one model that has wide applicability in the multimedia, graphics, and signal processing domains. Streaming models execute as a set of independent actors that explicitly communicate data through channels. This paper presents a compiler technique for planning and orchestrating the execution of streaming applications on multicore platforms. An integrated unfolding and partitioning step based on integer linear programming is presented that unfolds data parallel actors as needed and maximally packs actors onto cores. Next, the actors are assigned to pipeline stages in such a way that all communication is maximally overlapped with computation on the cores. To facilitate experimentation, a generalized code generation template for mapping the software pipeline onto the Cell architecture is presented. For a range of streaming applications, a geometric mean speedup of 14.7x is achieved on a 16-core Cell platform compared to a single core.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Multicore systems have become the industry standard from highend servers, down through desktops and gaming platforms, and finally into handheld devices. Example systems include the Sun UltraSparc T1 that has 8 cores <ref type="bibr" target="#b13">[14]</ref>, the Sony/Toshiba/IBM Cell processor that consists of 9 cores <ref type="bibr" target="#b9">[10]</ref>, the NVIDIA GeForce 8800 GTX that contains 16 streaming multiprocessors each with eight processing units <ref type="bibr" target="#b18">[19]</ref>, and the Cisco CRS-1 Metro router that utilizes 192 Tensilica processors <ref type="bibr" target="#b4">[5]</ref>. Intel and AMD are producing quad-core x86 systems today and larger systems are on their near term roadmaps. Putting more cores on a chip increases peak perfor-Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PLDI'08, June 7-13, 2008, Tucson, Arizona, USA. Copyright c 2008 ACM 978-1-59593-860-2/08/06. . . $5.00 mance, but has shifted the burden onto both the programmer and compiler to identify large amounts of coarse-grain parallelism to effectively utilize the cores. Highly threaded server workloads naturally take advantage of more cores to increase throughput. However, the performance of single-thread applications has dramatically lagged behind. Traditional programming models, such as C, C++, and Fortran, are poorly matched to multicore environments because they assume a single instruction stream and a centralized memory structure.</p><p>The stream programming paradigm offers a promising approach for programming multicore systems. Stream languages are motivated by the application style used in image processing, graphics, networking, and other media processing domains. Example stream languages are StreamIt <ref type="bibr" target="#b25">[26]</ref>, Brook <ref type="bibr" target="#b2">[3]</ref>, CUDA <ref type="bibr" target="#b18">[19]</ref>, SPUR <ref type="bibr" target="#b27">[28]</ref>, Cg <ref type="bibr" target="#b17">[18]</ref>, and Baker <ref type="bibr" target="#b3">[4]</ref>. Stream languages enable the explicit specification of producer-consumer parallelism between coarse grain units of computation. For this work, we focus on StreamIt where a program is represented as a set of autonomous actors (called filters in StreamIt) that communicate through first-in first-out (FIFO) data channels <ref type="bibr" target="#b25">[26]</ref>. StreamIt implements the synchronous dataflow model <ref type="bibr" target="#b14">[15]</ref> in which the number of data samples produced and consumed by each actor are specified a priori. During program execution, actors fire repeatedly in a periodic schedule <ref type="bibr" target="#b5">[6]</ref>. Each actor has a separate instruction stream and an independent address space, thus all dependences between actors are made explicit through the communication channels. Compilers can leverage these characteristics to plan and orchestrate parallel execution.</p><p>Stream programs contain an abundance of explicit parallelism. The central challenge is obtaining an efficient mapping onto the target architecture. Often the gains obtained through parallel execution can be overshadowed by the costs of communication and synchronization. Resource limitations of the system must also be carefully modeled during the mapping process to avoid stalls. Resource limitations include finite processing capability and memory associated with each processing element, interconnect bandwidth, and direct memory access (DMA) latency. Lastly, stream programs contain multiple forms of parallelism that have different tradeoffs on when they should be exploited. It is critical that the compiler leverage a synergistic combination of parallelism, while avoiding both structural and resource hazards.</p><p>In this work, we propose a modulo scheduling algorithm for mapping streaming applications onto multicore systems, referred to as stream graph modulo scheduling or SGMS. Modulo scheduling is traditionally a form of software pipelining applied at the instruction level <ref type="bibr" target="#b21">[22]</ref>. We apply the same technique on a coarse-grain stream graph to pipeline the actors across multiple cores. The objective is to maximize concurrent execution of actors while hiding communication overhead to minimize stalls. SGMS is a phase-ordered approach consisting of two steps. First, an integrated actor fission and partitioning step is performed to assign actors to each processor ensuring maximum work balance. Parallel data actors are selectively replicated and split to increase the opportunities for even work distribution. This first step is formulated as an integer linear program. The second step is stage assignment wherein each actor is assigned to a pipeline stage for execution. Stages are assigned to ensure data dependences are satisfied and inter-processor communication latency is maximally overlapped with computation.</p><p>Our target platform is the Cell architecture, which represents the first tangible platform that is a decoupled multicore where there is no shared cache so code-data colocation is necessary <ref type="bibr" target="#b9">[10]</ref>. SGMS is part of a fully automatic compilation system, known as StreamRoller, that maps StreamIt applications onto a Cell system. The SGMS schedule is output in the form of a C template that executes an arbitrary software pipeline. This template, combined with C versions of the actors, are compiled with the host compiler to execute on the target system. For our experiments, we use an IBM QS20 Blade Server running Fedora Core 6.0. It is a Cell system equipped with 16 3.2GHz synergistic processing engines (SPEs) on 2 chips, and 1 GB RAM.</p><p>Our work has the most overlap with the coarse-grained scheduling used in the StreamIt compiler <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b5">6]</ref>. The StreamIt scheduler consists of two major phases. First, a set of transformations are applied on the stream graph to combine and split actors to ensure the computation granularity is balanced. Second, a coarse-grain software pipeline is constructed by iteratively applying a greedy partitioning heuristic that assigns filters to processors. Each filter is considered in order of decreasing work and assigned to the processor with the least amount of work so far. To minimize synchronization, the partitioning algorithm is wrapped with a selective fusion pass that repeatedly fuses the two adjacent filters that have the smallest combined work. This process reduces communication overhead by forcing the combined filters to reside on the same processor.</p><p>Our work differs along two primary dimensions. First, the StreamIt compiler targets the Raw processor that has a traditional cache on each processor <ref type="bibr" target="#b24">[25]</ref>. In <ref type="bibr" target="#b5">[6]</ref>, intermediate buffers needed by the software pipeline of the stream graph are stored off to the off-chip DRAM banks, and a separate communication stage is introduced between steady states to shuffle data between banks. Our formulation of pipeline stage assignment explicitly models DMA overhead and proactively overlaps data transfers for future iterations with computation on the current iteration. Second, we formulate the partitioning and actor fission step as an integer linear program rather than employing iterative partitioning and fusing to generate a schedule. Our approach combines packing and fission of actors, data transfers, and resource constraints to generate more balanced and higher quality schedules for architectures such as Cell.</p><p>This paper offers the following contributions:</p><p>• The design, implementation, and evaluation of stream graph modulo scheduling for efficiently mapping streaming applications onto decoupled multicore systems.</p><p>• An integer linear program formulation for integrated actor fission and partitioning to assign actors to processing elements maximizing workload balance.</p><p>• A pipeline stage assignment algorithm that proactively overlaps DMA transfers with computation to minimize stalls.</p><p>• A fully automated compilation system for Cell capable of generating performance results on real hardware.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background and Motivation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">StreamIt Language</head><p>StreamIt <ref type="bibr" target="#b25">[26]</ref> is an explicitly parallel programming language that implements the synchronous data flow (SDF) <ref type="bibr" target="#b14">[15]</ref> programming model. Actors are specified by parametrized classes, which are similar to Java classes. They can have local variables corresponding to local actor state, and methods that accesses these variables. An actor can have both read-only and read-write state. A stateful actor that modifies local state during the work function cannot be parallelized as the next invocation depends on the previous invocation. However, the SDF semantics allow the parallel replication of stateless actors. A special method called work is reserved to specify the work function that is executed when the actor is invoked in steady state. The stream rates (number of items pushed and popped on every invocation) of the work functions are specified statically in the program.</p><p>The stream graph is constructed by instantiating objects of the actor classes. StreamIt provides ways to construct specific structures like pipeline, split-join, and feedback loop. Using these primitives, the entire graph can be constructed hierarchically. Note that feedback loops provide a means to create cycles in the stream graph. Feedback loops are naïvely handled by fusing the entire loop into a single actor. More intelligent ways to handle nested loops is beyond the scope of this paper. Further, the feedback loop pattern does not appear in any of the benchmarks that we evaluate. Hence, the rest of the paper assumes an acyclic stream graph. Figure <ref type="figure" target="#fig_0">1</ref> shows an example StreamIt program and its corresponding stream graph. StreamIt provides the peek primitive to the programmer, which can be used to non-destructively read values off the input channel. Note that this is only for convenience, and does not make StreamIt deviate from the pure SDF model. This is because a program with peek can always be reimplemented with just pushes and pops, and some local state that holds a subset of values seen so far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Cell Broadband Architecture</head><p>Our compilation target in this paper is the Cell Broadband Engine (CBE) shown in Figure <ref type="figure">2</ref>. The CBE is a heterogeneous multicore system, consisting of one 64bit PowerPC core called the Power Processing Element (PPE) and eight Synergistic Processing Elements (SPEs). Each SPE has a SIMD engine called the synergistic processing unit (SPU), 256 KB of local memory and a memory flow control (MFC) unit which can perform DMA operations to and from the local stores independent of the SPUs. The SPUs can only access the local store, so any sharing of data has to be per-  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Motivation</head><p>Stream programs are replete with pipeline parallelism. An actor can start working on the next data item as soon as it is done with the current item, even when other actors in the downward stream of the graph are still working on the current item. In a multiprocessor environment, by running different actors on different processors and overlapping iterations, the outer loop can be greatly sped up. Trying to exploit pipeline parallelism requires (1) a good distribution of work among the available processors and (2) managing the communication overhead resulting because of producers and consumers running on different processors.</p><p>The partitioning problem. Figure <ref type="figure">3</ref> shows the theoretical speedup possible for a set of unmodified stream programs for 2 to 64 processors. 1 The actors present in the programmer-conceived stream graph are assigned to processors in an optimal fashion such that the maximal load on any processor is minimized. Speedup is calculated by dividing the single processor runtime by the load on the maximally loaded processor. The programmer-conceived 1 More details of the applications are provided in <ref type="bibr">Section 4.</ref> stream graph has ample parallelism that can be exploited on up to 8 processors. Beyond 8 processors, the speedup begins to level off. Most benchmarks just do not have enough actors to span all processors. For example, fft has only 17 filters in its stream graph, therefore no speedup is possible beyond 17 processors. The other reason is that work is not evenly distributed across the actors. Even though the computation has been split into multiple actors, the programmer has no accurate idea of how long an actor's work function will take to execute on a processor when coding the function. This combined with the fact that work functions are indivisible units leads to less scaling on 16 or more processors. For example, in the vocoder benchmark, the longest running actor contributes to 12% of the work, thus limiting the theoretical speedup to 100 12 = 8.3. Most of the benchmarks are completely stateless, i.e., all actors are data parallel <ref type="bibr" target="#b5">[6]</ref>. In fact, only mpeg2, vocoder, and radar have actors that are stateful. Data parallel actors can be replicated (or fissed) any number of times without changing the meaning of the program. The longest running actor in vocoder benchmark is stateless, and can be fissed to reduce the amount of work done in a single actor. Fissing data parallel actors not only allows work to span more processors, it also allows work to be evenly distributed across processors by making the largest indivisible unit of work smaller.</p><p>Even though data parallel actors provide ample opportunity to divide up work evenly across processors, it is not obvious how many times an actor has to be fissed to achieve load balance. An actual partitioning has to be performed to decide if actors have been fissed enough number of times. On the other hand, a good partitioning is achieved only when actors have been fissed into suitably small units. This circular cause and consequence warrants an integrated solution that considers the problems of fission and partitioning in a holistic manner.</p><p>Communication overhead. When an actor that produces data and the actor(s) that consume that data are mapped to different processors, the data must be communicated to the consumers. In our implementation on the Cell system, actors are mapped to the SPEs that have disjoint address spaces. Therefore, communicating data to consumers is through an explicit DMA. When such transfers are not avoided, or not carefully overlapped with useful work, the overhead could dominate the execution times.</p><p>The next section addresses the problem of partitioning and communication overhead. First, an integrated fission and partitioning method is presented that fisses the actors just enough to span all processors, and also obtain an even work distribution. Next, the stage assignment step divides up the actors into pipeline stages in which all communication is overlapped with computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Stream Graph Modulo Scheduling</head><p>This section describes our method for scheduling a stream graph onto a multicore system. The objective is to obtain a maximal throughput software pipeline taking both the computation and communication overhead into account. The stream graph modulo scheduling (SGMS) algorithm is divided into two phases. The first phase is an integrated fission and processor assignment step based on an integer linear program formulation. It fisses data parallel actors as necessary to get maximal load balance across the given number of processors. The second phase assigns actors to pipeline stages in such a manner that all communication is overlapped with computation on the processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Integrated Fission and Processor Assignment</head><p>Consider a dataflow graph G = (V, E) corresponding to a stream program. Let |V| = N be the number of actors. Let the basic repetition vector be r, where r i specifies the number of times v i is executed in a static schedule. Let t(v i ) be the time taken to execute r i copies of v i . The rest of the section assumes r i executions of v i as the basic schedulable unit. Given P processors, a software pipeline needs some assignment of the actors to the processors. The throughput of the software pipeline is determined by the load on the maximally loaded processor. As shown in Section 2, even an optimal assignment on the unmodified programmer conceived stream graph does not provide linear speedups beyond 8 processors. Some data parallel actors need to be fissed into two or more copies so that there is more freedom in distributing work evenly across the processors. For each actor in the stream graph, the following ILP formulation comes up with the number of times the actor has to be fissed, and an assignment of each copy of the actor to a processor. The objective function is the maximal load on any processor, which is minimized.</p><p>A set of 0-1 integer variables a i, j,k,l is introduced for every actor v i . The meaning of the four suffixes is explained below:</p><p>• i identifies the actor.</p><p>• j identifies the version of the actor that would appear in the final graph. For every actor v i , the formulation considers multiple versions of the actor. Version 0 of the actor is fissed 0 times (no copies made), version 1 of the actor is fissed once so that two copies of the actor are considered for scheduling, and so on.</p><p>• k identifies the copy of the jth version of the actor v i . Version 0 has only one copy. Version 1 has 2 copies of the actor and a splitter and joiner. The splitter and joiner have to run on some processor, therefore, they are considered as independent schedulable units. Thus there are ( j + 3) schedulable actors in the jth version. We have either 0 ≤ k &lt; j + 3 when j ≥ 1, or k = 0 when j = 0.</p><p>• l identifies the processor to which the kth copy is assigned.</p><p>Let Q be the maximum number of versions considered for an actor. Actors with carried state cannot be fissed at all and Q = 1 for such actors. On the other hand, stateless actors can be fissed any number of times. The choice of Q affects the load balance obtained from the processor assignment. Choosing a low value for Q would inhibit the freedom of distributing copies of an actor to many processors. We observed that the maximum number of copies of an actor that appear in the best partitions is always less than P for all benchmarks. Therefore, in the experiments Q was set to P, the number of processors under consideration. The following equation ensures that a copy of an actor is either assigned to one processor or not assigned to any processor at all, implying that a different version was chosen.</p><formula xml:id="formula_0">P l=1 a i, j,k,l ≤ 1 ∀i, 0 ≤ j &lt; Q, 0 ≤ k &lt; j + 3 (1)</formula><p>When a copy of an actor is indeed assigned to a processor, all other copies in the same version have to be assigned to processors, and all other versions should not be assigned to processors. To ensure this, a set of Q indicator variables, b i,q , 0 ≤ q &lt; Q, are introduced for every actor v i . These indicator variables are 0-1 variables which serve two purposes. First, they indicate which version of the actor was chosen. Second, by virtue of being either 0 or 1 only, ensure that either all copies of a version are assigned to processors, or no copy is assigned to any processor. The following set of equations show the relation between the indicator variables b i,q and the assignment variables a i, j,k,l .  </p><formula xml:id="formula_1">P l=1 a i,0,0,l -b i,0 = 0 ∀i<label>(2)</label></formula><formula xml:id="formula_2">P l=1 j+3 k=0 a i, j,k,l -( j + 3) -b i, j ≤ M × b i, j ∀i, 1 ≤ j &lt; Q (3) P l=1 j+3 k=0 a i, j,k,l -( j + 4) -b i, j ≥ -M + M × b i, j ∀i, 1 ≤ j &lt; Q (4)</formula><p>M in Equations 3 and 4 is a constant that is larger than the upper bound of P l=1 j+3 k=0 a i, j,k,l . Note that Equations 3 and 4 are standard ILP tricks to ensure that a linear sum either equals a constant or is zero.</p><p>In this case, the sum P l=1 j+3 k=0 a i, j,k,l either has to be ( j + 3), denoting that all copies of a version were assigned to some processor, or has to be 0, denoting that none of the copies were assigned to any processor. b i, j conveniently takes on 1 or 0, respectively. The following equation ensures that one and only one version of an actor is chosen in the final assignment.</p><formula xml:id="formula_3">Q j=0 b i, j = 1 ∀i<label>(5)</label></formula><p>Figure <ref type="figure" target="#fig_3">4</ref> illustrates the above set of equations for an example actor.</p><p>Q is chosen to be 3 in the example. Three versions of the actor are shown in the figure. The labels on the nodes indicate the version number and copy number. The last equation b</p><formula xml:id="formula_4">1,0 + b 1,1 + b 1,2 =</formula><p>1 ensures that only one version is chosen, and the rest of the equations ensure that all copies of the chosen version are assigned to processors.</p><p>To determine the quality of an assignment, the amount of work assigned to each processor has to be calculated. The following equation computes the work (in terms of time) done by a copy of an actor.</p><formula xml:id="formula_5">W i, j,k,l =                  t(v i ) if j = 0 t(v i ) j+1 + if j &gt; 1 and k &lt; j+1 splitter work(v i ) if j &gt; 1 and k = j+1 joiner work(v i ) if j &gt; 1 and k = j+2 (6)</formula><p>Version 0 of the actor is same as the original actor. Therefore, the work done by version 0 is the original work t(v i ). In version 1, there are 2 copies of the actor that do half the work as the original actor. Note that there is a small overhead of when fissing actors which peek more elements than they pop. This is due to the introduction of a decimation stage on each copy which just pops and ignores part of the data to maintain correct semantics. In addition, there is additional work done by the splitter and joiner in version 1. The last three cases in Equation 6 compute the work done by copies of the actor, splitter, and joiner. Note that the work done in splitter and joiner depends on the implementation. However, they both are constants given the number of items popped by the corresponding actor. For some assignment of actors to processors, the following equation computes the total work T W p that gets assigned to a processor p.</p><formula xml:id="formula_6">T W p = N i=1 Q j=0 valid k a i, j,k,l × W i, j,k,p<label>(7)</label></formula><p>The processor p with maximum work T W p assigned to it constitutes the bottleneck processor, and thus T W p denotes the inverse of the throughput of the overall pipeline. We borrow the terminology from operation-centric modulo scheduling used in compiler backends, and use the term Initiation Interval (II) to denote the inverse of the throughput. The following set of equations compute II from the T W p 's.</p><formula xml:id="formula_7">T W p ≤ II 1 ≤ p ≤ P (8)</formula><p>The ILP program that minimizes II subject to constraints given by Equations 1 to 8 provides the following information.</p><p>• The value of j for which b i, j = 1 identifies the version of the actor chosen. Note that Equation <ref type="formula" target="#formula_3">5</ref>ensures that only one of the b i, j 's have the value 1.</p><p>• Given a copy k of the chosen version j, the set of values a i, j,k,l that are 1 identify the processors to which the copy is assigned. For example, if a i, j,k,4 = 1, then the kth copy the actor is assigned to processor 4.</p><p>The above formulation does not account for any communication overhead. The data produced by an actor has to be communicated to a consuming actor if that actor was assigned to a different processor.</p><p>The following section shows how all such communication can be hidden, thus achieving the exact throughput obtained from the processor assignment step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Stage Assignment</head><p>The processor assignment obtained by the method described in the previous section provides only partial information for a pipeline schedule. Namely, it specifies how actor executions are overlapped across processors. It does not specify how they are overlapped in time. To realize the throughput, which is the load on the maximally loaded processor obtained from processor assignment, all actors assigned to a processor including the necessary DMAs have to be completed within a window of II time units. The only goal of processor assignment step is load balance, therefore it assigns actors to different processors without taking any data precedence constraints into consideration. An actor assigned to a processor could have its producer assigned to a different processor, and have its consumer assigned to yet another processor. To honor data dependence constraints and still realize the throughput obtained from processor assignment, the actor executions corresponding to a single iteration of the entire stream graph are grouped into stages. Note that the concept of stage is adapted from traditional VLIW modulo scheduling. Across all processors, stages of a single iteration execute sequentially, thus honoring data dependences. Within a single processor, no stages are active at the beginning of execution. During the initial few iterations, stages are activated sequentially, thus filling up the pipeline and enabling executions of data dependent actors belonging to earlier iterations concurrently with actors from later iterations. In steady state, all stages are active on a processor, thus realizing the throughput obtained from processor assignment. The pipeline is drained by deactivating stages during the final few iterations.</p><p>The overarching goal of the stage assignment step is to overlap all data communication (DMAs) between actors. To achieve this, the stage assignment step considers the DMAs as schedulable units.</p><p>To honor data dependences and ensure DMAs can be overlapped with actor executions, certain properties are enforced on the stage numbers of actors. Consider a stream graph G = (V, E). The stage to which an actor v i is assigned to is denoted by S i . In addition, the processor to which v i is assigned to is denoted by p i . The following rules enforce data dependences and ensure DMA overlap.</p><p>• (v i , v j ) ∈ E ⇒ S j ≥ S i , i.e., the stage number of a consuming actor should come after the producing actor. This is to preserve data dependence.</p><p>• If (v i , v j ) ∈ E and p i p j , then a DMA operation must be performed to get the data from p i to p j . The DMA operation is given a separate stage number S DMA . As shown in Figure <ref type="figure" target="#fig_4">5</ref>, the inequality S i &lt; S DMA &lt; S j is enforced between the stages of the different actors and the DMA operation. The DMA operation is separated from the producer by at least one stage, and similarly, the consumer is separated from the DMA operation by one stage. This ensures decoupling, and allows the overlap of the producer and the DMA, as well as the DMA and the consumer.</p><p>• Within the set of actors assigned to some processor p, the inequality S j =s t(v j ) ≤ II, ∀s is enforced. In other words, the sum of execution times of actors (S j ) assigned to a stage (s) should be less than the desired II. This is the basic modulo scheduling constraint, which ensures that the stages are not overloaded, and that a new iteration can be initiated every II time units.</p><p>A simple data flow traversal of the stream graph is used to assign stages to actors as shown in Algorithm 1. For each actor in dataflow order, the FindStage procedure assigns a stage to the actor. The for loop beginning on the line marked 1 computes the maximum stage of the producers of the actor under consideration. If any of the producers are assigned to a different processor, the earliest stage considered for actor is maxstage + 2, which leaves room for DMAs in maxstage + 1. Otherwise, the actor could be placed on maxstage. The while loop beginning on the line marked 4 finds a stage number later than stage on which the load is less than the II obtained from processor assignment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Code Generation for Cell</head><p>This section describes a code generation strategy to implement the modulo schedule obtained for a stream program on a Cell system. The target of our code generation are the multiple SPEs, as opposed to the PPE. This section describes the general code generation schema, the buffer allocation strategy, and provides a complete example.</p><p>Code generation schema. The SPEs are independent processors with disjoint address spaces. The general code generation strat- Figure <ref type="figure" target="#fig_5">6</ref> shows pseudo C code that runs on each SPE thread. It mimics the kernel-only <ref type="bibr" target="#b22">[23]</ref> code of modulo scheduling for a VLIW processor. The array stage functions similar to the staging predicate, and its size (N) is the maximum number of stages. The main loop starts off with only the first stage active. The if conditions that test different elements of stage ensure only actors assigned to a particular stage are executed. The last part of the loop shifts the elements of the array stage to the left, which has the effect of filling up the software pipeline. Finally, when all iterations are done, draining the software pipeline is accomplished by shifting a 0 into the last element of stage.  The code corresponding to each active stage are calls to the work functions of the actors assigned to this SPE and the corresponding stage, and the necessary DMAs to fetch data from other SPEs. The Cell processor provides non-blocking DMA functionality <ref type="bibr" target="#b10">[11]</ref>, which is leveraged for overlapping DMAs and computation. A DMA operation assigned to a particular stage is imple-  mented using the mfc get primitive, which enters the DMA command into a queue and returns immediately. The MFC engine in each SPE processes the queue asynchronously and independent of the processor. After enqueuing the DMA request, the code proceeds to execute work functions for actors. Note that even though the actual DMA operations are asynchronous, the SPE should queue up the DMA requests synchronously using the mfc get primitive. No more DMAs can be queued once work functions begin execution. Therefore, all DMA operations belonging to a stage are queued up before any work functions are called to ensure maximal overlap of actual DMAs and computation. Finally, the wait for dma completion uses the mfc read tag status all primitive to ensure all DMAs issued in the current iteration are completed, and a barrier synchronization is executed to ensure the current iteration is completed on all SPEs. barrier() is implemented using the signal mechanism available on the SPEs, and with the current implementation, 2 × 10 6 barriers can be performed in 1 second.</p><p>Buffer allocation. In the code generation schema described above, several iterations of the original stream graph are in flight concurrently. A producer actor could be executed multiple times before one of its consumers is ever executed. To ensure correct operation, multiple buffers are used to store the outputs of producer actors. The buffers are used in a fashion similar to rotating registers in a traditional modulo schedule. The number of buffers needed for the output of a producer actor assigned to stage S p feeding a consumer actor on stage S c can easily be calculated as S c -S p + 1.</p><p>Figure <ref type="figure" target="#fig_7">7</ref> shows the buffer allocation for a producer actor A and consumer actor B. They are assigned to different processors with an intervening DMA. Since the stage separation between A and the DMA is 3, 4 buffers are allocated on the local memory of PE1, and A uses them in a round-robin fashion. The arrows on the picture on the right shows the current buffers being used. Note that the DMA operation and actor A are executing concurrently by using different buffers. Similarly, B is using a buffer different from the DMA. In the current implementation, all buffers are allocated on the local memories of the SPEs. The buffers between a producer actor and a DMA operation are stored on the SPE on which the producer is running. Symmetrically, the buffers between the DMA operation and the consuming actor are stored on the consumer SPE. 256KB of local store is sufficient to hold all the buffers needed by the benchmarks evaluated. This is corroborated by the authors of <ref type="bibr" target="#b5">[6]</ref>, who report that the buffers needed by the benchmarks would fit on the 512KB cache of the Cell processor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Example</head><p>Figure <ref type="figure" target="#fig_9">8</ref>(a) shows an example stream graph. Assume that all actors in the graph are data parallel, i.e., they can be fissed any number of times. The numbers beside the nodes represent the amount of work done by the actors. Note that B does the most work of 40 units and the sum of work done by all actors is 60 units. When trying to schedule the unmodified graph on to 2 processors, the maximum    achievable speedup is 60 40 = 1.5. Figure <ref type="figure" target="#fig_9">8</ref>(b) shows the result of the integrated fission on processor assignment step. Node B has been fissed once, resulting in two new nodes B1 and B2, and the corresponding splitter S and joiner J, whose work are assumed to be 2 units. The processor assignment obtained has an II of 32, thus resulting in a speedup of 60 32 ∼ 2. Finally, Figure <ref type="figure" target="#fig_9">8</ref>(c) shows the stage assignment in which DMAs are separated from consumers by one stage, thus ensuring complete overlap of computation and communication.</p><p>Figure <ref type="figure" target="#fig_11">9</ref> shows the execution timeline of the code running on two SPEs. The main feature to note is the steady state execution, which starts from the 5th iteration in Figure <ref type="figure" target="#fig_11">9</ref>. In the steady state,</p><formula xml:id="formula_8">A 1 B 1 C 1 D 1 E 1 F 1 A 2 B 2 C 2 D 2 E 2 F 2 A 3 B 3 C 3 D 3 E 3 F 3 D M A D M A D M A D M A D M A D M A</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PE1 PE2 PE3</head><p>S tre am da ta dep ende nce S ta te da ta depen den ce all actors and all DMAs are active. The 4 iterations shown before the steady state correspond to the prologue of the modulo schedule, in which some actor executions and DMAs do not happen as they are predicated by the stage array. The DMA operations are started before actor executions on the SPEs, thus ensuring overlap with computation. Due to the overlap, the purported speedup of 2 is achieved by the schedule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Evaluation</head><p>This section presents our evaluation of SGMS. First, a simple alternative scheme which naïvely unfolds the entire stream graph is presented. Then, various aspects of SGMS are evaluated, including a comparison to naïve unfolding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Naïve Unfolding</head><p>This technique is based on a simple observation: when all actors in a stream program are stateless, the graph can be unfolded P times (where P is the number of available processors) and each copy of the graph can be run on one of the processors without incurring any communication overhead, and thus achieving a speedup of P.</p><p>Unfolding <ref type="bibr" target="#b19">[20]</ref> refers to the process of making multiple copies of the stream program and is analogous to unrolling a loop in traditional compilation. Unfolding is different from fission presented earlier in the paper. Fissing an actor introduces additional split and join nodes, and stream program semantics does not allow fissing a stateful actor. Unfolding the entire stream graph, including stateful actors, is possible if the additional dependences introduced due to carried state are honored. Also, when the entire graph is unfolded, stateless actors that peek more elements than they pop should also be considered stateful. This is because the extra elements that are peeked have to be "remembered" until the next invocation.</p><p>Figure <ref type="figure" target="#fig_12">10</ref> shows a stream graph unfolded 3 times and mapped on to 3 processors. The copies of nodes A and E shown as darker circles are stateful actors in the original graph. In the unfolded version, new edges A 1 → A 2 , A 2 → A 3 , and A 3 → A 1 enforce dependencies due to persistent state in actor A. These edges, referred to as state data dependence edges, are different from the edges which denote flow of stream data. State data dependence edges enforce the fact that the second copy of the unfolded actor can execute only after the first copy has finished its execution and passed on the values of state variables.</p><p>Unfolding the stream graph and mapping it to processors as shown in Figure <ref type="figure" target="#fig_12">10</ref> introduces recurrence cycles which is one of the limiting factors of performance of such a mapping. Consider a stream graph G = (V, E). Let the stateful nodes in V be denoted by the set V s ⊆ V. Suppose t(v) be the execution time of actor v ∈ V and s(v), the amount of time taken to transfer the state data associated with v ∈ V s . s(v) depends on the size of the persistent state of actor v and the communication latency. We assume that the size of persistent state is constant and does not grow during runtime. StreamIt does not allow dynamic memory allocation, and thus this property holds for all benchmarks in our evaluation. As evident from Figure <ref type="figure" target="#fig_12">10</ref>, for every stateful node, a recurrence cycle of length n × s(v) + n × t(v) is introduced in the unfolded version, where n is the unfold factor. The longest cycle in the graph constrains the maximum throughput achievable for the graph. We adopt the terminology used in traditional instruction centric software pipelining, and refer to the critical path length as "recurrence constrained minimum initiation interval", or RecMII. Thus, the RecMII in the unfolded graph is</p><formula xml:id="formula_9">RecMII = max v∈Vs (n × s(v) + n × t(v))<label>(9)</label></formula><p>The maximum achievable throughput is also limited by the resources, in this case the limited number of processors available to execute the graph. The constraint on throughput due to resources is referred to as "resource constrained minimum initiation interval", or ResMII. In the mapping shown in Figure <ref type="figure" target="#fig_12">10</ref>, each processor executes all the actors in the original stream graph. In addition, for every stateful actor, the processor performs a DMA to move the state data. Thus, every processor is equally loaded, and the load is</p><formula xml:id="formula_10">ResMII = v∈Vs s(v) + v∈V t(v)<label>(10)</label></formula><p>The best throughput for the graph using the above mapping described, referred to as the "minimum initiation interval", or MII, is simple the maximum of RecMII and ResMII. Suppose the number of actors in the stream program are much larger than the number of available processors, i.e., |V| P. Then, RecMII would be much smaller than ResMII because ResMII is the sum of work on all actors, whereas RecMII depends on the work of one actor. As long as the stream program does not have a large stateful filter that dominates the run time, which is true of our benchmark set, we have ResMII &gt; RecMII. Given that MII = ResMII, in steady state, the above mapping on n processors completes n iterations in MII cycles. Thus the speedup achieved by this mapping over one processor is given by</p><formula xml:id="formula_11">S peedup = n × v∈V t(v) v∈Vs s(v) + v∈V t(v)<label>(11)</label></formula><p>The code to run the naïve unfolding schedule on the Cell processor consists of one thread per SPE. SPEs are ordered to keep track of which iterations are executed on which SPE. Each SPE executes all actors in the stream graph in data flow order. Before executing a stateful actor, an SPE synchronizes with the "previous" SPE, and gets the values of state variables. The SPE then synchronizes with the "next" SPE and passes on the values of state variables. This is done repetitively, so that an SPE executes iterations i, i + n, i + 2n..., where n is the total number of SPEs.</p><p>The main differences between naïve unfolding and SGMS can be summarized as below.</p><p>• All DMA transfers of stream data can be overlapped with computation in SGMS where as DMA transfers of state data cannot be overlapped with any computation as it is present in the critical path.</p><p>• In the naïve unfolding method, each SPE runs all actors in the original stream graph, whereas in SGMS, an SPE runs only a subset of the actors. Therefore, the memory footprint of code for naïve unfolding is much larger than for SGMS. • The latency for one iteration of the original stream graph is equal to the uni-processor execution time of an iteration in the naïve unfolding method. This is because all actors belonging to one iteration is executed sequentially by an SPE. In contrast, task level parallelism is exploited within an iteration in SGMS, and therefore, the latency for an iteration could be much smaller.</p><p>Despite the shortcomings compared to SGMS, naïve unfolding is a simple method which requires no sophisticated compiler analyses, and is straightforward to implement for the Cell processor. We compare SGMS with naïve unfolding in the following section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Experiments</head><p>This section presents the results of the experimental evaluation of SGMS, and comparison to the naïve unfolding method. A uniprocessor schedule was first generated for one SPE, with instrumentations added for measuring running time of each actor. The SPU "decrementer", a low overhead timing measurement mechanism, is used for profiling. The timing profile for each actor is used by the SGMS scheduler that generates schedules for 2-16 processors. The scheduler uses the CPLEX mixed integer program solver during the integrated fission and processor assignment phase. The code generation phase outputs plain C code that is divided into code that runs on the Power processor and code that runs on individual SPEs. The main thread running on Power processor spawns one thread per SPE. Each SPE thread executes a code pattern that was described in Section 3.3. IBM's Cell SDK 2.1 was used to implement the DMA copies, and the barrier synchronization. The GNU C compiler gcc 4.1.1 targeting the SPE was used to compile the programs. Note that only vectorization that was automatically discovered by gcc were performed on the actors' codes. The hardware used for our evaluation is an IBM QS20 Blade server. It is equipped with 2 Cell BE processors and 1 GB XDRAM. Benchmark suite. The set of benchmarks available with StreamIt software version 2.1.1 was used to evaluate the scheduling methods. Most benchmarks are from the signal processing domain. bitonic implements the parallel bitonic sorting algorithm. des is a pipelined version of DES encryption cipher. <ref type="bibr" target="#b5">[6]</ref> provides descriptions of the benchmarks. Table <ref type="table" target="#tab_4">1</ref> shows the details relevant to our evaluation. Number of stateful actors with explicit state and peeking actors with implicit state are important to understand the speedups from naïve unfolding. Typical sizes of states in these benchmarks are also shown.</p><p>SGMS performance. Figure <ref type="figure" target="#fig_0">11</ref> shows the speedups obtained by SGMS over single processor execution on 2 to 16 processors for the benchmark suite. SGMS obtains near linear speedup for all benchmarks, resulting in the geometric mean speedup of 14.7x on 16 processors. The main reasons for near linear speedups are listed below. • The integrated fission and partitioning step fisses enough data parallel actors and the resulting number of actors is enough to span all available processors.</p><p>• The partitioning assigns actors to processors with maximal load balance.</p><p>• Stage assignment separates data transfers and actors that use the data into different stages. This ensures that all data transfers are overlapped with computation.</p><p>Note that with perfect load balance and complete overlap of all communication with computation should always result in a speedup of N on N processors. However, the observed geometric mean speedup is only 14.7x on 16 processors. One of the main overheads in our implementation arises from the barrier synchronization. As shown in Figure <ref type="figure" target="#fig_5">6</ref>, all SPEs do a barrier synchronization at the end of every iteration of the loop implementing the modulo schedule.</p><p>Our implementation of the barrier on the SPEs adds an overhead of 1 second for every 2 × 10 6 calls. Depending on the number iterations the stream graph is executed, barrier synchronization adds an overhead of up to 3 seconds in some benchmarks. A notable benchmark is vocoder for which the 16 processor speedup is only 13x. vocoder has 96 actors in the stream graph. On 16 processors, the partitioning results in over 30 DMA operations being in flight at the same time, which adds some overhead to the steady state. SGMS relies on static work estimates during the partitioning phase. Any deviation from the static estimate during runtime would change the balance of work across processors and cause a reduction in speedup. However, this effect is difficult to quantify.</p><p>Comparing naïve unfolding to SGMS.Figure <ref type="figure" target="#fig_0">12</ref> compares the speedup obtained by SGMS and naïve unfolding on 16 processors. There are 3 bars per benchmark. The first bar is the speedup obtained by naïve unfolding for the original stream graph. The sec- ond bar is the speedup obtained by naïve unfolding on the same set of benchmarks, but with the size of state variables artificially increased by 16x compared to the original implementation. The last bar the speedup obtained by SGMS for the original stream graph. Figure <ref type="figure" target="#fig_0">12</ref> has to be correlated with Table <ref type="table" target="#tab_4">1</ref> for better understanding. For benchmarks that are almost completely stateless, such as dct, des and mpeg2, naïve unfolding achieves over 15.5x speedup on 16 processors. This is not surprising as independent iterations run on different processors without any communication. Note that each benchmark nominally has 2 stateful actors, which are the input and output actors. These are used for preserving program order. The small amount of communication needed for these two stateful filters adds very little overhead, and thus completely stateless stream programs achieve close to 16x speedup on 16 processors. The SGMS method for these programs does not unfold the stream graph completely, but only fisses enough actors to get an even work distribution. The selective fissing adds extra splitters and joiners that add non-zero overhead to the steady state. Also, SGMS uses a barrier synchronization at the end of each iteration, whereas in naïve unfolding, the stateful actors perform a point to point synchronization. Because of these two facts, naïve unfolding performs 5-10% better than SGMS for completely stateless stream programs.</p><p>For stream programs with many stateful and peeking actors, such as vocoder, radar, and fmradio, SGMS outperforms naïve unfolding by up to 20%. The DMA transfer of state data in naïve unfolding is completely exposed as it is in the critical path. However, all DMA transfers of stream data are overlapped with computation in SGMS. The exposed DMA overhead for naïve unfolding is more pronounced when the state size is artificially increased to 16x the original state size. In this case, SGMS, whose performance is unaffected by the state size increase, outperforms naïve unfolding by up to 35%.</p><p>Effect of exposed DMA latency. Figure <ref type="figure" target="#fig_14">13</ref> illustrates the effectiveness of computation/communication overlap. For each benchmark, a version of the C code for SPEs was generated in which the data transfer overhead was completely exposed. For this case, the stage assignment did not separate the DMA operation and the consumer actor into different stages. Rather, they were put in the same stage and the consumer SPE stalls until the DMA operation is completed. The effect of exposed DMA latency is detrimental for all benchmarks. For channel, filterbank, and radar, which have high computation to communication ratios, the effect is not very pronounced and they retain most of their speedups even with exposed DMA latency. bitonic and des have low computation to communication ratios, and they suffer up to 25% perfomance loss when the DMA latencies are exposed.</p><p>Comparing ILP partitioning to greedy partitioning. The integrated fission and processor assignment phase is in part an optimal formulation for bin packing. In addition to deciding how many times each actor has to be fissed, this phase also does the assignment with maximal load balancing. Figure <ref type="figure" target="#fig_15">14</ref> compares the optimal formulation with a greedy heuristic. We only compare the 8 processor speedup. This is because the programmer conceived stream graph already has enough parallelism to span 8 processors as shown in Figure <ref type="figure">3</ref> and the fission part of the formulation does not fiss any actors. Thus, Figure <ref type="figure" target="#fig_15">14</ref> effectively compares an optimal bin packing formulation to a greedy strategy. We use the Metis <ref type="bibr" target="#b11">[12]</ref> graph partitioner as our greedy strategy. The original stream graph is partitioned into N parts using Metis, where N is the number of processors. The same work estimates are used as weights on the nodes of the graph. Note that this greedy partitioning is similar to the one used in <ref type="bibr" target="#b5">[6]</ref>. In <ref type="bibr" target="#b5">[6]</ref>, a separate communication stage is introduced between steady states to shuffle data between banks. However, to make the comparison fair, the same algorithm for stage assignment is used in both cases which overlaps all DMA transfers with computation. Figure <ref type="figure" target="#fig_15">14</ref> shows that the quality of graph partition using a greedy method depends greatly on the structure of the graph. For example, fft and tde are just linear graphs with no splitters or joiners. For these cases, the greedy graph partitioner is able to achieve the same load balance as the optimal partitioner. For highly parallel graphs like filterbank and vocoder, heuristics perform up to 35% worse than an optimal formulation. Overall, the optimal partitioner achieves a geometric mean speedup of 7.6x, whereas the greedy partitioner achieves 6.7x on 8 processors.</p><p>Scaling of ILP formulation.The vocoder benchmark is used to study how the CPLEX solver run times scales when trying to partition the graph for 2 to 128 processors. vocoder is the largest benchmark in the suite, and the solver run times are smaller for all other benchmarks. The solver run times were under 30 seconds for up to 16 processors. The time taken for partitioning on 32, 64 and 128 processors were 2, 6, and 16 minutes, respectively on a Intel Pentium D running at 3.2GHz.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Related Work</head><p>There is a large body of literature on synchronous dataflow graphs, on languages to express stream graphs, and methods to exploit the parallelism expressed in stream graphs. Even though SDF is a powerful explicitly parallel programming model, its niche has been in DSP domain for a long time. Early works from the Ptolemy group <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b14">15]</ref> has focused on expressing DSP algorithms as stream graphs. Some of their scheduling techniques <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b8">9]</ref> have focused on scheduling stream graphs to multiprocessor systems. However, they focus on acyclic scheduling and do not evaluate scheduling to a real architecture.</p><p>There has been other programming systems based on the stream programming paradigm, and each of those systems have compilers which target multiprocessors. <ref type="bibr" target="#b7">[8]</ref> maps StreamC to a multithreaded processor. This was more of a feasibility study, and the scheduling was done manually. In <ref type="bibr" target="#b26">[27]</ref>, the authors map the Brook language to a multicore processor. They make use of affine partitioning techniques which are more suitable for parameterized loop based programs. With StreamIt, the stream graph is completely resolved at compile time, and a direct scheduling technique like ours is more effective. Note that any stream programming system in which the computation can be expressed as an stream graph could utilize our scheduling method.</p><p>There has been a recent spur of research in the domain of compiling to the Cell processor. CellSs <ref type="bibr" target="#b0">[1]</ref> is a stylized C model for programming the cell. The computation is expressed as functions which make all their inputs and outputs explicit in terms of parameters. Functions can be stringed together to form a data flow graph. A run time scheduler treats this graph in the same way a superscalar processor treats operations, and schedules these functions on to the cell SPEs as soon as their inputs are ready. Our work is distinctly different from theirs in that, we use a static compile time schedule which does not have run time scheduling overheads. <ref type="bibr" target="#b12">[13]</ref> talks about compiling the Sequoia language to the Cell processor. This paper's focus is more on representing machines with multiple levels of memories, possibly with disjoint address spaces, in a reusable way, and a compiler to automatically target such representations. Our work focuses more on the actual scheduler, and assumes a fixed machine. <ref type="bibr" target="#b1">[2]</ref> talks about parallelizing a specific application at multi levels of granularity on the Cell processor. This is more of an experiences paper, and the parallelization was done manually.</p><p>The problem scheduling coarse grain actors to processors on a multicore with distributed memory is conceptually similar to scheduling operations to the function units in a multicluster VLIW processor <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24]</ref>. However, stream graph exposes more optimization opportunities such as the ability to fiss actors. Also, the constraints of limited register space is not an issue on multicores as there is ample memory available to hold the intermediate buffers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>The widespread use of multicore processors is pushing explicitly parallel high-level programming models to the forefront. Stream programming is a promising approach as it naturally expresses parallelism in applications from a wide variety of domains. In this paper, we develop methods to automatically map a stream program on to the Cell processor. One of the main issues of getting an even distribution of computation across processors is dealt in an integrated fission and partitioning step that breaks up computation units just enough to span the available processors. The issue of communication overhead is overcome by an intelligent stage assignment, which overlaps all communication with computation. A detailed evaluation of our method on real hardware shows consistent speedup for a wide range of benchmarks. Stream graph modulo scheduling provides a geometric mean speedup of 14.7x over single processor execution across the StreamIt benchmark suite. We compare our method to naïve unfolding that unfolds all actors as many times as the number of processors. Even though naïve unfolding gets speedups similar to SGMS for completely stateless programs, SGMS demonstrates wider applicability by offering consistent speedups on both stateless and stateful programs. Finally, the integrated fission and partitioning phase is largely independent of the underlying architecture, and can be used when compiling to different multicore platforms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (a) Example StreamIt Program and (b) corresponding stream graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>7 Figure 2 :</head><label>72</label><figDesc>Figure 2: The Cell broadband architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 b 1</head><label>21</label><figDesc>2 ,j,i -b 1,2 -5 ≥ -M + M b 1,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Example illustrating ILP formulation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Properties of stages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Main loop implementing the modulo schedule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Buffer allocation for the modulo schedule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>4 P ro c 1 P ro c 2 (</head><label>412</label><figDesc>a) O riginal stream graph (b) F ission and processor assignm ent (c) S tage assignm ent S pee du p ~ 2 M a xim um speedu p (unm odified grap h) = 1.5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Example illustrating fission, processor assignment and stage assignment.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Example illustrating a modulo schedule running on Cell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Mapping of an unfolded stream graph on to 3 processors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 11 :Figure 12 :</head><label>1112</label><figDesc>Figure 11: Stream graph modulo scheduling speedup normalized to single SPE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Effect of exposed DMA latency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Comparing ILP partitioning to greedy partitioning.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Stage assignment procedure egy is to spawn one thread per SPE. Each thread makes calls to work functions corresponding to actors that are assigned to the respective SPEs, and perform DMAs to get data from other SPEs. The main program, running on the PPE, just spawns the SPE threads and does not intervene thereafter.</figDesc><table><row><cell cols="2">FindStage (actor) :</cell></row><row><cell cols="2">maxstage ← 0 ;</cell></row><row><cell cols="2">f lag ← f alse ;</cell></row><row><cell cols="2">1 foreach producer p of actor do</cell></row><row><cell></cell><cell>if stage(p) &gt; maxstage then</cell></row><row><cell></cell><cell>maxstage ← stage(p) ;</cell></row><row><cell></cell><cell>end</cell></row><row><cell>2</cell><cell>if Proc(p) Proc(actor) then</cell></row><row><cell></cell><cell>f lag ← true ;</cell></row><row><cell></cell><cell>end</cell></row><row><cell>end</cell><cell></cell></row><row><cell cols="2">3 if flag then</cell></row><row><cell></cell><cell>stage ← maxstage + 2 ;</cell></row><row><cell>else</cell><cell></cell></row><row><cell></cell><cell>stage ← maxstage ;</cell></row><row><cell>end</cell><cell></cell></row><row><cell cols="2">4 while Load(Proc(p), stage) + t(actor) &gt; II do</cell></row><row><cell></cell><cell>stage ← stage + 1</cell></row><row><cell>end</cell><cell></cell></row><row><cell cols="2">Load(Proc(p), stage) + = t(actor) ;</cell></row><row><cell cols="2">return stage</cell></row><row><cell></cell><cell>Algorithm 1:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>Benchmark characteristics.</figDesc><table><row><cell>Benchmark</cell><cell>Actors</cell><cell>Stateful</cell><cell>Peeking</cell><cell>State size (bytes)</cell></row><row><cell>bitonic</cell><cell>28</cell><cell>2</cell><cell>0</cell><cell>4</cell></row><row><cell>channel</cell><cell>54</cell><cell>2</cell><cell>34</cell><cell>252</cell></row><row><cell>dct</cell><cell>36</cell><cell>2</cell><cell>0</cell><cell>4</cell></row><row><cell>des</cell><cell>33</cell><cell>2</cell><cell>0</cell><cell>4</cell></row><row><cell>fft</cell><cell>17</cell><cell>2</cell><cell>0</cell><cell>4</cell></row><row><cell>filterbank</cell><cell>68</cell><cell>2</cell><cell>32</cell><cell>508</cell></row><row><cell>fmradio</cell><cell>29</cell><cell>2</cell><cell>14</cell><cell>508</cell></row><row><cell>tde</cell><cell>28</cell><cell>2</cell><cell>0</cell><cell>4</cell></row><row><cell>mpeg2</cell><cell>26</cell><cell>3</cell><cell>0</cell><cell>4</cell></row><row><cell>vocoder</cell><cell>96</cell><cell>11</cell><cell>17</cell><cell>112</cell></row><row><cell>radar</cell><cell>54</cell><cell>44</cell><cell>0</cell><cell>1032</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Acknowledgments</head><p>We thank Dr. Rodric Rabbah at IBM Research for his time, energy, and useful feedback on this research. We also extend our thanks to the anonymous referees who provided excellent comments. This</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Cellss: a programming model for the cell be architecture</title>
		<author>
			<persName><forename type="first">Pieter</forename><surname>Bellens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Josep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rosa</forename><forename type="middle">M</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesus</forename><surname>Badia</surname></persName>
		</author>
		<author>
			<persName><surname>Labarta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Supercomputing &apos;06</title>
		<meeting>Supercomputing &apos;06</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">00</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dynamic multigrain parallelization on the cell broadband engine</title>
		<author>
			<persName><forename type="first">Filip</forename><surname>Blagojevic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitris</forename><forename type="middle">S</forename><surname>Nikolopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandros</forename><surname>Stamatakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><forename type="middle">D</forename><surname>Antonopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>of the 12th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="90" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Brook for GPUs: Stream computing on graphics hardware</title>
		<author>
			<persName><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="777" to="786" />
			<date type="published" when="2004-08">August 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Shangri-la: Achieving high performance from compiled network applications while enabling ease of programming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the SIGPLAN &apos;05 Conference on Programming Language Design and Implementation</title>
		<meeting>of the SIGPLAN &apos;05 Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
			<biblScope unit="page" from="224" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The push of network processing to the top of the pyramid</title>
		<author>
			<persName><forename type="first">W</forename><surname>Eatherton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Exploiting coarse-grained task, data, and pipeline parallelism in stream programs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saman</forename><surname>Thies</surname></persName>
		</author>
		<author>
			<persName><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="151" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">David Maze, and Saman Amarasinghe. A stream compiler for communication-exposed architectures</title>
		<author>
			<persName><forename type="first">I</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michal</forename><surname>Thies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jasper</forename><surname>Karczmarek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><forename type="middle">S</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">A</forename><surname>Meli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Lamb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Leger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><surname>Hoffmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tenth International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="2002-10">October 2002</date>
			<biblScope unit="page" from="291" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Stream programming on general-purpose processors</title>
		<author>
			<persName><forename type="first">Jayanth</forename><surname>Gummaraju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mendel</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 38th Annual International Symposium on Microarchitecture</title>
		<meeting>of the 38th Annual International Symposium on Microarchitecture<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="343" to="354" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Compile-time scheduling and assignment of data-flow program graphs with datadependent iteration</title>
		<author>
			<persName><forename type="first">Soonhoi</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1225" to="1238" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Power efficient processor design and the Cell processor</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Hofstee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 11th International Symposium on High-Performance Computer Architecture</title>
		<meeting>of the 11th International Symposium on High-Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2005-02">February 2005</date>
			<biblScope unit="page" from="258" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<author>
			<persName><surname>Ibm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cell Broadband Engine Architecture</title>
		<imprint>
			<date type="published" when="2006-03">March 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Metis: A Software Package for Paritioning Unstructured Graphs, Partitioning Meshes and Computing Fill-Reducing Orderings of Sparce Matrices</title>
		<author>
			<persName><forename type="first">G</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-09">September 1998</date>
		</imprint>
		<respStmt>
			<orgName>University of Minnesota</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Compilation for explicitly managed memory hierarchies</title>
		<author>
			<persName><forename type="first">Timothy</forename><forename type="middle">J</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ji</forename><forename type="middle">Young</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manman</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mattan</forename><surname>Erez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kayvon</forename><surname>Fatahalian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">J</forename><surname>Dally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>of the 12th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="226" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Niagara: A 32-way multithreaded SPARC processor</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kongetira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Aingaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="21" to="29" />
			<date type="published" when="2005-02">February 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Synchronous data flow</title>
		<author>
			<persName><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Messerschmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Proceedings</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1235" to="1245" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Pipeline interleaved programmable dsp&apos;s: Synchronous data flow programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Messerschmitt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="1334" to="1345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Static scheduling of synchronous data flow programs for digital signal processing</title>
		<author>
			<persName><forename type="first">Edward</forename><surname>Ashford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">G</forename><surname>Messerschmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="35" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Cg: A system for programming graphics hardware in a C-like language</title>
		<author>
			<persName><forename type="first">W</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Glanville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Akeley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilgard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30 th International Conference on Computer Graphics and Interactive Techniques</title>
		<meeting>of the 30 th International Conference on Computer Graphics and Interactive Techniques</meeting>
		<imprint>
			<date type="published" when="2003-07">July 2003</date>
			<biblScope unit="page" from="893" to="907" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">NVIDIA CUDA software and GPU parallel computing architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>Nickolls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Buck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Microprocessor Forum</title>
		<imprint>
			<date type="published" when="2007-05">May 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Static rate-optimal scheduling of iterative data-flow programs via optimum unfolding</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Parhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Messerschmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="178" to="195" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">A hierarchical multiprocessor scheduling framework for synchronous dataflow graphs</title>
		<author>
			<persName><forename type="first">Jose</forename><surname>Luis Pino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuvra</forename><forename type="middle">S</forename><surname>Bhattacharyya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<idno>UCB/ERL M95/36</idno>
		<imprint>
			<date type="published" when="1995-05">May 1995</date>
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Iterative modulo scheduling: An algorithm for software pipelining loops</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Rau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 27th Annual International Symposium on Microarchitecture</title>
		<meeting>of the 27th Annual International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1994-11">November 1994</date>
			<biblScope unit="page" from="63" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Code generation for modulo scheduled loops</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R</forename><surname>Rau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Schlansker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Tirumalai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25th Annual International Symposium on Microarchitecture</title>
		<meeting>of the 25th Annual International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="1992-11">November 1992</date>
			<biblScope unit="page" from="158" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Modulo scheduling for a fullydistributed clustered VLIW architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sánchez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>González</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 33rd Annual International Symposium on Microarchitecture</title>
		<meeting>of the 33rd Annual International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2000-12">December 2000</date>
			<biblScope unit="page" from="124" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The Raw microprocessor: A computational fabric for software circuits and general purpose programs</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Bedford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Taylor</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="25" to="35" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">StreamIt: A language for streaming applications</title>
		<author>
			<persName><forename type="first">W</forename><surname>Thies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karczmarek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2002 International Conference on Compiler Construction</title>
		<meeting>of the 2002 International Conference on Compiler Construction</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="179" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Data and computation transformations for brook streaming applications on multiprocessors</title>
		<author>
			<persName><forename type="first">Zhaohui</forename><surname>Shih Wei Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gansha</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guei-Yuan</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><surname>Lueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2006 International Symposium on Code Generation and Optimization</title>
		<meeting>of the 2006 International Symposium on Code Generation and Optimization</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="196" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A programming model for an embedded media processing architecture</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 5 th International Symposium on Systems, Architectures, Modeling, and Simulation</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of the 5 th International Symposium on Systems, Architectures, Modeling, and Simulation</meeting>
		<imprint>
			<date type="published" when="2005-07">July 2005</date>
			<biblScope unit="volume">3553</biblScope>
			<biblScope unit="page" from="251" to="261" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
