<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Contract-Based Methodology for Aircraft Electric Power System Design</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Pierluigi</forename><surname>Nuzzo</surname></persName>
							<email>nuzzo@eecs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California at Berkeley</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Huan</forename><surname>Xu</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Institute for Systems Research and Aerospace Engineering</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<postCode>20742</postCode>
									<settlement>College Park</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Necmiye</forename><surname>Ozay</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<postCode>48109</postCode>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><forename type="middle">B</forename><surname>Finn</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California at Berkeley</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alberto</forename><forename type="middle">L</forename><surname>Sangiovanni-Vincentelli</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California at Berkeley</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Richard</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Engineering and Applied Science Department</orgName>
								<orgName type="institution">California Institute of Technology</orgName>
								<address>
									<postCode>91125</postCode>
									<settlement>Pasadena</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexandre</forename><surname>Donzé</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California at Berkeley</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sanjit</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California at Berkeley</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Contract-Based Methodology for Aircraft Electric Power System Design</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DF5BAC202733A8EAD51C0866FE65BA90</idno>
					<idno type="DOI">10.1109/ACCESS.2013.2295764</idno>
					<note type="submission">Received October 10, 2013, accepted November 26, 2013, date of publication December 20, 2013, date of current version January 7, 2014.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In an aircraft electric power system, one or more supervisory control units actuate a set of electromechanical switches to dynamically distribute power from generators to loads, while satisfying safety, reliability, and real-time performance requirements. To reduce expensive redesign steps, this control problem is generally addressed by minor incremental changes on top of consolidated solutions. A more systematic approach is hindered by a lack of rigorous design methodologies that allow estimating the impact of earlier design decisions on the final implementation. To achieve an optimal implementation that satisfies a set of requirements, we propose a platform-based methodology for electric power system design, which enables independent implementation of system topology (i.e., interconnection among elements) and control protocol by using a compositional approach. In our flow, design space exploration is carried out as a sequence of refinement steps from the initial specification toward a final implementation by mapping higher level behavioral and performance models into a set of either existing or virtual library components at the lower level of abstraction. Specifications are first expressed using the formalisms of linear temporal logic, signal temporal logic, and arithmetic constraints on Boolean variables. To reason about different requirements, we use specialized analysis and synthesis frameworks and formulate assume guarantee contracts at the articulation points in the design flow. We show the effectiveness of our approach on a proof-of-concept electric power system design.</p><p>INDEX TERMS Design methodology, design automation, aircraft, power systems, control system synthesis, contract-based design, platform-based design, cyber-physical systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The advent of high capability, reliable power electronics together with powerful embedded processors has enabled an increasing amount of ''electrification'' of vehicles such as cars and aircraft in recent years <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>. Hydraulic, pneumatic and mechanical systems are being replaced by cyber-electrical components that increase the overall system efficiency <ref type="bibr" target="#b2">[3]</ref>. However, the increased use of electricallypowered elements poses significant challenges to the aircraft electric power system in terms of the reliability of electrical power generation and distribution while satisfying safety requirements.</p><p>A severe limitation in common design practice is the lack of formalized specifications. System requirements are predominantly written in text-based languages that are not suitable for mathematical analysis and verification. Assessing system correctness is then left for simulations and prototype tests later in the design process, when modifications are significantly more expensive. Additionally, the inability to rigorously model the interactions among heterogeneous components and between the physical and the cyber sides of the system poses a serious obstacle. Thus, the traditional heuristic design process based on text-based requirement capture and designers' experience leads to implementations that are inefficient and sometimes do not even satisfy the requirements, yielding long re-design cycles, cost overruns and unacceptable delays. Personal use is also permitted, but republication republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.</p><p>We propose instead to carry out a rigorous design process that includes allocation of the requirements to the components and early validation of design constraints. By following the platform-based design paradigm <ref type="bibr" target="#b3">[4]</ref>, we proceed by subsequent refinement of design requirements using a library of available components. To perform this task, we define convenient abstractions for system exploration and compositional synthesis of system topology (interconnection among the various components) and control. In particular, we build a rich, multi-view set of component models that can be used by different, domain-specific analysis, synthesis and verification frameworks. We first synthesize an electric power system topology from system requirements formalized as arithmetic constraints on Boolean variables. For the given topology, we translate the requirements into temporal logic formulas, by which we synthesize and verify control protocols. To reason about different requirements in a compositional way, we use the concept of contracts <ref type="bibr" target="#b4">[5]</ref> that formalize the notion of interfaces between models and tools in the design flow. A few theoretical results (Theorem 3.1, Propositions 6.1 and 6.2) show how contracts can offer a natural framework to reason about distributed control architectures as well as the heterogeneous interface between the controller and its plant.</p><p>Our design methodology builds on a number of results that have opened the way for a more structured approach to the design of aircraft electric power systems. The adoption of model-based development and simulation for the analysis of aircraft performance and power optimization has already been advocated in <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>. In the context of the More Open Electrical Technologies (MOET) project <ref type="bibr" target="#b1">[2]</ref>, a set of model libraries have been developed using the Modelica language <ref type="bibr" target="#b7">[8]</ref> to support ''more-electric'' aircraft simulation, design and validation. Simulation is used for electric power system performance verification (e.g., stability and power quality) at the network level, by leveraging models with different levels of complexity to analyze different system properties, and validated with real equipment measurements. However, design space exploration, optimization and analysis of faulty behaviors in these models can still become computationally unaffordable unless proper levels of abstraction are devised, based on the goals at each design step.</p><p>A library-based approach to instantiate, analyze and verify a system design was also adopted in <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>, within the META research program, with the aim to compress the product development and deployment timeline of defense systems. A simulation framework based on Modelica was developed to enable exploration of architectural design decisions, while a language based on SysML <ref type="bibr" target="#b10">[11]</ref> was proposed to enable semantically robust integration of models, analytical methods and results provided by other domain specific languages and tools <ref type="bibr" target="#b11">[12]</ref>. Such integration language incorporates assumeguarantee contracts to formalize system requirements and enable the generation of monitors. In this paper, we further extend the use of assume-guarantee contracts as a design aid in combination with platform-based design to yield system synthesis and optimization in addition to system simulation and verification.</p><p>An optimization-oriented power system design methodology following the platform-based paradigm was proposed in <ref type="bibr" target="#b12">[13]</ref> where initial specifications are refined and mapped to the final implementation in four steps. At each step, a binary optimization problem is formulated to derive a class of candidate implementations for the next exploration step. The methodology deals with how to select the power generators and synthesize the electric power system topology. In this paper, we extend the flow in <ref type="bibr" target="#b12">[13]</ref> to enable synthesis of electric power system topology and control, subject to heterogeneous sets of system requirements that are not always approximated by binary or mixed integer-linear constraints. To perform automatic synthesis of control protocols, we build on recent works on formal synthesis of aircraft vehicle management systems <ref type="bibr" target="#b13">[14]</ref>, distributed control synthesis <ref type="bibr" target="#b14">[15]</ref>, and reactive synthesis for electric power systems <ref type="bibr" target="#b15">[16]</ref>. In particular, we express system specifications in linear temporal logic (LTL) <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b17">[18]</ref> and leverage a combination of tools from the computer science and formal methods domains.</p><p>The remainder of the paper is organized as follows. After a brief description of a typical electric power system and its design challenges in Section II, we provide some background on contract-based design and control synthesis in Section III. Section IV summarizes our electric power system design methodology while Section V and Section VI provide details on topology and control design. Section VII reports results from the application of our methodology to a prototype electric power system design, and is followed by concluding remarks in Section VIII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. THE AIRCRAFT ELECTRIC POWER SYSTEM</head><p>Fig. <ref type="figure">1</ref> illustrates a sample architecture for power generation and distribution in a passenger aircraft in the form of a singleline diagram (SLD) <ref type="bibr" target="#b0">[1]</ref>, a simplified notation for three-phase power systems. Typically, aircraft electric power systems consist of generation, primary distribution and secondary distribution sub-systems. In this paper, we focus on the primary power distribution system, which includes the majority of the supervisory control logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. COMPONENTS</head><p>The main components of an electric power system are generators, contactors, buses, and loads. Primary generators are connected to the aircraft engine and can operate at high or low voltages. Auxiliary generators are mounted atop an auxiliary power unit (APU). The APU is normally used on ground (when no engines are available) to provide hydraulic and electric power, but can also be used in flight when one of the primary generators fails. With a small abuse of notation, we hereafter refer to auxiliary generators themselves as APUs. Batteries are primarily used at start-up and in case of emergency. AC and DC buses (both high and low-voltage) deliver power to a number of loads. Buses can be essential or nonessential. Essential buses supply loads that should always be powered, while non-essential ones supply loads that may be shed in the case of a fault or limited power capacity.</p><p>Contactors are electromechanical switches that connect components, and therefore determine the power flow from sources to loads. They are configured to be open or closed by one or multiple controllers (not shown in Fig. <ref type="figure">1</ref>), denoted as Bus Power Control Units (BPCU).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FIGURE 1.</head><p>Single-line diagram of an aircraft electric power system adapted from a Honeywell, Inc. patent <ref type="bibr" target="#b18">[19]</ref>.</p><p>Loads include subsystems such as lighting, heating, avionics and navigation. Bus loads also include power conversion devices: Rectifier units convert AC power to DC power, while AC transformers (ACTs) step down a high-voltage to a lower one, Transformer Rectifier Units (TRUs) both decrease the voltage level and convert it from AC to DC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. SYSTEM DESCRIPTION</head><p>The main AC power sources at the top of Fig. <ref type="figure">1</ref> include two low-voltage generators, two high-voltage generators, and two APU-mounted auxiliary generators. Each engine connects to a high-voltage AC (HVAC) generator (L1 and R1) and a lowvoltage AC (LVAC) generator (L2 and R2). Panels, denoted as dashed square boxes, represent groups of components that are physically separated on the aircraft. The three panels below the generators include the HVAC buses, which can be selectively connected to the HVAC generators, to the auxiliary generators, and to each other via contactors, denoted by double bars.</p><p>Four rectifier units are selectively connected to buses as HVAC loads. The two panels below the high-voltage DC (HVDC) buses include the LVAC subsystem. A set of AC transformers (ACTs) convert HVAC power to LVAC power and are connected to four LVAC buses. LVAC ESS Bus 3 and LVAC ESS Bus 4 are essential and are selectively connected to the two low-voltage generators. The LVAC essential buses are also connected to rectifier units, and thus to low-voltage DC (LVDC) power. The LVDC subsystem also contains two batteries. Power can be selectively routed directly from the HVAC bus to the LVDC buses 3 and 4 using TRUs.</p><p>One or more bus power control units use sensors (which are not depicted in Fig. <ref type="figure">1</ref>) to measure physical quantities, such as voltages and currents, and control the state (open or closed) of the contactors, to dynamically reconfigure the system based on the status and availability of the power sources. For the rest of the paper, we denote this centralized or distributed supervisory control unit as BPCU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. SYSTEM REQUIREMENTS</head><p>Given a set of loads, together with their power and reliability requirements, the goal is to determine the system's architecture and control such that the demand of the loads is satisfied for all flight conditions and a set of predetermined faults. To better formalize this design objective, we begin with a qualitative analysis of the main system requirements, by categorizing them in terms of safety and reliability requirements. For each of these categories, we provide a few examples that serve as a reference for the rest of the paper.</p><p>Safety specifications constrain the way each bus must be powered to avoid loss of essential features, and the maximum time interval allowed for power shortages. For instance, to avoid generator damage, we proscribe AC sources to be paralleled, i.e. no AC bus can be powered by multiple generators at the same time. Moreover, we refine the definition of essential loads and buses (such as flight-critical actuators) provided above by requiring that they be never unpowered for more than a specified time t max .</p><p>Reliability specifications describe the bounds on the failure probabilities that can be tolerated for different portions of the system. Based on its failure modes, every component is characterized by a failure rate. A failure rate of λ indicates that a failure occurs, on average, every 1/λ hours. For a given mission profile, failure rates can be translated into failure probabilities so that system reliability specifications are also expressed in terms of the failure probabilities of the components. Based on the component failure rates, a typical specification would require that the failure probability for an essential load (i.e., the probability of being unpowered for longer than t max ) be smaller than 10 -9 per flight hour. The actual probability value depends on the load criticality <ref type="bibr" target="#b0">[1]</ref>. In our example, both the electric power system topology and the controller should be designed to accommodate any possible combination of faults potentially causing the failure of an essential component, and having a joint probability larger than 10 -9 per flight hour.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. CONTRACT-BASED DESIGN OF CYBER-PHYSICAL SYSTEMS</head><p>Inspired by recent results on assume-guarantee compositional reasoning and interface theories in the context of hybrid systems and software verification, our methodology is based on the use of assume-guarantee contracts for cyber-VOLUME 2, 2014 physical systems <ref type="bibr" target="#b4">[5]</ref>. Informally, contracts mimic the thought process of a designer, who aims at guaranteeing certain performance figures for the design under specific assumptions on its environment. The essence of contracts is, therefore, a compositional approach, where design and verification complexity is reduced by decomposing system-level tasks into more manageable subproblems at the component level, under a set of assumptions. System properties can then be inferred or proved based on component properties. In this respect, contract-based design can be a rigorous and effective paradigm while dealing with the complexity of modern system design, and has been successfully applied to other embedded system domains, such as automotive applications <ref type="bibr" target="#b19">[20]</ref> and mixed-signal integrated circuits <ref type="bibr" target="#b20">[21]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. COMPONENTS</head><p>We summarize the main concepts behind contract-based design starting with the notion of components. A summary of the notation used in this Section and in the rest of the paper is given in Table <ref type="table" target="#tab_0">1</ref>.</p><p>A component M can be seen as an abstraction, a hierarchical entity representing an element of a design, characterized by the following component attributes:</p><formula xml:id="formula_0">• a set of input variables U ∈ U, output variables Y ∈ Y,</formula><p>and internal variables (including state variables) X ∈ X ; a set of configuration parameters κ ∈ K, and a set of input, output and bidirectional ports λ ∈ Λ for connections with other components;</p><p>• a set of behaviors, which can be implicitly represented by a dynamic behavioral model F(U , Y , X , κ) = 0, uniquely determining the value of the output and internal variables given the one of the input variables and configuration parameters. We assume that components can respond to every possible sequence of input variables, i.e., they are receptive to their input variables. Behaviors are generic, and could be continuous functions that result from solving differential equations, or sequences of values or events recognized by an automata model;</p><p>• a set of non-functional models, i.e. maps that allow computing non-functional properties of a component corresponding to particular valuations of its input variables and configuration parameters. Examples of nonfunctional maps include the performance model P, computing a set of performance figures by solving the behavioral model, or the reliability model R, providing the failure probability of a component. Components can be connected together by sharing certain ports under constraints on the values of certain variables. In what follows, we use variables to denote both component variables and ports. Moreover, components can be hierarchically organized to represent a system at different levels of abstraction. Given a set of components at level l, a system can then be composed by parallel composition and represented as a new component at level l + 1. At each level of abstraction, components are also capable of exposing multiple, complementary views, associated to different concerns (e.g. safety, performance, and reliability), which can be expressed via different formalisms and analyzed by different tools.</p><p>A component may be associated to both implementations and contracts. An implementation M is an instantiation of a component M for a given set of configuration parameters. In what follows, we also denote with M the set of all its behaviors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. CONTRACTS</head><p>A contract C for a component M is a pair of assertions (A, G), called the assumptions and the guarantees. An assertion H represents a specific set of behaviors over variables that satisfies H . Therefore, operations on assertions and contracts are set operations. An implementation M satisfies an assertion H whenever M and H are defined over the same set of variables and all the behaviors of M satisfy the assertion, i.e. when M ⊆ H . The set of all the legal environments for C collects all implementations E such that E ⊆ A. An implementation of a component satisfies a contract whenever it satisfies its guarantee, subject to the assumption. Formally, M ∩ A ⊆ G, where M and C have the same variables. We denote such a satisfaction relation by writing M | C. Similarly, we relate a legal environment E to a contract C by the satisfaction relation</p><formula xml:id="formula_1">E | E C.</formula><p>Any implementation M of a component such that M ⊆ G ∪ ¬A, where ¬A is the complement of A, is also an implementation for C. In general, M C = G ∪ ¬A is the maximal implementation for C. Two contracts C and C with identical variables, identical assumptions, and such that G ∪ ¬A = G ∪ ¬A, possess identical sets of implementations. Such two contracts are then equivalent. Therefore, any contract C = (A, G) is equivalent to a contract in saturated form (A, G ), which also satisfies G ⊇ ¬A, or, equivalently, G ∪A = True, the true assertion. To obtain the saturated form of a contract, it is enough to take G = G ∪ ¬A.</p><p>Contracts associated with different components can be combined according to different rules. Similar to parallel composition of components, parallel composition of contracts can be used to construct composite contracts out of simpler ones. Let C 1 = (A 1 , G 1 ) and C 2 = (A 2 , G 2 ) be contracts in saturated form, then the assumptions and the guarantees of the composite C 1 ⊗ C 2 can be computed as follows <ref type="bibr" target="#b19">[20]</ref>:</p><formula xml:id="formula_2">A = (A 1 ∩ A 2 ) ∪ ¬(G 1 ∩ G 2 ),<label>(1)</label></formula><formula xml:id="formula_3">G = G 1 ∩ G 2 .<label>(2)</label></formula><p>The composite contract must clearly satisfy the guarantees of both. Moreover, since the environment should satisfy all the assumptions, we should expect that the assumptions of each contract would also combine by conjunction. In general, however, part of the assumptions A 1 will be already satisfied by composing C 1 with C 2 , which acts as a partial environment for C 1 . Therefore, G 2 can relax the assumptions A 1 , and viceversa, which motivates equation (1). To use equation (1) and equation ( <ref type="formula" target="#formula_3">2</ref>), the behaviors related to the original contracts need to be extended to a common set of variables. Such an extension, which is also called alphabet equalization, can be achieved by an operation of inverse projection <ref type="bibr" target="#b19">[20]</ref>. Even if they need to be satisfied simultaneously, multiple views of the same component do not generally compose by parallel composition. Therefore, the conjunction (∧) of contracts can also be defined so that if </p><formula xml:id="formula_4">M | C 1 ∧ C 2 , then M | C 1 and M | C 2 .</formula><formula xml:id="formula_5">C 1 ∧ C 2 = (A 1 ∪ A 2 , G 1 ∩ G 2 ),<label>(3)</label></formula><p>i.e. conjunction of contracts amounts to taking the intersection of the guarantees and the union of the assumptions. Conjunction can be used to compute the overall contract for a component starting from the contracts related to multiple views (concerns, requirements) in a design.</p><p>In addition to satisfaction and refinement, consistency and compatibility are also relations involving contracts. Technically, these two notions refer to individual contracts. A contract is consistent when the set of implementations satisfying it is not empty, i.e. it is feasible to develop implementations for it. For contracts in saturated form, this amounts to verifying that G = ∅. C is compatible if there exists a legal environment E for C, i.e. if and only if A = ∅. The intent is that a component satisfying contract C can only be used in the context of a compatible environment. In practice, however, violations of consistency and compatibility occur as a result of a parallel composition, so that we can refer to the collection of components forming a composite contract as being consistent or compatible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. PLATFORM-BASED DESIGN AND CONTRACTS</head><p>We use contracts in the context of platform-based design <ref type="bibr" target="#b3">[4]</ref>, a paradigm that allows reasoning about design in a structured way. In platform-based design, design progresses in precisely defined abstraction levels; at each level, functionality (what the system is supposed to do) is strictly separated from architecture (how the functionality can be implemented). Differently than model-based development, platform-based design consists of a meet-in-the-middle approach where successive top-down refinements of high-level specifications across design layers are mapped onto bottom-up abstractions and characterizations of potential implementations. Each layer is defined by a design platform, which is a library (collection) of components, models, representing functionality and performance of the components (as detailed in Section III-A), and composition rules.</p><p>In this context, contracts can play a fundamental role in: (i) determining valid compositions so that when the design space is explored, only legal (i.e. satisfying the composition rules) compositions that are compatible (i.e. satisfying the contracts) are taken into consideration; (ii) guaranteeing that a component at a higher level of abstraction is an accurate representation of a lower level component (or aggregation of components); (iii) checking that an architecture platform is indeed a correct refinement of a specification platform, and (iv) formalizing top-level system requirements.</p><p>Since compatibility is assessed among components at the same abstraction layer, the first category of contracts is denoted as horizontal contracts. If an environment violates a horizontal contract, it cannot host any of its implementations.</p><p>However, checking horizontal contracts is not sufficient, in general, to guarantee correct implementations. When <ref type="bibr">VOLUME 2, 2014</ref> analyzing the behavior of complex cyber-physical systems, simplified macro-models can be used to capture the relevant behavior of the components at higher levels of abstraction. Therefore, guarantees should also be provided on the accuracy of the macro-models with respect to models at lower levels of abstraction. These guarantees are captured via bottom-up vertical contracts. On the other hand, vertical contracts can also be used to encode top-down requirements that system architects introduce to craft the behavior of a chosen architecture according to the desired functionality. The above set of constraints can be expressed using topdown vertical contracts. They are used to ensure that an implementation is correct, by checking that the architecture platform is a refinement of the specification platform.</p><p>To partition system specifications, we identify which entity is responsible for a set of requirements, and which ones are just indirectly affected. By assigning information about requirements to components, we make it explicit what each component guarantees and what it assumes about its environment. Both of these aspects determine the top-down vertical contract for the component. If the assumptions are satisfied, then the component specification can be developed independently of other subsystems. In section IV, we exploit this concept to independently develop the electric power system topology and its control protocol.</p><p>To formulate system and component requirements as contracts, we adopt different formalisms based on the computational models used to represent the components and the tools used to analyze and synthesize them. Example of formalisms include automata or temporal logic constructs (e.g. used for safety requirements), probabilistic constraints (e.g. used for reliability requirements), linear arithmetic constraints on Boolean variables (e.g. used for connectivity requirements), integro-differential equations, and linear or nonlinear constraints on real numbers (e.g. used for real-time requirements). In what follows, we review the formalisms adopted in Section VI for the analysis and synthesis of reactive controllers in a contract-based framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. REQUIREMENT FORMALIZATION</head><p>We use two formal specification languages, namely, linear temporal logic (LTL) and signal temporal logic (STL), particularly suitable for capturing system and component requirements and reasoning about the correctness of their behaviors. As such, these languages will be used for defining contracts for control design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) LINEAR TEMPORAL LOGIC</head><p>Temporal logic is a branch of logic that incorporates temporal aspects in order to reason about propositions in time, and was first used as a specification language by Pnueli <ref type="bibr" target="#b21">[22]</ref>. In this section, we consider a version of temporal logic called linear temporal logic (LTL), whose formal semantics can be found in <ref type="bibr" target="#b22">[23]</ref>. While in contract-based design the component is regarded as the fundamental element of a design, and systems are denoted as interconnections of components, as we describe the basics of LTL, we prefer to adhere to the classical terminology, which is historically consolidated <ref type="bibr" target="#b22">[23]</ref>, and define design abstractions in terms of systems.</p><p>Definition 1: A system consists of a set S of variables. The domain of S, denoted by dom(S), is the set of valuations of S.</p><p>Definition 2: An atomic proposition is a statement on system variables that has a unique truth value (True or False) for a given value s. Let s ∈ dom(S) be a state of the system (i.e., a specific valuation of its variables) and p be an atomic proposition. Then s | p if p is True at the state s. Otherwise, s | p.</p><p>LTL also includes Boolean connectors such as negation (¬), disjunction (∨), conjunction (∧), material implication (→), and two basic temporal modalities, next ( ) and until (U). By combining these operators, it is possible to specify a wide range of requirements. Given a set AP of atomic propositions, LTL formulas are formed according to the following grammar:</p><formula xml:id="formula_6">ϕ := True | p | ¬ϕ | ϕ 1 ∧ ϕ 2 | ϕ| ϕ 1 U ϕ 2</formula><p>where p ∈ AP. Formulas involving other operators, including eventually (♦) and always ( ), can be derived from these basic ones.</p><p>LTL formulas over AP are interpreted over infinite sequences of states. In the LTL abstraction, we denote such a sequence as a behavior of the system. Let σ = s 0 s 1 s 2 . . . be a behavior and ϕ be an LTL formula. We say that ϕ holds at position i ≥ 0 of σ , written s i | ϕ, if and only if ϕ holds for the remainder of the sequence starting at position i. Then, a sequence σ satisfies ϕ, denoted by σ | ϕ, if s 0 | ϕ. Let be the collection of all sequences σ such that σ ∈ . Then, a system composed of the variables S is said to satisfy ϕ, written | ϕ, if all sequences satisfy ϕ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) SIGNAL TEMPORAL LOGIC</head><p>LTL allows formal reasoning about temporal behaviors of systems with Boolean, discrete-time signals (variables) or sequences of events. To deal with dense-time real signals and hybrid dynamical model that mix the discrete dynamics of the controller with the continuous dynamics of the plant, several logics have been introduced over the years, such as Timed Propositional Temporal Logic <ref type="bibr" target="#b23">[24]</ref>, and Metric Temporal Logic <ref type="bibr" target="#b24">[25]</ref>. Signal Temporal Logic (STL) <ref type="bibr" target="#b25">[26]</ref> has been proposed more recently as a specification language for constraints on real-valued signals in the context of analog and mixed-signal circuits. In this paper, we refine LTL system requirements into constraints on physical variables (e.g. voltages and currents) expressed using STL constructs. Then, we monitor and process simulation traces to verify constraint satisfaction, while optimizing a set of design parameters.</p><p>For a hybrid dynamical model, we define a signal as a function mapping the time domain T = R ≥0 to the reals R. A multi-dimensional signal q is then a function from T to R n such that ∀t ∈ T, q(t) = (q 1 (t), . . . , q n (t)), where q i (t) is the i-th component of vector q(t). It is convenient to repre-sent the behavior of the system's variables over time using multi-dimensional signals. Therefore, we assume that a hybrid system behavioral model F (e.g. implemented in a simulator) takes as input a signal u(t) and computes an output signal y(t) and an internal signal x(t) such that F(u(t), y(t), x(t), κ) = 0, where κ is a given vector of system configuration parameters. A collection of signals resulting from a simulation of the system is a trace, which can also be viewed as a multi-dimensional signal. A trace s(t) that includes all the system input, output and internal signals can also denote a system behavior.</p><p>In STL, constraints on real-valued signals, or predicates, can be reduced to the form µ = g(q) ∼ π , where g is a scalar-valued function over the signal q, ∼∈ {&lt;, ≤, ≥, &gt;, =, =}, and π is a real number. As in LTL, temporal formulas are formed using temporal operators, always, eventually and until. However, each temporal operator is indexed by intervals of the form (a, b), <ref type="bibr">)</ref>, where each of a, b is a non-negative real-valued constant. If I is an interval, then an STL formula is written using the following grammar:</p><formula xml:id="formula_7">(a, b], [a, b), [a, b], (a, ∞) or [a, ∞</formula><formula xml:id="formula_8">ϕ := True | µ | ¬ϕ | ϕ 1 ∧ ϕ 2 | ϕ 1 U I ϕ 2</formula><p>The always and eventually operators are defined as special cases of the until operator as follows:</p><formula xml:id="formula_9">I ϕ ¬♦ I ¬ϕ, ♦ I ϕ True U I ϕ. When the interval I is omitted, we use the default interval of [0, +∞).</formula><p>The semantics of STL formulas are defined informally as follows. The signal q satisfies µ = g(q) &lt; 2 at time t (where t ≥ 0), written (q, t) | µ, if g(q(t)) &lt; 2. It satisfies ϕ = [0,2) (q &gt; -1), written (q, t) | ϕ, if for all time 0 ≤ t &lt; 2, q(t) &gt; -1. The signal q 1 satisfies ϕ = ♦ [1,2) q 1 &gt; 0.4 iff there exists time t such that 1 ≤ t &lt; 2 and q 1 (t) &gt; 0.4. The two-dimensional signal q = (q 1 , q 2 ) satisfies the formula ϕ = (q 1 &gt; 10) U [2.3,4.5] (q 2 &lt; 1) iff there is some time t 0 where 2.3 ≤ t 0 ≤ 4.5 and q 2 (t 0 ) &lt; 1, and for all time t in [2.3, t 0 ), q 1 (t) is greater than 10. We write q | ϕ as a shorthand of (q, 0) | ϕ. Formal semantics can be found in <ref type="bibr" target="#b25">[26]</ref>.</p><p>Parametric Signal Temporal Logic (PSTL) is an extension of STL introduced in <ref type="bibr" target="#b26">[27]</ref> to define template formulas containing unknown parameters. Syntactically speaking, a PSTL formula is an STL formula where numeric constants, either in the constraints given by the predicates µ or in the time intervals of the temporal operators, can be replaced by symbolic parameters. These parameters are divided into two types:</p><p>• A scale parameter π is a parameter appearing in predicates of the form µ = g(q) ∼ π ,</p><p>• A time parameter τ is a parameter appearing in an interval of a temporal operator. An STL formula is obtained by pairing a PSTL formula with a valuation function that assigns a value to each symbolic parameter. For example, consider the PSTL formula ϕ(π, τ ) = [0,τ ] q &gt; π, with symbolic parameters π (scale) and τ (time). The STL formula [0,10] q &gt; 1.2 is an instance of ϕ obtained with the valuation w = {τ → 10, π → 1.2}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. REACTIVE CONTROL SYNTHESIS</head><p>Reactive systems are systems that maintain an ongoing relation with their environment by appropriately reacting to it. The controllers that regulate the behavior of such systems are called reactive controllers.</p><p>A control system is a composition of a physical plant, including sensors and actuators (e.g., an electric power system topology with fault sensors and contactors), and an embedded controller that runs a control protocol (control logic) to restrict the behaviors of the plant so that all the remaining behaviors satisfy a set of system specifications. System specifications can be expressed as a contract C = (A, G), where, roughly speaking, assumptions A encode the allowable behaviors of the environment the control system operates in, and guarantees G encode the system requirements.</p><p>The synthesis of reactive controls can then be interpreted in terms of assume-guarantee contracts. Given the system contract C, control synthesis finds a control logic that, when implemented, ensures that the system satisfies C; or declares that no such logic exists. It is possible to extend this idea to distributed control architectures. In distributed synthesis, different control subsystems can be composed if their contracts are compatible. Hence, the goal of distributed synthesis is to simultaneously refine a system contract into compatible horizontal contracts for the components (i.e., subsystems), and to find the control logics that realize those contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) REACTIVE SYNTHESIS FROM LTL SPECIFICATIONS</head><p>Let E and D be sets of environment and controlled variables, respectively. Let s = (e, d) ∈ dom(E) × dom(D) be a state of the system. Consider an LTL specification ϕ of assumeguarantee form</p><formula xml:id="formula_10">ϕ = (ϕ e → ϕ s ),<label>(4)</label></formula><p>where ϕ e characterizes the assumptions on the environment and ϕ s characterizes the system requirements. The synthesis problem is concerned with constructing a control protocol (a partial function f : (s 0 s 1 . . . s t-1 , e t ) → d t ) which chooses the move of the controlled variables based on the state sequence so far and the behavior of the environment so that the system satisfies ϕ s as long as the environment satisfies ϕ e . If such a protocol exists, the specification ϕ is said to be realizable. Reactive synthesis can then be viewed as a two-player game between an environment that attempts to falsify the specification in equation ( <ref type="formula" target="#formula_10">4</ref>) and a controlled plant that tries to satisfy it. For general LTL, the synthesis problem has a doubly exponential complexity <ref type="bibr" target="#b27">[28]</ref>. However, a subset of LTL, namely generalized reactivity (1) (GR(1)), generates problems that can be solved in polynomial time (i.e., polynomial in |dom(E)×dom(D)|, the number of valuations of the variables in E and D) <ref type="bibr" target="#b28">[29]</ref>. GR(1) specifications restrict ϕ e and ϕ s to take the following form, for α ∈ {e, s},</p><formula xml:id="formula_11">ϕ α := ϕ α init ∧ i∈I α 1 ϕ α 1,i ∧ i∈I α 2 ♦ϕ α 2,i , VOLUME 2, 2014</formula><p>where ϕ α init is a propositional formula characterizing the initial conditions; ϕ α 1,i are transition relations characterizing safe, allowable moves and propositional formulas characterizing invariants; ϕ α 2,i are propositional formulas characterizing states that should be attained infinitely often; I α 1 and I α 2 are index sets enumerating formulas ϕ α 1,i and ϕ α 2,i , respectively. Given a GR(1) specification, there are game solvers and digital design synthesis tools that generate a finite-state automaton that represents the control protocol for the system <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b30">[31]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) DISTRIBUTED SYNTHESIS</head><p>To provide an inherent level of redundancy for system reliability, distributed control architectures are increasingly being adopted in modern aircraft electric power systems, thus motivating the extension of reactive synthesis techniques to the design of distributed controllers. Given a global specification and a system composed of subsystems, distributed synthesis proceeds by first finding local specifications for each subsystem, and then synthesizing local controllers for these subsystems separately. If the local specifications satisfy certain conditions, it can be shown that the local controllers realizing these local specifications can be implemented together and the overall system is guaranteed to satisfy the global specification, as detailed in <ref type="bibr" target="#b14">[15]</ref>. We describe below a special case of distributed architecture, i.e. a serial interconnection of controllers, which is used in the design in Section VII-B.2 to synthesize controllers for AC and DC subsystems separately. The following theorem is based on a result that was first reported in <ref type="bibr" target="#b14">[15]</ref>. We introduce here a new proof that shows how contracts can offer a rigorous and effective framework to reason about distributed control architectures in a compositional manner.</p><p>Theorem 3.1: Given</p><p>• a system characterized by a set S = D ∪ E of variables, where D and E are disjoint sets of controllable and environment variables,</p><p>• its two subsystems with variables</p><formula xml:id="formula_12">S 1 = D 1 ∪ E 1 and S 2 = D 2 ∪ E 2 ,</formula><p>where for each i ∈ {1, 2}, D i and E i are disjoint sets of controllable and environment variables for the i th subsystem, D 1 and D 2 are disjoint, and</p><formula xml:id="formula_13">D = D 1 ∪ D 2 ,</formula><p>• a set I of pairs of variables representing the interconnection structure, that is, for a serial interconnection, if the following conditions hold:</p><formula xml:id="formula_14">I = {(o 1 , i 2 )|o 1 ∈ O 1 ⊆ (D 1 ∪ E 1 ), i 2 ∈ I 2 ⊆ E 2 },</formula><p>1) any behavior that satisfies ϕ e also satisfies (ϕ e 1 ∧ ϕ e 2 ), 2) any behavior that satisfies (ϕ s 1 ∧ ϕ s 2 ) also satisfies ϕ s , 3) there exist two controllers that make the local specifications (ϕ e 1 → ϕ s 1 ) and (ϕ e 2 → ϕ s 2 ) true under the interconnection structure I; then, implementing the two controller together leads to a controller that satisfies the global specification ϕ e → ϕ s .</p><p>Proof: The conditions on D, D 1 , D 2 ensure that the two controllers are composable, i.e. they do not try to control the same output (controllable) variables. We first derive contracts from global and local specifications, by defining the following sets of behaviors in terms of assumptions and guarantees:</p><formula xml:id="formula_15">A = {σ : σ | ϕ e }; A i = {σ : σ | ϕ e i }; G = {σ : σ | (ϕ e → ϕ s )}; G i = {σ : σ | (ϕ e i → ϕ s i )}; A = {σ : σ | (ϕ e 1 ∧ ϕ e 2 )}; G = {σ : σ | (ϕ e 1 ∧ ϕ e 2 ) → (ϕ s 1 ∧ ϕ s 2 ) }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We immediately observe that</head><formula xml:id="formula_16">A = A 1 ∩ A 2 while G ⊇ (G 1 ∩G 2 ). Now, let C = (A, G) be the global contract and C 1 = (A 1 , G 1 ), C 2 = (A 2 , G 2 ) the local contracts, all in saturated form. Clearly, for any implementation M i , M i | C i if and only if its set of behaviors σ M i ⊆ G i , i.e. σ M i | ϕ i ,</formula><p>after alphabet equalization. Moreover, because any implementations M 1 and M 2 of C 1 and C 2 are composable, contract composition using equations ( <ref type="formula" target="#formula_2">1</ref>) and ( <ref type="formula" target="#formula_3">2</ref>) is well defined and the composition M 1 × M 2 (under the interconnection I) is an implementation of C 1 ⊗ C 2 (under the interconnection I).</p><p>We now prove that</p><formula xml:id="formula_17">C 1 ⊗ C 2 C, i.e., C 1 ⊗ C 2 = (A 12 , G 12 ) refines C.</formula><p>By the definition of refinement, this amounts to showing that G 12 ⊆ G and A 12 ⊇ A. We obtain</p><formula xml:id="formula_18">G 12 = (G 1 ∩ G 2 ) ⊆ G ⊆ G (5)</formula><p>by conditions 1 and 2 in the theorem statement, and</p><formula xml:id="formula_19">A 12 = (A 1 ∩ A 2 ∪ ¬G 12 ) ⊇ (A 1 ∩ A 2 ) = A ⊇ A,<label>(6)</label></formula><p>by condition 1. Moreover, if C is compatible (i.e. A is not empty), C 1 ⊗ C 2 will also be compatible (i.e. A 12 is not empty) by <ref type="bibr" target="#b5">(6)</ref>. Equations ( <ref type="formula">5</ref>) and ( <ref type="formula" target="#formula_19">6</ref>) allow us to conclude that C 1 ⊗ C 2 is well defined and refines C, hence for any implementations M 1 and M 2 of C 1 and C 2 , M 1 × M 2 satisfies the global specification.</p><p>There are two sources of conservatism in distributed synthesis. The first one is due to the fact that local controllers have only local information. Therefore, even if there exists a centralized controller that realizes a global specification, there may not exist local controllers that do so. This is an inherent problem and can only be addressed by modifying the control architecture (e.g., by changing the mapping of controlled variables to controllers, by introducing new sensors, or by modifying the information flow between local controllers). The second source of conservatism is computational. Even when local controllers that realize the global specification exist, it might be difficult to find them (e.g., see <ref type="bibr" target="#b27">[28]</ref> for some undecidability results). We note that the conditions provided in Theorem 3.1 are only sufficient conditions. The choices of ϕ e j and ϕ s j for j ∈ {1, 2} plays a role in the level of conservatism. In principle, ϕ e j and ϕ s j should be chosen such that A is as ''small'' as possible, and G is as ''large'' as possible in the sense of set inclusion. Hence, when conditions 1 and 2 are satisfied but condition 3 is not satisfied, one can gradually refine the local specifications. See <ref type="bibr" target="#b14">[15]</ref> for further details and an example of such a refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. DESIGN SPACE EXPLORATION AND PERFORMANCE OPTIMIZATION</head><p>Several real-time performance requirements (e.g. timing constraints), mostly relating to the dynamic behaviors of the physical plant and the hardware implementation of the control algorithm, are better assessed on hybrid dynamical models. For this purpose, we refine a subset of LTL requirements into STL constructs on physical (e.g. electrical, mechanical) quantities and leverage off-line or on-line monitoring techniques while optimizing the system.</p><p>A Boolean verdict on whether a property is satisfied may not be sufficient for design space exploration and system optimization. In fact, we are also interested in capturing the robustness of satisfaction of a formula ϕ by a signal q, i.e., the amount of margin by which a property is satisfied. To do so, we refer to the quantitative semantics of STL. The quantitative semantics of STL are defined using a real-valued function ρ of a trace q, a formula ϕ, and time t satisfying the following property:</p><formula xml:id="formula_20">ρ(ϕ, q, t) ≥ 0 iff (q, t) | ϕ.<label>(7)</label></formula><p>The underlying idea is that, whenever the absolute value of ρ(ϕ, q, t) is large, a change in q is less likely to affect the Boolean satisfaction (or violation) of ϕ by q, i.e. the margin by which a design satisfies ϕ is larger. Without loss of generality, an STL predicate µ can be identified to an inequality of the form g(q) ≥ 0 (the use of strict or non strict inequalities is a matter of choice and other inequalities can be trivially transformed into this form). From this form, a straightforward quantitative semantics for predicate µ is defined as</p><formula xml:id="formula_21">ρ(µ, q, t) = g(q(t)). (<label>8</label></formula><formula xml:id="formula_22">)</formula><p>Then ρ can be inductively defined for every STL formula using the following rules:</p><formula xml:id="formula_23">ρ(¬ϕ, q, t) = -ρ(ϕ, q, t) (9) ρ(ϕ 1 ∧ ϕ 2 , q, t) = min(ρ(ϕ 1 , q, t), ρ(ϕ 2 , q, t)) (10) ρ(ϕ 1 U I ϕ 2 , q, t) = sup t ∈t+I min ρ(ϕ 2 , q, t ), inf t ∈[t,t ) ρ(ϕ 1 , q, t ) .<label>(11)</label></formula><p>Additionally, by combining equation <ref type="bibr" target="#b10">(11)</ref>, and I ϕ ¬♦ I ¬ϕ, we get</p><formula xml:id="formula_24">ρ( I ϕ, q, t) = inf t ∈t+I ρ(ϕ, q, t )<label>(12)</label></formula><p>Finally, for ♦, we get a similar expression using sup instead of inf. It can be shown that ρ, as defined above, satisfies equation ( <ref type="formula" target="#formula_20">7</ref>) and thus defines a quantitative semantics for STL <ref type="bibr" target="#b31">[32]</ref>. By leveraging such quantitative semantics, a design space exploration problem on a hybrid system model defined as in Section III-D.2 can be formulated as follows. Let C STL = (ϕ e , ϕ s ) be an STL contract encoding a set of system requirements, with ϕ e and ϕ s PSTL formulas. Let C be an array of costs, and κ ∈ K a vector of platform configuration parameters, i.e., a vector of variables in the hybrid system model that are selected as a result of the design process. Our goal is to find a set of parameter vectors κ * that are Pareto optimal with respect to the objectives in C, while guaranteeing that the system satisfies ϕ s for all possible system traces s ∈ S satisfying the environment assumptions ϕ e . Examples of design parameters could be the controller clock or a tunable delay in a component.</p><p>To formalize the above multi-objective optimization problem, we partition ϕ s as</p><formula xml:id="formula_25">ϕ s (τ , π ) = ϕ sc (τ , π ) ∧ m i=1 ϕ sr,i (τ , π),<label>(13)</label></formula><p>where a set of time parameters τ ∈ T and scale parameters π ∈ Π can be used to capture degrees of freedom that are available in the system specifications, and whose final value can also be determined as a result of the optimization process. The formula ϕ sc in (13) encodes the requirements that will be considered as ''hard'' optimization constraints for Boolean satisfaction, while ϕ sr,i are formulas that will also be considered for robust satisfaction, i.e., given a system trace s and a parameter set (τ , π ), the robust satisfaction ρ i (ϕ sr,i (τ , π ), s , 0) will also be computed. Similarly, the array of costs C can be partitioned as follows</p><formula xml:id="formula_26">C(κ, τ , π) = C c (κ, τ , π), C i (ρ i (ϕ s,ri (τ , π), s(κ), 0)) 1≤i≤m ,<label>(14)</label></formula><p>where C c (κ, τ , π) is a vector of costs that depend only on the parameters of the model and the formulas; it can be used to capture, for instance, some performance figures (e.g., bandwidth, energy) as a function of the system design parameters, or the duration of a requirement violation. Each component C i (ρ i (ϕ sr,i , s, 0)) in ( <ref type="formula" target="#formula_26">14</ref>) is instead a scalar function of the quantitative satisfaction of each formula ϕ sr,i ; it can be used to capture and maximize the margin by which ϕ sr,i is satisfied.</p><p>By putting it all together, the design exploration problem can be expressed as a multi-objective robust optimization problem min κ∈K,τ ∈T,π ∈Π C(κ, τ , π)</p><p>s.t.</p><formula xml:id="formula_28">   F(s, κ) = 0 s | ϕ s (τ , π) ∀s s.t. s | ϕ e VOLUME 2, 2014 FIGURE 2.</formula><p>Pictorial representation of the main steps in the electric power system design flow in Fig. <ref type="figure">3</ref>.</p><p>where we aim to minimize a set of costs over all possible system and formula parameter valuations, for all the system behaviors satisfying the behavioral model and the contract C STL . For a given parameter valuation κ , s = (u , y , x ) is the trace of input, output and internal signals that are obtained by simulating F(.). A multi-objective optimization algorithm with simulation in the loop can then be used to find the Pareto optimal solutions κ * . While this may be expensive in general, it becomes affordable in many practical cases, as will be shown in Section VI and Section VII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. PLATFORM-BASED FLOW FOR ELECTRIC POWER SYSTEM DESIGN USING CONTRACTS</head><p>Our design flow, pictorially represented in Fig. <ref type="figure">2</ref>, consists of two main steps, namely, topology design and control design.</p><p>The topology design step instantiates electric power system components and connections among them to generate an optimal topology while guaranteeing the desired reliability level. Given this topology, the BPCU state machine can then be synthesized in the control design phase to actuate contactors while guaranteeing that loads are correctly powered. The above two steps are, however, connected. The correctness of the controller needs to be enforced in conjunction with its boundary conditions, i.e., the assumptions on the entities that are not controlled, yet interact with it. An example of such an assumption is the number of paths from generators to a load made available by the electric power system architecture to the controller. Similarly, the reliability of an architecture must be assessed under the assumptions that the controller adequately configures the contactors to leverage the available paths. Therefore, to achieve independent implementation of architecture and controller, we address the synthesis problem in a compositional way, by using contracts to incorporate the information on the environment conditions under which each entity is expected to operate.</p><p>Our design process includes a top-down and a bottom-up phase. In the top-down phase, we associate the requirements to the different entities in the system and formulate topdown vertical contracts for them. In the bottom-up phase, we populate the library of architecture components including, for instance, generators, buses, power converters and contactors. Each component is characterized by its attributes, including multiple models or views, such as behavioral or reliability views, and finite state machine or continuous-time models, as detailed in Section III-A. Horizontal contracts specify legal compositions between components. Bottom-up vertical contracts define under which conditions a model is a faithful representation of a physical element in the system. In what follows, we provide details on the electric power system design space exploration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. DESIGN SPACE EXPLORATION</head><p>There is currently no automated procedure for optimal synthesis of control protocols simultaneously subject to reliability, safety and real-time performance constraints. Therefore, we reason about these three aspects of the design by using specialized analysis and synthesis frameworks that operate with different formalisms. Contracts specifying the interface between components and views help transfer requirements between different frameworks and verify correctness with respect to the full set of requirements. As also shown in Fig. <ref type="figure">3</ref>, our design space exploration is organized as follows: FIGURE 3. Electric power system architecture and control design flow and tool chain. a) From system requirements, we generate a set of requirements for the electric power system architecture (denoted as a contract C T in Fig. <ref type="figure">3</ref>). Safety, connectivity and power flow requirements are expressed as arithmetic constraints on Boolean variables (mixed integer-linear inequalities); reliability constraints are inequalities on real numbers involving component failure probabilities.</p><p>The trade-off between redundancy and cost can then be explored and an electric power system topology is synthesized to minimize the total component cost while satisfying the constraints above. The synthesized topology serves as a specification (assumption) for the subsequent control design step. b) A subset of the original high-level system specifications are translated into LTL formulas for the topology generated in a) (contract C C,LTL in Fig. <ref type="figure">3</ref>). Using the results in Section III-E, a reactive control protocol is then synthesized from LTL constructs and made available as one (or more) state machines, satisfying safety and reliability specifications by construction. However, several architectural and real-time constraints (e.g. timing) related to the physical plant and the hardware implementation of the control algorithm are not available at this level of abstraction. Approaches to incorporate timing within reactive control synthesis, by using timed specification languages (e.g., timed computation tree logic) and related synthesis tools (e.g., UPPAAL-Tiga <ref type="bibr" target="#b32">[33]</ref>), are currently under investigation. In this work, timing constraints are handled at a lower abstraction level, as detailed below. c) The architecture in a) and the controller in b) are executed using continuous-time or hybrid behavioral models to assess satisfaction of (some of) the requirements at a lower abstraction level (contract C C,STL in Fig. <ref type="figure">3</ref>).</p><p>The LTL requirements from b) are also refined into STL formulas (contract C C,LTL in Fig. <ref type="figure">3</ref>). Simulation traces are monitored to verify and optimize the controller using the approach detailed in Section III-F. As an example, an optimal reaction period can be selected in the presence of delays in the switches and under the assumption of a synchronous controller implementation. The resulting architecture and controller pair is then returned as the final design. We provide details on both topology and control synthesis in Section V and Section VI, including sufficient conditions for their co-design, while guaranteeing that top-level requirements for the controlled system are satisfied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. ELECTRIC POWER SYSTEM TOPOLOGY DESIGN</head><p>We cast the topology design problem as a mixed integer-linear optimization problem. Our goal is to derive an electric power system architecture that satisfies a set of connectivity, power flow and reliability requirements, while minimizing cost and complexity (i.e. number of components) of the overall network.</p><p>The electric power system architecture is modelled as a directed graph G = (V , E), where each node v i ∈ V represents a component (with the exception of contactors, which are associated with edges) and each edge e ij ∈ E represents the interconnection between v i and v j (i, j ∈ {1, . . . , n}). Therefore, the set of Boolean variables {e ij }, each denoting the presence or absence of an interconnection, are the decision variables for our optimization problem. While connectivity and power flow requirements generate constraints that are linear in the decision variables, or can be straightforwardly linearized, the situation is different for reliability constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Topology Design</head><p>A reliability constraint prescribes that the failure probability of a critical load, i.e. the probability that a load stays unpowered longer than specified because of failures, should be less than a desired threshold. As further discussed in Section V-B, evaluating such a failure probability produces high-order polynomial inequalities in terms of the decision variables. Such constraints would either call for a nonlinear solver or for several symbolic manipulations and linearization techniques, possibly involving large sets of auxiliary variables. Therefore, instead of formulating a single, ''flat'' optimization problem, we propose an iterative algorithm inspired by the mixed integer-linear programming modulo theory approach <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b34">[35]</ref>, summarized in Algorithm 1.</p><p>The topology design algorithm receives as inputs: (part of) the electric power system platform library L, including generator power ratings g, component costs w and failure probabilities P; a topology template T with the maximum number of allowed components for each category and their composition rules; the set of requirements, including connectivity constraints, load power and reliability requirements. Reliability requirements are generally specified at critical loads or essential buses; to simplify, in Algorithm 1, we assume that an overall system reliability requirement r * is provided, as defined in Section V-B.</p><p>A mixed integer-linear program (MILP) generates minimum cost topologies for the given set of connectivity and power flow constraints. The MILP is solved in a loop with a reliability analysis algorithm, which receives as input a candidate topology, evaluates the failure probability of critical loads and implements strategies to improve the reliability, by providing additional constraints for the MILP, until all requirements are satisfied.</p><p>The contract for the topology design step can then be expressed as a pair C T = (A T , G T ), where A T represents the set of topology graphs that conform to the template T and are labelled with the generator power ratings g, the component costs w and failure probabilities P. G T represents the topology graphs that satisfy the load reliability requirements and power requirements (in nominal conditions). Both A T and G T can be concretely expressed using mixed integerlinear or nonlinear constraints (originated from probability computations) in the decision variables and the graph model parameters. In what follows, we detail the two key VOLUME 2, 2014 components of our synthesis flow, namely the MILP formulation function FORMMILP and the reliability analysis function RELANALYSIS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. MIXED INTEGER-LINEAR PROGRAM FORMULATION</head><p>FORMMILP formulates the optimization problem by assuming an initial graph template T for the electric power system topology, comprising a maximal number of virtual nodes and edges together with their composition rules. Some nodes and edges are activated during an optimization run to generate a candidate topology. The others remain inactive or can be used in subsequent optimization runs to provide redundant paths, by increasing or reconfiguring the electric power system interconnections until all the reliability requirements are satisfied. The candidate topology resulting from an optimization step is a minimal topology, in which unnecessary nodes and edges are pruned away to minimize the overall network cost, while satisfying a set of connectivity and power flow constraints.</p><p>To simplify our notation, we partition the adjacency matrix of G into smaller blocks to represent interconnections between subsets of components, as summarized in Table <ref type="table" target="#tab_3">2</ref>. For instance, the interconnections between n gen generators and n acb AC buses can be represented by a n gen × n acb connectivity sub-matrix denoted as M gb . We further assume that any interconnection (edge) between two components is associated to a contactor. Relaxing this assumption entails minor modifications in our formulation to handle contactors as separate nodes in G. The cost function is the sum of the costs of all components (associated with the nodes) and contactors (associated with the edges) used in the electric power system architecture, i.e.</p><formula xml:id="formula_29">|V | i=1 δ i w i + |V | i=1 |V | j=1 e ij wij (<label>16</label></formula><formula xml:id="formula_30">)</formula><p>where |V | is the number of nodes, w i is the cost of component i, wij is the cost of contactor on edge e ij and δ i is a binary variable equal to one if the component is instantiated in a topology and zero otherwise. All components and paths in the electric power system need to obey the composition rules in our library. In particular, connectivity constraints enforce legal connections among components and are formalized as arithmetic constraints on the Boolean decision variables. As an example, we prescribe that any DC load must be directly connected to only one DC bus as follows:</p><formula xml:id="formula_31">n dcb i=1 M dl i,j = 1 ∀ j ∈ N, j ∈ [1, n load ].</formula><p>Moreover, all DC buses that are connected to the network (e.g. to a load or another DC bus) must be connected to at least one TRU to receive power from an AC bus i.e.</p><formula xml:id="formula_32">∀ j ∈ N, j ∈ [1, n dcb ] n rec i=1 M rd i,j ≥ n load i=1 M dl j,i , n rec i=1 M rd i,j ≥ n dcb i=1 M dd j,i .</formula><p>All TRUs that are connected to a DC bus must be connected to at least one AC bus, i.e.</p><formula xml:id="formula_33">∀ j ∈ N, j ∈ [1, n rec ] n acb i=1 M br i,j ≥ n dcb i=1 M rd j,i .</formula><p>Similarly, all AC buses that are connected to a TRU or another AC bus must be connected to one generator, i.e.</p><formula xml:id="formula_34">∀ j ∈ N, j ∈ [1, n acb ] n gen i=1 M gb i,j ≥ n rec i=1 M br j,i , n gen i=1 M gb i,j ≥ n acb i=1 M bb j,i ,</formula><p>while a rectifier cannot be directly connected to more than one DC bus and to more than one AC bus, i.e.</p><formula xml:id="formula_35">∀ j ∈ N, j ∈ [1, n rec ] n dcb i=1 M rd j,i ≤ 1, n acb i=1 M br i,j ≤ 1.</formula><p>Power-flow constraints are used to enforce that the total power provided by the generators in each operating condition is greater than or equal to the total power required by the connected loads. For instance, in normal operating conditions, the power generated on each side should be greater than or equal to the total power required by the loads on that side. On the other hand, when only the APU is active, then it should be capable of powering at least the non-sheddable loads on both sides of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. RELIABILITY ANALYSIS</head><p>As discussed in Section III-A, every library component is characterized by a reliability model estimating the failure probability during its operation. Experimental data on the failure rates of the physical components (e.g. contactors, generators, buses) have been collected over the years and made available in the literature. Failure rates can be related to probabilities as follows. We assume that the time at which a component can fail is a random variable with an exponential distribution, whose parameter λ is the failure rate <ref type="bibr" target="#b35">[36]</ref>. Therefore, the probability that a failure is observed in a time interval T can be computed as P fail = 1 -e -λT . The objective of the reliability analysis function RELANALYSIS is then to compute the probability of composite events of failure in the system, starting from the failure probabilities of its components. We denote as overall system failure F an event in which there is no possibility for any of the available generators to deliver power to a critical load or an essential bus. Therefore, the overall system failure probability r, also denoted as reliability level, is defined as</p><formula xml:id="formula_36">r = P(F) = P m k=1 F k ,<label>(17)</label></formula><p>where F k is a failure event at the critical load (or essential bus) j, and m is the total number of critical loads (or essential buses). We assume that when a component fails, it is no longer possible to deliver power from and through that component, i.e. the component becomes an open circuit in the schematic and cannot be recovered. Moreover, failures in different components are considered as independent.</p><p>To compute the reliability at a critical load, we adopt an extension of traditional fault tree analysis (FTA) that supports hierarchical composition, similar to the approach in <ref type="bibr" target="#b36">[37]</ref>. Besides handling decomposition with respect to the hierarchy of failure influences, our formulation is able to compute failure probabilities directly from the electric power system topology. Our assumption is that the reliability level of an electric power system can be statically determined by its topological structure and the redundancy of the paths used to power a critical load.</p><p>To compute the event F i of a system failure at component i, we first convert the original electric power system graph G = (V , E) into a directed graph G . An edge is directed from v i to v j if v i receives power by (or through) v j when traversing the graph from a critical load to a generator. An example of such a graph G is shown in Fig. <ref type="figure" target="#fig_2">4</ref>. Let A be the adjacency matrix for G , P i be the event that component i fails (self-induced failure), and let p i = P(P i ). Then, the event F i of a system failure at component i can be recursively computed as follows</p><formula xml:id="formula_37">F i = P i ∪     n j=1 A i,j =0 F j     (18)</formula><p>where A i,j is i th -row, j th -column element of A. In other words, component i ceases to be powered when either a failure is generated by itself, or when failures are induced in all its neighbor nodes. We denote as neighbors only those nodes through which i can actually receive power.</p><p>When G is a tree, computing the failure probability for a critical load i is straightforward. The tree is traversed from the critical load (the root of the tree) to the generators (the leaves of the tree), and the probability of failure at node i can be directly derived from equation <ref type="bibr" target="#b17">(18)</ref> as</p><formula xml:id="formula_38">P(F i ) = p i if A i,j = 0 ∀j p i + (1 -p i ) n j=1 [P(F j )] A i,j otherwise. (<label>19</label></formula><formula xml:id="formula_39">)</formula><p>If G includes cycles, failure probabilities of critical loads can still be computed by traversing the graph using a similar procedure as above, as sketched by the recursive implementation in Algorithm 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 COMPRELIABILITY</head><p>To compute the failure probability at a critical load i, COMPRELIABILITY stores in L all the neighbor nodes of i that have not been visited yet (provided by the function UNVNEIGH). Then, COMPRELIABILITY generates all possible combinations of failure events due to components in L (provided by the function GENEVENT) and compute their probability, by multiplying the contributions due to independent components and summing up the contributions due to disjoint events. Whenever one (or more) components are healthy (EXISTSHEALTHY returns one), COMPRELIABILITY is recursively called by using such healthy components as current nodes. Recursion stops when either a healthy generator is found or L is empty. In the first case, there exists a path of healthy components from a generator to a critical load and, therefore, its failure probability is zero. Otherwise, a ''healthy'' path is found which does not include a generator; its contribution to the overall failure probability is then irrelevant and COMPRELIABILITY returns the neutral element 1.</p><p>At each iteration, if the optimal architecture satisfies the reliability constraints, it is returned as the final solution. Otherwise, RELANALYSIS. estimates the number of paths needed to achieve the desired reliability and suggests a set of strategies to implement the required paths by augmenting the original optimization problem with a set of connectivity  constraints. Such strategies are subsequently deployed until the target failure probability is reached. As a first strategy, the number of available paths is increased by introducing additional interconnections (and contactors) between the right and the left side buses of the system, where critical loads are connected. Afterwards, redundancy in the DC and AC buses on each side of the topology is increased. Finally, redundant components may be added if available, whenever they are compatible with other cost or weight constraints.</p><p>As an example of constraints generated to improve reliability, we enforce that the number of connections between leftside and right-side DC buses be incremented by adding</p><formula xml:id="formula_40">n L dcb i=1 n R dcb j=1 M d,LR,new i,j ≥ 1 + n L dcb i=1 n R dcb j=1 M d,LR,old i,j .<label>(20)</label></formula><p>However, if a right-side DC bus is connected to a left-side DC bus then it should also be connected to a right-side DC bus or load, i.e.,</p><formula xml:id="formula_41">M d,LR,new i,j ≤ max{max k M dl,R j,k , max k M dd,R j,k }<label>(21)</label></formula><formula xml:id="formula_42">∀ i ∈ N, i ∈ [1, n L dcb ], ∀ j ∈ N, j ∈ [1, n R dcb ]</formula><p>. Moreover, if a left-side DC bus is connected to a right-side DC bus, then it should also be connected to a rectifier, i.e.,</p><formula xml:id="formula_43">M d,LR,new i,j ≤ max k M rd,L k,i (22) ∀ i ∈ N, i ∈ [1, n L dcb ], ∀ j ∈ N, j ∈ [1, n R dcb ]</formula><p>. The superscripts R and L in equation <ref type="bibr" target="#b20">(21)</ref> and equation ( <ref type="formula">22</ref>) denote left and right-side matrices, M d,LR is the left-right DC bus connectivity matrix, n L dcb and n R dcb are the number of left and right DC buses, respectively. Equations ( <ref type="formula" target="#formula_40">20</ref>)-( <ref type="formula">22</ref>) are encoded and added to the optimization constraints for the next iteration every time the number of connections between left-side and right-side DC buses must be incremented. Similar constraints must also hold after replacing R with L, and vice-versa, in equations ( <ref type="formula" target="#formula_41">21</ref>) and <ref type="bibr" target="#b21">(22)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. ELECTRIC POWER SYSTEM CONTROLLER DESIGN</head><p>Power requirements of different loads might differ in an aircraft based on the mode of operation. Similarly, the availability of the generators and the health conditions of several components might vary during the flight. The goal of the BPCU (i.e., controller) is to reconfigure the electric power system and reroute power by appropriately reacting to such changes in system conditions to ensure that safety-critical loads are always powered. In this section we first describe how the control logic for the BPCU can be automatically synthesized within the proposed framework. Then, we present a domain specific language for electric power system to facilitate requirement formalization for reactive synthesis based on LTL. Finally, we discuss the use of STL and simulationbased design space exploration to check or enforce real-time constraints (e.g. timing) for controller implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. SYNTHESIS OF REACTIVE PROTOCOLS FOR ELECTRIC POWER DISTRIBUTION</head><p>The control protocol synthesis problem for electric power system can be stated as follows: given an electric power system topology (generated as discussed in Section V) and a formal specification describing assumptions on the components and requirements for the system, build a controller that reconfigures the system (via turning on and off the contactors) by sensing and reacting to the faults and the changes in system status so as to ensure that the specification is met. Next, we discuss how to formalize the requirements to recast the above problem as a reactive synthesis problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) VARIABLES</head><p>Environment variables include the health statuses of components that are uncontrolled. In our formulation, we consider only generators, APUs, and rectifier units as environment variables. They can each take values of healthy <ref type="bibr" target="#b0">(1)</ref> and unhealthy (0), and may change at any point in time. 1  Controlled variables are contactors, and can each take values of open (0) or closed <ref type="bibr" target="#b0">(1)</ref>. A closed contactor allows power to pass through, while an open one does not. Dependent variables are buses that can be either powered (1) or unpowered (0). Bus values will depend on the status of their neighboring contactors, buses, as well as the health status of connecting generators, APUs, or rectifier units. Timing considerations play a key part in the specifications for an electric power system. LTL, however, only addresses 1 Generators can be taken offline by the pilot or may stop functioning due to a fault. We do not differentiate between these cases and simply call a generator unhealthy when it is unavailable or malfunctioning. the notion of temporal ordering of events. To reconcile this discrepancy, we handle timing annotations by introducing clock variables. Verification of actual timing constraints related to the controller implementation is then performed at a lower abstraction level, as detailed in Section III-F.</p><p>Based on the set of variables above, system specifications are expressed as a contract C C = (A C , G C ), where assumptions A C encode the allowable behaviors of the environment the control system operates in, and guarantees G C encode the controller requirements. By defining A C = {σ |σ | ϕ e } and G C = {σ |σ | (ϕ e → ϕ s )}, with ϕ e and ϕ s as in equation ( <ref type="formula" target="#formula_10">4</ref>), a behavior σ | ϕ if and only if σ is in the guarantees of C C (already in saturated form). Therefore, solving the reactive synthesis problem is equivalent to generating an implementation for C C . The following lists the temporal logic formulas used to concretely express the contracts for controller synthesis for the primary distribution problem in an electric power system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) ENVIRONMENT ASSUMPTIONS</head><p>Let I be an index set enumerating the set of environment variables described in Section VI-A.1. For each environment variable e i , i ∈ I, let p i be its probability of failure in a given time interval T as defined in Section V-B. Let r S be the overall reliability level the system has to achieve, that is, the probability of the overall system failure should be less than or equal to r S . Assuming independence of component failures, the overall reliability level determines the allowable environment assumptions by providing a bound on the number of simultaneous component failures allowed. More formally, denote a single configuration of the environment (i.e., an environment state) by e. For a given subset I ⊆ I of the environment variables, we define e I = (e 1 , . . . , e |I| ), where e i = 0 (unhealthy) if i ∈ I ; and e i = 1 (healthy) otherwise. Let h : [0, 1] → 2 2 I be the function that maps the system reliability level to the possible environment configurations. We can then enumerate all allowable environment configurations based on the required reliability level, as</p><formula xml:id="formula_44">E S = e I |I ∈ h(r S ) .<label>(23)</label></formula><p>With this definitions, an environment assumption can be written in LTL as (e ∈ E S ).</p><p>As the function h can be difficult to compute, alternatively, one can reason about the probability r C of an environment configuration and map it back to the system reliability level r S . To this effect, we enumerate all environment configurations that occur with probability more than a given level r C . Then, if the control synthesis problem is realizable with the assumption (e ∈ E C ), this implies that the system level reliability is</p><formula xml:id="formula_45">r S = e / ∈E C j:e j =0 p j j:e j =1 (1 -p j ).</formula><p>The second environment assumption is also related to failure analysis. We assume that when a component fails during the flight (the interval T ), it will not come back online. This can be expressed in LTL as i∈I ((e i = 0) → (e i = 0)) .</p><p>(24)</p><p>3) CONTROLLER GUARANTEES</p><p>We consider the following system requirements as LTL guarantees for the controller.</p><p>Power Status of Buses: An AC bus can only be powered if there exists a live path (i.e., all contactors closed along a path) that connects the bus to a healthy AC generator or a healthy APU. Similarly, a DC bus can only be powered if there exists a live path that connects it to a healthy rectifier unit, which itself is connected to a powered AC bus. Let pi,B denote the set of all components (i.e., contactors and buses) along a path between bus B and environment variable e i for i ∈ I, excluding B and e i . Furthermore, let G ⊆ I and R ⊆ I represent the sets of generators and rectifier units. AC bus B is powered if there exists a live path between B and e i for i ∈ G, written as 2</p><formula xml:id="formula_46">   i∈G   (e i = 1) ∧ X ∈p i,B (x = 1)   → (b = 1)    .<label>(25)</label></formula><p>If there exists no live path between B and a generator e i for i ∈ G, then B will be unpowered</p><formula xml:id="formula_47">   ¬ i∈G   (e i = 1) ∧ X ∈p i,B (x = 1)   → (b = 0)    .<label>(26)</label></formula><p>A similar set of specifications for DC buses holds in which environment variables e i span i ∈ R.</p><p>Balanced Power Flow in Nominal Conditions: Under nominal conditions (i.e., when all generators and rectifier units are healthy), the power drawn from each generator by the buses connected to it should be less than the capacity of that generator. Let PB be a constant that corresponds to the maximum power required by the loads connected to the bus B and Pe i be a constant corresponding to the power generator i can nominally provide. Using the live path constructs, we define the power variables l i,B ∈ {0, PB } such that X ∈p i,B (x = 1) → (l i,B = PB ), and ¬ X ∈p i,B (x = 1) → (l i,B = 0). Then, the power flow requirement can be written as</p><formula xml:id="formula_48">   i∈I (e i = 1) → i∈G Pe i ≥ B∈B l i,B    ,</formula><p>where B represents the set of buses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>No Paralleling of AC Sources:</head><p>To avoid paralleling, we explicitly enumerate and disallow all bad configurations. In Fig. <ref type="figure">1</ref>, paralleling can occur if there exists a live path that connects two AC generators or APUs. Let pi,j represent the set of components along a path between generators e i , e j , for i, j ∈ G and i = j. We disallow configurations in which all 2 Per abuse of notation, we denote components by uppercase letters (e.g., C, B) and component statuses by lowercase letters (e.g., c, b). <ref type="bibr">VOLUME 2, 2014</ref> contactors C ∈ pi,j create a live path. These specifications are written as</p><formula xml:id="formula_49">i,j∈G    ¬ C∈p i,j (c = 1)    .<label>(27)</label></formula><p>Safety-Criticality of Buses: A safety-critical bus can be unpowered for no longer than T s time steps. This is implemented through the use of an additional clock variable x B for each bus B, where each ''tick'' of the clock represents δ time. If the bus is unpowered, then at the next time step clock x B increases by δ. If B is unpowered, then at the next time step clock x B resets to zero. Then, we limit the number of steps B can remain unpowered in order to ensure that x B never becomes larger than T s . Thus, for all safety-critical buses,</p><formula xml:id="formula_50">{(b = 0) → ( x B = x B + δ)},<label>(28a)</label></formula><formula xml:id="formula_51">{(b = 1) → ( x B = 0)},<label>(28b)</label></formula><formula xml:id="formula_52">(x B ≤ T s ). (<label>28c</label></formula><formula xml:id="formula_53">)</formula><p>Unhealthy Sources: A bus connected to an unhealthy source (generator or rectifier unit) will create a short-circuit failure, leading to excessive electrical currents, overheating, and possible fires. While generators have internal protections to avoid such failures, we require that appropriate contactors open when a generator or APU becomes unhealthy to isolate the unhealthy source and prevent its use. Let N (e i ) represent the set of contactors directly connected, or neighboring, environment variable e i for i ∈ I. We write the specifications to disconnect all unhealthy sources as</p><formula xml:id="formula_54">i∈I    (e i = 0) → C∈N (e i ) (c = 0)    .<label>(29)</label></formula><p>The above mentioned specifications can be put in assumeguarantee form as in equation ( <ref type="formula" target="#formula_10">4</ref>). Moreover, since they are within the GR(1) fragment of LTL, digital synthesis tools, such as the one implemented in JTLV <ref type="bibr" target="#b29">[30]</ref>, can be used to automatically synthesize the control protocol. For the examples discussed in this paper, we used the Temporal Logic Planning (TuLiP) Toolbox <ref type="bibr" target="#b30">[31]</ref>, a collection of Python-based code for automatic synthesis of embedded control software, which provides an interface to JTLV.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4) CAPTURING ACTUATION DELAYS</head><p>In the discussion above, we assumed ideal contactors that can be instantaneously controlled. It is possible to capture delays in contactor opening and closing times, as well as the communication delays between the controller and the contactors. To this effect, one can introduce a controlled variable C to represent the controller intent for contactor C and treat the contactor as an environment variable. The uncertain delay between the controller intent and contactor state can be handled by the use of an additional clock variable x C for each contactor C, where each ''tick'' of the clock represents δ time. If the contactor intent is open and the contactor state is closed, the contactor opens within [T o min , T o max ] units of time unless a close command is issued before it opens. If the contactor intent is closed and the contactor state is open, the contactor closes within [T c min , T c max ] units of time unless an open command is issued before it closes. Once the contactor intent is set, if the contactor state does not match the intent, at the next step clock x C will increase by δ. If contactor state and intent match, then at the next step clock x C resets to zero:</p><formula xml:id="formula_55">{( c = c) → ( x C = 0)}.</formula><p>When the control command is the same as the contactor state, the contactor state remains the same, i.e.,</p><formula xml:id="formula_56">{(c = c) → ( c = c)}.</formula><p>Finally, the assumption capturing the contactor closing behavior in relation to the controller input intent is given by</p><formula xml:id="formula_57">{(c = 1 ∧ c = 0 ∧ (x C &lt; T c min )) → ( c = 0 ∧ x C = x C + δ)}, {(c = 1 ∧ c = 0 ∧ (x C ≥ T c min )) → ( c = 1 ∨ x C = x C + δ)}, (x C ≤ T c max ).</formula><p>The contactor opening behavior can be formally captured in a similar manner. The formulas mentioned in this section enter to the control synthesis problem as new environment assumptions when delays are taken into account. It should also be noted that unhealthy sources can only be disconnected with a delay in this case, therefore formula (29) should be adjusted accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. DOMAIN-SPECIFIC LANGUAGE</head><p>The lack of familiarity with formal methods among system engineers provides a challenge to the actual adoption of reactive synthesis techniques. Therefore, we also propose an electric power system domain-specific language that enables automatic generation of the LTL specifications described in Sections VI-A.2 and VI-A.3 out of a set of pre-defined primitives. Our language can smoothly interface with pre-existing tools, such as visual programs for single-line diagrams, which engineers are familiar with, as well as with the topology design framework in Section V.</p><p>A graph data structure G = (V , E) as the one used in Section V can be generated from a visual representation of the topology, provided by the user, or directly imported as a result of the design procedure in Section V. The set of nodes V represents the set of components, consisting of generators, buses, and rectifier units; the set of edges E represents the set of contactors as well as solid wire links between components. The adjacency matrix A is a square matrix whose diagonal entries are zeros, and whose non-diagonal entries are ones or zeros depending on whether a connection (with or without contactors) exists between vertices. The component properties that are used to formulate the LTL specifications are directly referenced from the component attributes in the platform library, as described in Section III-A. Given the electric power system topology and the component attributes, the LTL specifications in Section VI-A can be converted from a set of primitives, a representative subset of which are provided in the following.</p><p>Environment assumptions: In the environment primitive, the first input is the system reliability level, followed by all subsets of components that are uncontrolled and can fail. As an example, when only generators and rectifier units are assumed to fail, this can be written as env(r S , G e , R e ), where G e ⊆ G and R e ⊆ R, G and R being the sets of all generators and rectifier units, respectively.</p><p>No-paralleling of AC sources: A ''non-paralleling'' primitive accepts as inputs any subset of G, and can be written as noparallel(G p ), where G p ⊆ G.</p><p>Essential (safety-critical) buses: Let the set of all buses be B. An ''essential bus'' primitive can input any subset of B such that the bus elements can be unpowered for no longer than the maximum allowable time as specified in the component library. This primitive is written as essbus(B e ), where B e ⊆ B.</p><p>Disconnect unhealthy sources: A ''disconnect'' primitive can take as input the union of subsets of G and R. This primitive is written as disconnect(G d , R d ), where G d ⊆ G and R d ⊆ R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. CO-DESIGN OF TOPOLOGY AND CONTROL</head><p>As mentioned in Section IV, topology and control protocol need to be coherently designed to satisfy the top-level requirements of an electric power system. In this section, we deal with the co-design problem for both system topology and control protocol to satisfy a system contract C S with an overall reliability requirement r S . We show that if system-level requirements are partitioned according to the contracts C T and C C , as defined, respectively, in Section V and Section VI-A, then the electric power system can be designed in a compositional way, i.e., the methodologies illustrated in in Section V and Section VI-A can be independently deployed, while guaranteeing that the assembled system is correct and satisfies C S .</p><p>In particular, Propositions 6.1 and 6.2 below discuss conditions for the controlled system to satisfy the system-level contract C S if the selected topology and control protocol satisfy their contracts C T and C C . First, in Proposition 6.1, we assume that actuation delays are ignored in control synthesis. We then remove this assumption in Proposition 6.2. Proposition 6.1: Assume contactor delays are ignored in control synthesis (i.e., T o min = T o max = T c min = T c max = 0, therefore no contactor intent variable is introduced). If the topology implements its contract C T with a reliability level r T , then a centralized control implementing its contract C C for this topology is always realizable when a reliability level r S ≥ r T is used while generating the environment assumptions as in <ref type="bibr" target="#b22">(23)</ref>. Moreover, the controlled system will satisfy the system-level requirements with a reliability level r S .</p><p>Proof: As shown in Figs. <ref type="figure">2</ref> and<ref type="figure">3</ref>, both the topology synthesis and control synthesis steps are based on a consistent set of models and share the same labelled topology template T . In fact, the configurations conforming to T are the assumptions for the topology contract C T , while the synthesized topology is used to generate the LTL formulas for the controller contract C C . We prove the realizability of the controller by discussing the system-level requirements listed in Section VI-A.3 and Section V as follows:</p><p>(a) Reliability Requirements. In both the topology and control design steps, we assume that when a component fails it will not come back online. Therefore, reliability requirements are treated as static requirements in failure condition. If the topology guarantees a reliability level r T , then there are enough components and paths from generators to critical loads such that any combination of component faults causing a system failure has a joint probability p &lt; r T . Let E T be set of all the environment configurations that correspond to these combinations of component faults, and let E T be its complement. Then any combination of faults associated with a configuration in E T does not cause any loss in system functionality because of the available redundancy. Since r S ≥ r T is used in C C , E S ⊆ E T will also hold, hence accommodating any combination of faults associated with an environment configuration in E S will also be feasible. Therefore, a centralized controller assuming a reliability level r S in C C will always realize this specification, thus guaranteeing an overall reliability level r = r S for the controlled system.</p><p>(b) Balanced Power Flow in Nominal Conditions. Power requirements are treated as static requirements in nominal condition. Power flow constraints in the topology optimization problem enforce that loads on each side of the topology graph are selectively connected to one or more generators on the same side, in such a way that the total power capability of the generators is equal or larger than the required power from the respective loads. It is, therefore, enough to use the available paths in the synthesized topology for a centralized controller to realize this specification.</p><p>(c) Unhealthy Sources. Connectivity constraints in the topology optimization problem enforce that any edge (interconnection) originating from a source node (generator or rectifier unit) is associated with a contactor. Therefore, it is always possible for a centralized controller to open such contactors to isolate unhealthy sources and realize this specification. Since contactors can be instantaneously operated, full isolation of unhealthy sources is guaranteed within one time step (δ time).</p><p>(d) No Paralleling of AC Sources. As discussed above, all AC sources can be isolated by opening the related contactors. Moreover, connectivity constraints prescribe that AC buses be also connected via contactors. This makes it possible for a centralized controller to always realize this specification by isolating buses connected to different AC sources as well as isolating unhealthy sources while inserting healthy ones.</p><p>(e) Safety-Criticality of Buses. Since all contactors are assumed as ideal and instantaneously controllable, it is always possible for a centralized controller to configure the topology and realize this specification whenever T s ≥ δ.</p><p>We then conclude that the conjunction of the LTL formulas used in C C to formalize requirements (b)-(e) under the assumptions in (a) can always be realized by a centralized controller if r T ≤ r S holds.</p><p>Based on Proposition 6.1, for the controlled system to satisfy a contract C S with a reliability level r S , it is enough to select a topology that implements its contract C T with a reliability level r T ≤ r S , and then synthesize a centralized controller for the selected topology by using a reliability level r S to generate the environment assumptions. When contactor delays are not ignored in control synthesis, a similar proposition holds if an additional condition is assumed on the maximum bus unpowered time T s allowed in <ref type="bibr" target="#b27">(28)</ref>, as discussed below.</p><p>Proposition 6.2: Assume delays in the contactors are taken into account in control synthesis (i.e., T o min &gt; 0 and T c min &gt; 0). If the topology implements its contract C T with a reliability level r T , then there exists a large enough time T * such that a centralized control implementing its contract C C for this topology is realizable when a reliability level r S ≥ r T in equation ( <ref type="formula" target="#formula_44">23</ref>) and a bus unpowered time T s ≥ T * in equation ( <ref type="formula" target="#formula_50">28</ref>) are used while generating C C . Moreover, the controlled system will satisfy the system-level requirements with a reliability level r S .</p><p>Proof: As in Proposition 6.1, both the topology and control synthesis steps are based on a consistent set of models and share the same template T . Moreover, we can prove the realizability of the controller by discussing the requirements in Section VI-A.3 and Section V at a time. In particular, the static specifications in (a) and (b) will be always realizable by the same arguments used in Proposition 6.1. To show that the dynamic requirements in (c), (d) and (e) will also be realizable when actuation delays are taken into account, we proceed as follows:</p><p>(c)-(d) Unhealthy Source Isolation and AC Sources Paralleling. By the same arguments used in Proposition 6.1 (c), all sources (including AC sources) can be isolated by opening the related contactors. Moreover, the topology connectivity constraints prescribe that AC buses should also be connected via contactors. Even if contactors can only be opened or closed with a delay, it is still possible for a centralized controller to realize this specification by disconnecting two AC buses at least T o max time before connecting them to different AC sources or by isolating unhealthy sources at least T o max time before connecting the healthy ones.</p><p>(e) Safety-Criticality of Buses. To guarantee that safetycritical buses are unpowered for no longer than the desired time T s , the controller needs to reconfigure the topology by opening and closing sets of contactors to deactivate existing components and paths and activate new ones. Because of the actuation delay, topology reconfigurations cannot occur instantaneously; some sets of contactors will need to be actuated in sequence to guarantee isolation of unhealthy sources and prevent paralleling of AC sources, as required in (c) and (d). Since there is a finite number of topology configurations, there will also be a finite number of possible reconfigurations R. Consider the step i from an initial configuration A i to a final configuration Z i . Let n i o and n i c be the minimum number of contactor sets that must be, respectively, opened and closed in sequence in order to provide power to a critical bus during reconfiguration i. Then, the minimum (worst-case) time during which at least one critical bus stays unpowered will be</p><formula xml:id="formula_58">T i = n i o T o max δ δ + n i c T c max δ δ.</formula><p>Let T * = max i∈R T i ; then, T * is the minimum bus unpowered time that can always be guaranteed across all possible topology reconfigurations. Therefore, a centralized controller can always be realizable when T s ≥ T * is chosen in C C .</p><p>As in Proposition 6.1, by combining the arguments above with the ones used in (a) and (b), we can conclude that the conjunction of the LTL formulas used in C C to formalize requirements (b)-(e) under the assumptions in (a) can always be realized by a centralized controller if r T ≤ r S and T s ≥ T * hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. SIMULATION-BASED DESIGN SPACE EXPLORATION</head><p>As shown in Section VI-C, the design steps in Section V and Section VI-A allow synthesizing electric power system architectures and control protocols that jointly satisfy the toplevel system specifications, represented by contracts C T and C C,LTL . To assess the satisfaction of real-time performance constraints, we monitor STL formulas from the controller contracts C C,STL and C C,LTL on voltage and current waveforms over time, as discussed in Section III-F and Section IV. As an example, we investigate here the maximum reaction time allowed to the controller. For this purpose, we assume a synchronous implementation of the controller, running at a fixed period T r . In our hybrid model, the BPCU is connected in closed loop with the power system plant, while failure events can be injected by setting the input signal u(t). Moreover, we assume that all contactors respond with a fixed delay T d to the open/close commands from the BPCU. We then consider the requirement that a DC essential bus must never be unpowered for more than t max under any possible failure scenario. In a continuous setting, such a requirement is translated by stating that the DC bus voltage V DC should never deviate from the desired value V d by more than a margin for more than t max . The predicate specifying that the current value of the voltage stays in the desired range is:</p><formula xml:id="formula_59">|V DC (t) -V d | &lt; .</formula><p>Then, the STL formula expressing this to be false for at least t max is:</p><formula xml:id="formula_60">χ = [0,t max ] ¬(|V DC (t) -V d | &lt; ). (<label>30</label></formula><formula xml:id="formula_61">)</formula><p>Since we need to enforce that V DC is never out of range only after the initial start-up transient time τ i , we require</p><formula xml:id="formula_62">φ(τ i ) = ¬(♦ [τ i ,∞) χ)<label>(31)</label></formula><p>to be true.</p><p>To compute the maximum amount of time elapsed while the DC bus voltage is out of range, i.e. for how long at most the voltage requirement on the DC bus is violated, we turn (30) into a PSTL formula, by introducing the timing parameter τ e , after which an out-of-range voltage event is detected, as follows:</p><formula xml:id="formula_63">ψ(τ e ) = [0,τ e ] ¬(|V DC (t) -V d | &lt; ).<label>(32)</label></formula><p>The initial start-up transient time τ i is estimated from simulation as a function of T r and T d . Then, the maximum violation period τ * e (T r , T d ) can be computed as the</p><formula xml:id="formula_64">sup{τ e ≥ 0 | φ (τ i (T r , T d ), τ e ) = False},<label>(33)</label></formula><p>where</p><formula xml:id="formula_65">φ(τ i , τ e ) = ¬(♦ [τ i ,∞) ψ(τ e )).<label>(34)</label></formula><p>The formula in <ref type="bibr" target="#b33">(34)</ref> allows exploring the T r -versus-T d design space and finding the maximum allowed controller reaction time T * r for a fixed T * d , in such a way that the essential DC bus is never out of range for more than t max . To do so, we cast an optimization problem following the formulation in ( <ref type="formula" target="#formula_27">15</ref>)</p><formula xml:id="formula_66">min T r &gt;0 1/T r (35) s.t.        F(u, V DC , T r ) = 0 V DC | φ τ i (T r , T * d ), τ e ∀τ e ≥ t max ∀u s.t. u | ϕ e where C = 1/T r is the cost function, κ = T r is the design parameter, ϕ s (τ ) = τ e ≥t max φ τ i (T r , T * d )</formula><p>, τ e is the conjunction of PSTL formulas that must be satisfied, each parameterized by τ = T r , and ϕ e refines the environment assumption formula ϕ e in Section VI-A. In this case, the system behavior s is the trace s = (u, V DC ), where V DC is the output signal to be observed during simulation, and u spans the set of all admissible failure injection traces that are consistent with the environment assumptions in Section VI-A.2.</p><p>The formulation in <ref type="bibr" target="#b34">(35)</ref> includes an infinite set of formulas that must be satisfied for all admissible failure traces and values of τ e ≥ t max . However, such formulation can be further simplified, by observing that <ref type="bibr" target="#b34">(35)</ref> </p><formula xml:id="formula_67">is equivalent to max T r &gt;0 T r (36) s.t.    F(u, V DC , T r ) = 0 τ * e (T r , T * d ) ≤ t max ∀u s.t. u | ϕ e where τ *</formula><p>e is defined in <ref type="bibr" target="#b32">(33)</ref>. Moreover, as shown in Section VII-C, it is enough to compute V DC (t) and τ * e under the worst case failure scenario, rather than for all possible failure traces, whenever the worst case assumptions on u(t) can be determined a priori. Problem <ref type="bibr" target="#b35">(36)</ref> can then be solved by first solving the optimization problem in <ref type="bibr" target="#b32">(33)</ref> to compute τ * e as a function of T r and T * d in the worst case input scenario, and then by computing the value T * r of the controller reaction time that makes τ * e equal to t max . For the example discussed in this paper, we used the Breach toolbox <ref type="bibr" target="#b37">[38]</ref> to facilitate postprocessing of simulation traces and verify the satisfaction of the STL formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. DESIGN EXAMPLE AND RESULTS</head><p>We illustrate our methodology on the proof-of-concept design of the primary power distribution of an electric power system, involving the configuration of contactors to deliver power to high-voltage AC and DC buses and loads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. TOPOLOGY SYNTHESIS</head><p>The topology synthesis algorithm has been implemented in Matlab and leverages Cplex <ref type="bibr" target="#b38">[39]</ref> to solve the MILP at each iteration. We present the result obtained for an electric power system topology template T consisting of two generators, two AC buses, two rectifiers, two DC buses and two loads on each side. Tables <ref type="table" target="#tab_4">3</ref> and<ref type="table" target="#tab_5">4</ref> report the load power requirements and the generator power ratings in our example; Table <ref type="table" target="#tab_6">5</ref> shows the component costs, while the failure probabilities are reported in Table <ref type="table">6</ref>. Figs. <ref type="figure" target="#fig_2">4</ref> and<ref type="figure">5</ref> show the topologies obtained after running the synthesis algorithm when a set of strategies are sequentially implemented after every MILP iteration to increase reliability and satisfy the specified level r * = 10 -9 . By solving the MILP including only connectivity and power flow constraints, we obtain the topology in Fig. <ref type="figure" target="#fig_2">4</ref>, the simplest VOLUME 2, 2014 between a bus and a generator. In Fig. <ref type="figure">5</ref>(b), bus LB2 is powered if either generator LG1 or APU 1 is powered, and the contactor between generator and bus is closed:</p><p>((LG1 = 1) ∧ (C LG1,LB2 = 1) → (LB2 = 1)), ((APU 1 = 1) ∧ (C APU 1,LB2 = 1) → (LB2 = 1)).</p><p>If neither of these two cases is true, then LB2 will be unpowered. These specifications are written as (¬(((LG1 = 1) ∧ (C LG1,LB2 = 1) ∨((APU 1 = 1) ∧ (C APU 1,LB2 = 1))) → (LB2 = 0)). Similar specifications may be written for buses RB2, LD2, and RD1.</p><p>Safety-Criticality of Buses: We consider all buses to be safety-critical; at the abstraction level of LTL, this is equivalent to require that at no time can any bus be unpowered ((LB2 = 1) ∧ (RB2 = 1) ∧ (LD2 = 1) ∧ (RD1 = 1)).</p><p>The resulting controller has 32 states with a computation time of 1.6 s on a 2.2-GHz Intel Core Processor with 4-GB memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) DISTRIBUTED SYNTHESIS</head><p>For the topology in Fig. <ref type="figure">5</ref>(b), the distributed control synthesis problem can be solved by splitting the topology into two subsystems S 1 and S 2 . The sets E S 1 , S S 1 , and E S 2 , S S 2 contain all environment and system variables for subsystems S 1 and S 2 , respectively. E S 1 is composed of generators LG1, APU 1 and RG1. S S 1 contains AC buses LB2, RB2, and contactors C LG1,LB2 , C APU 1,LB2 , C RG1,RB2 , C LB2,RB2 . E S 2 is composed of rectifiers LR2, RR2 and AC buses LB2, RB2, while S S 2 contains DC buses LD2, RD1 and contactors C LR2,LD2 , C RR2,RD1 , C LD2,RD1 . We assume the link between AC buses and rectifier units is a solid wire.</p><p>The environment assumption ϕ e S 1 for subsystem S 1 enforces that at least one generator will always remain healthy. Environment assumption ϕ e S 2 enforces that at least one rectifier unit will always remain healthy. In addition, it also assumes that both AC buses will always be powered. This is an additional guarantee S 1 must provide to S 2 for the distributed synthesis problem to become realizable. All other specifications remain the same as the centralized control problem.</p><p>The synthesized controllers for S 1 and S 2 contains 4 and 8 states, respectively. Each controller has a computation time of approximately 0.5 s on a 2.2-GHz Intel Core Processor with 4-GB memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. DESIGN SPACE EXPLORATION FOR REAL-TIME PERFORMANCE</head><p>Continuous-time models of the plant are implemented in Simulink, by exploiting the SimPowerSystems extension. As an example, the continuous-time model of a generator consists of a mechanical engine (turbine), a three-phase synchronous machine, in addition to the generator control unit, driving the field voltage of the generator. In addition to timing properties, our power network model allows measuring current and voltage levels at the different circuit loads. It can be discretized to speed up simulations and can seamlessly interface also with Matlab functions or StateFlow models implementing the controller.</p><p>In what follows, we focus on the centralized controller for topology 3 in Fig. <ref type="figure">5</ref>(b), and provide results for the design exploration problem in Section VI-D. In particular, we are interested in finding the maximum controller reaction time T * r as a function of T d , so that the essential DC bus LD2 is never out of range for more than t max = 70 ms. Based on the environment assumptions discussed in Section VII-B, the worst case failure scenario for the left DC bus LD2 occurs when cascaded failures in two generators (e.g. LG1 and APU 1) and one rectifier (LR2) correlate so as to maximize the time the bus voltage is out of the specified range. The controller reacts to a generator fault by routing power from another generator and connects the two DC buses LD2 and RD1 when one of the rectifiers fails. Therefore, the worst case failure scenario occurs when the rectifier fault happens at the end, and any fault after the first one happens right before LD2 fully recovers from the previous fault, while trying to reach the desired voltage level.    The T r versus T d design space is explored in Figs. 7 and 8 by following the optimization procedure in Section VI-D. We sampled the parameter space in approximately 4 hours to obtain a 15 × 15 point grid. The first plot represents the maximum amount of elapsed time τ * e , while the DC bus voltage is out of range, i.e. for how long the requirement on the DC bus is violated, as computed in equation <ref type="bibr" target="#b32">(33)</ref>. Such a violation period is then compared with the ''hard'' threshold t max = 70 ms in Fig. <ref type="figure" target="#fig_6">8</ref>, thus providing the designer with the ''safe'' region (marked in blue in Fig. <ref type="figure" target="#fig_6">8</ref>) for the controller reaction time as a function of the contactor delay. As an example, for a specific value of T d = 20 ms the maximum BPCU reaction time T * r allowed for safe operation is 6.5 ms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>We presented a rigorous platform-based methodology for the design of an aircraft electric power system. Our flow consists of three main phases: topology synthesis, control synthesis, and simulation-based design space exploration and verification. To express system requirements, we adopt different formalisms supported by specialized synthesis and analysis frameworks. To generate the system topology, we formulate a mixed integer-linear program that minimizes the overall cost while satisfying a set of connectivity, power flow and reliability requirements, expressed in terms of linear arithmetic constraints on Boolean variables and probabilistic constraints. To synthesize a controller for a given topology, we leverage results from reactive synthesis of control logic from linear temporal logic specifications. We then refine these LTL specifications into signal-temporal logic constructs to assess the real-time system performance and explore the design space at a lower abstraction level, based on high fidelity behavioral models. Our compositional approach uses contracts to guarantee independent implementation of system topology and control, since both topology synthesis and control synthesis rely on a consistent set of models and design constraints.</p><p>We plan to extend our control synthesis algorithms to support richer formal languages (e.g., timed logic, branching logic), continuous-time specifications and continuous dynamics (e.g., transients, network and communication delays). Moreover, we plan to investigate techniques for automatic generation of local contracts for the synthesis of distributed and hierarchical control architectures.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>2013 IEEE. Translations and content mining are permitted for academic research only.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FIGURE 4 .</head><label>4</label><figDesc>FIGURE 4. Directed graph representation of an electric power system architecture. Unconnected nodes represent virtual components.</figDesc><graphic coords="14,27.40,61.81,256.16,259.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6</head><label>6</label><figDesc>shows the simulated voltage V LD2 of bus LD2 as a function of time, in the worst case scenario, for T r = 20 ms and T d = 20 ms, both defined as in Section VI-D. The waveforms at the top and bottom of the figure are the voltage signals at the LB2 (AC) and LD2 (DC) buses, respectively. The signal in the middle represents the health status of LR2.Both the AC and DC voltages decay to zero because of the generators' faults. When a fault is also injected into LR2, an additional drop in the DC voltage is observed. The red signal at the bottom of the figure is interpreted as a Boolean signal, which is high (one) when χ in equation (30) holds (i.e. the requirement is violated) and low (zero) otherwise. To</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FIGURE 6 .</head><label>6</label><figDesc>FIGURE 6. Real-time requirement violation at the DC bus LD2 due to two generator faults followed by a rectifier fault.</figDesc><graphic coords="21,278.99,538.04,280.36,176.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>FIGURE 7 .</head><label>7</label><figDesc>FIGURE 7. Maximum duration of the violation of the DC bus voltage requirement.</figDesc><graphic coords="22,37.53,56.19,252.40,172.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FIGURE 8 .</head><label>8</label><figDesc>FIGURE 8. BPCU reaction times and contactor delays in the blue region satisfy the DC bus requirement.</figDesc><graphic coords="22,30.74,328.85,265.88,204.19" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE 1 .</head><label>1</label><figDesc>Notation.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>We say that C refines C , written C C (with C and C both in saturated form), if A ⊇ A and G ⊆ G . Refinement amounts to relaxing assumptions and reinforcing guarantees, therefore strengthening the contract. Clearly, if M | C and C C , then M | C . On the other hand, if E | E C , then E | E C. With the given ordering, we can compute the conjunction of contracts by taking the greatest lower bound of C 1 and C 2 . For contracts in saturated form, we have</figDesc><table><row><cell>Contract conjunction can be computed</cell></row><row><cell>by defining a preorder on contracts, which formalizes a notion</cell></row><row><cell>of refinement.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>→ ϕ s , and two local specifications ϕ 1 : ϕ e 1 → ϕ s 1 and ϕ 2 : ϕ e 2 → ϕ s 2 , where ϕ e , ϕ e 1 , ϕ e 2 , ϕ s , ϕ s 1 , and ϕ s</figDesc><table /><note><p><p>where for all (o, i) ∈ I, o = i,</p>• a global specification ϕ : ϕ e 2 are LTL formulas containing variables only from their respective sets of environment variables E, E 1 , E 2 and system variables S, S 1 , S 2 ;</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE 2 .</head><label>2</label><figDesc>Connectivity sub-matrices.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE 3 .</head><label>3</label><figDesc>Load requirements.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE 4 .</head><label>4</label><figDesc>Generator power ratings.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>TABLE 5 .</head><label>5</label><figDesc>Component costs.</figDesc><table><row><cell>6. Component failure probabilities.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>  VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>  VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>  VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_3"><p>  VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_4"><p>  VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_5"><p>  VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_7"><p>  VOLUME 2, 2014   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_8"><p>i and j denote the name of the components contactor C i,j connects. 20 VOLUME 2, 2014</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_9"><p>  VOLUME 2, 2014   </p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ACKNOWLEDGMENT The authors wish to acknowledge Rich Poisson and Eelco Scholte from United Technologies Corporation (UTC), Mohammad Mozumdar, Antonio Iannopollo and Ufuk Topcu for helpful discussions. This work was supported in part by IBM and UTC via the iCyPhy consortium and by the TerraSwarm Research Center, one of six centers supported by the STARnet phase of the Focus Center Research Program (FCRP) a Semiconductor Research Corporation program sponsored by MARCO and DARPA.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported in part by IBM and United Technologies Corporation (UTC) via the iCyPhy consortium, and in part by the TerraSwarm Research Center, one of six centers supported by the STARnet phase of the Focus Center Research Program, a Semiconductor Research Corporation Program sponsored by MARCO and DARPA.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE 7.</head><p>Load and system failure probabilities for the topologies in Fig. <ref type="figure">4</ref> and<ref type="figure">5</ref>.</p><p>possible architecture, which only provides a single path from a load to a generator (or APU) on each side. Such a topology presents the highest load and system failure probabilities, as shown in Table <ref type="table">7</ref>.</p><p>In Fig. <ref type="figure">5</ref>(a) and (b) horizontal connections are added between the DC buses and AC buses of the left and right hand sides of the system. Because increasing the number of components is expensive, the algorithm first tries to increase reliability by adding connections among existing components at the cost of additional contactors. Additional components (e.g. buses and rectifiers) are finally used in Fig. <ref type="figure">5(c</ref>) to achieve the desired specification. In Table <ref type="table">7</ref>, we report the achieved reliability level (failure probability) at load LL1 and the overall achieved system reliability level r T , as computed for the topologies in Figs. <ref type="figure">4</ref> and<ref type="figure">5</ref>. The total computation time to generate the topologies in Figs. <ref type="figure">4</ref> and<ref type="figure">5</ref> was 19.7 s on an Intel Core i7 2.8-GHz Processor with 6-GB memory. In a typical run, the number of necessary paths to achieve r * is estimated after the first MILP step and convergence to the final topology occurs in no more than two iterations, which reduces the overall computation time to approximately 10 s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. CONTROL SYNTHESIS</head><p>To validate our approach, for each of the four topologies in Section VII-A, we formalize a set of environment assumptions and system specifications to synthesize centralized and distributed control protocols for an overall reliability level r S = r T , as discussed in Section VI-C. For the purpose of brevity, we present the variables and formal specifications, written in LTL, for the topology depicted in Fig. <ref type="figure">5</ref>(b) only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) CENTRALIZED SYNTHESIS</head><p>Environment Variables: Generators LG1, LG2, APU 1 and rectifier units LR2 and RR2 are uncontrolled variables that can switch between healthy (1) and unhealthy (0). Controlled Variables: Contactors C i,j 3 (depicted only as wires in Fig. <ref type="figure">5</ref>) are variables that are set to open (0) or closed <ref type="bibr" target="#b0">(1)</ref>.</p><p>Dependent Variables: Buses are either powered (1) or unpowered (0) depending on the status of environment and controlled variables.</p><p>Environment Assumption: We allow environment configurations which are mapped back from the function h in Section VI-A.2 to an overall system reliability level r S . Topology 3 from Fig. <ref type="figure">5</ref>(b) has a total of 32 environment configurations. For a reliability level r S = 4 × 10 -8 , h(r S ) maps to a set of 21 allowable configurations. The specification can be written as a conjunction of all configurations. More compactly, the environment assumption disallows configurations in which either both rectifiers fail or all generators fail. Thus, we can equivalently write the environment assumption for Topology 3 as:</p><p>No Paralleling of AC Sources: No combination of contactors can be closed so that a path exists between generators:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Power Status of Buses:</head><p>A bus can only be powered if there exists a path (in which a contactor is closed)  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Aircraft Systems: Mechanical, Electrical and Avionics Subsystems Integration</title>
		<author>
			<persName><forename type="first">I</forename><surname>Moir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seabridge</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Wiley</publisher>
			<biblScope unit="volume">3</biblScope>
			<pubPlace>Chichester, U.K.</pubPlace>
		</imprint>
	</monogr>
	<note>rd ed</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">T</forename><surname>Jomier</surname></persName>
		</author>
		<idno>D0.02.3</idno>
	</analytic>
	<monogr>
		<title level="j">Final MOET technical report</title>
		<imprint>
			<date type="published" when="2009-12">Dec. 2009</date>
			<pubPlace>Toulouse, France</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
	<note>AIRBUS OPERATIONS S.A.S.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Aviation cyber-physical systems: Foundations for future aircraft and air transport</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sampigethaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Poovendran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1834" to="1855" />
			<date type="published" when="2013-08">Aug. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Quo vadis, SLD? Reasoning about the trends and challenges of system level design</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="467" to="506" />
			<date type="published" when="2007-03">Mar. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Taming Dr. Frankenstein: Contract-based design for cyber-physical systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Passerone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. Decision Control</title>
		<meeting>Conf. Decision Control</meeting>
		<imprint>
			<date type="published" when="2011-12">Dec. 2011</date>
			<biblScope unit="page" from="1" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Complete aircraft system simulation for aircraft design-Paradigms for modelling of complex systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Krus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nyman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICAS, 2000</title>
		<meeting>ICAS, 2000</meeting>
		<imprint>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Virtual iron bird-A multidisciplinary modelling and simulation platform for new aircraft system architectures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pfeiffer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Schallert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. German Aerosp. Conf</title>
		<meeting>German Aerosp. Conf</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Modelica Language</title>
		<ptr target="http://www.modelica.org" />
		<imprint>
			<date type="published" when="2009">2013. Oct. 9</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Simulation-based design of aircraft electrical power systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kurtoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bunus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Kleer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Modelica Conf</title>
		<meeting>Int. Modelica Conf</meeting>
		<imprint>
			<date type="published" when="2011-03">Mar. 2011</date>
			<biblScope unit="page" from="92" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">META II: Formal Co-verification of correctness of largescale cyber-physical systems during design</title>
		<author>
			<persName><forename type="first">S</forename><surname>Uckun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tech. Rep</title>
		<imprint>
			<date type="published" when="2011-09">Sep. 2011</date>
			<pubPlace>Palo Alto Research Center (PARC), Palo Alto, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">OMG Systems Modeling Language</title>
		<ptr target="http://www.sysml.org/" />
		<imprint>
			<date type="published" when="2009">2013. Oct. 9</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">META II: Lingua franca design and integration language</title>
		<author>
			<persName><forename type="first">M</forename><surname>Masin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ferrari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mangeruca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Broodney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Research</title>
		<imprint>
			<date type="published" when="2011-08">Aug. 2011</date>
			<pubPlace>Haifa, Isreal</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Haifa Research Laboratory</orgName>
		</respStmt>
	</monogr>
	<note>Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">&apos;Correct-by-construction design of aircraft electric power systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Becz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Reeve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th AIAA Aviation Technol., Integr., Operations Conf</title>
		<meeting>10th AIAA Aviation Technol., Integr., Operations Conf</meeting>
		<imprint>
			<date type="published" when="2010-09">Sep. 2010</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Formal synthesis of embedded control software for vehicle management systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wongpiromsarn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. AIAA Infotech. Aerosp. Conf</title>
		<imprint>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2011-03">Mar. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Distributed power allocation for vehicle management systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ozay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 50th CDC-ECC</title>
		<meeting>50th CDC-ECC</meeting>
		<imprint>
			<date type="published" when="2011-12">Dec. 2011</date>
			<biblScope unit="page" from="4841" to="4848" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A case study on reactive protocols for aircraft electric power distribution,&apos;</title>
		<author>
			<persName><forename type="first">H</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">&apos; in Proc. Int. CDC</title>
		<imprint>
			<biblScope unit="page" from="1" to="8" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The Temporal Logic of Reactive and Concurrent Systems: Specification</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">1</biblScope>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Temporal and modal logic</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Handbook Theoretical Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="995" to="1072" />
			<date type="published" when="1990-03">Mar. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Electrical starting, generation, conversion and distribution system architecture for a more electric vehicle</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Michalko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">U.S. Patent</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="439" to="634" />
			<date type="published" when="2008-10-21">Oct. 21, 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Contracts for system design</title>
		<author>
			<persName><forename type="first">A</forename><surname>Benveniste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Caillaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nickovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Passerone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-B</forename><surname>Raclet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Reinkemeier</surname></persName>
		</author>
		<idno>RR-8147</idno>
	</analytic>
	<monogr>
		<title level="j">INRIA</title>
		<imprint>
			<date type="published" when="2012-11">Nov. 2012</date>
			<pubPlace>Rennes, France</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Methodology for the design of analog integrated interfaces using contracts</title>
		<author>
			<persName><forename type="first">P</forename><surname>Nuzzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Puggelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sensors J</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="3329" to="3345" />
			<date type="published" when="2012-12">Dec. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The temporal logic of programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th Annu</title>
		<meeting>18th Annu</meeting>
		<imprint>
			<date type="published" when="1977-11">Nov. 1977</date>
			<biblScope unit="page" from="46" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Principles of Model Checking</title>
		<author>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Katoen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A really temporal logic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Found. Comput. Sci</title>
		<meeting>Symp. Found. Comput. Sci</meeting>
		<imprint>
			<date type="published" when="1989-07">Jul. 1989</date>
			<biblScope unit="page" from="164" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Specifying real-time properties with metric temporal logic</title>
		<author>
			<persName><forename type="first">R</forename><surname>Koymans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Real-Time Syst</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="255" to="299" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Monitoring temporal properties of continuous signals,&apos;&apos; in Formal Modelling and Analysis of Timed Systems</title>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nickovic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="152" to="166" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Parametric identification of temporal properties,&apos;&apos; in Runtime Verification</title>
		<author>
			<persName><forename type="first">E</forename><surname>Asarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Donzé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nickovic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="147" to="160" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Distributed reactive systems are hard to synthesize</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 31st Annu</title>
		<meeting>31st Annu</meeting>
		<imprint>
			<date type="published" when="1990-10">Oct. 1990</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="746" to="757" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Synthesis of reactive (1) designs,&apos;&apos; in Verification, Model Checking, and Abstract Interpretation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="364" to="380" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">JTLV: A framework for developing verification algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Saar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Zuck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Touili</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Cook</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Jackson</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="171" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">TuLiP: A software toolbox for receding horizon temporal logic planning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wongpiromsarn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ozay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. HSCC</title>
		<meeting>Int. Conf. HSCC</meeting>
		<imprint>
			<date type="published" when="2011-04">Apr. 2011</date>
			<biblScope unit="page" from="313" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Robust satisfaction of temporal logic over realvalued signals,&apos;&apos; in Formal Modeling and Analysis of Timed Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Donzé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="92" to="106" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Uppaal-Tiga, A Synthesis Tool For Timed Games</title>
		<ptr target="http://people.cs.aau.dk/~adavid/tiga/" />
		<imprint>
			<date type="published" when="2009">2013. Oct. 9</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Satisfiability modulo theories</title>
		<author>
			<persName><forename type="first">C</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tinelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Handbook of Satisfiability</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Biere</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Van Maaren</surname></persName>
		</editor>
		<editor>
			<persName><surname>Walsh</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2009">2009</date>
			<publisher>Ios Press</publisher>
			<pubPlace>Amsterdam, The Netherlands</pubPlace>
		</imprint>
	</monogr>
	<note>ch. 8</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Synthesizing cyber-physical architectural models with real-time constraints</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Manolios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Papavasileiou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd Int. Conf. CAV</title>
		<meeting>23rd Int. Conf. CAV</meeting>
		<imprint>
			<date type="published" when="2011-07">Jul. 2011</date>
			<biblScope unit="page" from="441" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Lyu</surname></persName>
		</author>
		<title level="m">Handbook of Software Reliability Engineering</title>
		<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A new component concept for fault trees</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liggesmeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Mäckel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th Austral</title>
		<meeting>8th Austral</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="37" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Breach, a toolbox for verification and parameter synthesis of hybrid systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Donzé</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd Int. Conf. CAV</title>
		<meeting>22nd Int. Conf. CAV</meeting>
		<imprint>
			<date type="published" when="2010-07">Jul. 2010</date>
			<biblScope unit="page" from="167" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">IBM ILOG CPLEX Optimizer</title>
		<ptr target="http://www.ibm.com/software/integration/optimization/cplex-optimizer/" />
		<imprint>
			<date type="published" when="2012-02">2012. Feb.</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
