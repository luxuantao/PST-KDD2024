<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Matthew</forename><forename type="middle">C</forename><surname>Gombolay</surname></persName>
							<email>gombolay@csail.mit.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Wilcox</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Georgia Institute of Technology</orgName>
								<address>
									<postCode>30332</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">7064E9BEF48DBE38720ECBF75BF3559B</idno>
					<idno type="DOI">10.1109/TRO.2018.2795034</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast Scheduling of Robot Teams Performing Tasks</head><p>With Temporospatial Constraints Matthew C. Gombolay, Ronald J. Wilcox, and Julie A. Shah</p><p>Abstract-The application of robotics to traditionally manual manufacturing processes requires careful coordination between human and robotic agents in order to support safe and efficient coordinated work. Tasks must be allocated to agents and sequenced according to temporal and spatial constraints. Also, systems must be capable of responding on-the-fly to disturbances and people working in close physical proximity to robots. In this paper, we present a centralized algorithm, named "Tercio," that handles tightly intercoupled temporal and spatial constraints. Our key innovation is a fast, satisficing multi-agent task sequencer inspired by real-time processor scheduling techniques and adapted to leverage a hierarchical problem structure. We use this sequencer in conjunction with a mixed-integer linear program solver and empirically demonstrate the ability to generate near-optimal schedules for realworld problems an order of magnitude larger than those reported in prior art. Finally, we demonstrate the use of our algorithm in a multirobot hardware testbed.</p><p>Index Terms-Human-robot teaming, scheduling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>R OBOTIC systems are increasingly entering into domains previously occupied exclusively by humans. In the manufacturing field, for example, there is a strong economic motivation to enable human and robotic agents to cooperatively perform traditionally manual work. This integration requires a choreography of human and robotic work that meets upper and lower bound temporal deadlines for task completion (e.g., the assigned work must be completed within a single shift) and spatial restrictions on agent proximity (e.g., robots must maintain at least 4 m of separation from other agents) in order to support safe and efficient human-robot cooperation. Multi-agent coordination problems with temporospatial constraints can be readily formulated as a mixed-integer linear program (MILP) <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b48">[49]</ref>; however, the problem of optimally scheduling n ≥ 3 tasks (each with a sequence of n i subtasks) on a set of m machines is NP-hard <ref type="bibr" target="#b72">[73]</ref> and is computationally intractable for problems of interest to large-scale factory operations.</p><p>Various decentralized or distributed approaches have achieved fast computation and favorable scalability characteristics <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b67">[68]</ref>, <ref type="bibr" target="#b75">[76]</ref>. Rapid computation is desirable because it enables the system to respond on-the-fly to schedule disturbances, such as an inaccurately performed job, a machine breakdown, or changing temporal constraints <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b69">[70]</ref>. Some approaches boost computational performance by decomposing plan constraints and contributions to the objective function among agents <ref type="bibr" target="#b13">[14]</ref>. However, these methods break down when agents' schedules become tightly intercoupled, such as scenarios wherein multiple agents are maneuvering in close physical proximity to one another. While distributed coordination approaches are necessary for field operations in which environment and geography affect communication among agents, factory operations allow sufficient connectivity and bandwidth for either centralized or distributed approaches to task assignment and scheduling.</p><p>In this paper, we present Tercio, <ref type="foot" target="#foot_0">1</ref> a centralized task assignment and scheduling algorithm that scales to multi-agent, factory-size problems and supports on-the-fly scheduling in the presence of temporal and spatial proximity constraints. We empirically demonstrate that this capability enables human and robotic agents to perform manufacturing tasks effectively and in close proximity to one another.</p><p>Tercio takes as input a set of tasks composed of precedencerelated subtasks; a set of interval temporal constraints relating the start and finish times of subtasks; two-dimensional coordinates specifying the spatial locations where subtasks are performed; physical constraints restricting agent proximity; a set of agent capabilities specifying the tasks and subtasks each agent may perform and the minimum, maximum, and expected time for each agent to complete each task; and an objective function to optimize. Tercio provides a solution consisting of the assignment of agents (i.e., humans or robots) to tasks and a schedule for each agent's jobs (i.e., start and finish times for each job) such that all temporal and spatial proximity constraints are satisfied and the objective function is empirically within 10% of optimal the majority of the time (see Section X).</p><p>Tercio is made efficient through a fast, satisficing multi-agent task sequencer that is inspired by real-time processor scheduling techniques but adapted to leverage a hierarchical problem structure. Our task sequencer computes, in polynomial time, a multi-agent schedule satisfying upper and lower bound temporal deadlines, as well as spatial restrictions of agent proximity. Although the sequencing algorithm is satisficing and incomplete, we empirically show that it produces task schedules within 10% of optimal. We also demonstrate that it produces solutions for nearly all problem instances solvable by a complete solution technique. We use this fast task sequencer in conjunction with an MILP solver and indicate that Tercio is able to generate task assignments and schedules for up to 10 agents and 1000 subtasks in approximately one minute, on average. In this regard, Tercio scales better than representative state-of-the-art benchmarks in heuristic (i.e., <ref type="bibr" target="#b57">[58]</ref>), metaheuristic (i.e., <ref type="bibr" target="#b87">[88]</ref>), and exact (i.e., <ref type="bibr" target="#b34">[35]</ref>) approaches. Tercio also returns flexible time windows for execution <ref type="bibr" target="#b83">[84]</ref>, enabling agents to adapt to small disturbances online without the need for a full recomputation of the schedule.</p><p>Tercio was first introduced by Gombolay et al. <ref type="bibr" target="#b33">[34]</ref>. <ref type="foot" target="#foot_1">2</ref> In this paper, we present two advancements for this work, proofs of correctness, and further analysis of the algorithm's performance. First, we generalize the types of task sets that Tercio can efficiently schedule. Second, we present an improved sequencer that produces less-conservative schedules than the method originally presented <ref type="bibr" target="#b33">[34]</ref>. Third, we include proofs of correctness for Tercio's subroutines. Finally, we expand the empirical evaluation of Tercio to demonstrate its significance over the closest available benchmarks in prior literature <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b57">[58]</ref>, <ref type="bibr" target="#b87">[88]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>There is a wealth of prior work related to task assignment and scheduling within the manufacturing field and other applications. Korsah et al. provided a comprehensive taxonomy <ref type="bibr" target="#b42">[43]</ref> for the multirobot task allocation and scheduling problem. According to this taxonomy, our problem fits within the crossschedule dependencies [XD] category, with single-task robots [ST], single-robot tasks <ref type="bibr">[SR]</ref>, and the time-extended allocation <ref type="bibr">[TA]</ref> problem (XD [ST-SR-TA]). Cross-schedule dependencies exist when the utility of one agent is directly affected by the scheduling commitment of another. As noted by <ref type="bibr" target="#b41">[42]</ref>, these dependencies occur in the form of various temporal constraints (e.g., precedence constraints) or of finite-capacity resources that must be shared by agents to complete their tasks. We consider both temporal and resource-based cross-schedule dependencies in this work. We note that prior works often seek to find a feasible schedule with the shortest duration, although other applicationspecific cost functions are sometimes considered.</p><p>While in many cases the problem of task allocation with crossschedule dependencies can be readily formulated and solved as an MILP <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b48">[49]</ref>, the complexity MILP-based solution techniques (e.g., branch-and-bound search) are exponential, leading to computational intractability for large-scale factory operations. Various algorithms have been proposed with the goal Fig. <ref type="figure" target="#fig_7">1</ref>. This table provides a summary of relevant prior work. of achieving favorable scalability characteristics. Here, we survey solution techniques for scheduling problems similar to the problem we present in this work-including MILP formulations, auction-and market-based methods, and other hybrid approaches-and discuss the applicability of these prior techniques to our problem. Table <ref type="table">1</ref> depicts a summary of the relevant approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. MILP/CP Solution Techniques</head><p>One promising approach to solving this class of problems has been the development of a hybrid algorithm incorporating MILP and constraint programming (CP) methods along with decomposition. Techniques based on Benders decomposition <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b52">[53]</ref> are among the most widely used. Benders decomposition works by iteratively updating a function f (ȳ), which provides a lower bound on the optimal solution for an optimization problem where y is a subset of the decision variables and ȳ indicates a specific assignment to those decision variables. For a scheduling problem, y might represent the assignment of agents to jobs, and the remaining variables might represent potential sequences of those jobs. Through bifurcation of the decision variables, it is possible to improve the computation time for a solution to the optimization problem <ref type="bibr" target="#b37">[38]</ref>.</p><p>Various scheduling applications have incorporated Benders decomposition. Logic-based Benders decomposition in particular has been applied to solve job shop scheduling problems where n tasks must be scheduled at m facilities <ref type="bibr" target="#b37">[38]</ref>. Benders cuts (i.e., a lower bound constraint on the optimal solution provided by f (ȳ)) are generated by separating the allocation of tasks from the sequencing of those tasks. Reported results have demonstrated optimal solutions for problems involving approximately 10 facilities and 50 tasks.</p><p>Cordeau et al. <ref type="bibr" target="#b14">[15]</ref> and Mercier et al. <ref type="bibr" target="#b54">[55]</ref> employed Benders decomposition for aircraft routing and crew scheduling <ref type="bibr" target="#b14">[15]</ref>. The authors heuristically decomposed aircraft routing from crew assignment and generated Benders cuts for the resulting assignment subproblem. They empirically demonstrated that this method produced more cost-efficient schedules than prior art. Rekik et al. similarly employed Benders decomposition to schedule personnel shift-work <ref type="bibr" target="#b65">[66]</ref>. The authors applied handtailored forward and backward constraints to cut the search space and proved the correctness of these constraints. Rekik et al. showed that Benders decomposition can be used to solve particularly challenging problems in which the forward and backward constraints do not sufficiently prune the search space.</p><p>While Benders decomposition has served as the basis for many state-of-the-art scheduling algorithms, several alternative techniques have also successfully combined MILP and CP approaches. Jain and Grossmann <ref type="bibr" target="#b38">[39]</ref> presented an iterative method that first solves a relaxed MILP formulation and then searches for the complete solution using CP. When applied to the scheduling of jobs for machines, the MILP relaxation solves for the assignment of jobs and the CP solves for the schedule. If a solution is identified, the algorithm returns the optimal solution; otherwise, the algorithm infers cuts based on the solution of the MILP relaxation and solves the new MILP relaxation using these cuts. The authors reported results for problems involving up to 20 tasks and 5 machines. Li and Womer later improved on this work by employing a hybrid Benders decomposition algorithm with MILP and CP solver subroutines <ref type="bibr" target="#b49">[50]</ref> and reported that their method can solve problems involving 30 tasks and eight different agent types up to four times faster than a standard MILP. Ren and Tang <ref type="bibr" target="#b66">[67]</ref> took a similar approach but employed heuristic strategies to generate informative cuts in the event that the CP solver was unable to identify a feasible task sequence. A related method proposed by Harjunkoski and Grossman <ref type="bibr" target="#b36">[37]</ref> utilized an iterative approach to producing task assignments and schedules. Both Ren and Tang and Harjunkoski and Grossman empirically demonstrated that their algorithms can solve problems involving up to eight machines and 36 jobs; however, these works did not address problems associated with cross-schedule dependencies.</p><p>Although not mathematical programs, some prior works have incorporated planning domain definition language (PDDL)style problem formulations. For example, Erdem et al. <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref> developed distributed and semidistributed techniques for scheduling problems involving precedence and absolute temporal constraints, as well as other resource and spatial proximity constraints. These works utilize a formulation that supports causality-based reasoning. The Erdem et al. <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref> technique yielded optimal solutions for problems with absolute deadlines and complex geometric constraints and readily scaled to problems involving up to eight agents and 80 tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Auction and Market-Based Solution Techniques</head><p>Auction methods and other market-based approaches to scheduling problems, such as those developed by Ponda et al., <ref type="bibr">Choi et al.</ref>, and Liu and Shell, also frequently rely upon decomposition of the problem structure <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b51">[52]</ref>, <ref type="bibr" target="#b63">[64]</ref>. For example, Ponda et al. <ref type="bibr" target="#b63">[64]</ref> developed a decentralized, market-based solution technique for allocating tasks to agents, given that tasks are constrained by time windows. Ponda et al. <ref type="bibr" target="#b63">[64]</ref> employed the consensus-based bundle algorithm (CBBA) <ref type="bibr" target="#b13">[14]</ref>, in which the objective function and constraints are decomposed by agent so that each agent can quickly solve for the value of its bid on each task. Thus, while the work by <ref type="bibr" target="#b63">[64]</ref> represents an added capability for the CBBA, the scalability of the algorithm is strictly worse than the CBBA.</p><p>Recently, Nunes and Gini <ref type="bibr" target="#b57">[58]</ref> developed the temporal sequential single-item (TeSSI) auction algorithm for decentralized scheduling, which has been shown to outperform the CBBA. TeSSI takes as input a task set in the form of a simple temporal problem (STP); each task has an earliest start and latest finish time (absolute wait and deadline constraints). Constraints relating tasks comprise travel time constraints; resource constraints are not included. Nunes and Gini <ref type="bibr" target="#b57">[58]</ref> empirically demonstrated their approach yields improved performance compared with the CBBA <ref type="bibr" target="#b13">[14]</ref>. Furthermore, their approach has since been extended to incorporate precedence relations among tasks <ref type="bibr" target="#b53">[54]</ref>. However, TeSSI and its variants <ref type="bibr" target="#b53">[54]</ref>, <ref type="bibr" target="#b57">[58]</ref> solve a narrower class of problem than Tercio, in that while they handle some crossschedule dependencies in the form of precedence relations, they do not handle subtask-to-subtask deadlines (i.e., deadlines constraining the maximum time between the start time of one subtask and the finish time of the second) or resource capacity constraints.</p><p>Other techniques solve the task allocation problem efficiently <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b51">[52]</ref>, <ref type="bibr" target="#b73">[74]</ref>, <ref type="bibr" target="#b84">[85]</ref>, but do not address the sequencing problem. For example, Sung et al. addressed multirobot task allocation where each agent maintains a queue of tasks and partial information about other agents' queues <ref type="bibr" target="#b73">[74]</ref>. During execution, agents communicate when possible and choose to exchange tasks using a heuristic approach. Sung et al. empirically demonstrated that their algorithm can solve problems involving up to six agents and up to 250 tasks; however, the problems did not involve cross-schedule dependencies or task deadlines.</p><p>Liu and Shell recently proposed a novel distributed method for task allocation via strategic pricing <ref type="bibr" target="#b51">[52]</ref>. Their work builds upon prior approaches to distributed auction algorithms <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b84">[85]</ref>, runs in polynomial time, and produces globally optimal solutions. However, this technique does not consider coupling constraints-for example, a problem in which one agent's assignment directly affects the domain of feasible assignments for other agents, as is the case when agents are performing tasks subject to temporal and resource constraints. Chien et al. proposed planning methods for a team of robotic rovers to accomplish a set of scientific objectives <ref type="bibr" target="#b12">[13]</ref>. The rovers needed to complete a set of tasks where each task required the use of shared, single-access resources (i.e., "shared resources"). The approach by Chien et al. <ref type="bibr" target="#b12">[13]</ref> uses an iterative-repair centralized planner coupled with an auction algorithm to perform centralized goal allocation and decentralized route planning and goal sequencing. Chien et al. benchmarked against a set of randomized problems with three rovers and 12 goals; however, thorough empirical evaluation with an optimal benchmark was not reported.</p><p>Lemaire et al. approached the problem of allocating UAVs to tasks, represented by a bipartite graph <ref type="bibr" target="#b47">[48]</ref>. Here, one set of tasks (UAV navigation) was required to be completed before the second set (target sensing). The authors first presented a centralized auction solution and reported empirical results for a problem involving 50 tasks and four agents. Next, they described a distributed approach wherein an auctioneer agent assigns the first set of tasks to the multirobot team, and then the second set of tasks is auctioned. This method supports rescheduling in light of dynamic disturbances occurring during task execution; however, the authors did not report empirical results for their distributed method. Sycara et al. <ref type="bibr" target="#b74">[75]</ref> explored the problem of task allocation and sequencing for a set of agents. In this work, agents were required to share a finite set of resources necessary for task execution. The authors' formulation was distributed in nature and relied upon multiple heuristics to sequentially construct an effective schedule; however, their approach was suboptimal and did not consider deadline constraints relating tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Hybrid Solution Techniques</head><p>Other hybrid approaches have integrated heuristic schedulers within the MILP solver to achieve better scalability characteristics. For example, Chen et al. incorporated depth-first search (DFS) with heuristic scheduling <ref type="bibr" target="#b11">[12]</ref>. In this approach, a DFS algorithm sequentially assigns tasks to agents, and a heuristic scheduling algorithm sequences the tasks according to a minimum slack priority. The algorithm also employs heuristics to guide the order in which tasks are assigned to resources during the search. Chen benchmarked their work on problems involving approximately 50 tasks and 10 resources (or agents) using a standard problem database <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b59">[60]</ref>.</p><p>Alternatively, Castro and Petrovic <ref type="bibr" target="#b8">[9]</ref> used a heuristic scheduler to seed a feasible schedule for the MILP with regard to patient procedures conducted within a hospital. This method incorporates a tiered approach to minimize a three-term objective function: First, a heuristic scheduling algorithm generates an initial feasible solution. Next, an MILP is solved for the first term of the objective function using the heuristic solution as a seed schedule. The MILP is solved again to optimize the second objective function term, using the solution from the first MILP as a constraint. This process repeats, but for the third objective function term. The solution time is reduced by sequentially optimizing the objective function terms; however, this approach sacrifices global optimality.</p><p>Other approaches perform cooperative scheduling by incorporating Tabu search within an MILP solver <ref type="bibr" target="#b76">[77]</ref>, or by applying heuristics to abstract the problem to groupings of agents <ref type="bibr" target="#b43">[44]</ref>. These hybrid methods are able to solve scheduling problems involving 5 agents (or groups of agents) and 50 tasks in minutes or seconds and address problems incorporating multiple resources, task precedence, and temporal constraints relating task start and end times to the plan epoch time. However, these approaches do not take more general, task-task temporal constraints into consideration.</p><p>Cesta et al. <ref type="bibr" target="#b9">[10]</ref> addressed the problem of project scheduling with time windows by formulating it as a constraint satisfaction problem. In their work, candidate (potentially infeasible) solutions are initially generated using heuristic methods; random and deterministic heuristic techniques are then used to itera-tively repair any infeasibilities in the problem. Cesta et al. <ref type="bibr" target="#b9">[10]</ref> noted that randomization is essential to counteract the bias of greedy scheduling heuristics; however, they did not consider wait constraints that create cross-schedule dependencies, nor did they consider shared resources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Metaheuristic Techniques</head><p>Successful metaheuristic methods have included simulated annealing (SA) and genetic algorithms (GAs). Davis <ref type="bibr" target="#b17">[18]</ref> produced one of the early works applying GAs to job shop scheduling, although many researchers have since followed suit <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b86">[87]</ref>. Recently, Zhang and Wong <ref type="bibr" target="#b87">[88]</ref> developed a GA to perform process planning for single-task machines, singlemachine tasks, and time-extended scheduling with precedence constraints; however, the formulation did not consider deadline constraints or shared resource constraints.</p><p>Researchers have also sought to apply SA techniques to specific scheduling problems <ref type="bibr" target="#b55">[56]</ref>, <ref type="bibr" target="#b58">[59]</ref>, <ref type="bibr" target="#b80">[81]</ref>. Prior works have combined GAs and SA to further improve upon solution quality <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b82">[83]</ref>. These techniques rely upon a random walk through the space of possible schedules; as the number of steps in the walk (i.e., algorithm iterations) approaches ∞, the optimal solution will be found.</p><p>These solution techniques are typically applied to job shop scheduling problems in which tasks are related through neither tightly intercoupled upper and lower bound temporal constraints nor shared resource constraints <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b86">[87]</ref>, <ref type="bibr" target="#b87">[88]</ref>. As they are only probabilistically optimal and rely upon random search, metaheuristics can require a large amount of computation time in order to identify and improve schedules when tight upper bound constraints exist.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Application to Task Assignment and Scheduling With Temporospatial Constraints</head><p>The problem of scheduling-allocating agents to tasks and sequencing those tasks-has been studied in a wide array of works incorporating various solution techniques. However, prior research does not address the need to quickly solve large-scale problems involving tight dependencies among agents' schedules, which can make decomposition problematic. Typically, allowing multiple robots to work closely within the same physical space produces dependencies among the agents' temporal and spatial constraints, leading to uninformative decompositions. We are unaware of prior work that has yielded a solution technique for time-extended scheduling of heterogeneous agents in which each unit of work (i.e., subtask) is related through upper and lower bound temporal constraints without restriction on problem structure (e.g., only some subtasks can be related by certain constraints), where agents must share access to resources (e.g., physical locations) when performing their work.</p><p>While we are not aware of prior work focused on our problem definition, we are able to adapt heuristic, metaheuristic, and exact solution techniques to provide an informative empirical validation. In particular, we benchmarked our solution technique, Tercio, against the following techniques:</p><p>1) We adapted the insertion-heuristic-based TeSSI algorithm <ref type="bibr" target="#b57">[58]</ref> to accommodate our class of problems.</p><p>Insertion heuristics are commonly used in vehicle routing and scheduling <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b71">[72]</ref>. 2) A state-of-the-art GA proposed by Zhang and Wong <ref type="bibr" target="#b87">[88]</ref> for integrated process planning and scheduling. 3) An exact, MILP-based solution technique, Gurobi <ref type="bibr" target="#b34">[35]</ref>,</p><p>which uses state-of-the-art branch-and-bound search and cutting plane heuristics, for the mathematical formulation presented in Section III. In Section X, we show that our technique has the singular ability to balance computational efficiency with solution quality to provide fast, empirically near-optimal solutions for largescale scheduling problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PROBLEM STATEMENT</head><p>In this section, we formulate a task assignment and scheduling problem for multiple robots working within a shared physical space.</p><p>Tercio takes the following as input: 1) τ : The set of all tasks to be performed. Each task</p><formula xml:id="formula_0">τ i ∈ τ is composed of m i precedence-constrained subtasks, denoted τ j i , for j = [1, m i ],</formula><p>where a subtask τ j +1 i may not be released to execute until its predecessor τ j i , finishes executing. Note |τ | is the number of subtasks in τ .</p><p>2) A: The set of all agents that perform subtasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) T C:</head><p>The set of interval temporal constraints <ref type="bibr" target="#b18">[19]</ref> relating subtasks' start and finish times. Lower bound "wait constraints" are denoted as W τ j i ,τ y x and specify that τ y x starts at least W ≥ 0 time units after τ j i ends. Upper bound "deadline constraints" are denoted as D s2s τ j i ,τ y x and specify that τ y x must finish within D s2s &gt; 0 time units of the start of τ j i . "Absolute" deadline constraints D abs for each subtask τ j i . 6) z: An objective function to minimize that includes the makespan and possibly other application-specific terms. A solution to the problem consists of an assignment (i.e.,</p><formula xml:id="formula_1">∀τ j i , ∃!a ∈ A s.t. A a τ j i = 1</formula><p>) of each subtask τ j i ∈ τ to one agent a ∈ A and the assignment of the start s j i ∈ R and finish time f j i ∈ R of each subtask such that all constraints [see ( <ref type="formula">2</ref>)-( <ref type="formula" target="#formula_13">12</ref>)] are satisfied and the objective function [see <ref type="bibr" target="#b0">(1)</ref>] is minimized.</p><p>Remark (On Complexity): Sotskov and Shakhlevich <ref type="bibr" target="#b72">[73]</ref> proved that the following problem (denoted SS'95) is NPhard: Find a minimum makespan schedule for a set of machines M l ∈ M (i.e., agents a ∈ A) completing a set of jobs J i ∈ J (i.e., tasks τ i ∈ τ ) consisting of operations l j i ∈ J i (i.e., τ j i ∈ τ ) with duration t j i such that l j i must be completed be-</p><formula xml:id="formula_2">fore l j +1 i (i.e., T C = {W τ j i ,τ j + 1 i |τ j i , τ j +1 i ∈ τ })</formula><p>, and operation l i,j must be completed on machine M j (i.e., a fixed agent assignment such that (A a τ j i = 1|j = a) → infeasible), where |M |, |J| ≥ 3. In this paper, we consider a problem specification (denoted GWS'17) that is a superset of SS'95 by including general deadline, wait, and resource constraints, and a variable agent assignment. One can map in polynomial time a problem in SS'95 to one in GWS'17 by specifying the fixed agent assignment (i.e., C a</p><formula xml:id="formula_3">τ j i ← ∞ ∀j = a and C a τ j i ← t j i otherwise) in O(|τ ||A|) time. TC consists only of the wait constraints between consecutive subtasks (i.e., T C = {W τ j i ,τ j + 1 i |τ j i , τ j +1 i ∈ τ }) and τ R = ∅.</formula><p>As such, there exists a mapping in P from a problem in SS'95 to one in GWS'17. Therefore, we can say that SS'95 ≤ P GWS'17. As problems in SS'95 are NP-hard, the problem we address are at least NP-hard provided that P = NP.</p><p>The multi-agent coordination problem (with temporospatial constraints) can be readily formulated as an MILP as follows. In this formulation, A a τ j i ∈ {0, 1} is a binary decision variable for the assignment of agent a to subtask</p><formula xml:id="formula_4">τ j i , x τ j i ,τ y x ∈ {0, 1}</formula><p>is a binary decision variable specifying whether τ j i comes after or before τ y x , and s j i , f j i ∈ [0, ∞) are the start and finish times of τ j i . A is the set of all agents a, τ is the set of all tasks and subtasks, and τ R is the set of all subtask pairs τ j i , τ y x that are separated by less than the allowable spatial proximity. M is an artificial variable set to a large positive number and is used to encode conditional constraints.</p><p>Equation <ref type="bibr" target="#b1">(2)</ref> ensures that each task is assigned to one agent. Equation (3) encodes the explicit ordering of subtasks according to the lower bound temporal constraints. Equations ( <ref type="formula">4</ref>) and ( <ref type="formula">5</ref>) encode the minimum wait times and upper bound deadline constraints, respectively, between pairs of subtasks. Equation ( <ref type="formula">6</ref>) enforces the absolute deadlines constraining subtask finish times. Equations ( <ref type="formula">7</ref>) and ( <ref type="formula">8</ref>) ensure that agents are not required to complete tasks any faster or slower than they are capable of. Note that human and robotic workers inherently have varying capabilities. For example, a robot may be able to place composite material, whereas a human might be able to perform a more dexterous task, such as wire-laying. Also, two humans are likely to perform the same task at different rates. In this work, we assume that workers are heterogeneous agents and that each subtask has an agent-specific completion time. Equations ( <ref type="formula" target="#formula_7">9</ref>) and ( <ref type="formula" target="#formula_9">10</ref>) sequence actions to ensure that agents maintain safe buffer distances from one another while performing tasks. Equations <ref type="bibr" target="#b10">(11)</ref> and <ref type="bibr" target="#b11">(12)</ref> ensure that each agent only performs one task at a time. Note that ( <ref type="formula" target="#formula_7">9</ref>) and ( <ref type="formula" target="#formula_9">10</ref>) couple the variables relevant to sequencing and spatial proximity constraints and to task start and end times and produce tight dependencies among agents' schedules Objective: min(z)</p><p>(1)</p><formula xml:id="formula_5">subject to a∈A A a τ j i = 1 ∀τ j i ∈ τ (2) x τ j i ,τ y x = 1 ∀W τ j i ,τ y x ∈ T C (3) W τ j i ,τ y x ≤ s y x -f j i ∀W τ j i ,τ y x ∈ T C (4) D s2s τ j i ,τ y x ≥ f y x -s j i ∀D s2s τ j i ,τ y x ∈ T C (5) D abs τ j i ≥ f j i ∀D abs τ j i ∈ T C (6)</formula><formula xml:id="formula_6">f j i -s j i ≥ lb a τ j i -M 1 -A a τ j i ∀τ j i ∈ τ , a ∈ A (7)</formula><formula xml:id="formula_7">f j i -s j i ≤ ub a τ j i + M 1 -A a τ j i ∀τ j i ∈ τ , a ∈ A (8) s y x -f j i ≥ M x τ j i ,τ y x -1 ∀ τ y x , τ j i ∈ τ R (<label>9</label></formula><formula xml:id="formula_8">)</formula><formula xml:id="formula_9">s j i -f y x ≥ -Mx τ j i ,τ y x ∀ τ j i , τ y x ∈ τ R (<label>10</label></formula><formula xml:id="formula_10">)</formula><formula xml:id="formula_11">s y x -f j i ≥ M 1 + x τ j i ,τ y x -A a τ j i -A a τ y x ∀τ j i , τ y x ∈ τ (<label>11</label></formula><formula xml:id="formula_12">)</formula><formula xml:id="formula_13">s j i -f y x ≥ M 2 -x τ j i ,τ y x -A a τ j i -A a τ y x ∀τ j i , τ y x ∈ τ . (<label>12</label></formula><formula xml:id="formula_14">)</formula><p>Employing branch-and-bound search to identify the optimal solution in this MILP-based formulation requires O 2 |A ||τ |) 3 just in terms of the integer variables for allocation (A a τ j i ) and sequencing (x τ j i ,τ y x ). Note that the number of possible sequencing permutations is O (|τ |!), while the number of sequencing variables in this formulation is O |τ | 2 . Within the manufacturing settings of interest, the number of tasks and subtasks is typically much larger than the number of agents, so the computational bottleneck when solving for a schedule occurs within the sequencing subproblem.</p><p>As noted in Section II, other related works have included formulation of similar scheduling problems as MILPs: For example, Korsah et al. <ref type="bibr" target="#b42">[43]</ref> proposed a general formulation of the instantaneous assignment problem for the XD class. However, our formulation considers time-extended scheduling in which one must also determine how to sequence jobs. Pinto and Grossmann <ref type="bibr" target="#b60">[61]</ref> proposed an MILP formulation that bears similarities to ours: both consider assignments of agents to tasks [see ( <ref type="formula">2</ref>)], as well as the ordering of tasks for machines (or agents) as given by ( <ref type="formula" target="#formula_11">11</ref>) and ( <ref type="formula" target="#formula_13">12</ref>). However, our MILP formulation includes shared resource constraints [see ( <ref type="formula" target="#formula_7">9</ref>) and ( <ref type="formula" target="#formula_9">10</ref>)], as well as the unique capabilities or production rates of agents [see ( <ref type="formula">7</ref>) and ( <ref type="formula">8</ref>)].Other works have considered separate aspects of our problem, such as inclusion of heterogeneous agents (see <ref type="bibr" target="#b77">[78]</ref>) or shared resources (see <ref type="bibr" target="#b40">[41]</ref>). However, these works do not propose a mathematical formulation that addresses the XD [ST-SR-TA] problem variant with resource constraints.</p><p>Tercio approximately solves our problem by producing suboptimal makespan solutions. Section X demonstrates through empirical evaluation that the produced makespans are within 10% of optimal for the range of problems evaluated. To preserve temporal flexibility at execution, the solution is then reformulated as an STP that is flexibly dispatched <ref type="bibr" target="#b83">[84]</ref> (see Section IV-A).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Real-World Motivation Example</head><p>Our problem statement is motivated by real-world applications, such as the Boeing 777 Fully Autonomous Upright Build project (see Fig. <ref type="figure" target="#fig_1">2</ref>). This type of application requires the coordination of six to eight robots for successful assembly of an aerospace structure. Precedence constraints among the work packages must be respected to ensure structural integrity during the build process. Task-task temporal constraints are imposed by process requirements for the timed application of sealant. The robots' work must be sequenced to ensure mutually exclusive access to tools, utilities, and floor space; efficient solutions to the problem involve an intricate choreography of robot movements. A fast dynamic scheduling method is necessary to efficiently and effectively respond to schedule disruptions such as those caused by process time variation, rework, and inspection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. TERCIO</head><p>In this section, we present Tercio, a centralized task assignment and scheduling algorithm that scales to multi-agent, factory-size problems and supports on-the-fly rescheduling with temporal and spatial proximity constraints. Fig. <ref type="figure" target="#fig_2">3</ref> depicts the system architecture, and the pseudocode for the Tercio algorithm is presented in Fig. <ref type="figure" target="#fig_3">4</ref>. Tercio is made efficient through a fast, multi-agent task sequencer inspired by real-time processor scheduling techniques but adapted to leverage the hierarchical problem structure, wherein tasks are composed of precedencerelated subtasks. Our approach decomposes the problem statement in Section III into subproblems of task allocation and sequencing. We use an MILP-based solution method (see Section V) to allocate agents to tasks and a polynomial-time task sequencer to efficiently solve the task sequencing problem (see Section VI). Although the task sequencer is satisficing and incomplete, it substantially improves worst-case time complexity. (We present time complexity analysis for each component of Tercio at the conclusion of their respective description below.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Tercio Pseudocode</head><p>Tercio takes the inputs defined in Section III, along with a user-specified makespan cutoff intended to terminate the optimization process. This cutoff can often be derived from the temporal constraints of the manufacturing process: for example, a user may specify that a provided task set must be completed within an 8-hour shift. Tercio works by iterating through agent allocations until a schedule can be identified that satisfies the maximum allowable makespan for the problem. However, Tercio can also run as an anytime heuristic, terminating once the allotted time has expired.</p><p>As shown in Fig. <ref type="figure" target="#fig_3">4</ref>, Tercio initializes the makespan (line 1) and previous solution (line 2), and then iterates lines 3-7 to compute a schedule that meets this makespan. A third-party optimizer (Gurobi) solves the agent-allocation MILP (line 4) and returns the agent allocation matrix A. Interval temporal (TC) constraints are updated according to this matrix by tightening task time intervals (line 5). For example, if a task is originally designated to take between 5 and 15 min, but the assigned robot can complete it in no fewer than 10 min, the interval tightens from <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">15]</ref> to <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>The agent allocation, the capability-updated TCs, and the spatial map of tasks are then provided as input to the Tercio multi-agent task sequencer (line 6). The task sequencer (described further in Section VI) returns a tight upper bound on the optimal makespan for the given agent allocation, as well as a sequence of tasks for each agent. While this makespan is longer than cutoff (or while the algorithm's runtime has not exceeded the specified timeout), the algorithm iterates lines 3-7, each time adding a constraint (line 7) to exclude previously attempted agent allocations. Tercio terminates when either the returned makespan falls beneath cutoff or when no solution can be found after iterating through all feasible agent allocations. Note that, for each iteration, a search tree is generated for the agent allocation. We propose preserving the search tree across iterations in future work to reduce computation time, updating it with excluded allocations.</p><p>If the cutoff makespan is satisfied, agent and spatial resource sequencing constraints (interval form of [0, ∞)) are added to TC (line 9). The resulting STP, composed of the interval temporal constraints, is compiled into a dispatchable form (line 10) <ref type="bibr" target="#b56">[57]</ref>, <ref type="bibr" target="#b83">[84]</ref>, which guarantees that, for any consistent choice of a time point within a flexible window, there exists a solution that can be identified through one-step propagation of interval bounds. The dispatchable form maintains flexibility to increase robustness to disturbances and has been shown to decrease the amount of time spent recomputing solutions in response to disturbances for randomly generated structured problems by up to 75% <ref type="bibr" target="#b83">[84]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. TERCIO: AGENT ALLOCATION</head><p>The Tercio agent allocator performs agent-task allocation by solving an MILP that includes (2), <ref type="bibr" target="#b6">(7)</ref>, and ( <ref type="formula">8</ref>), ensuring that each task is assigned to exactly one agent and that the allocation does not violate the upper and lower bound temporal constraints. In this work, we investigate the objective of minimizing schedule makespan. This corresponds to solving the MILP defined in Section III according to the objective function depicted in <ref type="bibr" target="#b12">(13)</ref>, where we seek the optimal makespan (i.e., the overall process duration):</p><formula xml:id="formula_15">min(z), z = g MILP (A, τ ) = max τ j i ,τ y x f j i -s y x . (<label>13</label></formula><formula xml:id="formula_16">)</formula><p>However, decomposition of task allocation and sequencing necessitates an objective function that guides the task allocation subroutine toward solutions that are likely to be favorable for the sequencing subroutine. As such, we developed the following objective function [see <ref type="bibr" target="#b13">(14)</ref>], comprising three mixed-integer linear terms [see <ref type="bibr" target="#b14">(15)</ref> and ( <ref type="formula" target="#formula_18">16</ref>)]. Equation <ref type="bibr" target="#b14">(15)</ref> minimizes the maximum work assigned to any one agent, which mitigates situations resulting in a single agent bottle-necking the schedule. Equation ( <ref type="formula" target="#formula_18">16</ref>) minimizes the total amount of work time (i.e., "agent-hours") by selecting the most efficient agent for each subtask. As such, Tercio's agent-allocation subroutine maximizes <ref type="bibr" target="#b13">(14)</ref> subject to <ref type="bibr" target="#b14">(15)</ref> and <ref type="bibr" target="#b15">(16)</ref>. In our MILP-based task allocation subroutine, binary decision variable A a τ j i represents the assignment of agent a to subtask τ j i . The worst-case time complexity of assigning one of a = |A| agents to each subtask in τ via branch-and-bound search is given by O 2 |A ||τ | :</p><formula xml:id="formula_17">min(z), z = α 1 g 1 (A, τ ) + α 2 g 2 (A, τ )<label>(14</label></formula><p>)</p><formula xml:id="formula_18">g 1 (A, τ ) ≥ τ j i ∈τ A a τ j i × C a τ j i ∀a ∈ A (15) g 2 (A, τ ) ≥ a∈A τ j i ∈τ A a τ j i × C a τ j i . (<label>16</label></formula><formula xml:id="formula_19">)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. TERCIO: MULTI-AGENT TASK SEQUENCER</head><p>The Tercio task sequencer takes the problem defined in Section III as input, along with a set of task assignments provided by the Tercio agent allocator described in Section V. The task sequencer is satisficing, meaning the produced schedule merely satisfies the constraints of the problem [see ( <ref type="formula">2</ref>)-( <ref type="formula" target="#formula_13">12</ref>)] and does not take an objective function as input. The task sequencer returns a valid task sequence if the algorithm can identify one. Tercio schedules tasks in simulation using the dynamic priority policy earliest-deadline first (EDF), as well as an online schedulability test that guarantees satisfaction of temporospatial constraints for any opportunistic scheduling policy (i.e., a policy that executes a task if one is available to execute). We formulate this schedulability test as a CP problem and determine whether a full, feasible schedule can be developed if subtask τ j i is scheduled at time t.</p><p>The Tercio task sequencer is inspired by real-time processor scheduling techniques and operates on the structure of a realtime processor scheduling model, called the "self-suspending task model." The sequencer performs a rapid variant of "edgechecking" (similar to that performed in <ref type="bibr" target="#b44">[45]</ref> and <ref type="bibr" target="#b81">[82]</ref>), which we call the multiprocessor Russian dolls test. To our knowledge, the Tercio task sequencer is the first real-time scheduling method for multiprocessor systems that tests the schedulability of nonpreemptive, self-suspending tasks in scenarios where multiple tasks have more than one self-suspension and tasks are constrained by shared memory resources.</p><p>We now outline the steps taken by the Tercio task sequencer. In Section VII, we discuss the relationship of our problem to prior art in real-time processor scheduling and describe our problem as a real-time processor scheduling problem. We then present how the problem depicted in Section III is reformulated into a real-time processor scheduling problem. Finally, in Section VIII, we present the task sequencer's priority policy and multiprocessor Russian dolls test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Multi-Agent Task Sequencer Walk-Through</head><p>Here, we address the mechanics of our task sequencing algorithm, as depicted in Fig. <ref type="figure" target="#fig_4">5</ref>. In line 1, the task set is reformulated (if necessary) into a specific structure that makes the task sequencer operate more efficiently. The task sequencer requires that every subtask τ j i involved in an absolute deadline constraint D abs x ,τ j i . In turn, every τ y x must have exactly one such predecessor subtask. This recurses until reaching either the epoch subtask τ 0 0 in the case of an absolute deadline constraint, or τ b a in the case of a subtask-to-subtask deadline. In Section VII-C, we prove that the reformulation process preserves correctness-any schedule that satisfies the constraints of the reformulated task set will also satisfy the constraints of the original set. The ability to reformulate depends upon the laxity of the deadlines within the task set and the structure of the constraints. The tighter the deadlines and the more connected the constraint graph, the less able the algorithm will be to reformulate the problem into the structure our schedulability test requires. However, this more restricted structure enables our schedulability test to compute an empirically tight schedulability test in polynomial time.</p><p>In line 2, simulation time is initialized to zero. In line 3, the algorithm determines whether the set of absolute deadlines D abs in the reformulated task set is temporally consistent, meaning that the set of agents will be able to successfully schedule against those deadline constraints and their associated spatial constraints. This is determined using the multiprocessor Russian dolls test, as described in Section VIII. After ensuring schedule feasibility due to D abs , the algorithm begins to schedule all subtasks in τ in simulation (lines 4-14). In line 5, the algorithm prioritizes the order in which it attempts to schedule available subtasks according to the EDF dynamic scheduling priority. EDF, commonly used in real-time systems <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b85">[86]</ref>, <ref type="bibr" target="#b88">[89]</ref> and multi-agent scheduling <ref type="bibr" target="#b10">[11]</ref>, attempts to execute the task τ j i with the earliest (smallest in magnitude) deadline d j i first. Line 6 iterates over all available subtasks τ j i and applies the multiprocessor Russian dolls test (line 7) to determine whether a subtask can feasibly be scheduled at time t while satisfying the temporospatial constraints. If feasible, the subtask is scheduled at time t (line 8) and an all-pairs shortest path (APSP) computation <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b39">[40]</ref> is performed to update the temporal constraints. The simulation time is incremented (line 11) and the algorithm continues until all tasks have been scheduled (line 12). Finally, the algorithm returns the makespan and subtask sequence (line 15).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. REAL-TIME PROCESSOR SCHEDULING ANALOGY FOR THE TASK SEQUENCER</head><p>The design of our informative, polynomial-time task sequencer was inspired by a processor scheduling analogy in which each agent is a computer processor able to perform one task at a time, and a physical location in discretized space is modeled as a shared memory resource accessible by only one processor at a time. Wait constraints (lower bounds on interval temporal constraints) are modeled as "self-suspensions" <ref type="bibr" target="#b45">[46]</ref>, <ref type="bibr" target="#b68">[69]</ref>-times during which a task is blocked while another piece of hardware completes a different, time-durative task.</p><p>Typically, assembly manufacturing tasks have more structure (e.g., parallel and sequential subcomponents) and more complex temporal constraints than real-time processor scheduling problems. AI scheduling methods address complex temporal constraints and gain computational tractability by leveraging a hierarchical structure within the plan <ref type="bibr" target="#b70">[71]</ref>. We bridged AI and real-time processor scheduling in order to develop a fast multiagent task sequencer that satisfies tightly coupled upper and lower bound temporal deadlines and spatial proximity restrictions (shared resource constraints).</p><p>The Tercio task sequencer operates on an augmented selfsuspending task model (defined in Section VII-B) and returns a valid task sequence if the algorithm can identify one. The task sequencer is satisficing and incomplete; however, we have empirically validated that it returns makespans within 10% of the optimal when integrated with the Tercio agent allocation algorithm (see Section X).</p><p>Processor scheduling of self-suspending task systems has been the focus of much prior work due to the integration of relatively recent hardware and supporting software systems (e.g., GPUs and PPUs) that trigger the external blocking of tasks <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b45">[46]</ref>, <ref type="bibr" target="#b68">[69]</ref>. Self-suspensions can be thought of as lower bound temporal constraints relating tasks: for example, a user might specify that a first coat of paint needs at least 30 min to dry before a second coat may be applied-this 30-minute wait time is a self-suspension of the painting task.</p><p>Prior work has computed the uniprocessor schedulability of a task set with single <ref type="bibr" target="#b50">[51]</ref>, <ref type="bibr" target="#b68">[69]</ref> or multiple <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b32">[33]</ref> self-suspensions. In our work, we compute the multiprocessor schedulability of a task set in which multiple tasks have more than one suspension and each subtask has a resource constraint. Our approach incorporates a scheduling policy that partially restricts the behavior of the scheduler in order to reduce incidence of multiprocessor schedule anomalies due to self-suspensions. Our approach is similar in spirit to prior art that restricted behavior to reduce anomalies that inherently arise from application of uniprocessor scheduling methods to self-suspending task sets <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b32">[33]</ref>, <ref type="bibr" target="#b46">[47]</ref>, <ref type="bibr" target="#b64">[65]</ref>, <ref type="bibr" target="#b68">[69]</ref>. We first introduce our task model in this section. Second, we describe how our task sequencer satisfies temporospatial constraints in Section VIII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Traditional Self-Suspending Task Model</head><p>The Tercio task sequencer relies upon a well-formed task model that captures hierarchical and precedence structure within the task network. The basis for our framework is the selfsuspending task model, described as</p><formula xml:id="formula_20">τ i : W τ 0 i ,τ 1 i , C 1 i , W τ 1 i ,τ 2 i , C 2 i , . . . , C m i , T i , D i . (<label>17</label></formula><formula xml:id="formula_21">)</formula><p>In this model, a set of tasks τ must be processed by the computer. An instance of each task τ i is released (eligible to execute) at every period T i . The execution of the first subtask of τ i may be delayed from the epoch start as specified by a lower bound wait constraint W τ 0 i ,τ 1 i , called the "phase offset." For each task, there are m i subtasks, with m i -1 self-suspension intervals for each task τ i ∈ τ . We use τ j i to denote the jth subtask of τ i . C j i is the expected duration (cost) of τ j i . A subtask τ k i is released once its predecessor subtask and preceding self-suspension have both finished executing. W τ j -1 i ,τ j i is the lower bound wait constraint (or self-suspension) interval relating the end of τ j -1 i and the start of τ j i . T i and D i are the period and deadline of τ i , respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Augmented Self-Suspending Task Model</head><p>The standard self-suspending task model provides a solid basis for describing many real-world processor scheduling problems of interest <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b45">[46]</ref>, <ref type="bibr" target="#b68">[69]</ref>. Scheduling problems within the manufacturing domain inherently have strong, hierarchical structures that are captured well by the traditional selfsuspending task model. However, self-suspending task systems generally assume that processors are homogeneous and do not include more general temporal or resource constraints among tasks and subtasks <ref type="bibr" target="#b50">[51]</ref>:</p><formula xml:id="formula_22">τ i : W τ 0 i ,τ 1 i , (C a τ 1 i , R 1 i ), W τ 1 i ,τ 2 i , (C a τ 2 i , R 2 i ), . . . (C a τ m i , R m i ), T i , D s2s i , D abs i ; A a τ j i , W τ j i ,τ y x . (<label>18</label></formula><formula xml:id="formula_23">)</formula><p>We first augmented the model to encode the assignment of processors (i.e., agents) to subtasks, denoted by the set of binary decision variables {A a τ j i }. The subtask cost C a τ j i is now dependent upon the capabilities of the agent a processing the subtask. The second augmentation enables a user to specify subtask-tosubtask deadlines D s2s τ j i ,τ k i between the start of τ j i and end of τ k i [see <ref type="bibr" target="#b18">(19)</ref>]; as well as absolute deadlines D abs τ j i for the absolute finish times of subtasks [see <ref type="bibr" target="#b19">(20)</ref>], as shown in <ref type="bibr" target="#b18">(19)</ref> and <ref type="bibr" target="#b19">(20)</ref>. Subtask-to-subtask deadlines are restricted to constrain subtasks within the same task, enabling fast edge-checking in our schedulability test (see Section VIII). In Section VII-C, we describe how general upper bound deadline constraints relating pairs of subtasks are reformulated into this augmented self-suspending task model:</p><formula xml:id="formula_24">D s2s τ j i ,τ k i ≥ f k i -s j i (<label>19</label></formula><formula xml:id="formula_25">)</formula><formula xml:id="formula_26">D abs τ j i ≥ f j i . (<label>20</label></formula><formula xml:id="formula_27">)</formula><p>We define d j i as the implicit deadline on the finish time f j i of subtask τ j i , which is implied by the absolute and subtask deadlines D abs ∪ D s2s . These deadline constraints provide additional expressiveness to encode binary temporal constraints relating tasks. For instance, these constraints may be used to specify that a sequence of subtasks involving sealant application must be completed within 30 min of opening the sealant container. These types of constraints are commonly included in AI and operations research scheduling models and are vital for modeling many real-world problems <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b56">[57]</ref>.</p><p>We augmented the model to express subtask-to-subtask wait constraints [see <ref type="bibr" target="#b20">(21)</ref>] provided that the subtasks meet certain criteria. To describe this restriction, we first introduce two categories of subtasks: free and embedded. Definition 1: A free subtask τ j i ∈ τ free is a subtask that does not share a deadline constraint with τ j -1 i . In other words, a subtask τ j i is free iff for any deadline D τ a i ,τ b i associated with that task (j ≤ a) ∨ (b &lt; j). We define τ 1 i as free, since a preceding subtask does not exist.</p><p>Definition 2: An embedded subtask τ j +1 i ∈ τ emb edded is a subtask that shares a deadline constraint with τ j i (i.e., τ j +1 i / ∈ τ free ). τ free ∩ τ emb edded = ∅:</p><formula xml:id="formula_28">W τ j i ,τ y x ≤ s y x -f j i . (<label>21</label></formula><formula xml:id="formula_29">)</formula><p>For our augmented self-suspending task model, a wait constraint can be applied to subtasks across different tasks τ j i , τ y x if and only if τ y x is a free subtask. This restriction also enables fast edge-checking in our schedulability test, presented in Section VIII. We address how general lower bound wait constraints relating pairs of subtasks are reformulated into this model in Section VII-C.</p><p>We also extended the model to include shared memory resources. Each subtask τ j i requires that a set of shared memory resources R j i = {R j i,1 , . . . , R j i,k i } be utilized to perform that subtask (e.g., for memory shared among multiple processors). In a manufacturing setting, a shared memory resource corresponds to a region of space on the factory floor that must be physically unoccupied in order for an agent to execute a subtask there. Shared memory resources encode hard spatial constraints that prohibit agents from working in dangerously close physical proximity to one another.</p><p>We made four simplifying assumptions about this augmented self-suspending task model. First, we set the implicit deadlines of the tasks equal to the period of the task set. This modification accurately models many assembly line manufacturing processes wherein the set of tasks at each location are repeated once every "pulse" (i.e., period H) of the production line. In this scenario, the user allots a certain amount of time T for the set of tasks to be accomplished, and the set of tasks is repeated with a period of T .</p><p>We also assume that all subtasks are nonpreemptable, meaning that the interruption of a subtask significantly degrades its quality and that the cost of a subtask τ j i assigned to agent a is determined by the expected cost of agent a executing subtask τ j i . Finally, we assume that switching times between tasks (i.e., travel times on the factory floor) are small compared with subtask times and can be modeled as constant. We find this assumption suitable for many assembly manufacturing applicationsfor example, situations in which work is performed within a localized area and does not require lengthy traversals across the factory floor, or where calibration and set-up times at new work locations are long compared with travel times. This assumption would not be reasonable for applications involving the optimization of vehicle routes across a factory or satisfaction of more-complex geometric constraints. We leave the study of more general geometric and temporal logic constraints, such as those considered in <ref type="bibr" target="#b21">[22]</ref> and <ref type="bibr" target="#b61">[62]</ref>, for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Reformulating the Task Set</head><p>Tercio's task sequencer uses an online schedulability test to determine whether a given subtask τ j i can be scheduled at time t considering the deadline constraints within the task set. This schedulability test requires the specific structure of the augmented self-suspending task model in order for this inference to , subtask τ j i has only one predecessor subtask τ y x . This means that either τ y x = τ j -1 i , or that there exists a selfsuspension W τ y x ,τ j i . In turn, τ y</p><p>x must have exactly one such predecessor subtask. This process recurses until reaching either the epoch subtask τ 0 0 , in the case of an absolute deadline constraint, or τ b a , in the case of a subtask-to-subtask deadline. The reformulation preserves correctness, meaning that any schedule that satisfies the constraints of the reformulated task set will also satisfy the constraints of the original task set. The reformulation rules are based on the triangle rules and proofs of correctness developed by Tsamardinos et al. for the reformulation of temporal networks <ref type="bibr" target="#b79">[80]</ref>. However, note that the reformulation process for our algorithm is incomplete: it heuristically attempts to solve an NP-hard scheduling problem, does not explore the entire search space, and thus does not always return a sequence if one exists. The ability to reformulate depends upon the laxity of the deadlines in the task set and the structure of the constraints. The tighter the deadlines and the more connected the constraint graph, the less likely it is that the algorithm will be able to reformulate the problem into the structure our schedulability test requires. Fig. <ref type="figure" target="#fig_6">6</ref> depicts SEQUENCER-REFORMULATE, which takes a task set as input and returns either a reformulated task set (if the algorithm can find a solution) or null (if no feasible reformulated task set can be identified). i and τ y x , and that the APSP temporal lower bound between ordered tasks is nonpositive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Reformulation Pseudocode</head><p>For each subtask with its initiation constrained by a deadline and which involves more than one predecessor subtask, the algorithm iterates over the predecessor subtasks (lines 5 and 6). Lines 7 and 8 consider two predecessors at a time τ b a and τ y</p><p>x and determine whether the lower bound constraints can be reformulated such that τ b a is the predecessor of τ y x , or viceversa (lines 9 and 10). In line 11, in the event that both methods of reformulating the problem are feasible, the algorithm employs a "tie-breaker": If the temporal distance path τ j i → τ y x → τ b a is shorter than that between τ j i → τ b a → τ y x , the path from τ j i to τ y x is removed and a temporal wait constraint is added from τ b a to τ y x -as a result, τ y</p><p>x is now the predecessor of τ b a . If only one method of reformulation is feasible (lines 17 and 19), the constraints are modified accordingly (lines 18 and 20). Each time the constraint network is modified, the reformulation process restarts (lines 22 and 23). The algorithm returns null if it is impossible to reorder τ b a and τ y x and if there are no more predecessor subtasks of τ j i to process (line 24); otherwise, the algorithm returns the reformulated task set (line 28).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Reformulation Example</head><p>In this section, we provide an example to illustrate the reformulation process. Figs. 7 and 8 depict a task set before and after reformulation, respectively. In these figures, subtask start and end times are denoted as nodes (black circles), and constraints are represented by edges. Blue edges indicate lower bound temporal constraints (phase offsets, self-suspensions, or wait constraints), and orange edges represent upper bound temporal constraints (absolute or subtask-to-subtask deadline constraints). Recall that a task set must satisfy two conditions in order to be correctly sequenced by Tercio: First, for every subtask-to-subtask deadline D s2s τ j i ,τ y</p><p>x , there must be path of  precedence from τ j i to τ y x . Second, each subtask must have exactly one predecessor subtask.</p><p>Consider the task set depicted in Fig. <ref type="figure" target="#fig_9">7</ref>. This example includes three temporal constraints that conflict with the abovementioned requirements: D s2s τ 2  2 ,τ 2   3   does not satisfy the requirement of a directed path of precedence from τ 2 2 to τ 2 3 . Also, embedded subtask τ 2  2 has more than one precedence constraint delaying its initiation: (W τ 1 1 ,τ 2 . The requirement of a path of precedence from τ j i to τ y x for every subtask-to-subtask deadline D s2s τ j i ,τ y</p><p>x is now satisfied. Next, we address the wait constraints</p><formula xml:id="formula_30">W τ 1 1 ,τ 2 2 and W τ 1 2 ,τ 2 2 .</formula><p>In order to do so, we must first determine whether to require for τ 1 2 to precede τ 1 1 , or vice-versa. If neither option is possible, the reformulation algorithm cannot reformulate the task set. If only one option is possible, the algorithm selects and enforces that precedence constraint. If both options are temporally feasible, the algorithm assigns the ordering to reduce the delay of τ 2 2 . In this example, ordering τ 1 2 before τ 1  1 is preferred, so the algorithm replaces</p><formula xml:id="formula_31">W τ 1 2 ,τ 2 2 with W τ 1 2 ,τ 1 1 = max(W τ 1 2 ,τ 2 2 -(W τ 1 1 ,τ 2 2 C 2</formula><p>1 ), 0) to ensure satisfaction of the original constraint. The task set can now be correctly sequenced by the Tercio task sequencer algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Proofs of Termination and Correct Reformulation</head><p>In this section, we show that the reformulation algorithm (see Fig. <ref type="figure" target="#fig_6">6</ref>) will terminate for finite task sets. We also demonstrate that the algorithm preserves correctness-that any schedule that satisfies the constraints of the reformulated task set will also satisfy the constraints of the original task set.</p><p>Theorem VII.1: The reformulation subroutine preserves correctness, meaning that any schedule that satisfies the constraints of the reformulated task set will also satisfy the constraints of the original task set.</p><p>Proof by Deduction: Here, we show that each lower bound temporal constraint removed in lines 13, 15, 18, and 20 is made redundant by the newly added temporal constraint. Consider an embedded subtask τ j i , with predecessors τ b a and τ y x , ordered as</p><formula xml:id="formula_32">s j i ≥ f y x + W τ y x ,τ j i (<label>23</label></formula><formula xml:id="formula_33">)</formula><p>and</p><formula xml:id="formula_34">s j i ≥ f b a + W τ b a ,τ j i . (<label>24</label></formula><formula xml:id="formula_35">)</formula><p>The reformulation process either orders τ y x before τ b a , or viceversa. If ordering τ y</p><p>x before τ b a is temporally feasible <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b39">[40]</ref>, the algorithm removes constraint W τ y x ,τ j i and adds constraint W τ y x ,τ b a according to <ref type="bibr" target="#b21">(22)</ref>. (Note that the proof for ordering τ b a before τ y x is symmetric.) When W τ b a ,τ j i in ( <ref type="formula">22</ref>) is sufficiently large to contribute to the new wait constraint W τ y x ,τ b a , ( <ref type="formula" target="#formula_34">24</ref>) and ( <ref type="formula">22</ref>) recover ( <ref type="formula" target="#formula_32">23</ref>):</p><formula xml:id="formula_36">s j i ≥ W τ b a ,τ j i + f b a ≥ W τ b a ,τ j i + C τ b a + s b a ≥ W τ b a ,τ j i + C τ b a + W τ y x ,τ b a + f y x ≥ W τ b a ,τ j i + C τ b a + W τ y x ,τ j i -C τ b a + W τ b a ,τ j i + f y x ≥ f y x + W τ y x ,τ j i . (<label>25</label></formula><formula xml:id="formula_37">)</formula><p>If there already exists a constraint W τ y</p><p>x ,τ b a and W τ y</p><p>x ,τ j i -</p><formula xml:id="formula_38">(C τ b a + W τ b a ,τ j i ) ≤ W τ y</formula><p>x ,τ b a , then ordering τ y x before τ b a inherently satisfies <ref type="bibr" target="#b22">(23)</ref>. Likewise, if W τ y x ,τ b a does not exist and</p><formula xml:id="formula_39">W τ y x ,τ j i -(C τ b a + W τ b a ,τ j i</formula><p>) ≤ 0, then ordering τ y x before τ b a inherently satisfies <ref type="bibr" target="#b22">(23)</ref>. Equation ( <ref type="formula" target="#formula_34">24</ref>) remains satisfied because W τ b a ,τ j i remains unaltered. Theorem VII.2: The reformulation subroutine terminates. Proof by Deduction: Lines 1-4 process a finite number of subtask-to-subtask deadlines, replacing each with an absolute deadline. Lines 5-27 add temporal precedence constraints to the network. Each lower bound temporal constraint removed in lines 13, 15, 18, and 20 is redundant given the newly added temporal constraint, meaning that any schedule that satisfies the new temporal constraint also satisfies the removed constraint (see Theorem VII.1). Therefore, the size of the set of feasible schedules only decreases with each reformulation step, and the algorithm is ultimately guaranteed to terminate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G. SEQUENCER-REFORMULATE Complexity Analysis</head><p>Here, we present the computational complexity of SEQUENCER-REFORMULATE. Lines 1-4 of SEQUENCER-REFORMULATE convert a subset of the subtask-to-subtask deadlines into absolute deadlines. This involves a maximum of |τ | 2 operations. Lines 5-27 reformulate the task graph to ensure that all subtasks τ j i with constrained start times have no more than one predecessor. At most, |τ | 2 wait constraints are modified, and one wait constraint is removed at each iteration (lines <ref type="bibr">13, 15, 18, and 20)</ref>. The feasibility of each modification is assessed using Johnson's algorithm <ref type="bibr" target="#b39">[40]</ref>, which has a complexity of O(|τ</p><formula xml:id="formula_40">| 2 log|τ | + |τ ||TC|). Thus, the complexity of the refor- mulation algorithm is O |τ | 2 + |τ | 2 |τ | 2 log|τ | + |τ ||TC| .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. MULTI-AGENT ONLINE CONSISTENCY CHECK</head><p>The Tercio task sequencer presented in Fig. <ref type="figure" target="#fig_4">5</ref> uses a schedulability test to ensure feasibility while scheduling tasks against deadline constraints and shared memory (or spatial) resource constraints. Our schedulability test, the multiprocessor Russian dolls test, works by determining whether the execution of one set of subtasks associated with a single deadline constraint can be nested within the laxity of a second set of subtasks associated with another deadline constraint. The test operates on the augmented self-suspending task model introduced in Section VII-B and makes the explicit assumption that any subtask with a start time tightened by a deadline constraint will be released upon completion of its single predecessor and any wait or self-suspension time. This assumption enables the algorithm to compute an empirically tight schedulability test in polynomial time.</p><p>Our test is a variant of a resource edge-finding algorithm <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b81">[82]</ref>, the purpose of which is to determine whether an event must or may execute before or after a set of activities <ref type="bibr" target="#b1">[2]</ref>. To our knowledge, our approach is the first to leverage the structure of the self-suspending task model to perform fast edge-checking.</p><p>We incorporate the test in two ways: First, we use it to ensure that the sequencing algorithm can identify a feasible schedule against D abs upon initiation of the scheduling simulation. Second, we use the test to ensure that scheduling a subtask τ j i at time t will not result in plan infeasibility due to D abs ∪ D s2s .</p><p>To describe our test, we first define an active deadline (Definition 3) and an active subtask (Definition 4).</p><p>Definition 3: Active Deadline: A subtask-to-subtask deadline D s2s</p><formula xml:id="formula_41">τ j i ,τ y x is considered active for t ∈ [s j i , f y x )</formula><p>, and an absolute deadline D abs τ j i is considered active for t ∈ [0, f j i ). Definition 4: Active Subtask: A subtask is active at time t if it is unexecuted at time t and is directly constrained by an active deadline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Pseudocode Walk-Through</head><p>Fig. <ref type="figure" target="#fig_12">9</ref> depicts the pseudocode for the multiprocessor Russian dolls test. The test takes as input a subtask τ j i , the task set τ , the time t, and the type of test, and returns either the feasibility of the set of absolute deadlines (type = 1) or the feasibility of scheduling τ j i at time t (type = 2). Our test operates on a specific problem structure: For every absolute deadline constraint D abs</p><formula xml:id="formula_42">τ j i or subtask-to-subtask deadline constraint D s2s τ b a ,τ j i</formula><p>, subtask τ j i must have only one predecessor subtask τ y</p><p>x . This means that either τ y x = τ j -1 i , or else there exists a self-suspension W τ y x ,τ j i . In turn, each τ y</p><p>x must have exactly one such predecessor subtask. This recurses until reaching either the epoch subtask τ 0 0 , in the case of an absolute deadline constraint, or τ b a , in the case of a subtask-to-subtask deadline. This structure allows us to assume that a subtask constrained by a deadline will be released as soon as its predecessor subtask has executed and the wait constraint has expired. In Section VII-C, we describe the mechanism for reformulating a general task set into this structure.</p><p>Before sequencing the task, the algorithm tests the feasibility of the absolute deadlines by calling the Russian dolls test with τ j i = τ 0 0 (the epoch), the task set τ , time t = 0, and type = 1 as input. The test determines whether the set of subtasks constrained by each active deadline can feasibly be executed within the laxity of the other active deadlines. Recall that initially, when t = 0, only the absolute deadlines are active. The algorithm collects the set of active tasks (line 2) and iterates over all pairs of unique subtasks constrained by absolute deadlines (lines 14 and 15). If a pair of subtasks, τ k i and τ y x , is allocated to the same agent (i.e., processor) or requires the same resource, there is potential for contention between these subtasks. Line 17 checks whether the execution of one subtask τ k i , which must occur before d k i , can be nested within the laxity, d y x -C τ k i , of the deadline of subtask τ y x , or vice-versa. This nesting is possible if proposition</p><formula xml:id="formula_43">d k i ≤ d y x -C y x ∨ d k i -C k i ≥ d y x holds; if no such nesting is possible (i.e., if d k i &gt; d y x -C y x ∧ d k i -C k i &lt; d y x</formula><p>), the system returns that it cannot successfully schedule against the set of absolute deadline constraints (line 17). If the system can perform this nesting for all such pairs of subtasks, it returns that it can successfully schedule τ j i at time t (line 22). If the task sequencer calls the Russian dolls test to determine the feasibility of scheduling τ j i at time t (if type = 2), it must first consider the direct effect of executing τ j i . The algorithm iterates over all active subtasks (Definition 4) not including τ j i (line 4). If another active subtask τ y</p><p>x is assigned to the same agent or requires the same resource as τ j i (line 5), the test determines whether it is possible to nest the execution of τ j i within the laxity of τ y</p><p>x 's deadline (line 6). If such nesting is impossible, the algorithm returns false, prohibiting the scheduling of τ j i at time t (line 13). Otherwise, if scheduling τ j i at time t would activate a subtask-to-subtask deadline D s2s τ j i ,τ z i (Definition 3), the algorithm must consider the indirect effects of activation on the other subtasks influenced by this deadline constraint. If such activation would occur, the test stores the set of those subtasks explicitly constrained by D s2s τ j i ,τ z i , excluding τ j i (line 10). (Note that the algorithm has already tested the feasibility of τ j i .) Next, the algorithm iterates over the subtasks in this group and over the set of active subtasks (lines <ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref>. If an active subtask τ y</p><p>x and a subtask τ k i constrained by D s2s τ j i ,τ z i are assigned to the same agent or require the same resource (line 16), the test determines whether it is possible to nest the execution of τ k i within the laxity of τ y</p><p>x 's deadline, or vice-versa (line 17). The implicit deadline d k i for τ k i ∈ τ group is calculated assuming τ j i is executed at time t for the purposes of the test. If nesting is not feasible, the algorithm returns false, indicating there is no guarantee that a feasible schedule exists if τ j i is executed at time t (line 17). If nesting can be performed for all such pairs of subtasks, the algorithm returns true, indicating that τ j i can be scheduled at time t (line 22).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Proof of Correctness of Multiprocessor Russian Dolls Test</head><p>The multiprocessor Russian dolls test is polynomial in time complexity as it only performs pairwise comparisons between active subtasks and the tasks in τ group , and is therefore not a complete schedulability test. However, we prove in this section that the algorithm is nonetheless correct, in that only pairwise comparisons of subtasks are necessary to ensure schedule feasibility.</p><p>The test leverages the problem structure inherent in the augmented self-suspending task model in order to perform efficient computation. Recall that the task model requires every subtask constrained by an absolute D abs , the precedence recurses from τ j i to τ j -1 i and so on through τ 1 i . Likewise, for subtask-to-subtask deadline D s2s τ j i ,τ k i , the precedence recurses from τ k i to τ k -1 i through τ j i . This problem structure restricts the interaction of deadlines in the task set.</p><p>Lemma VIII.1: Scheduling τ j i does not change the implicit deadlines or the laxity of any subtask τ y</p><p>x unless x = i and a subtask-to-subtask deadline D s2s τ j i ,τ z i with i ≤ y ≤ z exists.</p><p>Proof: Consider a set of intratask deadlines for τ i . If the problem is correctly structured as an augmented self-suspending task model, then each embedded subtask in the set τ group = {τ j +1 i , . . . , τ y i , τ z i } has one predecessor that is either a member of τ group or is τ j i . Thus, when τ j i is scheduled, implicit deadlines δ y</p><p>x for subtasks τ y x / ∈ {τ j i , τ j +1 i , . . . , τ y i , τ z i } are unchanged.</p><p>Next, we use Lemma VIII.1 to demonstrate the correctness of the Russian dolls test.</p><p>Theorem VIII.2: The Russian dolls test is correct in that it requires only pairwise comparisons between active subtasks τ active and subtasks in τ group .</p><p>Proof: When τ j i is scheduled, the implicit deadlines for active subtasks may be tightened. We show that this tightening will not result in temporal infeasibility. As in Lemma VIII.1, scheduling τ j i does not change the implicit deadlines or slack times of any subtask τ y</p><p>x unless x = i and a subtask-to-subtask deadline D s2s τ j i ,τ z i with i ≤ y ≤ z exists. In the case where x = i or there is no D s2s τ j i ,τ z i , if it is feasible to nest an active subtask τ y</p><p>x within the laxity of every other active subtask τ q p at time t o , this schedule commitment will reduce the slack available for future scheduling commitments but will not tighten the deadlines of other active subtasks. As such, a pairwise comparison between subtasks in τ group and subtasks in τ active is sufficient to produce of a feasible schedule.</p><p>According to Theorem VIII.2, it is sufficient to consider all pairwise comparisons between subtasks in τ active and τ group to ensure correctness of the Russian dolls test. However, these comparisons are not necessary for correctness. While the computational complexity of the test is polynomial in time, as discussed in Section X, we seek to reduce the computational complexity further by leveraging the fact that these subtasks do not all utilize the same agents and resources.</p><p>Corollary VIII.3: The Russian dolls test is correct in that it requires only pairwise comparisons for each τ y</p><p>x , τ j i where τ y</p><p>x ∈ τ active and τ j i ∈ τ group (as in Theorem VIII.2), such that A a τ j i = A a τ j x and τ y x , τ j i ∈ τ R . Proof: Scheduling any subtask in τ j i ∈ τ group can only result in infeasibility if the required agent or resource is not available to execute τ j i before d j i because the agent or resource is occupied by some τ y</p><p>x ∈ τ active . Thus, to ensure feasibility in the Russian dolls test, it is only necessary to consider pairwise comparisons between subtasks in τ group and τ active that share the same agent or resource.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Russian Dolls Test Complexity Analysis</head><p>Here, we analyze the computational complexity of the Russian dolls test. The test can be called under one of two conditions, type 1 or type 2, depending on how the test is being used. In either case, the complexity is the same. For type 1, at most |τ | are added to τ group . Then, in lines 14-21, every member of τ group is compared to each member of τ active in order to determine whether each τ k i ∈ τ group can nest within the slack of τ y</p><p>x ∈ τ active , or vice-versa (line 17 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. COMPLEXITY OF TERCIO</head><p>As presented in Section V, the computational complexity of Tercio's agent allocation subroutine is given by O 2 |A ||τ | . Here, we derive the complexity of Tercio's sequencing subroutine (see Fig. <ref type="figure" target="#fig_4">5</ref>). Tercio's sequencing subroutine, TERCIO-SEQUENCER, begins in line 1 by calling the reformulation algorithm, SEQUENCER-REFORMULATE (see Next, the sequencer iterates through time to sequence all tasks (line 1, Fig. <ref type="figure" target="#fig_4">5</ref>). The sequencing algorithm iterates f max = max τ j i f j i time steps at most, assuming a unit time step, and f m a x dt otherwise. At each iteration, a maximum of n subtasks (lines 5 and 6) is available for scheduling with satisfied precedence constraints. The priority queue of available subtasks is sorted with O(nlog(n)). Line 7 of the sequencer (see Fig. <ref type="figure" target="#fig_4">5</ref>) then evaluates the feasibility of scheduling each subtask using the Russian dolls type 2 test, the complexity of which is given by O(|τ |) (see Section VIII-C). Finally, the sequencer performs an APSP computation (line 8, Fig. <ref type="figure" target="#fig_4">5</ref>) for each subtask τ j i with a deadline constraint D s2s</p><formula xml:id="formula_44">τ j i ,τ y x . This involves O |τ | 2 log|τ | + |τ ||TC| operations.</formula><p>Thus, the sequencer's complexity is of</p><formula xml:id="formula_45">O(Sequencer) = O |τ | 2 + |τ 2 | + (|τ | 2 + |τ | 2 nf max nlog(n) (|τ | 2 log|τ | + |τ ||TC|)) = O((f max n 2 log(n))(|τ | 4 log|τ | + |τ | 3 |TC|)).</formula><p>Given the aforementioned, Tercio-including task allocation, the sequencer, and all sequencing subroutines-is of complexity</p><formula xml:id="formula_46">O(2 |A||τ | (f max n 2 log(n))(|τ | 4 log|τ | + |τ | 3 |TC|)).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. EVALUATION AND DISCUSSION</head><p>In this section, we empirically validate that Tercio quickly produces solutions within 10% of optimal for multi-agent scheduling problems with temporospatial constraints. Results were generated using an off-the-shelf laptop with an Intel Core i7-2820QM CPU 3.20 GHz (8 Cores) and 16 GB of RAM.</p><p>Tercio is composed of a task reformulator (see Section VII-C, Fig. <ref type="figure" target="#fig_6">6</ref>), task allocator (see Section V), and task (see Section VI, Fig. <ref type="figure" target="#fig_4">5</ref>). The reformulator is implemented in Java, the task allocation algorithm is solved using a Java interface to a third-party optimizer (Gurobi), and the task sequencer is in MATLAB.</p><p>Tercio is an iterative algorithm; for this evaluation, we limited the number of iterations to 25. We found that solutions returned by Tercio did not improve significantly with additional iterations for the problems we were able to benchmark against the optimal solution. For agent allocation, we set α 1 = 2 and α 2 = 1, as this generally achieves helpful allocations for the sequencer, and terminated Gurobi once the incumbent solution was found to be within 0.1% of optimal. We compared our approach against three benchmarks: 1) TeSSI <ref type="bibr" target="#b57">[58]</ref>, 2) object-coding genetic algorithm (OCGA) <ref type="bibr" target="#b87">[88]</ref>, and 3) an exact, MILP-based solution method. For all algorithms, a 60-minute timeout was applied.</p><p>We compared our approach to a technique based on TeSSI and its variants <ref type="bibr" target="#b53">[54]</ref>, <ref type="bibr" target="#b57">[58]</ref>. At its core, TeSSI is an insertion heuristic. As discussed in <ref type="bibr" target="#b28">[29]</ref>, insertion heuristics function by deciding which subtask should next be inserted, where, and to which agent based on some prescribed criteria. TeSSI's criterion is the makespan of the agent to which the subtask is assigned. TeSSI operates on a more-restricted problem structure that involves neither upper and lower bound temporal constraints nor resource constraints. Thus, to compute each agent's makespan, TeSSI simply adds the duration of each task and the time spent traveling between tasks, which is linear in the number of subtasks assigned to the agent. In contrast, Tercio considers problems with upper and lower bound temporal constraints and resource constraints. In order to correctly schedule against upper bound temporal constraints, it is necessary to employ a temporal consistency check (e.g., Tercio's Russian dolls test) as commitments are made. A directed path consistency algorithm <ref type="bibr" target="#b18">[19]</ref> may also serve this purpose as an alternative to the Russian dolls test. For our comparison, we used Snowball <ref type="bibr" target="#b62">[63]</ref>, a state-of-the-art algorithm that achieves complexity of O(n 2 ) for certain cases, such as graphs of constant tree width. We refer to this APSPvariant of TeSSI as TeSSI*.</p><p>OCGA is a state-of-the-art GA developed for job shop scheduling problems <ref type="bibr" target="#b87">[88]</ref>. We adopted the parameter prescribed by <ref type="bibr" target="#b87">[88]</ref> for OCGA as follows: population size N = 100, pairs of parents replicating per iteration r = 7, probability for crossover p c = 1, probability for shifting genes' loci p e = 1, probability for re-allocating agent for a given subtask p m = 0.06, degeneration ratio R = 0.09, and number of iterations N = 2, 500. As with TeSSI*, it was necessary to add a directed path consistency algorithm to evaluate the quality of each schedule; we also used Snowball for this purpose <ref type="bibr" target="#b62">[63]</ref>. In order to improve runtime, we used a hashing function, which stored the quality of previously computed schedules to reduce the number of calls to Snowball with successive iterations of OCGA. GAs such as OCGA are generally probabilistically guaranteed to find the optimal solution as the number of iterations approaches infinity. Thus, given enough time, OCGA will identify a solution better than that generated by Tercio. We find that a more-helpful benchmark than comparing solution quality between OCGA and Tercio is to measure how much time is required for OCGA to find a solution comparable to or better than that identified by Tercio. Thus, in our results, we report the computation time required for OCGA to find such a solution. For instances in which Tercio cannot identify a solution, we report the total computation time required for all 2500 iterations, as prescribed by <ref type="bibr" target="#b87">[88]</ref>.</p><p>The exact, MILP-based formulation, corresponding to solving the MILP defined in Section III and objective function in <ref type="bibr" target="#b12">(13)</ref>, was solved by calling Gurobi using its default settings, which sets the optimality threshold to 0.1%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Generating Random Problems</head><p>We evaluated the performance of Tercio when applied to randomly generated problems. The lower bound agent-task times were of the form lb a τ j i and were drawn from a uniform distribution over the interval <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b9">10]</ref>. Expected agent-task times C a τ j i were generated from C a τ j i ∼ U [lb a τ j i , 10]. We did not explicitly constrain the maximum amount of time an agent spent performing a subtask. Approximately 25% of the generated precedence constraints W τ y -1 x ,τ y x were wait constraints with nonzero lower bounds drawn from the interval <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b9">10]</ref>. Approximately 25% of subtasks had a wait constraint W τ j i ,τ y x , in addition to their self-suspension constraint W τ y -1 x ,τ y x . In order to generate subtask-to-subtask deadlines, we randomly sampled two subtasks τ j i and τ y x , such that y ≥ j, and added a deadline constraint D s2s τ j i ,τ y x . To add absolute deadlines, we randomly sampled a subtask τ j i and added a deadline constraint D abs τ j i . We sought to generate problems of sufficient challenge for our validation. We established a metric D = D s 2 s τ j i , τ y x (yj + 1) + D abs τ j i j and set it to 1 4 for our empirical evaluation depicted by Fig. <ref type="figure" target="#fig_15">10(a)-(l)</ref>. The upper bound of each deadline constraint was drawn from a uniform distribution, with the lower bound set to the tightest feasible deadline and the upper bound set to the sum over subtask costs and wait constraint times. The one-dimensional physical locations of subtasks were drawn from a uniform distribution <ref type="bibr">[1, |τ |]</ref>. The number of subtasks m i within each task τ i was drawn from a uniform distribution in the interval <ref type="bibr">[1, 2n]</ref>, where n is the number of tasks τ i in τ . While an agent performed subtask τ j i at resource location (x), no other agent could work on a subtask at location (u) if x -1 ≤ u ≤ x + 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Computation Speed and Scalability</head><p>Fig. <ref type="figure" target="#fig_15">10(a)</ref>, (e), and (i) depict our evaluation of Tercio's scalability and computational speed. We present the median and upper/lower quartiles of the computation time for 50 randomly generated problems incorporating 5, 10, or 100 agents [see Fig. <ref type="figure" target="#fig_15">10(a)</ref>, (e), and (i), respectively] and between 4 and 1024 subtasks. Where possible, we provide the computation time for the MILP-based solution method, the insertion algorithm, and the time required for OCGA to find a solution as good as that identified by Tercio. Note that the median is typically reported for such optimization problems because the distributions are often skewed and the mean is a less informative measure <ref type="bibr" target="#b78">[79]</ref>.</p><p>Tercio can solve problems involving up to 100 agents and 1000 subtasks in ∼ 120 s, a substantial improvement over our benchmarks. We note that TeSSI* and OCGA compute more slowly than previously published variants because of the need to include a temporospatial feasibility test for each assignment according to the upper and lower bound temporospatial constraints, requiring O(n 2 ) step in the innermost loop of the algorithm. This feasibility test greatly increases computation time despite using the fastest technique available <ref type="bibr" target="#b62">[63]</ref>. Our findings underscore the benefit to computation time provided by our schedulability test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Optimality</head><p>We empirically validate that Tercio produces solutions within 10% of optimal. Fig. <ref type="figure" target="#fig_15">10(c</ref>), (g), and (k) depict the median and upper/lower quartiles of the makespans produced by Tercio, along with the insertion algorithm for 50 randomly generated problems involving 5 and 10 agents and problem sizes spanning four to 42 tasks. The median deviation from optimal for Tercio was less than 10% for all testable problem sizes. However, the median deviation from optimal for the insertion algorithm increased up to 100% for larger problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Evaluating Completeness</head><p>Fig. <ref type="figure" target="#fig_15">10(d</ref>), (h), and (l) depict the proportion of problems solved by Tercio with 5, 10, and 100 agents, respectively. While TeSSI* and OCGA were able to solve slightly more smaller problems than Tercio, Tercio's ability overtook that of both TeSSI* and OCGA as problem size increased. Furthermore, Tercio's completeness is proportional to the number of agents; conversely, OCGA and TeSSI* appear less able to identify satisfactory solutions as the number of agents increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Robustness</head><p>To test the robustness of our approach, we considered problems that are more-or less-constrained in Fig. <ref type="figure" target="#fig_17">11</ref> }. We found that, relative to OCGA and TeSSI*, Tercio's performance remained strong across a range of constraint settings. Tercio's completeness did degrade for the most-constrained problems [see Fig. <ref type="figure" target="#fig_17">11(l)</ref>], but its scalability and solution quality remained strong relative to our benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Robot Demonstration</head><p>Here, we demonstrate the use of Tercio in two hypothetical manufacturing scenarios. In both cases, a team (i.e., set) of robots worked to complete tasks on a simulated fuselage. The robots performed their tasks at specific locations on the factory floor, where there can be multiple subtasks at each location. In order to prevent collisions, each robot reserved the physical location for its subtasks, along with any immediately adjacent  task locations; thus, no two workers could be present at the same location (or in neighboring locations) at the same time. For simplicity, only absolute deadlines D abs were considered, although other constraints could be easily incorporated.</p><p>In the first evaluation, two KUKA Youbots simulated completion of drilling tasks on an aerospace fuselage, as shown in Fig. <ref type="figure" target="#fig_18">12</ref> (video available at http://tiny.cc/t6wjxw). Initially, the robots planned to evenly split 12 identical tasks down the middle of the fuselage. After the robots completed their first subtasks, a worker then requested time to inspect the completed work along the left half of the fuselage; in the problem formulation, this corresponds to adding a resource reservation for the left half for a specified period of time. Tercio replanned in response to the addition of this new constraint and reallocated work in a reasonable manner to make productive use of both robots. For the purposes of this demonstration, the replanning process involved calling Tercio while forcing a fixed assignment and ordering of all subtasks completed prior to the replan request. More-efficient methods could also be considered, such as pruning completed subtasks and reformulating appropriate temporal constraints.</p><p>Second, we demonstrated Tercio on a larger simulated problem, as shown in Fig. <ref type="figure" target="#fig_19">13</ref> (video available at http://tiny.cc/jladjy). In this demonstration, which incorporated ABB's Robot Studio simulation environment, Tercio coordinated 5 robots to perform 110 identical tasks around an aerospace fuselage. Tercio was applied to replan in response to three disturbances: 1) a human worker's request to enter the space to perform a qualityassurance (QA) inspection, 2) a robot breakdown, and 3) changing task deadlines. The duration of the QA request and the robot breakdown were known at the time of the disturbance. Tercio modeled the QA request as a resource reservation for the section of the fuselage to be inspected (i.e., no robots could occupy that space for a given duration). Tercio modeled the robot breakdown as an agent occupied by a repair subtask for a given duration.</p><p>These demonstrations indicate the applicability of the Tercio algorithm for solving real-world problems with applicationspecific features and complex objective functions. For example, localization errors among mobile robots must be accounted for during schedule generation. Intrarobot errors accumulate, which can result in gaps or overlaps in work. In order to reduce the number of opportunities for such errors to occur, we added a term to reduce the number of times when two different agents were used to perform adjacent work, as defined by g 4 (A, τ ) ≥ a∈A τ j i ,τ y</p><p>x ∈τ R A a τ j i × (1 -A a τ y x ). Also, schedule changes in response to disturbances must be interpretable by human workers. Small disturbances can potentially result in substantial changes to robot task assignments, and human workers may find it challenging to understand and anticipate the actions of the robots. In many cases, small schedule changes may be an acceptable tradeoff for a marginally suboptimal solution. As such, we included an additional term to minimize the number of assignment changes from one schedule's allocation P a ).</p><p>While practitioners might attempt to apply other scheduling technology (e.g., one of the benchmarks we employed), we believe Tercio provides a singular ability to rapidly and nearoptimally reschedule robots in dynamic environment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XI. CONCLUSION</head><p>We developed Tercio, a scheduling algorithm made efficient through a fast, multi-agent task sequencer inspired by real-time processor scheduling techniques. We used the task sequencer in conjunction with an MILP solver to compute an integrated multi-agent task sequence that satisfies precedence and temporal and spatial-proximity constraints. Although Tercio is incomplete, we empirically show that the algorithm produces schedules within 10% of the optimal for real-world, structured problems. We also show that Tercio is able to solve more problems and achieve better-quality solutions for such problems than the prior state-of-the-art technique. Finally, we provide physical and virtual demonstrations of Tercio coordinating the activities of a robotic team within a human work environment.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>time of τ j i to within D abs &gt; 0 time units of the epoch start time. 4) τ R : The set of all subtask pairs separated by less than the allowable spatial proximity, derived from spatial locations on the factory floor where subtasks are performed (specified via two-dimensional Cartesian coordinates). 5) AC: The set of agent capabilities specifying the subtasks each agent a ∈ A may perform, as well as that agent's minimum lb</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. This figure depicts the Boeing 777 Fuselage Upright Autonomous Build Process. Courtesy: The Boeing Company.</figDesc><graphic coords="6,303.95,221.24,245.76,83.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. This figure depicts the system architecture of Tercio.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Pseudocode for the Tercio algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Pseudocode for the Tercio multi-agent task sequencer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>τ j i or subtask-to-subtask deadline constraint D s2s τ b a ,τ j i have only one predecessor subtask τ y x . This means that either τ y x = τ j -1 i , or else there exists a lower bound wait con-straint W τ y</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Pseudocode for the reformulation subroutine.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Line 1</head><label>1</label><figDesc>checks whether any subtask-to-subtask deadlines D s2s τ j i ,τ y x exist such that there is neither a wait constraint W τ j i ,τ y x nor a set of wait constraints linking τ j i and τ y x via one or more intermediary subtasks (e.g., temporal upper bound between τ j</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>For a subtask τ j i with two predecessors τ b a and τ y x , the algorithm restructures the problem such that τ b a is the predecessor of τ y x by replacing W τ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. This figure depicts a task set that must be reformulated to adhere to the augmented self-suspending task model.</figDesc><graphic coords="11,322.67,66.04,216.00,114.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. This figure depicts the first two steps for the reformulation of the task set in Fig. 7.</figDesc><graphic coords="11,322.67,226.52,216.00,114.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>2 and W τ 1 2 2 2 ,τ 2 3 as an absolute deadline D abs τ 2 3 , as shown inFig. 8 , 2 3is sufficiently tight to guarantee that f 2 3 does not occur later than s 2 2</head><label>212338232</label><figDesc>Fig. 8, such that D abs τ 2 3 is sufficiently tight to guarantee that f 2 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Pseudocode describing the multiprocessor Russian dolls test.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 6 )</head><label>6</label><figDesc>, to transform general task sets into the structured model required for the schedulability test. The complexity of this subroutine is given by O |τ | 2 + |τ | 2 |τ | 2 log|τ | + |τ ||T C| . After reformulation, the sequencing subroutine uses the Russian dolls test (Fig. 9, type 1 test) to ensure the feasibility of D abs , which has a complexity of O(|τ |) (see Section VIII-C).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. This figure depicts the performance of Tercio relative to TeSSI*, OCGA, and the exact solution (where possible). (a)-(d), (e)-(h), and (i)-(l) present results for problems involving 5, 10, and 100 agents, respectively. When reporting computation time or solution quality (i.e., the makespan), the graphs depict the median and quartiles. Tercio is represented in blue, TeSSI* in red, OCGA in green, and the MILP-based solution technique in black. Note that OCGA is not depicted when reporting the optimality gap, as we terminated OCGA once it found a solution as good as that of Tercio.</figDesc><graphic coords="16,49.45,66.35,491.04,308.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>(a)-(d), (e)-(h), and (i)-(l). We set D = { 0 4 , 1 4 , 2 4 }. Furthermore, we varied the proportion of subtasks with wait constraints W τ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. This figure depicts the performance of Tercio relative to the exact solution, TeSSI*, and OCGA. (a)-(d), (e)-(h), and (i)-(l) present results for problems that involve ten agents and are lightly, moderately, and severely constrained, respectively. Tercio is depicted in blue, TeSSI* in red, OCGA in green, and the MILP-based solution technique in black.</figDesc><graphic coords="17,53.66,66.24,491.04,302.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Robotic team completes mock aerospace final-assembly tasks while maintaining a safe distance from human workers.</figDesc><graphic coords="17,45.15,419.33,245.76,92.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Robotic team adapts performance of work related to a virtual fuselage in response to multiple disruptions.</figDesc><graphic coords="17,308.16,419.05,245.76,50.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>by g 5 (A, P , τ ) ≥ a∈A τ j i ∈τ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>). As such, the complexity of the Russian dolls type 1 test is O |τ | 2 . For type 2, the algorithm first checks the feasibility of scheduling τ j i at time t in lines 4-9. Here, the test considers pairings of τ j i to each subtask in τ active , resulting in a maximum of |τ | -1 operations. Next, lines 14-21 consider pairings of each τ k i in τ group to each subtask in τ active . There are at most τ -1 in both τ group and τ active , resulting in |τ |(|τ | -1) evaluations. Overall, the type 2 Russian dolls test is of complexity O (|τ |(|τ | -1) + (|τ | -1)) = O |τ | 2 . Thus, the complexity of the Russian dolls test under type 1 or 2 is given by O |τ | 2 .</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>"Tercio" is named for the Spanish military formation used during the Renaissance period, which consisted of several different types of troops, each with their own strengths, working together as a single unit.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Parts of this work have been published in Proceedings of Robotics: Science and Systems (RSS 2013).</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper was recommended for publication by Associate Editor R. Carloni and Editor T. Murphey upon evaluation of the reviewers' comments. This work was supported in part by Boeing Research and Technology and in part by the National Science Foundation Graduate Research Fellowship Program under Grant 2388357.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Task assignment for a physical agent team via a dynamic forward/reverse auction mechanism</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-W</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Integr. Knowl. Intensive Multi-Agent Syst</title>
		<meeting>Int. Conf. Integr. Knowl. Intensive Multi-Agent Syst</meeting>
		<imprint>
			<date type="published" when="2005-04">Apr. 2005</date>
			<biblScope unit="page" from="311" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Constraint propagation and decomposition techniques for highly disjunctive and highly cumulative project scheduling problems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Baptiste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Pape</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Constraints</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="119" to="139" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Coordinated target assignment and intercept for unmanned air vehicles</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Beard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Mclain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Goodrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot. Autom</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="911" to="922" />
			<date type="published" when="2002-12">Dec. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Partitioning procedures for solving mixed-variables programming problems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Benders</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numer. Math</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="238" to="252" />
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Auction algorithms for network flow problems: A tutorial introduction</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Bertsekas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Optim. Appl</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="7" to="66" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Brucker</surname></persName>
		</author>
		<title level="m">Scheduling Algorithms</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>3rd ed</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient insertion heuristics for vehicle routing and scheduling problems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Savelsbergh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transp. Sci</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="369" to="378" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Distributed algorithms for dynamic reassignment</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Castañón</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 42nd IEEE Int. Conf. Decis. Control</title>
		<meeting>42nd IEEE Int. Conf. Decis. Control</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="13" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Combined mathematical programming and heuristics for a radiotherapy pre-treatment scheduling problem</title>
		<author>
			<persName><forename type="first">E</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Petrovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Scheduling</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="333" to="346" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A constraint-based method for project scheduling with time windows</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cesta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Oddi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Heuristics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="109" to="136" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Optimal subtask allocation for human and robot collaboration within hybrid assembly system</title>
		<author>
			<persName><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sekiyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cannella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Fukuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Autom. Sci. Eng</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1065" to="1075" />
			<date type="published" when="2014-10">Oct. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Project selection, scheduling and resource allocation with time dependent returns</title>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Askin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">193</biblScope>
			<biblScope unit="page" from="23" to="34" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A comparison of coordinated planning methods for cooperating rovers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Estlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rabideau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int. Conf. Auton. Agents</title>
		<meeting>4th Int. Conf. Auton. Agents</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="100" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Consensus-based decentralized auctions for robust task allocation</title>
		<author>
			<persName><forename type="first">H.-L</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Brunet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>How</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Robot</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="912" to="926" />
			<date type="published" when="2009-08">Aug. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Benders decomposition for simultaneous aircraft routing and crew scheduling</title>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Cordeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Stojković</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Soumis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Desrosiers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transp. Sci</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="357" to="388" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Simultaneous area search and task assignment for a team of cooperative agents</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Curtis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Murphey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AIAA Guid</title>
		<meeting>AIAA Guid</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="2003" to="5584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Energyefficient scheduling for a flexible flow shop using an improved geneticsimulated annealing algorithm</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Giret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Salido</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">D</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Robot. Comput.-Intgr. Manuf</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="418" to="429" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Job shop scheduling with genetic algorithms</title>
		<author>
			<persName><forename type="first">L</forename><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int. Conf. Genetic Algorithm</title>
		<meeting>1st Int. Conf. Genetic Algorithm</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="136" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Temporal constraint networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Meiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="61" to="95" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An improved schedulability test for uniprocessor periodic task systems</title>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">C</forename><surname>Devi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Euromicro Conf. Real-Time Syst</title>
		<meeting>15th Euromicro Conf. Real-Time Syst</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Progen/π x an instance generator for resource-constrained project scheduling problems with partially renewable resources and further extensions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Drexl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nissen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Salewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="59" to="72" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Answer set programming for collaborative housekeeping robotics: Representation, reasoning, and execution</title>
		<author>
			<persName><forename type="first">E</forename><surname>Erdem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Aker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Patoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intell. Serv. Robot</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="275" to="291" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Causality-based planning and diagnostic reasoning for cognitive factories</title>
		<author>
			<persName><forename type="first">E</forename><surname>Erdem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Haspalamutgil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Patoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Uras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2012 IEEE 17th Int. Conf. Emerging Technol. Factory Autom</title>
		<meeting>2012 IEEE 17th Int. Conf. Emerging Technol. Factory Autom</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Finding optimal plans for multiple teams of robots through a mediator: A logic-based approach</title>
		<author>
			<persName><forename type="first">E</forename><surname>Erdem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Patoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">G</forename><surname>Saribatur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schüller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Uras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Pract. Logic Program</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4-5</biblScope>
			<biblScope unit="page" from="831" to="846" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A genetic algorithm for job shop</title>
		<author>
			<persName><forename type="first">E</forename><surname>Falkenauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bouffouix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1991 IEEE Int. Conf. Robot. Autom</title>
		<meeting>1991 IEEE Int. Conf. Robot. Autom</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="824" to="829" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A promising genetic algorithm approach to job-shop scheduling, rescheduling, and open-shop scheduling problems</title>
		<author>
			<persName><forename type="first">H.-L</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Corne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Genetic Algorithm</title>
		<meeting>Int. Conf. Genetic Algorithm</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="375" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On insertion tie-breaking rules in heuristics for the permutation flowshop scheduling problem</title>
		<author>
			<persName><forename type="first">V</forename><surname>Fernandez-Viagas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Framinan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="60" to="67" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Algorithm 97: Shortest path</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Floyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">345</biblScope>
			<date type="published" when="1962-06">Jun. 1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A generalized insertion heuristic for the traveling salesman problem with time windows</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gendreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hertz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="330" to="335" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Generalized benders decomposition</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Geoffrion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Optim. Theory Appl</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="237" to="260" />
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Using genetic algorithms to solve scheduling problems on flexible manufacturing systems (FMS): A literature survey, classification and analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Godinho Filho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Barco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F T</forename><surname>Neto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Flexible Serv. Manuf. J</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="408" to="431" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Uniprocessor scheduler for task sets with well-formed precedence relations, temporal deadlines, and wait constraints</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Gombolay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AIAA Infotech@Aerosp</title>
		<meeting>AIAA Infotech@Aerosp</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Schedulability analysis of task sets with upper-and lower-bound temporal constraints</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Gombolay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Aerosp. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="821" to="841" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Fast scheduling of multirobot teams with temporospatial constraints</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Gombolay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Wilcox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-06">Jun. 2013</date>
			<biblScope unit="page" from="49" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Gurobi Optimizer Reference Manual, Gurobi Optimization</title>
		<ptr target="http://www.gurobi.com" />
		<imprint>
			<date type="published" when="2016">2016</date>
			<pubPlace>Houston TX, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Response time analysis for tasks scheduled under EDF within fixed priorities</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Harbour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Palencia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th IEEE Real-Time Syst. Symp</title>
		<meeting>24th IEEE Real-Time Syst. Symp</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="200" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Decomposition techniques for multistage scheduling problems using mixed-integer and constraint programming methods</title>
		<author>
			<persName><forename type="first">I</forename><surname>Harjunkoski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">E</forename><surname>Grossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Chem. Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1533" to="1552" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Logic-based benders decomposition</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Hooker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic-Based Methods for Optimization: Combining Optimization and Constraint Satisfaction</title>
		<meeting><address><addrLine>Hoboken, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Algorithms for hybrid MILP/CP models for a class of optimization problems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">E</forename><surname>Grossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="258" to="276" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Optimal two-and three-stage production schedules with setup times included</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nav. Res. Logist. Quar</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="61" to="68" />
			<date type="published" when="1954">1954</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Time-extended multi-robot coordination for domains with intra-path constraints</title>
		<author>
			<persName><forename type="first">E</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stentz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Auton. Robots</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="41" to="56" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Exploring bounded optimal coordination for heterogeneous teams with cross-schedule dependencies</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Korsah</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-01">Jan. 2011</date>
			<pubPlace>Pittsburgh, PA, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon Univ</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation, Robotics Inst</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A comprehensive taxonomy for multi-robot task allocation</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Korsah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stentz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Dias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Robot. Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1495" to="1512" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Towards a swarm of agile micro quadrotors</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kushleyev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mellinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Powers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Auton. Robots</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="287" to="300" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Algorithms for propagating resource constraints in AI planning and scheduling: Existing approaches and new results</title>
		<author>
			<persName><forename type="first">P</forename><surname>Laborie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">143</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="151" to="188" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Scheduling self-suspending realtime tasks with rate-monotonic priorities</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Rajkumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2010 16th IEEE Real</title>
		<meeting>2010 16th IEEE Real</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Open problems in scheduling self-suspending tasks</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lakshmanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Rajkumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int</title>
		<meeting>1st Int</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="12" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A distributed tasks allocation scheme in multi-UAV context</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lemaire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Alami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lacroix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="2004-04">2004. Apr. 2004</date>
			<biblScope unit="page" from="3622" to="3627" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Complexity of scheduling under precedence constraints</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">H G R</forename><surname>Kan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="22" to="35" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Scheduling projects with multi-skill personnel by a hybrid MILP/CP benders decomposition algorithm</title>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Womer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Scheduling</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="281" to="298" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Improving the schedulability of sporadic selfsuspending soft real-time multiprocessor task systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2010 IEEE 16th Int</title>
		<meeting>2010 IEEE 16th Int</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Optimal market-based multi-robot task allocation via strategic pricing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Shell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Large Scale Linear and Integer Optimization: A Unified Approach</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Martin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Norwell, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Iterated multi-robot auctions for precedence-constrained task scheduling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mcintire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Nunes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2016 Int. Conf. Auton. Agents Multiagent Syst</title>
		<meeting>2016 Int. Conf. Auton. Agents Multiagent Syst</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1078" to="1086" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A computational study of benders decomposition for the integrated aircraft routing and crew scheduling problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mercier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Cordeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Soumis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1451" to="1476" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A hybrid simulated annealing algorithm for location and routing scheduling problems with crossdocking in the supply chain</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Mousavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tavakkoli-Moghaddam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Manuf. Syst</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="335" to="347" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Reformulating temporal plans for efficient execution</title>
		<author>
			<persName><forename type="first">N</forename><surname>Muscettola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th Int. Conf. Principles Knowl</title>
		<meeting>6th Int. Conf. Principles Knowl</meeting>
		<imprint>
			<date type="published" when="1998-06">Jun. 1998</date>
			<biblScope unit="page" from="444" to="452" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Multi-robot auctions for allocation of tasks with temporal constraints</title>
		<author>
			<persName><forename type="first">E</forename><surname>Nunes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th AAAI Conf</title>
		<meeting>29th AAAI Conf</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2110" to="2116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Simulated annealing for permutation flow-shop scheduling</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Osman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Potts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Omega</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="551" to="557" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A comparison of exact approaches for solving the multiple constrained resource, project scheduling problem</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Manage. Sci</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="854" to="867" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A continuous time MILP model for short term scheduling of multistage batch plants</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">E</forename><surname>Grossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ind. Eng. Chem. Res</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="3037" to="3051" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Planning in discrete and continuous spaces: From LTL tasks to robot motions</title>
		<author>
			<persName><forename type="first">E</forename><surname>Plaku</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Autonomous Robotics</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="331" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Computing all-pairs shortest paths by leveraging low treewidth</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Planken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>De Weerdt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Van Der Krogt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="353" to="388" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Decentralized planning for complex missions with dynamic communication constraints</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ponda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Redding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-L</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>How</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vavrina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2010 Amer. Control Conf</title>
		<meeting>2010 Amer. Control Conf</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="3998" to="4003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Dealing with self-suspending period tasks</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Rajkumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM</title>
		<imprint>
			<date type="published" when="1991">1991</date>
			<pubPlace>Armonk, NY, USA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Using benders decomposition to implicitly model tour scheduling</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rekik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Cordeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Soumis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transp. Sci</title>
		<imprint>
			<biblScope unit="volume">128</biblScope>
			<biblScope unit="page" from="111" to="133" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">An improved hybrid MILP/CP algorithm framework for the job-shop scheduling</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2009 IEEE Int. Conf. Autom. Logist</title>
		<meeting>2009 IEEE Int. Conf. Autom. Logist</meeting>
		<imprint>
			<date type="published" when="2009-08">Aug. 2009</date>
			<biblScope unit="page" from="890" to="894" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Coordination variables, coordination functions, and cooperative timing missions</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Beard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Mclain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Guid., Control, Dyn</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="150" to="161" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Negative results for scheduling independent hard real-time tasks with self-suspensions</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ridouard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Richard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th IEEE Int</title>
		<meeting>25th IEEE Int</meeting>
		<imprint>
			<date type="published" when="2006-05">May 2006</date>
			<biblScope unit="page" from="47" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Real time auction based allocation of tasks for multi-robot exploration problem in dynamic environments</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sariel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Balch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI Workshop Integr. Plan. Scheduling</title>
		<meeting>AAAI Workshop Integr. Plan. Scheduling</meeting>
		<imprint>
			<date type="published" when="2005-07">Jul. 2005</date>
			<biblScope unit="page" from="27" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Bridging the gap between planning and scheduling</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jónsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowl. Eng. Rev</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="47" to="83" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Algorithms for the vehicle routing and scheduling problems with time window constraints</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Solomon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="254" to="265" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Np-hardness of shop-scheduling problems with three jobs</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Sotskov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">V</forename><surname>Shakhlevich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Appl. Math</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="237" to="266" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Improving the performance of multirobot systems by task switching</title>
		<author>
			<persName><forename type="first">C</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ayanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="2999" to="3006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Resource allocation in distributed factory scheduling</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Sycara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="40" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">UAV team decision and control using efficient collaborative estimation</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J R</forename><surname>Shima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Chandler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2005 Amer</title>
		<meeting>2005 Amer</meeting>
		<imprint>
			<date type="published" when="2005-06">Jun. 2005</date>
			<biblScope unit="page" from="4107" to="4112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">A linearized polynomial MILP for the integration of process planning and scheduling</title>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Intell. Manuf</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="593" to="605" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Task scheduling algorithms for heterogeneous processors</title>
		<author>
			<persName><forename type="first">H</forename><surname>Topcuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hariri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Heterogeneous Comput. Workshop</title>
		<meeting>Heterogeneous Comput. Workshop</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Efficient solution techniques for disjunctive temporal reasoning problems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Pollack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">151</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="43" to="89" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Fast transformation of temporal plans for efficient execution</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Muscettola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Nat. Conf. Artif. Intell</title>
		<meeting>13th Nat. Conf. Artif. Intell</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="254" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Job shop scheduling by simulated annealing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Van Laarhoven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">H</forename><surname>Aarts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="113" to="125" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Extension of o (n log n) filtering algorithms for the unary resource constraint to optional activities</title>
		<author>
			<persName><forename type="first">P</forename><surname>Vilím</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Barták</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Čepek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Constraints</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="403" to="425" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">A modified genetic algorithm for job shop scheduling</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D.-Z</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Adv. Manuf. Technol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="72" to="76" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Optimization of temporal dynamics for adaptive human-robot interaction in assembly manufacturing</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Wilcox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nikolaidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Robot. Sci. Syst</title>
		<imprint>
			<biblScope unit="page" from="441" to="448" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">A distributed auction algorithm for the assignment problem</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Zavlanos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Spesivtsev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2008 47th IEEE Conf. Decis. Control</title>
		<meeting>2008 47th IEEE Conf. Decis. Control</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1212" to="1217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Schedulability analysis for real-time systems with EDF scheduling</title>
		<author>
			<persName><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Burns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1250" to="1258" />
			<date type="published" when="2009-09">Sep. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Using genetic algorithms in process planning for job shop machining</title>
		<author>
			<persName><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y C</forename><surname>Nee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evol. Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="278" to="289" />
			<date type="published" when="1997-11">Nov. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">An object-coding genetic algorithm for integrated process planning and scheduling</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">244</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="434" to="444" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Worst case response time analysis of sporadic task graphs with EDF non-preemptive scheduling on a uniprocessor</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Midonnet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int. Conf. Autonomic Auton. Syst</title>
		<meeting>3rd Int. Conf. Autonomic Auton. Syst</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="22" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Gombolay received the B.S. degree in mechanical engineering from the Mechanical Engineering Department</title>
		<author>
			<persName><forename type="first">C</forename><surname>Matthew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">He will join the faculty in the School of Interactive Computing, Georgia Institute of Technology, Atlanta, GA, USA, as the Catherine M. and James E. Allchin Early-Career Associate Professor in Fall 2018, where he will develop novel computational methods for dynamic</title>
		<imprint>
			<date type="published" when="2011">2011. 2013. 2017</date>
		</imprint>
		<respStmt>
			<orgName>Johns Hopkins University</orgName>
		</respStmt>
	</monogr>
	<note>Baltimore, MD, USA, the S.M. degree in aeronautics and astronautics from the Department of Aeronautics and Astronautics, Massachusetts Institute of Technology (MIT), Cambridge, MA, USA, and the Ph.D. degree in autonomous systems from MIT. fluent human-robot teaming</note>
</biblStruct>

<biblStruct xml:id="b90">
	<monogr>
		<title level="m" type="main">VA, USA, and the M.S. degree in mechanical engineering from the Mechanical Engineering Department</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ronald</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011 and 2013</date>
			<pubPlace>Williamsburg; Massachusetts Institute of Technology, Cambridge, MA, USA; New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
	<note>Wilcox received the B.A. degree in physics from College of William and Mary. respectively. He is currently an Associate with Oliver Wyman</note>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">She is an Associate Professor of aeronautics and astronautics with MIT and the Director of the Interactive Robotics Group, which aims to imagine the future of work by designing collaborative robot teammates that enhance human capability. Before joining the faculty, she worked with Boeing Research and Technology on robotics applications for aerospace manufacturing</title>
		<author>
			<persName><forename type="first">Julie</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Massachusetts Institute of Technology (MIT), Cambridge, MA, USA, and the Ph.D. degree in autonomous systems from MIT</title>
		<imprint>
			<date type="published" when="2004">2004. 2006, and 2010</date>
		</imprint>
	</monogr>
	<note>degrees in aeronautics and astronautics from the Department of Aeronautics and Astronautics</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
