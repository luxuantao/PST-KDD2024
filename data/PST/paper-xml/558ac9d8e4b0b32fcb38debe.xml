<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Similarity Flooding: A Versatile Graph Matching Algorithm and its Application to Schema Matching</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sergey</forename><surname>Melnik</surname></persName>
							<email>melnik@db.stanford.edu</email>
						</author>
						<author>
							<persName><forename type="first">Hector</forename><surname>Garcia-Molina</surname></persName>
							<email>hector@db.stanford.edu</email>
						</author>
						<author>
							<persName><forename type="first">Erhard</forename><surname>Rahm</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<postCode>94305</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Leipzig</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Similarity Flooding: A Versatile Graph Matching Algorithm and its Application to Schema Matching</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A2ECC01C5F38CA3317EB9A31E632BEF2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:25+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Matching elements of two data schemas or two data instances plays a key role in data warehousing, e-business, or even biochemical applications. In this paper we present a matching algorithm based on a fixpoint computation that is usable across different scenarios. The algorithm takes two graphs (schemas, catalogs, or other data structures) as input, and produces as output a mapping between corresponding nodes of the graphs. Depending on the matching goal, a subset of the mapping is chosen using filters. After our algorithm runs, we expect a human to check and if necessary adjust the results. As a matter of fact, we evaluate the 'accuracy' of the algorithm by counting the number of needed adjustments. We conducted a user study, in which our accuracy metric was used to estimate the labor savings that the users could obtain by utilizing our algorithm to obtain an initial matching. Finally, we illustrate how our matching algorithm is deployed as one of several high-level operators in an implemented testbed for managing information models and mappings.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Finding correspondences between elements of data schemas or data instances is required in many application scenarios. This task is often referred to as matching. Consider a comparison shopping website that aggregates product offers from multiple independent online stores. The comparison site developers need to match the product catalogs of each store against their combined catalog. For instance, the 'product code' field in one catalog may match the 'product ID' and 'store ID' fields in the combined catalog. Or, think of a merger between two corporations, both of which need to consolidate their relational databases deployed by different departments. In this integration scenario, and in many data warehousing applications, match-£ On leave from the University of Leipzig ing of relational schemas is required. Schema matching is utilized for a variety of other types of schemas including UML class taxonomies, ER diagrams, and ontologies.</p><p>Matching of data instances is another important task. For example, consider two CAD files or program scripts that have been independently modified by several developers. In this scenario, matching helps identify moved or modified elements in these complex data structures. In bioinformatics, matching has been used for network analysis of molecular interactions <ref type="bibr" target="#b8">[9]</ref>. In this domain, data instances represent metabolic networks of chemical compounds, or molecular assembly maps. Matching of molecular networks and biochemical pathways helps to predict metabolism of an organism given its genome sequence.</p><p>Matching problems often differ a lot. So do the approaches to matching. For example, for matching relational schemas one could use SQL data types to determine which columns are closely related. On the other hand, in XML schema matching, hierarchical relationships between schema elements can be exploited. Because of this diversity, applications that rely on matching are often built from scratch and require significant amount of thought and programming. We address this problem by proposing a matching algorithm that allows quick development of matchers for a broad spectrum of different scenarios. We are not trying to outperform custom matchers that use highly tuned, domain-specific heuristics.</p><p>In this paper we suggest a simple structural algorithm that can be used for matching of diverse data structures. Such data structures, which we call models, may be data schemas, data instances, or a combination of both. The elements of models represent artifacts like relational tables and columns, or products and customers. The algorithm that we suggest is based on the following idea. First, we convert the models to be matched into directed labeled graphs. These graphs are used in an iterative fixpoint computation whose results tell us what nodes in one graph are similar to nodes in the second graph. For computing the similarities, we rely on the intuition that elements of two distinct models are similar when their adjacent elements are similar. In other words, a part of the similarity of two elements propagates to their respective neighbors. The spreading of similarities in the matched models is reminiscent to the way how IP packets flood the network in broadcast communication. For this reason, we call our algorithm the similarity flooding algorithm. We refer to the result produced by the algorithm as a mapping. Depending on the particular matching goal, we then choose a subset of the resulting mapping using adequate filters. After our algorithm runs, we expect a human to check and if necessary adjust the results. As a matter of fact, in Section 5 we evaluate the 'accuracy' of the algorithm by counting the number of needed adjustments.</p><p>While this paper focuses on matching, the broader goal of our work is to design a generic tool that helps to manipulate and maintain schemas, instances, and match results. With this tool, matching is not done entirely automatically. Instead, the tool assists human developers in matching by suggesting plausible match candidates for the elements of a schema. Using a graphical interface, the user adjusts the proposed match result by removing or adding lines connecting the elements of two schemas. Often, the correct match depends on the information only available or understandable by humans. For example, even matches as plausible as ZipCode to zip code can be doomed as incorrect by a data warehouse designer who knows that zip codes from a given relational source should not be collected due to poor data quality. In such cases, the mappings suggested by the tool may be incorrect or incomplete.</p><p>In this paper we are making the following contributions:</p><p>¯We introduce a generic matching algorithm that is usable across application areas (Section 3).</p><p>¯We discuss approaches for selecting relevant subsets of match results (Section 4).</p><p>¯We suggest an 'accuracy' metric for evaluating automatic matching algorithms (Section 5) and evaluate the effectiveness of our algorithm on the basis of a user study that we conducted (Section 6).</p><p>We review the related work in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Overview of the Approach</head><p>Before we go into details of our matching algorithm, let us briefly walk through an example that illustrates matching of two relational database schemas. Please keep in mind that the technique we describe is not limited to relational schemas. Consider schemas Ë ½ and Ë ¾ depicted in Figure <ref type="figure" target="#fig_0">1</ref>. The elements of Ë ½ and Ë ¾ are tables and columns. Assume for now that our goal is to obtain exactly one matching element for every element in Ë ½ . A part of the matching result could be, for example, the correspondence of column  A sequence of steps that allows us to determine the correspondences between tables and columns in Ë ½ and Ë ¾ can be expressed as the following script:</p><formula xml:id="formula_0">1. ½ = SQL2Graph(Ë ½ ); ¾ = SQL2Graph(Ë ¾ ); 2. initialMap = StringMatch( ½ , ¾ ); 3. product = SFJoin( ½ , ¾ , initialMap); 4. result = SelectThreshold(product);</formula><p>As a first step, we translate the schemas from their native format into graphs ½ and ¾ . In our example, the native format of the schemas are ASCII files containing table definitions in SQL DDL. A portion of the graph ½ is depicted in Figure <ref type="figure">2</ref>. The translation into graphs is done using an import filter SQL2Graph that understands the definitions of relational schemas. We do not insist on choosing a particular graph representation for relational schemas. The representation used in Figure <ref type="figure">2</ref> is based on the Open Information Model (OIM) specification <ref type="bibr" target="#b0">[1]</ref>. The nodes in the graph are shown as ovals and rectangles. The labels inside the ovals denote the identifiers of the nodes, whereas rectangles represent literals, or string values. For example, node &amp;1 represents the table Personnel in graph ½ , whereas nodes &amp;2, &amp;4, and &amp;6 denote columns Pno, Pname, and Dept, respectively. Column Born and unique key perskey are omitted from the figure for clarity. Tables Employee and Department from schema Ë ¾ are represented in a similar manner in graph ¾ . In our example, ½ has a total of 31 nodes while ¾ has 55 nodes.</p><p>As a second step, we obtain an initial mapping ini-tialMap between ½ and ¾ using operator StringMatch. The mapping initialMap is obtained using a simple string matcher that compares common prefixes and suffixes of literals. A portion of the initial mapping is shown in Table 1. Literal nodes are highlighted using apostrophes. The second column of the table lists similarity values between nodes in ½ and ¾ computed on the basis of their tex- As a third step, operator SFJoin is applied to produce a refined mapping called product between ½ and ¾ . In this paper we propose an iterative 'similarity flooding' (SF) algorithm based on a fixpoint computation that is used for implementing operator SFJoin. The SF algorithm has no knowledge of node and edge semantics. As a starting point for the fixpoint computation the algorithm uses an initial mapping like initialMap. Our algorithm is based on the assumption that whenever any two elements in models ½ and ¾ are found to be similar, the similarity of their adjacent elements increases. Thus, over a number of iterations, the initial similarity of any two nodes propagates through the graphs. For example, in the first iteration the initial textual similarity of strings 'Pname' and 'EmpName' adds to the similarity of columns Personnel/Pname and Employee/EmpName. In the next iteration, the similarity of Personnel/Pname to Em-  </p><formula xml:id="formula_1">¿½ ¡ ½ ¼ entries in the ½ ¾ cross-product).</formula><p>As a last operation in the script, operator SelectThreshold selects a subset of node pairs in product that corresponds to the 'most plausible' matching entries. We discuss this operator in Section 4. The complete mapping returned by SelectThreshold contains 12 entries and is listed in Table <ref type="table" target="#tab_3">2</ref>. For readability, we substituted numeric node identifiers by the descriptions of the objects they represent. For example, we replaced node identifier &amp;2 by [Col:Personnel/Pno].</p><p>As we see in Table <ref type="table" target="#tab_3">2</ref>, the SF algorithm was able to produce a good mapping between Ë ½ and Ë ¾ without any builtin knowledge about SQL DDL by merely using graph structures. For example, table Personnel was matched to table Employee despite the lack of textual similarity. Notice that the table still contains correspondences like the one between node Column in ½ to node Column in ¾ , which are hardly of use given our goal of matching the specific tables and columns. We discuss the filtering of match results in more detail in Section 4. The similarity values shown in the table may appear relatively low. As we will explain, in presence of multiple match candidates for a given model element, relative similarities are often more important than absolute values. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Similarity Flooding Algorithm</head><p>The internal data model that we use for models and mappings is based on directed labeled graphs. Every edge in a graph is represented as a triple ´× Ô Óµ, where × and Ó are the source and target nodes of the edge, and the middle element Ô is the label of the edge. For a more formal definition of our internal data model please refer to <ref type="bibr" target="#b13">[14]</ref>. In this section, we explain our algorithm using a simple example presented in Figure <ref type="figure" target="#fig_1">3</ref>. The top left part of the figure shows two models and that we want to match.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Similarity propagation graph A similarity propagation</head><p>graph is an auxiliary data structure derived from models and that is used in the fixpoint computation of our algorithm. To illustrate how the propagation graph is computed from and , we first define a pairwise connectivity graph</p><formula xml:id="formula_2">(PCG) as follows: ´´Ü Ýµ Ô ´Ü¼ Ý ¼ µµ ¾ PCG´ µ ´µ ´Ü Ô Ü ¼ µ ¾ and ´Ý Ô Ý ¼ µ ¾ .</formula><p>Each node in the connectivity graph is an element from ¢ . We call such nodes map pairs. The connectivity graph for our example is enclosed in a dashed frame in Figure <ref type="figure" target="#fig_1">3</ref>. The intuition behind arcs that connect map pairs is the following. Consider for example map pairs ´ µ and ´ ½ ½ µ. If is similar to , then probably ½ is somewhat similar to ½ . The evidence for this conclusion is provided by the Ð ½ -edges that connect to ½ in graph and to ½ in graph . This evidence is captured in the connectivity graph as an Ð ½ -edge leading from ´ µ to ´ ½ ½ µ. We call ´ ½ ½ µ and ´ µ neighbors.</p><p>The induced propagation graph for and is shown next to the connectivity graph in Figure <ref type="figure" target="#fig_1">3</ref>. For every edge in the connectivity graph, the propagation graph contains an additional edge going in the opposite direction. The weights placed on the edges of the propagation graph indicate how well the similarity of a given map pair propagates to its neighbors and back. These so-called propagation coefficients range from 0 to 1 inclusively and can be computed in many different ways. The approach illustrated in Figure <ref type="figure" target="#fig_1">3</ref> is based on the intuition that each edge type makes an equal contribution of 1.0 to spreading of similarities from a given map pair. For example, there is exactly one Ð ¾ -edge out of ´ ½ µ in the connectivity graph. In such case we set the coefficient Û´´ ½ µ ´ ¾ ¾ µµ in the propagation graph to 1.0. The value 1.0 indicates that the similarity of ½ to contributes fully to that of ¾ and ¾ . Analogously, the propagation coefficient Û´´ ¾ ¾ µ ´ ½ µµ on the reverse edge is also set to 1.0, since there is exactly one incoming Ð ¾edge for ´ ¾ ¾ µ. In contrast, two Ð ½ -edges are leaving map pair ´ µ in the connectivity graph. Thus, the weight of 1.0 is distributed equally among Û´´ µ ´ ½ ½ µµ ¼ and Û´´ µ ´ ¾ ½ µµ ¼ . In <ref type="bibr" target="#b13">[14]</ref> we analyze several alternative ways of computing the propagation coefficients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fixpoint computation</head><p>Let ´Ü Ýµ ¼ be the similarity measure of nodes Ü ¾ and Ý ¾ defined as a total function over ¢ . We refer to as a mapping. The similarity flooding algorithm is based on an iterative computation of -values. Let denote the mapping between and after Ø iteration. Mapping ¼ represents the initial similarity between nodes of and , which is obtained e.g., using string comparisons of node labels. In our example we assume that no initial mapping between and is available, i.e. ¼ ´Ü Ýµ ½ ¼ for all ´Ü Ýµ ¾ ¢ .</p><p>In every iteration, the -values for a map pair ´Ü Ýµ are incremented by the -values of its neighbor pairs in the propagation graph multiplied by the propagation coefficients on the edges going from the neighbor pairs to ´Ü Ýµ. For example, after the first iteration</p><formula xml:id="formula_3">½ ´ ½ ½ µ ¼ ´ ½ ½ µ • ¼ ´ µ ¡ ¼ ½ . Analogously, ½ ´ µ ¼ ´ µ • ¼ ´ ½ ½ µ¡½ ¼ • ¼ ´ ¾ ½ µ¡½ ¼ ¿ ¼. Then, all</formula><p>values are normalized, i.e., divided by the maximal -value</p><formula xml:id="formula_4">(of current iteration) ½ ´ µ ¿ ¼. Thus, after normaliza- tion we get ½ ´ µ ½ ¼, ½ ´ ½ ½ µ ½ ¿ ¼ ¼ , etc.</formula><p>In general, mapping •½ is computed from mapping as follows (normalization is omitted for clarity): </p><formula xml:id="formula_5">•½ ´Ü Ýµ ´Ü Ýµ• È ´ Ù Ô Üµ¾ ´ Ù Ô Ýµ¾ ´ Ù Ù µ ¡ Û´´ Ù Ù µ ´Ü Ýµµ • È ´Ü Ô Ú µ¾ ´Ý Ô Ú µ¾ ´ Ú Ú µ ¡ Û´´ Ú Ú µ ´Ü Ýµµ</formula><formula xml:id="formula_6">•½ ÒÓÖÑ Ð Þ ´ • ³´ µµ A •½ ÒÓÖÑ Ð Þ ´ ¼ • ³´ µµ B •½ ÒÓÖÑ Ð Þ ´³´ ¼ • µµ C •½ ÒÓÖÑ Ð Þ ´ ¼ • • ³´ ¼ • µµ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 3. Variations of the fixpoint formula</head><p>The above computation is performed iteratively until the Euclidean length of the residual vector ¡´ Ò Ò ½ µ be- comes less than for some Ò ¼. If the computation does not converge, we terminate it after some maximal number of iterations. In Section 6 we study the convergence properties of the algorithm. The right part of Figure <ref type="figure" target="#fig_1">3</ref> displays the similarity values for the map pairs in the propagation graph. These values have been obtained after five iterations using the above equation. In the figure, the top three matches with the highest ranks are highlighted in bold. These map pairs indicate how the nodes in should be mapped onto nodes in .</p><p>Taking normalization into account, we can rewrite the above equation to obtain the 'basic' fixpoint formula shown in Table <ref type="table">3</ref>. The function ³ increments the similarities of each map pair based on similarities of their neighbors in the propagation graph. The variations , , and of the fixpoint formula are studied in Section 6. Our experiments suggest that formula performs best with respect to quality of match results and convergence speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Filters</head><p>In this section we examine several filters that can be used for choosing the best match candidates from the list of ranked map pairs returned by the similarity flooding algorithm. Usually, for every element in the matched models, the algorithm delivers a large set of match candidates. Hence, the immediate result of the fixpoint computation (like the one shown on the right of Figure <ref type="figure" target="#fig_1">3</ref>) may still be too voluminous for many matching tasks. For instance, in a schema matching application the choice presented to a human user for every schema element may be overwhelming, even when the presented match candidates are ordered by rank. We refer to the immediate result of the iterative computation as multimapping, since it contains many potentially useful mappings as subsets.</p><p>It is not evident, which criteria could be useful for selecting a desirable subset from a multimapping. An additional complication is that as many as ¾ Ò different subsets can be formed from a set of Ò map pairs. To illustrate the selection problem, consider the match result obtained for two tiny models and that is shown on the left in Figure <ref type="figure">4</ref> (the models themselves are are omitted in the figure for clarity).</p><p>The multimapping Å contains four map pairs with similar-</p><formula xml:id="formula_7">S =1.27 s &lt; S =1.35 s a 1 a 2 (a 1 b ) 1 (a 2 b ) 2 (a 1 b ) 2 (a 2 b ) 1 b 1 b 2 1.0 0.54 0.81 0.27 [1,1]-[1,1] cardinality constraint</formula><p>Possible selections: ities ´ ½ ½ µ ½ ¼, ´ ¾ ½ µ ¼ , etc. From the set of 4 pairs, ¾ ½ distinct subsets can be selected. Every one of these 16 subsets may be a plausible alternative for the final match result presented to the user. We address the selection problem using a three-step approach. First, we use the available application-specific constraints to reduce the size of the multimapping. As exemplified below, typing and cardinality constraints may help to eliminate many map pairs from the multimapping. As a second step, we use selection techniques developed in context of matching in bipartite graphs to pick out the subset that is finally delivered to the user. At last, we evaluate the usefulness of particular selection techniques for a given class of matching tasks (e.g. schema matching) and choose the technique with empirically best results. In the rest of this section we discuss the first two steps in more detail. We present an evaluation of several selection techniques in Section 6.</p><formula xml:id="formula_8">M 1 = M1 M2 M 2 = but M is stable marriage! 1 Multimapping M</formula><p>Constraints Frequently, matching tasks include application-specific constraints that can be used for pruning of a large portion of possible selections. Recall our relational schemas Ë ½ (Personnel) and Ë ¾ (Employee) from Section 2. At least two useful constraints are conceivable for this matching scenario. First, we could use a typing constraint to restrict the result to only those matches that hold between columns or tables, i.e., we can ignore matches of keys, data types etc. Second, if our goal were to populate the Personnel table with data from the Employee table, we could deploy a cardinality constraint that requires exactly one match candidate for every element of schema Ë ½ . In this case, the cardinality of the resulting mapping would have to satisfy the restriction ¼ Ò ½ ½ (using the UML notation). The right expression ½ ½ limits the number of Ë ¾ -elements that may match each element of Ë ½ to exactly one (between a lower limit of 1 and an upper limit of 1). Conversely, the left expression ¼ Ò specifies the valid number of Ë ½ -match candidates (between 0 and Ò) for each element of Ë ¾ , i.e. elements of Ë ¾ may remain unmatched or may have one or more match candidates.</p><p>Unfortunately, in many matching tasks typing or cardinality constraints do not narrow down the match result sufficiently. For example, even after applying a one-to-one ( ½ ½ ½ ½ ) cardinality constraint in Figure <ref type="figure">4</ref>, we are still left with two sets of map pairs Å ½ and Å ¾ . Below we examine several strategies for making the decision between the remaining alternatives Å .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Selection metrics</head><p>To make an educated choice between Å 's we need an intuition of what constitutes a 'better' mapping. Fortunately, our selection dilemma is closely related to well-known matching problems in bipartite graphs, so that we can build on intuitions and algorithms developed for solving this class of problems (see e.g. <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b7">8]</ref>). In the graph matching literature, a matching is defined as a mapping with cardinality ¼ ½ ¼ ½ , i.e., a set of edges no two of which are incident on the same node. A bipartite graph is one whose nodes form two disjoint parts such that no edge connects any two nodes in the same part. Thus, a mapping can be viewed as an undirected weighted bipartite graph.</p><p>A helpful intuition that we will predominantly use for explaining alternative selection strategies for multimappings is provided by the so-called stable marriage problem. To remind, in an instance of the stable marriage problem, each of Ò women and Ò men lists the members of the opposite sex in order of preference. The goal is to find the best match between men and women. A stable marriage is defined as a complete matching of men and women with the property that there are no two couples ´Ü Ýµ and ´Ü¼ Ý ¼ µ such that Ü prefers Ý ¼ to Ý and Ý ¼ prefers Ü to Ü ¼ . For obvious reasons, such a situation would be regarded as unstable. Imagine that in Figure <ref type="figure">4</ref> elements ½ and ¾ correspond to women. Then, men ½ and ¾ would be the primary and the secondary choice for woman ½ . Obviously, mapping Å ½ satisfies the stable marriage condition, whereas Å ¾ does not. In Å ¾ , woman ½ and man ½ favor each other over their actual partners, which puts their marriages in jeopardy.</p><p>The stable-marriage property provides a plausible criterion for selecting a desired mapping from a multimapping. Further selection criteria can be borrowed from other wellknown matching problems like the assignment problem, finding a maximal matching, etc. For example, the assignment problem consists in finding a matching Å in a weighted bipartite graph Å that maximizes the total weight (cumulative similarity) È ´Ü Ýµ¾Å ´Ü Ýµ. Viewed as a marriage, such matching maximizes the total satisfaction of all men and women. In Figure <ref type="figure">4</ref>,</p><formula xml:id="formula_9">È Å¾ ¼ ½ • ¼ ½ ¿ , whereas È Å½ ½ ¼ • ¼ ¾ ½ ¾ . Thus, Å ¾</formula><p>maximizes the total satisfaction of all men and women even though Å ¾ is not a stable marriage.</p><p>To summarize, the filtering problem can be characterized by providing a set of constraints and a selection function that picks out the 'best' subset of the multimapping under a given selection metric. Conceptually, the selection function assigns a value to every subset of the multimapping. The subset for which the function takes the largest/smallest value is selected as the final result. For example, using the assignment problem as selection metric, we can construct a filter that applies a cardinality constraint ¼ ½ ¼ ½ and utilizes a selection function È ´Ü Ýµ¾Å ´Ü Ýµ to choose the best subset. In concrete implementations of selection functions, we can often find algorithms that avoid enumerating all subsets of the multimapping and determine the desired subset directly.</p><p>In the remainder of this section we describe a filter that produced empirically best results in a variety of schema matching tasks, as we show later in Section 6. This approach is implemented in our testbed as the SelectThreshold operator. The intuition behind this approach is based on a perfectionist egalitarian polygamy, which means that no male or female is willing to accept any partner(s) but the best. For a more detailed discussion of alternative selection approaches please refer to <ref type="bibr" target="#b13">[14]</ref>.</p><p>The SelectThreshold operator uses relative similarities, as opposed to the absolute similarities of map pairs computed by the flooding algorithm. Absolute similarity is symmetric, i.e. Ü is similar to Ý exactly as Ý to Ü. Under the marriage interpretation, this means that any two prospective partners like each other to the same extent. Considering relative similarities suggests a more diversified interpretation. Relative similarities are asymmetric and are computed as fractions of the absolute similarities of the best match candidates for any given element. In the example in Figure <ref type="figure">4</ref>, ½ is the best match candidate for ¾ , so we set Ö Ð ´ ¾ ½ µ ½ ¼. The relative similarity for all other match candidates of ¾ is computed as a fraction of</p><formula xml:id="formula_10">´ ¾ ½ µ. Thus, Ö Ð ´ ¾ ¾ µ ´ ¾ ¾µ ´ ¾ ½µ ¼ ¾ ¼ ¼ .</formula><p>All relative similarities for this example are summarized in Figure <ref type="figure">5</ref>.</p><p>The SelectThreshold operator selects a subset of a multimapping, in which all map pairs carry a relative similarity value of at least Ø Ö Ð . For example, for Ø Ö Ð ¼ in Figure <ref type="figure">5</ref>, woman ¾ would accept man ¾ as a partner, but man ¾ would reject woman ¾ since Ö Ð ´ ¾ ¾ µ ¼ ¿¿ ¼ . Most of the time, SelectThreshold with Ø Ö Ð ½ ¼ yields matchings, or monogamous societies. In a less picky version of the operator with Ø Ö Ð ½ ¼, more persons have a chance to find a partner, and polygamy is more likely. We demonstrate the impact of threshold value Ø Ö Ð in Section 5. SelectThreshold operator selects a sub-set of the multimapping which is guaranteed to satisfy the stable-marriage property in a polygamous society. As we illustrate in Section 6, the stable marriage property proved instrumental for filtering multimappings in schema matching scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Assessment of Matching Quality</head><p>In this section, we suggest a metric for measuring the quality of automatic matching algorithms. A crucial issue in evaluating matching algorithms is that a precise definition of the desired match result is often impossible. In many applications the goals of matching depend heavily on the intension of the users, much like the users of an information retrieval system have varying intensions when doing a search. Typically, a user of an information retrieval system is looking for a good, but not necessarily perfect search result, which is generally not known. In contrast, a user performing say schema matching is often able to determine the perfect match result for a given match problem. Moreover, the user is willing to adjust the result manually until the intended match has been established. Thus, we feel that the quality metrics for matching tasks that require tight human quality assessment need to have a slightly different focus than those developed in information retrieval.</p><p>The quality metric that we suggest below is based upon user effort needed to transform a match result obtained automatically into the intended result. We assume a strict notion of matching quality i.e. being close is not good enough. For example, imagine that a matching algorithm comes up with five equally plausible match candidates for a given element, then decides to return only two of them, and misses the intended candidate(s). In such case, we give the algorithm zero points despite the fact that the two returned candidates might be very similar to what we are looking for. Moreover, our metric does not address semiautomatic matching, in which the user iteratively adjusts the result and invokes repeatedly the matching procedure. Thus, the accuracy results we obtain here can be considered 'pessimistic', i.e., our matching algorithm may be 'more useful' that what our metric predicts.</p><p>Matching accuracy Our goal is to estimate how much effort it costs the user to modify the proposed match result È ´Ü½ Ý ½ µ ´ÜÒ Ý Ò µ into the intended result</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Á</head><p>´ ½ ½ µ ´ Ñ Ñ µ . The user effort can be mea- sured in terms of additions and deletions of map pairs performed on the proposed match result È . One simplified metric that can be used for this purpose is what we call match accuracy. Let È Á be the number of correct suggestions. The difference ´Ò µ denotes the number of false positives to be removed from È , and ´Ñ µ is the number of false negatives, i.e. missing matches that need to be added. For simplicity, let us assume that deletions and additions of match pairs require the same amount of effort, and that the verification of a correct match pair is free. If the user performs the whole matching procedure manually (and does not make mistakes), Ñ add operations are required.</p><p>Thus, the portion of the manual clean-up needed after applying the automatic matcher amounts to ´Ò µ•´Ñ µ Ñ of the fully manual matching.</p><p>We approximate the labor savings obtained by using an automatic matcher as accuracy of match result, defined as</p><formula xml:id="formula_11">½ ´Ò µ•´Ñ µ Ñ</formula><p>. In a perfect match, Ò Ñ , resulting in accuracy 1. Notice that Ñ and Ò correspond to recall and precision of matching <ref type="bibr" target="#b10">[11]</ref>. Hence, we can express match accuracy as a function of recall and precision as follows:</p><formula xml:id="formula_12">Accuracy ½ ´Ò µ•´Ñ µ Ñ Ñ ´¾ Ò µ Recall ¾ ½ Precision</formula><p>In the above definition, the notion of accuracy only makes sense if precision is not less than 0.5, i.e at least half of the returned matches are correct. Otherwise, the accuracy is negative. Indeed, if more than a half of the matches are wrong, it would take the user more effort to remove the false positives and add the missing matches than to do the matching manually from scratch. As expected, the best accuracy 1.0 is achieved when both precision and recall are equal to 1.0.</p><p>Intended match result Accuracy, as well as recall and precision, are relative measures that depend on the intended match result. For a meaningful assessment of match quality, the intended match result must be specified precisely. Recall our example dealing with relational schemas that we examined in Section 2. Three plausible match results for this example (that we call Sparse, Expected, and Verbose) are presented in Table <ref type="table">4</ref>. A plus sign (+) indicates that the map pair shown on the right is contained in the corresponding desired match result. For example, map pair ([Table : Personnel], [Table : Employee]) belongs to both Expected and Verbose intended results. The Expected result is the one that we consider the most natural one. The Verbose result illustrates a scenario where matches are included due to additional information available to the human designer. For example, the data in table Personnel is obtained from both Employee and Department, although this is not apparent just by looking at the schemas. Similarly, the Sparse result is a matching where some correspondences have been eliminated due to application-dependent semantics. Keep in mind that in the Sparse and Verbose scenarios, the human selecting the 'perfect' matchings has more information available than our matcher. Thus, clearly we cannot expect our matching algorithm to do as well as in the Expected case. Accuracy, precision, and recall obtained for all three intended results using version of the flooding algorithm (see Table <ref type="table">3</ref>) are summarized in Figure <ref type="figure" target="#fig_3">6</ref>. For each diagram, we executed a script like the one presented in Section 2. The SelectThreshold operator was parameterized using Ø Ö Ðthreshold values ranging from 0.6 to 1.0. As an additional last step in the script, we applied operator SQLMapFilter that eliminates all matches except those between tables, columns, and keys. 1 As shown in the figure, match accuracy 1.0 is achieved for ¼ Ø Ö Ð ½ ¼ in the Expected match, i.e., no manual adjustment of the result is required from the user. In contrast, if the intended result is Sparse, the user can save only 50% of work at best. Notice that the accuracy quickly becomes negative (precision goes below 0.5) with decreasing threshold values. Using no threshold filter at all, i.e. Ø Ö Ð ¼, yields recall of 100% but only 4% precision, and results in a desastrous accuracy value of -2144% (not shown in the figure). Increasing threshold values corresponds to the attempt of the user to quickly prune undesired results by adjusting a threshold slider in a graphical tool. Figure <ref type="figure" target="#fig_3">6</ref> indicates that the quality of matching algorithms may vary significantly in presence of different matching goals. As mentioned earlier, our definition of accuracy is pessimistic, i.e., the user may save more work as 1 SQLMapFilter does not filter out (unlikely) matches between say tables and columns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 4. Three plausible intended match results for matching problem in</head><p>indicated by the accuracy values. The reason for that is twofold. On the one hand, if accuracy goes far below zero, the user will probably scrap the proposed result altogether and start from scratch. In this case, no additional work (in contrast to that implied by negative accuracy) is required. On the other hand, removing false positives is typically less labor-intensive than finding the missing match candidates.</p><p>For example, consider the data point Ø Ö Ð ¼ in the Expected diagram. The matcher found all 6 intended map pairs (100% recall), and additionally returned 6 false positives (50% precision) resulting in an accuracy of 0.0. Arguably, removing these false positives requires less work as compared to starting with a blank screen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluation of algorithm and filters</head><p>To evaluate the performace of the algorithm for schema matching tasks, we conducted a user study with help of eight volunteers in the Stanford Database Group. The study also helped us to examine how different filters and parameters of the algorithm affect the match results. For our study we used nine relatively simple match problems. 2  Some of the problems were borrowed from reseach papers <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b17">18]</ref>. Others were derived from data used on the web- The information provided about the source and target schemas was intentionally vague. The users were asked to imagine a plausible scenario and to map elements in both schemas according to the scenario they had in mind.</p><p>No cardinality constraints were given (any ¼ Ò ¼ Ò mapping was accepted). Noteworthy is that almost no two users could agree on the intended match result for a given matching task, even when examples of data instances were provided (tasks <ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6)</ref>. Therefore, we could hardly expect any automatic procedure to produce excellent results. From eight users, one outlier (i.e. the user with highly deviating results) was eliminated. The accuracy in percent achieved by our algorithm (using fixpoint formula ) for each of the seven users and every task is summarized in Figure <ref type="figure" target="#fig_4">7</ref>. The accuracy metric was used to estimate the amount of work that a given user could save by using our algorithm. The accuracy data was obtained after applying SelectThreshold operator with Ø Ö Ð ½ . Negative accuracy of -14% in Task 3 indicates that User 1 would have spent 14% more work adjusting the automatic match result than doing the match manually.</p><p>Note that in Task 1 the algorithm performed very well, while in Task 2 the results were poor. It turned out that the models used in Task 2 had very simple structure, so that the algorithm was mainly driven by the initial textual match. We did not use any dictionaries for string matching in any of the experiments reported in this paper. Hence, the synonyms used in Task 2 were considered as plausible matches by humans but were not recognized by the algorithm. The matching accuracy over 7 users and 9 problems averaged to ¾±. Hence, our study suggests that for many matching tasks, as much as a half of manual work can be saved using very little application-specific code. This figure is typically even higher in simpler tasks, e.g. when matching two XML documents conforming to the same DTD. Using synonyms may further improve the results of matching. The sizes of the propagation graphs obtained from schemas used in the study ranged from 128 to 1222 edges. Using matching accuracy as the quality measure, we utilized the data collected in the user study to drive our evaluation and tuning of the algorithm for schema matching. As a result of this evaluation, we determined the parameters of the algorithm and the filter that performed best on average for all users and matching problems in our study. The variations of the fixpoint formula that we used are depicted in Table <ref type="table">3</ref>. Using distinct fixpoint formulas results in different multimappings produced by the algorithm as well as different convergence speed. We then applied different filters to choose the best subsets of multimappings. Figure <ref type="figure" target="#fig_5">8</ref> summarizes the accuracy (averaged over all tasks) obtained for every version of the algorithm and filter that we used. The filters were defined as follows:</p><p>¯Threshold filter corresponds to the SelectThreshold operator described in Section 4. It produces mappings of cardinality ¼ Ò ¼ Ò using relative-similarity threshold Ø Ö Ð ½ ¼.</p><p>¯Exact is a ¼ ½ ¼ ½ version of Threshold, which yields monogamous societies.</p><p>¯Best returns a ¼ ½ ¼ ½ mapping using a selection metric that corresponds to the assignment problem. The implementation of the filter uses a greedy heuristic. For the next unmatched element, a best available candidate is chosen that maximizes the cumulative similarity.</p><p>¯Left yields a ¼ ½ ½ ½ mapping, in which every node on the left is assigned a match candidate that maximizes the cumulative similarity. Right is a ½ ½ ¼ ½ counterpart of Left. ¯Outer filter delivers a ½ Ò ½ Ò mapping, in which every node on the left and on the right is guaranteed to have at least one match candidate.</p><p>As suggested by Figure <ref type="figure" target="#fig_5">8</ref>, the best overall accuracy of 57.9% was achieved using Threshold filter with the fixpoint formula . The accuracy of Threshold and Exact filters lie very close to each other. This is not surprising, since Threshold with Ø Ö Ð ½ ¼ typically produces ¼ ½ ¼ ½ mappings. In our study, Right consistently outperforms Left, since in most matching tasks the right schemas were smaller; nodes in right schemas were therefore more likely to appear in the intended match results supplied by the users. Outer performed worst, since in many tasks only small portions of schemas were intended to have matching counterparts.</p><p>We tried to estimate the usefulness of other filters, which are either hard to implement or require extensive computation, by using sampling. For example, a filter that returns a maximal matching (a ¼ ½ ¼ ½ mapping with the most map pairs) is apparently not an optimal one for schema matching. Under formula , the total number of map pairs in all tasks after applying the Best filter is 101, with associated accuracy of ¼±. This accuracy value is lower than 54% obtained using the Exact filter that yields only 73 map pairs. Overall, our study suggests that preserving the stable-marriage property is desirable for selecting subsets of multimappings.</p><p>Notice that the fixpoint formulae , , and yield comparable matching accuracy for each filter. However, formula has much better convergence properties, as suggested by Table <ref type="table" target="#tab_5">5</ref>. The table shows the number Ò of iterations that were required in every task to obtain a residual vector ¡´ Ò Ò ½ µ ¼ ¼ . For every fixpoint formula, we executed the algorithm in two versions, 'as is' and 'strongly connected'. Strongly connected versions guarantee convergence. This effect is achieved by making ¼ schemas. We found experimentally that the strongly connected versions of the algorithm yielded approximately the same overall accuracy for the filters that preserve the stablemarriage property (Threshold, Exact, and Best). In contrast, enforcing convergence had a substantial negative impact on accuracy for the filters Left, Right, and Outer. For a detailed dicussion of convergence criteria please refer to <ref type="bibr" target="#b13">[14]</ref>.</p><p>We investigated seven distinct approaches to computing the propagation coefficients in the induced propagation graph. In the approach illustrated in Section 3, we use a so-called inverse-product formula: we count the number of arcs with a certain label that leave a given pair of nodes in both graphs, multiply the two numbers, and take the inverse of this product as a propagation coefficient. In our user study, we found that the best overall match results were produced using the inverse-average formula. In this formula, we take the inverse of the average number (instead of product) of equilabeled arcs. A formal definition of the formulas that we examined and the details of this experiment are presented in <ref type="bibr" target="#b13">[14]</ref>.</p><p>As a last experiment in this section, we study the impact of the initial similarity values ( ¼ ) on the performance of the algorithm. For this purpose, we randomly distorted the initial values computed by the string matcher. The initial similarities were computed using two versions of a string matcher, one of which took term frequencies into account. Figure <ref type="figure" target="#fig_6">9</ref> depicts the influence of randomization on matching accuracy across all users and matching tasks. For example, randomization of 50% means that every initial similarity value was randomly increased or decreased by Ü percent, Ü ¾ ¼± ¼± . Negative similarity was adjusted to zero. It is noteworthy that a randomization factor of 100% introduced accuracy penalty of just about 15%. This result indicates that the similarity flooding algorithm is relatively robust against variations in seed similarities. The dotted lines show another radical modification of initial similarities, in which each non-zero value in ¼ was set to the same number computed as the average of all positive similarity values. In this case, the accuracy dropped to 30%, which still saves the users on average one third of the manual work.</p><p>To summarize, the main results of our study were the following:</p><p>¯For an average user, overall labor savings across all tasks were above 50%. Recall from Section 5 that our accuracy metric gives a pessimistic estimate, i.e. actual savings may be even higher.</p><p>¯A quickly converging version of the fixpoint formula ( ) did not introduce accuracy penalties.</p><p>¯Threshold filter performed best. ¯The best formula for computing the propagation coefficients was based on the inverse average <ref type="bibr" target="#b13">[14]</ref>.</p><p>¯The flooding algorithm is relatively insensitive to 'errors' in initial similarity values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head><p>Our work was inspired by model management scenarios presented in the vision paper <ref type="bibr" target="#b1">[2]</ref> by Bernstein et al. In particular, our scripts use similar high-level operations on models. Such an approach can significantly simplify the development of metadata-based tasks and applications compared to the use of current metadata repositories and their lowlevel APIs.</p><p>A recent classification and review of matching techniques can be found in <ref type="bibr" target="#b17">[18]</ref>. Most of the previously proposed approaches lack genericity and are tailored to a specific application domain such as schema or data integration, and specific schema types such as relational or XML schemas. Moreover, most approaches are restricted to finding 1:1 matching correspondences. A few promising approaches not only use schema-level but also instance-level information for schema matching <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b5">6]</ref>. Unfortunately, their use of neural networks <ref type="bibr" target="#b10">[11]</ref> or machine learning techniques <ref type="bibr" target="#b5">[6]</ref> introduces additional preparing and training effort.</p><p>Concurrently and independently to the work reported in this paper, a generic schema matching approach called Cupid was developed at Microsoft Research <ref type="bibr" target="#b12">[13]</ref>. It uses a comprehensive name matching based on synonym tables and other thesauri as well as a new structural matching approach considering data types and topological adjacency of schema elements.</p><p>Many other studies have used more sophisticated linguistic (name/text) matchers compared to our very simple string matcher, e.g. WHIRL <ref type="bibr" target="#b4">[5]</ref>. The work in <ref type="bibr" target="#b14">[15]</ref> addresses the related problem of determining mapping expressions between matching elements.</p><p>In general, match algorithms developed by different researchers are hard to compare since most of them are not generic but tailored to a specific application domain and schema types. Moreover, as we have discussed in Section 5, matching is a subjective operation and there is not always a unique result. Previously proposed metrics for measuring the matching accuracy <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b5">6]</ref> did not consider the extra work caused by wrong match proposals. Our accuracy metric is similar in spirit to measuring the length of edit scripts as suggested in <ref type="bibr" target="#b3">[4]</ref>. However, we are counting the edit operations on mappings, rather than those performed on models to be matched.</p><p>In designing our algorithm and the filters, we borrowed ideas from three research areas. The fixpoint computation corresponds to random walks over graphs <ref type="bibr" target="#b15">[16]</ref>, as explained in <ref type="bibr" target="#b13">[14]</ref>. A well-known example of using fixpoint computation for ranking nodes in graphs is the PageRank algorithm used in the Google search engine <ref type="bibr" target="#b2">[3]</ref>. Unlike Page-Rank, our algorithm has two source graphs and extensively uses and depends on edge labeling. The filters that we proposed for choosing subsets of multimappings are based on the intuition behind the class of stable marriage problems <ref type="bibr" target="#b7">[8]</ref>. General matching theory and algorithms are comprehensively covered in <ref type="bibr" target="#b11">[12]</ref>. Finally, the quality metric that we use for evaluating the algorithm is related to the precision/recall metrics developed in the context of information retrieval.</p><p>The data model used in this paper is based on the RDF model <ref type="bibr" target="#b9">[10]</ref>. For transforming native data into graphs we use graph-based models defined for different applications (see e.g. <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b6">7]</ref>).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Matching two relational schemas: Personnel and Employee-Department</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Example illustrating the Similarity Flooding Algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .Figure 5 .</head><label>45</label><figDesc>Figure 4. Cumulative similarity vs. 'stable marriage'</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Matching accuracy as a function of Ø Ö Ð -threshold for intended match results Sparse, Expected, and Verbose from Table 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Average matching accuracy for 7 users and 9 matching problems</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Matching accuracy for different filters and three versions of the algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Impact of randomizing initial similarities on matching accuracy</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 . A portion of initialMap (10 of total 26 entries are shown)</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="2">Column</cell><cell cols="3">ColumnType</cell></row><row><cell>Table type</cell><cell>column</cell><cell>type &amp;2</cell><cell cols="2">Pno SQLtype name</cell><cell>type &amp;3</cell><cell>name</cell><cell>int</cell></row><row><cell>name &amp;1</cell><cell>column column</cell><cell>type &amp;4</cell><cell cols="2">Pname SQLtype name</cell><cell>type &amp;5</cell><cell>name</cell><cell>string</cell></row><row><cell>Personnel</cell><cell cols="2">type</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">. . .</cell><cell>&amp;6</cell><cell cols="2">Dept SQLtype name</cell><cell></cell><cell></cell></row><row><cell cols="8">Figure 2. A portion of graph representation</cell></row><row><cell cols="4">½ for relational schema Ë ½</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Line#</cell><cell>Similarity</cell><cell cols="5">Node in ½ Node in ¾</cell></row><row><cell cols="2">1. 1.0</cell><cell cols="2">Column</cell><cell></cell><cell cols="2">Column</cell></row><row><cell cols="2">2. 0.66</cell><cell cols="2">ColumnType</cell><cell></cell><cell cols="2">Column</cell></row><row><cell cols="2">3. 0.66</cell><cell cols="2">'Dept'</cell><cell></cell><cell cols="2">'DeptNo'</cell></row><row><cell cols="2">4. 0.66</cell><cell cols="2">'Dept'</cell><cell cols="3">'DeptName'</cell></row><row><cell cols="2">5. 0.5</cell><cell cols="2">UniqueKey</cell><cell cols="3">PrimaryKey</cell></row><row><cell cols="2">6. 0.26</cell><cell cols="2">'Pname'</cell><cell cols="3">'DeptName'</cell></row><row><cell cols="2">7. 0.26</cell><cell cols="2">'Pname'</cell><cell cols="3">'EmpName'</cell></row><row><cell cols="2">8. 0.22</cell><cell cols="2">'date'</cell><cell></cell><cell cols="2">'Birthdate'</cell></row><row><cell cols="2">9. 0.11</cell><cell cols="2">'Dept'</cell><cell cols="3">'Department'</cell></row><row><cell cols="2">10. 0.06</cell><cell></cell><cell>'int'</cell><cell cols="3">'Department'</cell></row><row><cell cols="8">tual content. The similarity values range between 0 and 1</cell></row><row><cell cols="8">and indicate how well the corresponding nodes in ½ match</cell></row><row><cell cols="8">their counterparts in ¾ . Notice that the initial mapping is</cell></row><row><cell cols="8">still quite imprecise. For instance, it suggests mapping col-</cell></row><row><cell cols="8">umn names onto table names (e.g. column Dept in Ë ½ onto</cell></row><row><cell cols="8">table Department in Ë ¾ , line 9), or names of data types</cell></row><row><cell cols="8">onto column names (e.g. SQL type date in Ë ½ onto column</cell></row><row><cell cols="3">Birthdate in Ë ¾ , line 8).</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 . The mapping after applying Select- Threshold on result of SFJoin</head><label>2</label><figDesc></figDesc><table><row><cell>ployee/EmpName propagates to the SQL types string</cell></row><row><cell>and varchar(50). This subsequently causes increase</cell></row><row><cell>in similarity between literals 'string' and 'varchar',</cell></row><row><cell>leading to a higher resemblance of Personnel/Dept</cell></row><row><cell>to Department/DeptName than that of Person-</cell></row><row><cell>nel/Dept to Department/DeptNo. The algorithm</cell></row><row><cell>terminates after a fixpoint has been reached, i.e. the sim-</cell></row><row><cell>ilarities of all model elements stabilize. In our example,</cell></row><row><cell>the refined mapping product returned by SFJoin contains</cell></row><row><cell>211 node pairs with positive similarities (out of a total of</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 . Illustration of convergence properties of variations of fixpoint formula for tasks Ì ½ Ì in the user study. Shows iterations needed until length of residual vector</head><label>5</label><figDesc></figDesc><table><row><cell>Formula</cell><cell cols="4">Ì ½ Ì ¾ Ì ¿ Ì</cell><cell>Ì</cell><cell>Ì</cell><cell>Ì</cell><cell>Ì</cell><cell>Ì</cell><cell>Total</cell></row><row><cell>A (as is)</cell><cell>18</cell><cell>48</cell><cell>122</cell><cell>78</cell><cell>½</cell><cell>12</cell><cell>37</cell><cell>25</cell><cell>25</cell><cell>½</cell></row><row><cell>A (strongly connected)</cell><cell>15</cell><cell>56</cell><cell>89</cell><cell>81</cell><cell>1488</cell><cell>18</cell><cell>48</cell><cell>25</cell><cell>31</cell><cell>1851</cell></row><row><cell>B (as is)</cell><cell>8</cell><cell>428</cell><cell>17</cell><cell>39</cell><cell>8</cell><cell>13</cell><cell>10</cell><cell>24</cell><cell>21</cell><cell>568</cell></row><row><cell>B (strongly connected)</cell><cell>7</cell><cell>268</cell><cell>21</cell><cell>32</cell><cell>13</cell><cell>15</cell><cell>14</cell><cell>21</cell><cell>53</cell><cell>444</cell></row><row><cell>C (as is)</cell><cell>7</cell><cell>9</cell><cell>9</cell><cell>11</cell><cell>7</cell><cell>7</cell><cell>9</cell><cell>10</cell><cell>9</cell><cell>78</cell></row><row><cell>C (strongly connected)</cell><cell>7</cell><cell>9</cell><cell>8</cell><cell>11</cell><cell>7</cell><cell>5</cell><cell>9</cell><cell>7</cell><cell>9</cell><cell>72</cell></row></table><note><p>Proceedings of the 18th International Conference on Data Engineering (ICDE'02) 1063-6382/02 $17.00 © 2002 IEEE ¼ ¼ .</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Proceedings of the 18th International Conference on Data Engineering (ICDE'02) 1063-6382/02 $17.00 © 2002 IEEE</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Phil Bernstein, Alon Halevy, Jayant Madhavan, and the members of the Stanford Database Group for discussion and comments that helped strengthen the paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>In this paper we presented a simple structural algorithm based on fixpoint computation that is usable for matching of diverse data structures. We illustrated the applicability of the algorithm to a variety of scenarios. We defined several filtering strategies for pruning the immediate result of the fixpoint computation. We suggested a novel quality metric for evaluating the performance of matching algorithms, and conducted a user study to determine which configuration of the algorithm and filters performs best in chosen schema matching scenarios.</p><p>The similarity flooding algorithm and the filters discussed in the paper are used as operators in the testbed that we implemented. In our testbed, high-level algebraic operations are deployed for manipulating models and mappings using scripts like the one shown in Section 1. The testbed supports schema definitions and instance data available in SQL DDL, XML, OEM, UML, and RDF.</p><p>Additional aspects of our work are covered in the extended technical report <ref type="bibr" target="#b13">[14]</ref>. These aspects include convergence and complexity of the flooding algorithm, a summary of open issues and limitations, architecture and implementation of the testbed, and several detailed examples that illustrate computing schema correspondences using instance data, or finding related elements in a data instance.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Microsoft Repository Version 2 and the Open Information Model</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bergstraesser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sanders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="page" from="71" to="98" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Vision for Management of Complex Models</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pottinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="page" from="55" to="63" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Anatomy of a Large-Scale Hypertextual Web Search Engine</title>
		<author>
			<persName><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Page</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WWW7 Conf. Computer Networks</title>
		<meeting>WWW7 Conf. Computer Networks</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Meaningful Change Detection in Structured Data</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Chawathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD&apos;97</title>
		<meeting>SIGMOD&apos;97</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="26" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Integration of Heterogeneous Databases Without Common Domains Using Queries Based on Textual Similarity</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">W</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD 1998</title>
		<meeting>SIGMOD 1998</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="201" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reconciling Schemas of Disparate Data Sources: A Machine-Learning Approach</title>
		<author>
			<persName><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<ptr target="http://www.w3.org/TR/REC-DOM-Level-1/" />
		<title level="m">XML Document Object Model (DOM), W3C Recommendation</title>
		<imprint>
			<date type="published" when="1998-10">Oct. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Gusfield</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Irving</surname></persName>
		</author>
		<title level="m">The Stable Marriage Problem: Structure and Algorithms</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Post-Genome Informatics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kanehisa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Lassila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Swick</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/REC-rdf-syntax/" />
		<title level="m">Resource Description Framework (RDF) Model and Syntax Specification</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SEMINT: A tool for identifying attribute correspondences in heterogeneous databases using neural networks</title>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Clifton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. on Data &amp; Knowledge Engineering</title>
		<imprint>
			<biblScope unit="page" from="49" to="84" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Matching Theory</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lovàsz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Plummer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Generic Schema Matching with Cupid</title>
		<author>
			<persName><forename type="first">J</forename><surname>Madhavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th VLDB Conf</title>
		<meeting>27th VLDB Conf</meeting>
		<imprint>
			<date type="published" when="2001-09">Sept. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Similarity Flooding: A Versatile Graph Matching Algorithm</title>
		<author>
			<persName><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
		<ptr target="http://dbpubs.stanford.edu/pub/2001-25" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Extended Technical Report</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Schema Mapping as Query Discovery</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hernandez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB 2000</title>
		<meeting>VLDB 2000</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Randomized Algorithms</title>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Object Exchange Across Heterogeneous Information Sources</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>García-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 11th IEEE Int. Conf. on Data Engineering (ICDE)</title>
		<meeting>of the 11th IEEE Int. Conf. on Data Engineering (ICDE)<address><addrLine>Taipe, Taiwan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-03">Mar. 1995</date>
			<biblScope unit="page" from="251" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">On Matching Schemas Automatically</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<idno>MSR-TR-2001-17</idno>
		<ptr target="http://www.research.microsoft.com/pubs/" />
		<imprint>
			<date type="published" when="2001-02">Feb. 2001</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
