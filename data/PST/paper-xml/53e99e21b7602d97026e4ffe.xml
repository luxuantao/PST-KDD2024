<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Highly Flexible Ring Oscillator PUF</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Mingze</forename><surname>Gao</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Electrical and Computer Engineering</orgName>
								<orgName type="department" key="dep2">Institute for Systems Research</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Khai</forename><surname>Lai</surname></persName>
							<email>lai.khai@yahoo.com</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Electrical and Computer Engineering</orgName>
								<orgName type="department" key="dep2">Institute for Systems Research</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gang</forename><surname>Qu</surname></persName>
							<email>gangqu@umd.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Electrical and Computer Engineering</orgName>
								<orgName type="department" key="dep2">Institute for Systems Research</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Highly Flexible Ring Oscillator PUF</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1825A0A157F5BE2215594515F9457BE9</idno>
					<idno type="DOI">10.1145/2593069.2593072</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Physical Unclonable Function (PUF) is one of the most promising hardware features that can be utilized to improve system security. Ring Oscillator (RO) PUF captures the delay difference of a pair or a group of ROs introduced during fabrication process and defines PUF secrecy based on such difference. In this paper, we propose a framework to build RO PUF at inverter level, instead of RO level. This provides us the flexibility in choosing whether an inverter should be included in the RO-PUF and hence improve the security and reliability of RO PUF secrecy and reduce its hardware cost. Experimental results demonstrate that the PUF secrecy generated by our configurable RO PUFs is random (by passing the NIST randomness test) and unique from chip to chip. Our approach is more reliable against voltage and temperature variation than the original RO PUF and is 4X more hardware efficient than the robust 1-out-of-8 RO PUF.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Hardware is playing a more and more important and active role in system security. Physical Unclonable Function (PUF) is a small piece of circuitry embedded in the design that extracts silicon chip's fabrication variation and uses such intrinsic physical feature for security applications. Many types of silicon PUF have been proposed, which include arbiter PUF <ref type="bibr" target="#b0">[1]</ref>, ring oscillator (RO) PUF <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, SRAM PUF <ref type="bibr" target="#b2">[3]</ref>, butterfly PUF <ref type="bibr" target="#b3">[4]</ref>, flip-flop PUF <ref type="bibr" target="#b4">[5]</ref>, buskeeper PUF <ref type="bibr" target="#b5">[6]</ref>, bistable ring PUF <ref type="bibr" target="#b6">[7]</ref>. They have been successfully used for secret key storage, random number generation, chip authentication, intellectual property protection, and anti-counterfeiting.</p><p>In this paper, we consider RO PUF, which generates PUF output bits based on the delay difference between two identically designed ring oscillators. Such delay difference is caused by the manufacture variation, but is very sensitive to voltage and temperature changes and thus may make the PUF output bits unreliable. There are many proposals to improve the reliability, most at expensive hardware cost with redundant ROs <ref type="bibr" target="#b0">[1]</ref>, temperature sensors <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">8]</ref>, or additional circuitry for voltage control <ref type="bibr" target="#b8">[9]</ref> or error correction <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12]</ref>. A more detailed survey of the current state-of-the-art on RO PUF can be found in the section of related work.</p><p>We propose a novel configurable framework to build RO PUF in order to improve its reliability and hardware implementation efficiency. Unlike the current approaches that either use or not use a RO to generate PUF information, we selectively choose whether each inverter will be used in a RO. This flexibility will allow us to maximize the delay difference between the two ROs and thus improve the PUF output's reliability for two reasons. First, at the finer inverter level, we can utilize the detailed delay information about each inverter. Second, the inverter selection will be done as a post-silicon process when we can measure the real delay of each inverter. In addition, for a given reliability threshold, our approach will increase the number of reliable PUF bits generated from a given set of ROs. In other words, it will reduce the hardware cost to produce a desired amount of reliable PUF bits.</p><p>The contributions in this paper can be summarized as follows: <ref type="bibr" target="#b0">(1)</ref> We propose a novel framework to build highly flexible RO PUF at inverter level that can significantly improve PUF reliability. (2) Inspired by the approach in <ref type="bibr" target="#b12">[13]</ref>, we propose a similar method to measure inverter delays. (3) Experimental results indicate that our proposed configurable RO PUF can generate more secure and reliable PUF data than existing RO PUF approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head><p>We focus our short survey on RO PUF design and make a distinction between our approach and the previously studied configurable and reconfigurable PUFs.</p><p>Since the inception of RO PUF, there have been studies on how to improve its reliability. Suh and Devadas suggest the 1out-of-8 scheme where the fastest and slowest ring oscillators are picked from every 8 ring oscillators to generate one bit <ref type="bibr" target="#b0">[1]</ref>. This scheme can limit the PUF output bit flip rate to 0.48% in the presence of temperature and supply voltage variations. However, its hardware utilization is only 25% comparing to the original RO PUF where only two ROs are needed to create one bit. Yin and Qu <ref type="bibr" target="#b1">[2]</ref> propose a temperature-aware cooperative RO PUF that can reach a 80% higher hardware utilization than the 1-out-of-8 scheme. But their approach requires temperature sensors. Vivekraja and Nazhandali <ref type="bibr" target="#b7">[8]</ref> propose to operate the RO PUF at different optimal voltages depending on the temperature, so that the least number of bit flips occur. This approach can achieve 90-100% hardware utilization. It also improves the traditional RO PUF's reliability by 19% for temperature variation and 14% for voltage variation. However, this approach also requires a temperature sensor. Most recently, Mansouri and Dubrova <ref type="bibr" target="#b8">[9]</ref> propose to apply different voltages on different inverters in the same ring oscillator. This approach also requires specialized circuits which can increase the hardware overhead. Another standard approach to ensure reliability is to build extra circuitry to detect and correct the bit flips with error correction coding (ECC) <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b11">12]</ref>.</p><p>The notion of configurability in RO PUF has been introduced by Maiti and Schaumont <ref type="bibr" target="#b13">[14]</ref>. In their approach, at each stage of the RO, there is a multiplexer selecting one out of the two inverters. For 3 stages, this will give 8 possible configurations. The configurations with the largest delay difference will be used to generate the PUF output bits. Their 3-stage configurable RO PUF occupies two Configurable Logic Blocks (CLB) in Xilinx FPGAs; each 3-stage configurable RO occupies a single CLB. Xin et al. <ref type="bibr" target="#b14">[15]</ref> provides an improvement to this idea by increasing the number of possible configurations to 256 and still using the same number of CLBs.</p><p>There are many reported efforts on reconfigurable PUFs. In these approaches, the FPGA configuration bit-stream files are used for the reconfiguration of PUFs. Although these approaches can achieve more challenge-response pairs, they also expose more information and thus are vulnerable to attacks such as modeling and machine learning <ref type="bibr" target="#b15">[16]</ref>. Our configurable RO PUF is completely different from these reconfigurable approaches because in our method, once a RO PUF is configured (by fixing which inverters to be included in the RO) it will remain unchanged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. CONFIGURABLE RO PUF</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Architecture of the Configurable RO</head><p>Fig. <ref type="figure" target="#fig_0">1</ref> depicts the architecture that gives us the flexibility to select inverters for the construction of ROs. A multiplexer will be added after each inverter to control whether the inverter will be included in the RO. This is achieved by the selection bit of the multiplexer. If the selection bit is "1", the corresponding inverter will be included in the RO; if the selection bit is "0", the inverter will not be used and the signal will go through the wire to the next inverter (so the corresponding inverter will not be used in the RO). We use the term configuration vector to refer to the collection of all the multiplexer selection bits. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Inverter Delay Measurement</head><p>Measuring the delay of a single inverter can be difficult as it oscillates very fast. However, our approach does not require a very high accuracy of the measurement because we do not need the actual delay information of each inverter as long as we can tell their relative speed (that is, which one is faster and which one is slower). In addition, the flexibility of selecting inverters in our proposed architecture allows us to measure different combinations of inverters, from which we can calculate, instead of physically measure, the delay of each individual inverter. We would like to mention that this measurement scheme is inspired by the recent work of Majzoobi et al. <ref type="bibr" target="#b12">[13]</ref> where they implement programmable delay lines (PDL) on FPGA and measure their delay accurately to improve PUF's reliability. We define the delay unit we want to measure as shown in Figure <ref type="figure" target="#fig_1">2</ref>. A delay unit consists of one inverter and the following 2-to-1 MUX. As the delay-based PUF is very sensitive to process variation, we consider all the potential variation in this delay unit: due to process variation in the MUX, the delay when the selection bit has value "1" may be different from that when the selection bit has value "0". We refer these as the delays for path "1"and path "0" and denote them by d1 and d0, respectively. In Figure <ref type="figure" target="#fig_1">2</ref>, we can conceptually think these are the delays of two buffers so the MUX will be an ideal 0-delay device regardless of the value of the selection bit. Now, if the selective bit is "1", the total of the delay of this delay unit will be the sum of the inverter d and d1; if the selection bit is "0", the delay of the delay unit will be d0 (we can assume that d1 and d0 include the delays on the two pieces of wires in the case of "1" and "0", respectively). Therefore, the delay difference for a delay unit between the case of "1" and "0" can be expressed as ddiff = d + d1 -d0.</p><p>For the configurable RO as proposed in Figure <ref type="figure" target="#fig_0">1</ref>, we need to measure or compute the delay difference ddiff_i for each delay unit i in the RO. Measuring ddiff for a single delay unit may introduce large error. Instead, we measure the delay of the configurable RO when multiple inverters are selected and then compute the values of the ddiff_i's based on these measurements. Consider for example a configurable RO with 3 stages (or 3 delay units). We can set the configuration vector to "110" to skip the last inverter; then use "101" to skip the middle inverter; and finally use "011" to skip the first inverter. Let X, Y, and Z be the delay in these three cases, then it is easy to see that ddiff_1 = (X+Y-Z)/2, ddiff_2 = (X+Z-Y)/2, and ddiff_3 = (Y+Z-X)/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Design of the Configurable RO PUF</head><p>We deploy the configurable ROs in pairs on chip with n inverters in each RO. After the chip is fabricated and during the chip testing phase, we measure the delay of each inverter as mentioned in the previous section. Next, based on these measurements, we determine the configuration vector for each RO pair to configure them. Each configured RO pair will generate one PUF bit.</p><p>Our goal is to generate PUF output bits that are (1) reliable under different operating environments, (2) random so they will be robust against potential attacks, (3) unique so different chips will unlikely generate the same output bits. The proposed configurable RO PUF has advantages in achieving these goals over the existing RO PUF design approaches.</p><p>First, we configure the ROs after chip is fabricated. This allows us to measure the real delay and use that information to construct ROs. Existing RO PUF just uses whatever variation comes during the fabrication process. Second, we only put selective inverters in the RO, while current RO PUF uses all the inverters. Due to the randomness of the process variation, including all inverters in the RO will not reach the maximal delay difference, making the PUF bit less reliable. Third, when we cannot find a subset of inverters to generate a large delay difference between a pair of ROs, we don't have to use the PUF bit generated from this pair. This can eliminate the cost of ECC circuitry.</p><p>One remaining challenge in the proposed configurable RO PUF is how to find the subset of inverters that can maximize the delay difference between a pair of RO. If there are n inverters in each RO (assuming that n is odd), then there are ൫</p><formula xml:id="formula_0">ଵ ൯ + ൫ ଷ ൯ + ⋯ + ൫ ൯ + ⋯ + ൫</formula><p>൯ possible distinct ways to construct ROs. It will be expensive to evaluate each option, particularly when n is large. In the next subsection, we present our solution to this inverter selection question.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Solving the Inverter Selection Problem</head><p>The inverter selection problem aims to find the configuration vectors for the two ROs (that is, which inverter will be selected to construct the RO) such that their delay difference will be maximized. We assume that both RO will use the same number of inverters once configured. This is for security concern because the one that uses fewer inverters will most likely be faster, making it easier for an attacker to guess the bit value this pair of ROs generates. We consider two different cases: Case-1 is when both ROs use the same configuration vectors; and Case-2 is when they have different configurations.</p><p>For a pair of ROs, we refer to them as the top RO and the bottom RO. Let x1x2…xn and y1y2…yn be their configuration vectors, and αi and ßi be the delay of the i-th inverter in the top RO and bottom RO, respectively. In Case-1, because we require both ROs to have the same configuration ( x ୧ = y ୧ ∀i = 1, … , n), so we need to determine the value for each xi such that</p><formula xml:id="formula_1">arg max ‫ܠ‬ |∑ Δd ୧ ୬ ୧ୀଵ | where Δd ୧ = (α ୧ -β ୧ ) ⋅ x ୧ (1)</formula><p>This can be solved by realizing that the absolute summation will reach its maximum when all of the Δdi terms have the same sign. Let Δ+ be the sum of all the Δdi's with positive values and Δ-be the sum of all the Δdi's with negative values (we can ignore those zero-valued Δdi's). If Δ+ &gt; -Δ-, we select the i th inverter in both ROs whenever Δdi&gt; 0; otherwise, we select the i th inverter in both ROs whenever Δdi &lt; 0. This is clearly the optimal solution for the inverter selection problem.</p><p>In Case-2 when the top RO and the bottom RO do not have to use the same configuration, we need to determine the values for each xi and yi such that</p><formula xml:id="formula_2">arg max ‫ܡ,ܠ‬ |∑ Δd ୧ ୬ ୧ୀଵ | where Δd ୧ = α ୧ ‫ݔ‬ -β ୧ ‫ݕ‬ (2)</formula><p>To solve this, we sort both delay vectors α and ß in the descending order and let α(i) and ß(i) as the i th largest inverter delay value of the top RO and the bottom RO, respectively. Let x(i)=xj where j is the location of the i th slowest inverter in the top RO and y(i)=yj where j is the location of the i th slowest inverter in the bottom RO. Then solving (2) will be equivalent to finding values for each xi and yi such that</p><formula xml:id="formula_3">arg max ‫ܡ,ܠ‬ |∑ Δd ୧ ୬ ୧ୀଵ | (3)</formula><p>where Δd ୧ = α (୧) ⋅ x (୧) -β (୬ି୧ାଵ) ⋅ ‫ݕ‬ (୬ି୧ାଵ)</p><p>Similarly to the solution of Case-1, we can define two sums to keep track the total delay discrepancy based on whether the top RO is faster (Δdi &lt; 0) or the bottom RO is faster (Δdi &gt; 0). The first sum (when the top RO is faster) will stop when the k th fastest inverter in the top RO is not faster than the k th slowest inverter in the bottom RO. The second sum (when the bottom RO is faster) can be computed similarly and like in Case-1, we will construct the RO PUF by selecting the one with the larger magnitude.</p><p>The solutions to the above inverter selection problems will be an n-bit configuration vector for each RO. Due to the unpredictable behavior of manufacture variation, we conjecture that the optimal configuration will have about n/2 inverters selected in the ROs. That is, the configuration vector will have roughly half 1's and half 0's. The intuition behind this is that when the systematic variation is filtered out, the random variation will make inverter delay distribution of the top RO and the bottom RO identical or similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. EXPERIMENTAL RESULTS</head><p>The experiments are conducted based on both our in-house RO PUF delay measurement and the Virginia Tech's public PUF dataset <ref type="bibr" target="#b15">[16]</ref>. We use our in-house data of the delay measurement at inverter level on 9 Xilinx Virtex-5 LX ML501 boards to validate that our proposed configurable RO PUF can generate more reliable PUF bits than the existing RO PUF approaches (section IV.E).</p><p>To demonstrate that the PUF bits generated by our configurable RO PUF meet all the requirements for PUF information, our in-house data are not sufficient. As an alternative, we use the public available dataset in <ref type="bibr" target="#b15">[16]</ref>, which consist of frequency measurements of ROs from 198 Xilinx Spartan (XC3S500E) FPGA boards. This dataset only has the frequency measurements of ROs and not individual inverters. We treat each RO as an inverter in our experimentation due to the lack of public data on delay at inverter level.</p><p>Among the 198 boards, 194 boards have measurements at a fixed supply voltage (1.20V) and a fixed temperature (25°C). We implement our proposed configurable PUF using the dataset of these 194 boards and extract the PUF output to test (A) whether the output information is statistically random, which measures PUF's security; (B) whether the PUF outputs are unique and collisionfree, (C) whether the best configurations of different ROs are random and distinct. In addition, five FPGA boards have measurements taken at varying supply voltages and temperatures. The ranges of supply voltages are 0.98V, 1.08V, 1.20V, 1.32V, and 1.44V. The ranges of temperatures are 35°C, 45°C, 55°C, and 65°C. We use the dataset of these 5 boards to test (D) the reliability of our configurable PUFs under different operating environments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Randomness of Configurable RO PUF's Outputs</head><p>We report the results when each RO consists of 5 inverters, that is n=5. The results for other n values are similar as we will show in section IV.D. Based on the input length requirement (for the purpose of ensuring accuracy) of the NIST statistical test <ref type="bibr" target="#b16">[17]</ref>, we combine the PUF outputs from 2 FPGA boards to generate a 96-bit output. Therefore, the dataset from the 194 FPGAs provide us 97 PUF-response bit-streams, each with 96 bits. These bit-streams are then tested by the NIST statistical test suite for their randomness.</p><p>As expected, the NIST test fails on the bit-streams generated from the raw data. This is known to be caused by the systematic variation <ref type="bibr" target="#b17">[18]</ref>. After we apply the distiller technique in <ref type="bibr" target="#b17">[18]</ref> to filter out the system variation, the new bit-streams successfully pass all the NIST randomness tests.</p><p>Tables <ref type="table">I</ref> and<ref type="table" target="#tab_1">II</ref> give the detailed test results for our Case-1 and Case-2 configurable PUFs, respectively. According to the NIST test, "The minimum pass rate for each statistical test is approximately = 93 for a sample size = 97 binary sequences". We can see that both Case-1 and Case-2 pass the randomness test as shown in the column "PROPORTION". For the "P-VALUE" test, the passing threshold is 0.001 and our bit-steams have scored much higher than this threshold value. <ref type="figure">----------------------------------------------------------------------------</ref>  C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 P-VALUE PROPORTION STATISTICAL TEST ------------------------------------------------------------------------------9 <ref type="bibr" target="#b12">13</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE I. NIST TEST RESULTS OF THE OUTPUTS OF THE CONFIGURABLE PUFS OF CASE-1.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 P-VALUE PROPORTION STATISTICAL TEST</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Uniqueness of RO Configurable PUF's Outputs</head><p>Because PUF output information will be used for many security applications such as device authentication and secret key generation, it is vital to show that different chip will have distinct PUF output. To demonstrate that our configurable PUFs meet this requirement, we compare the pair-wise Hamming distance (HD) on all the 97 96-bit PUF-response bit-streams (see section IV.A above). Fig. <ref type="figure" target="#fig_2">3</ref> is the histogram of the interchip HD of outputs of the configurable PUFs for Case-1 and Case-2, where we see the perfect bell shape. For Case-1, the mean HD is 46.88 bits with a standard deviation of 4.89 bits. For Case-2, these values are 46.79 bits and 4.95 bits, respectively. This, together with the two histograms, show that the PUF outputs are unique and it is very unlikely for two PUFs to generate the same output. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. RO Configuration Information</head><p>We study the information of the best configuration of different ROs, that is, which inverters will be selected, because, if these configurations look alike or have certain pattern, it may leak the PUF output information.</p><p>For each of the 194 FPGA boards, we consider the case that a RO will be constructed from a series of n=15 inverters. Therefore, each FPGA board will have 16 pairs of ROs. For a pair of ROs, recall that xi=1 (or yi=1) if the i-th inverter in the top (or bottom) RO is included and xi=0 (or yi=0) if it is not selected.</p><p>In Case-1, because the top and bottom ROs will have the same configuration, we have xi=yi for i=1, 2, …, 15. So the configuration of each RO-pair is defined by a 15-bit bitstream. Each FPGA board has 16 RO-pairs and we have a total of 194 FPGA boards, this gives us a total of 194*16 = 3104 15bit bit-streams. We compare their pairwise Hamming distance and find that there is no duplicate (see Table <ref type="table" target="#tab_3">III</ref>). Indeed, we see that majority of these bit-streams have Hamming distance 6 or 8. In Case-2, because the configuration of the top RO the bottom RO may be different, the configuration of each RO-pair will be characterized by 2 15-bit bit-streams or a 30-bit bitstream and we will have a total of 194*16 = 3104 30-bit bitstreams. Table <ref type="table" target="#tab_4">IV</ref> gives the distribution of the pairwise Hamming distance between these bit-streams. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Reliability of the PUF Secret</head><p>Now we demonstrate one of the most important and challenging PUF features: the reliability of the PUF secret generated from the proposed configurable PUF. To be more specifically, <ref type="bibr" target="#b0">(1)</ref> what will be the best operating environment to test the chip and configure the RO PUF (2) whether the bits will flip when the operating environment changes</p><p>With the measurements of five FPGA boards taken under different voltage levels and different temperature, we are able to answer these questions empirically. Let us first consider Case-1 when both top and bottom ROs will have the same configuration.</p><p>Fig. <ref type="figure">4</ref> shows the percentage of bit flips under voltage variation for the proposed configurable RO PUFs, the traditional RO PUFs, and the 1-out-of-8 RO PUFs. It consists of 20 subplots (5 rows and 4 columns). Each row represents the data from each of the five FPGA boards. Each column represents the data for the same number of inverters that are available to be included in the ring oscillator (denoted by n). From left to right, we have n=3, 5, 7, and 9.</p><p>In each subplot, there are 7 vertical bars representing the percentage of bit flips for a particular FPGA board (row) with a particular n value (column). The first five bars are the percentages of bit flips for the configurable PUFs. The last two are those for the traditional PUFs and the 1-out-of-8 PUFs. Some bars don't show up (e.g. the last one for the 1-out-of-8 PUFs) because the values of those bars are zero. Now we report how we determine the bit flips. We extract the baseline PUF outputs based on the measurement at a fixed voltage and fixed temperature (1.20V and 25°C in this case) for the traditional and 1-out-of-8 RO PUFs. The total number of bits in the output is reported in Table <ref type="table" target="#tab_5">V</ref>. Then we extract the PUF outputs from measurements at different voltage levels and check whether there is any difference from the baseline outputs at each bit position. The number of bit positions that have one or multiple changes is considered as the total number of bit flips.</p><p>For our configurable RO PUF, because the configuration of the ROs depends on the measurements, we find the best configuration for each possible voltage level, and then test the bit flips with this configuration at other voltage levels. From the first bar to the fifth bar in each subplot, the best configurations are found as voltage goes up from the lowest 0.98V to the highest 1.44V. Note that our method will generate the same number of bits as the traditional RO PUFs.</p><p>We make the following observations from Fig. <ref type="figure">4</ref>: 1. The 6 th bar, the one for traditional PUF, is always the tallest or the most unreliable. The bars corresponding to the configurable PUFs are much shorter, which means much more reliable than the traditional PUFs. 2. The last bar, the one for 1-out-of-8 PUF, has value 0 in all cases, meaning that 1-out-of-8 is a very reliable PUF. However, it suffers with high hardware cost because it can only generate ¼ of the bits that traditional or our configurable PUFs can generate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The reliability of the configurable PUF increases as we</head><p>increase the length of the ROs n starting from 3. In fact, when n=7, we can achieve the 0% bit flip rate on all five boards. This verifies our conjecture that the best configuration will include about half of the available inverters (7 is about one half of 15 in this case).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>The best configuration determined by using the dataset at the middle voltage value often yields the lowest percentage of bit flips. This suggests the best voltage level to configure the ROs. There is little impact of temperature variation on the reliability of the PUF outputs. Only the traditional RO PUF has bit flips. This suggests that the proposed configurable RO PUFs are very reliable against temperature variations.</p><p>Similar observations hold for Case-2 when we allow the top and bottom ROs to be configured differently. The only noticeable difference is that because of this flexibility, the Case-2 configurable PUF becomes more reliable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Reliability with In-House Data and Different Threshold</head><p>In the traditional RO PUF, a threshold Rth is the minimum delay difference between two ROs for a reliable bit to be generated from the pair of ROs. In other words, if the two ROs' delay difference is smaller than Rth, no PUF bit will be defined from this pair to avoid unreliable bit. Clearly, as we increase the value of Rth, the PUF bits will become more and more reliable, but the number of bits the same RO PUF can generate will decrease. This is a well-known tradeoff between PUF's reliability and hardware utilization <ref type="bibr" target="#b1">[2]</ref>.</p><p>We measure the delay information at inverter level on 9 Xilinx Virtex-5 LX ML501 boards, each with 1024 inverters. From these inverters, we construct 64 ROs each with up to 13 inverters. When we set Rth=0, 64/2=32 bits can be generated by the traditional RO PUF. With the threshold goes up, the number of bits goes down. When the threshold Rth=3, the number of reliable bits drops to 13. With our proposed configurable RO PUF, even at Rth=3, we can still define 32 reliable bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION</head><p>In this paper, we propose a novel configurable RO PUF that configures the RO after fabrication, based on the real inverter delay information. Compared to the current RO PUF approaches where the inverters in the RO are all included in the RO, our method has several advantages in generating more PUF bits which are more reliable against operating environment variations. We demonstrate these advantages by experiments on available RO PUF data.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Architecture of the configurable RO.</figDesc><graphic coords="2,52.06,480.08,249.72,66.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. A delay unit of the configurable RO.</figDesc><graphic coords="2,371.50,95.84,146.04,50.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. HD of Configurable PUF Outputs for Case 1 (left) and Case 2 (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II .</head><label>II</label><figDesc></figDesc><table /><note><p>NIST TEST RESULTS OF THE OUTPUTS OF THE CONFIGURABLE PUFS OF CASE-2.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE III .</head><label>III</label><figDesc>INTRA-CHIP HD OF BEST CONFIGURATION OF CASE1.</figDesc><table><row><cell cols="5">(HD: Hamming distance; %: percentage of bit-stream pairs with certain HD)</cell></row><row><cell>HD</cell><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell></row><row><cell>%</cell><cell>0</cell><cell>0.822</cell><cell>9.80</cell><cell>32.8</cell></row><row><cell>HD</cell><cell>8</cell><cell>10</cell><cell>12</cell><cell>14</cell></row><row><cell>%</cell><cell>38.3</cell><cell>16.1</cell><cell>2.15</cell><cell>0.061</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE IV .</head><label>IV</label><figDesc>INTRA-CHIP HD OF BEST CONFIGURATION OF CASE2.</figDesc><table><row><cell cols="6">(HD: Hamming distance; %: percentage of bit-stream pairs with certain HD;</cell></row><row><cell></cell><cell></cell><cell cols="3">~0: percentage less than 0.001%)</cell><cell></cell></row><row><cell>HD</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell>10</cell></row><row><cell>%</cell><cell>~0</cell><cell>0.015</cell><cell>0.213</cell><cell>1.64</cell><cell>6.87</cell></row><row><cell>HD</cell><cell>12</cell><cell>14</cell><cell>16</cell><cell>18</cell><cell>20</cell></row><row><cell>%</cell><cell>17.2</cell><cell>26.3</cell><cell>25.4</cell><cell>15.3</cell><cell>5.68</cell></row><row><cell>HD</cell><cell>22</cell><cell>24</cell><cell>26</cell><cell>28</cell><cell>0 and 30</cell></row><row><cell>%</cell><cell>1.25</cell><cell>0.153</cell><cell>~0</cell><cell>~0</cell><cell>0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE V</head><label>V</label><figDesc></figDesc><table><row><cell></cell><cell cols="3">. TOTAL NUMBER OF BITS PER BOARD</cell><cell></cell></row><row><cell></cell><cell>n=3</cell><cell>n=5</cell><cell>n=7</cell><cell>n=9</cell></row><row><cell>Configurable PUFs</cell><cell>80</cell><cell>48</cell><cell>32</cell><cell>24</cell></row><row><cell>Traditional PUFs</cell><cell>80</cell><cell>48</cell><cell>32</cell><cell>24</cell></row><row><cell>1-out-of-8 PUFs</cell><cell>20</cell><cell>12</cell><cell>8</cell><cell>6</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgement. This work is supported in part by the National Science Foundation of China under grant 61228204 and by a University Partnership with the Laboratory of Telecommunications Sciences contract number H9823013D00560002. The authors would also like to thank Dr. Chi-En Yin and Mr. Jiliang Zhang for their valuable discussion and suggestions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Physical Unclonable Functions for Device Authentication and Secret Key Generateion</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>ACM DAC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Temperature-aware cooperative ring oscillator PUF</title>
		<author>
			<persName><forename type="first">C.-E</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Qu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE International Workshop on Hardware-Oriented Security and Trust</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Power-Up SRAM state as an identifying fingerprint and source of true random numbers</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Holcomb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Burleson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1198" to="1210" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Extended abstract: The butterfly PUF protecting IP on every FPGA</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Guajardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Maes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G.-J</forename><surname>Schrijen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE International Workshop on Hardware-Oriented Security and Trust</title>
		<imprint>
			<biblScope unit="page" from="67" to="70" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Intrinsic PUFs from Flip-flops on reconfigurable devices</title>
		<author>
			<persName><forename type="first">R</forename><surname>Maes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Information and System Security</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><surname>Simons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Van Der Leest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Van Der Sluis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Buskeeper PUFs, a promising alternative to D Flip-Flop PUFs</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Bistable Ring PUF: A new architecture for strong Physical Unclonable Functions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Qingqing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Csaba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Lugli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Schlichtmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Ruhrmair</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE International Workshop on Hardware-Oriented Security and Trust</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Feedback Based Supply Voltage Control for Temperature Variation Tolerant PUFs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vivekraja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Nazhandali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th International Conference on VLSI Design (VLSI Design)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Ring oscillator physical unclonable function with multi level supply voltages</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Mansouri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Dubrova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 30th International Conference on Computer Design (ICCD)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Secure and Robust ErrorCorrection for Physical Unclonable Functions</title>
		<author>
			<persName><forename type="first">M.-D</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>IEEE Design &amp; Test of Computers</publisher>
		</imprint>
	</monogr>
	<note>Verifying Physical Trustworthiness of ICs and Systems</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fuzzy extractors: how to generate strong keys from biometrics and other noisy data</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Reyzin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -Eurocrypt</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Soft decision helper data algorithm for SRAM PUFs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Maes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tuyls</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Verbauwhede</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISIT</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design, Implementation, and Evaluation of Arbiter-based PUF on FPGA using Programmable Delay Lines</title>
		<author>
			<persName><forename type="first">M</forename><surname>Majzoobi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kharaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Koushanfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Transactions on Reconfigurable Technology and Systems</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Improving the quality of a physical unclonable function using configurable ring oscillators</title>
		<author>
			<persName><forename type="first">A</forename><surname>Maiti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schaumont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Field Programmable Logic and Applications -FPL 2009</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A Configurable Ring-Oscillator-Based PUF for Xilinx FPGAs</title>
		<author>
			<persName><forename type="first">X</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Kaps</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Gaj</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>2011 14th Euromicro Conference on Digital System Design</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Research on Physical Unclonble Functions (PUFs) at SES Lab, VT</title>
		<author>
			<persName><forename type="first">A</forename><surname>Maiti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schaumont</surname></persName>
		</author>
		<ptr target="http://rijndael.ece.vt.edu/puf/main.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A statistical test suite for random and pseudorandom number generators for cryptographic applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rukhin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Soto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nechvatal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIST Special</title>
		<imprint>
			<date type="published" when="2010-04">Apr. 2010</date>
		</imprint>
	</monogr>
	<note>Publication 800-22 Revision 1a</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Improving PUF security with regression-based distiller</title>
		<author>
			<persName><forename type="first">C.-E</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Qu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">50th AVM/IEEE Design Automation Conference (DAC)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
