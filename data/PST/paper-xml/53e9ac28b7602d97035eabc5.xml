<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Compiling and Verifying Security Protocols</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Florent</forename><surname>Jacquemard</surname></persName>
							<email>florent.jacquemard@loria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LORIA -INRIA Lorraine Campus Scientifique</orgName>
								<address>
									<postBox>B.P. 239</postBox>
									<postCode>54506</postCode>
									<settlement>Vandoeuvre-lès-Nancy Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Rusinowitch</surname></persName>
							<email>michael.rusinowitch@loria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LORIA -INRIA Lorraine Campus Scientifique</orgName>
								<address>
									<postBox>B.P. 239</postBox>
									<postCode>54506</postCode>
									<settlement>Vandoeuvre-lès-Nancy Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Laurent</forename><surname>Vigneron</surname></persName>
							<email>laurent.vigneron@loria.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">LORIA</orgName>
								<orgName type="institution" key="instit2">Université Nancy</orgName>
							</affiliation>
							<affiliation key="aff2">
								<address>
									<addrLine>Campus Scientifique</addrLine>
									<postBox>B.P. 239</postBox>
									<postCode>54506</postCode>
									<settlement>Vandoeuvre-lès-Nancy Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Compiling and Verifying Security Protocols</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BB667217A70658FA6077E82CED78B87A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose a direct and fully automated translation from standard security protocol descriptions to rewrite rules. This compilation defines non-ambiguous operational semantics for protocols and intruder behavior: they are rewrite systems executed by applying a variant of acnarrowing. The rewrite rules are processed by the theorem-prover daTac. Multiple instances of a protocol can be run simultaneously as well as a model of the intruder (among several possible). The existence of flaws in the protocol is revealed by the derivation of an inconsistency. Our implementation of the compiler CASRUL, together with the prover daTac, permitted us to derive security flaws in many classical cryptographic protocols.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Many verification methods have been applied to the analysis of some particular cryptographic protocols <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b33">34]</ref>. Recently, tools have appeared <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b8">9]</ref> to automatise the tedious and error-prone process of translating protocol descriptions into low-level languages that can be handled by automated verification systems. In this research stream, we propose a concise algorithm for a direct and fully automated translation of any standard description of a protocol, into rewrite rules. For analysis purposes, the description may include security requirements and malicious agent (intruder) abilities. The asset of our compilation is that it defines non-ambiguous operational semantics for protocols (and intruders): they are rewrite rules executed on initial data by applying a variant of narrowing <ref type="bibr" target="#b14">[15]</ref>.</p><p>In a second part of our work, we have processed the obtained rewrite rules by the theorem-prover daTac <ref type="bibr" target="#b32">[33]</ref> based on first order deduction modulo associativity and commutativity axioms (AC). Multiple instances of a protocol can be run simultaneously as well as a model of the intruder (among several possible). The existence of flaws in classical protocols (from <ref type="bibr" target="#b6">[7]</ref>) has been revealed by the derivation of an inconsistency with our tool CASRUL.</p><p>In our semantics, the protocol is modelled by a set of transition rules applied on a multiset of objects representing a global state. The global state contains both sent messages and expected ones, as well as every piece of information collected by the intruder. Counters (incremented by narrowing) are used for dynamic generation of nonces (random numbers) and therefore ensure their freshness. The expected messages are automatically generated from the standard protocol description and describes concisely the actions to be taken by an agent when receiving a message. Hence, there is no need to specify manually these actions with special constructs in the protocol description. The verification that a received message corresponds to what was expected is performed by unification between a sent message and an expected one. When there is a unifier, then a transition rule can be fired: the next message in the protocol is composed and sent, and the next expected one is built too. The message to be sent is composed from the previously received ones by simple projections, decryption, encryption and pairing operations. This is made explicit with our formalism. The information available to an intruder is also floating in the messages pool, and used for constructing faked messages, by ac-narrowing too. The intruder-specific rewrite rules are built by the compiler according to abilities of the intruder (for diverting and sending messages) given with the protocol description.</p><p>It is possible to specify several systems (in the sense of <ref type="bibr" target="#b16">[17]</ref>) running a protocol concurrently. Our compiler generates then a corresponding initial state. Finally, the existence of a security flaw can be detected by the reachability of a specific critical state. One critical state is defined for each security property given in the protocol description by mean of a pattern independent from the protocol.</p><p>We believe that a strong advantage of our method is that it is not ad-hoc: the translation is working without user interaction for a wide class of protocols and therefore does not run the risk to be biased towards the detection of a known flaw. To our knowledge, only two systems share this advantage, namely Casper <ref type="bibr" target="#b16">[17]</ref> and CAPSL <ref type="bibr" target="#b20">[21]</ref>. Therefore, we shall limit our comparison to these works.</p><p>Casper is a compiler from protocol specification to process algebra (CSP). The approach is oriented towards finite-state verification by model-checking with FDR <ref type="bibr" target="#b27">[28]</ref>. We use almost the same syntax as Casper for protocols description. However, our verification techniques, based on theorem proving methods, will handle infinite states models. This permits to relax many of the strong assumptions for bounding information (to get a finite number of states) in model checking. Especially, our counters technique based on narrowing ensures directly that all randomly generated nonces are pairwise different. This guarantees the freshness of information over sessions. Our approach is based on analysing infinite traces by refutational theorem-proving and it captures automatically the traces corresponding to attacks. Note that a recent interesting work by D.Basin <ref type="bibr" target="#b3">[4]</ref> proposes a lazy mechanism for the automated analysis of infinite traces.</p><p>CAPSL <ref type="bibr" target="#b20">[21]</ref> is a specification language for authentication protocols in the flavour of Casper's input. There exists a compiler <ref type="bibr" target="#b8">[9]</ref> from CAPSL to an in-termediate formalism CIL which may be converted to an input for automated verification tools such as Maude, PVS, NRL <ref type="bibr" target="#b19">[20]</ref>. The rewrite rules produced by our compilation is also an intermediate language, which has the advantage to be an idiom understood by many automatic deduction systems. In our case we have a single rule for every protocol message exchange, as opposite to CIL which has two rules. For this reason, we feel that our model is closer to Dolev and Yao original model of protocols <ref type="bibr" target="#b10">[11]</ref> than other rewrite models are.</p><p>As a back-end system, the advantage of daTac over Maude is that ac-unification is built-in. In <ref type="bibr" target="#b7">[8]</ref> it was necessary to program an ad-hoc narrowing algorithm in Maude in order to find flaws in protocols such as Needham-Schroeder Public Key.</p><p>We should also mention the works by C. Meadows <ref type="bibr" target="#b18">[19]</ref> who was the first to apply narrowing to protocol analysis. Her narrowing rules were however restricted to symbolic encryption equations.</p><p>The paper is organised as follows. In Section 1, we describe the syntax for specifying a protocol P to be analysed and to give as input to the translator. Section 2 presents the algorithm implemented in the translator to produce, given P, a set of rewrite rules R(P). This set defines the actions performed by users following the protocol. The intruder won't follow the rules of the protocol, but will rather use various skill to abuse other users. His behaviour is defined by a rewrite system I given in Section 3. The execution of P in presence of an intruder may be simulated by applying narrowing with the rules of R(P) ∪ I on some initial term. Therefore, this defines an operational semantics for security protocols (Section 4). In Section 5, we show how flaws of P can be detected by pattern matching on execution traces, and Section 6 describes the deduction techniques underlying the theorem prover daTac and some experiments performed with this system. For additional informations the interested reader may refer to http://www.loria.fr/equipes/protheo/SOFTWARES/CASRUL/.</p><p>We assume that the reader is familiar with basic notions of cryptography and security protocols (public and symmetric key cryptography, hash functions) <ref type="bibr" target="#b29">[30]</ref>, and of term rewriting <ref type="bibr" target="#b9">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Input Syntax</head><p>We present in this section a precise syntax for the description of security protocols. It is very close to the syntax of CAPSL <ref type="bibr" target="#b20">[21]</ref> or Casper <ref type="bibr" target="#b16">[17]</ref> though it differs on some points -for instance, on those in Casper which concern CSP. The specification of a protocol P comes in seven parts (see Example 1, Figure <ref type="figure" target="#fig_0">1</ref>). Three concern the protocol itself and the others describe an instance of the protocol (for a simulation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Identifiers Declarations</head><p>The identifiers used in the description of a protocol P have to be declared to belong to one of the following types: user (principal name), public key, symmetric key, table, function, number. The type number is an abstraction for any kind of data (numeric, text or record ...) not belonging to one of the other types (user, key etc). An identifier T of type table is a one entry array, which associates public keys to users names (T [D] is a public key of D). Therefore, public keys may be declared alone or by mean of an association table. An identifier F of type function is a one-way (hash) function. This means that one cannot retrieve X from the digest F (X).</p><p>The unary postfix function symbol -1 is used to represent the private key associated to some public key. For instance, in Figure <ref type="figure" target="#fig_0">1</ref>, T [D] -1 is the private key of D.</p><p>Among users, we shall distinguish an intruder I (it is not declared). It has been shown by G. Lowe <ref type="bibr" target="#b17">[18]</ref> that it is equivalent to consider an arbitrary number of intruders which may communicate and one single intruder.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Messages</head><p>The core of the protocol description is a list of lines specifying the rules for sending messages,</p><formula xml:id="formula_0">(i. S i → R i : M i ) 1≤i≤n</formula><p>For each i ≤ n, the components i (step number), S i , R i (users, respectively sender and receiver of the message) and M i (message) are ground terms over a signature defined as follows. The declared identifiers as well as I are nullary function symbols of . The symbols of with arity greater than 0 are -1 , [ ] (for tables access), ( ) (for one-way functions access), , (pairing), { } (encryption). We assume that multiple arguments in , . . . , are right associated. We use the same notation for public key and symmetric key encryption (overloaded operator). Which function is really employed shall be determined unambiguously by the type of the key.</p><p>Example 1. Throughout the paper, we illustrate our method on two toy examples of protocols inspired by <ref type="bibr" target="#b35">[36]</ref> and presented in Figure <ref type="figure" target="#fig_0">1</ref>. These protocols describe messages exchanges in a home cable tv set made of a decoder D and a smartcard C. C is in charge of recording and checking subscription rights to channels of the user. In the first rule of the symmetric key version, the decoder D transmits his name together with an instruction Ins to the smartcard C. The instruction Ins, summarised in a number, may be of the form "(un)subscribe to channel n" or also "check subscription right for channel n". It is encrypted using a symmetric key K known by C and D. The smartcard C executes the instruction Ins and if everything is fine (e.g. the subscription rights are paid for channel n), he acknowledges to D, with a message containing C, D and the instruction Ins encrypted with K. In the public key version, the privates keys of D and C respectively are used for encryption instead of K.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Knowledge</head><p>At the beginning of a protocol execution, each principal needs some initial knowledge to compose his messages.</p><p>The field following knowledge associates to each user a list of terms of T ( ) describing all the data (names, keys, function etc) he knows before the protocol starts. We assume that the own name of every user is always implicitly included in his initial knowledge. The intruder's name I may also figure here. In some cases indeed, the intruder's name is known by other (naïve) principals, who shall start to communicate with him because they ignore his bad intentions.</p><p>Example 2. In Example 1, D needs the name of the smartcard C to start communication. In the symmetric key version, both C and D know the shared key K. In the public key version, they both know the table T . It means that whenever D knows C's name, he can retrieve and use his public key T [C], and conversely. Note that the number Ins is not declared in D's knowledge. This value may indeed vary from one protocol execution to one another, because it is created by D at the beginning of a protocol execution. The identifier Ins is therefore called a fresh number, or nonce (for oNly once), as opposite to persistent identifiers like C, D or K. Definition 1. Identifiers which occur in a knowledge declaration U : . . . (including the user name U ) are called persistent. Other identifiers are called fresh.</p><p>The subset of of fresh identifiers is denoted fresh . The identifier ID ∈ fresh is said to be fresh in M i , if ID occurs in M i and does not occur in any M j for j &lt; i. We denote fresh(M i ) the list of identifiers fresh in M i (occurring in this order). We assume that if there is a public key K ∈ fresh(M i ) then K -1 also occurs in fresh(M i ) (right after K). Fresh identifiers are indeed instantiated by a principal in every protocol session, for use in this session only, and disappear at the end of the session. This is typically the case of nonces. Moreover we assume that the same fresh value cannot be created in two different executions of a protocol. Symmetric keys may either be persistent or fresh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Session Instances</head><p>This field proposes some possible values to be assigned to the persistent identifiers (e.g. tv for D in Figure <ref type="figure" target="#fig_0">1</ref>) and thus describes the different systems (in the sense of Casper <ref type="bibr" target="#b16">[17]</ref>) for running the protocol. The different sessions can take place concurrently or sequentially an arbitrary number of times.</p><p>Example 3. In Figure <ref type="figure" target="#fig_0">1</ref>, the field session instance contains only one trivial declaration, where one value is assigned to each identifier. This means that we want a simulation where only one system is running the protocol (i.e. the number of concurrent sessions is one, and the number of sequential sessions is unbounded).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Intruder</head><p>The intruder field describes which strategies the intruder can use, among passive eaves dropping, divert, impersonate. These strategies are described in Section 3. A blank line here means that we want a simulation of the protocol without intruder.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.6">Intruder Knowledge</head><p>The intruder knowledge is a set of values introduced in session instance, but not a set of identifiers (like knowledge of others principals).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.7">Goal</head><p>This is the kind of flaw we want to detect. There are two families of goals, correspondence between and secrecy of (see Sections 5.4 and 5.3). The secrecy is related to one identifier which must be given in the declaration, and the correspondence is related to two users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Protocol Rules</head><p>We shall give a formal description of the possible executions of a given protocol in the formalism of normalised ac-narrowing. More precisely, we give an algorithm which translates a protocol description P in the above syntax into a set of rewrite rules R(P).</p><p>We assume given a protocol P, described by all the fields defined in Section 1, such that</p><formula xml:id="formula_1">R i = S i+1 for i = 0 . . . n -1</formula><p>This hypothesis is not restrictive since we can add empty messages. For instance, we can replace</p><formula xml:id="formula_2">i. A → B : M i + 1. C → D : M by i. A → B : M i + 1. B → C : ∅ i + 2. C → D : M</formula><p>For technical convenience, we let R 0 = S 1 and assume that S 0 , M 0 are defined and are two arbitrary new constants of .</p><p>As in the model of Dolev and Yao <ref type="bibr" target="#b10">[11]</ref> the translation algorithm associates to each step S i → R i : M i a rewrite rule l i → r i . An additional rule l n+1 → r n+1 is also created. The left member l i describes the tests performed by R i-1 after receiving the message M i-1 -R i-1 compares M i-1 (by unification) with a pattern describing what was expected. The right member r i describes how S i = R i-1 composes and send the next message M i , and what is the pattern of the next message expected. This representation makes explicit most of the actions performed during protocol execution (recording information, checking and composing messages), which are generally hidden in protocol description. How to build the message from the pieces has to be carefully (unambiguously) specified. The expected pattern has also to be described precisely.</p><p>Example 4. In the symmetric key version of the protocol described in Figure <ref type="figure" target="#fig_0">1</ref>, the cipher {Ins} K in last field of message 2 may be composed in two ways: either directly by projection on second field of message 1, or by decryption of this projection (on second field of message 1), and re-encryption of the value Ins obtained, with key K. The first (shortest) case is chosen in our procedure. The pattern expected by C for message 1 is C, x 1 , {x 2 } K , because C does not know D's name in advance, nor the number Ins. The pattern expected by D for message 2 is C, D, {Ins} K , because D wants to check that C has sent the right Ins.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Normalised ac-Narrowing</head><p>Our operational semantics for protocols are based on narrowing <ref type="bibr" target="#b14">[15]</ref>. To be more precise, each step of an execution of the protocol P is simulated by a narrowing step using R(P). We recall that narrowing unifies the left-hand side of a rewrite rule with a target term and replaces it with the corresponding right-hand side, unlike standard rewriting which relies on matching left-hand sides.</p><p>Let T (F , X ) denote the set of terms constructed from a (finite) set F of function symbols and a (countable) set X of variables. The set of ground terms T (F , ∅) is denoted T (F ). In our notations, every variable starts by the letter x. We use u[t] p to denote a term that has t as a subterm at position p. We use u[•] to denote the context in which t occurs in the term u[t] p . By u| p , we denote the subterm of u rooted at position p. A rewrite rule over a set of terms is an ordered pair (l, r) of terms and is written l → r. A rewrite system S is a finite set of such rules. The rewrite relation → S can be extended to rewrite over congruence classes defined by a set of equations AC, rather than terms. These constitute acrewrite systems. In the following the set AC will be {x.(y.z) = (x.y).z, x.y = y.x} where . is a special binary function used for representing multisets of messages. The congruence relation generated by the AC axioms will be denoted = ac . For instance e.h.g = ac g.e.h. A term s ac-rewrites by S to another term t, denoted s → S t, if s| p = ac lσ and t = s[rσ] p , for some rule l → r in S, position p in s, and substitution σ. When s cannot be rewritten by S in any way we say it is a normal form for S. We note s ↓ S t, or t = s ↓ S if there is a finite sequence of rewritings s → S s 1 → S . . . → S t and t is a normal form for S.</p><p>In the following we shall consider two rewrite systems R and S. The role of the system S is to keep the messages normalised (by rewriting), while R is used for narrowing. A term s ac-narrows by R, S to another term t, denoted s R,S t, if i) s is a normal form for S, and ii) s| p σ = ac lσ and t = (s[r] p )σ ↓ S , for some rule l → r in R, position p in s, and substitution σ.</p><formula xml:id="formula_3">Example 5. Assume R = {a(x).c(x) → c(x)} and S = {c(x).c(x) → 0}. Then a(0).b(0).c(x) R,S b(0).c(0).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Messages Algebra</head><p>We shall use for the rewrite systems R and S a sorted signature F containing (among other symbols) all the non-nullary symbols of of Section 1, and a variable set X which contains one variable x t for each term t ∈ T ( ).</p><p>Sorts. The sorts for F are: user, intruder, iuser = user ∪ intruder, public key, private key, symmetric key, table, function, number. Additional sorts are text, a super-sort of all the above sorts, and int, message and list of.</p><p>Signature. All the constants occurring in a declaration session instance are constant symbols of F (with the same sort as the identifier in the declaration). The symbol I is the only constant of sort intruder in F . The pairing function , (profile text × text → text) and encryption functions { } (text × public key → text or text×private key → text or text×symmetric key → text) are the same as in (see Section 1.2), as well as the unary function -1 (public key → private key or private key → public key) for private keys (see Section 1.1), and as the table functions [ ] (table × iuser → public key). We use a unary function symbol nonce( ) : int → number for the fresh numbers, see Section 2.4. We shall use similar unary functions K( ) (int → public key) and SK ( ) (int → symmetric key) for respectively public and symmetric fresh keys.</p><p>At last, the constant 0 (sort int) and unary successor function s( ) (int → int) will be used for integer (time) encoding. Some other constants 1, . . . , k and 0, 1. . . and some alternative successor functions s 1 ( ),. . . ,s k ( ) are also used. The number k is fixed according to the protocol P (see page 140).</p><p>From now on, x t , x pu , x p , x s , x ps , x u , x f are variables of respective sorts table, public key, public key ∪ private key, symmetric key, public key ∪ private key ∪ symmetric key, user, and function. K, SK and KA will be arbitrary terms of T ( ) of resp. sorts public key∪private key, symmetric key and public key ∪ private key ∪ symmetric key.</p><p>Rewrite system for normalisation. In order to specify the actions performed by the principals, F contains some destructors. The decryption function applies to a text encrypted with some key, in order to extract its content. It is denoted the same way as the encryption function { } . Compound messages can be broken into parts using projections π 1 ( ), π 2 ( ). Hence the relations it introduces in the message algebra are:</p><formula xml:id="formula_4">{x} xs xs → x (<label>1</label></formula><formula xml:id="formula_5">)</formula><formula xml:id="formula_6">{x} xpu x -1 pu → x (2) {x} x -1 pu xpu → x (3) x -1 -1 → x (4) π 1 ( x 1 , x 2 ) → x 1 (5) π 2 ( x 1 , x 2 ) → x 2<label>(6)</label></formula><p>The rule (4) does not correspond to a real implementation of the generation of private key from public key. However, it is just a technical convenience. The terminating rewrite system (1) -( <ref type="formula" target="#formula_6">6</ref>) is called S 0 . It can be easily shown that S o is convergent <ref type="bibr" target="#b9">[10]</ref>, hence every message t admits a unique normal form t ↓ S0 for S 0 . We assume from now on that the protocol P is normalised, in the following sense. Definition 2. A protocol P is called normalised if all the message terms in the field messages are in normal form w.r.t. S 0 .</p><p>Note that this hypothesis is not restrictive since any protocol P is equivalent to the normalised protocol P ↓ S0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Operators on Messages</head><p>We define in this section some functions to be called during the construction of the system R(P) in Section 2.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Knowledge decomposition.</head><p>We denote by know (U, i) the information that a user U has memorised at the end of the step S i → R i : M i of the protocol P. This information augments incrementally with i:</p><p>if U is the receiver R i , then he records the received message M i as well as the sender's (official) name S i , -if U is the sender S i , then he records the fresh elements (nonces. . . ) he has created for composing M i (and may use latter),</p><p>in any other case, the knowledge of U remains unchanged.</p><p>The set know (U, i) contains labelled terms V : t ∈ T ( )×T (F , X ). The label t keeps track of the operations to derive V from the knowledge of U at the end of step i, using decryption and projection operators. This term t will be used later for composing new messages.</p><p>The informations are not only memorized but also decomposed with the function CL (7-11) () which is the closure of a set of terms using the following four rules: infer M : {t} t from {M } SK : t and SK : t <ref type="bibr" target="#b6">(7)</ref> infer M : {t} t from {M } K : t and K -1 : t (8) infer M : {t} t from {M } K -1 : t and K : t (</p><p>infer</p><formula xml:id="formula_8">M 1 : π 1 (t) (10) and M 2 : π 2 (t) from M 1 , M 2 : t (<label>11</label></formula><formula xml:id="formula_9">)</formula><p>The function know () is defined by: know (U, 0) = CL (7-11) {T 1 : x T1 , . . . , T k :</p><formula xml:id="formula_10">x T k } where knowledge U : T 1 , . . . , T k is a statement of P. know (U, i + 1) = know (U, i) if U = S i+1 and U = R i+1 know (R i+1 , i + 1) = CL (7-11) (know (U, i) ∪ {M i+1 : x Mi+1 , S i+1 : x Si+1 }) know (S i+1 , i + 1) = CL (7-11) (know (U, i) ∪ {N 1 : x N1 , . . . , N k : x N k })</formula><p>where N 1 , . . . , N k = fresh(M i+1 ) Example 6. In the symmetric-key version of the Cable TV example (Figure <ref type="figure" target="#fig_0">1</ref>), we have Ins :</p><formula xml:id="formula_11">{π 2 (x M )} K ∈ know (C, 1)</formula><p>where M is the first message and x M gets instantiated during the execution of a protocol instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Message composition.</head><p>We define now an operator compose(U, M, i) which returns a receipt of T (F , X ) for the user U for building M from the knowledge gained at the end of step i (hence, U 's knowledge at the begining of step i + 1).</p><p>In that way, we formalise the basic operations performed by a sender when he composes the pieces of the message M i+1 . In rule ( <ref type="formula">16</ref>) below, we assume that M is the k th nonce created in the message</p><formula xml:id="formula_12">M i+1 . compose(U, M, i) = t if M : t ∈ know (U, i) (12) compose U, M 1 , M 2 , i = compose(U, M 1 , i), compose(U, M 2 , i) (13) compose U, {M } KA , i = compose(U, M, i) compose(U,KA,i) (14) compose U, T [A], i = compose(U, T, i)[compose(U, A, i)] (<label>15</label></formula><formula xml:id="formula_13">)</formula><p>compose U, M, i = nonce(s k (x time )) ( <ref type="formula">16</ref>) compose(U, M, i) = Fail in every other case <ref type="bibr" target="#b16">(17)</ref> The cases of the compose() definition are tried in the given order. Other orders are possible, and more studies are necessary to evaluate their influence on the behaviour of our system.</p><p>The construction in case ( <ref type="formula">16</ref>) is similar when M is a fresh public key or a fresh symmetric key, with respective terms K(s k (x time )), and SK (s k (x time )).</p><p>Expected patterns. The term of T (F , X ) returned by the following variant of compose(U, M, i) is a filter used to check received messages by pattern matching. More precisely, the function expect (U, M, i) defined below is called right after the message M i+1 has been sent by U (hence with</p><formula xml:id="formula_14">U = S i+1 = R i ). expect (U, M, i) = t if M : t ∈ know (U, i) (18) expect U, M 1 , M 2 , i = expect (U, M 1 , i), expect(U, M 2 , i) (19) expect U, {M } K , i = expect(U, M, i) compose(U,K -1 ,i) -1 (20) expect U, {M } K -1 , i = expect(U, M, i) compose(U,K,i) -1 (21) expect U, {M } SK , i = expect(U, M, i) compose(U,SK,i) (22) expect U, T [A], i = expect (U, T, i)[expect(U, A, i)] (23) expect (U, M, i) = x U,M,i in every other case (<label>24</label></formula><formula xml:id="formula_15">)</formula><p>Note that unless compose(), the expect() function cannot fail. If the call to compose() fails in one of the cases ( <ref type="formula">20</ref>)-( <ref type="formula">22</ref>), then the case (24) will be applied. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Narrowing Rules for Standard Messages Exchanges</head><p>The global state associated to a step of a protocol instance will be defined as the set of messages m 1 .m 2 . . . . .m n sent and not yet read, union the set of expected messages w 1 . . . . .w m . A sent message is denoted by m(i, s , s, r, t, c) where i is the protocol step when it is sent, s is the real sender, s is the official sender, r is the receiver, t is the body of the message and c is a session counter (incremented at the end of each session).</p><formula xml:id="formula_16">m : step × iuser × iuser × iuser × text × int → message</formula><p>Note that s and s may differ since messages can be impersonated (the receiver r never knows the identity of the real sender s ).</p><p>A message expected by a principal is signalled by a term w(i, s, r, t, ) with similar meaning for the fields i, s, r, t, and c, and where is a list containing r's knowledge just before step i.</p><formula xml:id="formula_17">w : step × iuser × user × text × list of text × int → message</formula><p>Nonces and freshness. We describe now a mechanism for the construction of fresh terms, in particular of nonces. This is an important aspect of our method. Indeed, it ensures freshness of the randomly generated nonces or keys over several executions of a protocol. The idea is the following: nonces admit as argument a counter that is incremented at each transition (this argument is therefore the age of the nonce). Hence if two nonces are emitted at different steps in an execution trace, their counters do not match. We introduce another term in the global state for representing the counter, with the new unary head symbol h. Each rewrite rule l → r is extended to h(s(x time )).l → h(x time ).r in order to update the counter. Note that the variable x time occurs in the argument of nonce() in case <ref type="bibr" target="#b15">(16)</ref> of the definition of compose().</p><p>Rules. The rules set R(P) generated by our algorithm contains (for i = 0..n):</p><formula xml:id="formula_18">h(s(x time )). w i, x Si , x Ri , x Mi , know (R i , i), xc . m(i, x r , x Si , x Ri , x Mi , c) → h(x time ). m i + 1, x Ri , x Ri , compose(R i , R i+1 , i), compose(R i , M i+1 , i), c . w k i , compose(R i , S ki , i), x Ri , expect(R i , M ki , i ), know (R i , i ), c</formula><p>where k i is the next step when R i expects a message (see definition below), and know (R i , i), know (R i , i ) are lists of variables described below.</p><p>If i = 0, the term m(i, . . .) is missing in left member, and c = xc. If 1 ≤ i ≤ n, then c = xc (another variable).</p><p>If i = n, the term m(i, . . .) is missing in right member.</p><p>In every case (0</p><formula xml:id="formula_19">≤ i ≤ n), if k i &gt; i then i = i + 1 and c = xc, if k i ≤ i then i = 0 and c = s(xc).</formula><p>Note that the calls of compose() may return Fail. In this case, the construction of R(P) stops with failure. After receiving message i (of content x Mi ) from x r (apparently from x Si ), x Ri checks whether he received what he was expecting (by unification of the two instances of x Mi ), and then composes and sends message i + 1. The term returned by compose(R i , M i+1 , i) contains some variables in the list know (R i , i). As soon as he is sending the message i + 1, x Ri gets into a state where he is waiting for new messages. This will be expressed by deleting the term w(i, . . .) (previously expected message) and generating the term w(k i , . . .) in the righthand side (next expected message). Hence sending and receiving messages is not synchronous (see e.g. <ref type="bibr" target="#b4">[5]</ref>).</p><p>The function know (U, i) associates to a user U and a (step) number i ∈ {0..n} a term corresponding to a list of variables, used to refer to the knowledge of U . Below, :: a denotes the appending of the element a at the end of a list . know (U, 0) = x U , x T1 , . . . , x Tn where knowledge U : T 1 , . . . , T n is a statement of P, know (U, i + 1) = know (U, i) if U = R i = know (U, i) :: x Mi :: x Si :: n 1 :: . . . ::</p><formula xml:id="formula_20">n k if U = R i where fresh(M i ) = N 1 , . . . , N k and n i = x Ni if N i is of sort nonce or symmetric key,<label>and</label></formula><formula xml:id="formula_21">n i = x Ni :: x N -1 i if N i is of sort public key,</formula><p>The algorithm also uses the integer k i which is the next session step when R i expects a message. If R i is not supposed to receive another message in the current session then either he is the session initiator S 1 and k i is reinitialized to 0, otherwise k i is the first step in the next session where he should receive a message (and then k i &lt; i). Formally, k i is defined for i = 0 to n as follows:</p><formula xml:id="formula_22">k i = min{j j &gt; i and R j = R i } if this set is not empty; otherwise k i = min{j j ≤ i and R j = R i } (recall that R 0 = S 1 by hypothesis);</formula><p>Example 8. In both protocols presented in Figure <ref type="figure" target="#fig_0">1</ref>, one has R 0 = D, R 1 = C, R 2 = D, and therefore:</p><formula xml:id="formula_23">k 0 = 2, k 1 = 1, k 2 = 0.</formula><p>Lemma 1. k is a bijection from {0, . . . , n} to {0, . . . , n}.</p><p>Example 9. The translator generates the following R(P) for the symmetric key version of the protocol of Figure <ref type="figure" target="#fig_0">1</ref>. For sake of readability, in this example and the following ones, the fresh variables are denoted x i (where i is an integer) instead of the form of the case <ref type="bibr" target="#b23">(24)</ref> in the definition of expect ().</p><formula xml:id="formula_24">h(s(x time )).w 0, x S0 , x D , x M0 , x D , x C , x K , xc → h(x time ).m 1, x D , x D , x C , x D , {nonce(s 1 (x time ))} xK , xc . w 2, x C , x D , x C , x D , {nonce(s 1 (x time ))} xK , x D , x C , x K , x M0 , x S0 , nonce(s 1 (x time )) , xc (tvs 1 ) h(s(x time )).w 1, x D , x C , x M1 , x C , x K , xc . m 1, x r , x D , x C , x M1 , xc → h(x time ).m 2, x C , x C , π 1 (x M1 ), x C , π 1 (x M1 ), π 2 (x M1 ) , xc . w 1, x D , x C , x D , {x 1 } xK , x C , x K , s(xc) (tvs 2 ) h(s(x time )).w 2, x C , x D , x M2 , x D , x C , x K , x M0 , x S0 , x Ins , xc . m 2, x r , x C , x D , x M2 , xc → h(x time ).w 0, x S0 , x D , x M0 , x D , x C , x K , s(xc) (tvs 3 )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Intruder Rules</head><p>The main difference between the behaviour of a honest principal and the intruder I is that the latter is not forced to follow the protocol, but can send messages arbitrarily. Therefore, there will be no w() terms for I. In order to build messages, the intruder stores some information in the global state with terms of the form i(), where i is a new unary function symbol. The rewriting rules corresponding to the various intruder's techniques are detailed below.</p><p>The intruder can record the information aimed at him, <ref type="bibr" target="#b24">(25)</ref>. If divert is selected in the field intruder, the message is removed from the current state ( <ref type="formula">26</ref>), but not if eaves dropping is selected <ref type="bibr" target="#b26">(27)</ref>.</p><formula xml:id="formula_25">m(x i , x u , x u , I, x, xc) → i(x).i(x u ) (25) m(x i , x u , x u , x u , x, xc) → i(x).i(x u ).i(x u ) (26) m(x i , x u , x u , x u , x, xc) → m(x i , x u , x u , x u , x, xc).i(x).i(x u ).i(x u ) (<label>27</label></formula><formula xml:id="formula_26">)</formula><p>After collecting information, I can decompose it into smaller i() terms. Note that the information which is decomposed (e.g. x 1 , x 2 ) is not lost during the operation.</p><formula xml:id="formula_27">i x 1 , x 2 → i x 1 , x 2 .i(x 1 ).i(x 2 ) (<label>28</label></formula><formula xml:id="formula_28">)</formula><formula xml:id="formula_29">i {x 1 } xp .i x -1 p → i {x 1 } xp .i x -1 p .i(x 1 ) (29) i {x 1 } xs .i x s → i {x 1 } xs .i x s .i(x 1 ) (30) i {x 1 } x -1 p .i x p → i {x 1 } x -1 p .i x p .i(x 1 )<label>(31)</label></formula><p>I is then able to reconstruct terms as he wishes.</p><formula xml:id="formula_30">i(x 1 ).i(x 2 ) → i(x 1 ).i(x 2 ).i x 1 , x 2<label>(32)</label></formula><p>i(x 1 ).i(x ps ) → i(x 1 ).i(x ps ).i {x 1 } xps <ref type="bibr" target="#b32">(33)</ref> i(x f ).i(x) → i(x f ).i(x).i x f (x) (34)</p><formula xml:id="formula_31">i(x t ).i(x u ) → i(x t ).i(x u ).i x t [x u ] (<label>35</label></formula><formula xml:id="formula_32">)</formula><p>I can send arbitrary messages in his own name,</p><formula xml:id="formula_33">i(x).i(x u ) → i(x).i(x u ).m(j, I, I, x u , x, 0) j ≤ n (36)</formula><p>If moreover impersonate is selected, then I can fake others identity in sent messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i(x).i(x u ).i(x u ) → i(x).i(x u ).i(x u</head><p>).m(j, I, x u , x u , x, 0) j ≤ n (37) Note that the above intruder rules are independent from the protocol P in consideration. The rewrite system of the intruder ( <ref type="formula">25</ref>)-( <ref type="formula" target="#formula_37">37</ref>) is denoted I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Operational Semantics</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Initial State</head><p>After the definition of rules of R(P) and I, the presentation of an operational "state/transition" semantics of protocol executions is completed here by the definition of an initial state t init (P). This state is a term of the form w(. . .) containing the patterns of the first messages expected by the principals, and their initial knowledge, for every session instance. We add to the initial state term a set of initial knowledge for the intruder I. More precisely, we let t init (P) := t init (P).i(v 1 ). Executions in the presence of an intruder are the ones in EXEC i (P) := EXEC t init (P), R(P) ∪ I, S 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Executability</head><p>The following Theorem 1 states that if the construction of R(P) does not fail, then normal executions will not fail (the protocol can always run and restart without deadlock).</p><p>Theorem 1. If P is normalised, the field session instance of P contains only one declaration, and the construction of R(P) does not fail on P, then every derivation in EXEC n (P) is infinite.</p><p>Theorem 1 is not true if the field session instance of P contains at least two declarations, as explained in the next section. Concurrent executions may interfere and enter a deadlock state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Approximations for Intruder Rules</head><p>Due to the intruder rules of Section 3 the search space is too large. In particular, the application of rules ( <ref type="formula" target="#formula_30">32</ref>)-( <ref type="formula">33</ref>) is obviously non-terminating. In our experiences, we have used restricted intruder rules for message generation.</p><p>Intruder rules guided by expected messages. The first idea is to change rules ( <ref type="formula" target="#formula_36">36</ref>)-(37) so that I sends a faked message m(i, I, x u , x u , x) only if there exists a term of the form w(i, x u , x u , x, x , xc) in the global state. More precisely, we replace ( <ref type="formula" target="#formula_36">36</ref>), (37) in I by, respectively, i(x).i(x u ).w(j, I, x u , x, x , xc) → i(x).i(x u ).w(j, I, x u , x, x , xc).m(j, I, I, x u , x, 0) w h e r ej ≤ n (36 ) i(x).i(x u ).i(x u ).w(j, x u , x u , x, x , xc) → i(x).i(x u ).i(x u ).w(j, x u , x u , x, x , xc).m(j, I, x u , x u , x, 0) where j ≤ n (37 )</p><p>The obtained rewrite system is called I w . This approximation is complete: every attack in EXEC i (P) exists also in the trace generated by the modified system, indeed, the messages in a trace of EXEC i (P) and not in EXEC (t init (P), R(P) ∪ I w , S 0 ) would be rejected by the receiver as non-expected or ill-formed messages. Similar observations are reported independantly in <ref type="bibr" target="#b31">[32]</ref>. Therefore, there is no limitation for detecting attacks with this simplification (this strategy prunes only useless branches) but it is still inefficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rules guided approximation.</head><p>The above strategy is improved by deleting rules ( <ref type="formula" target="#formula_30">32</ref>)- <ref type="bibr" target="#b34">(35)</ref> and replacing each rules of (36'), (37') new rules (several for each protocol message), such that a sent message has the form m(i, I, x u , x u , t, 0), where, roughly speaking, t follows the pattern M i where missing parts are filled with some knowledge of I. Formally, we define a non-deterministic unary operator * : T ( ) → T (F , X ).</p><formula xml:id="formula_34">M 1 , M 2 * = M * 1 , M * 2 (38) {M } * K = {M * } K * x {M}K (39) F (M ) * = x F (M * ) x F (M)<label>(40)</label></formula><formula xml:id="formula_35">T [A] * = x T [x A ] x T [A] (41) ID * = x ID if ID is a nullary function symbol of<label>(42)</label></formula><p>Given T ∈ T ( ) we denote skel (T ) the set of possible terms for T * . Then, we replace ( <ref type="formula" target="#formula_36">36</ref>), (37 ) in I by, for each j ∈ 1..n, for each t ∈ skel (M j ), for each distinct identifier A of sort user, let {x 1 , . . . , x m } = Var (t) ∪ {x A , x Si , x Ri } (no variable occurrence more than once in the sequence x 1 , . . . , x m ):</p><formula xml:id="formula_36">i(x 1 ). . . . .i(x m ).w(i, x Si , x Ri , x, x , xc) → i(x 1 ). . . . .i(x m ).w(i, x Si , x Ri , x, x , xc).m(i, I, I, x A , t, 0)<label>( 36 )</label></formula><p>and, if impersonate is selected in the field intruder of P, by: for each i ∈ 1..n, for each t ∈ skel (M i ), for each distinct identifiers A, B of sort user, let {x 1 , . . . ,</p><formula xml:id="formula_37">x m } = Var (t) ∪ {x A , x B , x Si , x Ri }: i(x 1 ). . . . .i(x m ).w(i, x Si , x Ri , x, x , xc) → i(x 1 ). . . . .i(x m ).w(i, x Si , x Ri , x, x , xc).m(i, I, x A , x B , t, 0)<label>(37 )</label></formula><p>Because of deletion of rules ( <ref type="formula" target="#formula_30">32</ref>)-( <ref type="formula" target="#formula_31">35</ref>), one rule for public key decryption with tables needs to be added:</p><formula xml:id="formula_38">i {x 1 } xt[xu] -1 .i x t .i x u → i {x 1 } xt[xu] -1 .i x p .i x u .i(x 1 )<label>(43)</label></formula><p>The obtained system depends on P. Note that this approximation is not complete. However, it seems to give reasonable results in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Flaws</head><p>In our state/transition model, a flaw will be detected when the protocol execution reaches some critical state. We define a critical state as a pattern t goal (P) ∈ T (F , X ), which is constructed automatically from the protocol P. The existence of a flaw is reducible to the following reachability problem, where a can be either i or n: ∃t 0 , . . . , t goal (P)σ ∈ EXEC a (P) for some substitution σ</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Design Flaws</head><p>It may happen that the protocol fails to reach its goals even without intruder, i.e. only in presence of honest agents following the protocol carefully. In particular, it may be the case that there is an interference between several concurrent runs of the same protocol: confusion between a message m(i, . . .) from the first run and another m(i, . . .) from the second one. An example of this situation is given in Appendix A. The critical state in this case is: (recall that xc and xc correspond to session counters)</p><formula xml:id="formula_39">t goal (P) := w(i, x s , x r , x m , x l , xc).m(i, x s , x s , x r , x m , xc ).[xc = xc ]</formula><p>where [xc = xc ] is a constraint that can be checked either by extra rewrite rules or by an internal mechanism as in daTac.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Attacks, Generalities</head><p>Following the classification of Woo and Lam <ref type="bibr" target="#b35">[36]</ref>, we consider two basic security properties for authentication protocols: secrecy and correspondence. Secrecy means that some secret information (e.g. a key) exchanged during the protocol is kept secret. Correspondence means that every principal was really involved in the protocol execution, i.e. that mutual authentication is ensured. The failure of one of these properties in presence of an intruder is called a flaw.</p><p>Example 11. The following scenario is a correspondence attack for the symmetric key version of the cable tv toy example in Figure <ref type="figure" target="#fig_0">1</ref>:</p><formula xml:id="formula_40">1. D → I(C) : D, {Ins} K 2. I(C) → D : C, D, {Ins} K</formula><p>The auxiliary unary function symbol f ( ) scrapes off the s(. . .) context in the values of session counters, using the following rewrite rule (added to S 0 ):</p><formula xml:id="formula_41">f (s(x)) → f (x)<label>(44)</label></formula><p>The storage in secret ( , ) is performed in the rewrite rule for constructing the message M i+1 where N appears for the first time. More precisely, there is a special construction in the rewrite rule for building M i+1 .The binding to the secret N is a side effect of the recursive call of the form compose(U, N, i). The i th rule constructed by our algorithm (page 142) will be in this case:</p><formula xml:id="formula_42">   h(s(x time )). w(i, x Si , x Ri , x Mi , know(R i , i), xc). m(i, x r , x Si , x Ri , x Mi , xc )    →        h(x time ). m(i + 1, x Ri , x Ri , compose(R i , R i+1 , i), compose(R i , M i+1 , i), xc ). w(k i , compose(R i , S ki , i), x Ri , expect(R i , M ki , i ), i , c ). secret(t, f (xc ))        Example 12.</formula><p>The rules generated for the protocol of Figure <ref type="figure" target="#fig_0">1</ref>, public key version, are:</p><formula xml:id="formula_43">h(s(x time )).w 0, x S0 , x D , x M0 , x D , x C , x T , x T [D] -1 , xc → h(x time ).m 1, x D , x D , x C , x D , {nonce(s 1 (x time ))} x T [D]-1 , xc . w 2, x C , x D , x C , x D , {nonce(s 1 (x time ))} x1 , x D , x C , x T , x T [D] -1 , x M0 , x S0 , nonce(s 1 (x time )) , xc secret (nonce(s 1 (x time )), f(xc)) (tvp 1 ) h(s(x time )).w 1, x D , x C , x M1 , x C , x T , x T [C] -1 , xc . m 1, x r , x D , x C , x M1 , xc → h(x time ).m 2, x C , x D , π 1 (x M1 ), x C , π 1 (x M1 ), π 2 (x M1 ) , xc . w 1, x 1 , x U1 , x 1 , {x 2 } xK , x C , x T , x T [C] -1 , s(xc) (tvp 2 ) h(s(x time )).w 2, x C , x D , x M2 , x D , x C , x T , x T [D] -1 , x M0 , x S0 , x Ins , xc . m 2, x r , x C , x D , x M2 , xc → h(x time ).w 0, x S0 , x D , x M0 , x D , x C , x T , x T [D] -1 , s(xc) (tvp 3 )</formula><p>Note the term secret (nonce(s 1 (x time )), xc) in rule (tvp 1 ). As described in Example 11, it is easy to see that this protocol has a secrecy flaw. A subterm secret (nonce(x), 1).i(nonce(x)) is obtained in 4 steps, see appendix C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Correspondence Attack</head><p>The correspondence property between two users U and V means that when U terminates its part of a session c of the protocol (and starts next session s(c)), then V must have started his own part, and reciprocally. In Definition 6, we use the notation first S (U ) = min{i S i = U }, assuming min(∅) = 0. Definition 6. An execution t 0 , . . . ∈ EXEC i (P) satisfies the correspondence property between the (distinct) users U and V iff for each j, t j does not contain a subterm matching: w(first S (U ) -1, x s , u, x t , x , s(x c )).w(first S (V ) -1, x s , x r , x t , x , x c ) or w(first S (V ) -1, x s , v, x t , x , s(x c )).w(first S (U ) -1, x s , x r , x t , x , x c ), where U : u and V : v occur in the same line of the field session instance.</p><p>The critical state t goal (P) is therefore any of the two above terms in Definition 6. Again, these terms are independent from P.</p><p>Example 13. A critical state for the protocol in Figure <ref type="figure" target="#fig_0">1</ref>, symmetric key version, is: t goal (P) := w(0, x 1 , tv, x M1 , x l1 , xc).w(1, x 2 , scard, x M2 , x l2 , s(xc))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Key Compromising Attack</head><p>A classical goal of cryptographic protocols is the exchange between two users A and B of new keys -symmetric or public keys. In such a scenario, A may propose to B a new shared symmetric key K or B may ask a trusted server for A's public key K, see Section 5.6 below for this particular second case. In this setting, a technique of attack for the intruder is to introduce a compromised key K : I has built some key K and he let B think that K is the key proposed by A or that this is A's public key for instance (see Example 14 for a key compromising attack). The compromising of K may be obtained by exploiting for instance a type flaw as described below. Such an attack is not properly speaking a secrecy attack. However, it can of course be exploited if later on B wants to exchange some secret with A using K (actually the compromised K ).</p><p>Therefore, a key compromising attack is defined as a secrecy attack for an extended protocol P obtained from a protocol P of the above category as follows:</p><p>1. declare a new identifier X : number; 2. add a rule: n + 1. B → A : {X} K where n is the number of messages in P and K is the key to compromise, 3. add the declaration goal : secrecy of X;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Binding Attack</head><p>This is a particular case of key compromising attack, and therefore a particular case of secrecy attack, see Section 5.5. It can occur in protocols where the public keys are distributed by a trusted server (who knows a table K of public keys) because the principals do not know in advance the public keys of others. In some case, the intruder I can do appropriate diverting in order to let some principal learn a fake binding name -public key. For instance, I makes some principal B believe that I's public key K[I] is the public key of a third party A (binding A-K <ref type="bibr">[I]</ref>). This is what can happen with the protocol SLICE/AS, see <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Type Flaw</head><p>This flaw occurs when a principal can accept a term of the wrong type. For instance, he may accept a pair of numbers instead of a new symmetric key, when numbers, pair of numbers and symmetric keys are assumed to have the same type. Therefore, a type flaw refers more to implementation hypotheses than to the protocol itself. Such a flaw may be the cause of one of the above attack, but its detection requires a modification of the sort system of F . The idea it to collapse some sorts, by introducing new sorts equalities. For instance, one may have the equality symmetric key = text = number. By definition of profiles of { } and , , ciphers and pairs are in this case numbers, and be accepted as symmetric key.</p><p>Example 14. A known key compromising attack on Otway-Rees protocol, see <ref type="bibr" target="#b6">[7]</ref>, exploits a type flaw of this protocol. We present here the extended version of Otway-Rees, see Section 5. The symmetric keys K as and K bs are supposed to be only known by A and S, resp. B and S. The identifiers M , N a , and N b re nonces. The new symmetric K ab is generated by the trusted server S and transmitted to B and indirectly to A, by mean of the cipher {N a , K ab } Kas .</p><p>If the sorts numbers, text, and symmetric key are assumed to collapse, then we have the following scenario:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.</head><p>A → I(B) : M, A, B, {N a , M, A, B}K as 4. I(B) → A : M, {N a , M, A, B}K as 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A → I(B) : {X} M,A,B</head><p>In rule 1, I diverts (and memorises) A's message. In next step 4, I impersonates B and makes him think that the triple M, A, B is the new shared symmetric key K ab . We recall that , is right associative and thereafter N a , M, A, B can be considered as identical to N a , M, A, B</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Verification: Deduction Techniques and Experiments</head><p>We have implemented the construction of R(P) in OCaml r and performed experiments using the theorem prover daTac <ref type="bibr" target="#b32">[33]</ref> with paramodulation modulo AC. Each rule l → r ∈ R(P) is represented as an oriented equation l = r, the initial state is represented as a unit positive clause P t init (P) and the critical state as a unit negative clause ¬P t goal (P) .</p><p>As for multiset rewriting <ref type="bibr" target="#b7">[8]</ref>, an ac-operator will take care of concurrency. On the other hand unification will take care of communication in an elegant way.</p><p>The deduction system combines paramodulation steps with equational rewriting by S 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Deduction Techniques. Generalities</head><p>The main deduction technique consists in replacing a term by an equal one in a clause: given a clause l = r ∨ C and clause C[l ], the clause (C ∨ C[r])σ is deduced, where σ is a unifier of l and l , that is a mapping from variables to terms such that lσ is equal to l σ. This deduction rule is called paramodulation. It has been introduced by Robinson and Wos <ref type="bibr" target="#b26">[27]</ref>. Paramodulation (together with resolution and factoring) was proved refutationally complete by <ref type="bibr">Brand [6]</ref> who also shown that applying a replacement in a variable position is useless.</p><p>For reducing the number of potential deduction steps, the paramodulation rule has been restricted by an ordering, to guarantee it replaces big terms by smaller ones. This notion of ordered paramodulation has been applied to the Knuth-Bendix completion procedure <ref type="bibr" target="#b15">[16]</ref> for avoiding failure in some situations (see <ref type="bibr" target="#b13">[14]</ref> and <ref type="bibr" target="#b1">[2]</ref>). A lot of work has been devoted to putting more restrictions on paramodulation in order to limit combinatorial explosion <ref type="bibr" target="#b22">[23]</ref>.</p><p>In particular paramodulation is often inefficient with axioms such as associativity and commutativity since these axioms allow for many successful unifications between their subterms and subterms in other clauses. Typically word problems in finitely presented commutative semigroups cannot be decided by standard paramodulation. This gets possible by building the associativity and commutativity in the paramodulation rule using the so-called paramodulation modulo AC and rewriting modulo AC rules.</p><p>The integration of associativity and commutativity axioms within theoremproving systems has been first investigated by Plotkin <ref type="bibr" target="#b25">[26]</ref> and Slagle <ref type="bibr" target="#b30">[31]</ref>. Rusinowitch and Vigneron <ref type="bibr" target="#b28">[29]</ref> have built-in this theory in a way that is compatible with the ordered paramodulation strategy and rewriting and preserves refutational completeness. These techniques are implemented in the daTac system <ref type="bibr" target="#b32">[33]</ref>.</p><p>Another approach has been followed by Wertz <ref type="bibr" target="#b34">[35]</ref> and Bachmair and Ganzinger <ref type="bibr" target="#b2">[3]</ref>, consisting of using the idea of extended clauses developed for the equational case by Peterson and Stickel <ref type="bibr" target="#b24">[25]</ref>.</p><p>In all the approaches, the standard unification calculus has to be replaced by unification modulo associativity and commutativity. This may be very costly since some unification problems have doubly exponentially many minimal solutions <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Deduction Rules for Protocol Verification</head><p>We present here the version of paramodulation we have applied for simulating and verifying protocols. States are built with the specific ac-operator "." for representing the multiset of information components: sent and expected messages, and the knowledge of the intruder.</p><p>The definition of our instance of the paramodulation rule is the following.</p><p>Definition 7 (Paramodulation). l = r P(l ) P (r.z)σ if σ is an ac-unifier of l.z and l , and z is a new variable.</p><p>This rule is much simpler than the general one in <ref type="bibr" target="#b28">[29]</ref>. We only need to apply replacements at the top of the term. In addition the equations are such that the left-hand side is greater than the right-hand side and each clause is unit. So we do not need any strategy for orienting the equations or selecting a literal in a clause.</p><p>In the verification of protocols, we encounter only simple unification problems. They reduce to unifying multisets of standard terms, where one of the multisets has no variable as argument of ".". Only one argument of the other multiset is a variable. Hence for handling these problems we have designed a unification algorithm which is more efficient than the standard ac-unification algorithm of daTac.</p><p>Let us illustrate this with an example.</p><p>Example 15. For performing a paramodulation step from f (x 1 ).g(a) = c into P (a.g(x 2 ).f (b).h(x 3 )), trying to unify f (x 1 ).g(a) and a.g(x 2 ).f (b).h(x 3 ) will not succeed. We have to add a new variable in the left-hand side of the equation for capturing the additional arguments of the ac-operator. The unification problem we have to solve is f (x 1 ).g(a).z = ? ac a.g(x 2 ).f (b).h(x 3 ). Its unique solution σ is {x 1 → b, x 2 → a, z → a.h(x 3 )}. The deduced clause is P (c.z)σ, that is P (c.a.h(x 3 )).</p><p>The paramodulation rule is used for generating new clauses. We need a rule for detecting a contradiction with the clause representing the goal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (Contradiction). P (t) ¬P (t )</head><p>¾ if σ is an ac-unifier of t and t .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Results</head><p>The approach has been experimented with several protocols described in <ref type="bibr" target="#b6">[7]</ref>. We have been able to find the known flaws with this uniform method in several protocols, in less than 1 minute (including compilation) in every case, see Figure <ref type="figure">2</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have presented a complete, compliant translator from security protocols to rewrite rules and how it is used for the detection of flaws. The advantages of our system are that the automatic translation covers a large class of protocols and that the narrowing execution mechanism permits to handle several aspects like timeliness. A drawback of our approach is that the produced rewrite system can be complex and therefore flaw detection gets time-consuming. However, simplifications should be possible to shorten derivations. For instance, composition and reduction with rules S 0 may be performed in one step. The translation can be directly extended for handling key systems satisfying algebraic laws such as commutativity (cf. RSA). It can be extended to other kinds of flaws: binding, typing... We plan to analyse E-commerce protocols where our management of freshness should prove to be very useful since fresh data are ubiquitous in electronic forms (order and payment e.g.). We plan to develop a</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Cable TV toy examples</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 7 .</head><label>7</label><figDesc>The pattern expected by C for message 1 (Figure1, symmetric key version) is expect(C, D, {Ins} K , 1) = x C,D,1 , {x C,Ins,1 } xK because C does not know D's name in advance, nor the number Ins, but he knows K.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>. .i(v n ) if the field intruder knowledge: v 1 , . . . , v n ; is declared in P.</figDesc><table><row><cell>Example 10. The initial state for the protocol of Figure 1 (symmetric key ver-</cell></row><row><cell>sion) is: t init (P) := h(x time ).w(0, x 1 , tv, x 2 , tv, scard, key , 1)</cell></row><row><cell>.w(1, x 3 , scard, x 3 , {x 4 } key , scard, key , 1).i(scard)</cell></row><row><cell>4.2 Protocol Executions</cell></row><row><cell>Definition 3. Given a ground term t 0 and rewrite systems R, S the set of exe-</cell></row><row><cell>cutions EXEC (t</cell></row></table><note><p>0 , R, S) is the set of maximal derivations t 0 R,S t 1 R,S . . . Maximality is understood w.r.t. the prefix ordering on sequences. The normal executions of protocol P are the elements of the set EXEC n (P) := EXEC t init (P), R(P), S 0</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>5. K as , K bs , K ab : symmetric key; M, N a , N b , X : number; messages 1. A → B : M, A, B, {N a , M, A, B} Kas 2. B → S : M, A, B, {N a , M, A, B} Kas , N b , M, A, B K bs 3. S → B : M, {N a , K ab } Kas , {N b , K ab } K bs 4. B → A : M, {N a , K ab } Kas 5. A → B : {X} Kab knowledge A : B, S, K as ; B : S, K bs ; S : A, B, K as , K bs ; session instance [A : a, B : b, S : s, k as : k as , K bs : k bs ];</figDesc><table><row><cell cols="2">protocol Ottway Rees</cell></row><row><cell>identifiers</cell><cell></cell></row><row><cell>A, B, S</cell><cell>: user;</cell></row><row><cell cols="2">intruder : divert, impersonate;</cell></row><row><cell cols="2">intruder knowledge : ;</cell></row><row><cell cols="2">goal : secrecy of X;</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Following the traditional notation, the I(C) in step 1 means that I did divert the first message of D to C. Note that this ability is selected in Figure <ref type="figure">1</ref>. It may be performed in real world by interposing a computer between the decoder and the smartcard, with some serial interface and a smartcard reader. The sender I(C) in the second message means that C did impersonate C for sending this message. Note that I is able to reconstruct the message of step 2 from the message he diverted at step 1, with a projection π 1 to obtain the name of D and projection π 2 to obtain the cipher {Ins} K and his initial knowledge (the name of the smartcard). Note that the smartcard C did not participate at all to this protocol execution. Such an attack may be used if the intruder wants to watch some channel x which is not registered in his smartcard. See <ref type="bibr" target="#b0">[1]</ref> for the description of some real-world hacks on pay TV.</p><p>A secrecy attack can be performed on the public key version of the protocol in Figure <ref type="figure">1</ref>. By listening to the message sent by the decoder at step 1, the intruder (with eaves dropping ability) can decode the cipher {Ins} T [D] -1 since he knows the public key T [D], and thus he will learn the secret instruction Ins. Note that there was no correspondence flaw in this scenario.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Secrecy Attack</head><p>Definition 4. We say that a principal U of P shares a (secret) identifier N if there exists j and t such that N : t ∈ know (U, j).</p><p>In the construction of R(P), we say that the term t = compose(U, M, j) is bound to M . Definition 5. An execution t 0 , . . . ∈ EXEC i (P) satisfies the secrecy property iff for each j, t j does not contain an instance of i(t) as a subterm, where t is bound to a term N declared in a field goal : secrecy of N of P.</p><p>To define a critical state corresponding to a secrecy violation in our semantics, we add a binary function symbol secret ( , ) to F , which is used to store a term t (nonce or session key) that is bound to some data N declared as secret in P, by secrecy of N . If this term t appears as an argument of i( ), and I was not supposed to share t, then it means that its secrecy has been corrupted by the intruder I.</p><p>We must formalise the condition that "I was not supposed to share t". For this purpose, we add a second argument to secret( , ) which is a term of T ({s, 1, . . . , k}), corresponding to the the value of a session counter, where k is the number of fields session instance : in P. Let C = {1, . . . , k}. To each field session instance in P is associated a unique constant in C by the protcedure described in Section 4.1. Let J ⊆ C be the set of session instances where I has not the role of a principal that shares N .</p><p>The critical state t goal (P) is any of the terms of the set:</p><p>In addition to these two deduction rules, we need to simplify clauses by term rewriting, using equations of S 0 (rewrite rules (1)-( <ref type="formula">6</ref>)). For this step we have to compute a match σ of a term l into l , that is a substitution such that lσ = l .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 9 (Simplification). l = r P(t[l ])</head><p>Applying this rule consists in replacing the initial clause by the simplified one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Deduction Strategy</head><p>We basically apply a breadth first search strategy. The compilation of the protocol generates four sets of clauses:</p><p>(0) the rewrite rules of S 0 ;</p><p>(1) the clauses representing transitions rules (including intruder's rules);</p><p>(2) the clause representing the initial state, P t init (P) ;</p><p>(3) the critical state (¬P t goal (P) );</p><p>The deduction strategy used by daTac is the following: If it applies, Exit with message "contradiction found". Until no more clause to select in <ref type="bibr" target="#b0">(1)</ref> Until no more clause to select in <ref type="bibr" target="#b1">(2)</ref> Note that any derivation of a contradiction ¾ with this strategy is a linear derivation from the initial state to the goal and it can be directly interpreted as a scenario for a flaw or an attack. generic daTac proof strategy for reducing the exploration space when searching for flaws. We also conjecture it is possible to modify our approach in order to prove the absence of flaws under some assumptions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A: Design Flaws</head><p>This is a flawed e-commerce protocol. While browsing an online commerce site, the customer C is offered an object O (together with an order form, price information etc) by merchant M . Then, C transmits M a payment form N with his bank account information and the price of O, in order for M to ask directly to C's bank B for the payment. For confidentiality reasons, M must never read the contents of N , and B must not learn O. Therefore, O is encrypted in message 1 with the public key K c of C. Also, in message 2, N is transmitted by C to M in encrypted form with the bank's public key K b and in the form of a digest computed with the hash one-way function. Then M relays the cipher {N } K b to B together with a digest of O. The bank B makes the verification for the payment and when it is possible, gives his certificate to M in the form of a dual signature.</p><p>The problem is that in message 2, there is no occurrence of O, so there may be some interference between two executions of the protocol. Imagine that C is performing simultaneously two transactions with the same merchant M . In the two concurrent execution of the protocol, M sends 1. M → C : {car } Kc and 1. M → C : {peanut} Kc . C will reply with two distinct corresponding payment forms (the price field will vary) 2. C → M : B, {N car } K b , hash(N car ) and 2. C → M : B, {N peanut } K b , hash(N peanut ) . But after receiving these two messages, M may be confused about which payment form is for which offer (recall that M can not read N car and N peanut ), and send the wrong requests to B: 3. M → B : {N car } K b , hash(peanut) and 3. M → B : {N peanut } K b , hash(car ). If the bank refuses the payment of N car but authorises the one of N peanut , it will give a certificate for buying a car and paying peanuts! Fortunately for M , the check of dual signature (by M ) will fail and transaction will by aborted, but</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B: A Correspondence Attack</head><p>Trace obtained by daTac of a correspondence attack for the symmetric key TV protocol (Figure <ref type="figure">1</ref>).</p><p>.w <ref type="bibr">(</ref> One subterm (of the last term) matches the pattern t goal (P).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C: A Secrecy Attack</head><p>Trace obtained by daTac of a secrecy attack for the public key TV protocol (Figure <ref type="figure">1</ref>). .secret (nonce(x 1 ), f(1)) .i(key).i(tv ).i(scard ).i({nonce(x 1 )} key[tv ] -1 ).i(key[tv ]) <ref type="bibr" target="#b30">(31)</ref> h(x 1 ).m(1, tv , tv, scard , tv , {nonce(x 1 )} key[tv] -1 , 1)</p><p>.w(2, scard , tv, scard , tv, {nonce(x 1 )} key[tv] -1 , tv , scard , key, key[tv ] -1 , x 2 , x 3 , nonce(x 1 ) , 1) .w(1, x 4 , scard , x 4 , x 5 , scard , key, key[scard ] -1 , 1) .secret (nonce(x 1 ), f(1)) .i(key).i(tv ).i(scard ).i({nonce(x 1 )} key[tv ] -1 ).i(key[tv ]).i(nonce(x 1 ))</p><p>The subterm secret (nonce(x 1 ), f(1)).i(nonce(x 1 )) matches the pattern t goal (P).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Programming Satan&apos;s computer</title>
		<author>
			<persName><forename type="first">R</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1000</biblScope>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Completion without Failure</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bachmair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Plaisted</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Resolution of Equations in Algebraic Structures</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Aït-Kaci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Nivat</surname></persName>
		</editor>
		<imprint>
			<publisher>Academic Press inc</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">152</biblScope>
		</imprint>
	</monogr>
	<note>Rewriting Techniques</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Associative-Commutative Superposition</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bachmair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th CTRS Workshop</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Lindenstrauss</surname></persName>
		</editor>
		<meeting>4th CTRS Workshop<address><addrLine>Jerusalem (Israel</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">968</biblScope>
			<biblScope unit="page">153</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Lazy infinite-state analysis of security protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Secure Networking -CQRE [Secure] &apos;99</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1740</biblScope>
			<biblScope unit="page">132</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Towards the formal verification of electronic commerce protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bolignano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="page">142</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Proving Theorems with the Modification Method</title>
		<author>
			<persName><forename type="first">D</forename><surname>Brand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. of Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">152</biblScope>
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A survey of authentication protocol literature</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jacob</surname></persName>
		</author>
		<ptr target="http://www.cs.york.ac.uk/~jac/papers/drareviewps.ps" />
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="page">155</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Protocol specification and analysis in Maude</title>
		<author>
			<persName><forename type="first">G</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Talcott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Security Protocols, 1998. LICS &apos;98 Workshop</title>
		<imprint>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="page">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Capsl intermediate language</title>
		<author>
			<persName><forename type="first">G</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Millen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Security Protocols, 1999. FLOC &apos;99 Workshop</title>
		<imprint>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="page">132</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Handbook of Theoretical Computer Science, volume B, chapter 6: Rewrite Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Jouannaud</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="volume">133</biblScope>
			<biblScope unit="page">139</biblScope>
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the security of public key protocols</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yao</surname></persName>
		</author>
		<idno>STAN-CS-81-854</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">133</biblScope>
			<biblScope unit="page">137</biblScope>
			<date type="published" when="1981">1983. May 1981</date>
			<pubPlace>Stanford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A technical note on AC-unification. the number of minimal unifiers of the equation αx1 + • • • + αxp . =AC βy1 + • • • + βyq</title>
		<author>
			<persName><forename type="first">E</forename><surname>Domenjoud</surname></persName>
		</author>
		<idno>1992. 153</idno>
	</analytic>
	<monogr>
		<title level="j">JAR</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="39" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Cvs: A compiler for the analysis of cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Focardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gorrieri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page">131</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Proving Refutational Completeness of Theorem-Proving Strategies : the Transfinite Semantic Tree Method</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hsiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">152</biblScope>
			<date type="published" when="1991-07">July 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Canonical forms and unification</title>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Hullot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th International Conference on Automated Deduction</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1980-07">july 1980</date>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page">137</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Simple Word Problems in Universal Algebras</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Bendix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Problems in Abstract Algebra</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Leech</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford</addrLine></address></meeting>
		<imprint>
			<publisher>Pergamon Press</publisher>
			<date type="published" when="1970">1970</date>
			<biblScope unit="page">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Casper: a compiler for the analysis of security protocols</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">136</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Towards a completeness result for model checking of security protocols</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lowe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page">134</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Applying formal methods to the analysis of a key management protocol</title>
		<author>
			<persName><forename type="first">C</forename><surname>Meadows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">133</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The NRL protocol analyzer: an overview</title>
		<author>
			<persName><forename type="first">C</forename><surname>Meadows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">133</biblScope>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">CAPSL: Common Authentication Protocol Specification Language</title>
		<author>
			<persName><forename type="first">J</forename><surname>Millen</surname></persName>
		</author>
		<idno>MP 97B48</idno>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>The MITRE Corporation</publisher>
			<biblScope unit="volume">132</biblScope>
			<biblScope unit="page">133</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automated analysis of cryptographic protocols using Murφ</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Stern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page">131</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Paramodulation-based theorem proving</title>
		<author>
			<persName><forename type="first">R</forename><surname>Nieuwenhuis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rubio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Automated Reasoning</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier Science Publishers</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The inductive approach to verifying cryptographic protocols</title>
		<author>
			<persName><forename type="first">L</forename><surname>Paulson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">131</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Complete sets of reductions for some equational theories</title>
		<author>
			<persName><forename type="first">G</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Stickel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page">153</biblScope>
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Building-in equational theories</title>
		<author>
			<persName><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">152</biblScope>
			<date type="published" when="1972">1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Paramodulation and First-Order Theorem Proving</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>Wos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Intelligence 4</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Meltzer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Mitchie</surname></persName>
		</editor>
		<imprint>
			<publisher>Edinburgh University Press</publisher>
			<date type="published" when="1969">1969</date>
			<biblScope unit="page">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Modelling and verifying key-exchange protocols using CSP and FDR</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th IEEE Computer Security Foundations Workshop</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page">132</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Automated Deduction with Associative-Commutative Operators. Applicable Algebra in Engineering, Communication and Computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rusinowitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vigneron</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-01">January 1995</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">153</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Applied Cryptography</title>
		<author>
			<persName><forename type="first">B</forename><surname>Schneier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>John Wiley</publisher>
			<biblScope unit="page">133</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Automated Theorem-Proving for theories with Simplifiers</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Slagle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commutativity and Associativity. JACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">152</biblScope>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Dolev-Yao is no better than Machiavelli</title>
		<author>
			<persName><forename type="first">P</forename><surname>Syverson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Meadows</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Cervesato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WITS&apos;00. Workshop on Issues in the Theory of Security</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page">146</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Positive deduction modulo regular theories</title>
		<author>
			<persName><forename type="first">L</forename><surname>Vigneron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Computer Science Logic</title>
		<meeting>Computer Science Logic<address><addrLine>Paderborn (Germany)</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1092</biblScope>
			<biblScope unit="page">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Towards an automatic analysis of security protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Weidenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Automated Deduction</title>
		<meeting>the 16th International Conference on Automated Deduction</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1632</biblScope>
			<biblScope unit="page">131</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">First-Order Theorem Proving Modulo Equations</title>
		<author>
			<persName><forename type="first">U</forename><surname>Wertz</surname></persName>
		</author>
		<idno>MPI-I-92-216</idno>
		<imprint>
			<date type="published" when="0153">April 1992. 153</date>
			<publisher>MPI Informatik</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A semantic model for authentication protocols</title>
		<author>
			<persName><forename type="first">T</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Research in Security and Privacy</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">134</biblScope>
			<biblScope unit="page">147</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">there is nevertheless a serious interference flaw in this protocol, that can occur even only between two honest agents</title>
		<imprint/>
	</monogr>
	<note>without an intruder</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
