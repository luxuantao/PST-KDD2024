<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Verifying and enforcing network paths with ICING</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jad</forename><surname>Naous</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Walfish</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Nicolosi</surname></persName>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Mazi</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Miller</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Arun</forename><surname>Seehra</surname></persName>
						</author>
						<author>
							<persName><forename type="first">U</forename><forename type="middle">T</forename><surname>Austin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Stevens</forename><surname>Institute</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Technology</forename><forename type="middle">§</forename><surname>Stanford</surname></persName>
						</author>
						<title level="a" type="main">Verifying and enforcing network paths with ICING</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">72C3F50EA261F1953824065035D67F60</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T04:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.2.1 [Computer-Comunication Networks]: Network architecture and design</term>
					<term>C.2.0 [Computer-Communication Networks]: General-Security and protection</term>
					<term>C.2.2 [Computer-Communication Networks]: Network protocols</term>
					<term>D.4.6 [Operating Systems]: Security and Protection-Access controls</term>
					<term>Authentication</term>
					<term>Cryptographic controls</term>
					<term>Algorithms, Design, Experimentation, Performance, Security Path enforcement, consent, NetFPGA, default-off</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe a new networking primitive, called a Path Verification Mechanism (PVM). There has been much recent work about how senders and receivers express policies about the paths that their packets take. For instance, a company might want fine-grained control over which providers carry which traffic between its branch offices, or a receiver may want traffic sent to it to travel through an intrusion detection service.</p><p>While the ability to express policies has been well-studied, the ability to enforce policies has not. The core challenge is: if we assume an adversarial, decentralized, and high-speed environment, then when a packet arrives at a node, how can the node be sure that the packet followed an approved path? Our solution, ICING, incorporates an optimized cryptographic construction that is compact, and requires negligible configuration state and no PKI. We demonstrate ICING's plausibility with a NetFPGA hardware implementation. At 93% more costly than an IP router on the same platform, its cost is significant but affordable. Indeed, our evaluation suggests that ICING can scale to backbone speeds.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The current Internet provides a simple delivery mechanism: we put destination addresses in packets and launch them into the network. We leave the network to decide the path that our packets take and the intermediate providers that the path passes through. Even network operators have little control over the paths that packets take toward them, or after leaving them. There are times, however, when senders, receivers, and operators would prefer to control packets' paths-and be sure that their preferences are enforced.</p><p>For example, an enterprise might want the packets that it receives to pass through several services, such as an ac-counting service and a packet-cleaning service. Or a company might want fine-grained control over which providers carry which traffic between its branch offices, yet the network paths must respect the providers' pairwise business relationships. Or providers might want to make sure that they are carrying traffic only from friendly nations.</p><p>The functionality above does not exist in the Internet today, though there are proposals that address various aspects of the problem. However, there is no general-purpose mechanism that enforces these policies (short of allocating dedicated connections, which is expensive).</p><p>This paper tries to fill that void. We describe a new primitive that we call a PVM (Path Verification Mechanism). A PVM is a protocol and mechanism for forwarding (sending a packet to its next hop), as distinct from topology discovery and path selection, or routing. Enriching routing policy <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b57">59,</ref><ref type="bibr" target="#b62">64,</ref><ref type="bibr" target="#b65">67,</ref><ref type="bibr" target="#b66">68,</ref><ref type="bibr" target="#b68">70]</ref> has received much attention. Our focus, in contrast, is enforcing those policies during forwarding, which has received less attention and which we view as complementary: if it is important that routing produce policy-compliant paths, then it is important that packets actually be forwarded along those paths. (Note that this is orthogonal to the problem of securing routing protocols <ref type="bibr">[6, 16, 36-38, 40, 43, 70]</ref>.)</p><p>A PVM provides two properties:</p><p>1. Path Consent: Before a communication, every entity on the path of the communication (including the sender and receiver) or a delegate of that entity consents to the use of the whole path, based on the entity's or the delegate's particular policy <ref type="bibr" target="#b59">[61]</ref>. 2. Path Compliance: On receiving a packet, every entity can verify (1) that it or its delegate had approved the packet's purported path, and ( <ref type="formula">2</ref>) that all previous entities on the path have already forwarded the packet in the order specified by the path.</p><p>Realizing a PVM is a challenging technical problem: when a packet arrives at a node, how can the node be sure that the packet followed an approved path? Many "first-guess" solutions are ruled out by our target environment, which we assume is:</p><p>• Adversarial: Nodes may try to thwart the mechanism.</p><p>• High-speed: To work at Internet backbone speeds, a PVM cannot rely on per-packet public key operations (ruling out a signed log in every packet <ref type="bibr" target="#b17">[18]</ref>), per-flow state in forwarders (which stymies fail-over), and ideally not even per-flow public key operations.</p><p>• Decentralized: There is no authority that could configure every node per-flow (ruling out Ethane <ref type="bibr" target="#b18">[19]</ref>, which provides Path Consent but only inside an enterprise).</p><p>Our solution, ICING, has three key aspects. First, we develop a protocol whereby a node can tell, given a packet, whether the packet's stated path is approved and whether the prior nodes on that path actually handled the packet. The protocol condenses what appears to be quadratic information into linear space, without requiring a PKI or any significant configuration state; it composes cryptographic constructions (e.g., MAC aggregation <ref type="bibr" target="#b38">[39]</ref>) with security techniques (e.g., self-certifying names <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b50">51]</ref>). Second, the protocol does not require each entity to approve every flow; it allows an entity to selectively delegate its authority (for instance, a provider delegates to its customers, who delegate to their customers, etc.). Third, since we aim for high speeds, and since processing protocols cost-effectively at backbone speeds requires hardware, we apply careful engineering to make our design amenable to implementation in hardware. <ref type="foot" target="#foot_0">1</ref>To validate our design, we have implemented ICING in hardware, on NetFPGA <ref type="bibr" target="#b1">[2]</ref>. This implementation achieves a minimum throughput of 3.2 Gbits/s at an equivalent gate cost of 54% more than a simple IP forwarder running at 4 Gbits/s; thus, per unit of throughput, our ICING implementation costs 93% more than IP. Our evaluation further suggests that, if implemented on a custom ASIC (as in a modern router), ICING would scale to backbone speeds at acceptable cost ( §5- §6).</p><p>We have also implemented an overlay, ICING-ON, which uses ICING for forwarding and is incrementally deployable.</p><p>We treat related work later in the paper ( §7). For now we just note that some of ICING's components are reminiscent of or inspired by prior mechanisms <ref type="bibr">[7, 10, 11, 13, 17, 19, 24, 28-31, 49, 51, 57, 58, 65, 69]</ref>, and ICING can enforce many previously proposed policies. However, we know of only one proposal that offers both Path Consent and Path Compliance <ref type="bibr" target="#b17">[18]</ref> and none that offers these two properties in an environment that is adversarial, high-speed, and federated. More specifically, this paper's contributions are: • A new networking primitive, the PVM, and the design of an efficient PVM, called ICING. • A fast and affordable hardware implementation of ICING, and a software implementation in an overlay. • A packet header format and an optimized construction that demonstrate the plausibility of rich per-packet cryptography at network line rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Motivating scenarios and caveats</head><p>We gave several motivating scenarios above (controlling inbound packet paths for packet cleaning, etc.), and Section 4 goes into more detail.</p><p>Here, we just note that a PVM complements the many works on routing policy <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b57">59,</ref><ref type="bibr" target="#b62">64,</ref><ref type="bibr" target="#b65">67,</ref><ref type="bibr" target="#b66">68,</ref><ref type="bibr" target="#b68">70]</ref> by verifying that packets take the routes expressed by policy. We now give three caveats. First, a PVM lets principals restrict paths to specific providers but does not guarantee that those providers are trustworthy. In particular, to guarantee that a packet hasn't transited a particular network requires trusting every provider on the path not to tunnel through that network or copy packets there. Second, many of the applications that we give can individually be addressed by specialpurpose mechanisms-at the expense of the other examples. A PVM, in contrast, provides these functions together.</p><p>Third, we are not trying to convince the reader that a PVM is advantageous on all axes; indeed, our PVM has disadvantages (including complexity and some cost). However, before this study, researchers did not know whether it was possible to build a PVM, let alone how to build one or what it would cost. Indeed, a routinely deferred item in papers on routing security is "data plane security", and we found that realizing a PVM required careful design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">OVERVIEW OF ICING</head><p>We now describe ICING at a high level, including its threat model, deferring design details to Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Architecture and components</head><p>ICING is a packet forwarding mechanism that allows a forwarder to verify that a packet is following its pre-approved path-and hence that packet forwarding is complying with the path policies of all entities on the path-before letting the packet consume further network resources. An ICING network comprises ICING nodes, which may include end-hosts.</p><p>There are two natural deployment scenarios for ICING: (1) at layer 3 (the network layer) and (2) in an overlay. In the first case, transit providers would deploy ICING nodes at the ingress of their networks. Internal forwarders need not run ICING, just as today's internal forwarders may implement a different protocol from that of the border router. This scenario is default-off <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b63">65,</ref><ref type="bibr" target="#b67">69]</ref>, which necessitates careful bootstrapping; the details are beyond this paper's scope but can be found in <ref type="bibr">[52, §4]</ref>, and similar problems have been treated elsewhere <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b67">69]</ref>. In the overlay case, the ICING nodes are waypoints interconnected by the regular IP network. In this case, ICING's guarantees refer to the waypoint-level paths, not IP-level paths. This section will be agnostic about the deployment scenario.</p><p>To communicate with a receiver, the sender first chooses a path of nodes. How senders find paths depends on the scenario; the sender might query DNS to get a path, purchase access to a remote ISP via its Web site, statically configure paths, etc. This paper mostly assumes that the sender has candidate paths in hand, as ICING is concerned with forwarding and is orthogonal to path retrieval (routing).</p><p>Figure <ref type="figure">1</ref> summarizes ICING's forwarding. For each node on the path, the sender requests from the node's provider a Proof of Consent (PoC), which certifies the provider's consent to carry packets along that path. The PoC is cre- ated by a consent server owned by the provider or acting on its behalf. A consent server is a general-purpose server separate from a provider's forwarding nodes; as articulated in <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref>, this separation lets policies be flexible, fine-grained, and evolvable. We note that a provider's nodes and consent servers trust each other (they are a trust domain). As a packet travels through the network, each node verifies that the packet is following its approved path. This job decomposes into three tasks: (1) the node checks that the path is approved; (2) it checks that the path has been followed so far; and (3) it proves to downstream nodes that it has seen the packet. To perform these functions, ICING nodes use the construction depicted in Figure <ref type="figure" target="#fig_1">2</ref>. The construction relies on PoCs and on Proofs of Provenance, or PoPs. PoPs allow upstream nodes to prove to downstream nodes that they carried the packet. These proofs require pairwise PoP keys, but these keys do not require significant configuration or coordination, as nodes derive keys on demand from each other's IDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Goals and non-goals</head><p>ICING seeks to provide a PVM's two properties, Path Consent and Path Compliance. We refine these properties into the following requirements for ICING:</p><p>• Delegation: A consent server must be able to delegate its path approval function. • Path Consent: When a node receives a packet with path P, it must be able to verify that its consent server, or a delegate, approved P. • Path Compliance: When a node N i with index i in path P receives a packet with path P, the node must be able to verify that the packet was sent by the purported sender (index 0) and has been forwarded by each of the nodes at indices 1, 2,. . ., i-1, in that order.</p><p>ICING is designed to meet the above requirements while being amenable to an affordable high-speed hardware implementation and while not requiring a central authority, PKI, or significant configuration state. Our threat model, which is strongly adversarial, gives us further constraints. We describe this model in the next subsection.</p><p>There are several functions that ICING is not designed for (these are either seemingly infeasible or outside the scope of PoP2,3 our problem of path enforcement):</p><formula xml:id="formula_0">⊕ ⊕ A1 PoP0,1 A2 ⊕ PoP0,2 ⊕ A3 PoP0,3 ⊕ PoP0,1 A1 ⊕ ⊕ A3 PoP0,3 PoP1,3 N0 N1 N2 N3 N0 N1 N2 N3</formula><p>The statement of Path Compliance does not guarantee a packet's future. After a packet departs a node, any downstream node can send it anywhere. It seems extremely hard to prevent such misbehavior. However, ICING can contain it: honest nodes drop packets that do not contain a proof of having passed through every prior node on the path.</p><p>ICING nodes can copy packets and send them elsewhere, or pass packets through hidden nodes. This, too, seems very hard to prevent in a federated environment. However, unlike in the status quo, ICING senders and receivers can restrict the path to providers that they trust not to leak their packets. (This choice is an alternative to onion routing, which is not always feasible <ref type="bibr" target="#b20">[21]</ref>.)</p><p>ICING does not try to provide authenticated information about the location of silent errors or failures on the path. An ICING node can signal an error to the sender (Section 3.4); however, the sender cannot discover the location of a fault if none of the nodes on the path initiates this signal.</p><p>ICING does not provide information about whether a packet received any contracted-for services at a node. For instance, if a sender chooses to send a packet through a particular node because the node advertised a virus-scanning service, the receiver can check if the packet was forwarded through the node but not that it was actually scanned.</p><p>ICING makes a binary decision about whether a path is acceptable; it does not regulate the amount of traffic sent along a path, or associated to a PoC. Other work <ref type="bibr" target="#b67">[69]</ref> has shown how to perform such accounting with little forwarder state, and ICING could be extended with this technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Threat model</head><p>Machines that obey the protocol we term honest. We assume that some providers, nodes (including end-hosts), and consent servers are not honest and specifically that they are controlled by attackers. These machines can engage in Byzantine behavior that deviates arbitrarily from ICING's specified packet handling. For instance, the attacker can send arbitrary packets or try to flood links to which it connects. The attacker can also observe legitimate data packets that pass through it. We make no assumptions about how malicious nodes are implemented: they may connect to one another and be controlled by a single attacker, or they may collude, potentially bracketing honest nodes on paths. Furthermore, even honest machines may give service to malicious parties; for instance, a consent server can grant PoCs to an attacker.</p><p>The attacker tries to make ICING fail some of its goals (Section 2.2), for instance by trying to abuse the delegation mechanism, or trying to make an honest node N i accept a packet whose path was not approved by N i 's consent server (or a delegate), or whose actual path skipped some of the honest nodes upstream of N i in the approved path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Naming</head><p>Each ICING node assigns itself an identifier, called a node ID, that is a unique public key. The node keeps secret the private key. The identifier space is large enough to make the probability of a collision negligible. With such self-certifying names <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b50">51]</ref>, a central naming authority or PKI is not needed. This fits the Internet's federated structure.</p><p>A path is a list of nodeID, tag pairs. The tag identifies a specific set of local actions that a node performs on packets with this tag. For example, a tag can describe a priority level for queuing, identify a customer to bill, select an output link, request virus-scanning services, or specify a combination of these. It can be thought of as a generalized MPLS label <ref type="bibr" target="#b24">[25]</ref> (and shares some functionality with the vnode mechanism in <ref type="bibr" target="#b27">[28]</ref>). The provider conveys the particular meaning of a tag on a node to the users of that tag through out-of-band means, such as an agreement with the user or a Web page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Proofs of consent (PoCs)</head><p>After a sender has determined a path, it contacts a consent server for each node N on the path to obtain PoCs for that path. Each consent server is preconfigured with its provider's policy, so it can check whether paths are compliant. To aid its checks, the consent server may use external information (billing, authentication, etc.). If the check passes, the consent server creates a PoC and returns it to the sender.</p><p>For a node N, the PoC is a cryptographic token indicating that N's provider consents to the full path, including N's tag in that path. This token is computed under a tag key, which is unique to the N, tag pair. This key is known to both the consent server and the local node.</p><p>Consent serving is flexible. A provider with multiple ICING nodes can deploy a single consent server. It can also delegate the ability to create PoCs for a particular node and tag (by divulging that tag's key to the delegate) or disintermediate itself altogether (by disclosing all of its tag keys).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Packet creation and proofs of provenance (PoPs)</head><p>The sender uses the PoCs it obtains to construct the packet header; the construction is such that when a packet arrives at node N, N can tell whether the sender held a PoC issued by N's consent server. The sender also computes PoPs for each of the nodes on the path. These PoPs prove to the nodes that the sender created the packet; each PoP includes a MAC of the packet under a shared symmetric PoP key.</p><p>These shared PoP keys do not require the network to be configured with pairwise keys; ICING nodes derive PoP keys on demand. By using non-interactive Diffie Hellman key exchange, an ICING node (such as the sender) derives the PoP key that it shares with any other node N from its own private key and N's node ID (which is a public key). Nodes cache PoP keys after deriving them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Packet processing: Verification and forwarding</head><p>Each node that receives the packet does the following: 1. It computes the PoC from the path and the tag key that the node shares with its consent server; 2. For each upstream node in the path: The PoPs computed in step 2 prove to the node that the packet has passed through all the upstream nodes. If the PoC is correct and the PoPs are all correct, then the packet has been following an approved path. Otherwise, the node drops the packet. If the checks pass, the node proves to downstream nodes that it has seen the packet, as follows: 4. For each downstream node in the path:</p><p>(a) It derives the PoP key that it shares with this downstream node (from the downstream's ID, in the path); (b) It computes the PoP under this PoP key. 5. It inserts these PoPs into the header. 6. It forwards the packet to the next node.</p><p>As so far described, packet header size appears quadratic in the length of the path. However, the header size is in fact linear in path length. As illustrated in Figure <ref type="figure" target="#fig_1">2</ref>, the PoC and the PoPs that a node inspects in steps 1-3 above are XORed together in an aggregate MAC <ref type="bibr" target="#b38">[39]</ref>. The cost of this reduction in space is that a node cannot tell, in the case of tampering, which of the PoPs or PoC is incorrect. However, the probability of successful tampering is unaffected <ref type="bibr" target="#b38">[39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DESIGN DETAILS OF ICING</head><p>This section details ICING's design, which aims to meet the requirements stated in Section 2.2. Figure <ref type="figure" target="#fig_3">3</ref> describes the notation that we use throughout our design discussion and our pseudocode, while Figure <ref type="figure">4</ref> summarizes the secret cryptographic material used in ICING.</p><p>ICING's packet format is shown in Figure <ref type="figure" target="#fig_4">5</ref>. Each packet includes three types of information for every node in its path other than the sender. The first is per-node information: a node ID, N i , and a corresponding tag, tag i (Section 2.4). The second is the Proof of Consent (PoC) showing that the tag's owner authorized the path (Section 2.5). The third is the Proofs of Provenance (PoP), which allow a  </p><formula xml:id="formula_1">i . k i,j (= k j,i ) NIDH(x i , N i , N j )(= NIDH(x j , N j , N i )).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HASH(d)</head><p>A collision-resistant hash function that maps variable-length data d to a 248-bit digest. Based on CHI <ref type="bibr" target="#b34">[35]</ref>. Future versions of ICING will use the final SHA-3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>HASH2(d)</head><p>A collision-resistant hash function that maps variable-length data d to a 128-bit digest. Based on SHA-1. Future versions of ICING will use the final SHA-3. node i consent server i delegate</p><formula xml:id="formula_2">(i ≥ 0) (i &gt; 0) of node i sender xi x ki,j o mN i x x m N i :t/p o o x sN i :tag i o o o PoCi.proof o o o x</formula><p>Figure <ref type="figure">4</ref>-Cryptographic keys in ICING (rows), and holders of these keys (columns). The key material is relative to the i-th entry in a packet's path (which is the sender, if i = 0). x denotes a key that the entity is given; o denotes a key that the entity can derive. node to verify that every previous node has approved the path and forwarded the specific packet (Sections 2.6-2.7). The PoC-more precisely, an authenticator derived from it-and PoPs are aggregated into a constant-length verifier (V i .proof).</p><p>PoCs and PoPs allow ICING to meet its requirements of Path Consent and Path Compliance. We discuss Delegation later.</p><p>Because packets carry node IDs, and because node IDs are public keys, our design needs small public keys. Thus, we use elliptic curve cryptography (ECC): every node ID, N i , is a point on NIST's B-163 binary-field elliptic curve group <ref type="bibr" target="#b4">[5]</ref>, which gives roughly 80-bit security, similar to 1024-bit RSA keys <ref type="bibr" target="#b4">[5]</ref>. The private key, x i , corresponding to N i , is the 163bit number such that N i = g xi in B-163, where g is the group generator. To make the approach amenable to hardware implementation, we reduce the representation of N i from 163 to 160 bits. <ref type="foot" target="#foot_1">2</ref> We do so by requiring the top three bits to equal a cryptographic hash of the lower 160 bits; this does not diminish the strength of the keys, though it increases expected key generation time by a factor of 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Creating a packet</head><p>Once a sender assembles a path P (a process largely orthogonal to ICING, as discussed in Section 2.1), it must obtain PoCs for each N i :tag i in P. To do so, it contacts N i 's consent server. The PoC consists of a 16-bit expiration time indicator, PoC i .expire, and a cryptographic token, PoC i .proof = vPRF(s Ni :tag i , P || PoC i .expire). s Ni :tag i is a tag-specific secret key shared between node N i and its consent server. Because managing keys separately for their 2 32 tags would be cumbersome for a node and its consent server, they instead share one master tag key, m Ni , that pseudorandomly generates many tag keys. This process is encapsulated by GET-TAG-KEY(m Ni , tag i ), and we unpack it below, in Section 3.3. The master tag key m Ni is changed periodically to prevent cryptanalytic attacks; a PoC's expire indicator is relative to the time when m Ni was last re-keyed. The granularity of each expire time-unit is a per-node parameter; we envision typical choices between a few seconds and several minutes.</p><p>Given these PoCs, the sender calls INITIALIZE (Figure <ref type="figure">6</ref>), which creates a verifier V j for each other node j on the path. The sender initializes V j with A j (which binds the PoC j to the packet contents) and PoP 0,j ; given this V j , a downstream node can verify that the packet's path is approved by its consent server and that the packet has been created by the packet's purported sender.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Forwarding and receiving a packet</head><p>On receiving a packet, a node N i with index i in the packet's path processes it according to the pseudocode in Figure <ref type="figure">7</ref>. The node must ensure that Path Consent and Path Compliance (Section 2.2) are met for each packet that it passes. (Delegation will be discussed in Section 3.3.)</p><p>First, for Path Consent, N i must verify that the PoC implicit in the packet, PoC i , is correct. Second, for Path Comand hence not ICING's design. To smooth the changeover, hardware would support old and new versions (as with IPv4 to IPv6). Perform any special handling prescribed by tag i</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>34:</head><p>Transmit pkt to next node (or accept if destination) Figure <ref type="figure">7</ref>-Pseudocode for packet forwarding. The node validates the packet and transforms verifier entries before honoring the tag specified in the packet's header and sending the packet to the next node. Note that P is 0-indexed and V is 1-indexed. For brevity, generating and handling error packets ( §3.4) is not depicted. pliance, the node must verify the PoPs created by upstream nodes N 0 , . . . , N i-1 (that is, it must verify PoP j,i for j &lt; i).</p><p>The node executes both checks by validating the verifier V i . To do so, it derives an expected verifier V i , which requires deriving the expected PoC i (based on the path and the relevant tag key, cf. Figure <ref type="figure">7</ref>, lines 9-10), the expected A i , and the expected PoPs. If V i does not match the verifier in the packet (V i ), the packet is dropped (Figure <ref type="figure">7</ref>, lines 11-24). To perform its required duty with respect to Path Compliance, the node modifies the verifiers for downstream nodes (V j for j ≥ i) by XORing V j with PoP i,j (Figure <ref type="figure">7</ref>, lines <ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref>.</p><p>Computing PoPs may require deriving PoP keys k i,j (= k j,i ). Being resource-intensive (it takes about 4 msec in our implementation), this calculation happens on a node's slow path (meaning on a general-purpose processor). An attacker may try to attack a node's slow path by sending many pack-ets with invented node IDs. To defend against such an attack, the node requires a valid hardener (V i .hardener) in the packet, which it checks on the fast path (Figure <ref type="figure">7</ref>, lines 14-16). V i .hardener is only 32 bits, so it does not fully rule out such attacks, but it decreases their effectiveness by a factor of 2 32 , which is sufficient to avoid denial-of-service.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Deriving tag keys and controlled delegation</head><p>We now detail GET-TAG-KEY(m Ni , tag i ). Let t/p denote the p-bit prefix of tag t, and define m Ni :t/p to be the corresponding p-bit prefix key. We take m Ni :t/0 = m Ni for any tag t. Then, GET-TAG-KEY(m Ni , tag i ) iteratively computes m Ni :tag i /p = PRF(m Ni :tag i /(p-1) , tag i /p) to get m Ni :tag i /32 = s Ni :tag i , the tag key associated to N i :tag i . This approach is inspired by a technique in <ref type="bibr" target="#b55">[57]</ref>.</p><p>As so far described, this technique derives s Ni :tag i from m Ni :tag i /0 = m Ni using 32 serial rounds of PRF, which is too many for high speed packet processing. Three modifications that significantly reduce costs are described in <ref type="bibr">[52, §2.3.1]</ref>.</p><p>Controlled delegation. Given the above approach to tag key derivation, tag prefix delegation is easy to implement. To delegate the tag block with prefix t/p (i.e., 2 32-p tags), the node's provider shares m Ni :t/p . The delegate can further subdelegate tags by sharing m Ni :t/k , where k ≥ p. Delegation lets a provider give customers control over particular tags on the provider's nodes. A customer with such control can, with no provider intervention, act as a consent server on behalf of the provider (creating PoCs for its own traffic if it is an endhost or for its customers if it is itself a provider) or give its customers their own tag keys (to disintermediate itself).</p><p>Expiration and revocation. The PoC.expire timestamp allows consent servers to mint time-limited PoCs. This requires that a consent server and its nodes be loosely time synchronized (e.g., via NTP), within a tolerance commensurate to the expire-granularity adopted at the node.</p><p>The master tag key m Ni and other prefix keys m Ni :t/p are changed periodically to guard against chosen-message cryptanalytic attacks and to prevent an old timestamp that has wrapped from appearing valid.</p><p>To revoke PoCs before the expiration interval, a provider can (1) change m Ni at the node and consent server; or (2) change only a prefix key (or tag key), no longer deriving it from m Ni . The latter option requires a small, longest-prefixmatch override table mapping prefixes to prefix keys; the details are described in [52, §2.3.1].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Signaling errors and failures</head><p>Because ICING packets are source-routed, a network using ICING needs to report errors and other failures back to the sender so that the sender can use a different path if necessary. Note that a sender can hold pre-approved backup paths, so failures need not require the sender to obtain new paths.</p><p>On encountering an error, an ICING node generates an ICING error packet that travels backward along a given path toward the sender. A slight complication is Path Consent: for some nodes, consenting to a path's forward direction may not imply consent to carry error packets in reverse. In that case, the sender has to rely on end-to-end failure detection.</p><p>For nodes that do consent to carry error packets, ICING handles errors as follows. To create an error packet, a node sets the error index field in the header to the current index and replaces the payload with the original packet's hash, followed by optional error-specific information (analogous to ICMP error code and data). A node recognizes packets with non-zero error index fields as error packets and handles them differently: most importantly, the node forwards such packets to the previous node (rather than the next) and decrements (rather than increments) the path index field.</p><p>The V i in an error packet contain all the forward-direction PoPs from the original packet, in addition to PoPs for the error packet itself. Because the error payload begins with the original packet's hash, nodes can verify these forwarddirection PoPs despite not having the original packet. In particular, node i drops an error packet unless V i .proofs includes a PoP under k i,i . This ensures that a node will not forward an error packet if it did not previously forward the original.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Attacks</head><p>Attacks against the verification algorithm. The algorithm guards against the following attacks.</p><p>• Using incorrect or expired PoCs: This attack fails because each node checks the expiry and recalculates its expected PoC (Figure <ref type="figure">7</ref>, lines 7-10). • Skipping an honest node i: When the packet is received at honest node j downstream of node i, V j will lack PoP i,j and will be flagged (Figure <ref type="figure">7</ref>, lines 11-24). • Flooding a node's slow path: The attack is mitigated because the node checks V i .hardener before calculating any PoP keys (Figure <ref type="figure">7</ref>, lines <ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>.</p><p>Attacks that compromise secrets. How should a node handle the inevitable compromises of its cryptographic material (Figure <ref type="figure">4</ref>)? We have discussed PoC revocation (Section 3.3): a node changes prefix or tag keys (m Ni :t/p ). If an m Ni :t/p itself is compromised, a node can simply change it. A more serious concern is the compromise of a private key, x i , or any derived PoP key, k i,j . In that case, the node must generate a fresh public/private key pair so must also change its node ID. This requirement is inconvenient but not disastrous; other entities that express policy in terms of the renamed node must be notified about the change. <ref type="foot" target="#foot_2">3</ref>Attacks that attempt packet replay. An attacker who has observed a valid packet may inject a duplicate copy along a suffix of a path. At low rates, such attacks are not problematic: the layer using ICING presumably handles duplicates anyway. Meanwhile, an attack that aggressively floods using a few packets can be defeated by a modestly sized replay cache at each node; this cache would store PoC, counter pairs (the counter, from the packet header field, is chosen by the sender to be unique over the flow). A difficult case is if the attacker can amass packets from many flows within a single PoC validity window and then replay each packet a small number of times. Defending against this case is future work; it may require both reducing the PoC validity window and compressing the information in the replay cache.</p><p>Attacks on availability. What if an attacker overwhelms a consent server <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b67">69]</ref>? One option is to locate the consent server at a high-bandwidth denial-of-service mitigator (e.g., <ref type="bibr">[56]</ref>). Another option, if the receiver already knows who should be allowed to reach it (for example, employees or customers), is to give these senders their own tag keys s Ni :tag i so that they can mint their own PoCs without the consent server. Third, if PoC requests travel in ICING packets, then ICING's mechanisms themselves provide a foundation for defense. These mechanisms apply not just to an overloaded consent server but also to any receiver wishing not to hear from a sender. For instance, if senders can be identified at a useful granularity (e.g., "employees", "paying customers", "unknown senders who solved a CAPTCHA"), then the victim can assign each category to a different tag. When overloaded, the victim deprioritizes categories by not renewing expired PoCs for their tags; downgrading service to them; or, in an emergency, changing tag keys. If senders cannot be assigned to categories, we can follow TVA <ref type="bibr" target="#b67">[69]</ref>, ensuring roughly fair bandwidth consumption among senders by applying Hierarchical Fair Queueing <ref type="bibr" target="#b13">[14]</ref> to a packet's path. While attackers can weaken this defense under TVA by faking path identifiers, ICING does not have this vulnerability.</p><p>Other attacks. Section 2.2 mentioned attacks that ICING does not defend against.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">APPLICATIONS OF ICING</head><p>We first describe three applications of ICING and then say a few words about the interface to ICING.</p><p>First, ICING receivers can request services for incoming packets (e.g., outsourced intrusion detection service (IDS) or denial-of-service mitigation <ref type="bibr">[56]</ref>) and then verify that received packets actually traversed the services. ICING also enables these services themselves to specify other intermediate services (e.g., the IDS can specify an accounting service that drops traffic for non-customers). Unlike previous work <ref type="bibr" target="#b60">[62,</ref><ref type="bibr" target="#b61">63]</ref>, ICING provides integrity and authentication in the forwarding mechanism, even for intermediaries.</p><p>A second application is enforcing routing policy. Today, Internet providers run a policy routing protocol (BGP). Yet, forwarding in the current Internet can undermine policy routing: packets can (and do <ref type="bibr" target="#b47">[48]</ref>) deviate from the paths determined by BGP <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b25">26]</ref>. Under ICING, if a consent server agrees only to BGP-compliant paths, then its nodes will carry only packets that follow such paths.</p><p>Finally, ICING lets an enterprise protect itself against a flooding attack, by allowing it to control traffic toward it in a remote provider's network. The enterprise purchases delegated tags from a provider and mints PoCs for those tags on behalf of the provider only for authenticated senders.</p><p>Interface to ICING. We have implemented ICING both in an overlay network (called ICING-ON <ref type="bibr" target="#b49">[50]</ref>, <ref type="bibr">[52, §3]</ref>) and at layer-3 (see <ref type="bibr">[52, §4]</ref>) and have deployed ICING-ON on virtual machines in Amazon's EC2. We have no space for details so here just say a few words. These implementations demonstrate how bootstrapping, path retrieval, and topology discovery work. For ICING-ON, bootstrapping is easier since senders can always use the underlying network to reach consent servers. At layer 3, there are some details regarding how senders can use the default-off network itself to get consent to request consent <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b67">69]</ref>. For path building, how can the sender build a path that has the approval of all nodes? In the overlay scenario, one can iteratively build a path by querying consent servers that return patterns of allowed paths. At layer 3, allowed patterns are distributed in a routing protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION</head><p>This section describes our implementation of the ICING node's hardware and software. Our prototype node accepts ICING packets carried in Ethernet frames and implements the algorithm in Figure <ref type="figure">7</ref>. The implementation has a fast path that runs in hardware, and a slow path that is executed in software if a PoP key (k i,j ) is not cached in hardware or if an exception occurs. The fast path is implemented on the NetFPGA programmable hardware platform <ref type="bibr" target="#b1">[2]</ref>, which is a PCI card with 4 GigE ports, a field programmable gate array (FPGA), SRAM, and DRAM. The slow path, implemented in Click <ref type="bibr" target="#b41">[42]</ref>, calculates the needed keys and installs them in the hardware's key cache. The Diffie-Hellman key exchange is implemented with the MIRACL cryptographic library <ref type="bibr" target="#b58">[60]</ref>. All of the node's software runs on Linux 2.6.25.</p><p>We have not yet implemented PoC expiry or the handling of error packets. However, we do not expect these features to change our evaluation, as reported in the next section.</p><p>The hardware image uses support modules from the NetFPGA project. We implemented the ICING-specific logic, including cryptographic modules. The forwarder uses 89% of the total FPGA logic area and has a total equivalent gate count (EGC) of 13.4M. (EGC estimates how many gates a design would use on an ASIC, as reported by the Xilinx ISE synthesis tool, v10.1.) The area breakdown is: 38% to the AES, CHI, and PMAC modules, 28% to all other ICINGspecific logic, and 34% to the NetFPGA support modules.</p><p>By comparison, NetFPGA's reference IP router has an EGC of 8.7M and uses 50% of the total FPGA logic area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATION</head><p>ICING introduces space and time overhead from per-packet cryptographic objects and operations. Our principal question in this section is whether these overheads are practical at the speeds of Internet backbone links. In this section, we assume that ICING is deployed at the network layer. We begin by estimating ICING's total space overhead (Section 6.1). Sections 6.2 and 6.3 present microbenchmarks of our prototype node and supporting software. In Section 6.  from our results to assess ICING's future feasibility at Internet backbone scale. Our results are summarized in Figure <ref type="figure">8</ref>. Setup and parameters. Figure <ref type="figure" target="#fig_7">9</ref> lists the 3 machine classes that we use for evaluation. The NetFPGA is in the slow machine. Our experiments often vary packets' path lengths, path indices, and sizes; Figure <ref type="figure">10</ref> gives the fixed and variable parameters for these experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Packet overhead</head><p>Relative to IP, ICING requires larger packet headers so would consume more bandwidth. We now roughly quantify this overhead. An ICING header includes 13 bytes that do not depend on the packet's path length (see Figure <ref type="figure" target="#fig_4">5</ref>). 42 bytes are needed for each node in the path other than the sender: 24 bytes for the node ID and tag, N j :tag j , and 18 bytes for the verifier, V j . For a packet whose path length is 5-a pessimistic estimate of the average provider-level path length from <ref type="bibr" target="#b39">[40]</ref> and <ref type="bibr" target="#b6">[7]</ref>-the header is 205 bytes. To translate this overhead to a total increase in bandwidth, we look at a sample trace from CAIDA <ref type="bibr" target="#b2">[3]</ref>. The total number of packets observed for about 15 minutes was 37,571,701 with a total size of 28,475 MB. For each packet, ICING adds relative to an IP header (of 20 bytes) 205 -20 = 185 bytes (assuming path lengths have the same distribution across packet sizes). So the total increase in bandwidth for this dataset would be 37, 571, 701 × 185/(28, 475 × 2 20 ) = 23.3% relative to IP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">ICING hardware</head><p>We now measure the performance of the (fast path) hardware in our prototype ICING node, described in Section 5.</p><p>From Figure <ref type="figure">7</ref>, one might expect the cost of processing a packet to depend on the path length because the work of verifying Path Compliance and proving it seems proportional to the path length. However, the results of the various PRF-96 operations are XORed, so they can be parallelized in a pipeline and thus removed from the critical path. The only other heavily serialized function in the design is the hash function (HASH), so we expect it to be the bottleneck; i.e., throughput should depend on the number of bits that must be hashed. Since the only fields that are not hashed are the path index and the verifiers V j , we expect throughput to be lower when the V j 's represent a smaller fraction of the total packet bits. In other words, for a constant path length, we expect throughput to decrease as packet size increases.  <ref type="figure">10</ref>, row 1), path length (Fig. <ref type="figure">10</ref>, row 2), and path index (Fig. <ref type="figure">10</ref>, row 3). Percentages are relative to maximum possible throughput on the NetFPGA. Standard deviations are less than 0.02% of the means. The forwarder's throughput is lowest for packets with large payloads and small path lengths: such packets send the most bits through the hash function, which is the bottleneck.</p><p>We measure our prototype's fast path throughput by connecting the four ports of an ICING node to a NetFPGA packet generator <ref type="bibr" target="#b19">[20]</ref>. The ICING node loops ingress packets back to the generator, which measures the average bit rate. We take 5 10-second samples, using the parameters in Figure <ref type="figure">10</ref>.</p><p>Figure <ref type="figure">11</ref> plots the measured throughput. (Note that we do not report goodput; instead we report packet header overhead in Section 6.1.) The minimum aggregate throughput is 3.2 Gbit/s. The path index has no effect on performance because it doesn't affect the number of bits hashed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">ICING software</head><p>We now measure the performance of the (slow path) software in our prototype ICING node. We also measure end-host and consent server operations. Figure <ref type="figure" target="#fig_9">12</ref> summarizes.</p><p>Shared key (k i,j ) derivation. A packet invokes our prototype's slow path when the hardware does not have the required shared keys cached (Figure <ref type="figure">7</ref>). We measure the cost of deriving k i,j by running 3,000 iterations of the calculation function in a tight loop on the slow machine. On average, a single calculation takes 4 ms.</p><p>End-host. An end-host must also perform cryptographic operations: senders initialize all the verifier entries, and receivers validate and modify some of these entries. To understand these costs, we seek a linear function from path length  to processing time. To infer such a function, we vary path length per Figure <ref type="figure">10</ref>, take packet size to be 1,514 bytes, and collect 1,000 samples per path length on the medium machine. We record total processing cost (of either packet generation or verification, depending on sender or receiver; in both cases, we record the cost when the k i,j keys are and are not cached), and then use ordinary least squares linear regression. The inferred coefficients (R 2 &gt; 0.99) are in Figure <ref type="figure" target="#fig_9">12</ref>. Each entry in the path increases packet creation and verification times by 2.6 µs. For an average path length of 5, packet verification can be performed at 23K pkt/s.</p><p>Packet generation takes longer than verification because senders are so far unoptimized and compute HASH(P || M) twice. Were the endpoints optimized, receiving would likely be more expensive than sending: the receiver also hashes the packet (to verify V) and has an additional cost, namely recomputing the local PoC.</p><p>Consent server. To measure the cost of generating PoCs in software, we run the calculation function in a tight loop, varying path length per Figure <ref type="figure">10</ref>. We use the fast machine. We observe that cost is proportional to path length (Fig. <ref type="figure" target="#fig_9">12</ref>), as expected from the definition of PoC.proof ( §3). For a path length of 7, the consent server can generate ≈248k PoCs/s, within the range of rates handled by a fast DNS server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Scaling</head><p>We now give a rough assessment of whether an ICING node could meet the demands of the Internet backbone.</p><p>Throughput and cost. In assessing whether ICING could scale to backbone speeds, our metric is normalized cost: it measures the hardware cost, reported as equivalent gate count, per unit of throughput. As a baseline, we consider a simple IP router on the NetFPGA. We obtain gate counts as described in Section 5.</p><p>Figure <ref type="figure" target="#fig_3">13</ref> summarizes the comparison. Using our normalized cost metric, our ICING forwarder is ∼93% more expensive than the NetFPGA IP router. However, the IP router is a pessimistic baseline because it is bare bones: it has only a 32-entry TCAM for longest-prefix matching (commercial routers have far more, and the TCAM is a big consumer of logic area), and it does not have the functionality of commercial-grade routers (packet filtering, tunneling, etc.). On the other hand, almost all of ICING's processing can be parallelized, so it seems that there is no fundamental obstacle to scaling ICING to backbone speeds (around 100 Gbits/s). A rough estimate of the die size of an ASIC running ICING is in <ref type="bibr">[52, §2.5.4]</ref>. In summary, by moving to an ASIC with today's technology (say 40 nm), our design would be approximately 300 times smaller and three times faster (10 Gbps). Then, we could "spend" some of the area saved replicating processing logic to reach 100 Gbit/s.</p><p>PoP key cache. An ICING node N i stores a table of (N j , k i,j ) pairs. Would this cache be too expensive? There are fewer than 40k advertised AS numbers, and the total is growing at less than 3.2k/year <ref type="bibr" target="#b0">[1]</ref>. If we assume that each AS owns on average 10 nodes, the key cache would need to be approximately 400k entries. With 160-bit node IDs and 128bit PoP keys, fitting all of N i 's PoP keys would require less than 14 MB, which is within today's SRAM capabilities <ref type="bibr" target="#b3">[4]</ref>. Moreover, we believe that, to ease key management and policy configuration, providers would use the same node ID for many or all of their nodes. For further analysis of a nearly identical question, see <ref type="bibr">[7, §4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>We divide related work into: (1) secure routing and secure forwarding, (2) related mechanisms, and (3) policy routing. As noted in the introduction, ICING has many debts, but no work that we are aware of offers Path Consent and Path Compliance under our three environmental constraints.</p><p>Secure routing and forwarding. Routing security <ref type="bibr">[6, 16, 36-38, 40, 43, 70]</ref> ensures the authenticity and correctness of topology propagation and route computation. For instance, S-BGP <ref type="bibr" target="#b39">[40]</ref> protects BGP against spurious messages. However, these works do not ensure that the resulting routes are actually used in packet forwarding, which is ICING's focus and which we view as complementary.</p><p>Rule-Based Forwarding (RBF) <ref type="bibr" target="#b54">[55]</ref>, in which end-hosts get some control over forwarding functionality, is also complementary to ICING: the forwarder-specific rules could be named and invoked by ICING's tags, but by itself RBF does not provide Path Consent or Compliance.</p><p>Like ICING, other works bind packets to their purported paths. However, they do not target an environment that is high-speed and adversarial and federated. For instance, <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b53">54]</ref> use per-packet signatures and assume some centralization; <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b53">54]</ref> require large configuration state in the network and a packet header quadratic in path length; Ethane <ref type="bibr" target="#b18">[19]</ref> is centralized; and MPLS <ref type="bibr" target="#b56">[58]</ref> is not robust to misbehavior (two nodes on the path can collude to skip a third; more generally there is no proof that a packet follows its path).</p><p>Other work on forwarding security is geared toward secrecy or isolation. Virtual Private Networks (VPNs) (ei-ther point-to-point IPSec tunnels or isolated "slices" of a provider's network) provide neither Path Consent nor Path Compliance. Onion routing <ref type="bibr" target="#b20">[21]</ref> provides anonymity by onion-encrypting a source-routed packet, with one layer of encryption removed at every hop. ICING is reminiscent of onion routing's per-hop cryptography, but onion routing uses encryption and decryption at every hop to provide secrecy and anonymity while ICING uses PRFs and MACs to enforce Path Consent and Path Compliance.</p><p>Localizing faults <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b52">53,</ref><ref type="bibr" target="#b69">71]</ref> and providing availability in a Byzantine network <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b53">54]</ref> are also complementary. Other related works include denial-of-service (DoS) protection and allowing receivers to control which senders reach them <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b63">65,</ref><ref type="bibr" target="#b64">66,</ref><ref type="bibr" target="#b67">69]</ref>. These mechanisms can be enhanced to securely identify packets' senders <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b44">45]</ref>, enabling accountability. ICING likewise provides support for DoS protection and verifies not only sources but also paths.</p><p>Related mechanisms. Aspects of ICING are inspired by prior works. PoCs generalize network capabilities <ref type="bibr" target="#b55">[57,</ref><ref type="bibr" target="#b63">65,</ref><ref type="bibr" target="#b67">69]</ref> and Visas <ref type="bibr" target="#b23">[24]</ref>. For instance, under Platypus <ref type="bibr" target="#b55">[57]</ref>, senders choose overlay paths, and providers associate packets with accountable entities. Under TVA <ref type="bibr" target="#b67">[69]</ref>, receivers control which senders reach them. However, none of these works provides Path Consent or Path Compliance.</p><p>Other related mechanisms are as follows. Node IDs resemble the self-certifying <ref type="bibr" target="#b48">[49]</ref> ADs in AIP <ref type="bibr" target="#b6">[7]</ref> and HIP <ref type="bibr" target="#b50">[51]</ref>. PoPs are reminiscent of constructions in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13]</ref>. However in those works, the number of PoP-like things in a packet is quadratic in path length, whereas an ICING packet carries a linear number of PoPs. Using Diffie-Hellman key exchanges for creating pairwise keys between nodes (in analogy with ICING's PoP keys) is proposed in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b28">29]</ref>, but they suggest using a global directory or PKI, which ICING does not need (since node IDs are public keys). Also, ICING's hierarchical delegation generalizes a technique in Platypus <ref type="bibr" target="#b55">[57]</ref>, ICING's tags are reminiscent of Pathlets' vnodes <ref type="bibr" target="#b27">[28]</ref> and MPLS labels <ref type="bibr" target="#b56">[58]</ref>, and expressing policy in general-purpose servers apart from forwarding hardware echoes <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref>.</p><p>Policy routing. Like BGP, many works <ref type="bibr">[8, 28, 32, 33, 47, 59, 62-64, 67, 68, 70]</ref> allow entities to express path preferences. Under NIRA <ref type="bibr" target="#b65">[67]</ref>, for instance, senders choose the path into the Internet core, and receivers choose the path out. Indeed, even default-off and filtering can be regarded as policy routing, in that the receiver exercises control over the first path component, the sender (e.g., <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b63">65,</ref><ref type="bibr" target="#b64">66,</ref><ref type="bibr" target="#b67">69]</ref>).</p><p>These proposals are either orthogonal to ICING (because they concern only path computation, not enforcement), or else they incorporate a mechanism that enforces something less general than Path Consent and Path Compliance. For example, under Pathlets <ref type="bibr" target="#b27">[28]</ref>, senders choose paths, and providers specify policies based on the previous hop and a suffix of the path. But Pathlets does not provide verification that a path was actually followed. As another example, <ref type="bibr" target="#b66">[68]</ref> gives provider-approved path diversity but does not allow senders or receivers to determine paths. ICING can be re-garded as providing an enforcement mechanism that is general enough to enforce many of the policies in the works cited above. The next section discusses the price of this generality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">DISCUSSION</head><p>Does ICING restrict communication, as it empowers each node to enforce policy unilaterally? We note, first, that regardless of ICING, any carrier of a communication can exercise control over it. It is free to drop packets, deprioritize them, or corrupt them. Second, providers in the current Internet sometimes sever transit between each other to gain leverage in contract negotiations, effectively partitioning the Internet at users' expense (e.g., <ref type="bibr" target="#b70">[72]</ref>). Under ICING, end-points get multiple options about paths and providers, which could create competition where today monopoly reigns.</p><p>The generality of ICING ( §7) certainly has a price, as it is more expensive than many of the individual mechanisms that we have surveyed. However, we are solving a different problem than these other mechanisms: our goal is to provide a mechanism that can enforce a wide range of policies.</p><p>Moreover, it is possible to imagine cheaper PVMs than ICING, if we relax our requirements. As examples, if we assume a central authority (a reasonable assumption: the current Internet has IANA) that distributes a map from short identifiers to public keys, packets need not carry public keys, yielding smaller packet headers; or a PVM could check a fraction of the packets at a fraction of the cost; or if we allow per-flow state in nodes, then packets need not carry the full path, only a token that corresponds to it <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b67">69]</ref>.</p><p>We must also consider ICING's use complexity. At the network layer, there is some complexity from bootstrapping <ref type="bibr">[52, §4]</ref>. In an overlay, the interface to ICING is relatively simple (though obviously more involved than IP). Moreover, the overlay scenario may provide a path to deployment.</p><p>But this is looking ahead. Looking back, our animating question was whether it was possible to design a feasible PVM and, if so, what it would cost. This paper has attempted to answer that question.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 -</head><label>2</label><figDesc>Figure 2-Simplified ICING packet at steps and from Figure 1.Two crucial header fields are the path (P) and the verifiers (Vj's). The sender (N0) initializes the verifiers with path authenticators (Aj's) derived from the PoCs and the packet content. Each node Ni checks its own verifier (Vi) and updates the verifiers for downstream nodes (Vj for j &gt; i) to prove that it passed the packet. PoPi,j is a proof to Nj that Ni has carried the packet. ⊕ represents XOR.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>(a) The node derives the PoP key it shares with this upstream node (using the upstream's ID, from the path); (b) It computes the PoP (a MAC) under the PoP key. 3. It checks that the PoC and PoPs are correct.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 -</head><label>3</label><figDesc>Figure 3-Symbols and notation used in the pseudocode.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 -</head><label>5</label><figDesc>Figure5-ICING header. The per-node overhead is 42 bytes; we estimate the total overhead on the avg. packet to be &lt; 25% ( §6.1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 : 4 : 6 : 7 : 9 :Figure 6 -</head><label>146796</label><figDesc>Figure 6-Pseudocode for packet initialization. The sender initializes the verifiers before sending the packet to the first node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1 : 4 : 5 :T = current time 6 :j &lt; i do 19 : 32 :</head><label>14561932</label><figDesc>function RECEIVE(pkt) 2: P, M, V = pkt.P, pkt.M, pkt.V 3: i = pkt.path-idx Ni :tag i = i-th entry in P PoC i .expire = Vi.expire 7: if PoC i .expire &lt; T or Ni = my node ID then sN i :tag i = GET-TAG-KEY(mN i , tag i ) 10: PoC i .proof = vPRF(sN i :tag i , P || PoC i .expire) 11: H = HASH(P || M) 12:A i = PRF-96(PoC i .proof, -1 || H) 13: V i .proofs = A i 14: V i .hardener = PRF-32(PoC i .proof, 0 || H) 15: if V i .hardener = Vi.hardener then Nj = j-th node in P 20: kj,i = DHCache[Nj] or NIDH(xi, Nj, Ni) 21: PoPj,i = PRF-96(kj,i, j || H) 22: V i .proofs = V i .proofs ⊕ PoPj,i 23: if V i .proofs = Vi.proofs then downstream PoPs (prove Path Compliance) 26: for i ≤ j ≤ n do 27: Nj = j-th node in P 28: ki,j = DHCache[Nj] or NIDH(xi, Ni, Nj) 29: PoPi,j = PRF-96(ki,j, i || H) 30: Set Vj.proofs = Vj.proofs ⊕ PoPi,j 31: Set pkt.path-idx = i + 1 Add all calculated kx,y to DHCache 33:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 -</head><label>9</label><figDesc>Figure 9-Machines for measuring ICING overhead.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 -Figure 11 -</head><label>1011</label><figDesc>Figure 10-Parameters used throughout experiments. Packet size includes header.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 -</head><label>12</label><figDesc>Figure12-Processing time and throughput for software operations. x is the path length. Packet creation and verification costs are measured both with and without the use of cached shared keys (w/c and n/c resp.). For the last four rows, processing time is derived by linear regression, and R 2 &gt; 0.99 in all three cases.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Figure1-Forwarding in ICING. The sender logically gets PoCs from the consent servers of all nodes on the path (a consent server can delegate PoC-issuing, making this step lightweight). The sender creates and sends the packet to the first ICING node, having used the PoCs to construct tokens that each forwarder verifies and transforms for its successors until it arrives at the receiver.</figDesc><table><row><cell></cell><cell>Consent</cell><cell>Consent</cell><cell>Consent</cell></row><row><cell></cell><cell>Server 1</cell><cell>Server 2</cell><cell>Server 3</cell></row><row><cell></cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell>Sender</cell><cell>node 1</cell><cell>node 2</cell><cell>Receiver</cell></row><row><cell>2</cell><cell>3</cell><cell>4</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>M</head><label></label><figDesc>{vers, counter, proto, path-len, pkt-len, error-path-idx, payload}. A packet's static contents. P N 0 :tag 0 , N 1 :tag 1 , . . . , Nn :tag n . A packet's path: a list of node identifiers and corresponding tags. The p-bit-prefix key for tag t at node N i : an intermediate key, created by GET-TAG-KEY, that enables calculation of tag keys at node N i for any tag t with the same p-bit prefix as t's. Note that m N i :t/0 equals m N i for any t. s N i :tag i The tag key : used by a consent server for node N i to create a PoC for a path that includes N i :tag i . Amounts to m N i :tag i /32 . PoC i (PoC i .expire, PoC i .proof). Proof of Consent to path P by node N i . PoC i .expire A PoC's 16-bit expiration time indicator. PoC i .proof vPRF(s N</figDesc><table><row><cell>N i</cell><cell>A node's identifier: a public key.</cell></row><row><cell>x i</cell><cell>A node's private key: satisfies N i = g x i .</cell></row><row><cell>tag i</cell><cell>The tag corresponding to node N i on path P: an</cell></row><row><cell></cell><cell>opaque 32-bit string.</cell></row><row><cell>m N i</cell><cell>A node's master tag key: used in a key-derivation</cell></row><row><cell></cell><cell>function (GET-TAG-KEY) to associate key material</cell></row><row><cell></cell><cell>(tag keys) to any tag.</cell></row><row><cell>m N i :t/p</cell><cell></cell></row></table><note><p>i :tag i , P || PoC i .expire). A i PRF-96(PoC i .proof, -1 || HASH(P || M)). A packet's path authenticator for node N</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>V i .expire Same as PoC i .expire. V i .proofs A i ⊕ PoP 0,i ⊕ . . . ⊕ PoP i-1,i .</figDesc><table><row><cell>x i j ). (Hashed)</cell></row><row><cell>Non-interactive DiffieHellman key exchange.</cell></row><row><cell>vPRF(s, d) A keyed function that maps variable-length data d</cell></row><row><cell>to 128-bit pseudorandom outputs. The current</cell></row><row><cell>implementation uses PMAC [15].</cell></row><row><cell>PRF(k, d) A keyed function that maps 256-bit data to 128-bit</cell></row><row><cell>pseudorandom outputs. The current</cell></row><row><cell>implementation uses an optimized</cell></row><row><cell>AES-CBC-MAC.</cell></row></table><note><p>The PoP key: a symmetric key shared by nodes N i and N j , used for PoP computations. Soft state, derivable from nodes' identifiers. PoP i,j PRF-96(k i,j , i || HASH(P || M)). Proof of Provenance designated for N j : A MAC by which N i attests that it had approved a packet's path and handled it accordingly. V V 1 , . . . , Vn . A packet's verifier-vector. V i (V i .expire, V i .proofs, V i .hardener). Aggregate MAC by which N i checks out A i (and hence PoC i ), as well as PoP j,i , for j &lt; i. V i .hardener PRF-32(PoC i .proof, 0 || HASH(P || M)). Hardens forwarder slow path against DoS. NIDH(x i , N i , N j ) HASH2(SORT(N i , N j ) || N PRF-96(k, d) First 12 bytes of PRF(k, d). Suitable as a 128-bit message authentication code for d. PRF-32(k, d) Last 4 bytes of PRF(k, d).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>4, we extrapolateFigure 8-Summary of main evaluation results.</figDesc><table><row><cell cols="2">Average increase in packet overhead: 23.3%</cell><cell></cell><cell>§6.1</cell></row><row><cell cols="2">Throughput: 80-100% of IP on NetFPGA</cell><cell></cell><cell>§6.2</cell></row><row><cell cols="3">Normalized hardware cost: 193% of IP on NetGPA</cell><cell>§6.4</cell></row><row><cell cols="2">Machine type CPU</cell><cell>RAM</cell><cell>OS</cell></row><row><cell>slow</cell><cell>Intel Core 2 Duo 1.86 GHz</cell><cell cols="2">2 GB Linux 2.6.25</cell></row><row><cell>medium</cell><cell cols="3">Intel Core 2 Quad 2.40 GHz 4 GB Linux 2.6.25</cell></row><row><cell>fast</cell><cell>Intel quad Xeon 3.0 GHz</cell><cell cols="2">2 GB Linux 2.6.18</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>• 10 6 /(x + 3.5) PoC/s Create packet (w/c) 2.6x + 40.1 µs 3.9 • 10 5 /(x + 15.4) pkt/s Verify packet (w/c) 2.6x + 24.4 µs 3.9 • 10 5 /(x + 9.5) pkt/s Create packet (n/c) 33796.1x -32758.4 µs 29.6/(x -0.9) pkt/s Verify packet (n/c) 34875.1x -33647.1 µs 28.6/(x -0.9) pkt/s</figDesc><table><row><cell>Action</cell><cell>Processing time</cell><cell>Throughput (1/Proc. time)</cell></row><row><cell>Calculate k i,j</cell><cell>4 ms (σ = .043 ms)</cell><cell>250 keys/s</cell></row><row><cell>Generate PoC</cell><cell>0.4x + 1.3 µs</cell><cell>2.6</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Figure 13-Normalized costs of the NetFPGA ICING forwarder and the NetFPGA IP reference router.</figDesc><table><row><cell></cell><cell>NetFPGA ICING</cell><cell>NetFPGA IP</cell></row><row><cell>Min Throughput (Gbits/s)</cell><cell>3.2 (from  §6.2)</cell><cell>4</cell></row><row><cell>(Eq.) Gate Count (Gates)</cell><cell cols="2">13.4M (from  §5) 8.7M (from  §5)</cell></row><row><cell cols="2">Normalized Cost (Gates/(Gbits/s)) 4.2M</cell><cell>2.2M</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Recent work<ref type="bibr" target="#b22">[23]</ref> has examined high-speed software forwarders. However, backbone forwarders seem likely to continue to require dedicated hardware for the medium-term future. Besides, our design, being parallelizable, can run efficiently on multicore general-purpose processors.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Each version of ICING hard-codes particular cryptographic algorithms. As algorithms are later broken or require longer key lengths, we expect the choices of algorithms and key lengths to change but not the primitives (pseudo-random functions (PRFs), collision-resistant hash functions, etc.)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This inconvenience could be mitigated by modifying ICING to add a level of indirection in naming.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Naous's work was done at Stanford; Walfish's was done partially at Stanford and UCL. ICING has a long list of debts, beginning with one to Scott Shenker, who gave many and much-needed crucial expository suggestions. Dave  Andersen, Tom Anderson, Russ Cox, Brandon Heller, and Jennifer Rexford read drafts carefully and kindly spent hours to help improve the presentation. We are likewise grateful to the CoNEXT reviewers, who read our work carefully. Comments and conversations that improved our presentation were given by Hari Balakrishnan, Andrew Blumberg, Dan Boneh, Mike Dahlin, Dawson Engler, Nick Feamster, Sanjam Garg, Sharon Goldberg, Mark Handley, Steve Keckler, Ramesh Johari, Josh Leners, Nick McKeown, Guru Parulkar, Ivo Popov, Srinath Setty, and Emmett Witchel. Hao Wu assisted in the evaluation of ICING. We thank our shepherd Laurent Mathy for his support and critiques. For their support, advocacy, and generosity, we thank Lorenzo Alvisi, Mike Dahlin, Nick McKeown, and Jonathan Smith. This work was supported by NSF grants 1040083 (FIA), 1040784 (FIA), 1040190 (FIA), 0716806, 1052985, 0627112, and 1117679; by AFOSR grant FA9550-10-1-0073; by ONR grant N00014-09-10757; by the Stanford Clean Slate program; and by Intel Corporation, whose gift to Brad Karp supported Walfish and Mazières while they visited Karp at UCL in Autumn 2008. Source for our hardware and software is available at: http://www.cs.utexas.edu/icing.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.potaroo.net/tools/asn32/index.html" />
		<title level="m">The 32-bit autonomous system number report</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://netfpga.org" />
		<title level="m">NetFPGA: Programmable networking hardware</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://mawi.wide.ad.jp/mawi/samplepoint-F/2011/201101231400.html" />
		<title level="m">Packet traces from wide backbone</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://www.cypress.com/?id=95" />
		<title level="m">Sync SRAMs overview</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<orgName type="collaboration">DSS</orgName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Federal Information Processing Standards Publication</title>
		<imprint>
			<date type="published" when="2008-11">November 2008</date>
			<biblScope unit="page" from="186" to="189" />
		</imprint>
	</monogr>
	<note>Digital signature standard</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Origin authentication in interdomain routing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Aiello</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2003-10">Oct. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Accountable Internet protocol</title>
		<author>
			<persName><forename type="first">D</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2008-08">Aug. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Loose source routing as a mechanism for traffic policies</title>
		<author>
			<persName><forename type="first">K</forename><surname>Argyraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2004-09">Sept. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Network capabilities: The good, the bad and the ugly</title>
		<author>
			<persName><forename type="first">K</forename><surname>Argyraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cheriton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotNets</title>
		<imprint>
			<date type="published" when="2005-11">Nov. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Highly secure and efficient routing</title>
		<author>
			<persName><forename type="first">I</forename><surname>Avramopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INFOCOM</title>
		<imprint>
			<date type="published" when="2004-03">Mar. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Simple key-management for Internet Protocol (SKIP)</title>
		<author>
			<persName><forename type="first">A</forename><surname>Aziz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Baehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc of the INET Conference</title>
		<meeting>of the INET Conference</meeting>
		<imprint>
			<date type="published" when="1995-06">June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Off by default! In HotNets</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chawathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-11">Nov. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Protocols and lower bounds for failure localization in the Internet</title>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROCRYPT</title>
		<meeting>EUROCRYPT</meeting>
		<imprint>
			<date type="published" when="2008-04">Apr. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Hierarchical packet fair queueing algorithms</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C R</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM/IEEE Trans. on Networking</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="675" to="689" />
			<date type="published" when="1997-10">Oct. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A block-cipher mode of operation for parallelizable message authentication</title>
		<author>
			<persName><forename type="first">J</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROCRYPT</title>
		<meeting>EUROCRYPT</meeting>
		<imprint>
			<date type="published" when="2002-04">Apr. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A survey of BGP security issues and solutions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Farley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="2010-01">Jan. 2010</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="100" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Design and implementation of a routing control platform</title>
		<author>
			<persName><forename type="first">M</forename><surname>Caesar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Caldwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shaikh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Der Merwe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2005-05">May 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Separating routing and forwarding: A clean-slate network layer design</title>
		<author>
			<persName><forename type="first">K</forename><surname>Calvert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Griffioen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Poutievski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Broadnets</title>
		<meeting>IEEE Broadnets</meeting>
		<imprint>
			<date type="published" when="2007-09">Sept. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Ethane: Taking control of the enterprise</title>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2007-08">Aug. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A packet generator on the NetFPGA platform</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Covington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Lockwood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Field-Programmable Custom Computing Machines</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Tor: the second-generation onion router</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dingledine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mathewson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Syverson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX SECURITY</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Phalanx: Withstanding multimillion-node botnets</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2008-04">Apr. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Routebricks: exploiting parallelism to scale software routers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dobrescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Egi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Argyraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-G</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Iannaccone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Knies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Manesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">VISA protocols for controlling inter-organizational datagram flow</title>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mogul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tsudik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE JSAC</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1989-05">May 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Inter-domain MPLS and GMPLS traffic engineering -resource reservation protocol-traffic engineering (RSVP-TE) extensions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ayyangar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vasseur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">5151</biblScope>
			<date type="published" when="2008-02">Feb. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Proactive Techniques for Correct and Predictable Internet Routing</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Feamster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">M.I.T</title>
		<imprint>
			<date type="published" when="2005-09">Sept. 2005</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Network ingress filtering: Defeating denial of service attacks which employ IP source address spoofing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Ferguson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Senie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">2827</biblScope>
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Pathlet routing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ganichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2009-08">Aug. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Path-quality monitoring in the presence of adversaries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMETRICS</title>
		<imprint>
			<date type="published" when="2008-06">June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">A clean slate 4D approach to network control and management</title>
		<author>
			<persName><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hjalmtysson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Maltz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-10">Oct. 2005</date>
			<publisher>ACM CCR</publisher>
			<biblScope unit="volume">35</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">NOX: Towards an Operating System for Networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM CCR</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="105" to="110" />
			<date type="published" when="2008-07">July 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An end-middle-end approach to connection establishment</title>
		<author>
			<persName><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2007-08">Aug. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Improving the reliability of Internet paths with one-hop source routing</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Gummadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Gribble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2004-12">Dec. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Steps towards a DoS-resistant Internet architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Greenhalgh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM Wkshp. on Future Directions in Net. Arch</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Submission to the SHA-3 competition: The CHI family of cryptographic hash algorithms. Submission to NIST</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hawkes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mcdonald</surname></persName>
		</author>
		<ptr target="http://ehash.iaik.tugraz.at/uploads/2/2c/Chi_submission.pdf" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A survey of secure wireless ad hoc routing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security and Privacy Magazine</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="28" to="39" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Efficient security mechansims for routing protocols</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2003-02">Feb. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">SPV: Secure path vector routing for securing BGP</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sirbu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2004-09">Sept. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Aggregate message authentication codes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology -CT-RSA</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2008-04">April 2008</date>
			<biblScope unit="volume">4964</biblScope>
			<biblScope unit="page" from="155" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Secure border gateway protocol (S-BGP)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lynn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Seo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE JSAC</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2000-04">Apr. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">SOS: Secure overlay services</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Misra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rubenstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Click modular router. ACM TOCS</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="263" to="297" />
			<date type="published" when="2000-11">Nov. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">PHAS: A prefix hijack alert system</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Massey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX SECURITY</title>
		<imprint>
			<date type="published" when="2006-07">July 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Bootstrapping accountability in the Internet we have</title>
		<author>
			<persName><forename type="first">A</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2011-04">Apr. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Passport: Secure and adoptable source authentication</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2008-04">Apr. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">To filter or to authorize: Network-layer DoS defense against multimillion-node botnets</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2008-08">Aug. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Mutually controlled routing with independent ISPs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2007-04">Apr. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Towards an accurate AS-level traceroute tool</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Separating key management from file system security</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="1999-12">Dec. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">PoComON: A POlicy-COMpliant Overlay Network</title>
		<author>
			<persName><forename type="first">M</forename><surname>Miller</surname></persName>
		</author>
		<idno>HR-11-04</idno>
		<imprint>
			<date type="published" when="2011-10">Oct. 2011</date>
			<pubPlace>UT Austin</pubPlace>
		</imprint>
		<respStmt>
			<orgName>CS Dept</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>honors thesis</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Host identity protocol (HIP) architecture</title>
		<author>
			<persName><forename type="first">R</forename><surname>Moskowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nikander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">4423</biblScope>
			<date type="published" when="2006-05">May 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Path-policy Compliant Networking and a Platform for Heterogeneous IAAS Management</title>
		<author>
			<persName><forename type="first">J</forename><surname>Naous</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011-03">Mar. 2011</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Secure traceroute to detect faulty or malicious routing</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Padmanabhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2003-08">Aug. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Network layer protocols with Byzantine robustness</title>
		<author>
			<persName><forename type="first">R</forename><surname>Perlman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Building extensible networks with rule-based forwarding</title>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Egi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2010-10">Oct. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A system for authenticated policy-compliant routing</title>
		<author>
			<persName><forename type="first">B</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Snoeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2004-09">Sept. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Multiprotocol label switching</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Viswanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Callon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RFC</title>
		<imprint>
			<biblScope unit="volume">3031</biblScope>
			<date type="published" when="2001-01">Jan. 2001</date>
		</imprint>
		<respStmt>
			<orgName>Network Working Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Routescience</forename><surname>Pathcontrol</surname></persName>
		</author>
		<ptr target="http://www.networkworld.com/reviews/2002/0415rev.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
		<ptr target="https://www.shamus.ie/index.php?page=Downloads" />
		<title level="m">Miracl library</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A policy framework for the future Internet</title>
		<author>
			<persName><forename type="first">A</forename><surname>Seehra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naous</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nicolosi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotNets</title>
		<imprint>
			<date type="published" when="2009-10">Oct. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Internet Indirection Infrastructure</title>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Adkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhuang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Surana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2002-08">Aug. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Middleboxes no longer considered harmful</title>
		<author>
			<persName><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stribling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2004-12">Dec. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">MIRO: Multi-path interdomain routing</title>
		<author>
			<persName><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2006-09">Sept. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">SIFF: A stateless Internet flow filter to mitigate DDoS flooding attacks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2004-05">May 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">StackPi: New packet marking and filtering mechanisms for DDoS and IP spoofing defense</title>
		<author>
			<persName><forename type="first">A</forename><surname>Yaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE JSAC</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1853" to="1863" />
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">NIRA: A new inter-domain routing architecture</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM/IEEE Trans. on Networking</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007-08">Aug. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Source selectable path diversity via routing deflections</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2006-09">Sept. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">TVA: A DoS-limiting network architecture</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM/IEEE Trans. on Networking</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1267" to="1280" />
			<date type="published" when="2008-12">Dec. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">SCION: Scalability, control, and isolation on next-generation networks</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-C</forename><surname>Hsiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hasker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Andersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2011-05">May 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Packet-dropping adversary identification for data plane security</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CoNEXT</title>
		<imprint>
			<date type="published" when="2008-12">Dec. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Zmijewski</surname></persName>
		</author>
		<ptr target="http://www.renesys.com/blog/2008/03/you-cant-get-there-from-here-1.shtml" />
		<title level="m">You can&apos;t get there from here</title>
		<imprint>
			<date type="published" when="2008-03">Mar. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
