<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Pyomo: modeling and solving mathematical programs in Python</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-08-10">10 August 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">William</forename><forename type="middle">E</forename><surname>Hart</surname></persName>
							<email>wehart@sandia.gov</email>
						</author>
						<author>
							<persName><forename type="first">Jean-Paul</forename><surname>Watson</surname></persName>
							<email>jwatson@sandia.gov</email>
						</author>
						<author>
							<persName><forename type="first">David</forename><forename type="middle">L</forename><surname>Woodruff</surname></persName>
							<email>dlwoodruff@ucdavis.edu</email>
						</author>
						<author>
							<persName><forename type="first">J.-P</forename><surname>Watson</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Data Analysis and Informatics Department</orgName>
								<orgName type="department" key="dep2">Sandia National Laboratories</orgName>
								<address>
									<postBox>PO Box 5800</postBox>
									<postCode>1318, 87185</postCode>
									<settlement>Albuquerque</settlement>
									<region>MS, NM</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Discrete Math and Complex Systems Department</orgName>
								<orgName type="department" key="dep2">Sandia National Laboratories</orgName>
								<address>
									<postBox>PO Box 5800</postBox>
									<postCode>1318, 87185</postCode>
									<settlement>Albuquerque</settlement>
									<region>MS, NM</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Graduate School of Management</orgName>
								<orgName type="institution">University of California Davis</orgName>
								<address>
									<postCode>95616-8609</postCode>
									<settlement>Davis</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Pyomo: modeling and solving mathematical programs in Python</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-08-10">10 August 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">5DFBC58CA3516440C0098EC8076D3CC0</idno>
					<idno type="DOI">10.1007/s12532-011-0026-8</idno>
					<note type="submission">Received: 29 December 2009 / Accepted: 13 June 2011 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:15+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Python</term>
					<term>Algebraic modeling language</term>
					<term>Optimization</term>
					<term>Open source optimization software Mathematics Subject Classification (2000) 90C99</term>
					<term>93A30</term>
					<term>97N80</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We describe Pyomo, an open source software package for modeling and solving mathematical programs in Python. Pyomo can be used to define abstract and concrete problems, create problem instances, and solve these instances with standard open-source and commercial solvers. Pyomo provides a capability that is commonly associated with algebraic modeling languages such as AMPL, AIMMS, and GAMS. In contrast, Pyomo's modeling objects are embedded within a full-featured highlevel programming language with a rich set of supporting libraries. Pyomo leverages the capabilities of the Coopr software library, which together with Pyomo is part of IBM's COIN-OR open-source initiative for operations research software. Coopr integrates Python packages for defining optimizers, modeling optimization applications, and managing computational experiments. Numerous examples illustrating advanced scripting applications are provided.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The Python Optimization Modeling Objects (Pyomo) software package supports the definition and solution of optimization applications using the Python scripting language. Python is a powerful high-level programming language that has a very clear, readable syntax and intuitive object orientation. Pyomo includes Python classes for defining sparse sets, parameters, and variables, which can be used to formulate algebraic expressions that define objectives and constraints. Pyomo can be used to represent linear, mixed-integer, non-linear, and non-linear mixed-integer models for large-scale, real-world problems that involve thousands of constraints and variables.</p><p>The introduction of Pyomo was motivated by a variety of factors that impact optimization applications at Sandia National Laboratories, a large US Department of Energy Laboratory at which two of the co-authors are employed. Sandia's discrete mathematics group has successfully used AMPL <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">19]</ref> to model and solve large-scale integer programs for many years. Our application experience highlighted the value of Algebraic Modeling Languages (AMLs) for solving real-world optimization applications, and AMLs are now an integral part of operations research solutions at Sandia.</p><p>Our experience with these applications has also highlighted the need for more flexible AML frameworks. For example, direct integration with a high-level programming language is needed to allow modelers to leverage modern programming constructs, ensure cross-platform portability, and access the broad range of functionality found in standard software libraries. AMLs also need to support extensibility of the core modeling language and associated solver interfaces, since complex applications typically require some degree of customization. Finally, open-source licensing is required to manage costs associated with the deployment of optimization solutions, and to facilitate the integration of modeling capabilities from a broader technical community.</p><p>Pyomo was developed to provide an open-source platform for developing optimization models that leverages Python's rich high-level programming environment to facilitate the development and deployment of optimization capabilities. Pyomo is not intended to facilitate modeling better than existing, primarily commercial AML tools. Instead, it supports a different modeling approach in which the software is designed for flexibility, extensibility, portability, and maintainability. At the same time, Pyomo incorporates the central ideas in modern AMLs, e.g., differentiation between abstract models and concrete problem instances.</p><p>Pyomo is a component of the Coopr software library, a COmmon Optimization Python Repository <ref type="bibr" target="#b10">[12]</ref>. Coopr includes a flexible framework for applying optimizers to analyze Pyomo models, interfaces to well-known linear, mixed-integer, and nonlinear solvers, and provides an architecture that supports parallel solver execution. Coopr also includes an installation utility that automatically installs the diverse set of Python packages that are used by Pyomo. Coopr is hosted both as part of IBM's COIN-OR open-source software initiative for operations research [10] and at Sandia, and it is actively developed and maintained by Sandia and its collaborators.</p><p>The remainder of this paper is organized as follows. Section 2 describes the motivation and design philosophy behind Pyomo, and Sect. 3 discusses why Python was chosen for the design of Pyomo. Section 4 describes related high-level modeling approaches, and Pyomo is briefly contrasted with other Python-based modeling tools.</p><p>In Sect. 5, we discuss the novelty and impact of Pyomo, answering the related questions "Why another AML?" and "Why Pyomo?". Section 6 describes the use of Pyomo on a simple application that is also described in AMPL for comparison, introduces a number of advanced features of Pyomo, and discusses Pyomo run-time performance. Section 7 describes how Pyomo leverages the broader solver capabilities in Coopr. Section 8 illustrates the use of Pyomo by discussing a number of advanced case studies. Section 9 provides information for getting started with Coopr, and Sect. 10 describes future work that is planned for Pyomo and Coopr.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design goals and requirements</head><p>The following sections describe the design goals and requirements that have guided the development of Pyomo. The design of Pyomo has been driven by two different types of projects at Sandia. First, Pyomo has been used by research projects that require a flexible framework for customizing the formulation and evaluation of optimization models. Second, projects with external customers frequently require that optimization modeling techniques be deployed without the need for commercial licenses. -Transparency and reliability When managed well, open source projects facilitate transparency in software design and implementation. Because any developer can study and modify the software, bugs and performance limitations can be identified and resolved by a wide range of developers with diverse software experience. Consequently, there is growing evidence that managing software as open source can improve its reliability and that open source software exhibits similar defect evolution patterns as proprietary software <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b50">56]</ref>. -Flexible licensing A variety of significant operations research applications at Sandia have required the use of a modeling tool with a non-commercial and noninfectious license. There have been many different reasons for this requirement, including the need to support open source analysis tools, limitations for software deployment on classified computers, and licensing policies for commercial partners (e.g., who are motivated to minimize the cost of deploying an application model internally within their company). The Coopr software library, which contains Pyomo, is licensed under the BSD <ref type="bibr" target="#b8">[9]</ref>. BSD has fewer restrictions for commercial use than alternative open source licenses like the GPL <ref type="bibr" target="#b21">[24]</ref>, and is non-infectious.</p><p>The use of an open source software development model is not a panacea; ensuring high reliability of the software still requires careful management and a committed developer community. However, there is increasing recognition that open source software provides many advantages beyond simple cost savings <ref type="bibr" target="#b9">[11]</ref>, including supporting open standards and avoiding being locked into a single vendor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Customizable capability</head><p>A key limitation of proprietary commercial modeling tools is their limited support for customization of the modeling components or optimization processes. Pyomo's open source project model allows a diverse range of developers to prototype new capabilities. Thus, developers can customize the software for specific applications, and they can prototype capabilities that may eventually be integrated into future software releases.</p><p>More generally, Pyomo is designed to support a "stone soup" development model in which each developer "scratches their own itch." A key element of this design is the plugin framework that Pyomo uses to integrate software components like optimizers, optimizer managers, and optimizer model format converters. The plugin framework manages the registration of components, and it automates the interaction of these components through well-defined interfaces. Thus, users can customize Pyomo in a modular manner without the risk of destabilizing core functionality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Solver integration</head><p>Modeling tools can be roughly categorized into two classes based on how they integrate with optimization solvers. Tightly coupled modeling tools directly access optimization solver libraries (e.g., via static or dynamic linking). In contrast, loosely coupled modeling tools apply external optimization executables (e.g., through the use of system calls). Of course, these options are not exclusive, and a goal of Pyomo is to support both types of solver interfaces.</p><p>This design goal has led to a distinction in Pyomo between model formulation and optimizer execution. Pyomo uses a high level (scripting) programming language to formulate a problem that can be solved by optimizers written in low-level (compiled) languages. This two-language approach leverages the flexibility of the high-level language for formulating optimization problems and the efficiency of the low-level language for numerical computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Abstract models and concrete instances</head><p>A requirement of Pyomo's design is that it support the definition of abstract models in a manner similar to that of AMPL <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">19]</ref> and AIMMS <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b41">47]</ref>. An abstract model separates the declaration of a model from the data used to generate a specific model instance; the advantages of this approach are widely appreciated, e.g., see <ref type="bibr">[18, p. 35]</ref>. This separation provides an extremely flexible modeling capability, which has been leveraged extensively in optimization applications developed at Sandia.</p><p>To mimic this capability, Pyomo uses a symbolic representation of data, variables, constraints, and objectives. Model instances are then generated from external data sources using construction routines that are provided by the user when defining sets, parameters, and other modeling components. Further, Pyomo is designed to use data specified in the AMPL format to facilitate the translation of models between AMPL and Pyomo.</p><p>Pyomo can also create concrete instances directly from specific parameter data, bypassing the abstract modeling layer. This functionality is similar to that provided in the open-source modeling tools PuLP and PyMathProg, in addition to capabilities in many commercial AMLs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Flexible modeling language</head><p>Another goal of Pyomo is to directly use a modern high-level programming language to support the definition of optimization models. In this manner, Pyomo is similar to tools like FlopC++ <ref type="bibr" target="#b15">[17]</ref> and OptimJ <ref type="bibr" target="#b31">[36]</ref>, which support modeling in C++ and Java, respectively. The use of a broad-based high-level programming language to develop optimization models has several advantages:</p><p>-Extensibility and robustness A widely used high-level programming language provides a robust foundation for developing and solving optimization models: the language has been well-tested in a wide variety of application contexts and deployed on a range of computing platforms. Further, extensions almost never require changes to the core language but instead involve the definition of additional classes and functional routines that can be immediately leveraged in the modeling process. Further, support of the language itself is not a long-term factor when managing software releases. -Documentation Modern high-level programming languages are typically well-documented, and there is often a large on-line community to provide feedback to new users. -Standard libraries Languages like Java and Python have a rich set of libraries for tackling just about every conceivable programming task. For example, standard libraries can support capabilities like data integration (e.g., working with spreadsheets), thereby avoiding the need to directly support such capabilities in a modeling tool.</p><p>An additional benefit of basing Pyomo on a general-purpose high-level programming language is that we can directly support modern programming language features, including classes, looping and procedural constructs, and first-class functions-all of which can be critical when defining complex models. By contrast, such features are not uniformly available in commercial AMLs.</p><p>Pyomo is implemented in Python, a powerful dynamic programming language that has a very clear, readable syntax and intuitive object orientation. However, when compared with AMLs like AMPL, Pyomo has a more verbose and complex syntax. For example, declarations like set definitions can be expressed as inlined-functions in AMPL, but they require a more verbose syntax in Python because it supports a more generic computing model. Thus, a key issue with this approach concerns the target user community and their level of comfort with standard programming concepts.</p><p>Our examples in this paper compare and contrast AMPL and Pyomo models, which illustrate this trade-off.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Portability</head><p>A requirement of Pyomo's design is that it work on a diverse range of computing platforms. In particular, inter-operability between Microsoft Windows, Linux, and Macintosh platforms is a key requirement for many Sandia applications. For example, user front-ends are often GUIs on a Windows platform, while the computational backend may reside on a Linux cluster. The main impact of this requirement has been to limit the choice of the high-level programming language used to develop Pyomo. In particular, the Microsoft. Net languages were not considered for the design of Pyomo due to portability considerations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Why Python?</head><p>We chose to develop Pyomo using the Python <ref type="bibr" target="#b38">[44]</ref> programming language for a variety of reasons. First, Python meets the criteria outlined in the previous section: We considered several other popular programming languages prior to developing Pyomo. However, in most cases Python appears to have distinct advantages:</p><p>-.Net As mentioned earlier, the Microsoft. Net languages are not portable to Linux platforms, and thus they were not suitable for Pyomo. -Ruby At the moment, Python and Ruby appear to be the two most widely recommended scripting languages that are portable to Linux platforms, and comparisons suggest that their core functionality is similar. Our preference for Python is based in part on the fact that it has a nice syntax that does not require users to enter obtuse symbols (e.g., $, %, and @). Thus, we expect Python will be a more natural language for expressing optimization models. Further, the Python libraries are more integrated and comprehensive than those for Ruby. -Java Java has many of the same strengths as Python, and it is arguably as good a choice for the development of Pyomo. However, Python has a powerful interactive interpreter that allows real-time code development and encourages experimentation with Python software. Thus, users can work interactively with Pyomo models to become familiar with these objects and to diagnose bugs. -C++ Models formulated with the FlopC++ <ref type="bibr" target="#b15">[17]</ref> package are similar to models developed with Pyomo. Specifically, the models are specified in a declarative style using classes to represent model components (e.g., sets, variables, and constraints). However, C++ requires explicit compilation to execute code, and it does not support an interactive interpreter. Thus, we believe that Python will provide a more flexible language for users.</p><p>Finally, we note that run-time performance was not a key factor in our decision to use Python. Recent empirical comparisons suggest that scripting languages offer reasonable alternatives to languages like C and C++, even for tasks that must handle fair amounts of computation and data <ref type="bibr" target="#b33">[38]</ref>. Further, there is evidence that dynamically typed languages like Python allow users to be more productive than with statically typed languages like C++ and Java <ref type="bibr" target="#b39">[45,</ref><ref type="bibr" target="#b47">53]</ref>. It is widely acknowledged that Python's dynamic typing and compact, concise syntax facilitates rapid software development. Thus, it is not surprising that Python is widely used in the scientific community <ref type="bibr" target="#b30">[34]</ref>. Large Python projects like SciPy <ref type="bibr" target="#b26">[30]</ref> and SAGE <ref type="bibr" target="#b44">[50]</ref> strongly leverage a diverse set of Python packages to perform complex numerical calculations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Background</head><p>A variety of different strategies have been developed to facilitate the formulation and solution of complex optimization models. For restricted problem domains, optimizers can be directly interfaced with application modeling tools. For example, modern spreadsheets like Excel integrate optimizers that can be applied to linear programming and simple nonlinear programming problems in a natural way.</p><p>AMLs are an alternative approach that allows applications to be interfaced with optimizers that can exploit problem structure. AMLs are specialized high-level programming languages for describing and solving mathematical problems, particularly optimization-related problems <ref type="bibr" target="#b27">[31]</ref>. AMLs like AIMMS <ref type="bibr" target="#b1">[2]</ref>, AMPL <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b17">19]</ref>, and GAMS [21] provide programming languages with an intuitive mathematical syntax that support concepts like sparse sets, indices, and algebraic expressions. AMLs provide a mechanism for defining variables and generating constraints with a concise mathematical representation, which is essential for large-scale, real-world problems that involve thousands or millions of constraints and variables.</p><p>Standard programming languages can also be used to formulate optimization models when used in conjunction with a software library that uses object-oriented design to support mathematical concepts. Although these modeling libraries sacrifice some of the intuitive mathematical syntax of an AML, they allow the user to leverage the greater flexibility of standard programming languages. For example, modeling tools like FlopC++ <ref type="bibr" target="#b15">[17]</ref> and OptimJ <ref type="bibr" target="#b31">[36]</ref> can be used to formulate and solve optimization models in C++ and Java, respectively.</p><p>A related strategy is to use a high-level programming language to formulate optimization models, which are then solved with optimizers written in low-level languages. This two-language approach leverages the flexibility of the high-level language for formulating and manipulating optimization problems and the efficiency of the lowlevel language for numerical computations. This approach is increasingly common in scientific computing tools, and the Matlab TOMLAB Optimization Environment <ref type="bibr" target="#b46">[52]</ref> is probably the most mature optimization software using this approach. Python has also been used to implement a variety of optimization packages that use this approach:</p><p>-APLEpy A package that can be used to describe linear programming and mixedinteger linear programming optimization problems <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b28">32]</ref>. -CVXOPT A package for convex optimization <ref type="bibr" target="#b12">[14]</ref>.</p><p>-PuLP A package that can be used to describe linear programming and mixed-integer linear programming optimization problems <ref type="bibr" target="#b34">[40]</ref>. -POAMS A modeling tool for linear and mixed-integer linear programs that defines Python objects for symbolic sets, constraints, objectives, decision variables, and solver interfaces. -PyMathProg A package that includes PyGLPK, which encapsulates the functionality of the GNU Linear Programming Kit (GLPK) <ref type="bibr" target="#b35">[41]</ref>. -OpenOpt A numerical optimization framework that is closely coupled with the SciPy scientific Python package <ref type="bibr">[35]</ref>.</p><p>Pyomo is closely related to APLEpy, PyMathProg, PuLP, and POAMS. All of these packages define Python objects that can be used to express optimization models, but they can be distinguished according to the extent to which they support abstract models. Abstract models provide a data-independent specification of a mathematical program. Fourer and Gay <ref type="bibr" target="#b17">[19]</ref> summarized the advantages of abstract models when presenting AMPL:</p><p>-The statement of the abstract model can be made compact and understandable -The independent specification of an abstract model facilitates the specification of the validity of the associated data -Data from different sources can be used with the abstract model, depending on the computing environment PuLP and PyMathProg do not support abstract models; the concrete models that can be constructed by these tools are driven by explicit data. APLEpy supports symbolic definitions of set and parameter data, but the objective and constraint specifications are concrete. POAMS and Pyomo support abstract models, which can be used to generate concrete instances from various data sources. Pyomo also provides an automated construction process for generating concrete instances from an abstract model. Hart <ref type="bibr" target="#b23">[26]</ref> provides Python examples that illustrate the differences between PuLP, POAMS and Pyomo.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Why Pyomo: the value proposition</head><p>Before introducing Pyomo and subsequently illustrating advanced capabilities and scripting features, we first discuss the "value proposition" for Pyomo. In other words, we will address the related questions of "Why another AML?" and "Why Pyomo in particular?" In doing so, we argue that Pyomo holds a unique position in the field of both commercial and open-source AMLs. In what follows, we provide forward references to subsequent sections containing examples that support our arguments. Our immediate goal in this section is simply to outline the arguments.</p><p>The following features are what we view as the primary benefits of Pyomo:</p><p>-Open-source with flexible licensing As we argued in Sects. the comparable ease with which applications requiring advanced scripting can be developed. For complex optimization applications-beyond those requiring a simple "express model, generate model, solve model" capability, such scripting is often integral to successful deployment. Of course, it is difficult to quantify "ease" in this context, and we make no attempt to do so here. Rather, we point to specific examples illustrated in Sect. 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Pyomo: an overview</head><p>Pyomo can be used to define abstract models, create concrete problem instances (both directly and from abstract models), and solve those instances with standard solvers. Pyomo can generate problem instances and apply optimization solvers within a fully expressive programming language. Python's clean syntax allows Pyomo to express mathematical concepts in a reasonably intuitive and concise manner. Further, Pyomo can be used within an interactive Python shell, thereby allowing a user to interactively interrogate Pyomo-based models. Thus, Pyomo has most of the advantages of both AML interfaces and modeling libraries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">A simple example</head><p>In this section, we illustrate Pyomo's syntax and capabilities by demonstrating how a simple AMPL example can be replicated with Pyomo Python code. We focus here on the specification of symbolic or abstract models; concrete or directly specified models are discussed in Sect. 6.3.</p><p>Consider the following AMPL model prod.mod, which is available from http:// www.ampl.com/BOOK/EXAMPLES/EXAMPLES1:</p><p>To translate this AMPL model into Pyomo, the user must first import the Pyomo Python package and create a Pyomo AbstractModel object:</p><p>This import assumes that Pyomo is present in the user's Python path (see standard Python documentation for further details about the PYTHONPATH environment variable); the virtual Python executable installed by the Coopr installation script described in Sect. 9 automatically includes all requisite paths.</p><p>Next, we create the sets and parameters that correspond to the data declarations used in the AMPL model. This can be done very intuitively using the Set and Param classes defined by Pyomo: Note that the parameter b is a scalar, while parameters a, c, and u are arrays indexed by the set P. Further, we observe that all AML components in Pyomo (e.g., parameters, sets, variables, constraints, and objectives) are explicitly associated with a particular model. This allows Pyomo to automatically manage the naming of AML components, and multiple Pyomo models can be simultaneously defined and co-exist within a single application.</p><p>Next, we define the decision variables in the model using the Pyomo Var class: Model parameters and decision variables are used in the definition of the objectives and constraints in the model. Parameters define constants, and the variable values are determined via optimization. Parameter values can be defined in a separate data file that is processed by Pyomo (see Sect. 6.5), similar to the paradigm used in AMPL and AIMMS.</p><p>Objectives and constraints are explicitly defined expressions in Pyomo. In abstract models, the Objective and Constraint classes require a rule keyword option that specifies how these expressions are to be constructed. A rule is a function that takes one or more arguments and returns an expression that defines the constraint (body and bounds) or objective (expression). The last argument in a rule is the model containing the corresponding objective or constraint, and the preceding arguments are index values for the objective or constraint that is being defined. If only a single argument is supplied, the constraint and objectives are necessarily singletons, i.e., non-indexed. Using these constructs, we express the AMPL objective and constraints in Pyomo as follows:</p><p>This example illustrates several conventions for generating constraints using standard Python language constructs. The function objective_rule returns an algebraic expression that defines the objective, and the function time_rule returns a less-than-or-equal expression that defines an upper bound on the constraint body. They are created with Pyomo's summation function, which concisely specifies a vector sum of one or more arguments. An alternative is to use the Python sum function. So, for example, the sum over i in model.P of X i /a i could be done using the summation function as shown or using sum(model.X[j]/model.a[j] for j in model.P), which has the same effect. The function limit_rule illustrates another convention that is supported by Pyomo; a rule can return a tuple that defines the lower bound, constraint body, and upper bound for a constraint. The Python value None can be supplied as one of the limit values if a bound is not enforced.</p><p>Once an abstract Pyomo model has been created, it can be printed as follows:</p><p>This command summarizes the information in the Pyomo model, but it does not print out explicit expressions. This is due to the fact that an abstract model needs to be instantiated with data to generate the variables, constraints, and objectives. An instance of the prod model can be generated and displayed as follows:</p><p>The file prod.dat file contains set and param data commands that are consistent with AMPL data commands; this example file is also available from http://www.ampl. com/BOOK/EXAMPLES/EXAMPLES1.</p><p>Once a model instance has been constructed, an optimizer can be applied to find an optimal solution. For example, the CPLEX mixed-integer programming solver can be used within Pyomo as follows:</p><p>This code fragment imports the solver interfaces associated with Pyomo, and creates an optimizer interface for the CPLEX executable. The Pyomo model instance is optimized, and the optimizer returns an object that contains the solution(s) generated during optimization. Note that this optimization process is executed using other components of the Coopr library. The coopr.opt package manages the setup and execution of optimizers, and Coopr optimization plugins are used to manage the execution of specific optimizers.</p><p>Finally, the results of the optimization can be displayed simply by executing the following command:</p><p>Here, the num option indicates the maximum number of solutions from the results object to be written; some solvers (including CPLEX) can return multiple solutions that represent alternative optima, or other feasible points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Advanced Pyomo modeling features</head><p>The previous example provides a simple illustration of Pyomo's symbolic modeling capabilities. Much more complex models can be developed using Pyomo's flexible modeling components. For example, multi-dimensional set and parameter data can be naturally represented using Python tuple objects. The dimen option specifies the dimensionality of set or parameter data, e.g., as follows:</p><p>In this example, the p parameter is an array of data values indexed by A for which each value is a 2-tuple.</p><p>Additionally, set and parameter components can be directly constructed with data using the initialize option. In the simplest case, this option specifies data that is used in the component:</p><p>For arrays of data, a Python dictionary can be specified to map data index values to set or parameter values: More generally, the initialize option can specify a function that returns data values used to initialize the component: Set and parameter components also include mechanisms for validating data. The within option specifies a set that contains the corresponding set or parameter data, for example as follows:</p><p>The validate option can also specify a function that returns a boolean indicating whether data is acceptable: Pyomo includes a variety of virtual set objects that do not contain data but which can be used to perform validation, including:</p><p>-Any: Any numeric or non-numeric value other than the Python None value -PositiveReals: Positive real values -NonNegativeIntegers: Non-negative integer values -Boolean: Zero or one values Finally, there are many contexts where it is necessary to specify index sets that are more complex than simple product sets. To simplify model development in these cases, Pyomo supports set index rules that automatically generate temporary sets for indexing. For example, the following example illustrates how to index a variable on 2-tuples (i, j) for which i &lt; j:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Constructing concrete models</head><p>Concrete models are the most direct type of model that Pyomo supports. These models can be formulated in the same way as abstract models using Pyomo components for variables, objectives, and (optionally) constraints. Additionally, a user can easily leverage native Python data structures while constructing concrete models. The Con-creteModel class is used to represent concrete models whose data is provided as the model components are declared. In contrast to AbstractModel, a Concrete-Model immediately initializes model components as they are added to a instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Non-linear modeling extensions</head><p>A key differentiating feature of Pyomo relative to other open-source (and some commercial) modeling languages is the ability to specify and generate non-linear optimization models. Currently, the non-linear model output format supported by Pyomo is NL, the native AMPL file format. We have chosen this format principally because it is used by a variety of non-linear solvers, including Ipopt [29] and BONMIN <ref type="bibr" target="#b7">[8]</ref>. Further, the NL format supports the full range of non-linear operators. Examples of such operators, also provided in Pyomo, include:</p><p>pow, exp, and related operators (including sqrt and log10) sin, cos, tan, and related hyperbolic and inverse operators abs, the absolute value operator To illustrate the use of non-linear operators in Pyomo, consider the objective associated with the brownden CUTEr test problem instance <ref type="bibr" target="#b11">[13]</ref>:</p><p>As the example illustrates, non-linear operators are naturally incorporated into the syntax for specifying algebraic expressions in both constraints and objectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Importing data</head><p>While commercial AMLs provide streamlined functionality for accessing external data sources, the same is not true of open-source AMLs. As discussed below in Sect. 6.7, Python-based AMLs other than Pyomo require the user to specify data via native Python constructs, e.g., in dictionaries or low-level input/output routines. The same holds for non-Python open-source AMLs such as FlopC++. While flexible, this interface can be cumbersome and inefficient for non-programmers. In the case of abstract models, where data varies across a single core abstraction, users must maintain independent data stores for each instance. Further, in deployed optimization applications, data is almost exclusively maintained in central data stores, e.g., Excel or a database. To address these concerns, Pyomo provides streamlined initialization of data from external data sources.</p><p>The data file format discussed in Sect. 6.1 is one example of an external method by which Pyomo data can be initialized, and this is the most common mechanism for novice and academic Pyomo users. These files contain custom Pyomo data commands that are similar to those used by AMPL.</p><p>To support data access from more general sources such as structured ASCII file, csv files, spreadsheets, and databases, Pyomo supports the import command. The import command directs Pyomo to load a relational table that represents set and parameter data. A relational table consists of a matrix of numeric string values, simple strings, and quoted strings. All rows and columns must have the same number of entries, and the first row represents labels for the column data.</p><p>We now discuss some aspects of the Pyomo import syntax using small illustrative examples. First, consider data stored in a simple text white-space delimited text file called Y.tab:</p><p>This file specifies the values of a parameter Y, which is indexed by set A. The following import command loads the parameter data:</p><p>The first argument is the name of the file containing the data. The options after the ":" character indicate how the table data is mapped onto model data. The option <ref type="bibr">[A]</ref> indicates that the set A is used as the index, and the option Y indicates the name of the parameter to be initialized.</p><p>Similarly, set data can be loaded from an ASCII file named A.tab containing a single column:</p><p>The format option must be specified to denote the fact that the relational data is to be interpreted as a set, as follows:</p><p>Simple extensions of this general syntax can be used to specify data tuples, or indexed sets; additional keywords are provided to guide how relational table data is interpreted by Pyomo. The same general syntax can be used to access relational table data in csv (comma-separated) and xls (Excel) files. Similarly, data can be extracted from relational databases by adding appropriate keyword specifying the database driver, query, and optional user name and password, for example:</p><p>This command creates a relational table using all of the columns in the database table ABCD, extracted using the pyodbc database interface. The using keyword indicates that data is to be extracted using an external Python package, the Python ODBC database interface.</p><p>Other data partitioning and organizational commands are also supported in Pyomo, e.g., include statements that import nested. dat files and namespace commands that logically partition the contents of a single .dat file. Namespaces are particularly useful, allowing for the specification of data for multiple model instances in a single file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">The Pyomo command</head><p>While Pyomo-based Python code can be entered and executed directly from within the Python interpreter, Pyomo includes the pyomo command-line tool that can construct an abstract or concrete model, create a concrete instance from user-supplied data (if applicable), apply an optimizer, and summarize the results. For example, the following command line optimizes the AMPL prod model using the data in prod.dat:</p><p>The pyomo command automatically executes the following steps:</p><p>-Create an abstract or concrete model -Read the instance data (if applicable and specified) -Generate a concrete instance from the abstract model and instance data (if applicable)</p><p>-Apply simple preprocessors to the concrete instance -Apply a solver to the concrete instance -Load the results into the concrete instance -Display results</p><p>The pyomo script supports a variety of command-line options to guide and provide information about the optimization process; documentation of the various available options is obtained by specifying the -help option. to load and save model data from external sources, e.g., text files, spreadsheets, and databases. As discussed previously, the availability of these features is either critical for or extremely useful in the deployment of solutions to real-world applications.</p><p>For concrete model specification, the PuLP and Pyomo syntax are qualitatively similar. However, some differences are worth briefly highlighting. Consider the following PuLP model:</p><p>In this example, the variables x1 and x2 are not explicitly associated with the model. They can be accessed by scanning the set of model constraints, but this is in practice expensive. In Pyomo, all model components (parameters, sets, variables, etc.) are consistently and explicitly associated with a specific model, and can be directly accessed by querying the model in a clean, object-oriented fashion.</p><p>The mechanisms for expressing indexed components-in particular variables and constraints-are more natural and flexible in Pyomo than in PuLP. Indexed variables in PuLP are specified by creating a dictionary (mapping of keys to values) of variables, e.g., as follows:</p><p>This construct is expressed in Pyomo as follows:</p><p>One minor limitation of the PuLP indexed variable syntax is that variable lower and upper bounds are assumed to be homogeneous. In contrast, Pyomo provides for indexspecific bounds by supplying an arbitrary function via the bounds keyword in the Var constructor.</p><p>Next, we consider an example in which constraints are imposed on a variable value on a per-index basis. In PuLP, an example of such a constraint is as follows:</p><p>Note that the looping constructs must be manually specified, and that the constraints are not logically grouped within the model. In Pyomo, this constraint would be expressed as follows:</p><p>Contrasting the two approaches, we observe that the related constraints are automatically grouped in Pyomo, and the explicit (and potentially error-prone) looping constructs in PuLP are avoided. Similarly, constraint names are assigned automatically in Pyomo (e.g., my_constraint <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>), whereas the PuLP looping constructs require the user to explicitly form the constraint name (which is left unspecified for this reason in our example).</p><p>PuLP is actively supported, and is distributed under an open, BSD-like license. PuLP was recently accepted into the COIN-OR project.</p><p>APLEpy The APLEpy package <ref type="bibr" target="#b4">[5]</ref> is similar to PuLP in both design and functionality, although there are some differences worth highlighting. In contrast to PuLP, all model components are implicitly members of a single, globally accessible model object. As a consequence, maintaining and manipulating multiple model instances (e.g., as shown for Pyomo in Sect. 8) is not possible. The syntax for constructing constraints is very similar to that of PuLP. For example, explicit user looping is required in the case of indexed constraints. Like PuLP, APLEpy only supports concrete model specification, provides no integrated facilities for accessing external data, and does support specification of indexed variables and constraints. Although still available for download, APLEpy does not appear to be actively supported. APLEpy is distributed under the Common Public License.</p><p>PyMathProg and POAMS Other than PuLP and APLEpy, POAMS and PyMathProg are the two most similar open-source AMLs to Pyomo. Unfortunately, POAMS is not widely available for download and experimentation (there has been no formal release). PyMathProg <ref type="bibr" target="#b35">[41]</ref> is associated with the GNU GLPK project, and as a consequence, only interfaces to the GLPK solver. Models are specified in a PuLP-like syntax; no functionality for specifying abstract models is provided, nor are integrated interfaces to external data sources. PyMathProg is distributed under the GPL license.</p><p>Numberjack and Google OR-Tools A number of Python modeling and solver packages have recently originated from the constraint programming community, in particular Google OR tools <ref type="bibr" target="#b32">[37]</ref> and Numberjack <ref type="bibr" target="#b25">[28]</ref>. The goals of Numberjack are broader than Pyomo and related AMLs from the mathematical programming community, in that the objective is to support specification and solution of constraint programming, mixed-integer linear programming, and boolean satisfiability models. Consequently, a different set of solvers is supported, e.g., the SCIP mixed-integer solver, the Mistral constraint programming solver, and the MiniSat satisfiability solver. Like the other open-source AMLs discussed above, models may not be specified symbolically, and there is no integrated support for data input from external sources such as Excel. Non-linear operators for mathematical programming are not supported. The Numberjack syntax is very similar to that of PuLP, e.g., models are constructed using the += syntax and variables are specified externally to a model object. Numberjack is distributed under the LGPL. The solver interfaces in Numberjack are similar in design spirit to those in Coopr. In contrast to Numberjack, Google's OR-tools package is primarily focused at the present time on specifying and solving constraint programs, and supports a single integrated solver. Like Numberjack, the OR-tools package does not allow specification of abstract models, and lacks integrated support for obtaining data from external data sources. Google's OR-tools package is distributed under the Apache license, while Numberjack is licensed under the LGPL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.8">Run-time performance</head><p>Run-time performance was not the most significant factor in our choice of Python as a modeling language, but it is clearly an important factor for many Pyomo users. Although the optimization solver run-time is typically dominant, in some applications the time required to construct complex models can be nontrivial. Thus, we have simplified and tuned the behavior of Pyomo modeling components in an attempt to minimize the run-time required for model construction. This tuning effort is on-going, driven by experience with specific test applications. Figure <ref type="figure" target="#fig_0">1</ref> shows the run-time performance for Pyomo and AMPL on dense instances of the well-known p-median facility location problem. We have considerable experience solving large-scale p-median problem instances arising in water security contexts <ref type="bibr" target="#b24">[27]</ref>, motivating our investigation of run-time scaling using this particular optimization problem. The two curves in this plot show the time, in seconds, that was required to generate and write (but not solve) a model with AMPL and Pyomo. In both cases, we write the resulting mixed-integer program in the NL problem format, i.e., the preferred format in AMPL. The x-axis captures the problem size N • M for p-median problems where the number of customers, N , equals the number of facilities, M. Each point in this plot represents the average of 15 different trials, executed on a modern (3.33 GHz dual-processor Intel Xeon (×5680) with 24GB RAM and no hypher threading) multicore workstation running Linux. This graph was generated with the version of Pyomo that is included in the Coopr 3.0 release.</p><p>This figure shows that there is a substantial performance gap between Pyomo and AMPL for large p-median instances. For the largest problems, Pyomo with garbage collection enabled (the default) was 82 times slower than AMPL. This difference largely stems from the fact that Python is notoriously slow at constructing and destructing large numbers of small objects, e.g., such as parameter and variable values appearing in expressions. Constraint and objective expressions in Pyomo are encoded as trees, which represent each arithmetic operator and data value with a distinct Python object. Thus, constructing large expression trees involves the construction of many Python objects, yielding the observed performance differences. We are currently exploring alternative encodings of expression trees, specifically to avoid this source of performance degradation. Other sources of performance bottlenecks include string (component label) manipulation, expression preprocessing in preparation to write the NL file, and expression verification and simplification. Our analysis of Pyomo profiler output suggests that these bottlenecks can also be mitigated with a moderate development effort. Python performance can also be improved by using the Psyco JIT compiler [39], but this tool can only be used on 32-bit versions of Python on 64-bit computers. Finally, we observe that the performance discrepancies vary significantly, depending strongly on the model structure and the comparative baseline. For example, Dimitrov observed a 6× discrepancy between the performance of GAMS and Pyomo on a complex production/ transportation model <ref type="bibr" target="#b13">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">The Coopr optimization package</head><p>Much of Pyomo's flexibility and extensibility is due to the fact that Pyomo is integrated into Coopr, a COmmon Optimization Python Repository <ref type="bibr" target="#b10">[12]</ref>. Coopr utilizes a component-based software architecture to define plugins that modularize many aspects of the optimization process. This allows Coopr to support a generic optimization process. Coopr components manage the execution of optimizers, including run-time detection of available optimizers, conversion to file formats required by an optimizer, and transparent parallelization of independent optimization tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Generic optimization process</head><p>Pyomo strongly leverages Coopr's ability to execute optimizers in a generic manner. For example, the following Python script illustrates how an optimizer is initialized and executed with Coopr:</p><p>This example illustrates Coopr's explicit segregation of problems and solvers into separate objects. Such segregation promotes the development of tools like Pyomo that define optimization applications.</p><p>The results object returned by a Coopr optimizer includes information about the problem, the solver execution, and one or more solutions generated during optimization. This object supports a general representation of optimizer results that is similar in spirit to the results encoding scheme used by the COIN-OR OS project <ref type="bibr" target="#b18">[20]</ref>. The main difference is that Coopr represents results in YAML, a data serialization format that is both powerful and human readable <ref type="bibr" target="#b49">[55]</ref>. For example, Fig. <ref type="figure" target="#fig_2">2</ref> shows the results output after solving the AMPL example production planning problem described in Sect. 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Solver parallelization</head><p>Coopr includes two components that manage the execution of optimization solvers. First, Solver objects manage the local execution of an optimization solver. For example, Coopr includes plugins for MIP solvers like CPLEX, GUROBI, and CBC. Second, SolverManager objects coordinate the execution of Solver objects in different environments. The API for solver managers supports asynchronous execution of solvers as well as solver synchronization. Coopr includes solver managers that execute solvers serially, in parallel on compute clusters, and remotely with the NEOS optimization server <ref type="bibr" target="#b14">[16]</ref>. Coopr's Pyro solver manager supports parallel execution of solvers using two key mechanisms: the standard Python pickle module and the Pyro distributed computing library <ref type="bibr" target="#b37">[43]</ref>. The pickle module performs object serialization, which is a prerequisite for distributed computation. With very few exceptions, any Python object can be pickled for transmission across a communications channel. This includes simple, built-in objects such as lists, and more complex Pyomo objects like Abstract-Model and ConcreteModel instances. For example, the following code fragment illustrates the use of the pickle module to write and restore a Pyomo model instance via an intermediate file:</p><p>The simplicity of complex object serialization in Python is remarkable, especially relative to low-level languages C++ in which users must develop complex classspecific methods to achieve This issue is amplified by the presence of complex inter-relationships among objects, i.e., such as those present in Pyomo models.</p><p>Pyro (Python Remote Objects) <ref type="bibr" target="#b37">[43]</ref> is a mature third-party Python library that provides an object-oriented framework for distributed computing that is similar to Remote Procedure Calls. Pyro is cross-platform, such that different application components can execute on fundamentally different platform types, e.g., Windows and Linux. Interprocess communication is facilitated through a standard name server mechanism, and object serialization and de-serialization is performed via the Python pickle module.</p><p>The standard Coopr distribution includes both the Pyro library and a number of solver-centric utilities to facilitate parallel solution of Pyomo models. All communication is established through the Coopr name server, invoked via the coopr-ns script on some host node in a distributed system. A "router" process is then launched on a compute node via the Coopr dispatch_srvr script. Finally, one or more solver processes are launched on various compute nodes via the Coopr pyro_mip_server script. Each solver process identifies a dispatch server through the name server and notifies the dispatch server that it is available for solving instances. Note that the various solver processes can execute on distinct cores of a single workstation, across multiple workstations, and even across multiple workstations running different operating systems, e.g., hybrid Windows/Linux clusters. Communication with the global name server is typically accomplished by setting the PYRO_NS_HOSTNAME environment variable to identify the name server host; in a non-distributed (e.g., SMP) environment, such communication is automatic.</p><p>Once initialized, the distributed solver infrastructure is accessed by the Pyro solver manager, which can be constructed using the SolverManagerFactory functionality:</p><p>The Pyro solver manager identifies dispatch servers through the Coopr name server. Thus, a simple change in the argument name to the solver manager factory is sufficient to access distributed solver resources in Coopr. We note that if no solver manager is specified (as is the for examples shown early in this paper), a default serial solver manager is constructed automatically; this particular manager executes solves locally, in a sequential fashion. The ah object is known as an action handle, and informally serves as a "tracking number" through which users can interrogate the status of a submitted solve request.</p><p>Figure <ref type="figure" target="#fig_3">3</ref> illustrates a typical architecture for distributed solver computation in Coopr. In this example, the user executes a solver script (e.g., the runbenders script described in Sect. 8.2) on his or her local machine. The name and dispatch server processes (coopr-ns and dispatch_srvr) are configured as daemons on an administrative workstation, such that they are persistently available. This example network has two major compute resources: a Windows cluster and a multi-core Linux server. The Linux server has four CPLEX licenses, while the Windows cluster has the open-source CBC solver available on all of its 64 compute nodes. Four pyro_mip_server daemons are executing on the server (each is allocated two cores), while a pyro_mip_server daemon is executing on each compute node of the Windows cluster. In this particular example, all user-solver communication is performed via the sole dispatch server; in general, multiple dispatch servers can be configured to mitigate communication bottlenecks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Solver plugins</head><p>A common object-oriented characteristic of open-source optimization software is the ability to use classes and class inheritance to develop extensible functionality. In contrast, Coopr leverages the PyUtilib Component Architecture (PCA) to separate the declaration of component interfaces from their implementation <ref type="bibr" target="#b40">[46]</ref>, through a mechanism referred to as a plugin. A plugin specifies the required method and data associated with a specific interface, but does not require that all instances of this interface be derived from a particular base class. For example, in Coopr all optimization solvers are implemented by defining a distinct class encapsulating the associated functionality. However, these classes are not required to be sub-classes of a solver interface class. Instead, they are simply required to provide the same interface methods and data.</p><p>Coopr uses plugin components to modularize the process workflow commonly associated with optimization. A component is a software package, module, or object that provides a specific functionality. Plugin components augment the standard optimization workflow by implementing functionality that is exercised "on demand." Component-based software with plugins is a widely recognized best practice for extending and evolving complex software systems in a reliable manner <ref type="bibr" target="#b42">[48]</ref>. Component-based frameworks manage the interaction between components to promote adaptability, scalability, and maintainability in large software systems <ref type="bibr" target="#b45">[51]</ref>. For example, with component-based software there is much less need for major releases because software changes can be encapsulated within individual components. Component architectures also encourage third-party developers to add value to software systems without risking destabilization of the core functionality.</p><p>Coopr uses the PCA to define interfaces for the following plugin components:</p><p>-Solvers, which perform optimization -Solver managers, which manage the execution of solvers -Converters, which translate between different optimization problem file formats -Solution readers, which load optimization solutions from solver output files -Problem writers, which create solver input files that specify optimization problems -Transformations, which generate new models via reformulation of existing models</p><p>Coopr also contains Pyomo-specific components for preprocessing Pyomo models before they are solved.</p><p>Coopr includes a variety of plugins that implement these component interfaces, many of which rely on third-party software packages to provide key functionality. For example, solver plugins are available for the CPLEX, GUROBI, CBC, PICO, and GLPK mixed-integer linear programming solvers. These plugins rely on the availability of binary executables for these solvers, which need to be installed separately. Similarly, Coopr includes plugins that convert between different solver input file formats; these plugins rely on binary executables built by the GLPK <ref type="bibr" target="#b20">[23]</ref> and Acro <ref type="bibr" target="#b0">[1]</ref> software libraries.</p><p>Figure <ref type="figure" target="#fig_4">4</ref> illustrates the definition of a solver plugin that can be directly used by the pyomo command; this example is available in the standard Coopr distribution, in the directory coopr/examples/pyomo/p-median. The MySolver class implements the IOptSolver interface, which declares this class as a Coopr solver plugin. This plugin implements a solve method, which randomly generates solutions to a p-median optimization problem. The only other step required is to invoke Coopr's SolverRegistration function, which associates the solver name, random, with the plugin class, MySolver.</p><p>Importing the Python module containing MySolver activates this plugin; all other registration is automated by the PCA. For example, if this plugin is contained within the file solver2.py, then the following Python script can be used to apply this solver to Coopr's p-median example model:</p><p>The pyomo script can also be used to apply a custom optimizer in a natural manner. The following command-line is used to solve the Coopr's p-median example with the CBC mixed-integer programming solver:</p><p>Applying the custom solver simply requires the specification of the new solver name, random, and an indication (via the load option) that the solver2.py file should be imported before optimization: Thus, users can develop custom solvers in Python modules, which can be executed and tested directly the pyomo command.</p><p>This example serves to illustrate the ease with which new solver interfaces can be prototyped and deployed using Pyomo and Coopr. Similar plugins could be easily implemented for a wide range of metaheuristic or problem-specific solvers; the user simply needs to extract the necessary information from a Pyomo instance, transfer it to the specific solver, and then extract and store the results of the solve in the canonical Coopr results format. Further, such plugins can be seamlessly integrated into existing optimization workflows, e.g., via the pyomo command line utility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Advanced scripting and algorithm development</head><p>In Sect. 6, we presented a straightforward use of Pyomo: to construct a concrete instance from an abstract model and a data file, and to subsequently solve the instance using a specific solver plugin. A generic optimization process is executed by the pyomo command, so the typical user does not need to understand the details of the functionality present in most Pyomo and Coopr libraries. However, this command masks much of the power underlying Pyomo and Coopr, and it limits the degree to which Python's rich set of libraries can be leveraged.</p><p>An important consequence of the Python-based design of Pyomo and its integration with the Coopr environment is that modularity is fully supported over a range of abstractions. At one extreme, model elements can be manipulated explicitly by specifying their names and the values of their indexes. This sort of reference can be made more abstract, as is the case with other AMLs, by specifying various types of named sets and parameters so that the dimensions and details of the data can be separated from specification of the model. Separation of an abstract model from the data specification is a hallmark of structured modeling techniques <ref type="bibr" target="#b19">[22]</ref>. At the other extreme, elements of a optimization model can be treated in their fully canonical form as is supported by callable solver libraries. Methods can be written that access or manipulate, e.g., objective functions or constraints in a fully general way. This capability is a fundamental tool for general algorithm development and extension <ref type="bibr" target="#b29">[33]</ref>. Pyomo provides the full continuum of abstraction between these two extremes to support modeling, scripting, and algorithm development. Furthermore, methods are extensible via overloading of all defined operations. Both modelers and developers can alter the behavior of a package or add new functionality.</p><p>In the remainder of this section, we introduce a variety of example case studies highlighting the relative ease of both scripting and algorithm development in Coopr. The example in Sect. 8.1 discusses a script implementing a hybrid MIP-NLP optimization algorithm. Section 8.2 describes the Pyomo-based implementation of a Benders-based decomposition algorithm for a simple production planning problem. Together, these two examples illustrate the use of Pyomo and Coopr to solve optimization models requiring some degree of algorithmic customization, emphasizing different coding approaches to achieve similar goals. Finally, in Sect. 8.3 we introduce an example highlighting features of Pyomo and Python that facilitate the development of generic algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Advanced scripting: hybrid optimization</head><p>Hybrid methods may be required to solve particularly difficult real-world optimization problems. Due to the deviation from the standard optimization workflow process, in which a model is handed to an off-the-shelf solver, implementation of hybrid methods typically requires non-trivial scripting.</p><p>One instance of such a hybrid algorithm implemented in Coopr/Pyomo was developed by our collaborators in Texas A&amp;M's Department of Chemical Engineering. The specific problem of interest involved the development of a global optimization algorithm to solve a parameter estimation problem arising in the context of a model for childhood infectious disease transmission. For further information regarding both the model and its Pyomo implementation we refer to Hackebeil and Laird <ref type="bibr" target="#b22">[25]</ref>. Below, we briefly survey the high-level solution strategy, and highlight key fragments of Pyomo code implementing the strategy.</p><p>The parameter estimation model considered is a difficult non-convex, non-linear program for which no efficient solution algorithm exists. Consequently, to facilitate tractable solution, the problem is reformulated using a MIP under-estimator and an NLP over-estimator. Information is exchanged between the two formulations, and the process is iterated until the two solutions converge.</p><p>The main script for this process is implemented in Pyomo as follows; some initialization code is omitted for clarity:</p><p>In this example, user-defined Python functions are used to organize and modularize the optimization workflow. In contrast to examples shown previously, the optimization model in this case is constructed via a function (disease_model). A fragment of code for this function is as follows:</p><p>Beyond the standard Pyomo model constructs, we observe the ability to dynamically augment Pyomo models with arbitrary data, e.g., the definition of the pts_LS and pts_LI attributes; these are not model components, but rather raw Python data types. Pyomo itself is unaware of of these attributes, but other components of a user-defined script can access and manipulate these attributes. Such a mechanism is invaluable when information is being propagated across disparate components of a complex, multi-step optimization process. We note the use of an auxiliary function (linearize_exp, introduced to modularize the code) to construct specific classes of constraint, which are then added to the input Pyomo model.</p><p>Following instance construction, MIP and NLP variants of the master model instance are solved using the user-defined utility functions solve_MIP and solve_NLP. These functions simply activate the relevant model components (all model components in Pyomo can be independently activated and deactivated), solve the corresponding model, and return the results. The function output_results reports and caches results, and computes the current gap and upper bound. Finally, the functions update_points and tighten_bounds perform computations (obtained both analytically and via MIP solves) that yield the input data required for the next iteration of the process.</p><p>This example serves to illustrate, at a very high level, the scripting of a complex hybrid optimization algorithm using Pyomo and Coopr. Despite the complexity of the process (hidden in large part due to code modularization), the code (including that for the model definition) is relatively compact-a total of approximately 650 lines of Python code, including white-space. The full code is available upon request by contacting one of the authors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Benders decomposition</head><p>To further illustrate advanced scripting in Pyomo, we next consider the translation of an AMPL example involving the solution via Benders decomposition of a production planning problem formulated as a stochastic linear program. This example emphasizes different aspects of Pyomo and Coopr than the hybrid optimization discussed in Sect. 8.1, specifically in terms of how models are defined, manipulated, and solved.</p><p>The production planning problem considered is defined as follows. Given a number of product types and associated production rates, production limits, and inventory holding costs, the objective is to determine a production schedule over a number of weeks that maximizes the expected profit over a range of anticipated revenue scenarios. The problem is formulated as a two-stage stochastic linear program; first-stage decisions include the initial production, sales, and inventory quantities, while second-stage decisions (given scenario-specific revenues) include analogous parameters for all time periods other than the initial week. We refer the reader to Bertsimas and Tsitsiklis <ref type="bibr" target="#b5">[6]</ref> for a discussion of how general two-stage stochastic linear programs can be solved via Benders decomposition.</p><p>The original AMPL example consists of the three files stoch2.run (an AMPL script), stoch2.mod (an AMPL model file), and stoch.dat (an AMPL data file), which are available from http://www.ampl.com/NEW/LOOP2. The translation of this AMPL example into Pyomo illustrates many of the more powerful capabilities of Pyomo and Coopr, including dynamic construction of model variables and constraints, as well as parallelization of sub-problem solves. The codes for this example are available in the Coopr distribution, in the directory coopr/examples/pyomo/benders. The first step in the translation process involves creation of the master and sub-problem abstract models, mirroring the process previously documented in Sect. 6; the resulting models are captured in the files master.py and subproblem.py. We observe that AMPL allows "pick-and-choose" selection of components from a single model definition file to construct sub-models. In contrast, Pyomo requires that distinct models be self-contained in their definition.</p><p>The Python code to execute Benders decomposition for this particular example is found in the file runbenders; the remainder of this section will explore key aspects of this code in more detail.</p><p>As with the basic Pyomo example introduced in Sect. 6, the runbenders script begins by loading the necessary components of the Pyomo, Coopr, PyUtilib, and Python system libraries:</p><p>The need for and role of these various modules will be explained below.</p><p>The first executable component of the runbenders script involves construction of the abstract models and concrete problem instances for both the master and second-stage sub-problems:</p><p>In this code fragment, the master.py and subproblem.py model definition files are loaded (via the PyUtilib function import_file), defining the associated abstract models; the runbenders script accesses the corresponding model objects in the respectively Python modules. Given an abstract model object, a concrete instance can be created by invoking its create method supplied with an argument specifying a data file. For reasons discussed below, the second stage sub-problems are gathered into a Python list.</p><p>Next, we create the necessary solver and solver manager plugins:</p><p>In this example, use CPLEX to solve concrete instances, as it the variable and constraint suffixes needed for the Bender's procedure (e.g., reduced-costs, as discussed below). In Coopr, the solver manager is responsible for coordinating the execution of any solver plugins. The code fragment above specifies two alternative solver managers, with serial execution enabled by default; see Sect. 7.2 for a discussion of parallel solver execution (via the Pyro solver manager). Benders decomposition is an iterative process; sub-problems are solved, cuts are added to the master problem, and the master problem is (re-)solved; the process repeats until convergence. In the master.py model, the set of cuts and the corresponding constraint set is defined as follows: Initially, the CUTS set is empty. Consequently, no rule is required in the definition of the constraint set Cut_Defn. Similarly, the pricing (i.e., reduced-cost and dual) information from the sub-problems is stored in the following parameters within master.py (such pricing information is integral in the definition of Benders cuts <ref type="bibr" target="#b5">[6]</ref>):</p><p>Again, because the index set CUTS is empty, these parameter sets are initially empty. The parameters are indexed by sets whose declaration is not shown here: PROD is the set of products, SCEN is the set of scenarios, and TWOPLUSWEEKS is the set of weeks beginning with week 2.</p><p>Given these definitions, we now examine the main loop in the runbenders script. The first portion of the loop body solves the second stage sub-problems as follows: function solve_all_instances is a Coopr utility that performs three distinct operations: (1) queue the sub-problem solves with the solver manager, (2) solve each of the sub-problems, and (3) load the results into the sub-problem instances. This function encapsulates the detailed logic of queuing, solver/solver manager interactions, and barrier synchronization; such detail can be exposed as needed, e.g., when sub-problems can be solved asynchronously.</p><p>Next, the index set CUTS is expanded, and the pricing parameters are extracted from the sub-problem instances and stored in the master instance:</p><p>The first line in this code block dynamically expands the size of the CUTS set, adding an element corresponding to the current Benders loop iteration counter i. The code for transferring pricing information from the sub-problems to the master instance is straightforward: access of pricing parameters with a sub-index equal to i in the master instance is legal given the dynamic update of the CUTS set. Additionally, we observe the availability in Pyomo of standard variable "suffix" information (in this case constraint dual variables and variable upper reduced costs).</p><p>With pricing information available in the master instance, we can now define the new cut for Benders iteration i as follows:</p><p>The expression for the cut is formed using the Python sum function in conjunction with Python's list comprehension syntax. While somewhat more complex, the fundamentals of constraint generation shown above are qualitatively similar to the constraint rule generation examples presented in Sect. 6.1. Given the cut expression, the corresponding new element of the Cut_Defn constraint set is created via the add method of the Constraint class. Here, the method arguments respectively represent (1) the constraint index and (2) a tuple consisting of the constraint (lower bound, expression, upper bound).</p><p>The remainder of the runbenders script is straightforward, involving a simple looping construct and checks for convergence. This example further illustrates that sophisticated optimization strategies requiring direct access to Pyomo's modeling capabilities and Coopr's optimization capabilities can be easily implemented. The runbenders script has roughly the same complexity and length as the original AMPL script. Additionally, this script supports parallelization of this solver in a generic and straightforward manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Generic algorithms: generating extensive forms of stochastic programs</head><p>Moving beyond model-specific scripting, we now briefly discuss capabilities of Pyomo and Python that, when used in conjunction, can be used to develop generic, modelindependent algorithms. For purposes of illustration, we consider the case of stochastic linear and mixed-integer programs. A stochastic program can be viewed in terms of a scenario tree, i.e., a tree representing the evolution of model parameter uncertainty. To simplify exposition, we consider a two-stage stochastic program in which a single root node has n children, each of which represents a leaf node. Associated with each node is a set of variables. The variables corresponding to the root node are so-called first-stage variables, and represent decisions that must be made before the actual realization of uncertainty is revealed. The values of variables associated with the leaf nodes (also known as second-stage variables) are determined once the corresponding parameter uncertainty is revealed. For an in-depth introduction to stochastic programming, we defer to Shapiro et al. <ref type="bibr" target="#b43">[49]</ref>.</p><p>Conceptually, an n-scenario stochastic program can be viewed as a collection of n independent deterministic mathematical programs (each representing a single scenario), with one key augmentation: so-called non-anticipativity constraints are added to ensure equality of the first-stage decision variables across all n scenarios. Non-anticipativity is required to avoid prescient decision-making. This conceptualization is useful in practice, in part because it facilitates the transition from deterministic to stochastic programs, and further because many decomposition-based solution strategies explicitly operate on such a conceptualization. We now briefly discuss the implementation of a generic algorithm for constructing the mathematical program associated with this conceptualization, which is known as the extensive form. Further details concerning stochastic programming in the context of Pyomo and Coopr can be found in Watson et al. <ref type="bibr" target="#b48">[54]</ref>, which describes the PySP module of Coopr.</p><p>To generate the extensive form of any stochastic program using Pyomo/Coopr, the first step is to construct the individual scenario model instances. This can be accomplished with any of the approaches detailed above in Sects. 8.1 and 8.2. The more difficult step is to construct the non-anticipativity constraints, in a generic and modelindependent fashion. To understand the underlying programmatic mechanism, we first discuss how scenario trees are specified by users.</p><p>In PySP, there is a canonical Pyomo model of the scenario tree structure, specified as follows:</p><p>A key observation concerning this model is that all set and parameter values are strings, i.e., names given by the user to various objects. Of particular interest with respect to generation of a stochastic program extensive form is the definitions of the set Stage-Variables. For the well-known Birge and Louveaux "farmer" example (see <ref type="bibr" target="#b6">[7]</ref>), the corresponding data are specified as follows:</p><p>This data indicates that all indices of the variable DevotedAcreage are first-stage decision variables, for which non-anticipativity constraints must be constructed. In terms of implementation, the three key mechanisms required are (1) identification of the relevant Var objects on each Pyomo scenario instance, (2) construction of a "master" variable corresponding to each such object, and (3) construction of the nonanticipativity constraints enforcing equality between the master variable and each of the corresponding scenario instance variables. The following code fragment illustrates the implementation of these three steps; we have intentionally omitted various error-checking mechanisms (vital in the real PySP implementation), in addition to the code translating the scenario tree information above into a traversable, object-oriented structure:</p><p>The most salient observation regarding this code is its compactness, which is facilitated by a combination of Pyomo and Python functionality. In particular, the Python function getattr function is used to extract attributes of objects by name, at runtime-something that is not possible in statically typed languages such as C++. This capability, known as introspection, is used in the above fragment to access the objects on each Pyomo scenario instance in a completely generic and model-independent manner. Other features worth noting include (1) the ability to clone Var objects using index sets (as occurs when the ef variables are constructed), (2) the use of the Python function setattr to add components to the extensive form model instance, and (3) the use of in-line function definitions to construct the expressions associated with the non-anticipativity constraints.</p><p>The example above serves to illustrate the use of Pyomo/Coopr in the role of algorithm development, as opposed to just simple scripting. In particular, generic algorithms can be constructed with relatively little code. For example, the full construction routine for the extensive form in PySP is approximately 300 lines (including all white-space and error checking). Similarly, the core code for a complex decomposition solver strategy (Progressive Hedging) is approximately 1,000 lines. While we are not advocating the development of core numerical routines in Pyomo/Coopr (e.g., mixed-integer solvers), our efforts to date indicate that such an approach is effective when developing high-level computational strategies that in turn leverage fast numerical routines through, for example, the use of solver plugins.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Getting started with Pyomo</head><p>The installation of Pyomo is complicated by the fact that Coopr is comprised of an ensemble of Python packages, as well as third-party numerical software libraries. Coopr provides an installation script, coopr_install, that leverages Python's online package index <ref type="bibr" target="#b36">[42]</ref> to install Coopr-related Python packages. For example, in Linux and MacOS the command: will create a coopr directory that contains a virtual Python installation. All Coopr scripts will be installed in the coopr/bin directory, and these scripts are configured to automatically import the Coopr and PyUtilib libraries, in addition to other necessary Python packages. Similarly, in MS Windows the command: will create a coopr directory containing a virtual Python installation. The Coopr scripts will be installed in the coopr/bin directory, including *.cmd scripts that are recognized as DOS commands. On all platforms, the only additional user requirement is that the PATH environment variable be updated to include coopr/bin (Linux and MacOS) or coopr\bin (MS Windows). Windows installer executables are also available.</p><p>By default, the coopr_install script installs the latest official release of all Coopr-related Python packages. The coopr_install script also includes options for installing trunk versions (via the -trunk option) of the Coopr and PyUtilib Python This facilitates collaborations with non-developers to fix bugs and try out new Coopr capabilities.</p><p>More information regarding Coopr is available on the Coopr wiki page, available at: https://software.sandia.gov/trac/coopr/. This Trac site includes detailed installation instructions, and provides a mechanism for users to submit tickets for feature requests and bugs. Coopr is a COIN-OR software package [10]; further information can be obtained by e-mailing the associated COIN-OR or Google groups mailing lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Discussion and conclusions</head><p>Pyomo was developed and is actively supported for real-world optimization applications at Sandia National Laboratories <ref type="bibr" target="#b24">[27]</ref>. Our experience to date with Pyomo and Coopr has validated our initial assessment that Python is an effective language for supporting the development and deployment of solutions to optimization applications. Although it is clear that custom AMLs can support a more concise and mathematically intuitive syntax, Python's clean syntax and programming model make it a natural choice for optimization tools like Pyomo.</p><p>It is noteworthy that the use of Python for developing Pyomo has proven quite strategic. First, the development of Pyomo did not require implementation of a parser and the effort associated with cross-platform deployment, both of which are necessary for the development of an AML. Second, Pyomo users have been able to rely on Python's extensive documentation to rapidly get up-to-speed without relying on developers to provide detailed language documentation. Although general use of Pyomo requires documentation of Pyomo-specific features, this is a much smaller burden than the language documentation required for optimization AMLs. Finally, we have demonstrated that Pyomo can effectively leverage Python's rich set of standard and third-party libraries to support advanced computing capabilities like distributed execution of optimizers. This clearly distinguishes Pyomo from custom AMLs, and it frees Pyomo and Coopr developers to focus on innovative optimization capabilities.</p><p>Pyomo and Coopr were publicly released as an open source project in 2008. Future development will focus on several key design issues:</p><p>-Optimized expression trees Our scaling experiments suggest that Pyomo's runtime performance can be significantly improved by using a different representation for expression trees. The representation of expression trees could be reworked to avoid frequent object construction, either through a low-level representation or a Python extension library. -Extending the range of solver plugins We plan to expand the suite of pre-written solver plugins to include other commercial solvers, e.g., XpressMP. Additionally, we plan to leverage optimizers that are available in other Python optimization packages, which are particularly interesting when solving nonlinear formulations. -Direct optimizer interfaces Currently, most Coopr solvers are invoked via system calls. However, direct library interfaces to optimizers are also possible. For example, both CPLEX and GUROBI ship with Python library bindings. Direct solver interfaces promise to yield improved performance, due to the lack of a need for file manipulation and the overhead associated with spawning processes. -Remote solver execution Coopr currently supports solver managers for remote solver execution using Pyro. A preliminary interface to NEOS <ref type="bibr" target="#b14">[16]</ref> has been developed, but this solver manager currently only supports CBC. We plan to extend this interface, and to develop interfaces for Optimization Services <ref type="bibr" target="#b18">[20]</ref>, as well as cloud computing solvers based on, for example, Amazon's EC2 compute cloud.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2. 1</head><label>1</label><figDesc>Open source licensing A key goal of Pyomo is to provide an open source optimization modeling capability. Although open source optimization solvers are widely available in packages like COIN-OR [10], comparatively few open source tools have been developed to model optimization applications. The open source requirement for Pyomo is motivated by several factors:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1</head><label>1</label><figDesc>Fig.<ref type="bibr" target="#b0">1</ref> The real (wall clock) run time required to construct and write dense p-median model instances to an NL file with AMPL and Pyomo</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Results output for the production planning model described in Sect. 6</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3</head><label>3</label><figDesc>Fig. 3 An example of a hybrid compute architecture and how it can be configured for distributed solves using Pyro and Coopr</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 A</head><label>4</label><figDesc>Fig. 4 A simple customized Coopr solver for p-median problems</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>2 and 3, a flexible opensource license is often critical when deploying real-world applications. Further, open-source software is customizable and typically more extensible than commercial alternatives. Pyomo is obviously differentiated from commercial AMLs in this regard, and it is differentiated from open-source AMLs such as PyMathProg that use restrictive licenses. Integrated support for distributed computation Pyomo provides integrated support for distributed computation (see Sect. 7.2) by leveraging and extending capabilities in both Python and the Python library Pyro. This capability is unique in the context of open-source AMLs, and is uncommon in commercial AMLs. Support for distributed computation is becoming increasingly critical for application deployment, the co-authors and their collaborators. Similar capabilities could be embedded in related open-source AMLs such as PuLP and APLEpy, but are not currently available. -Integrated support for obtaining data from external sources Pyomo provides a rich range of interfaces to extract data from structured text files, spreadsheets, and databases, driven by the requirements for real-world deployment of optimization applications. As discussed in Sect. 6.5, this capability distinguishes Pyomo from other open-source AMLs. -Extensibility via component-based software architecture Drawing on best practices in commercial software design, Pyomo and Coopr are designed in a modular, component-based fashion. In particular, users can provide extensions without impacting the core software design, e.g., in the form of customized solvers and problem writers. Such functionality is discussed in Sect. 7.3, along with an example of a simple custom solver. The ability to seamlessly extend the core functionality is unique among open-source and commercial AMLs. -Advanced application scripting Perhaps the most important feature of Pyomo is</figDesc><table /><note><p><p><p>-Embedded in a high-level, full-featured programming language Commercial AMLs are embedded in proprietary languages, which typically lack the spectrum of language features found in modern high-level programming languages, e.g., functions, classes, and advanced looping constructs. For example, the lack of functions in AMPL makes programming many of the types of advanced applications shown in Sect.</p><ref type="bibr" target="#b7">8</ref> </p>very difficult. Other open-source AMLs share this advantage with Pyomo. -Access to extensive third-party library functionality By embedding Pyomo in Python, users immediately gain access to a remarkable range of powerful and free third-party libraries, including: SciPy, NumPy, Matplotlib, Pyro, and various database / spreadsheet interfaces. -Support for abstract and concrete math programming models As we argued in Sect. 2.4, the separation of model from data is extremely useful in practice. While commercial AMLs support this distinction, Pyomo is the only open-source AML to fully support the specification of both abstract and concrete math programming models. -Support for non-linear math programming models and solvers While many commercial AMLs provide capabilities to express and solve non-linear programs, few open-source tools support non-linear capabilities; OpenOpt [35] is a notable exception. This Pyomo capability is discussed in Sect. 6.4. given the growing availability of cluster-based and cloud computing. -Cross-platform deployment capabilities By embedding Pyomo in Python, we are able to rapidly deploy applications in cross-platform environments. Examples of such environments are discussed in Sect. 7.2, drawn from real-world computing environments exercised by</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Options can control how much or even if debugging information is printed, including logging information generated by the optimizer and a summary of the model generated by Pyomo. Further, Pyomo can be configured to keep all intermediate files used during optimization, which facilitates debugging of the model construction process.6.7 Comparison with other Python-based modeling languagesWe now briefly contrast Pyomo with several open-source Python-based math program modeling packages providing related functionality. A comprehensive comparison is beyond the scope of this paper. Instead, our goal here is to briefly outline the primary differences in the design and functionality of these packages. We focus first and in most detail on a comparison of Pyomo and PuLP, as the latter is arguably the most widely used open-source AML.</figDesc><table /><note><p><p><p>PuLP The PuLP package</p><ref type="bibr" target="#b34">[40]</ref> </p>is a widely used, light-weight Python package for expressing and solving optimization problems. The biggest functional differences between PuLP and Pyomo are: (1) PuLP can only express concrete model instances, (2) PuLP only allows for expression of linear and mixed-integer models, and (3) PuLP provides no built-in mechanism (other than what is available through Python)</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Jon Berry, Robert Carr, Carl Laird, Cindy Phillips, and John Siirola for their critical feedback on the design of Pyomo, and David Gay for developing the Coopr interfaces to AMPL NL and SOL files. We would like to thank Gabe Hackebeil for providing the hybrid optimization scripting example. Additionally, we thank the anonymous referees and associate editor for their suggestions, which served to significantly improve the paper. Sandia is a multiprogram laboratory operated by Sandia Corporation, a Lockheed Martin Company, for the United States Department of Energy's National Nuclear Security Administration under Contract DE-AC04-94-AL85000.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>Acro</surname></persName>
		</author>
		<ptr target="http://software.sandia.gov/acro" />
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>ACRO optimization framework</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Aimms</surname></persName>
		</author>
		<ptr target="http://www.aimms.com" />
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>AIMMS home page</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ampl</surname></persName>
		</author>
		<ptr target="http://www.ampl.com/" />
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>AMPL home page</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On reliability analysis of open source software-FEDORA</title>
		<author>
			<persName><forename type="first">P</forename><surname>Anbalagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vouk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th International Symposium on Software Reliability Engineering</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">APLEpy: an open source algebraic programming language extension for Python</title>
		<author>
			<persName><surname>Aplepy</surname></persName>
		</author>
		<ptr target="http://aplepy.sourceforge.net/" />
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Bertsimas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Tsitsiklis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Athena Scientific/Dynamic Ideas</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<pubPlace>Belmont</pubPlace>
		</imprint>
	</monogr>
	<note>Introduction to Linear Optimization</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Introduction to Stochastic Programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Birge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Louveaux</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><surname>Bonmin</surname></persName>
		</author>
		<ptr target="https://projects.coin-or.org/Bonmin" />
		<title level="m">The Bonmin wiki page</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Open Source Initiative (OSI)-the BSD license</title>
		<author>
			<persName><surname>Bsd</surname></persName>
		</author>
		<ptr target="http://www.opensource.org/licenses/bsd-license.php" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Open source software&apos;s expanding role in the enterprise</title>
		<author>
			<persName><forename type="first">Forrester</forename><surname>Consulting</surname></persName>
		</author>
		<ptr target="http://www.unisys.com/eprise/main/admin/corporate/doc/Forrester_research-open_source_buying_behaviors.pdf" />
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Coopr: A common optimization python repository</title>
		<author>
			<persName><surname>Coopr</surname></persName>
		</author>
		<ptr target="http://software.sandia.gov/coopr" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Cuter: A constrained and unconstrained testing environment</title>
		<author>
			<persName><surname>Cuter</surname></persName>
		</author>
		<ptr target="http://www.hsl.rl.ac.uk/cuter-www/index.html" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>revisited</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><surname>Cvxopt</surname></persName>
		</author>
		<ptr target="http://abel.ee.ucla.edu/cvxopt" />
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>CVXOPT home page</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Nedialki Dimitrov, naval postgraduate school</title>
		<author>
			<persName><surname>Dimitrov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Personal Communication</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Kestrel: an interface from optimization modeling systems to the NEOS server</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Dolan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fourer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Goux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Munson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sarich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INFORMS J Comput</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="525" to="538" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">FLOPC++ home page</title>
		<author>
			<persName><surname>Flopc++</surname></persName>
		</author>
		<ptr target="https://projects.coin-or.org/FlopC++" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">AMPL: a mathematical programming language</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fourer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Manag. Sci</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="519" to="554" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Fourer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
		<title level="m">AMPL: a Modeling Language for Mathematical Programming</title>
		<meeting><address><addrLine>Brooks/Cole Thomson Learning, Pacific Grove</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Optimization services: a framework for distributed optimization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fourer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oper. Res</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1624" to="1636" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An introduction to structured modeling</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Geoffrion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Manag. Sci</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="547" to="588" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">GLPK: GNU linear programming toolkit</title>
		<author>
			<persName><surname>Glpk</surname></persName>
		</author>
		<ptr target="http://www.gnu.org/software/glpk/" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><surname>Gpl</surname></persName>
		</author>
		<ptr target="http://www.gnu.org/licenses/gpl.html" />
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>GNU general public license</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Global optimization for estimation of on/off seasonality in infectious disease spread using pyomo</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hackebeil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Laird</surname></persName>
		</author>
		<ptr target="https://software.sandia.gov/trac/coopr/attachment/wiki/Pyomo/global_opt.pptx" />
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Python Optimization Modeling Objects (Pyomo)</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Hart</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-0-387-88843-9_1</idno>
	</analytic>
	<monogr>
		<title level="m">Operations Research and Cyber-Infrastructure</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Chinneck</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Kristjansson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Saltzman</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">US Environmental Protection Agency uses operations research to reduce contamination risks in drinking water</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Hart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Boman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INFORMS Interfaces</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="57" to="68" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Constraint Programming and Combinatorial Optimisation in Numberjack</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hebrard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>O'mahony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>O'sullivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CPAIOR 2010</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Lodi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Milano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Toth</surname></persName>
		</editor>
		<meeting>CPAIOR 2010<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6140</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">SciPy: open source scientific tools for Python</title>
		<author>
			<persName><forename type="first">E</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Oliphant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Peterson</surname></persName>
		</author>
		<ptr target="http://www.scipy.org/" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Modeling Languages in Mathematical Optimization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kallrath</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Kluwer</publisher>
			<pubPlace>Dordrecht</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A common medium for programming operations-research models</title>
		<author>
			<persName><forename type="first">S</forename><surname>Karabuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">H</forename><surname>Grant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Software</title>
		<meeting>the IEEE Software</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="39" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The design of the XMP linear programming library</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Marsten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Math. Softw</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="481" to="497" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Python for scientific computing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Oliphant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing in Science and Engineering</title>
		<imprint>
			<biblScope unit="page" from="10" to="20" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Ateji home page</title>
		<author>
			<persName><surname>Optimj</surname></persName>
		</author>
		<ptr target="http://www.ateji.com" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<ptr target="http://code.google.com/p/or-tools" />
		<title level="m">Ortools: Google OR tools-operations research tools developed at Google (2011)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An empirical comparison of seven programming languages</title>
		<author>
			<persName><forename type="first">L</forename><surname>Prechelt</surname></persName>
		</author>
		<idno type="DOI">10.1109/2.876288</idno>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<idno type="ISSN">0018-9162</idno>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="23" to="29" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">PuLP: a Python linear programming modeler</title>
		<author>
			<persName><surname>Pulp</surname></persName>
		</author>
		<ptr target="http://130.216.209.237/engsci392/pulp/FrontPage" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName><surname>Pymathprog</surname></persName>
		</author>
		<ptr target="http://pymprog.sourceforge.net/" />
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>PyMathProg home page</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Python package index</title>
		<author>
			<persName><surname>Pypi</surname></persName>
		</author>
		<ptr target="http://pypi.python.org/pypi" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">PYRO: Python remote objects</title>
		<author>
			<persName><surname>Pyro</surname></persName>
		</author>
		<ptr target="http://pyro.sourceforge.net" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Python: Python programming language-official website</title>
		<ptr target="http://python.org" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Python &amp; Java: a side-by-side comparison</title>
		<author>
			<persName><surname>Pythonvsjava</surname></persName>
		</author>
		<ptr target="http://www.ferg.org/projects/python_java_side-by-side.html" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">PyUtilib optimization framework</title>
		<author>
			<persName><surname>Pyutilib</surname></persName>
		</author>
		<ptr target="http://software.sandia.gov/pyutilib" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Roelofs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bisschop</surname></persName>
		</author>
		<ptr target="http://lulu.com" />
		<title level="m">AIMMS 3.9-The User&apos;s Guide</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Building your own plugin framework</title>
		<author>
			<persName><forename type="first">G</forename><surname>Sayfan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dr. Dobbs J</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<author>
			<persName><forename type="first">A</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dentcheva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruszczynski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Lectures on Stochastic Programming: Modeling and Theory</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">S</forename><surname>Sage</surname></persName>
		</author>
		<ptr target="http://www.sagemath.org" />
	</analytic>
	<monogr>
		<title level="m">Open Source Mathematical Software</title>
		<title level="s">The Sage Group</title>
		<imprint>
			<date type="published" when="2008-02-10">Version 2.10.2. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Component Software: Beyond Object-Oriented Programming</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szyperski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>ACM Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title/>
		<author>
			<persName><surname>Tomlab</surname></persName>
		</author>
		<ptr target="http://www.tomopt.com/tomlab" />
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>TOMLAB optimization environment</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Dynamically typed languages</title>
		<author>
			<persName><forename type="first">L</forename><surname>Tratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Comput</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="149" to="184" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Hart</surname></persName>
		</author>
		<ptr target="https://software.sandia.gov/trac/coopr/attachment/wiki/PySP/pysp_jnl.pdf" />
		<title level="m">Pysp: modeling and solving stochastic programs in python</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<ptr target="http://yaml.org/" />
		<title level="m">YAML: The official YAML web site</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Open source software reliability model: an empirical approach</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGSOFT Softw. Eng. Notes</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
