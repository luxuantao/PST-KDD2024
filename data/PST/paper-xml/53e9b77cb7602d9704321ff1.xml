<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Revisiting Co-Processing for Hash Joins on the Coupled CPU-GPU Architecture</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jiong</forename><surname>He</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mian</forename><surname>Lu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Nanyang Technological University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">STAR Institute of HPC</orgName>
								<address>
									<country>Singapore Bingsheng He</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Nanyang Technological University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">The 39th International Conference on Very Large Data Bases</orgName>
								<address>
									<addrLine>Riva del Garda</addrLine>
									<postCode>26th -30th 2013</postCode>
									<settlement>August, Trento</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Revisiting Co-Processing for Hash Joins on the Coupled CPU-GPU Architecture</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1A932C845B0F5CCC8C524322FF60F387</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:07+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Query co-processing on graphics processors (GPUs) has become an effective means to improve the performance of main memory databases. However, the relatively low bandwidth and high latency of the PCI-e bus are usually bottleneck issues for co-processing. Recently, coupled CPU-GPU architectures have received a lot of attention, e.g. AMD APUs with the CPU and the GPU integrated into a single chip. That opens up new opportunities for optimizing query coprocessing. In this paper, we experimentally revisit hash joins, one of the most important join algorithms for main memory databases, on a coupled CPU-GPU architecture. Particularly, we study the fine-grained co-processing mechanisms on hash joins with and without partitioning. The co-processing outlines an interesting design space. We extend existing cost models to automatically guide decisions on the design space. Our experimental results on a recent AMD APU show that (1) the coupled architecture enables fine-grained co-processing and cache reuses, which are inefficient on discrete CPU-GPU architectures; (2) the cost model can automatically guide the design and tuning knobs in the design space; (3) fine-grained co-processing achieves up to 53%, 35% and 28% performance improvement over CPUonly, GPU-only and conventional CPU-GPU co-processing, respectively. We believe that the insights and implications from this study are initial yet important for further research on query co-processing on coupled CPU-GPU architectures.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Query co-processing on GPUs (or Graphics Processing Units) have been an effective means to improve the performance of main memory databases(e.g., <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b21">22]</ref>). Compared with CPUs, GPUs have rather high memory bandwidth and massive thread parallelism, which is ideal for data parallelism in query processing. Designed as a coprocessor, the GPU is usually connected to the CPU with a PCI-e bus. So far, most research studies on GPU query coprocessing have been conducted on such discrete CPU-GPU architectures. The relatively low bandwidth and high latency of the PCI-e bus are usually bottleneck issues <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b21">22]</ref>. GPU co-processing algorithms have to be carefully designed so that the overhead of data transfer on PCI-e is minimized. Recently, hardware vendors have attempted to resolve this overhead with new architectures. We have seen integrated chips with coupled CPU-GPU architectures. The CPU and the GPU are integrated into a single chip, avoiding the costly data transfer via the PCI-e bus. For example, the AMD APU (Accelerated Processing Unit) architecture integrates the CPU and the GPU into a single chip, and Intel released their latest generation Ivy Bridge processor in late April, 2012. These new heterogeneous architectures potentially open up new optimization opportunities for GPU query co-processing. Since hash joins have been extensively studied on both CPUs and GPUs and are one of the most important join algorithms for main memory databases, this paper revisits co-processing for hash joins on the coupled CPU-GPU architecture.</p><p>Before exploring the new opportunities by the coupled architecture, let us analyze the performance issues of query coprocessing on discrete architectures. A number of hash join algorithms have been developed for CPU-GPU co-processing on the discrete architecture <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23]</ref>. The data transfer on the PCI-e bus is an inevitable overhead, although it is feasible to reduce this overhead by overlapping computation and data transfer. This data transfer leads to coarse-grained query co-processing schemes. Most studies off-load the entire join to the GPU, and the CPU is usually under-utilized during the join process. On the other hand, co-processing on the discrete architecture under-utilizes the data cache, because the CPU and the GPU have their own caches. This prohibits cache reuse among processors to reduce the memory stall, which is one of the major performance factors for hash joins <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b26">27]</ref>.</p><p>By integrating the CPU and the GPU into the same chip, the coupled architecture eliminates the data transfer overhead of the PCI-e bus. Existing query co-processing algorithms (e.g., <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref>) can immediately gain this performance improvement. However, a natural question is whether and how we can further improve the performance of co-processing on the coupled architecture. Considering the above-mentioned performance issues of co-processing on discrete architectures, we find that the two hardware features of the coupled architecture lead to significant implications on the effectiveness of co-processing.</p><p>Firstly, unlike discrete architectures where the CPU and the GPU have their own memory hierarchy, the CPU and the GPU in the coupled architecture share the same physical main memory. Furthermore, they can share some levels of the cache hierarchy (e.g., the CPU and the GPU in the AMD APU share the L2 data cache). The CPU and the GPU can communicate at the memory (or even cache) speed, and more fine-grained co-processing designs and data sharing are feasible, which are inefficient on the discrete architecture.</p><p>Secondly, due to the limited chip area, the GPU in the coupled architecture is usually less powerful than the highend GPU in discrete architectures (see Table <ref type="table" target="#tab_0">1</ref> of Section 2). The GPU in the coupled architecture usually cannot deliver a dominant performance speedup as it does in discrete architectures. Therefore, a good co-processing scheme must keep both processors busy as well as carefully assigning workloads to them for the maximized speedup.</p><p>In this paper, we revisit co-processing schemes for hash joins on such CPU-GPU coupled architectures. Specifically, we examine both hash joins with and without partitioning, and explore the design space of fine-grained co-processing on the coupled architecture. Additionally, we consider a series of design tradeoffs such as whether the hash table should be shared or separated between the two processors as well as different co-processing granularities. We extend existing cost models to predict the performance of hash joins with different co-processing schemes, and thus guide the decisions on co-processing design space.</p><p>We implement all co-processing schemes of hash joins with OpenCL on AMD APU A8 3870K. The major experimental results are summarized as follows.</p><p>First, we evaluate the co-processing schemes on the (emulated) discrete architecture in comparison with the coupled architecture, and show that (1) conventional co-processing of hash joins <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b22">23]</ref> can achieve only marginal performance improvement on the coupled architecture; (2) the coupled architecture enables fine-grained co-processing and cache reuse optimizations, which are inefficient/infeasible on discrete architectures (Section 5.2).</p><p>Second, we evaluate the cost model and show that our cost model is able to effectively guide the decision on the optimizations in the design space (Section 5.3).</p><p>Third, we evaluate a number of design tradeoffs on the fine-grained co-processing, which are important for the hash join performance (Section 5.4).</p><p>Fourth, we evaluate a number of co-processing variants, and show that fine-grained co-processing achieves up to 53%, 35% and 28% performance improvement compared with CPUonly, GPU-only and conventional CPU-GPU co-processing, respectively (Section 5.5).</p><p>To the best of our knowledge, this is the first systematic study of hash join co-processing on the coupled architecture. We believe that the insights and implications from this study can shed light on further research of query co-processing on CPU-GPU coupled architectures.</p><p>Organization. The remainder of this paper is organized as follows. In Section 2, we briefly introduce background and related work. In Section 3, we revisit fine-grained CPU-GPU co-processing schemes for hash joins. The cost model is described in Section 4. We present the experimental results in Section 5 and conclude in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES AND RELATED WORK</head><p>We first introduce CPU-GPU architectures and OpenCL, and then review the related work on hash joins. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Coupled CPU-GPU Architecture</head><p>GPUs have emerged as promising hardware co-processors to speedup various applications, such as scientific computing <ref type="bibr" target="#b32">[33]</ref> and database operations <ref type="bibr" target="#b16">[17]</ref>. With massive thread parallelism and high memory bandwidth, GPUs are suitable for applications with massive data parallelism and high computation intensity.</p><p>One hurdle for the effectiveness of CPU-GPU co-processing is that the GPU is usually connected with the CPU with a PCI-e bus, as illustrated in Figure <ref type="figure" target="#fig_0">1</ref> (a). On such discrete architectures, the mismatch between the PCI-e bandwidth (e.g., 4-8 GB/sec) and CPU/GPU memory bandwidth (e.g., dozens to hundreds of GB/sec) can offset the overall performance of CPU-GPU co-processing. As a result, it is preferred to have coarse-grained co-processing to reduce the data transfer on the PCI-e bus. Moreover, as the GPU and the CPU have their own memory controllers and caches (such as L2 data cache), data accesses are in different paths.</p><p>Recently, vendors have released new coupled CPU-GPU architectures, such as the AMD APU and Intel Ivy Bridge. An abstract view of the coupled architecture is illustrated in Figure <ref type="figure" target="#fig_0">1 (b)</ref>. The CPU and the GPU are integrated into the same chip. They can access the same main memory space, which is managed by a unified memory controller. Furthermore, both processors share the L2/L3 data cache, which potentially increases the cache efficiency.</p><p>Table <ref type="table" target="#tab_0">1</ref> gives an overview of AMD APU A8-3870K, which is used in our study. We also show the specification of the latest AMD GPU (Radeon HD 7970) in discrete architectures for comparison. The GPU in the coupled architecture has a much smaller number of cores at lower clock frequency, mainly because of chip area limitations. On current AMD APUs, the system memory is further divided into two parts, which are host memory for the CPU and device memory for the GPU. Both of the two memory spaces can be accessed by either the GPU or the CPU through the zero copy buffer. This study stores the data in the zero copy buffer to fully take advantage of co-processing capabilities of the coupled architecture. The current zero copy buffer is relatively small, which can be relaxed in the future coupled CPU-GPU architecture [2].</p><p>There have been some studies (like MapReduce <ref type="bibr" target="#b5">[6]</ref> and key-value stores <ref type="bibr" target="#b19">[20]</ref>) on the coupled architecture. Most studies have demonstrated the performance advantage of the coupled architecture over the CPU-only or the GPU-only algorithm. This study focuses on hash joins, and goes beyond existing studies <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b19">20]</ref> in two major aspects. Firstly, we revisit the design space of hash joins on the coupled architecture and develop a cost model that can guide the decisions for co-processing. We conjecture that the design space and cost models are also applicable to those studies <ref type="bibr">[</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">OpenCL</head><p>We develop our co-processing schemes based on OpenCL, which is specifically designed for heterogeneous computing. The advantage of OpenCL is that the same OpenCL code can run on both the CPU and the GPU without modification. A vendor-specific compiler is employed to optimize OpenCL to the target architecture. Previous studies (such as <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b34">35]</ref>) have shown that implementations with Open-CL achieve very close performance to those with native languages such as CUDA and OpenMP on the GPU and the CPU, respectively.</p><p>In OpenCL, the CPU and the GPU can be viewed to have the same logical architecture, namely compute device. On the APU, the CPU and the GPU are programmed as two compute devices. A compute device consists of a number of Compute Units (CUs). Furthermore, each CU contains multiple Processing Elements (PEs) running in SIMD style. The piece of code executed by a specific device is called a kernel. A kernel employs multiple work groups for the execution, and each work group contains a number of work items. A work group is mapped to a CU, and multiple work items are executed concurrently on the CU. The execution of a work group on the target architecture is vendor specific. AMD usually executes 64 work items in a wavefront and NVIDIA with 32 work items in a warp. All work items in the same wavefront run in the SIMD manner. In this paper, we use the terminology from AMD.</p><p>OpenCL exposes a logical memory hierarchy with three levels, i.e., global memory, local memory and private memory. The global memory is accessible to all work items with high access latency. The small but fast local memory is shared by all work items within the same work group. Furthermore, the smallest private memory is only accessible to a work item with the lowest latency. The logical memory hierarchy is mapped to the physical memory hierarchy of the target processor by the compiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Architecture-aware Hash Joins</head><p>Hash joins are considered as the most efficient join algorithm for main memory databases. Fruitful research efforts have been devoted to hash joins in the past decades. Researchers have optimized hash join algorithms in two main categories: for a single hash join <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr">8,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b2">3]</ref> and for a pipeline of hash joins <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b6">7]</ref>. In this study, we focus on a single hash join, which can be the basic building block for a pipeline of hash joins. There are also many studies on parallel hash joins on multi-processor environments(e.g., <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b9">10]</ref>). We focus on the related work on modern architectures.</p><p>Memory stalls have been a major performance bottleneck for hash joins in main memory databases <ref type="bibr" target="#b1">[1,</ref><ref type="bibr" target="#b26">27]</ref>, because of random memory accesses. New algorithms (either cacheconscious <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b4">5]</ref> or cache-oblivious <ref type="bibr" target="#b15">[16]</ref>) have been developed to exploit data access locality. The other approach <ref type="bibr">[8]</ref> is to hide the memory latency with computation by software prefetching techniques.</p><p>For multi-core CPUs, memory optimizations continue to be a major research focus. Garcia et al. <ref type="bibr" target="#b12">[13]</ref> examined a pipelined hash join implementation. NUMA memory systems have also been investigated <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b23">24]</ref>. In addition to memory optimizations, there have been studies with architectureaware tuning and optimizations. Blanas et al. <ref type="bibr" target="#b3">[4]</ref> showed that synchronization is also an important factor affecting the overall performance of hash joins on multi-core processors. Ross <ref type="bibr" target="#b28">[29]</ref> proposed a hash join implementation based on Cuckoo hashing employing branch instruction elimination and SIMD instructions. Balkesen et al. <ref type="bibr" target="#b2">[3]</ref> carefully evaluated hardware-conscious techniques.</p><p>In addition to CPUs, new architectures (e.g., network processors <ref type="bibr" target="#b13">[14]</ref>, cell <ref type="bibr" target="#b28">[29]</ref> and GPUs <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b22">23]</ref>) have also been proposed to improve join performance. Query co-processing on GPUs has received a lot of attentions. By exploiting the hardware feature of GPUs, the performance of hash joins can be significantly improved <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b22">23]</ref>. There have also been proposals on reducing the PCI-e bus overhead for join co-processing on the GPU. Kaldewey et al. <ref type="bibr" target="#b21">[22]</ref> evaluated the join processing on NVIDIA GPUs by adopting UVA (Universal Virtual Addressing). Pirk et al. <ref type="bibr" target="#b27">[28]</ref> proposed to exploit the asymmetric memory channels.</p><p>Among various hash join algorithms, there are two basic forms: simple hash join and partitioned hash join. These two algorithms have demonstrated very competitive performance on multi-core CPUs and GPUs in many previous studies <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b16">17]</ref>. Thus, this study will experimentally revisit both of them on the coupled architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">HASH JOIN CO-PROCESSING</head><p>In the Introduction, we have described the two implications on the effectiveness of co-processing on the coupled architecture. On the coupled architecture, co-processing should be fine-grained, and schedule the workloads carefully to the CPU and the GPU. Moreover, we need to consider the memory specific optimizations for the shared cache architecture and memory systems exposed by OpenCL.</p><p>We start by defining the fine-grained step definitions in hash joins. A step consists of computation or memory accesses on a set of input or intermediate tuples. Next, we revisit the design space of co-processing, leading to a number of hash join variants with and without partitioning. Finally, we present the implementation details of some design tradeoffs in memory optimizations and OpenCL-related optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Fine-grained Steps in Hash Joins</head><p>A hash join operator works on two input relations, R and S. We assume that |R| &lt; |S|. A typical hash join algorithm has three phases: partition, build, and probe. The partition phase is optional, and the simple hash join does not have a partition phase. We define the fine-grained steps for the simple hash join (SHJ) and the partitioned hash join (PHJ) in Algorithms 1 and 2, respectively. The granularity of our step definition is similar to that in the previous study by Chen et al. <ref type="bibr">[8]</ref>. We will discuss other step definitions in Section 3.3.</p><p>In SHJ, the build phase constructs an in-memory hash table for R. Then in the probe phase, for each tuple in S, it looks up the hash table for matching entries. Both the build and the probe phases are divided into four steps, b1 to b4 and p1 to p4, respectively. The simple hash join has poor data locality if the hash table cannot fit into the cache. However, a recent study by Blanas et al. <ref type="bibr" target="#b3">[4]</ref> showed that SHJ is very competitive to other complex hash join algorithms on the multi-core CPUs, especially with data skew.</p><p>We adopt the hash table implementation that has been used in the previous studies <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b22">23]</ref>. A hash table consists of an array of bucket headers. Each bucket header contains two fields: total number of tuples within that bucket and the pointer to a key list. The key list contains all the unique keys with the same hash value, each of which links a rid list storing the IDs for all tuples with the same key. We adopt radix hash join <ref type="bibr" target="#b4">[5]</ref> as PHJ in this study. In PHJ, it first splits the input relations R and S into the same number of partitions through a radix partitioning algorithm. The radix partitioning is performed by multiple passes based on a number of lower bits of the integer hash values. The number of passes is tuned according to the memory hierarchy (e.g., TLB and data caches). On each pass of partitioning, the steps are the same, n1 to n3. We use a structure similar to the hash table to store all the partitions, where a bucket is used to store a partition. Next, PHJ performs SHJ on each partition pair from R and S in Algorithm 1.</p><p>We consider a hash join algorithm with multiple series of data-parallel steps (namely step series) separated by barriers. For each input data item (e.g., a tuple or largergranularity data), it goes through all the steps to generate the result, and data dependency exists between two consecutive steps. We view the step definition with the granularity of one tuple as fine-grained ones. That is, we develop coprocessing schemes based on the per-tuple step definitions in Algorithms 1 and 2. An SHJ has two step series, b1, ..., b4 for the build phase and p1, ..., p4 for the probe phase. There is a barrier between the build and the probe phases. Similarly, a PHJ with g-pass partitioning has g step series (n1, ..., n3) plus two step series the same as SHJ for joining each partition pair.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Revisiting Co-processing Mechanisms</head><p>We revisit the following co-processing mechanisms, which have their roots in query processing techniques in previous studies <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23]</ref>. Particularly, we describe the high-level idea of each co-processing mechanism and their strengths and weakness in co-processing on the coupled architecture. Applying those co-processing schemes to SHJ and PHJ creates an interesting design space for co-processing on the coupled architecture. Thus, we summarize a number of hash join variants at the end of this subsection.</p><p>In the following description, we consider a general step series with n steps denoted by s1, ..., sn.</p><p>Off-loading (OL). In the previous study on GPU-accelerated query processing <ref type="bibr" target="#b16">[17]</ref>, OL is the major technique to exploit the GPU. For example, the previous study <ref type="bibr" target="#b16">[17]</ref> proposed to off-load some heavy operators like joins to the GPU while other operators in the query remain on the CPU. The basic idea of OL on a step series is: the GPU is designed as a powerful massively parallel query co-processor, and a step is evaluated entirely by either the GPU or the CPU. Query processing continues on the CPU until the off-loaded computation completes on the GPU, and vice versa. That is, given a step series s1, ..., sn, we need to decide if si is performed on the CPU or the GPU.</p><p>On the discrete architecture, the PCI-e data transfer overhead is an important consideration for OL. The decision to off-load a step affects the decisions on other steps. As a result, we have to consider 2 n possible offloading schemes for the step series. In contrast, on the coupled architecture, by eliminating the data transfer overhead, the offloading decision is relatively simple: depending only on the performance comparison of running the steps on the CPU and the GPU.</p><p>Data dividing (DD). OL could under-utilize the CPU when the off-loaded computations are being executed on the GPU, and vice versa. As the performance gap between the GPU and the CPU on the coupled architecture is smaller than that on discrete architectures, we need to keep both the CPU and the GPU busy to further improve the performance. Thus, the CPU and the GPU work simultaneously on the same step. We can model the CPU and the GPU as two independent processors, and the problem is to schedule the workload to them. This problem has its root in parallel query processing <ref type="bibr" target="#b8">[9]</ref>. One of the most commonly used schemes is to partition the input data among processors, perform parallel query processing on individual processors and merge the partial results from individual processors as the final result. We adopt this scheme to be the data-dividing co-processing scheme (DD) on the coupled architecture. Particularly, given a step series s1, ..., sn, we need to decide a work ratio for the CPU, r (0 ≤ r ≤ 1) so that a portion of r of all tuples on the step series are performed on the CPU, and the remainder are performed on the GPU. If r = 0, DD becomes a CPU-only execution; if r = 1.0, it becomes a GPU-only execution. To reduce the amount of the intermediate result, each tuple goes through all the steps in a pipelined manner in DD.</p><p>The advantage of DD is that we can leverage the parallel query processing techniques in parallel databases to keep both the CPU and the GPU busy. However, DD may still cause under-utilization of the CPU and the GPU. Considering the fact that DD uses coarse-grained workload scheduling, some steps assigned to the CPU actually have higher performance on the GPU, and vice versa. That means, the workload scheduling has to consider the performance characteristics of the CPU and the GPU, and to perform finegrained scheduling for the optimal efficiency on individual processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pipelined execution (PL).</head><p>To address the limitations of OL and DD, we consider fine-grained workload scheduling between the CPU and the GPU so that we can capture their performance differences in processing the same workload. For example, the GPU is much more efficient than the CPU on b1 and p1 whereas b3 and p3 are more efficient on the CPU. Meanwhile, we should keep both processors busy. Therefore, we leverage the concept of pipelined execution and develop an adaptive fine-grained co-processing scheme for maximizing the efficiency of co-processing on the coupled architecture.</p><p>Unlike DD that has the same workload ratios for all steps, we consider the data-dividing approach at the granularity of each step (as illustrated in Figure <ref type="figure" target="#fig_1">2</ref>). Within Step si, we have a ratio ri of the tuples assigned to the CPU and the remainder (1 -ri) assigned to the GPU. This differs from DD as we may have different workload ratios across steps. Intermediate results are generated on two consecutive steps if they have different workload ratios. For given workload ratios, we prefer a longer pipeline (a larger number of steps that a tuple can go through) to reduce the amount of intermediate results. On the other hand, we need to pay attention to the data dependency between steps. If the output data of Step si is not available for Step si+1, Step si+1 has to be stalled.</p><p>To achieve the optimal performance, the suitable workload ratios ri (1 ≤ i ≤ n) should adapt to the computational characteristics of the steps. We have developed a cost model to evaluate the performance of the pipelined execution for the given ratios r1, ..., rn for Steps s1, ..., sn, respectively. Then, we use a simple approach to obtain the suitable ratios for the best estimated performance. Specifically, we consider all the possible ratios at the step of δ for ri (1 ≤ i ≤ n, 0 ≤ δ ≤ 1), i.e., ri=δ, 2δ, 3δ, ..., ⌊ 1 δ ⌋δ. For each set of given ratios, we use the cost model to predict the performance, and thus get the suitable workload ratios. In our experiments, we use δ = 0.02 as a tradeoff between the effectiveness and the execution time of optimizations.</p><p>We can consider OL and DD as special cases for PL. DD is equivalent to PL with all the ratios the same on all steps. OL is equivalent to PL with all the workload ratios being either zero or one.</p><p>The co-processing schemes presented above outline an interesting design space for hash joins on the coupled archi- tecture. In this experimental study, we focus on evaluating how those co-processing mechanisms are implemented in SHJ and PHJ.</p><p>We apply DD, OL and PL schemes to SHJ and obtain three variants (SHJ-DD, SHJ-OL and SHJ-PL, respectively). For each variant, we consider all bi (1 ≤ i ≤ 4) in the build phase and all pi (1 ≤ i ≤ 4) in the probe phase as two different step series. There are some tuning parameters, and we use the cost model presented in the next section to determine their suitable values for the best performance. Some details of those SHJ variants are described as follows: (1) SHJ-DD: It decides two workload ratios, r b and rp, 0 ≤ r b , rp ≤ 1, for the build and the probe phases, respectively. For example, in the build phase, a portion of r b of the build table are processed by the CPU to construct the hash table . (2) SHJ-OL: It decides whether each of the steps (bi in the build phase and pi in the probe phase) is performed on the CPU or the GPU. (3) SHJ-PL: It determines the suitable workload ratios for all the steps in the build and the probe phases.</p><p>We apply DD, OL and PL schemes to PHJ and obtain three variants (PHJ-DD, PHJ-OL and PHJ-PL, respectively). The idea is the same as the above SHJ variants, except that we consider the steps in each pass of partitioning as a step series.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Implementations and Design Tradeoffs</head><p>There are a few design tradeoffs in memory optimizations and OpenCL-related optimizations, which often have significant impact on the performance of hash joins.</p><p>Memory allocator. In the hash join algorithm, dynamic memory allocations are common, including (1) the output buffer for a partition, (2) allocating a new key in the key list, and (3) the join result output. Current OpenCL (version 1.2) does not support dynamic memory allocation inside the kernel. The efficiency in supporting dynamic memory allocations is essential for those operations. Inspired by the previous study <ref type="bibr" target="#b20">[21]</ref>, we develop a software dynamic memory allocator on a pre-allocated array, and memory requests are dynamically allocated from that array.</p><p>A basic implementation of the memory allocator is to use a single pointer marking the starting address of the free memory in an pre-allocated array. The pointer initially points to the starting address of the array. After serving a memory request, the pointer is moved accordingly. We use the atomic operation (specifically atomic add in our study) to implement a latch for synchronization among multiple requests. Additionally, the latch is applicable at both the local memory and the global memory operations. However, this basic implementation could suffer from the contention of atomic operations, especially for supporting massive thread parallelism on the GPU.</p><p>To reduce the contention, we develop an optimized memory allocator. The memory allocation is at the granularity of a block. The block size is a tuning parameter and we will experimentally evaluate its impact in the experiments. The memory allocator maintains a global pointer. The memory request is always made by work item 0 (Thread 0) from a work group, and the global pointer is advanced by one block size. The memory allocator returns one block to the work group. The threads within the work group request memory from the block. It uses a local pointer for synchronization among the threads within the work group. We allocate the local pointer in the local memory to reduce the memory access overhead. Note, the local memory is accessible to all the threads within a work group.</p><p>The optimized memory allocator resolves the contention on the GPU. Additionally, the pre-allocation is also beneficial for the CPU. It eliminates many small malloc operations, and reduces the memory allocation overhead on the CPU.</p><p>Shared vs. separate hash tables. Cache performance and concurrency are two key factors for the design of hash tables. An important design choice in the build phase is to use a shared hash table or separate hash tables for the CPU and the GPU. Either solution has its own benefits and drawbacks. A shared hash table has better cache performance, since the CPU and the GPU share the data cache on the coupled architecture. Additionally, it uses less memory space in the zero copy buffer. On the other hand, separate hash tables have smaller latch contention between the CPU and the GPU. We experimentally evaluate these two solutions.</p><p>Workload divergence. In OpenCL, all work items in the same wavefront run simultaneously in a lockstep. The execution time of a wavefront is equal to the worst execution time of all work items. Workload divergence among work items causes severe penalties in the overall performance of the wavefront. One common source of workload divergence in hash joins is data skew. For example, data skews cause workload divergence in b3 in the build phase and p3 in the probe phase.</p><p>To reduce the workload divergence, we adopt a groupingbased approach in the previous study <ref type="bibr" target="#b17">[18]</ref>, which is used to reduce the branch divergence of transaction executions on the GPU. In order to reduce the workload divergence, we group the input data according to the amount of workload. Using the probe as an example, the input data are the hash bucket headers given in b2, and the amount of workload is represented by the number of keys in the key list. After grouping, the input data with the similar amount of workload are grouped together, and the divergence among the work items in a work group is reduced. The number of groups is tuned for the tradeoff between the grouping overhead and the gain of reduced workload divergence.</p><p>Step definitions. So far, we have adopted very finegrained step definitions for co-processing. Ideally, there are other granularities of defining steps, which can have different memory performance and efficiency of co-processing.</p><p>We are particularly interested in evaluating the step definition for PHJ in the previous study <ref type="bibr" target="#b3">[4]</ref>. After the partition phase, we have got P partition pairs on R and S (&lt;Ri, Si&gt;, 0 ≤ i ≤ P -1). The further join processing on Ri and Si is performed by one thread. Thus, all the join processing on the P partition pairs on R and S can be viewed as a step, and a partition pair is considered to be the input data The peak instruction per cycle on XPU item to the step. Thus, the granularity for a step for this co-processing is a SHJ on the partition pair. Note, those SHJs use separate hash tables, which potentially loses the opportunities of cache reuse in our fine-grained PHJ variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PERFORMANCE MODEL</head><p>There are a number of parameters (for example, the ratio in the data-dividing scheme) to be determined for the coprocessing performance on the coupled architecture. In this section, we develop a cost model to predict the performance of hash joins with co-processing on the coupled architecture, and then use the cost model to determine the suitable values for the parameters.</p><p>Cost models for hash joins have been developed in previous studies, e.g., on the CPU <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b25">26]</ref> and the GPU <ref type="bibr" target="#b14">[15]</ref>. Those cost models are highly specialized for the target architectures and the architecture-specific query processing algorithms. For example, the cost model for GPU-based coprocessing <ref type="bibr" target="#b14">[15]</ref> needs the cost estimation on the PCI-e data transfer. In this study, the implementations on the CPU and the GPU are based on the same OpenCL programs with different input parameters. The CPU and the GPU are abstracted as the same compute device model. Moreover, the CPU and the GPU share the data cache and the main memory without the PCI-e bus on the coupled architecture. It is desirable to have an unified model to estimate the performance of co-processing on both the CPU and the GPU in terms of both computation and memory latency.</p><p>In Section 3, we have identified PL as a basic abstraction for hash join co-processing on the coupled architecture (DD and OL are special cases for PL). This allows us to abstract the common design issues on the cost model for different co-processing schemes. We call this high level abstraction the abstract model. For a specific co-processing algorithm, we obtain its cost model by instantiating the abstract model with profiling and algorithm-specific analytic modelling (e.g., memory optimizations). In the remainder of this section, we first present the abstract model for PL on the coupled architecture, and next use SHJs as an example of instantiating the abstract model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Abstract Model</head><p>We model the elapsed time of executing a step series with PL. The step series consists of n steps, with xi input data items on Step i (1 ≤ i ≤ n). The cost model predicts the elapsed time of PL with workload ratios ri in Step i. The parameters are summarized in Table <ref type="table" target="#tab_2">2</ref> for reference. Thus, the total elapsed time T is estimated to be the longer execution time of the CPU and the GPU.</p><formula xml:id="formula_0">T = max(TXPU ), XPU = {CPU , GPU } (1)</formula><p>On each processor, we estimate the execution time to be the total execution time of all steps in the step series. The execution time of Step i (T i XPU ) is further estimated in three parts: computation time C i XPU , global memory access time M i XPU and the pipelined delay</p><formula xml:id="formula_1">D i XPU . TXPU = n ∑ i=1 T i XPU = n ∑ i=1 (C i XPU + M i XPU + D i XPU ) (2)</formula><p>We describe the estimation of each component accordingly.</p><p>We estimate the computation time to be the total execution time for all the instructions of the step. We assume an ideal execution pipeline with the optimal IPC on each processor, and a hash join on uniform data distributions.</p><formula xml:id="formula_2">C i XPU = #I i XPU × ri × xi IPC XPU (3)</formula><p>To estimate the memory stalls, we adopt a traditional calibration method for the CPU <ref type="bibr" target="#b25">[26]</ref> and for the GPU <ref type="bibr" target="#b14">[15]</ref>, which can estimate the memory stall cost per data item in each step. The basic idea is to measure the memory stall cost, by excluding the caching effects and the thread parallelism. It is suitable to estimate the memory stall costs for both random and sequential accesses. For details on the calibrations and models, we refer readers to the original paper <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b25">26]</ref>. For different steps, we have instantiated the model with the consideration of their access patterns.</p><p>For D i XPU , this delay is caused by different workload ratios in the two consecutive steps. Due to data dependency between the two processors, one processor has to synchronize with the other one on Step i if the workload ratios are different on Steps i and (i -1). The delay occurs when the input data for Step i have not been generated from Step (i-1). There are two cases depending on the workload ratio comparison.</p><p>Case 1: if ri &gt; ri-1, we use Eq. 4. The CPU may encounter delay while the GPU prepares the input data in Step (i -1) for the CPU in Step i. The ratio of the GPU time that is not pipelined with the CPU in Step (i -1) is</p><formula xml:id="formula_3">1-r i 1-r i-1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By subtracting this amount of time (T i-1</head><p>GP U × 1-r i 1-r i-1 ) from the total GPU time from Step 1 to Step i -1, we get the time of the GPU from Step 1 to the end of the pipelined execution area in Step i -1. The total CPU time from Step 1 to the end of pipelined execution area with the GPU in</p><p>Step i is i ∑ j=1 T j CPU . Therefore, D i CP U is the delay time on the CPU to wait for data generated from the GPU in Step i -1, as in Eq. 4. Naturally, if D i CP U ≤ 0, it is set as 0, meaning there will be no pipelined execution delay.</p><formula xml:id="formula_4">D i CPU = ( i-1 ∑ j=1 T j GPU -T i-1 GP U × 1 -ri 1 -ri-1 ) - i ∑ j=1 T j CPU (<label>4</label></formula><formula xml:id="formula_5">)</formula><p>Case 2: If ri &lt; ri-1, we use Eq. 5 to calculate the pipelined execution delay for the GPU in a similar way to Case 1.</p><formula xml:id="formula_6">D i GPU = i-1 ∑ j=1 T j CPU -( i ∑ j=1 T j GPU -T i GPU × 1 -ri-1 1 -ri ) (5)</formula><p>Finally, as specific to the pipelined co-processing, we need to estimate the cost of intermediate results and the communication cost between the CPU and the GPU. We estimate the cost for two consecutive steps. If they have the same workload ratio, we can ignore the costs on intermediate results and the communication. Otherwise, the amount of intermediate results can be derived from the difference of the workload ratio between the two steps. For Step i, the number of intermediate data items is (ri -ri-1) × xi, assuming a uniform distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Model Instantiation</head><p>We use SHJs as an example to illustrate the model instantiation. We consider fine-grained co-processing SHJ variants (with the granularity of tuples).</p><p>For computation time, the optimal IPC value can be obtained from the hardware specification. The number of instructions for per tuple in each step can be obtained from profiling tools such as AMD CodeXL and AMD APP Profiler. One issue to handle is that the number of instructions per tuple in some steps varies with the workload. For example, the costs of b3 and p3 depend on the length of the key list. Therefore, we use the number of instructions per key search as the unit cost for that step, and estimate the number of instructions of the step to be the number of instructions per key search multiplied by the average number of keys in the key list.</p><p>Next, we calibrate the memory unit cost per tuple with the calibration method <ref type="bibr" target="#b14">[15]</ref>. For some steps, the memory unit cost is workload-dependent. We adopt the same approach as profiling the number of instructions discussed above.</p><p>Given the above calibrations, we can derive the total cost for different SHJ variants. Here, we use SHJ-DD as an example, and we can derive the cost for other variants similarly. We estimate the performance of SHJ-DD as the total elapsed time of the build phase and the probe phase. Since the estimation of the build phase is similar to the probe phase, we estimate the build phase as follows. We instantiate Eqs. 1-5. In Eq. 2, we set n = 4, because there are four steps in the build phase. In Eq. 3, the number of instructions is substituted with the profiled result from each step. We then use the calibrated values for each step to get the memory costs, and determine the pipelined execution delay in Eqs. 4 and 5. Thus, we can get the cost for the build phase in Eq. 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>In section, we experimentally evaluate the co-processing scheme for the hash join on the coupled CPU-GPU architecture. Overall, there are four groups of experiments. Firstly, we investigate the overhead of data transfers and other operations of co-processing for the hash join on a discrete CPU-GPU architecture (Section 5.2). Secondly, we evaluate the accuracy of our cost model (Section 5.3). Thirdly, we study the performance impact of the design tradeoffs in coprocessing of hash joins (Section 5.4). Finally, we show the end-to-end performance comparison (Section 5.5). More experimental results can be found in the extended version <ref type="bibr" target="#b18">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>Hardware configuration. We conduct our experiments on a PC equipped with an AMD APU A8-3870K. The hardware specification has been summarized in Table <ref type="table" target="#tab_0">1</ref>.</p><p>Data sets. We use the same synthetic data sets as the previous study <ref type="bibr" target="#b3">[4]</ref> to evaluate our implementations. Both relations R and S consist of two four-byte integer attributes, namely the record ID and key value. Our default data set size is 16 million tuples with uniform-distributed key values for both relations R and S, unless specified otherwise. Both R and S can be considered as basic relations (without compression) in column-oriented databases, or the intermediate relations by extracting the key and record ID from much larger relations in row-oriented databases. We experimentally evaluate the impact of different data sizes. In addition to uniform data sets, we also use skewed data sets and vary the selectivity to show the overall performance comparisons. We created two skewed datasets with s% of tuples with one duplicate key values: low-skew with s = 10 and high-skew with s = 25.</p><p>Implementation details. We develop all hash join variants using OpenCL 1.2. The OpenCL configuration including work groups and work items has been tuned to fully utilize the CPU and the GPU capabilities. In addition to co-processing, we also implement CPU-only and GPU-only algorithms. Our implementations have adopted the common practice in the previous implementations <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5]</ref>. For example, we choose the hash function MurmurHash 2.0 that is also used in the previous study <ref type="bibr" target="#b3">[4]</ref>, which has a good hash collision rate and low computational overhead.</p><p>We compare the discrete and the coupled architectures to investigate the performance issues of discrete architectures. For a fair comparison, we should ideally use the CPU and the GPU that have exactly the same architectures as those in the coupled architecture. However, this may be not always feasible as the coupled architecture advances. Instead, we use the CPU and the GPU on the coupled architecture to emulate the CPU and the GPU on a discrete architecture, and emulate the PCI-e bus data transfer with a delay. This simulation-based approach allows us to evaluate the impact of different processors and PCI-e bus. Unlike real discrete architectures, the CPU and the GPU in the emulated architecture still share the cache. In our experiment, we find that the emulated approach is able to help us to understand the performance issues of the discrete architecture. The delay of one data transfer on PCI-e bus is estimated to be latency + size bandwidth , where size is the data size and latency and bandwidth are the latency and bandwidth of the PCI-e bus, respectively. In our study, we emulate a PCI-e bus with latency = 0.015 ms and bandwidth = 3 GB/sec.</p><p>On the emulated discrete architecture, we can implement all the hash join variants except PL. Using SHJ-DD as an example, in the build phase, a part of the build table is transferred to the GPU memory before the GPU starts building hash tables. An estimated delay is added so that the GPU starts the build phase later. When the build phase is done, the partial hash table is transferred back to the CPU for a merge operation. The probe phase has a similar process to the build phase. For PL, it is inefficient to implement the fine-grained co-processing on the discrete architecture for two reasons. Firstly, there are much more memory data transfers by exchanging the intermediate results between the CPU and the GPU. Secondly, the data dependency control logic on the GPU memory is difficult to implement on the PCI-e bus. Thus, we use the execution of PL on the coupled architecture to analyse the impact of PL on the discrete architecture, including intermediate results and efficiency of pipelined execution. Data transfer and merge overhead. We first study the time breakdown of hash join variants on the discrete architecture. For comparison, we also show the time breakdown on the coupled architecture. Figure <ref type="figure" target="#fig_2">3</ref> shows the time breakdown for the data dividing and off-loading co-processing schemes. On the discrete architecture, the workload ratios for the build and probe phases for SHJ-DD are 25% and 42%, respectively; the workload ratios for the partition, build and probe phases for PHJ-DD are 11%, 26% and 41%, respectively. We can see that the suitable workload ratios vary across different phases. SHJ-OL and PHJ-OL have degraded to be GPU-only, because all the steps on the GPU are faster than those on the CPU (as we will discussed later).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Evaluations on Discrete Architectures</head><p>On the discrete architecture, co-processing usually requires explicit data transfer on the PCI-e bus and the merge operation. In the experiments, DD has both kinds of overhead and OL has only the data transfer overhead because OL is essentially GPU-only. Overall, the PCI-e data transfer overhead is 4-10% of the overall execution time. PHJ generally has higher data transfer overhead, since it has one more phase than SHJ. In comparison, this data transfer overhead is eliminated on the coupled CPU-GPU architecture.</p><p>The merging operation usually creates a more significant overhead than the data transfer on PCI-e bus (14% and 18% of the overall time in SHJ-DD and PHJ-DD, respectively). While the data transfer overhead on the PCI-e bus can be reduced with advanced overlapping of computation and data transfer, the merge overhead is inherent to DD on the discrete architecture. In comparison, on the coupled architecture, DD uses a shared hash table (as we evaluate in Section 5.4), and the merge overhead is eliminated.</p><p>Workload ratios in DD. We study the workload ratios on two different architectures (Figures are omitted due to space limits). Generally, we find that the suitable workload ratios of the CPU on the discrete architectures are higher than those on the coupled architecture. During the data transfer, the CPU can do more useful work for DD. Since the data transfer accounts for 4-10% of the total execution time, the difference is small (smaller than 5%).</p><p>GPU and CPU processing capabilities for different steps. In order to achieve the efficiency of employing We measure the performance of each step on the CPU-only and the GPU-only algorithms. Figure <ref type="figure">4</ref> shows the average processing time per tuple for different steps in PHJ on the CPU and the GPU. We have observed similar results on SHJ. Overall, the hash value computation can greatly benefit from the GPU acceleration due to its massive data parallelism and computation intensity. Therefore, the GPU can accelerate the hash value computation based steps (i.e., n1, b1, and p1) by more than 15X. Instead, some other operations, such as b3 or p3, cannot match the GPU architecture features, because of random memory accesses and divergent branches. As a result, the GPU and the CPU have very close performance on those steps. Since different steps may have different performance comparison on the CPU and the GPU, this confirms that a fine-grained co-processing algorithm is essential to better exploit the strength of the CPU and the GPU. Workloads of different steps should be carefully assigned to suitable compute devices. That leads to our further analysis of PL. Analyzing PL. We analyze the workload ratios of different steps for PL on the coupled architecture to understand the impact of intermediate results and efficiency of pipelined execution. Figures <ref type="figure">5</ref> and<ref type="figure" target="#fig_4">6</ref> show the optimal workload ratios of different steps in SHJ-PL and PHJ-PL on the coupled architecture, respectively. Overall, the optimal workload ratios are varied across different steps. The GPU can take all workload (b1 in Figure <ref type="figure">5</ref>(a) and p1 in Figure <ref type="figure">5(b)</ref>), or takes only a very small portion of workload (1% for p4 in Figure <ref type="figure">5(b)</ref>). We have the following two implications.  Firstly, PL can be inefficient on the discrete architecture, since the significant difference in the workload ratios among the steps creates significant overhead in data transfer and pipeline execution. Recall that, in PL, the workload ratio difference between two consecutive steps determines the amount of intermediate results. We use the grey area in the figures to indicate the intermediate results to be generated during the execution of PL. For example, in Figure <ref type="figure">5</ref>, the CPU only takes 4% workload for b2, but takes 60% for b3. That requires a transfer of 56% of the output data of b2 on the PCI-e bus, if PL runs on the discrete architecture. On the other hand, the overhead of pipelined execution is not shown in the figure. The difference in the workload ratios results in different lengths of pipelines in the execution, which results in workload divergence.</p><p>The other implication is that, since the optimal workload ratios vary for different steps, the conventional approach (by offloading the entire join to the GPU) cannot fully exploit the co-processing capabilities from both the CPU and the GPU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Cost Model Evaluation</head><p>Overall, our cost model can accurately predict the performance of all hash join variants with different tuning parameters, and thus can guide the decision of getting the suitable value. Since the results are similar for both SHJs and PHJs, we focus of the results on SHJs.</p><p>Figure <ref type="figure">7</ref> compares the estimated performance with measured performance for SHJ-DD with the workload ratios varied. The black solid squares in the figures denote the optimal points. It shows that our estimated time is close to the measured time. However, the estimated time is slightly lower than the measured time. One factor to consider is that our cost model does not include the estimation of the lock contention overhead.</p><p>PL has a large design space. In general, our estimation can closely predict the performance of PL with different work- In this special case of PL, we see that our prediction is close to the performance varying r and also is able to predict its suitable value.</p><p>To evaluate our cost model in more details, we perform experiments with Monte Carlo simulations on the workload ratios. Each simulation runs a PL with randomly generated ratio settings. Figure <ref type="figure">9</ref> demonstrates the cumulative distribution function (CDF) for the elapsed time of the build phase of SHJ-PL and the probe phase of PHJ-PL with one thousand simulation runs. We also highlight the elapsed time of our approach given by the cost model. The proposed approach is very close to the best performance of the Monte Carlo simulations. For each simulation run, we evaluate the prediction by our model and the measured execution time. The difference is smaller than 15% in most cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Design Tradeoffs on Coupled CPU-GPU Architectures</head><p>We evaluate the impact of each tradeoff by varying the setting of that tradeoff while other tradeoffs have already been tuned. Based on them, we optimize the performance of the hash join variants on the target coupled architecture.</p><p>Separate vs. shared hash table. We first show the elapsed time of build phase of DD with separate and shared hash tables, as shown in Figure <ref type="figure" target="#fig_0">10</ref>. SHJ-DD and PHJ-DD with a shared hash table outperform those with separate hash tables by 16% and 26%, respectively. The major benefit of adopting the shared hash table is the elimination of the merging operation (as we have seen in Section 5.2). The other benefit is the improved cache performance due to potential cache reuse on the coupled architecture. The numbers of cache misses of SHJ-DD and PHJ-DD with separate hash tables are 2% and 4% larger than those with shared hash table, respectively. The improvement shows that, on the tested coupled architecture, the concurrency overhead  of the shared hash table is compensated by the two major benefits over the separate hash table.</p><p>Optimized memory allocator. We adopt an optimized memory allocator to reduce the number of atomic operations. Figure <ref type="figure" target="#fig_0">11</ref>(a) shows the overall time with the memory allocation block size varied in PHJ. We observed similar results on SHJ. Overall, at the beginning, the performance keeps improving when the block size becomes larger. However, the performance remains stable when the block size is larger than 2KB. The suitable block size is set to 2KB in our experiments. The major reason of the performance improvement is the reduction of global memory lock overhead from atomic operations.</p><p>To confirm our conclusion, we further study the lock overhead with the block size varied in Figure <ref type="figure" target="#fig_0">11</ref>(b) for PHJ. So far, there is no profiling tool to measure the lock overhead directly on the hardware. Therefore, we estimate the lock overhead as the difference of the measured time and estimated time based on our cost model. This is because our cost model does not consider the lock overhead. This back-of-the-envelop approach is simplistic but sufficient to show the trend of the lock overhead for our purpose. As the allocation memory block size increases, the lock overhead decreases significantly for all hash join variants.</p><p>Figure <ref type="figure" target="#fig_1">12</ref> compares the performance of hash joins with the basic memory allocator and our optimized memory allocator (denoted as Basic and Ours, respectively). Compared with the Basic allocator, the optimized allocator significantly improves the hash join performance, with up to 36% and 39% improvement on SHJ and PHJ.</p><p>Workload divergence. We study the impact of grouping approach on reducing the workload divergence. Our experimental results show that, the grouping approach can improve the overall performance by 5-10% (Figures are omitted due to space interests). The impact on the GPU is larger than that on the CPU, because the GPU hardware executes the wavefront strictly in a SIMD manner and also does not have advanced branch prediction mechanisms like the CPU.</p><p>Fine-grained step definition. We study the CPU and 0 0.5  the GPU running time for hash joins employing the finegrained and coarse-grained step definition. We apply PL to the coarse-grained step definition that we discussed in Section 3.3, and denote this co-processing to be PHJ-PL'. Table <ref type="table" target="#tab_7">3</ref> shows the execution time and the cache performance of PHJ-PL and PHJ-PL'. PHJ-PL' is much slower than PHJ-PL. As the coarse-grained step definition introduces separate hash tables, PHJ-PL' has a larger number of cache misses and a higher cache miss ratio than PHJ-PL. This shows the advantage of co-processing with fine-grained steps. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">End-to-End Performance Comparison</head><p>In this section, we compare end-to-end performance for different hash join variants on the coupled architecture. The OL essentially is a GPU-only implementation, and thus the results for GPU-only are omitted.</p><p>Data skew and data size. We first show performance numbers on the uniform, low-skew and high-skew data sets. We fix the probe relation to 16 million tuples and vary the build relation from 64K to 16M tuples. Figures <ref type="figure" target="#fig_2">13</ref> and<ref type="figure" target="#fig_7">14</ref> show the comparison results for uniform and high-skew data sets, respectively. The figures for the low-skew data sets are omitted due to the space limits, and we describe the results in texts. In general, they have similar performance trends on all three data sets. It shows that our co-processing techniques work well on either uniform or skew data sets. The elapsed time of running on high-skew data can be actually comparable to or even lower than that on uniform data. This is mainly because the benefit of data locality in highskew data compensates the overhead of latches. This point has also been pointed out in the previous study <ref type="bibr" target="#b3">[4]</ref>. We have also observed that when the relation size exceeds the cache size (4MB), there is a leap in the running time. Additionally, the performance improvement also scales well with the build relation size. In most cases, exploiting the capabilities of the both the GPU and the CPU (DD and Pipelined) can generate better performance than using only the CPU (CPU-only) or GPU-only (OL). Specifically, the optimized fine-grained pipelined join outperforms the CPU-only and GPU-only implementations by up to 53% and 35%, respectively. Thus, it is important to exploit both the CPU and the GPU on the coupled architecture. Additionally, PL outperforms DD by up to 28%. This confirms the effectiveness of our optimizations on fine-grained co-processing. Join selectivity. We study the impact of join selectivity. Figure <ref type="figure" target="#fig_8">15</ref> shows the results on time breakdown for the join selectivity values of 12.5%, 50% and 100%. For DD and OL, the selectivity only affects the probe phase. As a result, the time for the probe phase becomes slightly longer when the selectivity increases from 12.5 % to 100% for DD (from 0.47 to 0.58 seconds) or OL (from 0.59 to 0.71 seconds). For PL, both the build and probe phases are affected by the join selectivity. However, the performance impact is marginal, because our implementation simply outputs the matching rid pair. When the selectivity increases, there are more chances for workload divergence when probing the hash table . 
After studying all hash join variants, we find that PHJ-PL is usually the fastest, which is 2-6% faster than SHJ-PL. Nevertheless, both SHJ-PL and PHJ-PL are very competitive on the coupled architecture on different data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Summary and Lessons Learnt</head><p>We summarize the major findings and lessons learnt from this study and their implications for developing an efficient query processor on the coupled architecture.</p><p>Firstly, conventional co-processing of hash joins <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b22">23]</ref> can achieve only marginal performance improvement on the coupled architecture, since only the data transfer overhead is eliminated (accounting for 4-10% of the total execution time). This calls for the use of fine-grained co-processing on the coupled architecture, instead of coarse-grained coprocessing in the previous studies <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17]</ref>. Moreover, fine-grained co-processing schemes are inefficient on the discrete architecture. It indicates that "one size does not fit all", and we need to adopt different co-processing schemes between discrete and coupled architectures.</p><p>Secondly, fine-grained co-processing on hash joins has an interesting design space. It further increases the number of tuning knobs for hash joins. Automaticity of optimization is feasible which is enabled by our cost model. Going be-yond hash joins, we believe that the automaticity could be achieved through integrating the awareness of fine-grained co-processing into query optimizations.</p><p>Thirdly, memory optimizations and OpenCL-related optimizations have significant impact on the overall performance of hash join co-processing. Traditional issues like shared vs. separate hash tables remain important on the coupled architecture. More generally, architecture-aware query processing techniques (e.g., <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b28">29]</ref>) are still relevant to performance optimizations. But their impacts should be carefully studied on the target coupled architecture.</p><p>Fourthly, fine-grained co-processing is a must on the coupled architecture, which significantly outperforms the performance of processing on a single processor and the conventional co-processing. It not only keeps both processors busy, but also assigns the suitable workload to them for efficiency. The design space applies to general query processing, and an efficient query processor should expose sufficiently fine-grained data parallelism for scheduling among different processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>While GPU co-processing has shown significant performance speedups on main memory databases, the discrete CPU-GPU architecture design has hindered the further performance improvement of GPU co-processing. This paper revisits co-processing for hash joins on the coupled CPU-GPU architecture. With the integration of the CPU and the GPU into a single chip, the data transfer via PCI-e bus is eliminated on the coupled architecture. More importantly, the coupled architecture has opened up vast opportunities for improving the performance of co-processing of hash joins, as we have demonstrated in this experimental study. Specifically, we revisit the design space of fine-grained coprocessing on hash joins with and without partitioning. We show that the fine-grained co-processing can improve the performance by up to 53%, 35% and 28% over the CPUonly, GPU-only and conventional CPU-GPU co-processing, respectively. This paper represents a key first step in designing efficient query co-processing on coupled architectures. We are developing a full-fledged query processor on the coupled architecture <ref type="bibr" target="#b35">[36]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An overview of discrete and coupled CPU-GPU architectures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Fine-grained co-processing algorithm on a series of steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Time breakdown on discrete and coupled architectures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: Unit costs for different steps on the CPU and the GPU for PHJ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Optimal workload ratios of different steps for PHJ-PL on the coupled architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>Figure 7: Estimated and measured time for SHJ-DD with workload ratios varied</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 11 :Figure 12 :</head><label>1112</label><figDesc>Elapsed time (left) and lock overhead (Comparison between basic and optimized memory allocators (Basic and Ours, respectively)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Elapsed time comparison on the highskew data set</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: PHJ with join selectivity varied</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Configuration of AMD Fusion A8-3870K. The last column shows the configuration of AMD Radeon HD 7970 for reference.</head><label>1</label><figDesc>6,    </figDesc><table><row><cell></cell><cell>CPU</cell><cell>GPU</cell><cell>GPU (Dis-</cell></row><row><cell></cell><cell>(APU)</cell><cell>(APU)</cell><cell>crete)</cell></row><row><cell># Cores</cell><cell>4</cell><cell>400</cell><cell>2048</cell></row><row><cell>Core frequency(GHz)</cell><cell>3.0</cell><cell>0.6</cell><cell>0.9</cell></row><row><cell>Zero copy buffer (MB)</cell><cell cols="2">512 (shared)</cell><cell>-</cell></row><row><cell cols="2">Local memory size(KB) 32</cell><cell>32</cell><cell>32</cell></row><row><cell>Cache size(MB)</cell><cell cols="2">4 (shared)</cell><cell>-</cell></row><row><cell cols="4">20]. Secondly, we quantitatively show the advantage of co-</cell></row><row><cell cols="4">processing on the coupled architecture, in comparison with</cell></row><row><cell cols="2">that on the discrete architecture.</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 : Notations in the cost model</head><label>2</label><figDesc></figDesc><table><row><cell>Notation</cell><cell>Description</cell></row><row><cell>ri</cell><cell>Workload ratios for the CPU at Step i (1 ≤ i ≤</cell></row><row><cell></cell><cell>#Steps)</cell></row><row><cell>xi</cell><cell>The number of input items (e.g., tuples) at Step i</cell></row><row><cell></cell><cell>(1 ≤ i ≤ #Steps)</cell></row><row><cell>T</cell><cell>Total elapsed time of executing the entire step series</cell></row><row><cell>TXPU</cell><cell>The execution time on the processor XPU (XPU =</cell></row><row><cell></cell><cell>{CPU , GPU })</cell></row><row><cell>T i XPU</cell><cell>The execution time on the processor XPU at Step i</cell></row><row><cell>C i XPU</cell><cell>Computation time at Step i</cell></row><row><cell>M i XPU</cell><cell>Total global memory access time at Step i</cell></row><row><cell>D i XPU</cell><cell>The pipelined delay at Step i</cell></row><row><cell>#I i XPU</cell><cell>The average number of instructions on XPU per tuple</cell></row><row><cell></cell><cell>in Step i</cell></row><row><cell>IPC XPU</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>CDF of SHJ-PL (build) and PHJ-PL (probe) with one thousand Monte Carlo simulations</head><label></label><figDesc></figDesc><table><row><cell></cell><cell>100%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>100%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>CDF of instances</cell><cell>20% 40% 60% 80%</cell><cell cols="2">Ours</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>CDF of instances</cell><cell>20% 40% 60% 80%</cell><cell cols="2">Ours</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0%</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0.65</cell><cell>0.7</cell><cell>0.75</cell><cell>0.8</cell><cell>0.85</cell><cell>0.9</cell><cell>0.95</cell><cell>1</cell><cell>1.05</cell><cell>1.1</cell><cell>1.15</cell><cell>1.2</cell><cell>1.25</cell><cell>More</cell><cell>0.35</cell><cell>0.38</cell><cell>0.41</cell><cell>0.44</cell><cell>0.47</cell><cell>0.5</cell><cell>0.53</cell><cell>0.56</cell><cell>0.59</cell><cell>0.62</cell><cell>0.65</cell><cell>0.68</cell><cell>More</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="8">Build time in SHJ-PL (s)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="7">Probe time in PHJ-PL (s)</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="12">(a) build of SHJ-PL</cell><cell></cell><cell></cell><cell cols="11">(b) probe of PHJ-PL</cell><cell></cell></row><row><cell cols="6">0.2 0.4 0.6 0.8 1 1.2 1.4 Figure 9: 0 Elapsed time (s) 1.6 1.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">separate hash table shared hash table</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="6">Simple hash join</cell><cell cols="6">Partitioned hash join</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Figure 10: Elapsed time of the build phase in DD with separate and shared hash tables load</head><label></label><figDesc>ratios. For clarity of presentation, we consider a special case for PL: offloading the entire b1 and p1 to the GPU, and applying data-dividing with the same ratio r to all the other steps. The results in Figure8are measured by varying r.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 : Comparison between fine-grained and coarse-grained step definitions in PL</head><label>3</label><figDesc></figDesc><table><row><cell></cell><cell>L2 cache misses</cell><cell>L2 cache miss</cell><cell>Time (s)</cell></row><row><cell></cell><cell>(×10 6 )</cell><cell>ratio</cell><cell></cell></row><row><cell>PHJ-PL</cell><cell>7</cell><cell>10%</cell><cell>1.6</cell></row><row><cell>PHJ-PL'</cell><cell>15</cell><cell>23%</cell><cell>2.2</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">ACKNOWLEDGEMENT</head><p>The authors would like to thank anonymous reviewers, Qiong Luo and Ong Zhong Liang for their valuable comments. This work is partly supported by a MoE AcRF Tier 2 grant (MOE2012-T2-2-067) in Singapore and an Interdisciplinary Strategic Competitive Fund of Nanyang Technological University 2011 for "C3: Cloud-Assisted Green Computing at NTU Campus".</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dbmss on a modern processor: Where does time go?</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Main-memory hash joins on multi-core cpus: tunning to the underlying hardware</title>
		<author>
			<persName><forename type="first">C</forename><surname>Balkesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Teubner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Oszu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Design and evaluation of main memory hash join algorithms for multi-core cpus</title>
		<author>
			<persName><forename type="first">S</forename><surname>Blanas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Database architecture optimized for the new bottleneck: Memory access</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Manegold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Kersten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Accelerating mapreduce on a coupled cpu-gpu architecture</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Huo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Using segmented right-deep trees for the execution of pipelined hash joins</title>
		<author>
			<persName><forename type="first">M.-S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-L</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Improving hash join performance through prefetching</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Parallel database systems: the future of high performance database systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Multiprocessor hash-based join algorithms</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Gerber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="151" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A comprehensive performance comparison of cuda and opencl</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Varbanescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sips</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICPP</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Database compression on graphics processors</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="670" to="680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Pipelined hash-join on multithreaded architectures</title>
		<author>
			<persName><forename type="first">P</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
		<editor>DaMoN</editor>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Accelerating database operators using a network processor</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Huston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Falsafi</surname></persName>
		</author>
		<editor>DaMoN</editor>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Relational query coprocessing on graphics processors</title>
		<author>
			<persName><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Govindaraju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Sander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page">39</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Cache-oblivious databases: Limitations and opportunities</title>
		<author>
			<persName><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">42</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Relational joins on graphics processors</title>
		<author>
			<persName><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Govindaraju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Sander</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="511" to="524" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">High-throughput transaction executions on graphics processors</title>
		<author>
			<persName><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="314" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Revisiting co-processing for hash joins on the coupled cpu-gpu architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1307.1955</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Characterizing and evaluating a key-value store application on heterogeneous cpu-gpu systems</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Hetherington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISPASS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="88" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mapcg: writing parallel program portable between cpu and gpu</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PACT</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="217" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Gpu join processing revisited</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kaldewey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lohman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Volk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="55" to="62" />
			<pubPlace>DaMoN</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Sort vs. hash revisited: fast join implementation on modern multi-core cpus</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Numa-aware algorithms: the case of data shuffling</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pandis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Raman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lohman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On optimal processor allocation to support pipelined hash joins</title>
		<author>
			<persName><forename type="first">M.-L</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-S</forename><forename type="middle">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Ravishankar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="69" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Generic database cost models for hierarchical memory systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Manegold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Kersten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="191" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">What happens during a join? dissecting cpu and memory optimization effects</title>
		<author>
			<persName><forename type="first">S</forename><surname>Manegold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Kersten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Accelerating foreign-key joins using asymmetric memory channels</title>
		<author>
			<persName><forename type="first">H</forename><surname>Pirk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Manegold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kersten</surname></persName>
		</author>
		<editor>ADMS</editor>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficient hash probes on modern processors</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1297" to="1301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A performance evaluation of four parallel join algorithms in a shared-nothing multiprocessor environment</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="110" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Cache conscious algorithms for relational query processing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shatdal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">C-store: a column-oriented dbms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="553" to="564" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Fast implementation of dgemm on fermi gpu</title>
		<author>
			<persName><forename type="first">G</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Triechle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SC</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">How soccer players would do stream joins</title>
		<author>
			<persName><forename type="first">J</forename><surname>Teubner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mueller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="625" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Comparison of openmp and opencl parallel processing technologies</title>
		<author>
			<persName><forename type="first">K</forename><surname>Thouti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Sathe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IJACSA</title>
		<imprint>
			<biblScope unit="page" from="56" to="161" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Omnidb: Towards portable and efficient query processing on parallel cpu/gpu architectures</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PVLDB</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
