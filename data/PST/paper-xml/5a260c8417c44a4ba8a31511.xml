<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">mixup: BEYOND EMPIRICAL RISK MINIMIZATION</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hongyi</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Mit</forename><forename type="middle">Moustapha</forename><surname>Cisse</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yann</forename><forename type="middle">N</forename><surname>Dauphin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Lopez-Paz</surname></persName>
						</author>
						<title level="a" type="main">mixup: BEYOND EMPIRICAL RISK MINIMIZATION</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Large deep neural networks are powerful, but exhibit undesirable behaviors such as memorization and sensitivity to adversarial examples. In this work, we propose mixup, a simple learning principle to alleviate these issues. In essence, mixup trains a neural network on convex combinations of pairs of examples and their labels. By doing so, mixup regularizes the neural network to favor simple linear behavior in-between training examples. Our experiments on the ImageNet-2012, CIFAR-10, CIFAR-100, Google commands and UCI datasets show that mixup improves the generalization of state-of-the-art neural network architectures. We also find that mixup reduces the memorization of corrupt labels, increases the robustness to adversarial examples, and stabilizes the training of generative adversarial networks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Large deep neural networks have enabled breakthroughs in fields such as computer vision <ref type="bibr" target="#b22">(Krizhevsky et al., 2012)</ref>, speech recognition <ref type="bibr" target="#b19">(Hinton et al., 2012)</ref>, and reinforcement learning <ref type="bibr" target="#b28">(Silver et al., 2016)</ref>. In most successful applications, these neural networks share two commonalities. First, they are trained as to minimize their average error over the training data, a learning rule also known as the Empirical Risk Minimization (ERM) principle <ref type="bibr" target="#b35">(Vapnik, 1998)</ref>. Second, the size of these state-of-theart neural networks scales linearly with the number of training examples. For instance, the network of <ref type="bibr" target="#b31">Springenberg et al. (2015)</ref> used 10 6 parameters to model the 5 • 10 4 images in the CIFAR-10 dataset, the network of <ref type="bibr" target="#b30">(Simonyan &amp; Zisserman, 2015)</ref> used 10 8 parameters to model the 10 6 images in the ImageNet-2012 dataset, and the network of <ref type="bibr" target="#b5">Chelba et al. (2013)</ref> used 2 • 10 10 parameters to model the 10 9 words in the One Billion Word dataset.</p><p>Strikingly, a classical result in learning theory <ref type="bibr" target="#b36">(Vapnik &amp; Chervonenkis, 1971)</ref> tells us that the convergence of ERM is guaranteed as long as the size of the learning machine (e.g., the neural network) does not increase with the number of training data. Here, the size of a learning machine is measured in terms of its number of parameters or, relatedly, its VC-complexity <ref type="bibr" target="#b16">(Harvey et al., 2017)</ref>. This contradiction challenges the suitability of ERM to train our current neural network models, as highlighted in recent research. On the one hand, ERM allows large neural networks to memorize (instead of generalize from) the training data even in the presence of strong regularization, or in classification problems where the labels are assigned at random <ref type="bibr" target="#b42">(Zhang et al., 2017)</ref>. On the other hand, neural networks trained with ERM change their predictions drastically when evaluated on examples just outside the training distribution <ref type="bibr" target="#b33">(Szegedy et al., 2014)</ref>, also known as adversarial examples. This evidence suggests that ERM is unable to explain or provide generalization on testing distributions that differ only slightly from the training data. However, what is the alternative to ERM?</p><p>The method of choice to train on similar but different examples to the training data is known as data augmentation <ref type="bibr" target="#b29">(Simard et al., 1998)</ref>, formalized by the Vicinal Risk Minimization (VRM) principle <ref type="bibr" target="#b3">(Chapelle et al., 2000)</ref>. In VRM, human knowledge is required to describe a vicinity or neighborhood around each example in the training data. Then, additional virtual examples can be drawn from the vicinity distribution of the training examples to enlarge the support of the training distribution. For instance, when performing image classification, it is common to define the vicinity of one image as the set of its horizontal reflections, slight rotations, and mild scalings. While data augmentation consistently leads to improved generalization <ref type="bibr" target="#b29">(Simard et al., 1998)</ref>, the procedure is dataset-dependent, and thus requires the use of expert knowledge. Furthermore, data augmentation assumes that the examples in the vicinity share the same class, and does not model the vicinity relation across examples of different classes.</p><p>Contribution Motivated by these issues, we introduce a simple and data-agnostic data augmentation routine, termed mixup (Section 2). In a nutshell, mixup constructs virtual training examples</p><formula xml:id="formula_0">x = λx i + (1 − λ)x j ,</formula><p>where x i , x j are raw input vectors</p><formula xml:id="formula_1">ỹ = λy i + (1 − λ)y j ,</formula><p>where y i , y j are one-hot label encodings To understand the effects of various design choices in mixup, we conduct a thorough set of ablation study experiments (Section 3.8). The results suggest that mixup performs significantly better than related methods in previous work, and each of the design choices contributes to the final performance. We conclude by exploring the connections to prior work (Section 4), as well as offering some points for discussion (Section 5).</p><formula xml:id="formula_2">(x i , y i )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">FROM EMPIRICAL RISK MINIMIZATION TO mixup</head><p>In supervised learning, we are interested in finding a function f ∈ F that describes the relationship between a random feature vector X and a random target vector Y , which follow the joint distribution P (X, Y ). To this end, we first define a loss function that penalizes the differences between predictions f (x) and actual targets y, for examples (x, y) ∼ P . Then, we minimize the average of the loss function over the data distribution P , also known as the expected risk:</p><formula xml:id="formula_3">R(f ) = (f (x), y)dP (x, y).</formula><p>Unfortunately, the distribution P is unknown in most practical situations. Instead, we usually have access to a set of training data D = {(x i , y i )} n i=1 , where (x i , y i ) ∼ P for all i = 1, . . . , n. Using the training data D, we may approximate P by the empirical distribution</p><formula xml:id="formula_4">P δ (x, y) = 1 n n i=1 δ(x = x i , y = y i ),</formula><p>where δ(x = x i , y = y i ) is a Dirac mass centered at (x i , y i ). Using the empirical distribution P δ , we can now approximate the expected risk by the empirical risk:</p><formula xml:id="formula_5">R δ (f ) = (f (x), y)dP δ (x, y) = 1 n n i=1 (f (x i ), y i ).<label>(1)</label></formula><p>Learning the function f by minimizing (1) is known as the Empirical Risk Minimization (ERM) principle <ref type="bibr" target="#b35">(Vapnik, 1998)</ref>. While efficient to compute, the empirical risk (1) monitors the behaviour of f only at a finite set of n examples. When considering functions with a number parameters comparable to n (such as large neural networks), one trivial way to minimize (1) is to memorize the training data <ref type="bibr" target="#b42">(Zhang et al., 2017)</ref>. Memorization, in turn, leads to the undesirable behaviour of f outside the training data <ref type="bibr" target="#b33">(Szegedy et al., 2014)</ref>.  However, the naïve estimate P δ is one out of many possible choices to approximate the true distribution P . For instance, in the Vicinal Risk Minimization (VRM) principle <ref type="bibr" target="#b3">(Chapelle et al., 2000)</ref>, the distribution P is approximated by</p><formula xml:id="formula_6">P ν (x, ỹ) = 1 n n i=1 ν(x, ỹ|x i , y i ),</formula><p>where ν is a vicinity distribution that measures the probability of finding the virtual feature-target pair (x, ỹ) in the vicinity of the training feature-target pair (x i , y i ). In particular, <ref type="bibr" target="#b3">Chapelle et al. (2000)</ref> considered Gaussian vicinities ν(x, ỹ|x i , y i ) = N (x − x i , σ 2 )δ(ỹ = y i ), which is equivalent to augmenting the training data with additive Gaussian noise. To learn using VRM, we sample the vicinal distribution to construct a dataset D ν := {(x i , ỹi )} m i=1 , and minimize the empirical vicinal risk:</p><formula xml:id="formula_7">R ν (f ) = 1 m m i=1 (f (x i ), ỹi ).</formula><p>The contribution of this paper is to propose a generic vicinal distribution, called mixup:</p><formula xml:id="formula_8">µ(x, ỹ|x i , y i ) = 1 n n j E λ [δ(x = λ • x i + (1 − λ) • x j , ỹ = λ • y i + (1 − λ) • y j )] ,</formula><p>where λ ∼ Beta(α, α), for α ∈ (0, ∞). In a nutshell, sampling from the mixup vicinal distribution produces virtual feature-target vectors</p><formula xml:id="formula_9">x = λx i + (1 − λ)x j , ỹ = λy i + (1 − λ)y j ,</formula><p>where (x i , y i ) and (x j , y j ) are two feature-target vectors drawn at random from the training data, and λ ∈ [0, 1]. The mixup hyper-parameter α controls the strength of interpolation between feature-target pairs, recovering the ERM principle as α → 0.</p><p>The implementation of mixup training is straightforward, and introduces a minimal computation overhead. Figure <ref type="figure" target="#fig_1">1a</ref> shows the few lines of code necessary to implement mixup training in PyTorch. Finally, we mention alternative design choices. First, in preliminary experiments we find that convex combinations of three or more examples with weights sampled from a Dirichlet distribution does not provide further gain, but increases the computation cost of mixup. Second, our current implementation uses a single data loader to obtain one minibatch, and then mixup is applied to the same minibatch after random shuffling. We found this strategy works equally well, while reducing I/O requirements. Third, interpolating only between inputs with equal label did not lead to the performance gains of mixup discussed in the sequel. More empirical comparison can be found in Section 3.8.</p><p>What is mixup doing? The mixup vicinal distribution can be understood as a form of data augmentation that encourages the model f to behave linearly in-between training examples. We argue that this linear behaviour reduces the amount of undesirable oscillations when predicting outside the training examples. Also, linearity is a good inductive bias from the perspective of Occam's razor,   since it is one of the simplest possible behaviors. Figure <ref type="figure" target="#fig_1">1b</ref> shows that mixup leads to decision boundaries that transition linearly from class to class, providing a smoother estimate of uncertainty.</p><p>Figure <ref type="figure" target="#fig_3">2</ref> illustrate the average behaviors of two neural network models trained on the CIFAR-10 dataset using ERM and mixup. Both models have the same architecture, are trained with the same procedure, and are evaluated at the same points in-between randomly sampled training data. The model trained with mixup is more stable in terms of model predictions and gradient norms in-between training samples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXPERIMENTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">IMAGENET CLASSIFICATION</head><p>We evaluate mixup on the ImageNet-2012 classification dataset <ref type="bibr" target="#b27">(Russakovsky et al., 2015)</ref>. This dataset contains 1.3 million training images and 50,000 validation images, from a total of 1,000 classes.</p><p>For training, we follow standard data augmentation practices: scale and aspect ratio distortions, random crops, and horizontal flips <ref type="bibr" target="#b13">(Goyal et al., 2017)</ref>   For all the experiments in this section, we use data-parallel distributed training in Caffe2<ref type="foot" target="#foot_0">1</ref> with a minibatch size of 1,024. We use the learning rate schedule described in <ref type="bibr" target="#b13">(Goyal et al., 2017)</ref>. Specifically, the learning rate is increased linearly from 0.1 to 0.4 during the first 5 epochs, and it is then divided by 10 after 30, 60 and 80 epochs when training for 90 epochs; or after 60, 120 and 180 epochs when training for 200 epochs.</p><p>For mixup, we find that α ∈ [0.1, 0.4] leads to improved performance over ERM, whereas for large α, mixup leads to underfitting. We also find that models with higher capacities and/or longer training runs are the ones to benefit the most from mixup. For example, when trained for 90 epochs, the mixup variants of ResNet-101 and ResNeXt-101 obtain a greater improvement (0.5% to 0.6%) over their ERM analogues than the gain of smaller models such as ResNet-50 (0.2%). When trained for 200 epochs, the top-1 error of the mixup variant of ResNet-50 is further reduced by 1.2% compared to the 90 epoch run, whereas its ERM analogue stays the same.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">CIFAR-10 AND CIFAR-100</head><p>We conduct additional image classification experiments on the CIFAR-10 and CIFAR-100 datasets to further evaluate the generalization performance of mixup. In particular, we compare ERM and mixup training for: PreAct ResNet-18 <ref type="bibr" target="#b17">(He et al., 2016)</ref> as implemented in <ref type="bibr" target="#b25">(Liu, 2017)</ref>, WideResNet-28-10 (Zagoruyko &amp; Komodakis, 2016a) as implemented in <ref type="bibr" target="#b41">(Zagoruyko &amp; Komodakis, 2016b)</ref>, and DenseNet <ref type="bibr" target="#b20">(Huang et al., 2017)</ref> as implemented in <ref type="bibr" target="#b37">(Veit, 2017)</ref>. For DenseNet, we change the growth rate to 40 to follow the DenseNet-BC-190 specification from <ref type="bibr" target="#b20">(Huang et al., 2017)</ref>. For mixup, we fix α = 1, which results in interpolations λ uniformly distributed between zero and one. All models are trained on a single Nvidia Tesla P100 GPU using PyTorch<ref type="foot" target="#foot_1">2</ref> for 200 epochs on the training set with 128 examples per minibatch, and evaluated on the test set. Learning rates start at 0.1 and are divided by 10 after 100 and 150 epochs for all models except WideResNet. For WideResNet, we follow <ref type="bibr" target="#b40">(Zagoruyko &amp; Komodakis, 2016a)</ref> and divide the learning rate by 10 after 60, 120 and 180 epochs. Weight decay is set to 10 −4 . We do not use dropout in these experiments.</p><p>We summarize our results in Figure <ref type="figure" target="#fig_5">3a</ref>. In both CIFAR-10 and CIFAR-100 classification problems, the models trained using mixup significantly outperform their analogues trained with ERM. As seen in Figure <ref type="figure" target="#fig_5">3b</ref>, mixup and ERM converge at a similar speed to their best test errors. Note that the DenseNet models in <ref type="bibr" target="#b20">(Huang et al., 2017)</ref> were trained for 300 epochs with further learning rate decays scheduled at the 150 and 225 epochs, which may explain the discrepancy the performance of DenseNet reported in Figure <ref type="figure" target="#fig_5">3a</ref> and the original result of <ref type="bibr" target="#b20">Huang et al. (2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">SPEECH DATA</head><p>Next, we perform speech recognition experiments using the Google commands dataset <ref type="bibr" target="#b38">(Warden, 2017)</ref>. The dataset contains 65,000 utterances, where each utterance is about one-second long and belongs to one out of 30 classes. The classes correspond to voice commands such as yes, no, down, left, as pronounced by a few thousand different speakers.  extract normalized spectrograms from the original waveforms at a sampling rate of 16 kHz. Next, we zero-pad the spectrograms to equalize their sizes at 160 × 101. For speech data, it is reasonable to apply mixup both at the waveform and spectrogram levels. Here, we apply mixup at the spectrogram level just before feeding the data to the network.</p><p>For this experiment, we compare a LeNet <ref type="bibr" target="#b23">(Lecun et al., 2001</ref>) and a VGG-11 <ref type="bibr" target="#b30">(Simonyan &amp; Zisserman, 2015)</ref> architecture, each of them composed by two convolutional and two fully-connected layers.</p><p>We train each model for 30 epochs with minibatches of 100 examples, using Adam as the optimizer <ref type="bibr" target="#b21">(Kingma &amp; Ba, 2015)</ref>. Training starts with a learning rate equal to 3 × 10 −3 and is divided by 10 every 10 epochs. For mixup, we use a warm-up period of five epochs where we train the network on original training examples, since we find it speeds up initial convergence. Table <ref type="table" target="#tab_6">4</ref> shows that mixup outperforms ERM on this task, specially when using VGG-11, the model with larger capacity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">MEMORIZATION OF CORRUPTED LABELS</head><p>Following <ref type="bibr" target="#b42">Zhang et al. (2017)</ref>, we evaluate the robustness of ERM and mixup models against randomly corrupted labels. We hypothesize that increasing the strength of mixup interpolation α should generate virtual examples further from the training examples, making memorization more difficult to achieve.</p><p>In particular, it should be easier to learn interpolations between real examples compared to memorizing interpolations involving random labels. We adapt an open-source implementation <ref type="bibr" target="#b43">(Zhang, 2017)</ref> to generate three CIFAR-10 training sets, where 20%, 50%, or 80% of the labels are replaced by random noise, respectively. All the test labels are kept intact for evaluation. Dropout <ref type="bibr" target="#b32">(Srivastava et al., 2014)</ref> is considered the state-of-the-art method for learning with corrupted labels <ref type="bibr" target="#b1">(Arpit et al., 2017)</ref>. Thus, we compare in these experiments mixup, dropout, mixup + dropout, and ERM. For mixup, we choose α ∈ {1, 2, 8, 32}; for dropout, we add one dropout layer in each PreAct block after the ReLU activation layer between two convolution layers, as suggested in <ref type="bibr" target="#b40">(Zagoruyko &amp; Komodakis, 2016a)</ref>. We choose the dropout probability p ∈ {0.5, 0.7, 0.8, 0.9}. For the combination of mixup and dropout, we choose α ∈ {1, 2, 4, 8} and p ∈ {0.3, 0.5, 0.7}. These experiments use the PreAct ResNet-18 <ref type="bibr" target="#b17">(He et al., 2016)</ref> model implemented in <ref type="bibr" target="#b25">(Liu, 2017)</ref>. All the other settings are the same as in Section 3.2.</p><p>We summarize our results in Table <ref type="table" target="#tab_4">2</ref>, where we note the best test error achieved during the training session, as well as the final test error after 200 epochs. To quantify the amount of memorization, we also evaluate the training errors at the last epoch on real labels and corrupted labels. As the training progresses with a smaller learning rate (e.g. less than 0.01), the ERM model starts to overfit the corrupted labels. When using a large probability (e.g. 0.7 or 0.8), dropout can effectively reduce overfitting. mixup with a large α (e.g. 8 or 32) outperforms dropout on both the best and last epoch test errors, and achieves lower training error on real labels while remaining resistant to noisy labels. Interestingly, mixup + dropout performs the best of all, showing that the two methods are compatible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">ROBUSTNESS TO ADVERSARIAL EXAMPLES</head><p>One undesirable consequence of models trained using ERM is their fragility to adversarial examples <ref type="bibr" target="#b33">(Szegedy et al., 2014)</ref>  Among the several methods aiming to solve this problem, some have proposed to penalize the norm of the Jacobian of the model to control its Lipschitz constant <ref type="bibr" target="#b9">(Drucker &amp; Le Cun, 1992;</ref><ref type="bibr" target="#b6">Cisse et al., 2017;</ref><ref type="bibr" target="#b2">Bartlett et al., 2017;</ref><ref type="bibr" target="#b18">Hein &amp; Andriushchenko, 2017)</ref>. Other approaches perform data augmentation by producing and training on adversarial examples <ref type="bibr" target="#b12">(Goodfellow et al., 2015)</ref>. Unfortunately, all of these methods add significant computational overhead to ERM. Here, we show that mixup can significantly improve the robustness of neural networks without hindering the speed of ERM by penalizing the norm of the gradient of the loss w.r.t a given input along the most plausible directions (e.g. the directions to other training points). Indeed, Figure <ref type="figure" target="#fig_3">2</ref> shows that mixup results in models having a smaller loss and gradient norm between examples compared to vanilla ERM.</p><p>To assess the robustness of mixup models to adversarial examples, we use three ResNet-101 models: two of them trained using ERM on ImageNet-2012, and the third trained using mixup. In the first set of experiments, we study the robustness of one ERM model and the mixup model against white box attacks. That is, for each of the two models, we use the model itself to generate adversarial examples, either using the Fast Gradient Sign Method (FGSM) or the Iterative FGSM (I-FGSM) methods <ref type="bibr" target="#b12">(Goodfellow et al., 2015)</ref>, allowing a maximum perturbation of = 4 for every pixel. For I-FGSM, we use 10 iterations with equal step size.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">TABULAR DATA</head><p>To further explore the performance of mixup on non-image data, we performed a series of experiments on six arbitrary classification problems drawn from the UCI dataset <ref type="bibr" target="#b24">(Lichman, 2013)</ref>. The neural networks in this section are fully-connected, and have two hidden layers of 128 ReLU units. The parameters of these neural networks are learned using Adam <ref type="bibr" target="#b21">(Kingma &amp; Ba, 2015)</ref> with default hyper-parameters, over 10 epochs of mini-batches of size 16. Table <ref type="table" target="#tab_6">4</ref> shows that mixup improves the average test error on four out of the six considered datasets, and never underperforms ERM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">STABILIZATION OF GENERATIVE ADVERSARIAL NETWORKS (GANS)</head><p>Generative Adversarial Networks, also known as GANs <ref type="bibr" target="#b11">(Goodfellow et al., 2014)</ref>, are a powerful family of implicit generative models. In GANs, a generator and a discriminator compete against each other to model a distribution P . On the one hand, the generator g competes to transform noise vectors z ∼ Q into fake samples g(z) that resemble real samples x ∼ P . On the other hand, the discriminator competes to distinguish between real samples x and fake samples g(z). Mathematically, training a GAN is equivalent to solving the optimization problem</p><formula xml:id="formula_10">max g min d E x,z (d(x), 1) + (d(g(z)), 0),</formula><p>where is the binary cross entropy loss. Unfortunately, solving the previous min-max equation is a notoriously difficult optimization problem <ref type="bibr" target="#b10">(Goodfellow, 2016)</ref>, since the discriminator often provides the generator with vanishing gradients. We argue that mixup should stabilize GAN training because it acts as a regularizer on the gradients of the discriminator, akin to the binary classifier in Figure <ref type="figure" target="#fig_1">1b</ref>.</p><p>Then, the smoothness of the discriminator guarantees a stable source of gradient information to the generator. The mixup formulation of GANs is:</p><formula xml:id="formula_11">max g min d E x,z,λ (d(λx + (1 − λ)g(z)), λ).</formula><p>Figure <ref type="figure" target="#fig_7">5</ref> illustrates the stabilizing effect of mixup the training of GAN (orange samples) when modeling two toy datasets (blue samples). The neural networks in these experiments are fullyconnected and have three hidden layers of 512 ReLU units. The generator network accepts twodimensional Gaussian noise vectors. The networks are trained for 20,000 mini-batches of size 128 using the Adam optimizer with default parameters, where the discriminator is trained for five iterations before every generator iteration. The training of mixup GANs seems promisingly robust to hyper-parameter and architectural choices.  <ref type="bibr">(k=200)</ref>. Please refer to the text for details about the experiments and interpretations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">ABLATION STUDIES</head><p>mixup is a data augmentation method that consists of only two parts: random convex combination of raw inputs, and correspondingly, convex combination of one-hot label encodings. However, there are several design choices to make. For example, on how to augment the inputs, we could have chosen to interpolate the latent representations (i.e. feature maps) of a neural network, and we could have chosen to interpolate only between the nearest neighbors, or only between inputs of the same class.</p><p>When the inputs to interpolate come from two different classes, we could have chosen to assign a single label to the synthetic input, for example using the label of the input that weights more in the convex combination. To compare mixup with these alternative possibilities, we run a set of ablation study experiments using the PreAct ResNet-18 architecture on the CIFAR-10 dataset.</p><p>Specifically, for each of the data augmentation methods, we test two weight decay settings (10 −4 which works well for mixup, and 5 × 10 −4 which works well for ERM). All the other settings and hyperparameters are the same as reported in Section 3.2.</p><p>To compare interpolating raw inputs with interpolating latent representations, we test on random convex combination of the learned representations before each residual block (denoted Layer 1-4) or before the uppermost "average pooling + fully connected" layer (denoted Layer 5). To compare mixing random pairs of inputs (RP) with mixing nearest neighbors (KNN), we first compute the 200 nearest neighbors for each training sample, either from the same class (SC) or from all the classes (AC). Then during training, for each sample in a minibatch, we replace the sample with a synthetic sample by convex combination with a random draw from its nearest neighbors. To compare mixing all the classes (AC) with mixing within the same class (SC), we convex combine a minibatch with a random permutation of its sample index, where the permutation is done in a per-batch basis (AC) or a per-class basis (SC). To compare mixing inputs and labels with mixing inputs only, we either use a convex combination of the two one-hot encodings as the target, or select the one-hot encoding of the closer training sample as the target. For label smoothing, we follow <ref type="bibr" target="#b34">Szegedy et al. (2016)</ref> and use 10 as the target for incorrect classes, and 1 − 9 10 as the target for the correct class.Adding Gaussian noise to inputs is used as another baseline. We report the median test errors of the last 10 epochs. Results are shown in Table <ref type="table" target="#tab_7">5</ref>.</p><p>From the ablation study experiments, we have the following observations. First, mixup is the best data augmentation method we test, and is significantly better than the second best method (mix input + label smoothing). Second, the effect of regularization can be seen by comparing the test error with a small weight decay (10 −4 ) with a large one (5 × 10 −4 ). For example, for ERM a large weight decay works better, whereas for mixup a small weight decay is preferred, confirming its regularization effects. We also see an increasing advantage of large weight decay when interpolating in higher layers of latent representations, indicating decreasing strength of regularization. Among all the input interpolation methods, mixing random pairs from all classes (AC + RP) has the strongest regularization effect. Label smoothing and adding Gaussian noise have a relatively small regularization effect. Finally, we note that the SMOTE algorithm <ref type="bibr" target="#b4">(Chawla et al., 2002)</ref> does not lead to a noticeable gain in performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RELATED WORK</head><p>Data augmentation lies at the heart of all successful applications of deep learning, ranging from image classification <ref type="bibr" target="#b22">(Krizhevsky et al., 2012)</ref> to speech recognition <ref type="bibr" target="#b14">(Graves et al., 2013;</ref><ref type="bibr" target="#b0">Amodei et al., 2016)</ref>. In all cases, substantial domain knowledge is leveraged to design suitable data transformations leading to improved generalization. In image classification, for example, one routinely uses rotation, translation, cropping, resizing, flipping <ref type="bibr" target="#b23">(Lecun et al., 2001;</ref><ref type="bibr" target="#b30">Simonyan &amp; Zisserman, 2015)</ref>, and random erasing <ref type="bibr" target="#b44">(Zhong et al., 2017)</ref> to enforce visually plausible invariances in the model through the training data. Similarly, in speech recognition, noise injection is a prevalent practice to improve the robustness and accuracy of the trained models <ref type="bibr" target="#b0">(Amodei et al., 2016)</ref>.</p><p>More related to mixup, <ref type="bibr" target="#b4">Chawla et al. (2002)</ref> propose to augment the rare class in an imbalanced dataset by interpolating the nearest neighbors; <ref type="bibr" target="#b8">DeVries &amp; Taylor (2017)</ref> show that interpolation and extrapolation the nearest neighbors of the same class in feature space can improve generalization. However, their proposals only operate among the nearest neighbors within a certain class at the input / feature level, and hence does not account for changes in the corresponding labels. Recent approaches have also proposed to regularize the output distribution of a neural network by label smoothing <ref type="bibr" target="#b34">(Szegedy et al., 2016)</ref>, or penalizing high-confidence softmax distributions <ref type="bibr" target="#b26">(Pereyra et al., 2017)</ref>. These methods bear similarities with mixup in the sense that supervision depends on multiple smooth labels, rather than on single hard labels as in traditional ERM. However, the label smoothing in these works is applied or regularized independently from the associated feature values.</p><p>mixup enjoys several desirable aspects of previous data augmentation and regularization schemes without suffering from their drawbacks. Like the method of DeVries &amp; Taylor (2017), it does not require significant domain knowledge. Like label smoothing, the supervision of every example is not overly dominated by the ground-truth label. Unlike both of these approaches, the mixup transformation establishes a linear relationship between data augmentation and the supervision signal. We believe that this leads to a strong regularizer that improves generalization as demonstrated by our experiments. The linearity constraint, through its effect on the derivatives of the function approximated, also relates mixup to other methods such as Sobolev training of neural networks <ref type="bibr" target="#b7">(Czarnecki et al., 2017)</ref> or WGAN-GP <ref type="bibr" target="#b15">(Gulrajani et al., 2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>We have proposed mixup, a data-agnostic and straightforward data augmentation principle. We have shown that mixup is a form of vicinal risk minimization, which trains on virtual examples constructed as the linear interpolation of two random examples from the training set and their labels. Incorporating mixup into existing training pipelines reduces to a few lines of code, and introduces little or no computational overhead. Throughout an extensive evaluation, we have shown that mixup improves the generalization error of state-of-the-art models on ImageNet, CIFAR, speech, and tabular datasets. Furthermore, mixup helps to combat memorization of corrupt labels, sensitivity to adversarial examples, and instability in adversarial training.</p><p>In our experiments, the following trend is consistent: with increasingly large α, the training error on real data increases, while the generalization gap decreases. This sustains our hypothesis that mixup implicitly controls model complexity. However, we do not yet have a good theory for understanding the 'sweet spot' of this bias-variance trade-off. For example, in CIFAR-10 classification we can get very low training error on real data even when α → ∞ (i.e., training only on averages of pairs of real examples), whereas in ImageNet classification, the training error on real data increases significantly with α → ∞. Based on our ImageNet and Google commands experiments with different model architectures, we conjecture that increasing the model capacity would make training error less sensitive to large α, hence giving mixup a more significant advantage.</p><p>mixup also opens up several possibilities for further exploration. First, is it possible to make similar ideas work on other types of supervised learning problems, such as regression and structured prediction? While generalizing mixup to regression problems is straightforward, its application to structured prediction problems such as image segmentation remains less obvious. Second, can similar methods prove helpful beyond supervised learning? The interpolation principle seems like a reasonable inductive bias which might also help in unsupervised, semi-supervised, and reinforcement learning. Can we extend mixup to feature-label extrapolation to guarantee a robust model behavior far away from the training data? Although our discussion of these directions is still speculative, we are excited about the possibilities mixup opens up, and hope that our observations will prove useful for future development.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>#</head><label></label><figDesc>y1, y2 should be one-hot vectors for (x1, y1), (x2, y2) in zip(loader1, loader2): lam = numpy.random.beta(alpha, alpha) x = Variable(lam * x1 + (1. -lam) * x2) y = Variable(lam * y1 + (1. -lam) * y2) optimizer.zero_grad() loss(net(x), y).backward() optimizer.step() (a) One epoch of mixup training in PyTorch. ERM mixup (b) Effect of mixup (α = 1) on a toy problem. Green: Class 0. Orange: Class 1. Blue shading indicates p(y = 1|x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Illustration of mixup, which converges to ERM as α → 0.</figDesc><graphic url="image-1.png" coords="3,368.99,104.30,61.55,61.55" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Prediction errors in-between training data. Evaluated at x = λxi +(1−λ)xj, a prediction is counted as a "miss" if it does not belong to {yi, yj}. The model trained with mixup has fewer misses. Norm of the gradients of the model w.r.t. input in-between training data, evaluated at x = λxi + (1 − λ)xj. The model trained with mixup has smaller gradient norms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: mixup leads to more robust model behaviors in-between the training data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Test error evolution for the best ERM and mixup models.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Test errors for ERM and mixup on the CIFAR experiments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Classification errors of ERM and mixup on the Google commands dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Effect of mixup on stabilizing GAN training at iterations 10, 100, 1000, 10000, and 20000.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>and (x j , y j ) are two examples drawn at random from our training data, and λ ∈ [0, 1]. Therefore, mixup extends the training distribution by incorporating the prior knowledge that linear interpolations of feature vectors should lead to linear interpolations of the associated targets. mixup can be implemented in a few lines of code, and introduces minimal computation overhead.Despite its simplicity, mixup allows a new state-of-the-art performance in the CIFAR-10, CIFAR-100, and ImageNet-2012 image classification datasets (Sections 3.1 and 3.2). Furthermore, mixup increases the robustness of neural networks when learning from corrupt labels (Section 3.4), or facing adversarial examples (Section 3.5). Finally, mixup improves generalization on speech(Sections 3.3)   </figDesc><table /><note>and tabular (Section 3.6) data, and can be used to stabilize the training of GANs (Section 3.7). The source-code necessary to replicate our CIFAR-10 experiments is available at: https://github.com/facebookresearch/mixup-cifar10.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Validation errors for ERM and mixup on the development set of ImageNet-2012.</figDesc><table><row><cell>Model</cell><cell>Method</cell><cell cols="3">Epochs Top-1 Error Top-5 Error</cell></row><row><cell>ResNet-50</cell><cell>ERM (Goyal et al., 2017) mixup α = 0.2</cell><cell>90 90</cell><cell>23.5 23.3</cell><cell>-6.6</cell></row><row><cell>ResNet-101</cell><cell>ERM (Goyal et al., 2017) mixup α = 0.2</cell><cell>90 90</cell><cell>22.1 21.5</cell><cell>-5.6</cell></row><row><cell cols="2">ResNeXt-101 32*4d ERM (Xie et al., 2016) ERM mixup α = 0.4</cell><cell>100 90 90</cell><cell>21.2 21.2 20.7</cell><cell>-5.6 5.3</cell></row><row><cell cols="2">ResNeXt-101 64*4d ERM (Xie et al., 2016) mixup α = 0.4</cell><cell>100 90</cell><cell>20.4 19.8</cell><cell>5.3 4.9</cell></row><row><cell>ResNet-50</cell><cell>ERM mixup α = 0.2</cell><cell>200 200</cell><cell>23.6 22.1</cell><cell>7.0 6.1</cell></row><row><cell>ResNet-101</cell><cell>ERM mixup α = 0.2</cell><cell>200 200</cell><cell>22.0 20.8</cell><cell>6.1 5.4</cell></row><row><cell cols="2">ResNeXt-101 32*4d ERM mixup α = 0.4</cell><cell>200 200</cell><cell>21.3 20.1</cell><cell>5.9 5.0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>To preprocess the utterances, we first</figDesc><table><row><cell cols="2">Published as a conference paper at ICLR 2018</cell><cell></cell><cell></cell></row><row><cell>Model</cell><cell>Method</cell><cell cols="2">Validation set Test set</cell></row><row><cell>LeNet</cell><cell>ERM mixup (α = 0.1) mixup (α = 0.2)</cell><cell>9.8 10.1 10.2</cell><cell>10.3 10.8 11.3</cell></row><row><cell>VGG-11</cell><cell>ERM mixup (α = 0.1) mixup (α = 0.2)</cell><cell>5.0 4.0 3.9</cell><cell>4.6 3.8 3.4</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 :</head><label>2</label><figDesc>Results on the corrupted label experiments for the best models.</figDesc><table><row><cell cols="3">Label corruption Method</cell><cell></cell><cell></cell><cell cols="2">Test error Best Last</cell><cell cols="2">Training error Real Corrupted</cell></row><row><cell>20%</cell><cell></cell><cell cols="3">ERM ERM + dropout (p = 0.7) mixup (α = 8) mixup + dropout (α = 4, p = 0.1)</cell><cell cols="2">12.7 16.6 8.8 10.4 5.9 6.4 6.2 6.2</cell><cell>0.05 5.26 2.27 1.92</cell><cell>0.28 83.55 86.32 85.02</cell></row><row><cell>50%</cell><cell></cell><cell cols="6">ERM ERM + dropout (p = 0.8) mixup (α = 32) mixup + dropout (α = 8, p = 0.3) 10.9 10.9 18.8 44.6 14.1 15.5 12.71 0.26 11.3 12.7 5.84 7.56</cell><cell>0.64 86.98 85.71 87.90</cell></row><row><cell>80%</cell><cell></cell><cell cols="6">ERM ERM + dropout (p = 0.8) mixup (α = 32) mixup + dropout (α = 8, p = 0.3) 24.0 24.8 19.70 36.5 73.9 0.62 30.9 35.1 29.84 25.3 30.9 18.92</cell><cell>0.83 86.37 85.44 87.67</cell></row><row><cell cols="4">Metric Method FGSM I-FGSM</cell><cell cols="5">Metric Method FGSM I-FGSM</cell></row><row><cell>Top-1</cell><cell>ERM mixup</cell><cell>90.7 75.2</cell><cell>99.9 99.6</cell><cell cols="2">Top-1</cell><cell>ERM mixup</cell><cell>57.0 46.0</cell><cell>57.3 40.9</cell></row><row><cell>Top-5</cell><cell>ERM mixup</cell><cell>63.1 49.1</cell><cell>93.4 95.8</cell><cell cols="2">Top-5</cell><cell>ERM mixup</cell><cell>24.8 17.4</cell><cell>18.1 11.8</cell></row><row><cell></cell><cell cols="2">(a) White box attacks.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note>. Adversarial examples are obtained by adding tiny (visually imperceptible) perturbations to legitimate examples in order to deteriorate the performance of the model. The adversarial noise is generated by ascending the gradient of the loss surface with respect to the legitimate example. Improving the robustness to adversarial examples is a topic of active research. (b) Black box attacks.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 :</head><label>3</label><figDesc>Classification errors of ERM and mixup models when tested on adversarial examples.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>In the second set of experiments, we evaluate robustness against black box attacks. That is, we use the first ERM model to produce adversarial examples using FGSM and I-FGSM. Then, we test the robustness of the second ERM model and the mixup model to these examples. The results of both settings are summarized in Table3. ERM and mixup classification errors on the UCI datasets.</figDesc><table><row><cell cols="3">Published as a conference paper at ICLR 2018</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Dataset</cell><cell cols="2">ERM mixup</cell><cell>Dataset</cell><cell cols="2">ERM mixup</cell></row><row><cell>Abalone Arcene Arrhythmia</cell><cell>74.0 57.6 56.6</cell><cell>73.6 48.0 46.3</cell><cell>Htru2 Iris Phishing</cell><cell>2.0 21.3 16.3</cell><cell>2.0 17.3 15.2</cell></row></table><note>For the FGSM white box attack, the mixup model is 2.7 times more robust than the ERM model in terms of Top-1 error. For the FGSM black box attack, the mixup model is 1.25 times more robust than the ERM model in terms of Top-1 error. Also, while both mixup and ERM are not robust to white box I-FGSM attacks, mixup is about 40% more robust than ERM in the black box I-FGSM setting. Overall, mixup produces neural networks that are significantly more robust than ERM against adversarial examples in white box and black settings without additional overhead compared to ERM.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 5 :</head><label>5</label><figDesc>Results of the ablation studies on the CIFAR-10 dataset. Reported are the median test errors of the last 10 epochs. A tick () means the component is different from standard ERM training, whereas a cross () means it follows the standard training practice. AC: mix between all classes. SC: mix within the same class. RP: mix between random pairs. KNN: mix between k-nearest neighbors</figDesc><table><row><cell>Method ERM</cell><cell>Specification</cell><cell cols="2">Modified Input Target 10 −4 5 × 10 −4 Weight decay 5.53 5.18</cell></row><row><cell>mixup</cell><cell>AC + RP AC + KNN</cell><cell>4.24 4.98</cell><cell>4.68 5.26</cell></row><row><cell>mix labels and latent representations (AC + RP)</cell><cell>Layer 1 Layer 2 Layer 3 Layer 4 Layer 5</cell><cell>4.44 4.56 5.39 5.95 5.39</cell><cell>4.51 4.61 5.55 5.43 5.15</cell></row><row><cell>mix inputs only</cell><cell>SC + KNN (Chawla et al., 2002) AC + KNN SC + RP AC + RP</cell><cell>5.45 5.43 5.23 5.17</cell><cell>5.52 5.48 5.55 5.72</cell></row><row><cell>label smoothing (Szegedy et al., 2016)</cell><cell>= 0.05 = 0.1</cell><cell>5.25 5.33</cell><cell>5.02 5.17</cell></row><row><cell></cell><cell>= 0.2</cell><cell>5.34</cell><cell>5.06</cell></row><row><cell>mix inputs + label smoothing (AC + RP)</cell><cell>= 0.05 = 0.1 = 0.2</cell><cell>5.02 5.08 4.98</cell><cell>5.40 5.09 5.06</cell></row><row><cell></cell><cell>= 0.4</cell><cell>5.25</cell><cell>5.39</cell></row><row><cell>add Gaussian noise to inputs</cell><cell>σ = 0.05 σ = 0.1</cell><cell>5.53 6.41</cell><cell>5.04 5.86</cell></row><row><cell></cell><cell>σ = 0.2</cell><cell>7.16</cell><cell>7.24</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">https://caffe2.ai</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">http://pytorch.org</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank Priya Goyal, Yossi Adi and the PyTorch team. We also thank the Anonymous Review 2 for proposing the mixup + dropout experiments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Deep speech 2: End-to-end speech recognition in English and Mandarin</title>
		<author>
			<persName><forename type="first">D</forename><surname>Amodei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ananthanarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Anubhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Battenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Case</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Casper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Catanzaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">A closer look at memorization in deep networks</title>
		<author>
			<persName><forename type="first">D</forename><surname>Arpit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jastrzebski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ballas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Krueger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Kanwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Maharaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Bartlett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Telgarsky</surname></persName>
		</author>
		<title level="m">Spectrally-normalized margin bounds for neural networks. NIPS</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Chapelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vapnik</surname></persName>
		</author>
		<title level="m">Vicinal risk minimization. NIPS</title>
				<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">SMOTE: synthetic minority over-sampling technique</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">V</forename><surname>Chawla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Bowyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">O</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>Kegelmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of artificial intelligence research</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="321" to="357" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">One billion word benchmark for measuring progress in statistical language modeling</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chelba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Brants</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Koehn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Robinson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Cisse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bojanowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Grave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dauphin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Usunier</surname></persName>
		</author>
		<title level="m">Parseval networks: Improving robustness to adversarial examples. ICML</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Osindero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jaderberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Świrszcz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pascanu</surname></persName>
		</author>
		<title level="m">Sobolev training for neural networks. NIPS</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dataset augmentation in feature space</title>
		<author>
			<persName><forename type="first">T</forename><surname>Devries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">W</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICLR Workshops</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Improving generalization performance using double backpropagation</title>
		<author>
			<persName><forename type="first">H</forename><surname>Drucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Le Cun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Neural Networks</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="991" to="997" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Tutorial: Generative adversarial networks</title>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIPS</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pouget-Abadie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mirza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Warde-Farley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ozair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<title level="m">Generative adversarial nets. NIPS</title>
				<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Explaining and harnessing adversarial examples</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>ICLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dollár</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Noordhuis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wesolowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tulloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<title level="m">Accurate, large minibatch SGD: Training ImageNet in 1 hour</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Speech recognition with deep recurrent neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>-R. Mohamed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>In ICASSP. IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Improved training of Wasserstein GANs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Gulrajani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arjovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Dumoulin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Nearly-tight VC-dimension bounds for piecewise linear neural networks</title>
		<author>
			<persName><forename type="first">N</forename><surname>Harvey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mehrabian</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>JMLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<title level="m">Identity mappings in deep residual networks. ECCV</title>
				<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Formal guarantees on the robustness of a classifier against adversarial manipulation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Andriushchenko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Dahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>-R. Mohamed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jaitly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Senior</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Sainath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Processing Magazine</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Van Der Maaten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Adam: A method for stochastic optimization</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICLR</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">ImageNet classification with deep convolutional neural networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIPS</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Gradient-based learning applied to document recognition</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bottou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE</title>
				<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">UCI machine learning repository</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lichman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">K</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="https://github.com/kuangliu/pytorch-cifar" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Regularizing neural networks by penalizing confident output distributions</title>
		<author>
			<persName><forename type="first">G</forename><surname>Pereyra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chorowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ł</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>ICLR Workshops</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">O</forename><surname>Russakovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Satheesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Karpathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Khosla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fei-Fei</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>ImageNet large scale visual recognition challenge. IJCV</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Mastering the game of Go with deep neural networks and tree search</title>
		<author>
			<persName><forename type="first">D</forename><surname>Silver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Maddison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Guez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sifre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Van Den Driessche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Schrittwieser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Antonoglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Panneershelvam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lanctot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Transformation invariance in pattern recognitiontangent distance and tangent propagation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Simard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Denker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Victorri</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>Neural networks: tricks of the trade</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Very deep convolutional networks for large-scale image recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zisserman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>ICLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Striving for simplicity: The all convolutional net</title>
		<author>
			<persName><forename type="first">T</forename><surname>Springenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dosovitskiy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Brox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Riedmiller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>ICLR Workshops</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Dropout: a simple way to prevent neural networks from overfitting</title>
		<author>
			<persName><forename type="first">N</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1929" to="1958" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Intriguing properties of neural networks</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zaremba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bruna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">J</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fergus</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>ICLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Rethinking the Inception architecture for computer vision</title>
		<author>
			<persName><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ioffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Shlens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wojna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
				<meeting>the IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Statistical learning theory</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Vapnik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>J. Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">On the uniform convergence of relative frequencies of events to their probabilities. Theory of Probability and its Applications</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vapnik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Chervonenkis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Veit</surname></persName>
		</author>
		<ptr target="https://github.com/andreasveit" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">P</forename><surname>Warden</surname></persName>
		</author>
		<ptr target="https://research.googleblog.com/2017/08/launching-speech-commands-dataset.html" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Aggregated residual transformations for deep neural networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dollár</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>He</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>CVPR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Zagoruyko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Komodakis</surname></persName>
		</author>
		<title level="m">Wide residual networks. BMVC</title>
				<imprint>
			<date type="published" when="2016">2016a</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">S</forename><surname>Zagoruyko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Komodakis</surname></persName>
		</author>
		<ptr target="https://github.com/szagoruyko/wide-residual-networks" />
		<imprint>
			<date type="published" when="2016">2016b</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Understanding deep learning requires rethinking generalization</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Recht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<ptr target="https://github.com/pluskid/fitting-random-labels" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<title level="m">Random erasing data augmentation</title>
				<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
