<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Learning the Truth Privately and Confidently: Encrypted Confidence-Aware Truth Discovery in Mobile Crowdsensing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yifeng</forename><surname>Zheng</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Huayi</forename><surname>Duan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Cong</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Transactions on Information Forensics and Security</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Learning the Truth Privately and Confidently: Encrypted Confidence-Aware Truth Discovery in Mobile Crowdsensing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A74F7A2E8662BE0F9211825AC11331F0</idno>
					<idno type="DOI">10.1109/TIFS.2018.2819134</idno>
					<note type="submission">This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TIFS.2018.2819134, IEEE Transactions on Information Forensics and Security</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T16:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Mobile crowdsensing</term>
					<term>confidence-aware truth discovery</term>
					<term>privacy</term>
					<term>cloud</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Mobile crowdsensing enables convenient sensory data collection from a large number of mobile devices, and has found various applications. In the real practice, however, the sensory data collected from various mobile devices are usually unreliable. To extract truthful information from the unreliable sensory data in mobile crowdsensing, the topic of truth discovery has received wide attention recently, which essentially operates by estimating user reliability degrees and performing reliabilityaware truthful aggregation. Despite the effectiveness, applying truth discovery in mobile crowdsensing faces several privacy and security challenges. Firstly, the sensory data and reliability degrees of users may reveal privacy-sensitive information and thus demand strong protection. Secondly, the requester that initiates a crowdsensing application usually needs to have monetary investment, so the inferred truths can be the requester's proprietary information and should be protected as well.</p><p>In this paper, we propose a new system architecture enabling encrypted truth discovery in mobile crowdsensing. We focus on general and realistic mobile crowdsensing scenarios with varying levels of user participation, and our security design is built on the confidence-aware truth discovery (CATD) approach for its state-of-the-art accuracy in such scenarios. In our system architecture, users send encrypted sensory data to the cloud, where CATD is then conducted in the encrypted domain. The final encrypted inferred truths are sent to the requester for decryption. Along the whole workflow, the sensory data and reliability degrees of users, as well as the inferred truths of the requester, are kept private. Extensive experiments over realworld mobile crowdsensing dataset show that our design achieves practical performance on mobile devices.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The paradigm of mobile crowdsensing facilitates the collection of sensory data from a large number of mobile devices with sensing and computing capabilities, such as smartphones and wearables. With the benefits of low deployment cost and wide geographic coverage, mobile crowdsensing has enabled a broad range of applications, such as health monitoring, indoor floorplan reconstruction, environmental monitoring, and smart transportation <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>. In the real practice, however, the Y. Zheng is with the Department of Computer Science, City University of Hong Kong, Hong Kong, China, and also with the City University of Hong Kong Shenzhen Research Institute, Shenzhen 518057, China (e-mail: yifeng.zheng@my.cityu.edu.hk).</p><p>H. Duan is with the Department of Computer Science, City University of Hong Kong, Hong Kong, China (e-mail: hduan2-c@my.cityu.edu.hk).</p><p>C. Wang is with the Department of Computer Science, City University of Hong Kong, Hong Kong, China, and also with the City University of Hong Kong Shenzhen Research Institute, Shenzhen 518057, China (e-mail: congwang@cityu.edu.hk). sensory data collected from various mobile users are usually unreliable, due to the differences in sensor quality, ambient noise, skill level, etc <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b2">[3]</ref>. Therefore, it is vital for the crowdsensing platform, which is usually deployed at the public cloud due to its well-understood benefits, to aggregate the sensory data from different mobile users so as to obtain truthful information.</p><p>When aggregating the sensory data, intuitively one might consider traditional aggregation mechanisms such as averaging and majority voting. However, these traditional aggregation mechanisms do not essentially capture the quality difference in user-contributed sensory data and thus would fail to provide accurate results <ref type="bibr" target="#b2">[3]</ref>. To address this issue, truth discovery has been recently proposed, which refers to a family of algorithms <ref type="bibr" target="#b2">[3]</ref>- <ref type="bibr" target="#b4">[5]</ref> that estimate the reliability degrees of individual data contributors in the form of weights, and infer the truthful information via reliability-aware aggregation.</p><p>Despite the effectiveness, applying truth discovery in mobile crowdsensing to mine truthful information needs to tackle critical privacy and security challenges. Firstly, the sensory data collected by the cloud may reveal privacy-sensitive information (e.g., daily routines, location, personal health, and social relations) <ref type="bibr" target="#b0">[1]</ref>, and the cloud might also misuse the collected data for profit or suffer from data breaches <ref type="bibr" target="#b5">[6]</ref>. Secondly, in the context of truth discovery, the reliability degrees of individual users should also be protected as it may reveal some personal information such as education level, major, and age <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. Thirdly, a requester that initiates a crowdsensing application usually needs to invest in the application by paying the cloud service provider and offering rewards to users <ref type="bibr" target="#b6">[7]</ref>, so the inferred truths can be proprietary in nature. Thus, from the requester's perspective, keeping the inferred truths private is also highly demanded. Therefore, it is of critical importance to ensure user privacy and requester protection in mobile crowdsensing with truth discovery.</p><p>In the literature, only a few works <ref type="bibr" target="#b6">[7]</ref>- <ref type="bibr" target="#b9">[10]</ref> have started to study privacy-aware truth discovery with protection of both sensory data and reliability degrees of individual users. These works are valuable data points in the design space, yet they still have the following limitations. Firstly, the plaintext truth discovery algorithm underlying these works is not well suited for real-world mobile crowdsensing applications where it is common that user participation level varies significantly due to reasons like availability, capabilities, and sensing cost <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b10">[11]</ref>. That is, the number of objects sensed by different users is naturally different. This realistic fact will heavily affect the accuracy of weight estimation of users and thus of the inferred truths, yet is overlooked in their adopted plaintext truth discovery algorithm <ref type="bibr" target="#b3">[4]</ref>. So, when being deployed for real-world mobile crowdsensing applications, these works will fail to achieve high-quality truthful information. Secondly, these works do not provide requester protection as the inferred truths are directly exposed to the cloud server/users Thirdly, to protect both sensory data and reliability degrees of individual users, these works all require mobile users to stay online to actively participate in the whole truth discovery procedure, which is actually not easy to be satisfied in practice due to various factors such as unreliable networks and battery issues. In a word, prior works present undesirable limitations in functionality, security, and practicality.</p><p>The shortcomings of existing works drive us to explore a new private truth discovery architecture from the ground up for realistic mobile crowdsensing applications. Our research efforts aim to achieve highly accurate truthful information in truth discovery for realistic mobile crowdsensing applications with varying levels of user participation, while ensuring user privacy and requester protection. In particular, different from existing works, we build our completely new security design on top of the plaintext truth discovery algorithm in <ref type="bibr" target="#b3">[4]</ref> for its state-of-the-art accuracy performance in our target realistic mobile crowdsensing scenarios <ref type="bibr" target="#b11">[12]</ref>. This algorithm relies on the principle that if a user senses plenty of objects, then confidence of weight estimation is high; otherwise, if a user only senses a few objects, the confidence of weight estimation is low. So, <ref type="bibr" target="#b3">[4]</ref> integrates this principle and proposes confidenceaware truth discovery to obtain highly accurate inferred truths.</p><p>We propose a completely new secure system architecture enabling encrypted confidence-aware truth discovery in mobile crowdsensing, and simultaneously achieves user privacy and requester protection. At a high level, our system operates as follows. Users send encrypted sensory data to the cloud, where confidence-aware truth discovery is then conducted in the encrypted domain. Finally, the inferred truths are produced in encrypted form and sent to the requester for decryption. Throughout the whole procedure, the sensory data and reliability degrees of users, as well as the inferred truths of the requester, are kept private. In addition, users in our system architecture can be offline, which means that they can just send their encrypted sensory data whenever they desire and are not required to stay online to participate in the encrypted confidence-aware truth discovery procedure.</p><p>In particular, our system architecture adopts a non-colluding two-server model, in which we consider that two cloud servers hosted by independent cloud service providers are available. Such a two-server model is commonly used in the literature to facilitate security designs in various application domains (e.g., <ref type="bibr" target="#b12">[13]</ref>- <ref type="bibr" target="#b14">[15]</ref>, to just list a few). We note that the latest work on privacy-aware truth discovery <ref type="bibr" target="#b8">[9]</ref> also operates under such a model, so our adoption of the model is also consistent with the latest work. In our system, one cloud server acts as the crowdsensing platform bridging users and the requester, while the other provides assistance to complete the procedure of encrypted confidence-aware truth discovery. As long as the two semi-honest cloud servers do not collude, our system keeps the sensory data and reliability degree of users private, as well as the proprietary inferred truths of the requester.</p><p>Under the above model, we first present a basic construction as a starting point for encrypted confidence-aware truth discovery. Following the blue print of leveraging additively homomorphic encryption and garbled circuits to solve applicationspecific tasks as previous works did (e.g., <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b15">[16]</ref>- <ref type="bibr" target="#b18">[19]</ref>, to just list a few), our basic construction uniquely bridges additively homomorphic encryption and garbled circuits to embrace the operations required by confidence-aware truth discovery. It fully supports the target functionality while providing all the expected security strengths. However, the complexity of communication between the two cloud servers is nearly O(m•n), where m is the number of objects and n is the number of users. That is, the communication complexity depends on the amount of sensory data collected from all users. Considering that such a communication complexity may not scale well in practice, we then present our improved construction which optimizes the overall communication complexity between the two cloud servers as O(m + n). Particularly, we uniquely integrate and adapt a secure transformation technique from a recent work <ref type="bibr" target="#b19">[20]</ref>, which can transform an additively homomorphic encryption scheme into a scheme capable of evaluating multiplication on ciphertexts.</p><p>We derive a new insight on the design philosophy and our proposed key idea is as follows. During the encrypted confidence-aware truth discovery procedure, we leverage the multiplicative property of the secure transformation technique to let each cloud server do multiplication locally over a batch of values, and only transfer the encrypted aggregate values between the two cloud servers. Based on this key idea, we show how to devise a new improved privacy-preserving confidenceaware truth discovery protocol which significantly optimizes the communication complexity. We conduct a quantitative complexity analysis to show the efficacy of our optimization, and also justify that the improved construction does not trade off computation performance and security. Our optimization trick may be of independent interest and could provide useful guidelines and new insights on performance optimization for other two-server security designs that leverage homomorphic encryption for encrypted computation.</p><p>Our contributions can be summarized as follows.</p><p>• We propose the first secure system framework for encrypted confidence-aware truth discovery in mobile crowdsensing. It can deliver highly accurate truthful information, while providing user privacy and requester protection.</p><p>• We present a basic construction for encrypted confidenceaware truth discovery as a starting point, and further give our improved construction with optimized communication complexity between the two cloud servers. • We conduct extensive experiments to evaluate our design, and the evaluation over real-world mobile crowdsensing dataset demonstrate that our design achieves practical performance on mobile devices. The rest of this paper is organized as follows. Section II gives our problem statement and Section III provides some preliminaries. Section IV presents our basic construc-tion and Section V gives our improved construction. Section VI presents the experiments and Section VII describes the related work. Section VIII provides discussions and Section IX concludes the whole paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PROBLEM STATEMENT</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Background on Confidence-Aware Truth Discovery</head><p>In real-world mobile crowdsensing applications, the sensory data collected from users are usually not reliable and thus aggregation of sensory data from multiple users on the same objects is of practical importance <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. To ensure that the aggregation provides truthful information, the techniques of truth discovery have been proposed recently and have received wide attention. Truth discovery typically works by estimating the reliability degrees of different users in the form of weights, and integrating users' sensory data based on such reliability information to infer the ground truths <ref type="bibr" target="#b2">[3]</ref>.</p><p>So far, various plaintext truth discovery approaches targeting different application scenarios have been proposed <ref type="bibr" target="#b2">[3]</ref>- <ref type="bibr" target="#b4">[5]</ref>. In this paper, we focus on general and realistic mobile crowdsensing scenarios with various levels of user participation and resort to the approach in <ref type="bibr" target="#b3">[4]</ref> for its state-of-the-art accuracy performance in our target scenarios <ref type="bibr" target="#b11">[12]</ref>. The principle behind this approach is that if a user senses plenty of objects, then confidence of weight estimation is high; if a user only senses a few objects, the confidence of weight estimation is low. Based on this principle, <ref type="bibr" target="#b3">[4]</ref> introduces a confidence interval for the estimation of user weight, and proposes confidence-aware truth discovery (CATD).</p><p>We now formally introduce CATD. Firstly, we describe some notations. Let T be the whole set of objects, and U be the set of system users. We denote the subset of objects chosen by user i ∈ U as T i , where T i is a subset of T . We represent the subset of users that choose to sense object t by U t . We write |C| to denote the cardinality of a set C. We will refer to the sensory data provided users as sensing values. The sensing value provided by user i on object t is written as x i t , and the inferred truth for object t is x * t . With these notations, we now introduce the details of the CATD algorithm. The CATD algorithm starts with truth initialization for each object t, i.e., obtaining the initial truth x * (0) t</p><p>. Here, x * (0) t can be computed as the mean of the sensing values on object t. Then, the CATD algorithm performs weight update and truth update to obtain the inferred truths for different objects. We now introduce how to perform weight update and truth update below.</p><p>a) Weight update: Given the estimated truth x * t , the weight for each user i is updated as follows.</p><formula xml:id="formula_0">w i = y i t∈Ti (x i t -x * t ) 2 .<label>(1)</label></formula><p>Here y i is a coefficient to scale up the user's weight, and</p><formula xml:id="formula_1">y i = χ 2 (1-α/2,|Ti|)</formula><p>. Note that χ denotes the Chi-squared distribution, and the system-wide constant α is known as significance level, which is usually a small number such as 0.05. The more objects a user senses, the higher the user's weight will be scaled via y i . b) Truth update: Given the weight w i for each user i, the truth for each object t is updated as follows.</p><formula xml:id="formula_2">x * t = i∈Ut w i x i t i∈Ut w i . (<label>2</label></formula><formula xml:id="formula_3">)</formula><p>The above are the details of performing weight update and truth update in CATD. Note that the coefficient y i = χ 2</p><p>(1-α/2,|Ti|) for each user i in the weight update phase can be directly computed, given α and the number of objects for which user i provide the sensing values. For example, χ 2 (0.975,2) = 0.051. Hence, χ 2 (1-α/2,|Ti|) is independent of the sensing values of users and can be treated as public parameters once the number of objects sensed by each user is known. To apply CATD in practice, it is recommended that an iterative procedure be adopted on both weight update and truth update so as to achieve more accurate results <ref type="bibr" target="#b3">[4]</ref>. And the iterative procedure can stop when some termination criterion is met, say a maximum number of iterations <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. System Architecture</head><p>Fig. <ref type="figure">1</ref> illustrates our system architecture. At the core, our system consists of three types of entities: the requester, the cloud, and users. The requester is a party who initiates a crowdsensing application via the cloud and releases a set of objects for which he wants to collect sensing values. An example of a crowdsensing application is indoor floorplan reconstruction <ref type="bibr" target="#b20">[21]</ref>, which aims to construct the floorplan from the sensing values collected from mobile devices equipped with various sensors (e.g., compass, accelerometer, and gyroscope). Accordingly, an object in such a crowdsensing application may refer to measuring the distances between two specified location points. With regard to users, they are crowdsensing participants that are willing to sense the objects via their mobile devices. Naturally each user may choose a subset of the released object set to sense rather than all the objects <ref type="bibr" target="#b3">[4]</ref>. After sensing the selected objects, users will encrypt the sensing values before submitting them to the cloud so as to preserve their privacy.</p><p>In our architecture, we consider that the cloud entity consists of two cloud servers S 0 and S 1 , which are hosted by independent cloud service providers. Such a two-server model has been widely adopted in the literature to facilitate security applications (e.g., <ref type="bibr" target="#b12">[13]</ref>- <ref type="bibr" target="#b14">[15]</ref>, to just list a few) and we consider our adoption of this model to be in this trend. In our system, S 0 serves as a crowdsensing platform that releases the objects from the requester, and collects encrypted sensing values from users, while S 1 obliviously provides computation assistance to S 0 to support encrypted CATD. When encrypted CATD is finished, S 0 sends the encrypted inferred truths to the requester for decryption. It is worth noting that in our system the requester and users are not required to stay online to actively participate in the encrypted CATD procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Threat Model</head><p>Our security goal is to provide user privacy and requester protection. For user privacy, we aim to keep the sensing values and weights of users private. For requester protection, we aim to keep the inferred truths of objects confidential for the requester. As in our system the users only submit encrypted sensing values and the requester only receives encrypted truths of objects, we consider the remaining parties, i.e., the two cloud servers S 0 and S 1 as the adversaries. Similar to most of prior works in the two-server model (e.g., <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b16">[17]</ref>), we assume that S 0 and S 1 are honest-but-curious, and there is no collusion between them. Particularly, they will follow our protocol specification honestly, yet they are curious about inferring the private information and will do so independently.</p><p>Such an security assumption makes sense in our target cloud-based mobile crowdsensing applications, because in practice cloud service providers are well-established and business-driven parties who do not want to harm their reputation and thus avoid behaving maliciously and collusion <ref type="bibr" target="#b21">[22]</ref>- <ref type="bibr" target="#b23">[24]</ref>. Meanwhile, on the practical service deployment side, protocols under the semi-honest model would present much more efficient implementation than protocols under the malicious adversary model <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b24">[25]</ref>. For the non-collusion assumption, in practice we may further ensure it by taking procedural, organizational, or legal steps <ref type="bibr" target="#b22">[23]</ref>. Note that protocols in the semi-honest model are generally considered as the first step towards protocols that can handle malicious adversaries. So, we believe that our design lays a solid foundation for extending our initially proposed privacy-preserving CATD protocols to work under the malicious adversary model (with corresponding performance deterioration). This might be explored by using garbled circuits with malicious security <ref type="bibr" target="#b25">[26]</ref> and relevant verifiable computation techniques over data encrypted under homomorphic encryption <ref type="bibr" target="#b26">[27]</ref>. We leave a careful study as future work.</p><p>We do not consider that users maliciously manipulate their sensory data so as to disrupt the system. The defense against such a threat is an orthogonal problem and can be addressed via cryptographic techniques like zero-knowledge proofs <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b28">[29]</ref>. We also do not specifically consider privacy implication from object selection of different users, which can be tackled via deploying proper anonymization techniques <ref type="bibr" target="#b29">[30]</ref>. Our security focus in this work is to ensure data confidentiality against the cloud servers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. TECHNICAL PRELIMINARIES A. Yao's Garbled Circuits</head><p>Yao's garbled circuits enables two parties holding inputs a and b, respectively, to jointly compute an arbitrary function f(a, b) in such a manner that their inputs are kept confidential against each other and only the function output is revealed at the end <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b31">[32]</ref>. At a high level, the protocol of garbled circuits works as follows. Firstly, one party, called generator, generates a garbled version of a circuit computing f(•, •). Then, the generator sends the garbled circuit and the garbled value a corresponding to his input a to the other party, which is called the evaluator. The evaluator runs a 1-out-of-2 oblivious transfer (OT 2 1 ) protocol <ref type="bibr" target="#b32">[33]</ref> with the generator to obliviously obtain the garbled input b corresponding to his private input b. Upon obtaining a and b, the evaluator can evaluate the garbled circuit to obtain the target result f(a, b).</p><p>In more detail, the function f is represented as a Boolean circuit, and for each wire w of the circuit, the generator associates two random cryptographic keys {k w 0 , k w 1 }. Then, for each binary gate, the generator produces a garbled gate. In particular, for each row of the corresponding truth table, the generator encrypts the output wire key by using the two input wire keys. The set of the resulting randomly ordered four ciphertexts constitutes a garbled gate. Subsequently, the generator sends the garbled gates to the evaluator, along with the cryptographic keys associated with his input wires, and the mapping between the garbled-circuit output values and the actual bit values. The evaluator obtains the cryptographic keys corresponding to his input wires via running the oblivious transfer protocol with the generator. Then, the evaluator can evaluate the garbled circuit gate by gate, starting from the gates connected to the inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Additively Homomorphic Cryptosystem</head><p>Suppose now we are given a public-key encryption scheme HE = (Gen, E, D), where Gen is the key generation algorithm and E and D are its encryption algorithm and decryption algorithm respectively. We say that HE is additively homomorphic if it the following properties <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b34">[35]</ref>. Firstly, given two ciphertexts E pk (m 1 ) and E pk (m 2 ) of two plaintext messages m 1 and m 2 under the same public key pk, it holds that</p><formula xml:id="formula_4">D sk (E pk (m 1 ) • E pk (m 2 )) = m 1 + m 2 .</formula><p>That is, given the encryptions of two messages, we are able to directly derive the encryption of the sum of the two messages, without knowing the private key sk corresponding to pk. Secondly, give a public constant c and</p><formula xml:id="formula_5">E pk1 (m 1 ), it holds that D sk (E pk (m 1 ) c ) = c • m 1 .</formula><p>That is, given the encryption of a message and a public constant, we are able to directly derive the encryption of the multiplication of the message and the constant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Handling Floating-Point Numbers</head><p>Our security design will work over integers, which is inherently required by the underlying cryptographic primitive additively homomorphic encryption <ref type="bibr" target="#b35">[36]</ref> and is also a common practice of using garbled circuits <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr">[37]</ref>. To handle floatingpoint numbers, we will use a rounding factor L to scale up a fractional value a into an integer a = aL whenever needed. The approximate a can be later reconstructed as a/L <ref type="bibr" target="#b36">[38]</ref>. This is a common trick adopted in the literature ( <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b36">[38]</ref>, to just list a few). As validated in the experiments, a proper choice of L will not affect the accuracy of our design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. BASIC CONSTRUCTION</head><p>In this section, we present a basic construction for encrypted CATD. The basic construction enables CATD to be conducted over encrypted sensing values, and achieves the expected security strengths, i.e., protection of sensing values, weights, and inferred truths against the cloud servers. However, the complexity of communication between the two cloud servers is not optimal and remains to be improved. Later in Section V we will show how to optimize the communication complexity between the two cloud servers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Design Rationale</head><p>Our work targets encrypted CATD in general and realistic mobile crowdsensing scenarios with various levels of user participation. As the plaintext CATD algorithm needs to perform truth initialization and then iterative weight update and truth update, our proposed construction for encrypted CATD also consists of three components accordingly, i.e., (i) encrypted truth initialization, (ii) encrypted weight update, and (iii) encrypted truth update.</p><p>To support computation in the encrypted domain, we may directly resort to generic approaches like fully homomorphic encryption or garbled circuits. However, fully homomorphic encryption is prohibitively expensive <ref type="bibr" target="#b37">[39]</ref>, which would lead to highly cumbersome overhead in storage, computation, and communication. Simply building a garbled circuit which completes all the computation will require a large circuit with a size linear in the total number of sensing values and the number of iterations. Therefore, for practicality consideration, we would resort to a hybrid approach that bridges relatively lightweight additively homomorphic encryption with garbled circuits. Similar treatment also appears in previous works under other different application domains, like <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b15">[16]</ref>- <ref type="bibr" target="#b18">[19]</ref>, and readers may refer to <ref type="bibr" target="#b38">[40]</ref> for a formal description of the hybrid approach.</p><p>We craft a secure protocol customized for CATD, with guarantees of user privacy and requester protection. In particular, our main idea is to employ additively homomorphic encryption like the widely used Paillier cryptosystem <ref type="bibr" target="#b39">[41]</ref> to conduct secure aggregation (i) across users for each object in encrypted truth initialization, (ii) across objects for each user in encrypted weight update, and (iii) across users for each object in encrypted truth update. Then, when encrypted division is needed for aggregate values, garbled circuits are employed. We will show how to construct an encrypted division protocol from garbled circuits shortly. We are aware that there is a previous work <ref type="bibr" target="#b40">[42]</ref> which proposes encrypted integer division based on homomorphic encryption, yet it only handles specific cases where the divisor is publicly known or known to one party involved in the computation. However, in our proposed encrypted CATD protocol, it is required that the divisor (in both encrypted weight update and encrypted truth update) should be kept confidential against the two cloud servers, for ensuring user privacy and requester protection. So, the method in <ref type="bibr" target="#b40">[42]</ref> is not directly applicable to our context.</p><p>In addition, as multiplication in the encrypted domain is also required (e.g., computing squared distance between sensing Input: S 0 has E pk1 (a) and E pk1 (b); S 1 has secret key sk 1 . Output: S 0 obtains E pk1 (a/b). Procedure: S 0 :</p><p>1. Choose two random masks r a and r b , and compute 4. Build a garbled circuit GC taking as input the garbled values of u a , u b , r a , r b , and r, where r is a random mask chosen by S 1 . 5. Send GC to S 0 , along with the garbled values of u a , u b , and r. Also, E pk1 (r) is sent. S 0 , S 1 :</p><formula xml:id="formula_6">a ← E pk1 (a) • E pk1 (r a ) and b ← E pk1 (b) • E pk1 (r b ). 2.</formula><p>6. S 0 runs a OT protocol with S 1 to obtain the garbled values of r a and r b . S 0 :</p><p>7. Evaluate GC to obtain a/b -r. values and truths in Eq. 1, and computing weighted sensing values in Eq. 2), an encrypted multiplication protocol is also needed. We observe that this can be achieved by using a simple protocol based on homomorphic encryption from <ref type="bibr" target="#b22">[23]</ref>, which will also be introduced shortly. However, we will show later via theoretical analysis that the direct adoption of this encrypted multiplication protocol will lead to high communication complexity between the two cloud servers. This drives us to present an improved construction (Section V) in which the communication complexity due to encrypted multiplication is optimized. Note that the reason why we do not use garbled circuits for encrypted multiplication is as follows. In garbled circuits, even simple functions may result in a circuit with an excessive number of gates. Motivated by this observation, a recent trend in secure computation is to use garbled circuits selectively for cost efficiency. That is, garbled circuits are only used to handle operations that cannot be directly decomposed into arithmetic operations (addition and multiplication) <ref type="bibr" target="#b41">[43]</ref>. So, following this trend, we use homomorphic encryption for encrypted multiplication instead of garbled circuits.</p><formula xml:id="formula_7">8. E pk1 (a/b) = E pk1 (a/b -r) • E pk1 (r).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Building Blocks</head><p>Before presenting the detailed construction of encrypted CATD, we first introduce some building blocks that will be used in our construction.</p><p>1) Encrypted Division Protocol: We first show how to use garbled circuits to construct an encrypted division protocol. The goal of this protocol is to enable S 0 holding E pk1 (a) and E pk1 (b) to obtain E pk1 (a/b), without knowing a, b, and a/b. Here pk 1 is the public key of S 1 . Our high-level idea is to let S 1 build a garbled circuit for secure division, while S 0 evaluates the garbled circuit and finally obtains the division result in encrypted form.</p><p>To apply the above high-level idea, we need to consider (i) how to efficiently recover the inputs inside the garbled circuit for division, and (ii) how to efficiently produce the encrypted division result E pk1 (a/b) at the S 0 side. Note that straightforwardly performing complex homomorphic decryption (for E pk1 (a) and E pk1 (b)) and homomorphic encryption (for a/b) inside the garbled circuit is not practically efficient. Inspired by the idea of additive obfuscation via random masks as in previous works <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b16">[17]</ref>, the two issues are addressed as follows. Firstly, we describe how to efficiently recover the inputs inside the garbled circuit for division. We let S 0 obscure the original values by adding random masks in the encrypted domain and send the encrypted obscured values to S 1 . Then, S 1 obtains masked values, and prepares a garbled circuit inside which a relatively lightweight mask removal module is used to remove the masks and recover the original values for division. Secondly, we describe how to efficiently produce the encrypted division result E pk1 (a/b) at the S 0 side. We obscure the division result with a random mask r chosen by S 1 . That is, the evaluation result of the garbled circuit is a/b -r, so the division result a/b is oblivious to S 0 . Then, we can leverage the homomorphic property to enable S 0 to obtain E pk1 (a/b) outside the circuit, by asking S 1 to send E pk1 (r) to S 0 . Fig. <ref type="figure" target="#fig_2">2</ref> summarizes the encrypted division protocol, which will be denoted as EncDiv hereafter.</p><p>Proposition 1. The EncDiv has the security property that neither S 0 nor S 1 learns a, b, and a/b. That is, both cloud servers learn nothing.</p><p>Proof. For S 1 , it only observes randomly masked values u a and u b , which is indistinguishable from random values. For S 0 , it observes encryptions E pk1 (a), E pk1 (b), and E pk1 (r) under semantically-secure homomorphic cryptosystem, and the information revealed from the execution of garbled circuit. The security of garbled circuits, which is formally proved in <ref type="bibr" target="#b31">[32]</ref>, ensures that nothing is revealed except the evaluation output. The evaluation output produced at S 0 side is also a randomly masked result a/b -r (Step 7 in Fig. <ref type="figure" target="#fig_2">2</ref>), which also reveals nothing to S 0 . So, the view of each cloud server can be simulated, and both cloud servers learn nothing.</p><p>Remark. For the ease of presentation, we use a/b to represent the division result in the above description. For actual usage, the output of division should be represented as L • a/b , so the result from the protocol is actually E pk1 ( L • a/b ) for use in subsequent cryptographic computation.</p><p>Note that for the evaluation of division through garbled circuit, our design just requires the support of standard integer division functionality. Let \ denote the integer division operator that is distinguished from the normal division operator /. Note that we have L • a/b = L • a\b for the two integers a and b <ref type="bibr" target="#b15">[16]</ref>. So, to obtain L • a/b for two integers a and b, inside the garbled circuit we just need the support of computing a \b (a = L • a). Such a standard integer division functionality inside garbled circuit can be readily supported via the adoption of existing advanced programming frameworks for garbled circuit protocol implementation. In this paper, for demonstration purpose, we will resort to the expressive Input: S 0 has E pk1 (a) and E pk1 (b); S 1 has secret key sk 1 . Output: S 0 obtains E pk1 (a • b). Procedure: S 0 :</p><p>1. Choose two random masks r 1 and r  ObliVM-lang programming framework <ref type="bibr" target="#b42">[44]</ref> for garbled circuit protocol implementation. While in principle there are different ways to implement garbled circuits for the integer division functionality, e.g., the one in <ref type="bibr" target="#b43">[45]</ref>, it is noted that the garbled circuit backend ObliVM-GC <ref type="bibr" target="#b44">[46]</ref> underlying our adopted ObliVM-lang programming framework is one of the stateof-the-art tools that integrate various latest optimization techniques for garbled circuits and presents excellent performance. We emphasize that optimization of garbled circuit protocol implementation is an orthogonal research direction and is out of the scope of this paper.</p><formula xml:id="formula_8">2 . 2. a ← E pk1 (a) • E pk1 (r 1 ). 3. b ← E pk1 (b) • E pk1 (r 2 ).</formula><formula xml:id="formula_9">6. u = u a • u b . 7. u ← E pk1 (u). 8. Send u to S 0 . S 0 : 9. s ← u • E pk1 (a) -r2 • E pk1 (b) -r1 . 10. E pk1 (a • b) ← s • E pk1 (-r 1 • r 2 ).</formula><p>2) Encrypted Multiplication Protocol: To support multiplication over values encrypted by additively homomorphic cryptosystem, we observe that the protocol from <ref type="bibr" target="#b22">[23]</ref> can be used, which is shown in Fig. <ref type="figure" target="#fig_4">3</ref>. This protocol enables S 0 holding E pk1 (a) and E pk1 (b) to obtain E pk1 (a • b) via the interaction with S 1 . Hereafter we will refer to this encrypted multiplication protocol as EncMul.</p><p>Proposition 2. The EncMul protocol has the security property that neither S 0 nor S 1 learns a, b, and a•b. That is, both cloud servers learn nothing.</p><p>Proof. From the protocol execution, S 0 only observes encryptions of values E pk1 (a), E pk1 (b), and E pk1 (u) under semantically-secure homomorphic cryptosystem, for which S 0 does not have the private key for decryption. As for S 1 , it only observes randomly masked values u a and u b . In a nutshell, the messages observed by each cloud server are indistinguishable from random values. So, the view of each cloud server can be simulated, and both cloud servers learn nothing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Construction of Encrypted CATD</head><p>We now present our complete protocol, which includes three phases: (i) system setup, (ii) encrypted data provision, and (iii) encrypted CATD. In what follows, we describe the details of each phase.</p><p>Input: S 0 has E pk1 (x i t ) and E pk1 (x * t ); S 1 has secret key sk 1 . Output: S 0 obtains E pk1 (w i ). Procedure: S 0 :</p><formula xml:id="formula_10">1. E pk1 (d i t ) = E pk1 (x i t ) L • E pk1 (x * t ) -1 , for each t ∈ T i . // x * t = L 2 • x * t and d i t = L 2 • (x i t -x * t ) S 0 , S 1 :</formula><p>2. S 0 runs the EncMul protocol with S 1 to obtain E pk1 ((</p><formula xml:id="formula_11">d i t ) 2 ), for each t ∈ T i . S 0 : 3. Compute E pk1 (d i ) = E pk1 ( t∈Ti (d i t ) 2 ) via homo- morphic addition property. // d i = L 4 • t∈Ti (x i t -x * t ) 2 S 0 , S 1 :</formula><p>4. S 0 runs the EncDiv protocol with S 1 to obtain 1) System Setup: S 1 generates an asymmetric key pair &lt;pk 1 , sk 1 &gt; of the Paillier cryptosystem, and the public key pk is published. Similarly, the requester also generates a key pair &lt;pk rq , sk rq &gt; of the Paillier cryptosystem, and publishes the public key pk rq . Then, S 0 releases a set of objects T for some crowdsensing application initiated by the requester, and sets a public value for the significance level α (in this paper α is set to 0.05 following <ref type="bibr" target="#b3">[4]</ref>).</p><formula xml:id="formula_12">E pk1 (w i ) = E pk1 ( L • w i ). // w i = L 5 • y i \d i inside garbled circuit.</formula><p>2) Encrypted Data Provision: Each user i chooses a subset of objects T i ⊆ T to sense, and generates the sensing values {x i t } t∈Ti . Then, each user i encrypts his sensing values for the objects sensed and produces {E pk1 (x i t )} t∈Ti , where</p><formula xml:id="formula_13">x i t = L • x i t .</formula><p>Finally, each user i uploads {E pk1 (x i t )} t∈Ti to S 0 , and can go offline.</p><p>3) Encrypted CATD: After collecting the encrypted sensing values from users, S 0 and S 1 jointly performs CATD in the encrypted domain to obtain the encrypted inferred truth for each object. As mentioned before, the construction of encrypted CATD comprises the following components: (i) encrypted truth initialization, (ii) encrypted weight update, and (iii) encrypted truth update. We will introduce each component in detail below.</p><p>i) Encrypted truth initialization: Before moving to the iterative procedure of weight update and truth update, the truth for use in the first iteration of encrypted weight update should be computed for each object. According to <ref type="bibr" target="#b3">[4]</ref>, the truth for each object t can be initialized as the mean of the sum across different users' sensing values on that object. This can be achieved as follows. Firstly, 0 computes E pk1 ( i∈Ut x i t ) = i∈Ut E pk1 (x i t ) based on the homomorphic addition property. Secondly, S 0 computes the encrypted initial truth E pk1 (x * (0) t</p><formula xml:id="formula_14">) = E pk1 ( i∈Ut x i t • L/|U t | ), where x * (0) t = L 2 • x i t /|U t | .</formula><p>Hereafter, for consistentcy of protocol description, we will assume and set the scaling factor for the truth x * t inferred in each iteration to be L 2 . ii) Encrypted weight update: Given the encrypted truth E pk1 (x * t ) for each object t, where x * t = L 2 • x * t , the weight w i for each user i is updated in the encrypted domain. The detailed steps of doing encrypted weight update for each user is given in Fig. <ref type="figure" target="#fig_5">4</ref>. In the final step, the encrypted weight E pk1 (w i ) is produced on the S 0 side, where</p><formula xml:id="formula_15">w i = L • w i . Note that in Step 1, if this is the first iteration, E pk1 (x * t ) = E pk1 (x * (0) t</formula><p>). Besides, in Step 4, the input of S 0 in the EncDiv protocol is</p><formula xml:id="formula_16">E pk1 (d i ), where d i = L 4 • t∈Ti (x i t -x * t ) 2 .</formula><p>Recall that y i is a public parameter as described before in Section II-A, so it can actually be directly sent to S 1 for use in building the garbled circuit.</p><p>iii) Encrypted truth update: After the encrypted weight E pk1 (w i ) for each user i is obtained, the truth for each object t can then be updated in the encrypted domain accordingly. The update of the encrypted truth for each object t is given in Fig. <ref type="figure" target="#fig_6">5</ref>. At the final step, the encrypted truth E pk1 (x * t ) is produced on the S 0 side. It is noted that in Step 5, the inputs of S 0 in the EncDiv protocols are E pk1 (L • i∈Ut w i x i t ) and E pk1 ( i∈Ut w i ).</p><p>Recall that in the last iteration of encrypted truth update, it is required that the encrypted truth obtained from encrypted division should be able to be decrypted by the requester. This requires that in Step 5 of the EncDiv protocol (see Fig. <ref type="figure" target="#fig_2">2</ref>), S 1 encrypts the random mask r using the requester's public key pk rq instead of S 1 's public key pk 1 . That is, in the last iteration, S 0 obtains E pkrq (x * t ) for each object t and sends the final encrypted inferred truths {E pkrq (x * t )} t∈T to the requester. After decryption, the requester can obtain the truth via x * t /L 2 for each object t.</p><p>D. Security Guarantees Proposition 3. Our basic construction ensures that either of the two cloud servers is oblivious to the sensing values and weights of users, and truths of the requester.</p><p>Proof. Given the security properties of the building blocks EncMul and EncDiv, and the semantic security of the Paillier cryptosystem, the security guarantees of our construction in the honest-but-curious model can be proved trivially by analyzing the concrete workflow in our encrypted CATD protocol, based on the modular sequential composition theorem <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b45">[47]</ref>. Firstly, S 0 receives sensing values encrypted by the semantically-secure Paillier cryptosystem, for which S 0 does not have the key for decryption. During the encrypted CATD procedure, S 0 operates over the ciphertexts of sensing values and has some interactions with S 1 , i.e., via either the EncMul protocol (Step 2 in Fig. <ref type="figure" target="#fig_5">4</ref> and Step 1 in Fig. <ref type="figure" target="#fig_6">5</ref>) or the EncDiv protocol (Step 4 in Fig. <ref type="figure" target="#fig_5">4</ref> and Step 5 in Fig. <ref type="figure" target="#fig_6">5</ref>). As shown before, neither S 0 nor S 1 learns anything about the private plaintext data underlying these interactions. Therefore, all the sensing values as well as the weights and truths produced in the encrypted form are well kept confidential against both S 0 and S 1 . It is noted that at the last iteration, the truth for an object t is produced in the encrypted form as E pkrq (x * t ), where</p><p>Input: S 0 has E pk1 (w i ) and E pk1 (x i t ); S 1 has secret key sk 1 . Output: S 0 obtains E pk1 (x * t ). Procedure: S 0 , S 1 :</p><p>1. S 0 runs the EncMul protocol with S 1 to compute E pk1 (w i x i t ), for each i ∈ U t . S 0 :</p><formula xml:id="formula_17">2. E pk1 ( i∈Ut w i x i t ) = i∈Ut E pk1 (w i x i t ) 3. E pk1 (L • i∈Ut w i x i t ) = E pk1 ( i∈Ut w i x i t ) L 4. E pk1 ( i∈Ut w i ) = i∈Ut E pk1 (w i ) S 0 , S 1 :</formula><p>5. S 0 runs the EncDiv protocol with S 1 to obtain only the requester holding the secret key corresponding to pk rq can recover x * t .</p><formula xml:id="formula_18">E pk1 (x * t ) = E pk1 ( L 2 • i∈Ut w i x i t / i∈Ut w i ). // x * t = L • i∈Ut w i x i t \ i∈Ut w i inside garbled circuit</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Discussion</head><p>The above basic construction allows CATD to be securely conducted in the encrypted domain. During the whole procedure, S 0 has interactions with S 1 via the EncMul protocol or EncDiv protocol whenever necessary. We now analyze the communication complexity due to the call of each building block in our basic construction.</p><p>Firstly, we note that the EncDiv protocol needs to be called |U| times for computing the weight for each user in the phase of encrypted weight update, and |T | times for computing the truth for each object in the phase of encrypted truth update, so the communication complexity introduced by the use of this protocol is O(|U| + |T |).</p><p>Secondly, for EncMul protocol, it needs to be called to compute E pk1 ((d i t ) 2 ) over the sensed objects for each user i in the phase of encrypted weight update (Step 2 in Fig. <ref type="figure" target="#fig_5">4</ref>), and E pk1 (w i • x i t ) over the sensing users for each object t in the phase of encrypted truth update (Step 1 in Fig. <ref type="figure" target="#fig_6">5</ref>). For the first term, the number of objects sensed by each user i is |T i |, so the EncMul protocol needs be called |T i | times for each user i. Given |U| users, the EncMul protocol should be called </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. IMPROVED CONSTRUCTION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Secure Transformation Technique</head><p>Our improved construction resorts to a recent technique proposed by Catalano and Fiore <ref type="bibr" target="#b19">[20]</ref> to improve the communication complexity due to encrypted multiplication and thus the overall communication complexity in each iteration of encrypted CATD at the cloud side. In <ref type="bibr" target="#b19">[20]</ref>, a secure transformation technique is proposed, which can transform an additively homomorphic encryption scheme like the Paillier cryptosystem into a scheme capable of evaluating multiplication on ciphertexts. For ease of presentation, we call this technique as the CF technique in this paper.</p><p>The CF technique is originally developed for the secure outsourced computation scenario, and it allows a client to leverage two untrusted servers to do some computation on encrypted data. In this technique, a client encrypts a plaintext message m as C (1) = (m -b, E pku (b)), where pk u is the public key of the client for the additively homomorphic encryption algorithm E and b is a random value. Then, one server holds C (1) = (m -b, E pku (b)) while the other holds C (2) = b. As long as the two semi-honest servers do not collude, either of them learns nothing about the underlying plaintext value m from the ciphertexts they receive respectively <ref type="bibr" target="#b19">[20]</ref>. Hereafter, we will refer to C (1) as the first-level CF ciphertext, and C (2)  as the second-level CF ciphertext. Later, with the two servers doing some computation separately, the client is able to obtain the multiplication result m 1 • m 2 for two values m 1 and m 2 .</p><p>Specifically, the server holding the first-level CF ciphertexts performs</p><formula xml:id="formula_19">E pku ((m 1 -b 1 )(m 2 -b 2 ))E pku (b 1 ) (m2-b2) E pku (b 2 ) (m1-b1) ,</formula><p>which is actually equal to </p><formula xml:id="formula_20">E pku (m 1 m 2 -b 1 b 2 ),<label>(3)</label></formula><formula xml:id="formula_21">m 1 m 2 via m 1 m 2 -b 1 b 2 + b 1 b 2 .</formula><p>Note that this technique also supports multiplication by a public constant on the ciphertext <ref type="bibr" target="#b19">[20]</ref>. In particular, given a public constant c, the server holding the first-level CF ciphertext computes (c(m -b), E pku (b) c ) = (mc -bc, E pku (bc)), while the server holding the second-level CF ciphertext computes bc. So, the result is that one server obtains the first-level CF ciphertext (mc -bc, E pku (bc)) for the value mc, while the other obtains the second-level CF ciphertext bc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Our Idea</head><p>We uniquely integrate and adapt the CF technique in our design to optimize the communication complexity between S 0 and S 1 due to encrypted multiplication as O(|U| + |T |) in each iteration of encrypted CATD. Our main idea is to let S 0 hold the first-level CF ciphertexts, while S 1 holds the secondlevel CF ciphertexts. Then, S 0 and S 1 can do multiplication separately for a batch of values. After the multiplication</p><formula xml:id="formula_22">Input: S 0 has (x i t -b i t , E pk1 (b i t )) and (x * t -b * t , E pk1 (b * t )); S 1 has b i t and b * t . Output: S 0 obtains (w i -b i w , E pk1 (b i w )); S 1 obtains b i w . Procedure: S 0 : 1. Compute L • x i t -x * t -(b i t -b * t ) = d i t -(b i t -b * t ) and E pk1 (b i t -b * t ), for each t ∈ T i . // x * t = L 2 • x * t and d i t = L 2 • (x i t -x * t ) 2. Compute E pk1 ((d i t ) 2 -(b i t -b * t ) 2</formula><p>) via the property of the CF technique (Eq. 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Comptue</head><formula xml:id="formula_23">E pk1 (d i -t∈Ti (b i t -b * t ) 2 ) via the homo- morphic addition property. // d i = t∈Ti (d i t ) 2 = L 4 • t∈Ti (x i t -x * t ) 2 S 1 : 4. Compute t∈Ti (b i t -b * t ) 2 . 5. Send E pk1 ( t∈Ti (b i t -b * t ) 2 ) to S 0 . S 0 : 6. E pk1 (d i -t∈Ti (b i t -b * t ) 2 )•E pk1 ( t∈Ti (b i t -b * t ) 2 ), which is equal to E pk1 (d i ).</formula><p>S 0 , S 1 : 7. S 0 runs the EncDiv protocol with S 1 to obtain the new encrypted weight, i.e., operation is done, each cloud server aggregates its computation result locally, and then only encrypted aggregate values are transferred between S 0 and S 1 . For example, suppose that S 0 obtains K multiplication results, i.e.,</p><formula xml:id="formula_24">S 0 : (w i -b i w , E pk1 (b i w )), S 1 : b i w . // w i = L • w i</formula><formula xml:id="formula_25">{E pk1 (m 1k • m 2k -b 1k b 2k )} K k=1 , while S 1 has {b 1k b 2k } K k=1 . Then, S 0 computes E pk1 ( K k=1 (m 1k m 2k -b 1k b 2k )), while S 1 com- putes K k=1 b 1k b 2k . After this, S 1 sends E pk1 (- K k=1 b 1k b 2k ) to S 0 , which can then obtain E pk1 ( K k=1 m 1k m 2k ) via E pk1 ( K k=1 (m 1k m 2k -b 1k b 2k )) • E pk1 (- K k=1 b 1k b 2k ).</formula><p>In this way, in order to obtain the sum of K multiplication results, there is only O(1) communication between S 0 and S 1 .</p><p>Note that in this procedure, S 0 operates over the first-level CF ciphertexts, for which it is unable to infer the underlying plaintext values <ref type="bibr" target="#b19">[20]</ref>, and only receives encrypted values from S 1 . Thus, S 0 learns nothing about the plaintext values through the interaction with S 1 . For S 1 , it only operates over the second-level CF ciphertexts and thus is also oblivious to the underlying plaintext values <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Construction Details</head><p>With the above main idea in mind, we are now ready to present the details of our improved construction in which the overall communication complexity between the two cloud servers is optimized as O(|U|+|T |) in each iteration, while the expected security strengths are still guaranteed. The improved construction also comprises three phases: (i) system setup, (ii) encrypted data provision, and (iii) encrypted CATD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) System Setup:</head><p>This phase is the same as in the above basic construction.</p><p>2) Encrypted Data Provision: This phase is to let S 0 obtain the first-level CF ciphertexts of the sensing values, while S 1 obtains the corresponding second-level CF ciphertexts. In particular, for each sensing value x i t on the sensed object t ∈ T i , each user i generates the first-level</p><formula xml:id="formula_26">CF ciphertext C i(1) t = (x i t -b i t , E pk1 (b i t )), where x i t = L • x i t . Then, each user i sends {C i(1) t } t∈Ti to S 0 . Upon receiving {C i(1) t } t∈Ti from each user i, S 0 sends {E pk1 (b i t )} t∈Ti to S 1</formula><p>, which then performs decryption to obtain {b i t } t∈Ti , i.e., the second-level CF ciphertexts of the sensing values.</p><p>3) Encrypted CATD: As before, this phase comprises the following components: (i) encrypted truth initialization, (ii) encrypted weight update, and (iii) encrypted truth update. We will introduce each component in detail below.</p><p>i) Encrypted truth initialization: Before initiating the iterative procedure of encrypted weight update and encrypted truth update, S 0 needs to initialize the truth of each object t as the mean value of users' sensing values in the encrypted domain. Firstly,</p><formula xml:id="formula_27">S 0 computes i∈Ut (x i t -b i t ) and E pk1 ( i∈Ut b i t ) = i∈Ut E pk1 (b i t ). Secondly, S 0 computes x * (0) t -b * (0) t = i∈Ut (x i t -b i t ) • L/|U t | and E pk1 (b * (0) t ) = E pk1 ( i∈Ut b i t • L/|U t | ). Here x * (0) t = L 2 • x i t /|U t | . Mean- while, S 1 computes b * (0) t = i∈Ut b i t • L/|U t | .</formula><p>Simialr to our basic construction, hereafter, for consistentcy of protocol description, we will assume and set the scaling factor for the truth x * t inferred in each iteration to be L 2 . As we can see, after this initialization, S 0 obtains the firstlevel CF ciphertext (x * (0) t</p><formula xml:id="formula_28">-b * (0) t , E pk1 (b * (0) t</formula><p>)) of the initial truth of each object t, while S 1 obtains the corresponding second-level CF ciphertext b * (0) t . ii) Encrypted weight update: Given the ciphertexts of the truth of each object t, i.e., (x * t -b * t , E pk1 (b * t )) at S 0 side and b * t at S 1 side, the weight for each user i can then be updated in the encrypted domain. The detailed steps of doing encrypted weight update for each user i is given in Fig. <ref type="figure" target="#fig_9">6</ref>. At the final step, after running the EncDiv protocol, S 0 obtains the first-level CF ciphertext (w i -b i w , E pk1 (b i w )) of the weight w i , while S 1 holds the second-level CF ciphertext b i w . Note that this is slightly different from the original EncDiv protocol as S 0 does not combine (w i -b i w ) and E pk1 (b i w ) to produce E pk1 (w i ) (see <ref type="bibr">Step 7 and</ref> Step 8 in Fig. <ref type="figure" target="#fig_2">2</ref>).</p><p>iii) Encrypted truth update: Fig. <ref type="figure">7</ref> gives the detailed steps of doing encrypted truth update for each object t. At the end of execution, S 0 obtains the first-level CF ciphertext</p><formula xml:id="formula_29">(x * t -b * t , E pk1 (b * t ))</formula><p>of the truth x * t , while S 1 obtains the second-level CF ciphertext b * t . Note that similar to the way of generating the encrypted weight, S 0 does not combine</p><formula xml:id="formula_30">x * t -b * t and E pk1 (b * t ) to produce E pk1 (x * t ). The first-level CF ciphertext (x * t -b * t , E pk1 (b * t ))</formula><p>and the second-level CF ciphertext b * t will be used in the next iteration of encrypted weight update.</p><formula xml:id="formula_31">Input: S 0 has (x i t -b i t , E pk1 (b i t )) and (w i -b i w , E pk1 (b i w )); S 1 has b i t and b i w . Output: S 0 obtains (x * t -b * t , E pk1 (b * t )); S 1 obtains b * t . S 0 : 1. Compute E pk1 (w i x i t -b i t b i w ) for each i ∈ U t , based on the property of the CF technique. 2. E pk1 ( i∈Ut (w i x i t -b i t b i w )) = i∈Ut E pk1 (w i x i t -b i t b i w ). S 1 : 3. Compute i∈Ut b i t b i w . 4. Send E pk1 ( i∈Ut b i t b i w ) to S 0 . S 0 : 5. E pk1 ( i∈Ut w i x i t ) = E pk1 ( i∈Ut (w i x i t -b i t b i w )) • E pk1 ( i∈Ut b i t b i w ). 6. E pk1 (L • i∈Ut w i x i t ) = E pk1 ( i∈Ut w i x i t ) L 7. E pk1 ( i∈Ut w i ) = E pk1 ( i∈Ut (w i -b i w )) • E pk1 ( i∈Ut b i w ). S 0 , S 1 :</formula><p>8. S 0 runs the EncDiv protocol with the S 1 to obtain the encrypted new truth, i.e.,</p><formula xml:id="formula_32">S 0 : (x * t -b * t , E pk1 (b * t )), S 1 : b * t . // x * t = L 2 • x * t Fig. 7.</formula><p>Our improved construction: Encrypted truth update for each object t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Complexity Analysis</head><p>We now provide detailed complexity analysis to show that the communication complexity in each iteration due to encrypted multiplication is O(|U| + |T |). Firstly, in encrypted weight update, S 1 computes t∈Ti (b i t -b * t )<ref type="foot" target="#foot_1">2</ref> for each user i, and sends E pk1 ( t∈Ti (b i t -b * t ) 2 ) to S 0 (Step 4 and Step 5 in Fig. <ref type="figure" target="#fig_9">6</ref>). So, for each user i, the communication complexity is only O(1). Given |U| users, the communication complexity due to encrypted multiplication is O(|U|). In encrypted truth update, S 1 computes i∈Ut b i t b i w for each object t, and sends E pk1 ( i∈Ut b i t b i w ) to S 0 (Step 3 and Step 4 in Fig. <ref type="figure">7</ref>). So, for each object t, the communication complexity is only O <ref type="bibr" target="#b0">(1)</ref> We stress that the improvement in the communication complexity does not trade off the computation performance. In fact, changing the way of doing encrypted multiplication also leads to the improvement of the overall computation performance. This can be easily understood by taking a look at the homomorphic cryptosystem related workload of S 0 and S 1 in doing encrypted multiplication, which is shown in Table <ref type="table">I</ref>. Specifically, in the basic construction, to perform one encrypted multiplication, S 0 needs to perform 3 encryption operations and 7 homomorphic operations, and S 1 needs to In contrast, in our improved construction, S 0 needs to perform 1 encryption operation and 5 homomorphic operations, and S 1 only needs to perform 1 encryption operation. Note that such gain would be amplified as the amount of computation grows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Security Guarantees</head><p>Our above improved construction optimizes the communication complexity while preserving the expected security strengths. That is, like our basic construction, our improved construction also ensures that either of the two cloud servers learns nothing about the sensing values and weights of users, and the proprietary truths of the requester. Such security guarantees provided by our improved construction also follow trivially based on the modular sequential composition theorem.</p><p>We now analyze the workflow of our improved construction in detail to justify the security guarantees. Firstly, S 0 obtains the first-level CF ciphertexts of users' sensing values, while the second-level CF ciphertexts are held by S 1 . The security of the CF technique ensures that either of them learns nothing about the underlying sensing values <ref type="bibr" target="#b19">[20]</ref>. During the encrypted CATD procedure, S 0 mainly operates over the first-level CF ciphertexts. Additionally, S 0 has some interactions with S 1 , which is to receive encrypted aggregate values for encrypted multiplication (Step 5 in Fig. <ref type="figure" target="#fig_9">6</ref> and Step 4 in Fig. <ref type="figure">7</ref>) or to obtain encrypted division result by the EncDiv protocol ( Step 7 in Fig. <ref type="figure" target="#fig_9">6</ref> and Step 8 in Fig. <ref type="figure">7</ref>). In a nutshell, both S 0 and S 1 operate in the ciphertext domain and thus are oblivious to the private plaintext data underlying the protocol. Therefore, neither S 0 nor S 1 can obtain the sensing values and weights of users, as well as the proprietary truths of the requester.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. EXPERIMENTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Implementation</head><p>We conduct extensive experiments for performance evaluation. Note that when we mention our encrypted CATD design in the following, we mean our optimized construction. The implementation is in Java programming language. For cryptographic primitives, we use the Paillier library<ref type="foot" target="#foot_0">1</ref> for additively homomorphic encryption, and the ObliVM-lang 2 programming framework for garbled circuits. To test the designated operations, we deploy the requester side process and cloud server side processes on the Microsoft Azure using the standard D12 instance (with 4 cores, 28GB RAM, and the   Ubuntu Server 16.04 LTS system), and the user side process on a Samsung Galaxy S4 Android phone (with a four-core 1.6 GHz processor and a four-core 1.2 GHz processor and 2.0 GB RAM). We use a real dataset <ref type="bibr" target="#b3">[4]</ref> in our experiments, which is collected from a real mobile crowdsensing application called crowdsourced indoor floorplan reconstruction. The dataset contains sensing values that measure the distance information for any two specified indoor points (e.g., a hallway segment). In particular, it contains sensing values from 247 users on 129 objects, and the total number of sensing values is 740.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Performance Evaluation 1) Accuracy:</head><p>We first show that our encrypted CATD design does not compromise the accuracy in the plaintext domain. Recall that we need to use a scaling factor L to round real values whenever necessary so as to support cryptographic computation. This is the root cause leading to potential accuracy loss in our encrypted CATD design. Hence, we vary the value of L and evaluate the corresponding accuracy. Specifically, we use two metrics to measure the accuracy of the final inferred truths and also compare our design with the plaintext CATD algorithm <ref type="bibr" target="#b3">[4]</ref>. To demonstrate the effectiveness of both our constructions, we also provide the accuracy results for our basic construction. The first accuracy metric we use is mean of absolute error (MAE), which measures the mean of absolute distance from the inferred truths to the ground truths. The second one is the root of mean squared error (RMSE). Following the implementation 3 of the plaintext CATD algorithm <ref type="bibr" target="#b3">[4]</ref>, we set the number of iterations to 2 for accuracy evaluation. Note that the number of iterations needed is actually data-dependent, and is also determined by the accuracy requirement of different applications. This is indeed orthogonal to our security design in this work. For truth 3 https://www.cse.buffalo.edu/∼jing/doc/CATD.zip initialization, we use the mean of sensing values associated with each object.</p><p>The accuracy evaluation results are shown in Fig. <ref type="figure" target="#fig_11">8</ref> (for MAE) and Fig. <ref type="figure">9</ref> (for RMSE). It can be observed that when L is quite small, say 10, the MAE and RMSE results of both our secure constructions do not match that of the plaintext CATD algorithm. However, when L reaches 10 2 or even higher, both our secure constructions achieve almost the same MAE and RMSE results as in the plaintext CATD algorithm. Thus, as long as the value of L is large enough, the accuracy of our encrypted CATD design can be guaranteed. In the following experiments, unless otherwise specified, the rounding factor is set to to 10 4 . Additionally, it is revealed that the accuracy results of our basic construction is the same as in our optimized construction. The reason here is as follows. For both our constructions, the accuracy results are actually decided by the use of the scaling factor (which has also already been reflected by the above experiment results). Compared to the basic construction, our optimized construction applies the scaling in the same way (which can be reflected by the scaling details shown in Fig. <ref type="figure" target="#fig_5">4</ref>, Fig. <ref type="figure" target="#fig_6">5</ref>, Fig. <ref type="figure" target="#fig_9">6</ref>, and Fig. <ref type="figure">7</ref>), and nontrivially optimizes the way of doing secure multiplication from homomorphic encryption. Therefore, our two constructions have the same accuracy performance.</p><p>2) Convergence: We now evaluate the convergence performance of our encrypted CATD design. In Fig. <ref type="figure" target="#fig_12">10</ref> and Fig. <ref type="figure" target="#fig_0">11</ref>, we respectively show the evolution of the MAE result and of the RMSE result, with regard to the number of iterations. The results reveal that the convergence of our security design is guaranteed and matches that in the plaintext domain. Particularly, we are able to achieve the convergence within up to ten iterations. We note that this result also has the same order of magnitude as in existing works on privacyaware truth discovery <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b8">[9]</ref>.</p><p>3) Energy Performance: As battery energy is one of the most precious resources of mobile devices <ref type="bibr" target="#b46">[48]</ref>, we first conduct an energy test on the user side to measure the energy performance. In particular, we measure the amount of energy consumed on the user side due to our designated computation, through the use of Power Tutor 2 Pro <ref type="bibr" target="#b47">[49]</ref>, which is a diagnostic tool capable of analyzing the power usage of mobile applications. Recall that in our design the user only needs to encrypt the sensing values of objects sensed by him. So, we measure the amount of energy consumed by the encryption of the sensing values. The result is shown in Fig. <ref type="figure" target="#fig_14">12</ref>. It can be observed that the energy consumed by the encryption of sensing values is positively correlated with the number |T i | of objects sensed by each user i. Particularly, when |T i | varies from 20 to 129, the corresponding energy cost grows from 37 mJ to 541 mJ.</p><p>Considering that the above energy figures may not be that easy to be understood, we now give an intuitive example to facilitate the understanding. In particular, we measure the amount of energy taken to play a 10-minute audio, which turns out to be about 10 J. Note that in our encrypted CATD design, even when the number of objects sensed by a user is large (i.e., 129), the energy overhead of our designated computation on the user side is just 0.541 J. Therefore, our encrypted CATD    design achieves practically affordable energy performance on mobile devices.</p><p>4) Computation Performance: Firstly, we report the computation cost at the user side. Recall that in our system the user needs to encrypt his sensing values to produce the ciphertexts</p><formula xml:id="formula_33">(x i t -b i t , E pk1 (b i t )).</formula><p>Obviously, the computation cost at the user side linearly scales with the number of objects sensed by him. Fig. <ref type="figure" target="#fig_15">13</ref> shows the computation cost at the user side, with regard to the number of sensed objects. It can be observed that when the number of objects ranges from 20 to 129, the computation cost at the user side increases from 0.261 s to 1.685 s, which is practically efficient. Regarding the requester, he only needs to decrypt the encrypted truths of objects. When the number of objects ranges from 20 to 129, the computation cost at the requester side ranges from 0.414 s to 2.68 s.</p><p>Finally, we report the cloud-side computation cost. In particular, we measure the computation cost in the encrypted weight update phase and encrypted truth phase, respectively. Fig. <ref type="figure" target="#fig_5">14</ref> shows the computation cost of the cloud servers S 0 and S 1 for each user in the encrypted weight update phase, with regard to the number of objects that are sensed by that user. It is shown that the computation cost of S 0 increases as the number of objects sensed by a user grows. When the number of objects ranges from 20 to 129, the computation cost of S 0 is from 0.332s to 1.453 s. Regarding S 1 , the computation cost is relatively low and stays around 0.15 s. This is mainly because to update the encrypted weight for each user, S 1 just deals with fast arithmetic operations over random values, a fixed number of homomorphic encryptions, and the generation of a garbled circuit. In Fig. <ref type="figure" target="#fig_6">15</ref>, we further show the computation cost of S 0 and S 1 for each object in the encrypted truth update phase, with regard to the number of users sensing that object. It is revealed that to update the encrypted truth for each object, the computation cost of S 0 grows with the number |U t | of the users sensing that object. When |U t | ranges from 40 to 247, the computation cost of S 0 is from 0.561 s to 2.688 s. The computation cost of S 1 is still much lower and stays around 0.171 s.</p><p>5) Bandwidth Performance: We first report the bandwidth consumption at the user side. Recall that in our design each user i only needs to send the encrypted sensing values {(x i t -b i t , E pk1 (b i t ))} t∈Ti to S 0 , and then can just stay offline. The size of the element (x i t -b i t ) is a half of the size of a Paillier ciphertext. So, for each user i, the size of the encrypted sensing values is 1.5z|T i |, where z is the size of a Paillier ciphertext and equal to 256 bytes in our test. When |T i | increases from 1 to 129, the bandwidth cost ranges from 0.375 KB to 48.375 KB, which is quite small. Secondly, for the requester, he does not need to participate in encrypted CATD procedure and only receives the encrypted truths which are Paillier ciphertexts. So, the bandwidth of the requester depends on the number of objects released by him and is z|T | bytes. When |T | ranges from 1 to 129, the bandwidth cost ranges from 0.25 KB to 32.25 KB. Finally, for the evaluated dataset, the overall bandwidth consumed among the cloud servers in each iteration is about 21.8622 MB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. RELATED WORK</head><p>In a broad sense, our work is under the umbrella of research on privacy-preserving data aggregation. Roughly speaking, this line of work shares the common goal of learning an aggregation result from the data collected from a set of users without revealing individual users' data. So far, a large body of work on privacy-preserving data aggregation (e.g., <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b48">[50]</ref>- <ref type="bibr" target="#b52">[54]</ref>, to just list a few) has been proposed in the literature. These works usually rely on (traditional or ad-hoc) homomorphic cryptosystem and/or data perturbation for privacy protection of user data. Homomorphic cryptosystem based approaches ensures private learning of accurate aggregation results <ref type="bibr" target="#b49">[51]</ref>, while approaches involving data perturbation inherently incurs a trade-off between privacy and utility <ref type="bibr" target="#b48">[50]</ref>. Although very useful, most of existing works focus on aggregation mechanisms (e.g., sum <ref type="bibr" target="#b48">[50]</ref>- <ref type="bibr" target="#b50">[52]</ref>, min <ref type="bibr" target="#b49">[51]</ref>, <ref type="bibr" target="#b51">[53]</ref>) that treat users equally without considering the reliability degrees of users.</p><p>In recent years, some works have began to study privacypreserving truthful aggregation via truth discovery in mobile crowdsensing. In <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr">Miao et al.</ref> propose the first privacypreserving truth discovery framework called PPTD for mobile crowdsensing. PPTD relies on the threshold homomorphic cryptosystem to protect the confidentiality of users' sensing values and weights, which requires a number of users to assist the decryption of any intermediate aggregate values for the cloud server whenever necessary. Hence, it brings considerable computation and communication overhead for users. Later, Xu et al. <ref type="bibr" target="#b7">[8]</ref> propose a design that achieves better performance than PPTD. However, their design requires users to share a secret key, which makes the system brittle in the presence of user compromise. Very recently, Miao et al. <ref type="bibr" target="#b8">[9]</ref> and Zheng et al. <ref type="bibr" target="#b9">[10]</ref> propose new protocols for efficient and privacy-preserving truth discovery, where the two-server model is leveraged. All these works are not tailored for general and realistic mobile crowdsensing scenarios where user participation level varies. Hence, they may not necessarily achieve high accuracy in truth estimation <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b11">[12]</ref>. Meanwhile, they fail to provide requester protection and also undesirably require all mobile users to stay online for participation in the truth discovery procedure. There still lacks a security design that can better fit realistic crowdsensing applications with stronger security properties and support for practical deployment.</p><p>Different from prior works on privacy-aware truth discovery, we build our completely new design on the promising CATD approach in <ref type="bibr" target="#b3">[4]</ref> for its state-of-the-art accuracy performance in the general and realistic crowdsensing scenarios with various levels of participation <ref type="bibr" target="#b11">[12]</ref>. In addition to this fundamental difference, our design has other appealing benefits that prior works do not have. Firstly, our design respects the interests of the requester by producing the estimated truth in the encrypted domain and keeping it private for the requester. Secondly, our design does not requires users to stay online to participate in the truth discovery procedure, and this also makes our design fit much better into the practicality realm. Note that to achieve protection of both the sensing values and weights of users, the latest privacy-aware truth discover designs under the two-server model <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref> still require users to stay online to participate in the whole procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. DISCUSSIONS</head><p>In our security design we focus on the general case of continuous sensory data in realistic mobile crowdsensing applications. However, our security design is actually flexible enough to embrace other data types like categorical data. As indicated by existing works <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b6">[7]</ref>, for crowdsensing applications where the data are categorical, there are usually multiple candidate choices and only one of them is correct. In this case, the sensory data x i by user i on an object can be represented as a vector, i.e., x i = (0, • • • , 1 l , • • • , 0) T , which means that the l-th choice is selected by user i. To handle categorical data, we can perform truth discovery over each element of the sensory data vector for the object, and the estimated ground truth x * is a vector of probability values <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b6">[7]</ref>. The final truth result should be the choice that has the largest probability in vector x * . With this philosophy, supporting categorical data just requires the following slight modifications to our security design. Firstly, the difference term in Eq. 1 (i.e., the denominator) for weight update is replaced by the square of L 2 -norm to indicate the difference between the sensory data vectors and the initial truth vectors <ref type="bibr" target="#b3">[4]</ref>. Securely calculating this difference term can be readily supported in the encrypted weight update phase as it just requires encrypted addition and multiplication. Secondly, encrypted truth update is conducted over each element of categorical sensory data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION</head><p>We presented a completely new system architecture enabling encrypted CATD in mobile crowdsensing to securely extract truthful information from unreliable sensory data. We first gave a basic construction for encrypted CATD as a starting point, which uniquely bridges relatively lightweight additively homomorphic encryption and garbled circuits. The basic construction ensures that the sensing values and weights of users, as well as the inferred truths of the requester, are kept private along the workflow. We then further presented an improved construction which optimizes the communication complexity between the two cloud servers while preserving the same security guarantees. We conducted extensive experiments for performance evaluation, and the results validated the practical efficiency of our design for mobile devices.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>S 1 Fig. 1 .</head><label>11</label><figDesc>Fig. 1. The illustration of our system architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Send a and b to S 1 . S 1 : 3. u a = D sk1 (a ) and u b = D sk1 (b ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Building block: Encrypted division protocol.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4 . 1 : 5 .</head><label>415</label><figDesc>Send a and b to S 1 . S u a = D sk1 (a ) and u b = D sk1 (b ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig.3. Building block: Encrypted multiplication protocol<ref type="bibr" target="#b22">[23]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Our basic construction: Encrypted weight update for each user i.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Our basic construction: Encrypted truth update for each object t.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>i=1</head><label></label><figDesc>|T i | times to compute the first term for all the participating users. For the second term, the number of users providing the sensing values for each object is |U t |. Given |T | objects, the EncMul protocol should be called |T | t=1 |U t | to compute the second term for all the objects. Therefore, the communication complexity due to the calling of the EncMul protocol would be O( |U | i=1 |T i |), or O( |T | t=1 |U t |). That is, the communication complexity depends on the total number of sensing values collected from all the users. This may not scale well when the total number of sensing values is very large and we will show in the next section how to reduce this communication complexity to O(|U| + |T |).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>while the server holding the second-level CF ciphertext computes b 1 • b 2 . After getting back E pku (m 1 m 2 -b 1 b 2 ) and b 1 b 2 from the two servers respectively, the client can first decrypt E pku (m 1 m 2 -b 1 b 2 ) to obtain m 1 m 2 -b 1 b 2 , and then recover</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Our improved construction: Encrypted weight update for each user i.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>. Given |T | objects, the communication complexity due to encrypted multiplication is O(|T |). As a result, the communication complexity in each iteration due to encrypted multiplication is now O(|U| + |T |). It should be noted that the communication complexity due to other interactions (i.e., encrypted division) remains the same as in the basic construction, i.e., O(|U| + |T |). Therefore, our improved construction actually achieves an overall O(|U| + |T |) communication complexity in each iteration of encrypted CATD.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Accuracy: MAE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 9. Accuracy: RMSE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Convergence (with RMSE).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. User energy overhead due to our designated computation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. User computation cost.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Cloud server S 1 Fig. 14 .</head><label>114</label><figDesc>Fig. 14. Cloud computation cost per encrypted weight update.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>1 Fig. 15 .</head><label>115</label><figDesc>Fig. 15. Cloud computation cost per encrypted truth update.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Paillier Library:http://www.csee.umbc.edu/ kunliu1/research/Paillier.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>ObliVm-lang: http://oblivm.com/index.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Illinois Institute of Technology, USA, M.E. degree in Communication and Information System, and B.E. in Electronic Information Engineering, both from Wuhan University, China. His current research interests include data and computation outsourcing security in the context of cloud computing, network security in emerging Internet architecture, multimedia security and its applications, and privacy-enhancing technologies in the context of big data and IoT. He received the President's Awards from City University of Hong Kong in 2016. He is a co-recipient of the Best Student Paper Award of IEEE ICDCS 2017, the Best Paper Award of IEEE MSN 2015 and CHINACOM 2009. His research has been supported by multiple government research fund agencies, including National Natural Science Foundation of China, Hong Kong Research Grants Council, and Hong Kong Innovation and Technology Commission. He has been serving as the TPC co-chairs for a number of IEEE conferences/workshops. He is a senior member of the IEEE and is a member of the ACM.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work was supported in part by the Research Grants Council of Hong Kong under Grant CityU 11276816, Grant CityU 11212717, and Grant CityU C1008-16G, in part by the Innovation and Technology Commission of Hong Kong under ITF Project ITS/168/17, in part by the National Natural Science Foundation of China under Grant 61572412, and in part by a Microsoft Azure grant for research.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mobile crowdsensing: current state and future challenges</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Ganti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Magazine</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="32" to="39" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mobile crowd sensing and computing: The review of an emerging human-powered sensing paradigm</title>
		<author>
			<persName><forename type="first">B</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">Y</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A survey on truth discovery</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGKDD Explorations</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A confidence-aware approach for truth discovery on long-tail data</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Demirbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="425" to="436" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Conflicts to harmony: A framework for resolving conflicts in heterogeneous data by truth discovery</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1986" to="1999" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Toward encrypted cloud media center with secure deduplication</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Gui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Multimedia</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="251" to="265" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Cloud-enabled privacy-preserving truth discovery in crowd sensing systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SenSys</title>
		<meeting>of ACM SenSys</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Achieving efficient and privacy-preserving truth discovery in crowd sensing systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Security</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="page" from="114" to="126" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A lightweight privacypreserving truth discovery framework for mobile crowd sensing systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of INFOCOM</title>
		<meeting>of INFOCOM</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Privacy-aware and efficient mobile crowdsensing with truth discovery</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Dependable and Secure Computing</title>
		<imprint>
			<biblScope unit="issue">99</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">effsense: energy-efficient and costeffective data uploading in mobile crowdsensing</title>
		<author>
			<persName><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Xiong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of UbiComp-Adjunct Publication</title>
		<meeting>of UbiComp-Adjunct Publication</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Truth inference in crowdsourcing: Is the problem solved?</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="541" to="552" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Privacy-preserving matrix factorization</title>
		<author>
			<persName><forename type="first">V</forename><surname>Nikolaenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Weinsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Taft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CCS</title>
		<meeting>of ACM CCS</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Sechog: Privacypreserving outsourcing computation of histogram of oriented gradients in the cloud</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Zou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM AsiaCCS</title>
		<meeting>of ACM AsiaCCS</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Secureml: A system for scalable privacypreserving machine learning</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mohassel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE S&amp;P</title>
		<meeting>of IEEE S&amp;P</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Privacy-preserving ridge regression on hundreds of millions of records</title>
		<author>
			<persName><forename type="first">V</forename><surname>Nikolaenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Weinsberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Taft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE S&amp;P</title>
		<meeting>of IEEE S&amp;P</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Enabling secure and effective near-duplicate detection over encrypted in-network storage</title>
		<author>
			<persName><forename type="first">H</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of INFOCOM</title>
		<meeting>of INFOCOM</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Privacypreserving remote diagnostics</title>
		<author>
			<persName><forename type="first">J</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CCS</title>
		<meeting>of ACM CCS</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Privacypreserving ECG classification with branching programs and neural networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Failla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lazzeretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="452" to="468" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using linearly-homomorphic encryption to evaluate degree-2 functions on encrypted data</title>
		<author>
			<persName><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CCS</title>
		<meeting>of ACM CCS</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1518" to="1529" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Rise of the indoor crowd: Reconstruction of building interior view via mobile crowdsourcing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Qiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SENSYS</title>
		<meeting>of ACM SENSYS</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="59" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficiently outsourcing multiparty computation under multiple keys</title>
		<author>
			<persName><forename type="first">A</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tews</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katzenbeisser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2046" to="2058" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Generating private recommendations efficiently using homomorphic encryption and data packing</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Erkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Veugen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Toft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Lagendijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1053" to="1066" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Privacy-preserving image denoising from external cloud databases</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1285" to="1298" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Server-aided secure computation with off-line parties</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baldimtsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Scafuro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Triandopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ESORICS</title>
		<meeting>of ESORICS</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Faster secure two-party computation in the single-execution setting</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Malozemoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<editor>Proc. ofEUROCRYPT, J. Coron and J. B. Nielsen</editor>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="399" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Efficiently verifiable computation on encrypted data</title>
		<author>
			<persName><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pastro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CCS</title>
		<meeting>of ACM CCS</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Privacy-aware and trustworthy data aggregation in mobile sensing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE CNS</title>
		<meeting>of IEEE CNS</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Prio: Private, robust, and scalable computation of aggregate statistics</title>
		<author>
			<persName><forename type="first">H</forename><surname>Corrigan-Gibbs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of USENIX NSDI</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Howell</surname></persName>
		</editor>
		<meeting>of USENIX NSDI</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Participant privacy in mobile crowd sensing task management: A survey of methods and challenges</title>
		<author>
			<persName><forename type="first">L</forename><surname>Pournajaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Garcia-Ulloa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Sunderam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="23" to="34" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">How to generate and exchange secrets</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE FOCS</title>
		<meeting>of IEEE FOCS</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A proof of security of yao&apos;s protocol for twoparty computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="161" to="188" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A randomized protocol for signing contracts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="637" to="647" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Encrypted signal processing for privacy protection: Conveying the utility of homomorphic encryption and multiparty computation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Lagendijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Erkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Barni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Processing Magazine</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="82" to="105" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A survey of homomorphic encryption for nonspecialists</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fontaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Galand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP Journal on Information Security</title>
		<imprint>
			<biblScope unit="volume">2007</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Oblivious neural network predictions via minionn transformations</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Juuti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Asokan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM CCS</title>
		<editor>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>Thuraisingham</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Evans</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</editor>
		<meeting>of ACM CCS</meeting>
		<imprint>
			<date type="published" when="2015">2015. 2017</date>
		</imprint>
	</monogr>
	<note>Proc. of NDSS</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Harnessing the cloud for securely outsourcing large-scale systems of linear equations</title>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1172" to="1181" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Blindbox: Deep packet inspection over encrypted traffic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCOMM</title>
		<meeting>of ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">From dust to dawn: Practically efficient two-party secure function evaluation protocols and their modular design</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite degree residuosity classes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EUROCRYPT</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</editor>
		<meeting>of EUROCRYPT</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Encrypted integer division and secure comparison</title>
		<author>
			<persName><forename type="first">T</forename><surname>Veugen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Applied Cryptography</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="166" to="180" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Pretzel: Email encryption and provider-supplied functions are compatible</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Fingler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGCOMM</title>
		<meeting>of ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Oblivm: A programming framework for secure computation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE S&amp;P</title>
		<meeting>of IEEE S&amp;P</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Division between encrypted integers by means of garbled circuits</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lazzeretti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Barni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE International Workshop on Information Forensics and Security (WIFS)</title>
		<meeting>of IEEE International Workshop on Information Forensics and Security (WIFS)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">ObliVM-GC</title>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Wang</surname></persName>
		</author>
		<ptr target="https://github.com/oblivm/ObliVMGC" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Security and composition of multiparty cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="202" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Fine-grained data sharing in cloud computing for mobile devices</title>
		<author>
			<persName><forename type="first">J</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM</title>
		<meeting>of IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Self-constructive high-rate system energy modeling for battery-powered mobile systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM MobiSys</title>
		<meeting>of ACM MobiSys</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Privacypreserving aggregation of time-series data</title>
		<author>
			<persName><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Rieffel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of NDSS</title>
		<meeting>of NDSS</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Efficient and privacy-aware data aggregation in mobile sensing</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F L</forename><surname>Porta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Dependable and Secure Computing</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="115" to="129" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Efficient private statistics with succinct sketches</title>
		<author>
			<persName><forename type="first">L</forename><surname>Melis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Cristofaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of NDSS</title>
		<meeting>of NDSS</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Efficient and privacy-preserving min and kth min computations in mobile sensing systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Dependable and Secure Computing</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="21" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">His research interests include cloud security, mobile computing security, encrypted computation, and multimedia security. Huayi Duan received the B.S. degree with First Class Honors from City University of Hong Kong</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Erkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Troncoso-Pastoriza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Lagendijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pérez-González</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal Processing Magazine</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="75" to="86" />
			<date type="published" when="2013-09">2013. 2013. September to December 2013. 2015</date>
			<pubPlace>Guangzhou, China; Hangzhou, China; Hong Kong</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, City University of Hong Kong, Hong Kong ; Zhejiang University ; Department of Computer Science, City University of Hong Kong</orgName>
		</respStmt>
	</monogr>
	<note>Yifeng Zheng received the B.E. degree in information engineering from South China University of Technology. He is currently working toward the Ph.D. degree in the. Hong Kong. His research interests include network security and cloud security</note>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m">Cong Wang is currently an Associate Professor in the Department of Computer Science, City University of Hong Kong. He received his Ph.D. degree in the Electrical and Computer Engineering from</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
