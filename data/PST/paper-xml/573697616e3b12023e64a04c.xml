<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">To Block or not to Block, That is the Question: Students&apos; Perceptions of Blocks-based Programming</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">David</forename><surname>Weintrop</surname></persName>
							<email>dweintrop@u.northwestern.edu</email>
						</author>
						<author>
							<persName><forename type="first">Uri</forename><surname>Wilensky</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Northwestern University</orgName>
								<address>
									<addrLine>2120 Campus Drive, Suite 332 Evanston</addrLine>
									<postCode>60628</postCode>
									<region>Illinois</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Northwestern University</orgName>
								<address>
									<addrLine>2120 Campus Drive, Suite 337 Evanston</addrLine>
									<postCode>60628</postCode>
									<region>Illinois</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<postCode>2015</postCode>
									<settlement>Papers, Medford</settlement>
									<region>ID, MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">To Block or not to Block, That is the Question: Students&apos; Perceptions of Blocks-based Programming</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">992A671ED59E745A06B79579182FD240</idno>
					<idno type="DOI">10.1145/2771839.2771860</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>D.1.7 [Visual Programming]. K.3.2 [Computer and Information Science Education]: Computer science education Design, Human Factors, Languages Blocks-based Programming</term>
					<term>High School Computer Science Education</term>
					<term>Perceptions of Programming</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Blocks-based programming tools are becoming increasingly common in high-school introductory computer science classes. Such contexts are quite different than the younger audience and informal settings where these tools are more often used. This paper reports findings from a study looking at how high school students view blocks-based programming tools, what they identify as contributing to the perceived ease-of-use of such tools, and what they see as the most salient differences between blocksbased and text-based programming. Students report that numerous factors contribute to making blocks-based programming easy, including the natural language description of blocks, the drag-anddrop composition interaction, and the ease of browsing the language. Students also identify drawbacks to blocks-based programming compared to the conventional text-based approach, including a perceived lack of authenticity and being less powerful. These findings, along with the identified differences between blocks-based and text-based programming, contribute to our understanding of the suitability of using such tools in formal high school settings and can be used to inform the design of new, and revision of existing, introductory programming tools.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Computation is changing our world. Competencies and skills grounded in the ability to effectively use computational tools, and design and implement solutions that rely on computation, often collected under umbrella terms like "Computational Thinking," or "21 st Century Skills," are now the focus of many new K-12 initiatives. This has resulted in new curricula and learning environments for introducing students to the field of computer science. Increasingly, these courses are turning to blocks-based visual programming tools to serve as students' first introductions to the practice of programming. Notably, the Exploring Computer Science Curriculum <ref type="bibr" target="#b13">[13]</ref>, the CS Principles course <ref type="bibr" target="#b1">[1]</ref>, and the materials produced by code.org for classrooms, all rely on the use of blocks-based programming. This trend is in part due to the general perception that blocks-based programming is easier for novice programmers. Despite the rise in prominence of blocksbased programming in formal settings, open questions remain as the strengths and drawbacks of this programming modality in classroom settings. Notably, little work has been done examining how learners perceive blocks-based programming interfaces and what they see as the utility of the approach relative to the more conventional text-based alternatives. Additionally, much of the work done on evaluating block-based programming has focused on younger learners and informal settings, contexts quite distinct from the high school classrooms where blocks-based programming is increasingly being used. This paper seeks to address these gaps in the literature by answering the following three research questions:</p><p>• Do high school students think blocks-based programming is easier than text-based programming and if so why?</p><p>• What do high school students perceive as the differences between blocks-based and text-based programming?</p><p>• What potential drawbacks to block-based programming do high school students identify?</p><p>We begin the paper with an introduction to blocks-based programming, trying to capture the current state and popularity of the programming approach. We then present our study design, a ten-week intervention in three sections of an introductory high school computer science course that followed students as they spend five weeks working in blocks-based tools then transitioned to a text-based programming language. Next, we present our findings, which include student identified strengths and weaknesses of blocks-based programming and reports on what they see as the major differences between blocks-based and textbase programming. Finally, we discuss the implications of these findings with respect to the design of introductory tools and the use of blocks-based programming in formal classroom settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BLOCKS-BASED PROGRAMMING</head><p>Blocks-based programming environments are a variety of visual programming languages that leverage a primitives-as-puzzlepieces metaphor (Figure <ref type="figure" target="#fig_0">1</ref>). In such environments, learners can assemble functioning programs using only a mouse by snapping together instructions and receiving visual (and sometime audio) feedback informing the user if a given construction is valid. Each block provides visual cues to the user on how and where the block can be used through the block's shape, its color (which is associated with categories of similar blocks), and the use of natural language label on the block to communicate its function.</p><p>Along with the visual information depicted by each block, the construction space in which the blocks are used also provides various forms of scaffoldings including the grouping of similar blocks together, making it possible to easily browse the available set of blocks by category, and often providing a visual execution space in which the authored programs are enacted. Blocks-based programming is a relatively recent addition to the long line of programming languages and environments designed explicitly with learners in mind (for reviews of this work, see: <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b22">22]</ref>). The earliest language designed explicitly for children, and a direct influence for blocks-based programming tools is the Logo programming language <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b28">28]</ref>. The Logo language introduced a number of characteristics that feature prominently in blocks-based programming environments, notably, the use of egocentric motion commands like forward and turn right, the presence of onscreen avatars to carryout those commands (Logo had the turtle, while newer environments have sprites), and language primitives and syntax designed to be accessible to novices. Beyond features of the programming interface, the types of activities supported by blocks-based tools draw from the constructionist tradition that emphasizes learner-directed construction and exploration and the importance of learners creating public, sharable artifacts, often in the form of artwork, games, and interactive stories <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b28">28]</ref>.</p><p>In recent years, there has been a proliferation of programming environments that utilize a blocks-based approach. Well known block-based programming environments such as Scratch <ref type="bibr" target="#b29">[29]</ref> and Alice <ref type="bibr" target="#b5">[5]</ref> provide learners with open-ended, exploratory spaces designed to support creative activities like story telling and game making. With the rise in popularity of these and other similar tools, the number of activities a learner can engage with through blocks-based programming is growing increasingly diverse. For example, you can develop mobile applications with MIT App Inventor and Pocket Code <ref type="bibr" target="#b32">[32]</ref>, build and interact with computational models with DeltaTick <ref type="bibr" target="#b36">[36]</ref>, NetTango <ref type="bibr" target="#b19">[19]</ref>, Frog Pond <ref type="bibr" target="#b18">[18]</ref> or StarLogo TNG <ref type="bibr" target="#b2">[2]</ref>, create artistic masterpieces with Turtle Art <ref type="bibr" target="#b3">[3]</ref> or PicoBlocks, and play video games like RoboBuilder <ref type="bibr" target="#b34">[34]</ref> and CodeSpells <ref type="bibr" target="#b9">[9]</ref>. Similarly, informal computer science education initiatives are increasingly relying on blocks-based programming, including the activities provided as part of Code.org's Hour of Code and Google's Made with Code initiative. The rise of blocks-based tools is especially prominent in the design of programming tools for younger learners. A recent review of coding environments for children included 19 drag-anddrop tools among the 24 environments reviewed for learners under the age of eight, and 28 drag-and-drop environments out of the 47 total reviewed environments <ref type="bibr" target="#b8">[8]</ref>. Further, we expect this trend to continue as a growing number of libraries are making it easy to develop environments that incorporate a blocks-based programming interface <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b30">30]</ref>. With the growth of these environments, it is crucial to understand where they came from, if and why they work, and identify how learners perceive and interact with such tools and learn with such tools.</p><p>The blocks-based programming approach weaves together two historically distinct strands of research on ways to scaffold novice programmers. The first is the use of direct manipulation interfaces that present users with on-screen icons that depict the concepts or objects that the users will use to accomplish the desired goal.</p><p>Programming in these environments takes the form of connecting the appropriate icons on screen. This approach has become popular for designing robotics kits such as Lego Mindstorms NXT-G <ref type="bibr" target="#b23">[23]</ref> and the MiniBloq programming environment for the Arduino family of microcontrollers <ref type="bibr" target="#b31">[31]</ref>. The second influence on blocks-based programming arose from the rise of structured editors <ref type="bibr">[7]</ref>, which are software authoring environments that use information about a programming language's underlying grammar to provide scaffolds to the users such as code-complete suggestions, syntax highlighting and real-time complication checking <ref type="bibr" target="#b27">[27]</ref>. Similar to structured editors, blocks-based programming environments use the grammar of the language to support the act of programming by encoding the grammar of the language into the individual blocks through the name, shape and color ascribed to each block. The environments then allow the user to interact with these grammar elements (the blocks) directly though a drag-and-drop interface. In this way blocks-based tools provide the transparency and ease-of-use of direct manipulation interfaces with the scaffolds enabled by structured editors to create an introductory programming environment that is inviting and easy to use that also faithfully embodies the practice of programming and introduces learners to central ideas of programming.</p><p>Some have conceptualized blocks-based programming as serving as an introduction to programming that can lay the foundation for an eventual transition to text-based programming, but this remains an open empirical question that is only starting to be answered. A first step towards understanding if and how blocks-based programming prepares learners for future text-based programming is to identify what features of blocks-based programming learners find salient and how they perceive them relative to more conventional text-based programming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">METHODS AND PARTICIPANTS</head><p>The data presented in this paper are part of a larger study comparing blocks-based, text-based, and hybrid blocks/text programming environments at a selective enrollment public high school in a Midwestern city. We followed students in three sections of an elective introductory programming course for the first 10 weeks of the school year. Each class spent the first five weeks of the course working in a form of blocks-based programming environment. The students then transitioned to Java, a text-based programming language, for the next five weeks of the study and then continued with Java for the duration of the year. Two teachers participated in this study (one teacher taught two of the classes), both of whom have over five years of teaching high school computer science and have previously taught the course. Both teachers run a workshop-style class, doing little lecturing, instead having students spend class time working on assignments and asking for help when it is needed.</p><p>The three classes participating in our study used different modified versions of the Snap! programming environment during the first phase of the study <ref type="bibr" target="#b16">[16]</ref>. The Snap! environment closely mirrors Scratch, but adds a few additional features (like first order functions) and was created with the goal of creating a "no ceiling" blocks-based programming environment <ref type="bibr" target="#b16">[16]</ref>. The first class used a version of Snap! that added the ability to right-click on any block or script and open up a window showing a JavaScript implementation of what was clicked on (Figure <ref type="figure">2</ref>). This served as a hybrid, blocks/text read only environment, as students were able to read, but not edit or write, text-based versions of the programs they constructed with the blocks. The second class used a version of Snap! that allowed students to read their programs, like the read-only condition, but also added the ability to define the behavior of new blocks in JavaScript. This served as a hybrid blocks/text read/write environment, as students could both read a text-based version of their own blocks, as well as define the behaviors of new blocks in JavaScript. The usual workflow for defining new blocks was for students to author the behavior with blocks, view the JavaScript equivalent, and then copy/paste the text into their new block. In this way, students in the read-write condition were usually not writing JavaScript from scratch, but instead doing more tinkering and tweaking of the textually defined behaviors. It is important to note in this condition, students were only writing small snippets of code (usually four lines or less) to define custom block behaviors and then integrating the text-defined custom blocks into larger scripts. Thus, this condition is quite different than a full text-based programming environment as block-based composition was still the predominant form of authoring, but is also distinct from fully blocks-based programming given the need to write some textbased code. Students in the third class used a version of Snap! that had no text-based features, so they never saw any text-based versions of their programs during class time. These three classes served as our three conditions for the study, which we abbreviate as: read-only, read-write, and graphical. All three classes followed the same curriculum based on UC Berkeley's Beauty and Joy of Computing course that covers topics including control structures, variables, and defining new functions. We chose this curriculum because it include the creation of new blocks early, so students in the read-write condition would get early exposure to authoring blocks in JavaScript.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2. Side-by-side blocks and text in our version of Snap!</head><p>At the conclusion of the 5-week blocks-based introduction, the students transition to Java, following an objects-first curriculum designed around the Java Concepts: Early Objects textbook <ref type="bibr" target="#b20">[20]</ref>.</p><p>During the Java portion of the study, the topics covered in class included how to compile and run Java programs, simple data input and output, and the basics of defining and calling functions. It is worth noting this is a much more limited set of programming concepts than were covered in the 5-week Snap! curriculum.</p><p>A variety of data were collected as part of the study and used in the analysis presented below. Attitudinal surveys and content assessments were administered three times during the 10-weeks study: at the outset of the study (beginning of week 1), at the midpoint of the study after students had completed working with the blocks-based environments but before they had started with Java (end of week 5), and at the conclusion of the study after using Java for five week (end of week 10). All three surveys were administered online during class time. Additionally, a total of 27 semi-structured clinical interviews were conducted with students: nine during the first week of the study, ten at the midpoint (during weeks 5 and 6), and eight in the final week. The interviews took place in empty classrooms outside of class time, usually either during the student's lunch period or after school. For the interviews, the researcher sat alongside the student as they both faced a computer that had the Snap! programming environment on screen (Figure <ref type="figure" target="#fig_1">3</ref>). Each interview was recorded using software that captures both the user sitting at the computer and what is being shown on screen. We will discuss details of the interview protocols later as part of our analysis. The school we worked with was chosen as it offers three sections of their Programming I course allowing us to carry out our threecondition study design with students from the same student population. A total of 90 students across three sections of the course participated in the study, which included 67 male students and 23 female students. The students participating in the study were 43% Hispanic, 29% White, 10% Asian, 6% African American, and 10% Multi-racial -a breakdown comparable to the larger student body. The classes included one student in eighth grade, three high school freshman, 43 sophomores, 18 juniors, and 25 high school seniors. Two-thirds of the students in these classes speak a language other than English in their homes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">FINDINGS 4.1 Is Blocks-based Programming Easier?</head><p>Our first research question asks if students think blocks-based programming is easier than text-based programming, and if so why. To answer this question, we will use data from the survey administered at the conclusion of our study, after students had spent five weeks working in Snap! and then another five weeks learning Java. On the survey we asked students to compare the two environments, specifically asking what they saw as the major difference between the two tools. We then analyzed each response, identifying which answers attended to ease-of-use as</p><p>Full Papers ID 2015 Medford, MA, USA contributing to the difference between Snap! and Java. Of the 84 responses collected, more than half of students (58%) included ease-of-use as a major difference between the graphical and textbased environments. Table <ref type="table" target="#tab_0">1</ref> shows the outcome of the coding of the responses for ease-of-use. The subscript numbers in the table show the breakdown by the three Snap! conditions.</p><p>In this analysis, we were careful to only include responses that clearly attended to a difference in difficulty between the two environments. For example, the response "[In Java] there are no blocks to help out, it is basically done from scratch" was coded as attending to ease-of-use, since the blocks "help out", while the response: "Java is more writing as if it was a language, while Snap! you use logic to put blocks together" was not coded as attending to ease-of-use because the student did not make it clear that this difference made one environment easier than the other. We included responses that mentioned the need to memorize commands in Java to mean that Snap! was easier due to the assumption that memorization contributes to difficulty. While many responses required some interpretation, others were very clear on which environment they found easier, giving responses like: "Learning Java is more complicated than Snap!" and "Java is much easier for me than Snap!" Additionally, two students attended to ease-of-use, but specifically said the two modalities were comparable: "one is hard and the other is equally as hard."</p><p>These data show that students found the blocks-based programming approach of Snap! to be easier than Java, thus supporting the general view of blocks-based tools being easier for novice programmers. There were no significant differences in responses across the three conditions of the study with the exception that three of the four responses that said Java was easier came from the read-write condition, where students were asked to write JavaScript along with compose in blocks. One explanation of this is that these students preferred the text-based programming in Java because composing text in Snap! required additional steps (creating new blocks and opening the editor), so students who were already comfortable with text-based programming may have found Java easier as it didn't require these additional steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Why is blocks-based programming easy?</head><p>Since our analysis shows that students perceive blocks-based programming as easier than text-based programming, we now move to the second part of our first research question, why? To answer this question we draw on the interviews we conducted during the first week of our study when students were initially introduced to the Snap! programming environment. We focus on these interviews as they give us insight into students' first impressions of the blocks-based and text-based representations. Data from later in the study, after students have experience using the two representations, will be incorporated later in our analysis. The protocol for these interviews starts with a series of questions asking about students' prior programming experience and their reasons for taking the course. From there, we introduced them to the Snap! programming environment and, if they had never seen blocks-based programming before, showed them how to write a basic program (i.e. how to drag-and-drop blocks together to control the onscreen sprite). The main portion of the interview had students try and write a simple program (programs differed depending on their prior experience, but ranged from having a sprite draw a square to a basic number guessing game for more experienced students). Having written the short program, we then opened up the text window to display a JavaScript implementation of the program they just authored (Figure <ref type="figure" target="#fig_1">3</ref>.) and began a discussion about the differences between the two program representations.</p><p>Nine students were interviewed using this protocol, five male and four female. The students were distributed across the grades, with four grade 10 students, two grade 12 students, and one student each from grades, 8, 9, and 11. The students were chosen as they were representative of the larger sample with respect to grade, gender, and ethnicity, and had reported having little prior programming experience. From the nine interviews, four major reasons for blocks-based programming being easier emerged.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Blocks are Easier to Read</head><p>The first aspect of the blocks-based tools that students identified as helpful was the descriptive, easy-to-read labels on the blocks. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Shape and Visual Layout of the Blocks</head><p>The second feature students identified that makes blocks-based programming easy is the visual nature of the blocks and the graphical cues that each block provides for how and where they can be used. Four of the nine students interviewed explicitly mentioned the shape of the blocks as being useful. For example, when our eighth grade student was asked why some blocks have rounded edges and others have diamond shaped edges, she explained that it was so "the user knows that…they have a limited There is a potential drawback to the programming-primitives-aspuzzle-pieces metaphor stemming from the fact that in a puzzle, each piece has one specific place that it belongs. As one student said when talking about the blocks "everything has its place." This is not true with programming, as commands can be used in a variety of ways and in various places within a program to produce an infinite number of behaviors. One of our interviewees struggled due to holding this perspective, which became clear when he recounted his difficulty on the first class assignment. When asked if it was the blocks he struggled with, he answered that it was not the blocks themselves, but in not knowing "the combinations that do something specific, like, I'm not exactly sure which blocks snap together to do something, like a specific action." The idea that particular sequences of blocks, when snapped together, produce a specific action calls to mind special combinations used in video games, where unique combinations of moves results in special actions that are different that the sum of the inputs used to produce them. As a result, this participant felt there was something he did not know, some knowledge beyond what is shown in the interface. After getting help from a neighbor, he said the program he eventually wrote made sense, but admitted to not knowing how to create it initially. We raise this issue with blocks-based interfaces as we fear it may be exacerbated by introductory activities that provide fill-in-the-missing-command style challenges, as they may reinforce the "everything has its place" perception of programming as opposed to the more accurate view of there being multiple ways to successfully achieve a desired programming outcome.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Easier to compose</head><p>A third advantage identified by students was how the act of composing a program was easier with blocks. This is in part due to the shape of the blocks that we just discussed, but also a product of a number of other features of the blocks-based modality. The first is that the act of dragging-and-dropping commands is easier and less error prone than having to type in commands character-by-character: "If you type it, with like one word or one period or one something that's wrong it's going to mess everything up…it's just harder to write with the codes." Another student put it slightly differently saying: "I like visualizing things more so with Snap, it's a lot easier than having to type everything in," continuing by saying how with text-based programing "you have to be pretty precise with your punctuation, you have to type everything in." A third student succinctly put it, with blocks "you don't end up making as much mistakes."</p><p>Along with the ease of composing valid programs, a number of students highlight how blocks make it easier to tinker with a program. This benefit can be seen when watching students compose programs, often taking a block or sets of blocks and putting them off to the side while trying new blocks in their script, only to ultimately return the removed blocks back into the script.</p><p>Similarly, with blocks it becomes easy to compose complex statement in a non-linear order. For example, during her interview we asked one of our tenth grade students to write a program that required using a conditional statement to compare two numbers.</p><p>The student built her statement in four discrete steps (Figure <ref type="figure">4</ref>). First, she dragged out the green = comparison block. Second, she added the answer block to its left side and the number variable block to its right. Next, she dragged out the if block, placing her newly constructed comparator inside it, then finally completing the statement by nesting the say block inside the parent if block. This sequence of composition is quite different than how one conventionally goes about writing a conditional statement in a text-based language, where the left-to-right orientation imposed by the text editor makes it unnatural to start with anything other than the word if, making the approach this student took to building a conditional statements difficult. In this way, the blocksbased representation facilitates what Turkle and Papert <ref type="bibr" target="#b33">[33]</ref> call epistemological pluralism, where the medium can support a variety of authoring approaches, including the traditionally favored planner mentality, as well as a bricolage orientation that emphasizes negotiation and rearranging of materials.</p><p>Step 1.</p><p>Step 2.</p><p>Step 3.</p><p>Step 4.</p><p>Figure <ref type="figure">4</ref>. The sequence of steps followed by one student to assemble a conditional statement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.4">Blocks as Memory Aids</head><p>The final feature of blocks-based programming that was identified by four of the nine students interviewed, stems from the ease of finding way to browse all the available blocks, making it possible to use the blocks themselves as a source of ideas, as one student put it: "everything is here that you can do." Another student focused on how easy it was to browse the available set of blocks as being a key reason blocks-based programming was easier, saying "it's just because of the blocks and how they're separated into categories…so it's just much simpler to find the blocks and put them in to the pane." The utility of the organization and ease of browsing of the blocks was evident throughout the interviews. For example, during an interview with a grade ten student, we asked if he could draw a square on the screen, he successfully did so, but relied on the forever block in his program. When asked how he would change his program so it would be possible to draw a second square next to the first, he opened, the Control category where looping blocks were stored, read through the blocks, and said "I'm not really sure, I think it's in the tab somewhere though," showing how the organization of the blocks within the environment can support novices in constructing programs.</p><p>Recognizing the way that the graphical features of the blocksbased language various cognitive aspects of the programming activity is important as a designer as it provides a powerful scaffold for learners. Viewing this characteristic of blocks-based tools through a distributed cognition lens <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b21">21]</ref> provides a larger explanation that encompasses many of the features of blocks-based environments that students cited as supporting their learning. The distribution cognition theory argues that a cognitive system is not limited to just the internal processes of the individual, but includes the larger environment in which the activity occurs. In this expanded view, physical objects can serve as memories devices and aid the individual in accomplishing the task at hand. In blocks-based environments, this means the blocks themselves "remember" much of what would otherwise need to be known a priori by the user, including what the blocks do (captured by the text labels and what color and category the reside in) and how and where they can be used (denoted by the shape of the blocks). Similarly, the browsable categories offload the need for the user to have to remember everything that is possible in the language, and instead can serve as a guide for what is possible and act as a source of inspiration for the user <ref type="bibr" target="#b35">[35]</ref>. Through this lens, the affordances of the blocks-based environment that contribute to their ease-of-use can be understood as the aspects of the knowledge one needs to be a successful programmer that are designed into the environment and the representation itself.</p><p>That blocks can serve as memory aids, along with the other three characteristics of blocks-based programming tools discussed above, make up the four most salient features of blocks-based programming for the novice programmers we interviewed. It is important to reiterate that these features were identified at the outset of the learning process, not by the designers, researchers, or educators who bring specific goals to the use of such tools, or by learners who had not already mastered the use of either text-based or blocks-based programming. This analysis provides evidence that these tools are effective at scaffolding learners during the early stages of learning to programming and identifies specific features of blocks-based tools that the learners found useful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">What are the differences between blocksbased and text-based programming?</head><p>Having identified four reasons for the perception that blocksbased programming is easier than the text-based alternative, we now proceed to our second question, which asks what students see as the main differences between blocks-based and text-based programming. To answer this question we analyzed student responses to a pair of survey questions asking them to compare blocks-based programming in our custom versions of Snap! to text-based Java programming. The questions were asked at two points during the study. First, on the mid-study survey we asked: "The thing that will be the most different about programming in Java compared to programming in Snap! is:" Students answered this question after using Snap! for five weeks but before they had started working in Java. Five weeks later, after students had been working in Java, we asked the same question, just shifting from the future tense to the present tense. A total of 85 students took the mid-study survey with one fewer student taking the final survey, resulting in a total of 169 responses. We open-coded these two sets of responses and categorized them by what students chose to identify as the largest difference between the two environments. Figure <ref type="figure">5</ref> shows student responses to these questions grouped by difference identified, point-in-time, and the version of Snap! the students used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 5. Student reported differences between Snap! and Java given at the mid-point and conclusion of the study.</head><p>This analysis revealed three new categories on top of the four themes that emerged during our interviews about what makes blocks-based programming easier. The new categories include the presence of prefabricated commands, the ease of trial-and-error programming in Snap!, and the different types of programs authored in Snap! versus Java. Table <ref type="table">2</ref> provides examples of student responses for each category identified.</p><p>Despite the importance of the natural language labels on the blocks and the ease of readability that students emphasized at the outset of the study, students rarely cited this feature of blocksbased programming as being a major difference on the survey. The other three categories from the previous section were much more prominent. For the Visual Layout category, we included student responses that attended to shape or color of a block along with more general responses speaking to the graphical nature of the blocks. The Ease of Composition category included responses that directly referenced the drag-and-drop nature of the blocks or how the blocks can snap together. Our final category from the previous section, in which students highlighted the browsability of the blocks-based environment and how it alleviated the need to memorize syntax, was included in 37 student responses. Most of these responses highlighted how in Java, you have to know a command as well as it's syntax in order to use it in a program.</p><p>Beyond the four features discussed in the previous section, three other differences were repeatedly mentioned in students' survey responses. The first was how Java was not as conducive to the use of trial-and-error programming. This is particularly interesting as the trial-and-error approach is as valuable in text-based Table <ref type="table">2</ref>. Sample responses to the question having students compare Snap! and Java</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Category Example Responses</head><p>Ease of Readability "The programming language will no longer be translated to English completely for a user to easily understand what is going on." "Snap! was easy to read."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Visual Layout</head><p>"There aren't going to be anymore colorful blocks." "I will have to code without having help from blocks." Ease to Composition "Actually having to type everything out instead of dragging and dropping." "Java is all hand typed while in Snap! you grab and drop blocks."</p><p>Browsability "You will not have the blocks to aid you anymore and you will have to memorize and learn the Java script for everything you are trying to do." "Not feeling as restricted and having to think more because you don't have all the options in front of you." Support for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Trial &amp; Error</head><p>"Java is not a trial-and-error program. If I make a mistake, then I must fix it on my own. There is no guessing involved, and I think I will have a really difficult time adapting to this process." "In Java, I will not be able to test out blocks and incorporate them and see if they work." Prefabricated Commands "There will be no set blocks that will provide you with pre made functions." "You do everything on your own without the help of preset blocks for the code, and you have to compile the file." Visual Outcomes "Java is more about having things such as text be displayed while Snap! was more about making sprites do things such as move or complete a goal etc." programming as in blocks-based, and nothing about text-based programming prevents the programmer from using the strategy. There are also potential consequences to thinking trial-and-error is not possible or not acceptable in text-based programming. Papert <ref type="bibr" target="#b28">[28]</ref> addresses this in his discussion of the difference between learners perceiving errors as wrong versus errors as fixable and how the errors-as-fixable orientation is a much more productive learning strategy. If the shift from blocks-based to text-based programming also carries with it a shift from the trial-and-error strategy being supported to it being viewed as impractical or even not possible, it is important that we as designers and educators be aware of this misconception and try and address it.</p><p>The second new category to emerge was that of the lack of prefabricated commands in text-based programming. Whereas a single block can do something in Snap!, like move a sprite or ask a question, students thought that with text-based programming, the individual commands were more fine-grained, requiring more commands to be used to accomplish a comparable behavior. While this is not necessarily true when calling APIs or other predefined functions, this reported difference highlights the perceived contrast in the size of atomic block commands and text-based language primitives. The final new category captures students identifying the visual enactment of programs as being a major difference between Java and Snap! This difference speaks less to the blocks versus textual nature of the languages themselves, and more to the larger environments in which the programming is occurring. Interestingly, this was only identified by one student as a difference before the Java portion of the course, but was highlighted by eight students at the end of the study. It is worth mentioning this last difference need not always be the case as numerous text-based development environments (Java and otherwise) make it possible to have visual outcomes from the outset, with Logo being one prominent example.</p><p>Between the two sets of survey responses, there were an additional 35 differences identified that did not occur often enough to warrant their own category. These responses including Java requiring more planning upfront, Snap! running scripts in parallel, the compilation step required in Java programming, and the ease of debugging in the blocks-based environment. Additionally, 19 responses across the two sets of survey responses did not articulate a specific difference, instead giving broad, vague responses like "[Java] won't be as fun" or "Java is much easier for me than Snap!"</p><p>Looking at the differences between responses given at the midpoint of the study when students had only used the blocksbased tools and the end of the study after students had been exposed to Java, a number of shifts are visible. First, there was a significant drop in the number of students who identified the visual nature of the blocks (referring to their shape, color, and nested structure) as being the most significant difference between the modalities. This suggests that after working in Java, the visual representation loses significance relative to other differences that exist. A second difference was the growth in students attending to what is possible with Snap! and how the language supports accomplishing that objective. This can be seen in the rise of students identifying the visual outcomes of programs as being the most salient different as well as the loss of prefabricated blocks and the need to use more commands to achieve a specific outcome. Taking a step back, these shifts suggest that as experience with text-based programming language grows, what students attend to shifts from the visual presentation and layout of the program to differences in what can be done with the different tools and how one goes about accomplishing it.</p><p>Up to this point in our discussion, we have grouped the three conditions of the blocks-based environment together. As a reminder, the three versions of Snap! that students used were: an all-graphical version (the lightest colors in Figure <ref type="figure">5</ref>), a read-only version of Snap! where students could read JavaScript versions of the programs they authored (the middle shade of blue/red in Figure <ref type="figure">5</ref>), and a read-write version that added the ability for learners to define the behaviors of new blocks by writing short JavaScript programs (the darkest shade of the colors in Figure <ref type="figure">5</ref>). For the most part, there was little difference between the conditions in students' responses. One notable exception is in the Ease of Composition category, which was rarely cited as a difference between the blocks-based and text-based tools in the read-write condition. This is unsurprising given that in this version of Snap! it was possible for students to write small snippets of text-based code, thus making the ease of composition a less prominent difference. A second major difference among responses across the three conditions was the number of differences cited by students in the read-write condition that fell outside of the larger categories. After recoding the Other responses, we were unable to identify a pattern to explain this difference and leave as an open question we hope to return to in future analyses of the data we collected in this study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Drawbacks to blocks-based programming</head><p>While most of the differences we have presented thus far have generally showed students holding a positive impression of the blocks-based programming approach, stemming from its perceived ease-of-use, the use of blocks-based tools for introducing high school students to programming was not entirely unproblematic. Over the course of our ten-week study, students identified a number of drawbacks to blocks-based programming. We present these drawbacks to shed light on reservations students have regarding the use of this strategy in formal introductory programming contexts at the high school level. The data we present below were drawn from both the introductory interviews we used to answer our first research question as well as the survey responses given at the midpoint and conclusion of our study asking students to compare the Snap! and Java programming environments. Across this dataset, three drawbacks to programming in a block-based environment were raised.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Less Powerful</head><p>The first drawback to blocks-based programming students cited was that block-based programming was viewed as a less powerful programming technique compared to the text-based alternative. By power, we are referring to the set of things that are possible with the language. As one student said, with text-based programming "you can do a lot more." A second student reiterated this point, saying: "blocks are limiting, like you can't do everything you can with Java, I guess. There is not a block for everything." This comment is interesting as one could rebut that there is not a command for everything in Java either. The student who made this comment did not know how to program in Java, but nonetheless held the belief that the two representations were not equally powerful or expressive. Another student made these same points saying: "In Java you can make it more complex than something you make in Snap! or Scratch." She then continued: "I'm pretty sure there are going to be some things that are too big to put in blocks...too complex." This student viewed the blocksbased interface as a simplified version of Java, saying: "I think what Snap! does it just takes the simpler things in Java and then turns them into blocks." This last statement is particularly interesting given that the available set of primitives provided by Snap! is largely a superset of the keywords reserved in Java, not the other way around. When asked why we chose to start the course with Snap! before moving to Java, a grade ten student responded: "to increase understanding of programming. I mean like, Snap! is an awesome program, but there is only so much you can learn in it. But in Java, you can like figure out how to do like, all the other stuff." When pressed, the student was unable to articulate what "other stuff" consisted of, but still, this reveals a perceived limitation of what can be accomplished with blocksbased programming environments. In our post survey, one student summed up the difference between Java and Snap! succinctly by saying of Java: "there are more possibilities."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.2">Slower Authoring and More Verbose</head><p>The second drawback brought up by a number of students was the time and number of blocks it takes to compose a program in the blocks-based interface compared to the text-based alternative. For example, when comparing Snap! to her previous experience making web pages, a 9 th grade interviewee said: "I know you have the variables [in Snap!] that you can edit and mess around with but sometimes that takes a lot of time, but HTML and CSS you can kind of get creative and quickly just type something in to do something different". This was reiterated by a second student who said: "if you want a specific block and it's not there, you're going to have to put a lot of blocks together to make it do what you want it to do, and I think with JavaScript, it's just, like, one sentence I guess." While it is unclear what is mean by a "sentence" in JavaScript, this comment does give us insight into how the student perceived text-based programming to be advantageous. Text being more concise was identified as not only useful for composing programs, but students also thought that the resulting shorter textbased programs could be easier to understand. "It seems like when there is more blocks it's more confusing…when we did the games, we did a lot of, like a whole bunch of blocks, it was really hard to find where mistakes were. [Text-based programming] seems easier when there is like a lot." During our five-week study, programs rarely exceeded the size of the screen the students were working on, but in this case, the students experience with longer blocks-based programs lead to the recognition that longer blocksbased programs can be difficult to manage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.3">Inauthentic</head><p>The third and final drawback identified about the use of blocksbased tools is potentially the most damaging with respect to the effectiveness of their being used in introductory programming courses for older learners. Some of the students we interviewed expressed concerns over the authenticity of blocks-based programming. By authenticity, we mean how closely the programming tool and practices adhere to conventional, noneducational programming contexts. As one student said: "Java is actual code, while Snap! is something nobody will let you code in." This same point was made by another student who said: "if we actually want to program something, we wouldn't have blocks." It is important to note that this view was not universally held. As part of our interview protocol, students were asked if they thought what they were doing in Snap! constituted programming, to which every student answered in the affirmative. A number of students recognized blocks-based programming as being an introductory tool, giving responses like "I think [blocksbased programming] is the same thing, just easier" and "I would say [blocks-based programming] is like beginners programming". This suggests that even when perceived as potentially inauthentic, students still recognize the pedagogical usefulness of blocksbased tools. This drawback in particular seems like it is more likely to affect older learners who are eager to develop skills that can be used beyond the classroom, be it for a job or further computer science coursework.</p><p>These three perceived issues with blocks-based programming expressed by our participants gives us insight into potential drawbacks of the use of this approach at the high school level. We do not see this finding as undermining the use of blocks-based programming in formal, high school contexts, but instead, see these data as providing a fuller picture of how students perceive the tools we use for instruction, which in turn can be used to better inform educators on how to best utilize them in their classrooms. Further, identifying these perceived drawbacks can provide a roadmap for the improvement of these tools moving forward.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">DISCUSSION</head><p>This study looks at the use of block-based programming tools in high-school introductory programming contexts. This means older students learning in a formal setting, which is quite distinct from the younger audience and informal settings that Scratch, and many of the tools inspired by Scratch, were initially designed for <ref type="bibr" target="#b26">[26]</ref>. Much of the work that has been done on these tools focuses on the younger audiences and informal spaces that match the audience they were initially designed for [e.g. 9, 20, 21]. Given the role these tools are increasingly playing in introductory computer science classes at the high school level, it is important to understand how high-school aged learners are making sense of them and if they are effective in their role of introducing learner to the programming component of the field of computer science. As the data in this study show, high school students generally find blocks-based programming tools to be easier to use than conventional text-based alternatives. They attribute this ease-ofuse largely to visual features of the environment including the graphical presentation of the blocks, the drag-and-drop mechanism for authoring programs, and the ease of browsing the available set of blocks to figure out what commands to include in the program. This suggests that such blocks-based tools are effective for making it easier for high school aged students to get started programming, but that is not the whole story. Our study also found that some high school students see drawbacks to the use of such tools. Students saw the blocks-based tools as less powerful, potentially more cumbersome to use for larger projects, and inauthentic relative to conventional text-based programming. These findings are similar to what DiSalvo found in her analysis of high school students' preferences after work with both Alice and Jython (a text-based language) <ref type="bibr" target="#b6">[6]</ref>. That study had the additional finding that student motivation and interest further influences student perceptions.</p><p>One obvious take-away from this research is to make teachers aware of these findings. Teachers can highlight the useful features of the environments while also addressing and downplaying concerns students have, like the perceived inauthenticity or lack of expressive power that some students associate with blocks-based interfaces. The presence of the teacher is a feature of formal education spaces that we can leverage to alleviate some of these drawbacks. Additionally, as designers, we can use the findings reported above to potentially improve both the graphical introductory tools as well as the text-based programming environments the students use as they move on to Java, Python, or whatever languages await them.</p><p>Knowing the strengths and drawbacks of blocks-based programming environments as perceived by the high school learners that are using them, helps inform us as educators and designers about what is working, what aspects of their design we might want to modify for the high school audience, and what features of these tools we might want to introduce to text-based environments for novices. For example, to address authenticity, the blocks-based environments could support not just controlling on-screen sprites, but also make it possible to have programs read from and output to a conventional terminal, akin to what many early Java programs do. The idea is not to replace the stage or introductory activities with less engaging text-only exercises, but instead to reinforce the similarities between programming in blocks-based tools and text-based languages; to provide a concrete way to more directly show the isomorphism between the two types of programming by making it possible to write (and run) the exact same program in blocks-based tools and Java to see how the two tools are similar. Such an addition to a blocks-based environment could start to break the perception that blocks-based tools can only be used to control graphical sprites and show how it can be used to accomplish what students might perceive as more authentic programming tasks.</p><p>Just as our findings can inform the design of blocks-based tools, so to can they be used to improve introductory text-based environments. For example, students frequently cited the browsability of the blocks-based environment as a feature that made it easy to use. Why not add a similar browsability to introductory text-based environments? The auto-complete feature of modern programming environments is similar to this, but is not curated or displayed in the same way the blocks environments are, where the commands are persistent and grouped by function. Adding an easily browsed, well organized library of valid commands that lives inside the Java or Python programming environment is one example of how we can use what we learn from novices about what makes blocks-based tools easy to improve and better prepare them for the transition to the textbased tools that await them in more advanced courses.</p><p>The final point we want to make is on the importance of recognizing the gap between how novices and experts approach a program or, in our case, a programming environment. When a seasoned programmer looks at a blocks-based language, the meaning of the shapes and colors of blocks are immediately apparent, with the most common response being "how clever," as they can see how the blocks convey syntactic information and obviate some of the less obvious features of programming languages (like semi-colons and curly braces). It cannot be assumed that novices see the same thing. They have no prior knowledge of the syntax that is being represented and do not know what difficulties the graphical representation is alleviating from the act of programming. This is apparent as we have seen students using Snap! and other blocks-based tools write their first program left to right, completely ignoring the shape of the blocks. Upon telling students that programs are written top-to-bottom and showing the how blocks fit together, the shape of the blocks start to take on meaning, but it is important to state that we cannot take this knowledge for granted. We bring this point up as a reminder of the expert blindness that a designer who already knows how to program brings to the design of introductory programming tools. The solution to this is to remember that learners are the experts when it comes to understanding how novices make sense of and build an understanding of the practice of programming. As such, it is critical that we conduct studies like the one presented here, analyzing tools not from the perspective of those who have already mastered the content, but instead from the perspective of the learners who the tools is designed for.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Limitations</head><p>There are a few limitations to the study we conducted that may affect the generalizability of the findings. First, the school we conducted our study in is a selective enrollment school with an exceptional computer science department. This issue is partially mitigated by the fact that the school is public and the selectivity criteria for enrollment are designed to ensure the student body reflects the racial and socio-economic diversity of the district, but we do recognize that the students we worked with were exceptionally bright and motivated. Second, in these interviews, while we were trying to ask questions about the nature of blocksbased programming, we often got responses that were specific to the Snap! and Java or JavaScript tools we were using. Students struggled to disentangle the specific instance from the larger class of languages that we were using them to represent. While we recognize this drawback, we still find student responses to be insightful as to differences between the two modalities and, as we move forward in our work, intend on adding new languages and tools to address this. Finally, the study design followed students for five weeks in Snap! and five weeks in Java, but the amount of that can be covered in five weeks is vastly different. Wherein after five weeks of Snap! students were using conditional logic, variables, and loops, in Java, at the end of five weeks, we had only covered basic I/O and started calling methods, and thus, had not discussed many of the other topics we covered in Snap! This difference in coverage speaks to the ease of teaching with Snap! but also means students had not been exposed to the same set of material in the two modalities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>Blocks-based programming is becoming the standard way to introduce learners to programming both inside classrooms and beyond. Educators and designers advocate for this approach arguing that it is easier to get started and more engaging for the learner. In this paper, we sought to understand how high school students enrolled in an introductory programming course perceived the blocks-based programming approach. Through cognitive interviews and surveys, we found that students generally found blocks-based programming to be easier than the text-based alternative, citing reasons including the natural language labels on the blocks, the shapes and colors of the blocks, the drag-and-drop composition mechanism, and the ease of browsing the blocks library. Students also identified drawbacks to the blocks-based programming approach, including issues of authenticity, expressive power, and challenges in authoring larger, more sophisticated programs. We also found that the differences high school students see between blocks-based and text-based programming span the visual interface, the types of programs that can be authored, as well a different programming practices that each representation supports. By analyzing student responses, we can better understand how the learners themselves are making sense of these introductory tools, isolate what they are identifying as useful about the environment in advancing their developing understanding, and use these insights to improve the tools we are currently using in classrooms and inform the design of the next generation of introductory programming environments. Our hope is that by doing so, we can better prepare today's students for the computational challenges of tomorrow.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Three examples of blocks-based programming tools.</figDesc><graphic coords="2,54.00,268.08,57.12,78.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. A screen shot from an interview.</figDesc><graphic coords="3,317.76,313.20,234.96,123.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>block and understanding what they do through their organization within the programming environment. More specifically, how the blocks themselves alleviate the memorization that is required in text-based programming. "[The blocks] kind of jog your memory, so you can see something and be like 'oh, I remember how to do that now', but with [text-based programming] you don't really have anything there to help you remember how to code something." As a second student put it: "[In JavaScript] you need to like, know all the code words to draw something. Let's say you want to draw something, you need to type in a certain word to do that when in scratch you could just like, find the pen down block or something." This last point is critical, blocks-based environments provide an easy and organized</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 . Student responses comparing Java to Snap! -coded for ease-of-use of the environment.</head><label>1</label><figDesc></figDesc><table><row><cell>Perception</cell><cell>Count (Graph/Read-only/Read-write)</cell></row><row><cell>Text-based Programming is Easier</cell><cell>4 (0/1/3)</cell></row><row><cell>Blocks-based Programming is Easier</cell><cell>42 (14/15/13)</cell></row><row><cell>Comparable Difficulty</cell><cell>2 (0/1/1)</cell></row><row><cell>Did not attend to Difficulty</cell><cell>41 (13/13/14)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Of the nine student interviewed, seven mentioned the readability of the blocks as a feature that made them easier to use than the text-based alternative. That students find the natural language nature of Snap! helpful is supported by research on the design of novice programming languages that has found the strategy of drawing on learners' natural language knowledge to be effective<ref type="bibr" target="#b4">[4]</ref>.</figDesc><table /><note><p>"Well, I mean, if you can read it…for humans this looks better, it's easier to understand." Despite its looking less like a text editor when compared with the text-based code, a number of students viewed the blocks-based representation as closer to English than its text-based counterpart. "With blocks, it's in English, it's like pretty, like, more easier to understand and read," a second student highlighted this difference, saying: "Java is not in English it's in Java language, and the blocks are in English, it's easier to understand." A third student explained: "[the blocks] are basically a translation of what [the JavaScript] is doing, in, I guess, English for lack of better words. It is describing what [the JavaScript] is doing, but it's describing it in an English form...like a conversion." In calling the blocks a translation of the JavaScript, the student recognizes the equivalence of the two representations and identifies the blocks as being more easily read. Across these responses we see the blocks-based representation serving as an intermediary between English and conventional text-based programming, with students recognizing features of both in the blocks-based representation. Another way this difference appeared in our interviews was in students highlighting the lack of obscure punctuation in the block-based tool: "[the JavaScript] is really confusing to understand with all the parenthesis and bracket and all of that."</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>choice so that you don't make the mistake, because if all of [the blocks] the same, it might not work. If [the block is] rounded or diagonal, they'll know the difference; they'll know that you can't put [a diamond block] in [an oval slot], it's like a puzzle." A second student echoed this fact, when asked how he knew that Boolean blocks could be used with control structure blocks and numbers and mathematical operators worked with motion blocks he explained "it's because of their outline, [the Boolean blocks shape] is the same as [the control blocks inputs] and then in motion, the [oval input] is the same as [the mathematical blocks]." The shape was identified as being useful to see how blocks fit inside each other, as well as how sequences of blocks could be built, which was helpful for making sense of the resulting behavior. "When [the blocks] are attached to each other, you know that the first one is going to affect the ones underneath it…everything is connected and it's easier to understand what is going on…I guess it's more intuitive too, because you can see how they all connect." Students said that these shape cues helped not only to see where blocks could be used, but also the larger idea of the importance of the sequence of commands, "[the environment] teaches you that order is important."</figDesc><table /></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The CS principles project</title>
		<author>
			<persName><forename type="first">O</forename><surname>Astrachan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Briggs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Inroads</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="38" to="42" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Starlogo TNG: An introduction to game development</title>
		<author>
			<persName><forename type="first">A</forename><surname>Begel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Klopfer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of E-Learning</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Turtle, Art, TurtleArt</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bontá</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Constructionism 2010 Conference</title>
		<meeting>of Constructionism 2010 Conference<address><addrLine>Paris, Fr</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Bruckman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Edwards</surname></persName>
		</author>
		<title level="m">Should we leverage natural-language knowledge? Proc. of the SIGCHI conference</title>
		<imprint>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="page" from="207" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Alice: a 3-D tool for introductory programming concepts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cooper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computing Sciences in Colleges</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="107" to="116" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Graphical Qualities of Educational Technology: Using Drag-and-Drop and Text-Based Programs for Introductory Computer Science</title>
		<author>
			<persName><forename type="first">B</forename><surname>Disalvo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE computer graphics and applications</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="12" to="15" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Programming environments based on structured editors: The MENTOR experience</title>
		<author>
			<persName><forename type="first">V</forename><surname>Donzeau-Gouge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Interactive Programming Environments</title>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>McGraw Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Duncan</surname></persName>
		</author>
		<title level="m">Should Your 8-year-old Learn Coding? Proc. of WiPSCE</title>
		<meeting><address><addrLine>New York, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="60" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">CodeSpells: embodying the metaphor of wizardry for programming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Esper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ITiCSE</title>
		<meeting>of ITiCSE</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="249" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Programming-languages as a conceptual framework for teaching mathematics</title>
		<author>
			<persName><forename type="first">W</forename><surname>Feurzeig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGCUE Outlook</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="13" to="17" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Programming in the wild: trends in youth computational participation in the online scratch community</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Fields</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of WiPSCE</title>
		<meeting>of WiPSCE<address><addrLine>New York, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">N</forename><surname>Fraser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<pubPlace>Blockly. Google</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Beyond curriculum: the exploring computer science program</title>
		<author>
			<persName><forename type="first">J</forename><surname>Goode</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Inroads</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="47" to="53" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Programming environments for novices</title>
		<author>
			<persName><forename type="first">M</forename><surname>Guzdial</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Science Education Research</title>
		<imprint>
			<biblScope unit="page" from="127" to="154" />
			<date type="published" when="2004">2004. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Papert</forename><surname>Harel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
			<publisher>Ablex Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Bringing &quot;no ceiling&quot; to Scratch: Can one language serve kids and computer scientists?</title>
		<author>
			<persName><forename type="first">B</forename><surname>Harvey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mönig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Constructionism</title>
		<meeting>of Constructionism<address><addrLine>Paris, Fr</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Distributed cognition: toward a new foundation for human-computer interaction research</title>
		<author>
			<persName><forename type="first">J</forename><surname>Hollan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Computer-Human Interaction</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="174" to="196" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Frog pond: a codefirst learning environment on evolution and natural selection</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Horn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2014 IDC conference</title>
		<meeting>of the 2014 IDC conference</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="357" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">NetTango: A mash-up of NetLogo and Tern</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Wilensky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note>Paper presented at AERA 2012</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Horstmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Early Objects. Wiley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">How a cockpit remembers its speeds</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hutchins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cognitive science</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="265" to="288" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Lowering the barriers to programming: A taxonomy of programming environments for novice programmers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kelleher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pausch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m">Lego Mindstorms NXT-G System</title>
		<imprint>
			<publisher>Lego Systems Inc</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">How programming environment shapes perception, learning and goals: Logo vs. Scratch</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Lewis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 41 st ACM Technical Symposium on CSE</title>
		<meeting>of the 41 st ACM Technical Symposium on CSE</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="346" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Programming by choice: Urban youth learning programming with Scratch</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Maloney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCSE Bulletin</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="367" to="371" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The scratch programming language and environment</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Maloney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computing Education</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">16</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Evolution of novice programming environments: the structure editors of Carnegie Mellon University</title>
		<author>
			<persName><forename type="first">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Interactive Learning Envs</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="140" to="158" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Mindstorms: Children, computers, and powerful ideas</title>
		<author>
			<persName><forename type="first">S</forename><surname>Papert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
	<note>Basic books</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Scratch: Programming for all</title>
		<author>
			<persName><forename type="first">M</forename><surname>Resnick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page">60</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">OpenBlocks: An extendable framework for graphical block programming systems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Roque</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>MIT</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Da</forename><surname>Silva Gillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>miniBloq</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Tinkering with Pocket Code</title>
		<author>
			<persName><forename type="first">W</forename><surname>Slany</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Constructionism</title>
		<meeting>of Constructionism<address><addrLine>Vienna, Au</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Epistemological pluralism: Styles and voices within the computer culture</title>
		<author>
			<persName><forename type="first">S</forename><surname>Turkle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Papert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGNS: Journal of Women in Culture and Society</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="128" to="157" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">RoboBuilder: A program-to-play constructionist video game</title>
		<author>
			<persName><forename type="first">D</forename><surname>Weintrop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Wilensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Constructionism</title>
		<meeting>of Constructionism<address><addrLine>Athens, Gr</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Supporting computational expression: How novices use programming primitives in achieving a computational goal</title>
		<author>
			<persName><forename type="first">D</forename><surname>Weintrop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Wilensky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Paper presented at AERA 2013</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Restructuring Change, Interpreting Changes: The DeltaTick Modeling and Analysis Toolkit</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Wilkerson-Jerde</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Wilensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Constructionism</title>
		<meeting>of Constructionism<address><addrLine>Paris, Fr</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
