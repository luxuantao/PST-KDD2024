<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Pervasive and Mobile Computing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2009-07-14">14 July 2009</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Wen-Zhan</forename><surname>Song</surname></persName>
							<email>songwz@wsu.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Sensorweb Research Laboratory</orgName>
								<orgName type="institution">Washington State University</orgName>
								<address>
									<postCode>98686</postCode>
									<settlement>Vancouver</settlement>
									<region>WA</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Renjie</forename><surname>Huang</surname></persName>
							<email>renjie_huang@wsu.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Sensorweb Research Laboratory</orgName>
								<orgName type="institution">Washington State University</orgName>
								<address>
									<postCode>98686</postCode>
									<settlement>Vancouver</settlement>
									<region>WA</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Behrooz</forename><surname>Shirazi</surname></persName>
							<email>shirazi@wsu.edu</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Sensorweb Research Laboratory</orgName>
								<orgName type="institution">Washington State University</orgName>
								<address>
									<postCode>98686</postCode>
									<settlement>Vancouver</settlement>
									<region>WA</region>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Richard</forename><surname>Lahusen</surname></persName>
							<email>rlahusen@usgs.gov</email>
							<affiliation key="aff1">
								<orgName type="department">Cascades Volcano Observatory</orgName>
								<orgName type="institution">U.S. Geological Survey</orgName>
								<address>
									<country key="US">United States</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Pervasive and Mobile Computing</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2009-07-14">14 July 2009</date>
						</imprint>
					</monogr>
					<idno type="MD5">B0A698BC040B87368FBB124521F65513</idno>
					<idno type="DOI">10.1016/j.pmcj.2009.07.004</idno>
					<note type="submission">Received 26 February 2009 Received in revised form 7 June 2009 Accepted 2 July 2009</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>TreeMAC TDMA Sensor network Realtime High-data-rate Fairness</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Earlier sensor network MAC protocols focus on energy conservation in low-duty cycle applications, while some recent applications involve real-time high-data-rate signals. This motivates us to design an innovative localized TDMA MAC protocol to achieve high throughput and low congestion in data collection sensor networks, besides energy conservation. TreeMAC divides a time cycle into frames and each frame into slots. A parent node determines the children's frame assignment based on their relative bandwidth demand, and each node calculates its own slot assignment based on its hop-count to the sink. This innovative 2-dimensional frame-slot assignment algorithm has the following nice theory properties. First, given any node, at any time slot, there is at most one active sender in its neighborhood (including itself). Second, the packet scheduling with TreeMAC is bufferless, which therefore minimizes the probability of network congestion. Third, the data throughput to the gateway is at least 1/3 of the optimum assuming reliable links. Our experiments on a 24-node testbed show that TreeMAC protocol significantly improves network throughput, fairness, and energy efficiency compared to TinyOS's default CSMA MAC protocol and a recent TDMA MAC protocol Funneling-MAC. Partial results of this paper were published in Song, Huang, Shirazi and Lahusen [W.-Z. Song, R. Huang, B. Shirazi, and R. Lahusen, TreeMAC: Localized TDMA MAC protocol for high-throughput and fairness in sensor networks, in: The 7th Annual IEEE International Conference on Pervasive Computing and Communications, PerCom, March 2009]. Our new contributions include analyses of the performance of TreeMAC from various aspects. We also present more implementation detail and evaluate TreeMAC from other aspects.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In typical sensor network applications, sensor nodes monitor fields and generate events which traverse hop-by-hop towards one or more sink nodes. The major traffic pattern is therefore many-to-one forming a tree. It serves many diverse applications from low data rate event-driven monitoring applications to high data rate real-time industrial applications.</p><p>Controlling access to the channel, generally known as MAC protocol, plays a key role in determining channel capacity utilization, network delays and energy consumption. It also affects congestion and fairness in channel usage. The fundamental task of any MAC protocol is to regulate the access of a number of nodes to a shared medium in such a way that certain application-dependent performance requirements are satisfied. Traditional MAC protocols (including ALOHA, CSMA and their variants) assume random any-to-any communication and tend to give nodes equal channel access. However, equal channel access is not fair in the data collection scenario: the nodes closer to the sink need to forward more data than the nodes further away. For example, in Fig. <ref type="figure" target="#fig_0">1</ref>, assume all nodes in one collision domain, every node delivers data towards a sink through the subtree root f . If node k gets equal medium sharing opportunity as node f , it is obviously unfair and will cause congestion at node f (e.g., funneling effect <ref type="bibr" target="#b0">[1]</ref>). To ensure fairness, node f and h should get 6 times and 4 times the opportunities of nodes g, i, j, k. In other words, nodes in a network should get channel access opportunity proportional to their demands <ref type="bibr" target="#b1">[2]</ref>. Many-to-one routing, which is commonly used in most sensor networks, needs a fundamental revolution of MAC protocol design, as it is different from random any-to-any communication networks where equal means fair. This is the key motivation of TreeMAC design.</p><p>Earlier sensor network MAC protocols <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> are designed for low duty-cycle and low data-rate applications with the primary goal of energy conservation. More recent applications involve high-data-rate signals, such as monitoring industrial processes <ref type="bibr" target="#b4">[5]</ref>, geophysical environments <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref> and civil structures like buildings and bridges <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">8,</ref><ref type="bibr" target="#b9">9]</ref>. For those high-data-rate applications, there is a key challenge on how to collect these high-fidelity signals subject to the limited radio bandwidth available to sensor nodes. In addition to the limited physical bit rate of the radios used on those low power platforms, radio links often experience packet loss due to congestion, interference, and multi-path effects. These problems are exacerbated over multi-hop routing paths. TDMA-based MAC protocol is therefore a natural choice to increase network throughput and reduce congestion while conserving energy, with the aid of time synchronization protocols <ref type="bibr" target="#b10">[10]</ref><ref type="bibr" target="#b11">[11]</ref><ref type="bibr" target="#b12">[12]</ref>. Many existing TDMA MAC protocols are based on graph coloring to avoid scheduling conflicts in 2-hop neighborhoods and the message overhead is relatively high. In addition, their goals are to maximize the slot (e.g., spectrum) spatial reuse for all nodes in the network. However, slot reuse maximization based on graph coloring does not necessarily mean throughput maximization to the sink. In other words, it is true that every node can send out more data, but the sink does not necessarily get more data.</p><p>Motivated by the need of localized TDMA MAC protocols for high throughput and fairness, we propose TreeMAC, an innovative MAC protocol. With TreeMAC, channel access is well regulated for throughput maximization and energy conservation, and every node gets a number of time slots proportional to its bandwidth demand. TreeMAC divides each cycle into frames and each frame into three slots. By making use of the parent-children relationship established by any data collection routing protocol, the frame-slot assignment is determined and exchanged between parent and children only, hence it is truly localized. The parent determines the children's frame assignment based on their relative bandwidth demands; and each node calculates slot assignment based on its hop-count to the sink. This frame-slot assignment algorithm is an innovative two dimensional approach; the frame assignment eliminates horizontal two-hop interference, and the slot assignment eliminates vertical two-hop interference. We proved that, given any node, at any time slot, there is at most one active sender in its 1-hop neighborhood (including itself). We call it conflict-free packet sending/receiving and snooping, which is much stronger than conflict-free packet scheduling (e.g., conflict-free sending/receiving) in the literature. Snooping has been used by many wireless protocols (e.g., ExOR <ref type="bibr" target="#b13">[13]</ref>) to reduce communication cost and control overhead. With TreeMAC, the packet scheduling is bufferless, and the network throughput is theoretically bounded by 1/3 of the optimum (assuming reliable links). To our best knowledge, TreeMAC is the first localized TDMA MAC protocol to achieve these nice properties. Our experiments on a 24-node testbed show that TreeMAC protocol significantly improves the network throughput and energy efficiency compared to the TinyOS's default CSMA MAC protocol and a recent TDMA MAC protocol Funneling-MAC <ref type="bibr" target="#b0">[1]</ref>. Partial results of this paper were published in <ref type="bibr" target="#b14">[14]</ref>. Our new contributions include Section 4, which analyzes the performance of TreeMAC from various aspects. We also present more implementation detail and evaluate TreeMAC from new aspects.</p><p>The rest of the paper is organized as follows. In Section 2, we review existing MAC protocols for sensor networks. In Section 3, we introduce the principles and design of TreeMAC protocol and analyze its theoretical properties. Section 4 theoretically analyzes the performance of TreeMAC from various aspects. In Section 5, we present the system design and implementation details by considering various limitations and dynamics in a realistic network environment. We then evaluate the system performance on a real sensor network testbed in Section 6. Finally, Section 7 concludes the paper and discusses future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related works</head><p>The earlier sensor network MAC protocols mainly address energy conservation in low-duty cycle applications. S-MAC <ref type="bibr" target="#b2">[3]</ref> expects sensor networks to be deployed in an ad hoc fashion, with individual nodes remaining largely inactive for long time periods, but then becoming suddenly active when some events are detected. Energy conservation and self-configuration are the primary goals of S-MAC, while per-node fairness and latency are less important. S-MAC reduces idle listening energy waste by putting sensor nodes to sleep periodically. Neighboring nodes form virtual clusters to auto-synchronize on sleep schedules. In T-MAC <ref type="bibr" target="#b15">[15]</ref>, instead of having fixed sleep-wakeups, sensor nodes determine sleep-wakeup schedules adaptively. The schedules are determined based on a node's own traffic and that of its neighbors. B-MAC <ref type="bibr" target="#b3">[4]</ref> employs an adaptive preamble sampling scheme to reduce duty cycle and minimize idle listening. It supports on-the-fly reconfiguration and provides well-defined interfaces to optimize throughput, latency, or power conservation. The protocol in <ref type="bibr" target="#b16">[16]</ref> is a network-aware scheme in the sense that it considers route-through traffic when using rate control, and uses adaptive rate control mechanisms on top of CSMA to achieve energy efficiency and fairness. As pointed out in <ref type="bibr" target="#b0">[1]</ref>, they did not consider the funneling effect in high data rate data collection networks. After all, they are designed for energy conservation, not for throughput maximization.</p><p>Naturally, to improve network throughput and support real-time data delivery, schedule-based TDMA protocols have been studied in the literature. TRAMA <ref type="bibr" target="#b17">[17]</ref> reduces energy consumption by ensuring that unicast, multicast, and broadcast transmissions have no collisions, and by allowing nodes to switch to a low-power, idle state whenever they are not transmitting and receiving. It performs an adaptive election algorithm to overcome the drawback of wasting time slots. Seamlessly adapting the MAC behavior between TDMA and CSMA according to the level of contention was explored by <ref type="bibr" target="#b18">[18]</ref> for a wireless one-hop environment using a scheme called Probabilistic TDMA (PTDMA). As in TDMA, real time is slotted and by adjusting the access probability of owners and that of non-owners, PTDMA adapts the behavior of MAC between TDMA and CSMA depending on contention. However, PTDMA, designed primarily for a one-hop wireless LAN environment, does not deal with many difficulties that TDMA faces in multi-hop networks. Inspired from that, Z-MAC <ref type="bibr" target="#b19">[19]</ref> uses CSMA as the baseline MAC scheme, and uses a TDMA schedule as a hint to enhance contention resolution. Z-MAC uses DRAND (Distributed RAND) <ref type="bibr" target="#b20">[20]</ref> to compute time slot assignments. However, DRAND is a complex coloring algorithm that allocates time slots to every node ensuring that no two nodes among a two-hop neighborhood are assigned to the same time slot by broadcasting the TDMA schedule of each node to its two hop neighbors. Because of the overhead of running DRAND, Z-MAC does not recommend running it periodically, hence it is not really traffic adaptive. Those MAC protocols are not optimized for data gathering sensor network applications. In high-rate data collection networks, the nodes nearest to the sink (the intensity region) often experience heavy congestion since all data is forwarded toward the sink through those nodes, which have limited buffer size. This is called the funneling effect. Funneling-MAC <ref type="bibr" target="#b0">[1]</ref> is a hybrid TDMA and CSMA protocol proposed to address this problem. It uses TDMA scheduling in the intensity region to mitigate the funneling effect, while keeping CSMA in the rest of the network to provide flexibility. The funneling-MAC is sink-oriented because the burden of managing TDMA scheduling of sensor events in the intensity region falls on the sink node. It is essentially a centralized TDMA scheduling protocol. However, the funneling-MAC only operates in the intensity region close to the sink and not across the complete sensor field. It assumes that the sink node has relatively longer transmission range and can reach all nodes in the intensity region. This assumption may be applicable in some applications, but it is not always true. In some environmental applications, it is not uncommon that some stations of intensity region are behind obstacles, or the sink's radio range is not long enough to reach all nodes in the intensity region. In this paper, we present a localized TDMA MAC protocol to achieve high throughput and low congestion, by making use of the unique characteristics of data collection networks. It does not assume that any node is different from any other node, and is fully distributed and localized. Our experiments on a sensor network testbed show that it can achieve higher network throughput and fairness than Funneling-MAC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">TreeMAC protocol principles and design</head><p>In a many-to-one routing tree structure, to minimize congestion and maximize throughput, a key observation is that the time slots of depth-nodes shall be no less than the sum of the time slots of depth-( + 1) nodes and the slot demand for the depth-nodes themselves, as illustrated in Fig. <ref type="figure" target="#fig_1">2</ref>. Hence, we can make use of the parent-child relationship to assign slots locally. The basic idea is if a node u gets X slots assigned from its parent, then it can assign at most Xx slots to its children, where x is its own slot demand. This is the key observation inspiring the TreeMAC protocol design. Notice that, conventional TDMA MAC protocols assume random traffic and maximize slot reuse based on graph coloring. This assumption is not necessarily true in data collection networks. With that assumption, some nodes may send out more data, but the sink does not necessarily get more data, since those data may worsen the network congestion and be dropped in the congested funneling region. Appropriate slot reuse maximization shall consider proportional bandwidth demands.</p><p>TreeMAC protocol divides time into cycles, each cycle into N frames and each frame into 3 slots {0, 1, 2}, as illustrated in Fig. <ref type="figure" target="#fig_2">3</ref>. For each node u, its assigned frame-slot pair (F u , S u ) determines when u can send, receive or sleep, as will be described in algorithm 2.</p><p>The following notations will be used in the rest of the paper.</p><p>1. F u : the assigned frames set of each cycle to node u. For sink node, F sink is the set of all N frames.</p><p>2. S u ∈ {0, 1, 2}: the assigned transmittable time slot of each frame to node u.</p><p>3. u : the depth of node u in the routing tree, e.g., hop count to the sink.</p><p>4. β u : the slot demands of node u. Note that there are many ways to reflect bandwidth demand with tradeoffs. In this paper we use the total data rate of u's subtree plus that of itself. 5. C u : the children set of node u.   Frame and slot assignment illustration in an example tree. For each node, the bar illustrates its frame assignment, and the number denotes its transmittable slot in its assigned frame.  Each node u calculates its transmittable slot number S u according its own depth u in the tree: S u = ( u -1) mod 3. For example, in Fig. <ref type="figure" target="#fig_3">4</ref>, the node b has depth b = 2, hence S b = 1. It means that node b's transmittable slot number is 1 in its each assigned frame, that is to say, node b may transmit data in slot 1, but definitely not in slot 0 or slot 2. Whether a node can send or not in a time slot also depends on its frame assignment F u (see algorithm 2). Notice that, assigning transmittable slot based on tree depth eliminates vertical 2-hop interferences, as seen in Theorem 1.</p><p>For frame assignment, as mentioned earlier, the number of transmitting slots in depth-should be no less than the sum of the number of transmitting slots in depth-( + 1) and the slot demands of depth-'s own data. Hence, each depth-node could assign different subsets of its assigned frames to different children, then all depth +1 nodes will get non-overlapping frames. For instance, in Fig. <ref type="figure" target="#fig_3">4</ref>, node a got 11 frame assignments from its parent, then it may assign [0, 3] frame range to node b and <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b9">9]</ref> frame range to node f , then messages from node b and f will never conflict with each other. This recursive frame assignment eliminates horizontal 2-hop interferences, as seen in Theorem 1. Formally speaking, each node runs the frame-slot assignment procedure in Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 TreeMAC frame-slot assignment</head><p>Each cycle is divided into N frames. In each cycle, 1. each node u calculates its transmittable time slot S u = ( u -1) mod 3 ∈ {0, 1, 2}.</p><p>2. each node u assigns its children frames such that: (1)</p><formula xml:id="formula_0">F c i u ⊆ F u ; (2) F c i u F c j u = φ (if i = j) (3) size(F c i u ) = size(F u ) • β c i u /( c k u ∈C u β c i u + β u ).</formula><p>Algorithm 1 is simple yet powerful. TreeMAC's frame-slot assignment is a two dimensional approach: frame assignment eliminates horizontal two-hop interference, and slot assignment eliminates vertical two-hop interference. The graph coloring approaches used by conventional TDMA require at least 2-hop message exchanges to (try to) avoid hidden terminal problems, while TreeMAC ensures conflict-free scheduling by making use of the unique characteristics of many-to-one routing tree. Each node's transmittable time slot number only depends on its hop distance to the sink, which can be easily obtained from its own routing table. The frame assignment from parent to children can be piggybacked in data packets of previous cycle. Hence, the frame-slot assignment has near-zero control overhead. Each node's message transmission will not collide with the transmission from its parent, children, grandparent and grandchildren, since they get different transmittable slot numbers. In other words, the vertical two-hop interference is mitigated. Also, each node's message transmission will not collide with its sibling nodes (and their parents/children), since they get non-overlapping frames per cycle, therefore cannot transmit concurrently. In fact, we later will show that (in Theorem 1), given any node, there is at most one active sender in its neighborhood.</p><p>After getting its frame-slot assignment, each node performs the packet scheduling as described in Algorithm 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 TreeMAC packet scheduling</head><p>Let F be the current frame per cycle and S be current slot per frame, each node u takes the following actions: switch(F, S)</p><formula xml:id="formula_1">1. F ∈ F u :</formula><p>(a) case S = S u : node u may send a packet immediately. If there is no packet to send, it switches to sleeping mode to conserve energy.</p><p>(b) case S = S p u : node u switches to receiving mode to receive beacon or command and control information from parent. (c) case S = S c u : node u switches to receiving mode to receive data messages from children. 2. F / ∈ F u : (a) case S = S u : node u may switch to sleeping mode to conserve energy, or to receiving mode to snoop the neighborhood. (b) case S = S p u : node u switches to receiving mode to receive command and control information from parent, or snoop the neighborhood. If node u knows its parent's frame set F p u and knows F / ∈ F p u , it can switch to sleeping mode as well.</p><p>(c) case S = S c u : node u may switch to sleeping mode to conserve energy, or to receiving mode to snoop the neighborhood.</p><p>As described in Algorithm 2, if a slot is not scheduled for sending or receiving, a node can switch to sleeping mode to conserve energy and prolong network lifetime. For some up-layer protocols (e.g., ExOR <ref type="bibr" target="#b13">[13]</ref>) making use of snooping to improve communication efficiency, nodes may choose to stay at receiving mode. We will later show that TreeMAC remains collisions-free even at a snooper, hence these snooping-depended protocols will work effectively with TreeMAC.</p><p>In the following, we analyze the theory properties of TreeMAC protocol by adopting some simplified network models. We assume every node has the same transmission power, and a many-to-one routing protocol will generate a Shortest Path Tree (SPT), e.g., each node finds the lowest cost path to the root. We adopt the widely used protocol interferences model. In this model, a transmission by a node v i is successfully received by a node v j iff v j is not in the transmission range of the source of any other simultaneous transmission. The protocol interference model does not necessarily provide a comprehensive view of reality due to the aggregate effect of interference in wireless networks. However, it does provide some good estimations of interference and most importantly it enables a theoretical performance analysis of a number of protocols designed in the literature. We understand the interference is the sum of all emissions by interferers (e.g., unintended senders). However, if a interferer's radio signal reaches a node v weakly, which can not be decoded by node v, then v can not tell who the interferer is. It is reasonable to count these weak radio signals as background noises, which shall already be counted in the link quality measurement of routing protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. With TreeMAC protocol, for any node, at any time, there is at most one active sender in its neighborhood (including itself). We call it conflict-free packet sending/receiving and snooping.</head><p>Proof. In the literature, conflict-free packet scheduling usually means that packet sending/receiving is conflict-free. In other words, the concurrent communication pairs do not conflict with each other, e.g., sending and receiving are conflict free. Here TreeMAC supports a much stronger conflict-free packet scheduling: message snooping is also conflict-free. That is to say, even for a snooper, at any time, there is at most one active sender in its neighborhood. Snooping, uniquely enabled by the radio broadcast nature, has been used by many protocols <ref type="bibr" target="#b21">[21]</ref><ref type="bibr" target="#b22">[22]</ref><ref type="bibr" target="#b23">[23]</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b24">24]</ref> to reduce communication cost. The differences of those concepts are illustrated in Fig. <ref type="figure">5</ref>.</p><p>To prove conflict-free sending/receiving and snooping, it is equivalent to show that: given any node, at any time, there is at most one active sender in its neighborhood (including itself). We prove this result by inducing contradictions. Hypothesize that, two senders v and w send at same time and their messages collide at a receiver/snooper x. We will show this cannot happen with TreeMAC protocol.</p><p>The relationship of two senders v and w can be classified into the following three cases: <ref type="bibr" target="#b0">(1)</ref> The depth difference between v and w is 0. According to algorithm 1, they have same transmittable slot (e.g., S v = S w ), but have non-overlapped frames, since</p><formula xml:id="formula_2">F c i u F c j u = φ (if i = j)</formula><p>and so do their ascendants. Hence v and w cannot send concurrently. Contradiction is induced. (2) The depth difference between v and w is 1 or 2. According to algorithm 1, they must have different slots, since S u = ( u -1) mod 3 ∈ {0, 1, 2}. Hence v and w cannot send at the same time. Contradiction is induced.</p><p>(3) The depth difference between v and w is more than 2. First of all, if ( wv ) mod 3 equals 1 or 2, similar as above, they must have different slots and can never send at the same time. Then the only case left is ( wv ) mod 3 = 0. Indeed, they could transmit simultaneously, e.g., at the same slot in the same frame. W.L.O.G, we may assume wv = 3 (the other cases can be proved similarly). Also, notice that abs( x -v ) ≤ 1 since they communicate directly in a tree. Base on the hypothesis that node w can reach x, then x must be able to reach w too. Then if w chooses x as parent, then the depth of w should be reduced. Hence the given SPT would not be a shortest path tree. Contradiction is induced.</p><p>Consequently, the hypothesis is wrong. That is to say, given any node, there is at most one active sender in its neighborhood.</p><p>To our best knowledge, this is the first MAC protocol to support conflict-free snooping as well as conflict-free sending/receiving.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. TreeMAC protocol is a fair and bufferless packet scheduling protocol.</head><p>Proof. In Algorithm 1, each node u assigns the F c k u frame set to its child c k u , such that</p><formula xml:id="formula_3">F c i u F c j u = φ (if i = j) and size(F c i u ) = size(F u ) • β c i u /( c k u ∈C u β c i u + β u ).</formula><p>That is to say, children get a subset number of slots of their parent. The ratio</p><formula xml:id="formula_4">size(F c i u )/size(F c j u</formula><p>) is the ratio of their bandwidth demands. In other words, it is fair.</p><p>To show that it is bufferless, recall that parent and children have adjacent transmittable slots per frame, as illustrated in Fig. <ref type="figure">6</ref>. Once the parent receives a packet from a child, it could forward it up in the next slot (or the next frame). Hence, a parent does not need to buffer packets for more than one frame time. For example, as illustrated in Fig. <ref type="figure">6</ref>, a packet sent by node b in slot 1 is forwarded by node a in slot 0 of the next frame. In other words, the packet scheduling is bufferless and it minimizes the probability of network congestion. The bufferless scheduling is especially important in these resourceconstrained wireless sensor nodes since less memory is required to buffer the forwarding data. In addition, this also means that the sink node can receive a packet from its children in every frame. Theorem 3. The throughput of TreeMAC protocol is at least 1/3 of the optimum.</p><p>Proof. It is easy to see that the optimum solution is that, at most, the sink can receive a packet in every slot. With TreeMAC protocol, as illustrated in Theorem 2, the sink can receive a packet in every frame or every 3 time slots. Hence the throughput is bounded by 1/3 optimum.</p><p>In certain network configurations (if applicable), as illustrated in Fig. <ref type="figure" target="#fig_5">7</ref>, TreeMAC can even maximize the throughput to the optimum:</p><p>1. Configure three sinks to bridge sensor networks and a collector (e.g., a PC or laptop with a radio attached). 2. The i-th sink-tree uses i-th frequency channel for communications.</p><p>3. Each node u in the i-th sink-tree calculates its transmittable slot t u = ( u + i) mod 3 (including the sink with sink = 0), instead of t u = ( u -1) mod 3 in Algorithm 1. With this configuration, the three sinks may deliver data to the collector in a round-robin fashion: in each frame of each cycle, the i-th sink uses i-th channel in i-th slot to forward data to the collector. With this configuration, the collector can get data in every time slot, instead of every three time slots, the network throughput is therefore maximized to optimum. This network configuration is feasible, even preferred, in some field deployments <ref type="bibr" target="#b25">[25]</ref>. Using three different channels on three subnetworks increases system robustness and throughput. In case of broken links or link quality degradation in one subnetwork, the affected child node shall join the other subnetworks through the appropriate channel surfing <ref type="bibr" target="#b26">[26]</ref> technique. The basic idea is that, if a node cannot find a parent in one channel, it tunes to the other two channels. If it finds a better alternative parent node in channel i, it may switch to the channel i and connect to the new parent.</p><p>To our best knowledge, TreeMAC is the first localized TDMA MAC protocol to achieve all these nice theoretical properties: (1) sending/receiving and snooping are all conflict-free; (2) packet scheduling is fair and bufferless; (3) network throughput is bounded by a constant ratio of the optimum. Analysis establishes the theory foundation of TreeMAC, and our experiments later show that it indeed improves network throughput and reduces network congestion significantly in a real sensor network testbed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Performance analysis</head><p>We have proved that theoretically TreeMAC can achieve a network throughput bounded by 1/3 optimum and its bandwidth assignment is fair. Besides above properties, we further analyze the performance of TreeMAC from other aspects.</p><p>Delivery latency. Delivery latency is the time a packet takes to traverse from the source node to the gateway. Many multimedia applications such as video surveillance typically have stringent requirements on the packet delivery timeliness. In TreeMAC, once the parent receives a packet from a child, it will forward it in the next slot or the next frame. The next frame may be in a new cycle. Assume the TDMA cycle is T , then the average hop-delay is O(T /3). In a topology tree of size n, the average depth of each node is O(log n). The time taken by a packet to traverse to the gateway is O(log n) × O(T /3) = T /3 × O(log n). We can see that, when the network size is determined, the delivery latency is proportional to the TDMA cycle period T .</p><p>Responsiveness to topology dynamics. Topology dynamics are common in multi-hop wireless networks due to timevarying channel conditions, physical environmental changes, inaccurate link estimation, and node mobility. Handling the topology change requires a update of the transmission schedule. In TreeMAC, a parent node can immediately detect whether a node leaves/joins its children set by monitoring the continuous upstream data. So the convergence speed of the schedule update mostly depends on the time delay of the dissemination of scheduling messages. If a node u switches its parent from u p 0 to u p 1 and the common ancestor of u p 0 and u p 1 is u p , the bandwidth demand of the nodes on the path u p 0 → • • • → u p and u p 1 → • • • → u p will be affected as the amount of data they need to forward has changed and it requires an update in the bandwidth allocation. In the best case, the update takes places in merely one-hop range. In the worse case, u p is the sink. The time taken by the scheduling message to traverse hop by hop to get to intended nodes is T /3 × O(log n).</p><p>Control overhead. The control message overhead of TreeMAC is primarily the periodic scheduling messages. In the best case, the topology is a balanced tree, thus half of the nodes are leaves, who do not need to send out scheduling messages since they have no children. In this case, the control message overhead is n/(2T S ). Here T S is the schedule beaconing period. In the worse case, the topology is a line and only one node is a leaf. So the message cost is (n -1)/T S .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">TreeMAC implementation</head><p>In this section, we introduce the implementation of TreeMAC in the TinyOS-1.x [27] operating system, running on the iMote2 sensor network platform. The Imote2 sensor mote is an advanced wireless sensor node platform. It is equipped with 256 KB SRAM, 32 MB SDRAM, and an 802.15.4 compliant radio chip CC2420 which provides an effective data rate of 250 kbps. Its PXA271 processor can be configured to work from 13 MHz to 416 MHz. We configured its PXA271 processor to operate in a low voltage (0.85 V) and low frequency (13 MHz) mode in normal operations.</p><p>The implementation adopts a cross-layer design to have a joint optimization, as illustrated in Fig. <ref type="figure" target="#fig_8">8</ref>. It learns its parent and children set from the network layer. The link reliability known from transmission statistics in the link layer helps each node to allocate frames proportionally for its children based on demands. We activate the CCA (Clear Cannel Assessment) function of the CC2420 radio to enhance the protocol robustness and ease the need of fine-grained time synchronization. During the transmittable slots, a node starts transmission only when the CCA indicates the channel is idle. The CC2420 radio will backoff for a random period bounded by a time window when it detects the channel as busy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">System initialization</head><p>When the network starts, every node runs CSMA to discover its neighbors, run data collection routing protocols and establish time synchronization. Once the network is time synchronized, the sink node initializes the TreeMAC mode by assigning schedules to its children. For any node who receives schedules from its parent, it will switch to TreeMAC mode and start to assign the frames to its own children as well. During the transition period from CSMA to TreeMAC mode, some nodes in CSMA mode may potentially compete for channel access with those nodes in TreeMAC mode. To avoid this, nodes in CSMA mode are set with longer initial backoff window and congestion backoff window, hence have less opportunity to grasp the channel. After all, those nodes in CSMA mode will eventually switch to TreeMAC mode, as each parent will announce the schedule periodically.</p><p>When nodes are in TreeMAC mode, congestion backoff is enabled to resist interference from external environments. A white paper published by a European manufacturing group (associated with the development of a competing standard, Z-Wave) claims that wireless technologies such as ZigBee, which operate in the 2.4 GHz RF band, are subject to significant interference-enough to make them unusable <ref type="bibr" target="#b27">[28]</ref>. It claims that this is due to the presence of other wireless technologies like Wireless LAN in the same RF band. For example, the typical TX power output of Wi-Fi transceiver is up to 20 dBm, while the maximum signal strength of most 802.15.4 radio chips is no more than 0 dBm <ref type="bibr">[29]</ref>. It is obvious that a Wi-Fi signal can easily overwhelm the 802.15.4 radio signal. This is also confirmed in our lab experiments. We set a pair of sensor nodes S (sender) and R (receiver) to maximum power level 0 dBm. It shows that when either initial backoff (the delay before a packet transmission is attempted on the channel) or congestion backoff (the backoff time period when the channel is sensed busy) is turned off, the radio link between S and R suffers high packet loss up to 20%, while in the case they are turned on, the packet loss is near 0. Moreover, CSMA uses a large backoff window size to avoid high channel intention and successive collision. On the contrary, the most significant interference for TreeMAC is external, rather than inter-node, therefore a shorter backoff window is preferred to provide better throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Time synchronization</head><p>In the literature, there are several known solutions on time synchronization <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b11">11]</ref>. In our testbed experiments, we adopt FTSP <ref type="bibr" target="#b11">[11]</ref> (Flooding Time Synchronization Protocol), a multi-hop time synchronization protocol, which achieves high precision performance by utilizing MAC-layer time stamping and comprehensive error compensation including clock skew estimation. In the original FTSP work <ref type="bibr" target="#b11">[11]</ref>, timing errors of less than 67 µs were reported for an 11-hop network of Mica2 nodes. The protocol worked well in laboratory experiments. However, the original FTSP does not check the validity of synchronization messages, so a node reading an incorrect value can corrupt the calculation of the global time. In our implementation, the corrupted packet will be filtered to guarantee that only FTSP packets with the correct time are processed to get an accurate global time. In our experiments, the timing errors normally are no more than 1 ms (the time service to measure the error is of 1 ms resolution). That meets the requirements of TreeMAC since we enable CCA carrier sensing to ease the need of fine-grained time synchronization. FTSP synchronizes all nodes' time to a global clock, but it does not guarantee time slots are aligned since different nodes may start their timer at different time points. To solve that problem, we designed a RTC (Real Time Clock) module, which maintains a millisecond resolution timer, with the support of iMote2's microsecond resolution clock. The timer service provided by RTC is different from the default timer service in TinyOS <ref type="bibr">[27]</ref>; it synchronizes its clock value t to the UTC time and fires based on the clock value instead of the interval. In other words, the timer fires when the clock value t satisfies t%T = 0, where T is the sampling interval. For example, if T = 10 ms and the timer starts at 20 : 00 : 00 : 422, then the next fire point is 20 : 00 : 00 : 430, not 20 : 00 : 00 : 432. This enables strict synchronized timing event triggering: the slot timer of all nodes in the network will trigger at the same time point. However, time synchronization with FTSP may still have milliseconds of errors, and cause unaligned time slots. The problem is exacerbated in a multi-hop network. To prevent such mismatch errors from propagating to new cycles, TreeMAC uses two timers of millisecond resolution for transmission scheduling: slot timer and cycle timer. When the cycle timer fires, it stops and restarts the slot timer, so that the slot timer gets re-synchronized in each cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Obtaining tree structure information</head><p>TreeMAC protocol does not need separate tree formation and maintenance. Instead, it obtains the parent and children information from the routing tables of data collection routing protocol. In our implementation, we utilized an improved version of MultiHopLQI in TinyOS-1.x as the routing protocol. MultiHopLQI is a distance vector routing protocol that proactively discovers a path of lowest cost to the gateway for each node.</p><p>TreeMAC updates its frame-slot assignment periodically according to an updated routing table and traffic. In data collection routing, the parent information is easy to get, but children information is not obvious as we can only passively learn whether a child is alive or has left. In our implementation, we designed a neighbor management module linked to the routing module, which maintains the children set information based on upstream packets. Every time a sensor node receives a packet from a child, the liveliness of that child is set to a maximum value δ. When the liveliness times out, that is δ reaches 0, the child is removed from the children set. There is a tradeoff between the responsiveness to topology change and the protocol robustness. With a smaller δ, topology change can be detected with a shorter latency. However, sometimes a sensor node may fail to receive packets successfully from a child for a certain period due to network congestion. It is observed from our test bed that sometimes some part of the network is ''frozen'' for up to a few seconds because of high contention. That is to say, no packets from the nodes in that part of the network arrive at the sink during that period. We choose δ = 6 s as an appropriate value, based on our experimental test.</p><p>If a node changes parent during a cycle, we do not adjust frame and slot assignment immediately; instead, we wait until next cycle. We agree there could be some temporal mismatch, but it does not necessarily break the foundation: the number of time slots in depth-are no less than the sum of the number of time slots in depth-( + 1) and the number of slots for the depth-nodes' own data. Hence this temporal side effect is limited. In other words, TreeMAC is not fragile to tree topology updates; instead, it just makes use of the routing tree structure and its performance is not necessarily affected by topology changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Frame-slot schedule assignment and adjustment</head><p>After parent-child relationships are known, every node assigns frames to its children periodically. When a network stabilizes, the frame-slot schedule assignment run less frequently.</p><p>Before assigning frames, a parent node needs to collect the bandwidth demand of its children. At the first glance, a node's bandwidth demand will be the total data rate R of its subtree (including itself). However, nodes may have different link reliability toward their parents. To ensure fairness, we adjust the bandwidth demand level to R/p, where p is the link reliability of a node to its parent. To notify its parent of its bandwidth demand, a sensor node piggybacks this information in upstream packets. Originally the demand information is piggybacked in routing beacon messages. The advantage is that the signaling overhead is rather low. However, because beacon packets do not require acknowledgement, they are likely to be lost. In addition, the beacon interval can be as large as several cycles. As a result that may make TreeMAC not responsive enough to topology update (topology update will result in change of bandwidth demand). On the contrary, piggyback throughput upstream packets can provide much better reliability and consistency.</p><p>As described in the algorithm 1, every node uses a round robin method to assign frames to its children based on their proportional bandwidth demand. In our implementation, by default the number of frames per cycle is 24 and each slot is 20 ms. To guarantee that every node has an opportunity to transmit data, each node is at least assigned one frame if its bandwidth demand is not 0. If the total number of required frames is more than 24, TreeMAC can increase the cycle size adaptively to meet the demand. Although TreeMAC algorithm supports fraction frame allocation, that is multiple nodes share the same frame in different cycles in a round robin way when the network size is large, the current implementation only supports integer frame allocation. We also allow multiple packets transmission in one time lot, if possible. The basic principle is that each node should fully utilized its own slots. How to efficiently encode schedules for children is also important to reduce the control message overhead. Normally encoding a frame's position in a cycle of size N can take up to the order of log N bits. In our design,a bitmap is utilized to improve the schedule encoding efficiency. Each bit in the bitmap denotes a corresponding frame in each cycle. In a schedule message (see Fig. <ref type="figure" target="#fig_9">9</ref>), a bitmap that encodes a node's schedule follows its address. A bit set as '1' in the bitmap denotes an assigned frame.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1.">Maximize channel utilization</head><p>TreeMAC is primarily designed to support multi-hop TDMA, but there are nodes of depth less than 3. For those nodes, it is a waste to use only one slot of each assigned frame, since their data only require one-hop forwarding or even fewer. We improve the channel utilization by using Algorithm 3 to determine the transmittable slot of each assigned frame. For instance,  nodes with a depth of 1 do not need intermediate nodes to forward data for them, so they can use all 3 slots of each assigned frame. That enables TreeMAC to seamlessly support one-hop TDMA without the sacrifice of channel utilization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 Maximize Channel Utilization</head><p>Each node u of network depth u takes the following actions for each assigned frame: switch( u )</p><p>1. case u ≤ 1: S u ← 0, 1, and 2; 2. case u is 2: S u ← 0 and 1; 3. default: S u ← u mod 3;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5.">Pipelined sending and receiving between layers</head><p>TinyOS-1.x is an event-driven system and does not support multi-threading. In the recommended practice of TinyOS, an up-layer component cannot send another message to a low-layer component until the sendDone event of the previous message is received, which could cause a big gap between two consecutive sends. Fig. <ref type="figure" target="#fig_10">10</ref> (a) illustrates this issue. Similar situations happen during receiving. We enable pipelined sending/receive approach through buffering messages in sending/receiving queues at each layer, as illustrated in Fig. <ref type="figure" target="#fig_10">10 (b</ref>). Pipelined sending/receiving helps to improve the performance of a TDMA MAC protocol. Because when using a TDMA protocol, once a node is assigned a time slot, the node should use the slot efficiently, especially when high throughput is demanded. However, in the simplex approach, when a packet is sent by the MAC layer, the MAC module will signal up a sendDone message, usually via posting a task. And only after the original sender processes the sendDone event, will it make another send request to MAC component. In this way, precious channel time is wasted. In the design of TreeMAC, we overcome the problems by adding queues at each communication component. In this way, when the MAC layer finishes sending out one packet, it will immediately fetch the next packet in the queue, instead of waiting for the upper layer to send down a new packet.</p><p>In addition, the queue size in upper layer shall be no bigger than that in lower layer. Otherwise when the queue in lower layer cannot accommodate more messages, new incoming messages from upper layer will fail to be transmitted. Moreover, we observe that for intermediate nodes, locally originated packets have a higher privilege to be stored and sent, while forwarding packets are unfavored. We mitigate that problem by restricting the queue size in application layer to be no more than 1  3 of that in the network layer.  Moving average factor α 0.9</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Sensor testbed evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Experiment method</head><p>We conducted experiments on a sensor network testbed with 24 Imote2 motes. The sensor nodes are placed in a 4 × 6 grid without any obstruction. Fig. <ref type="figure" target="#fig_11">11</ref> shows a snapshot of the network topology on the testbed. The data payload size is 74 bytes. We conducted experiments with varying network traffic and network topologies to evaluate the capacity of TreeMAC compared to Funneling-MAC and CSMA (the default MAC protocol in TinyOS-1.x for CC2420 radio). Originally, Funneling-MAC is only implemented on a mica2 platform that uses CC1000 radio, so we ported it to a CC2420 radio. The only change made is scaling the power level. The power level range in CC2420 is <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">31]</ref> while that in CC1000 is <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">255]</ref>. The maximum TX power output is 0 dBm for both radio chips. We did not compare TreeMAC to Z-MAC <ref type="bibr" target="#b19">[19]</ref> and B-MAC <ref type="bibr" target="#b3">[4]</ref>, because Funneling-MAC <ref type="bibr" target="#b0">[1]</ref> has shown better performance than them. Tables <ref type="table" target="#tab_0">1</ref> and<ref type="table" target="#tab_1">2</ref> show the value of key parameters for TreeMAC and Funneling-MAC respectively in evaluation experiments. We use USB cable to supply power for sensor nodes to prevent their performance from being effected by battery power level. Under each network condition, the same experiment is repeated 5 times to get an average. In the experiments, network throughput, energy efficiency, network fairness, signaling overhead are compared between TreeMAC, Funneling-MAC and CSMA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Network throughput</head><p>One primary goal of TreeMAC is to achieve higher network throughput. We measure the network throughput by calculating how many data packets are successfully delivered to the sink from all nodes in one second.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1.">Throughput v.s. data rate</head><p>First, we evaluated the network throughput with a varying data rate and fixed network size 24. We conducted the experiment by varying the data rate of each node at 5 levels: 4, 6, 8, 10 and 12 pps (packet per second). The results in  Fig. <ref type="figure" target="#fig_12">12</ref> show that, when the injected data rate is 10 pps, all the three MAC protocols achieve their best throughput: the mean throughput for TreeMAC, Funneling-MAC and CSMA are 59.03 kpbs, 38.90 kpbs and 32.04 kpbs respectively. Between the window of [4 pps, 10 pps], the throughput increases as more data are injected. This is because the total data rate does not exceed the network capacity. Within the window of <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b12">12]</ref>, the network is congested and results in a decreasing throughput with a growth of data rate. Moreover, Fig. <ref type="figure" target="#fig_12">12</ref> shows that TreeMAC always achieves the best throughput compared to Funneling-MAC and CSMA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2.">Throughput v.s. network size</head><p>We also evaluated network throughput with varying network size and fixed data rate 8 pps. We conducted the experiment by varying network size at 5 levels: 8, 12, 16, 20, 24. Fig. <ref type="figure" target="#fig_13">13</ref> shows that the throughput increases as the network size varies from 8 nodes to 24 nodes. Also, TreeMAC outperforms Funneling-MAC 50%-90% for all experimented network sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3.">Throughput v.s time</head><p>We next investigated the throughput stability of TreeMAC at running time. With a network size of 24 nodes and a data rate of 8 pps, we ran the experiments for a long time and measured the throughput for each 5-min time window. The comparison between TreeMAC and Funneling-MAC is shown in Fig. <ref type="figure" target="#fig_14">14</ref>. We can see that at the beginning the throughput is slightly lower. That is because FTSP requires at least 4 time synchronization messages to get a node synchronized to the global time. After that, the throughput of TreeMAC keeps around 47 kbps with a fluctuation of no more than ±7 kbps. This shows that TreeMAC is robust with respect to dynamic topology (such as routing path changes) and can obtain stable performance in the long run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Energy efficiency</head><p>Maximizing energy efficiency is always an important goal to achieve in MAC protocol design. Energy efficiency <ref type="bibr" target="#b29">[30]</ref> is defined as the ratio of the number of delivered distinct packets to the gateway over the total number of packet transmissions in the network. The total number of transmissions includes all link layer retransmissions, as well as transmissions associated with packets that are dropped or corrupted. The energy efficiency η is formally defined as: η = d∈D hops(d) p∈P h∈hops(p) xmits(p,h) . It is a value between 0 and 1. D is the set of packets delivered to the sink; P is the set of all injected packets; hops(p) ranges over each hop packet p traverses; xmits(p, h) denotes the number of transmissions a packet p undergoes at hop h.  We evaluate the energy efficiency by fixing network size at 24 and varying data rate at 5 levels: 4, 6, 8, 10 and 12 pps (packet per second). Fig. <ref type="figure" target="#fig_15">15</ref> shows that both TreeMAC and Funneling-MAC save more energy than CSMA. This is the advantage of TDMA MAC protocol, as the media spectrum is scheduled for access. It is also shown that, TreeMAC is more energy efficient than Funneling-MAC. Especially when the data rate is above 10 pps, the gain is up to twice more energy efficient compared to Funneling-MAC. The high energy efficiency of TreeMAC lies in the fact that TreeMAC assigns slots according to proportional bandwidth demand. TreeMAC would rather drop a packet at the source node, than drop it at the intermediate nodes. In wireless network, buffer overflow occurs when a parent node has to discard a received packet from its children because its buffer queue is full. If children nodes send more packets than their parents can handle, it will result in buffer overflow. This experiment further proves that in data collection networks, slot reuse maximization based on graph coloring does not necessarily mean throughput maximization to the sink. Appropriate slot reuse in TreeMAC actually improves throughput and reduces energy cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Energy consumption</head><p>In a data collection network, nodes of different depths have varying energy consumption depending on the amount of data they need to transmit. Fig. <ref type="figure" target="#fig_16">16</ref> shows the comparison of average per node energy consumption. When the data rate is low, the energy consumption among CSMA, Funneling-MAC, and TreeMAC is almost at the same level. But as the data rate increases to 12 pps, the energy consumption of CSMA is much higher than Funneling-MAC and TreeMAC due to link layer retransmissions caused by collision; the energy consumption of TreeMAC is also lower than Funneling-MAC by 31.7% at the rate of 12 pps. That is because Funneling-MAC applied CSMA to the nodes outside of the intensity region and collisions are still likely to happen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5.">Network fairness</head><p>When a sensor network is deployed, users are typically interested in getting real-time data from the whole monitored area. However, high channel contention in a sensor network can cause channel starvation for some nodes/areas. We expect all nodes in a sensor network can fairly deliver their packets to the sink. We utilize the definition of fairness index φ from <ref type="bibr" target="#b29">[30]</ref>: φ =</p><formula xml:id="formula_5">( N k=1 r i ) 2</formula><p>N× N k=1 r i  If each node sends the same number of packets to the sink, then the fairness index is 1. Fig. <ref type="figure" target="#fig_17">17</ref> shows the comparison of fairness among TreeMAC, Funneling-MAC and CSMA. It shows that as the data rate varies from 4 pps to 12 pps, TreeMAC always achieves a network fairness above 85%. Also, we can see that, with TreeMAC, varying data rate does not affect the fairness much. That is because TreeMAC assigns slots proportionally to each node's bandwidth demand. It is interesting to note that Fig. 17 also shows that CSMA is better than Funneling-MAC in terms of fairness. The reason may be that, those nodes outside of the funneling region may still overflow the buffer of the nodes in the funneling region, as they are not controlled by the Funneling-MAC protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.">Signaling overhead</head><p>Both TreeMAC and Funneling-MAC use a TDMA mechanism, and thus have some signaling overhead. CSMA does not need extra control messages, so we only compare the signaling overhead between TreeMAC and Funneling-MAC. The signaling overhead is the dissemination of bandwidth demand and frame-slot schedule messages. For Funneling-MAC, the signaling overhead includes beacon packets, schedule packets, path information field, and meta-schedule. The signaling overhead index is defined as the ratio of total control packet bits over total data bits that reach the sink. Fig. <ref type="figure" target="#fig_18">18</ref> illustrates that the signaling overhead index of TreeMAC is less than 0.0025 for all tested data rates. TreeMAC achieves lower signaling overhead than Funneling-MAC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion and future work</head><p>Many-to-one communication pattern is fundamentally different from random any-to-any communication pattern, where equal channel access does not mean fairness and slot reuse maximization based on graph coloring does not mean data throughput maximization to the sink. TreeMAC is an innovative localized TDMA MAC protocol and designed to achieve high throughput and low congestion with low overhead, by utilizing unique characteristics of data collection networks. We have shown the nice properties of TreeMAC in theory and demonstrated that it achieves much better throughput and energy efficiency than CSMA and Funneling-MAC <ref type="bibr" target="#b0">[1]</ref> in a real sensor network test bed.</p><p>In the design of TreeMAC protocol, time synchronization precision has significant impact on its performance. Meanwhile, as is mentioned in Section 5, FTSP has the problem of propagated synchronization error, as a result of which the synchronization error will increase as the hop count to the FTSP root increases. That obviously effects the scalability of TreeMAC. In this paper, the problem is mitigated by using a cycle timer and a slot timer at the same time. Our future work is to make TreeMAC get rid of the need for global time synchronization.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The fairness of MAC protocol in data gathering scenarios. In the figure, the numbers denote the bandwidth demand of corresponding links.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The pattern of bandwidth demand. T ( ) denotes the demand of the depth-nodes. D( ) indicates the bandwidth demand for the depth-nodes' own data.</figDesc><graphic coords="4,193.74,53.10,153.06,80.09" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Relationship of cycle, frame and slot: cycle = N • frames = 3N • slots. In this illustration, N = 16.</figDesc><graphic coords="4,159.40,165.44,221.82,58.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4.Frame and slot assignment illustration in an example tree. For each node, the bar illustrates its frame assignment, and the number denotes its transmittable slot in its assigned frame.</figDesc><graphic coords="4,154.22,249.26,232.26,145.42" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>6. c k u ∈ C u : the kth child of node u.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>7 .</head><label>7</label><figDesc>p u : the parent of node u.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .Fig. 6 .</head><label>56</label><figDesc>Fig. 5. The definition of conflict-free. (Left) conflict-free sending/receiving. Concurrent transmissions v → u and w → y are conflict-free, but collide at a snooper x. (Right) conflict-free sending/receiving and snooping. Concurrent transmissions v → u and w → y are conflict-free, and have no collisions at snooper x.</figDesc><graphic coords="6,163.18,53.09,214.26,78.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Possible network configuration to maximize throughput: (1) three sinks are used to bridge sensor networks and a collector. (2) three different sink trees use three different channels; (3) given a node u in the sub-tree of sink i, the transmittable slot t u = ( u + i) mod 3.</figDesc><graphic coords="7,203.11,53.09,141.90,83.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The cross layer design of TreeMAC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Schedule encoding using bitmap: In the illustrated example, the bitmap for child k is 0 × 0830, which child k is assigned frames: 5, 6, 12.</figDesc><graphic coords="10,275.80,159.30,196.62,157.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. TinyOS communication stack optimization.</figDesc><graphic coords="10,68.36,159.30,197.70,157.54" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Snapshot of network topology on the testbed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Network throughput v.s. data rate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Network throughput v.s. data rate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Network throughput v.s. data rate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Energy efficiency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Average per node energy consumption.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. Network fairness.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 18 .</head><label>18</label><figDesc>Fig. 18. Signaling overhead.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>TreeMAC experiment parameters.</figDesc><table><row><cell>Parameter</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc>Funneling-MAC experiment parameters.</figDesc><table><row><cell>Parameter</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>. Here, r i is the average rate of packets delivered from the ith sensor and N is the number of sensors in the network.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>$ This work is supported by NASA ESTO AIST program and USGS Volcano Hazard program under the research grant NNX06AE42G.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Funneling-MAC: A localized, sink-oriented MAC for boosting fidelity in sensor networks</title>
		<author>
			<persName><forename type="first">G.-S</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Miluzzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">T</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Cuomo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th ACM Conference on Embedded Networked Sensor Systems, SenSys</title>
		<meeting>4th ACM Conference on Embedded Networked Sensor Systems, SenSys<address><addrLine>Boulder, CO, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Time-optimum packet scheduling for many-to-one routing in wireless sensor networks</title>
		<author>
			<persName><forename type="first">W.-Z</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lahusen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd IEEE International Conference on Mobile Ad-hoc and Sensor Systems</title>
		<meeting>3rd IEEE International Conference on Mobile Ad-hoc and Sensor Systems<address><addrLine>MASS, Vancouver BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An energy-efficient MAC protocol for wireless sensor networks</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Es</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st International Annual Joint Conference of the IEEE Computer and Communications Societies, INFOCOM</title>
		<meeting>21st International Annual Joint Conference of the IEEE Computer and Communications Societies, INFOCOM<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-04">Apr. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Versatile low power media access for wireless sensor networks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Polastre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd ACM Conference on Embedded Networked Sensor Systems, SenSys</title>
		<meeting>2nd ACM Conference on Embedded Networked Sensor Systems, SenSys<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Design and deployment of industrial sensor networks: Experiences from the north sea and a semiconductor plant</title>
		<author>
			<persName><forename type="first">R</forename><surname>Adler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Buonadonna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chhabra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Flanigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kushalnagar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Nachman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yarvis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pro. 3rd ACM Conference on Embedded Networked Sensor Systems, SenSys</title>
		<meeting><address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-11">Nov. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fidelity and yield in a volcano monitoring sensor network</title>
		<author>
			<persName><forename type="first">G</forename><surname>Werner-Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lorincz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lees</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>7th USENIX Symposium on Operating Systems Design and Implementation<address><addrLine>OSDI, Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">W.-Z</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimized autonomous space in-situ sensor-web for volcano monitoring</title>
		<author>
			<persName><forename type="first">B</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shirazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lahusen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kedar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Chien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Webb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pallister</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dzurisin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lisowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><surname>Pieri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2008 IEEE Aerospace Conference</title>
		<meeting><address><addrLine>Big Sky, MT, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-03">Mar. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A wireless sensor network for structural monitoring</title>
		<author>
			<persName><forename type="first">N</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rangwala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">K</forename><surname>Chintalapudi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ganesan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Broad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd ACM Conference on Embedded Networked Sensor Systems, SenSys</title>
		<meeting>2nd ACM Conference on Embedded Networked Sensor Systems, SenSys<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Multi-purpose wireless accelerometers for civil infrastructure monitoring</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Pakzad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">L</forename><surname>Fenves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Glaser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Demmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th International Workshop on Structural Health Monitoring, IWSHM</title>
		<meeting><address><addrLine>Stanford, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-09">Sep. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fine-grained network time synchronization using reference broadcasts</title>
		<author>
			<persName><forename type="first">J</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Girod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>5th USENIX Symposium on Operating Systems Design and Implementation<address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-12">Dec. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The flooding time synchronization protocol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Maróti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kusy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lédeczi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd International Conference on Embedded Networked Sensor Systems, SenSys</title>
		<meeting>2nd International Conference on Embedded Networked Sensor Systems, SenSys<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Timing-sync protocol for sensor networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ganeriwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st International Conference on Embedded networked sensor systems</title>
		<meeting>1st International Conference on Embedded networked sensor systems<address><addrLine>SenSys, Los Angeles, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-11">Nov. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Exor: opportunistic multi-hop routing for wireless networks</title>
		<author>
			<persName><forename type="first">S</forename><surname>Biswas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Morris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Annual Conference of the Special Interest Group on Data Communication, SIGCOMM</title>
		<meeting><address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-08">Aug. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">TreeMAC: Localized TDMA MAC protocol for high-throughput and fairness in sensor networks</title>
		<author>
			<persName><forename type="first">W.-Z</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shirazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lahusen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 7th Annual IEEE International Conference on Pervasive Computing and Communications</title>
		<meeting><address><addrLine>PerCom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-03">March 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An adaptive energy-efficient MAC protocol for wireless sensor networks</title>
		<author>
			<persName><forename type="first">T</forename><surname>Van Dam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Langendoen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st ACM Conference on Embedded Networked Sensor Systems</title>
		<meeting>1st ACM Conference on Embedded Networked Sensor Systems<address><addrLine>SenSys, Los Angeles, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-11">Nov. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A transmission control scheme for media access in sensor networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Annual International Conference on Mobile Computing and Networking</title>
		<meeting>7th Annual International Conference on Mobile Computing and Networking<address><addrLine>MOBICOM, Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-07">Jul. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Energy-efficient, collision-free medium access control for wireless sensor networks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Rajendran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Obraczka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Garcia</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st ACM Conference on Embedded Networked Sensor Systems</title>
		<meeting>1st ACM Conference on Embedded Networked Sensor Systems<address><addrLine>SenSys, Los Angeles, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-11">Nov. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Analysis of a hybrid access scheme for buffered usersprobabilistic time division</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ephremides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">A</forename><surname>Mowafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="52" to="61" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A hybrid MAC for wireless sensor networks</title>
		<author>
			<persName><forename type="first">I</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Warrier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Aia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z-Mac</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd ACM Conference on Embedded Networked Sensor Systems, SenSys</title>
		<meeting>3rd ACM Conference on Embedded Networked Sensor Systems, SenSys<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-11">Nov. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Randomized dining philosophers to TDMA scheduling in wireless sensor networks</title>
		<author>
			<persName><forename type="first">I</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Warrier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004-04">Apr. 2004</date>
			<pubPlace>Raleigh, NC</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, North Carolina State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On accurate measurement of link quality in multi-hop wireless mesh networks</title>
		<author>
			<persName><forename type="first">K.-H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Annual International Conference on Mobile Computing and Networking, MOBICOM</title>
		<meeting>12th Annual International Conference on Mobile Computing and Networking, MOBICOM<address><addrLine>Los Angeles, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-09">Sep. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">RBP: Robust broadcast propagation in wireless networks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Stann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heidemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shroff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z</forename><surname>Murtaza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th International Conference on Embedded Networked Sensor Systems</title>
		<meeting>4th International Conference on Embedded Networked Sensor Systems<address><addrLine>SenSys, Boulder, CO, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11">Nov. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Smart gossip: An adaptive gossip-based broadcasting service for sensor networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kyasanur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd IEEE International Conference on Mobile Ad-hoc and Sensor Systems</title>
		<meeting>3rd IEEE International Conference on Mobile Ad-hoc and Sensor Systems<address><addrLine>MASS, Vancouver BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10">Oct. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cacades: A reliable dissemination protocol for data collection sensor network</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Shirazi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 IEEE Aerospace Conference</title>
		<meeting><address><addrLine>Big Sky, MT, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-03">Mar. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<ptr target="http://sensorweb.vancouver.wsu.edu" />
		<title level="m">OASIS: Optimized Autonomous Space In-Situ Sensor Web</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Channel surfing: Defending wireless sensor networks from jamming and interference</title>
		<author>
			<persName><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Trappe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Information Processing in Sensor Networks, IPSN</title>
		<meeting><address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-04">Apr. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">WLAN Interference to IEEE802</title>
		<author>
			<persName><surname>Bgp</surname></persName>
		</author>
		<ptr target="http://www.z-wavealliance.org" />
		<imprint>
			<date type="published" when="2007-03">Mar. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<ptr target="http://focus.ti.com/docs/prod/folders/print/cc2420.html" />
		<title level="m">Data Sheet</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Mitigating congestion in wireless sensor networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jamieson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd International Conference on Embedded networked sensor systems, SenSys</title>
		<meeting>2nd International Conference on Embedded networked sensor systems, SenSys<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-11">Nov. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
