<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Non-commutativity and MELL in the Calculus of Structures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alessio</forename><surname>Guglielmi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dresden Fakultät Informatik</orgName>
								<orgName type="institution">Technische Universität</orgName>
								<address>
									<postCode>01062</postCode>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lutz</forename><surname>Straßburger</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dresden Fakultät Informatik</orgName>
								<orgName type="institution">Technische Universität</orgName>
								<address>
									<postCode>01062</postCode>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Non-commutativity and MELL in the Calculus of Structures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">87FB35B34CF94081A0BD6CB7ED17F63D</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:28+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce the calculus of structures: it is more general than the sequent calculus and it allows for cut elimination and the subformula property. We show a simple extension of multiplicative linear logic, by a self-dual noncommutative operator inspired by CCS, that seems not to be expressible in the sequent calculus. Then we show that multiplicative exponential linear logic benefits from its presentation in the calculus of structures, especially because we can replace the ordinary, global promotion rule by a local version. These formal systems, for which we prove cut elimination, outline a range of techniques and properties that were not previously available. Contrarily to what happens in the sequent calculus, the cut elimination proof is modular.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The sequent calculus <ref type="bibr" target="#b4">[5]</ref> is very appropriate for classical logic, but it has some problems in dealing with more refined logics like linear logic <ref type="bibr" target="#b5">[6]</ref>. Observing certain logical relations in the sequent calculus might be impossible. In this paper we show a calculus, called the calculus of structures, which is able to overcome those difficulties. We call calculus a framework, like natural deduction or the sequent calculus, for specifying logical systems. We say formal system to indicate a collection of inference rules in a given calculus. A derivation is a composition of instances of inference rules, a proof is a derivation free from hypotheses.</p><p>A proof in the sequent calculus is a tree, and branching occurs when two-premise rules are used. The two branches are statements that proofs exist for both premises. At the meta level, we say that the left branch is a proof and the right branch is a proof. In classical logic, this 'and' corresponds to the 'and' at the object level. This is not the case in other logics, like in linear logic.</p><p>Another founding property of the sequent calculus is the pivotal rôle of main connectives. Given a main connective in the conclusion, a rule gives meaning to it by saying that the conclusion is provable if subformulae obtained by removing the connective are in turn provable.</p><p>These two properties together have remarkable success in making the study of systems independent of their semantics, which is important if a semantics is incomplete, missing or still under development, as often happens in computer science. The problem is that the sequent calculus is unnecessarily rigid for some logics. We can relax the 'and' branching between premise trees, and abandon the decomposing of the conclusion around the main connective of one of its formulae. The question is whether we can do so while keeping the good properties, cut elimination especially.</p><p>The calculus of structures draws from a very simple principle, which is very dangerous if not realised with care. The inference rules are of the kind S{T } ρ S{R} , where premise and conclusion are structures, i.e., formulae subject to certain equivalences (associativity, commutativity, units, . . . ). A structure S{R} is a structure context S{ }, whose hole is filled by the structure R. The rule scheme ρ above specifies that if a structure matches R, in a context S{ }, it can be rewritten as specified by T , in the same context S{ } (or vice versa if one reasons top-down). A rule corresponds to implementing in the formal system any axiom T ⇒ R, where ⇒ stands for the implication we model in the system. The danger lies in the words 'any axiom'.</p><p>In fact, rules could be used as axioms of a generic Hilbert system, where there is no special, structural relation between T and R. But then all the good proof theoretical properties would be lost. Our challenge is to design inference rules in a way that is conservative enough to allow us to prove cut elimination, and such that they possess the subformula property. Still we have to be liberal enough to overcome the problems of rigidity mentioned above.</p><p>It is important to note that the calculus of structures is more general than the sequent calculus, for logics with De Morgan rules. Any system that admits a one-sided presentation can be ported, trivially, to the calculus of structures. But, since we can do more, we want to use the new expressive capabilities to get new logics, or to make old logics better. We will do both things in this paper (without paying a big price).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rules come in pairs,</head><p>S{T } ρ↓ S{R} (down version) and S{ R} ρ↑ S{ T } (up version), where Ū is the negation of U and S stands for any context. This duality derives from the duality between T ⇒ R and R ⇒ T . We would like to dispose of the up rules without affecting provability-after all, T ⇒ R and R ⇒ T are equivalent statements in many logics. The cut rule splits into several up rules, and this makes for a modular decomposition of the cut elimination argument, since we can get rid of up rules one after the other. This is one the main achievements of our paper (in <ref type="bibr" target="#b6">[7]</ref>, p. 15, Girard deems as 'rather shocking' this lack of modularity in the sequent calculus). Derivations in the calculus of structures are chains of instances of rules. Contrarily to what happens in the sequent calculus, whose derivations are trees, our derivations have a top-down symmetry. This allows for new manipulations of derivations. For example, permuting down certain rules, like the cut, is easier than in the sequent calculus; entire derivations may be flipped upside down and negated and they still are valid derivations; and so on. The most important consequence of the new symmetry is that the cut rule S{(R, R)} i↑ S{⊥} becomes top-down symmetric to the identity rule S{1} i↓ S{[R, R]} (here, (R, T ) and [R, T ] denote the conjunction and the disjunction of R and T , and 1 and ⊥ are the conjunctive and disjunctive units). It is then possible to reduce the cut rule to its atomic variant S{(a, ā)} a↑ S{⊥} , the same way as identity can be just required for atoms in most systems in the sequent calculus. The reduction of cut to its atomic form simplifies the cut elimination argument, since there is no more interaction between a cut's principal formula and the structure of the proof. We believe that the development of a calculus must be driven by its systems. Here we develop two systems inside the calculus of structures. The first one, in Sect. 2, is system BV (Basic system V ) <ref type="bibr" target="#b7">[8]</ref>. It is equivalent to multiplicative linear logic plus mix, extended by a non-commutative self-dual operator. System BV is motivated by the desire to grasp a sequential operator, like that of CCS <ref type="bibr" target="#b11">[12]</ref>, in a logical system, especially from a proof-search perspective. The logic obtained seems not to be expressible in the sequent calculus, certainly not in a simple way, while in our calculus it is straightforward. System BV is just a first, but crucial step toward a logical system encompassing languages of distributed computation. The methodology for designing systems, induced by the calculus of structures, is outlined in that section.</p><p>We start from a very simple observation. A basic reaction in CCS is a|ā → 0: the two parallel processes a and ā communicate and rewrite to the empty process 0. This naturally corresponds to the identity axiom in logic, if we express complementation in CCS by negation; the parallel composition '|' corresponds to disjunction (linear logic's multiplicative disjunction corresponds remarkably well, see for example <ref type="bibr" target="#b9">[10]</ref>). Consider now sequential composition, as in the process a.b: the dual of this process must be a.b = ā. b, since a.b | ā. b → * 0. Then, we need a self-dual non-commutative logical operator for modelling sequential composition. We are not committing to CCS: we just observe that, as witnessed by CCS, there is a natural way of seeing parallel and sequential compositions in a logical system.</p><p>In Sect. 3 the system ELS (multiplicative Exponential Linear logic in the calculus of Structures) is shown <ref type="bibr" target="#b16">[16]</ref>. A first reason to study this system, which is equivalent to sequent calculus's MELL, is to see how our calculus performs on a system that is studied already elsewhere. We get a surprising result: the promotion rule can be made local, what is unlikely in the sequent calculus.</p><p>There is another reason for studying MELL in our calculus: we plan to enrich BV with contraction, in the hope of making it Turing equivalent. To this purpose, we need exponentials to control contraction, because we do not want to destroy the good behaviour of multiplicative disjunction with respect to parallel composition (what is known as 'resource sensitivity').</p><p>For both systems BV and ELS we state decomposition theorems: rules in derivations can be rearranged in a highly structured way (impossible in the sequent calculus) where subsystems of a given system are applied in sequence. Decomposition results allow us greatly to simplify the cut elimination proofs and are (still mysteriously) linked to other features of the systems under study. These theorems are welcome because proving cut elimination in the calculus of structures can be harder than in the sequent calculus, due to the more liberal applicability of inference rules.</p><p>We also prove cut elimination for both systems, and, overall, the argument is quite different than the usual one in the sequent calculus. Exploring the new methodology is by itself interesting, because there is the possibility of characterising the property of cut elimination in a more systematic way than before.</p><p>This paper only deals with syntax: our sole purpose is to present the calculus of structures and its properties. MELL is, of course, semantically well-known, and then so is ELS. System BV has been discovered by trace semantics <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Non-commutativity</head><p>A system in our calculus requires a language of structures. These are sort of intermediate expressions between formulae and sequents. Here we define the language for systems BV and SBV , and we call it BV . Intuitively, [S Structures come with equational theories establishing some basic, decidable algebraic laws by which structures are indistinguishable. There is an analogue in the laws of associativity, commutativity, idempotency, and so on, usually imposed on sequents. We will see these laws together with the inference rules. It would be possible, of course, to introduce the equational laws by inference rules. But, having dropped connectives, our choice makes matters much clearer.</p><p>The next step in defining a system is giving its inference rules. The following definition is general, i.e., it holds for any system, not just BV .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Definition An (inference) rule is any scheme</head><formula xml:id="formula_0">T ρ R</formula><p>, where ρ is the name of the rule, T is its premise and R is its conclusion. Rule names are denoted by ρ and π. A (formal) system, denoted by S , is a set of rules. A derivation in a system S is a finite chain of instances of rules of S , and is denoted by ∆. A derivation can consist of just one structure. The topmost structure in a derivation is called its premise; the lowest structure is called conclusion. A derivation ∆ whose premise is T , conclusion is R, and whose rules are in S is denoted by</p><formula xml:id="formula_1">T R S ∆ .</formula><p>A typical rule has shape S{T } ρ S{R} and specifies a step of rewriting, by the implication T ⇒ R, inside a generic context S{ }. Rules with empty contexts correspond to the case of the sequent calculus. It is important to note that the notion of derivation is top-down symmetric. Logical axioms for the given systems will be given separately from the rules. They will induce the concept of proof, and their introduction is our way of breaking the symmetry and observing the usual proof theoretical properties, like cut elimination. We will be dealing with proofs only later in the section.</p><p>Let us see a system that deals with the new non-commutative logical relation. It is made by two sub-systems: one for interaction and the other for structure. The interaction fragment deals with negation, i.e., duality. It corresponds to identity and cut in the sequent calculus. In our calculus these rules become mutually top-down symmetric and both admit decompositions into their atomic counterparts.</p><p>The structure fragment corresponds, mainly, to logical rules in the sequent calculus; it defines the logical relations. Differently from the sequent calculus, the logical relations need not be defined in isolation, rather complex contexts can be taken into consideration. In the following system, as well as in the system in the next section, we consider pairs of logical relations, one inside the other.</p><formula xml:id="formula_2">Associativity [ R, [ T ]] = [ R, T ] ( R, ( T )) = ( R, T ) R; T ; U = R; T ; U Unit [•, R] = [ R] (•, R) = ( R) •; R = R; • = R Singleton [R] = (R) = R = R Commutativity [ R, T ] = [ T , R] ( R, T ) = ( T , R) Negation • = • [R 1 , . . . , R h ] = ( R1 , . . . , Rh ) (R 1 , . . . , R h ) = [ R1 , . . . , Rh ] R 1 ; . . . ; R h = R1 ; . . . ; Rh R = R Contextual Closure if R = T then S{R} = S{T } S{•} a↓ S [a, ā] S(a, ā) a↑ S{•} Interaction Structure (core) S([R, T ], U) s S [(R, U ), T ] S [R, T ]; [R , T ] q↓ S [ R; R , T ; T ] S( R; T , R ; T ) q↑ S (R, R ); (T, T )</formula><p>Fig. <ref type="figure">1</ref> Left: Syntactic equivalence = for BV Right: System SBV</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Definition</head><p>The structures of the language BV are equivalent modulo the relation =, defined at the left of Fig. <ref type="figure">1</ref>. There, R, T and U stand for finite, non-empty sequences of structures (sequences may contain ',' or ';' separators as appropriate in the context). At the right of the figure, system SBV is shown (Symmetric, or Selfdual, Basic system V ). The rules a↓, a↑, s, q↓ and q↑ are called respectively atomic interaction, atomic cut (or atomic cointeraction), switch, seq and coseq. The down fragment of SBV is {a↓, s, q↓}, the up fragment is {a↑, s, q↑}.</p><p>Negation is involutive and can be pushed directly over atoms. The unit • is selfdual and common to the three logical relations. One may think of it as a convenient way of expressing the empty sequence. Of course, rules become very flexible in the presence of such a unit. For example, the following notable derivation is valid:</p><formula xml:id="formula_3">(a, b) q↑ a; b q↓ = [a, b] ( a; • , •; b ) q↑ [a, •]; [•, b] = (a, •); (•, b) q↓ . [ a; • , •; b ] Here is a derivation for the CCS reaction a.b | ā. b → * 0: • a↓ [b, b] a↓ [a, ā]; [b, b] q↓ . [ a; b , ā; b ]</formula><p>Please note that [ a; b , b; ā ] admits no derivation where both [a, ā] and [b, b] interact. As the reader may notice, the correspondence with CCS is truly straightforward. The instance of the rule q↓ above can not be expressed in the sequent calculus, because 1 thereshouldbetwo premises a, ā 'and' b, b, but we would have big problems with cut elimination, essentially because 'and' is too strong; 2 there is no principal connective in the conclusion, rather there are two of them to be considered together, namely, the two seq relations between a and b and between ā and b. We do not mean that similar logics cannot be expressed in any other calculus. For example, Retoré does it in <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>, in proof nets. His logic is very close to ours, possibly the same, but the exact correspondence is at present unknown. None has been able to define in the sequent calculus a self-dual non-commutative relation that lives with commutative ones. We should mention the work <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">15]</ref> by Abrusci and Ruet: they mix commutative and non-commutative relations in a sequent system, but instead of one self-dual sequential connective, they have two mutually dual ones.</p><p>A way of understanding the rule s is by considering linear logic's times rule A, Φ B, Ψ A B, Φ, Ψ . This rule is mimicked by</p><formula xml:id="formula_4">([R A , T Φ ], [U B , V Ψ ]) s [([R A , T Φ ], U B ), V Ψ ] s , [(R A , U B ), T Φ , V Ψ ]</formula><p>where R A , U B , T Φ and V Ψ correspond to the formulae A, B and the multisets of formulae Φ and Ψ . The two s instances could be swapped: the substructures in the par context can be brought inside the times structure independently. We have no combinatorial explosion in the splitting of a times context <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b10">11]</ref>, which depends on the impossibility, in the sequent calculus, of representing the middle structure in the derivation above. In fact, the lazy splitting algorithm of <ref type="bibr" target="#b8">[9]</ref> is here represented naturally and simply.</p><p>System SBV is designed to ensure the subformula property: all the rule premises are made of substructures of the conclusions, except for the cut rule. This is of course a key ingredient in consistency arguments, and a basis for proof search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Definition</head><p>The following rules are called interaction and cut (or cointeraction):</p><formula xml:id="formula_5">S{•} i↓ S [R, R] and S(R, R) i↑ S{•} ;</formula><p>R and R are called principal structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The sequent calculus rule</head><formula xml:id="formula_6">A, Φ A ⊥ , Ψ cut Φ, Ψ is realised as ([R A , T Φ ], [R A , V Ψ ]) s [([R A , T Φ ], R A ), V Ψ ] s [(R A , R A ), T Φ , V Ψ ] i↑ . [T Φ , V Ψ ]</formula><p>The next theorem states the reduction of the interaction rules to atomic form. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Definition</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Theorem</head><p>The rules i↓ and i↑ are strongly admissible for the systems {a↓, s, q↓} and {a↑, s, q↑}, respectively.</p><p>Proof Structural induction on the principal structure. We show the inductive cases of i↑:</p><formula xml:id="formula_7">S( P ; Q , P ; Q ) q↑ S (P, P ); (Q, Q) i↑ S(Q, Q) i↑ and S{•} S(P, Q, [ P , Q]) s S(Q, [(P, P ), Q]) s S [(P, P ), (Q, Q)] i↑ S(Q, Q) i↑ . S{•}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Definition</head><p>We call core the set of rules, different than atomic (co)interaction ones, that appear in the reduction of interaction and cut to atomic form. Rules, other than (co)interactions, that are not in the core are called non-core. The core of SBV is {s, q↓, q↑}, called SBV c; there are no non-core rules in SBV .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.8">Remark</head><p>Let ρ be a rule and π be its corule, i.e., π is obtained by swapping and negating premise and conclusion in ρ. The rule π is then strongly admissible for the system {i↓, i↑, s, ρ}, because each instance S{T } π S{R} can be replaced by</p><formula xml:id="formula_8">S{T } i↓ S(T, [R, R]) s S [R, (T, R)] ρ S [R, (T, T )] i↑ . S{R}</formula><p>The main idea for getting decomposition and cut elimination theorems is studying the permutability of rules. To get a decomposition theorem, instances are moved up or down along the derivation until a certain scheme is obtained. To get cut elimination, 'evil' rules, corresponding to cuts to be eliminated, are permuted up a proof until they reach the logical axiom and disappear.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.9">Definition</head><p>A rule ρ permutes over π if ρ = π and for all</p><formula xml:id="formula_9">Q π U ρ P there is Q ρ V π P , for some V ; if Q ρ V P</formula><p>S ∪{π} exists, for some system S , we say that ρ permutes by S over π.</p><p>In the sequent calculus, identity rules are leaves of the derivation trees, of course. They can be put at the top in our calculus, too, but the dual is also true of cuts: they can be driven down with no effort. Here is the decomposition theorem. Derivations are reduced to three-phase ones: a 'creation' phase, a middle phase where atoms are shuffled by rules in the core, and a 'destruction' phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.10">Theorem For every derivation</head><p>It is time to break the top-down symmetry by making asymmetric observations: we want to detect proofs. To do so, we admit inference rules with no premise, called logical axioms. For SBV we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.11">Definition</head><p>The following (logical axiom) rule is called unit: •↓ • . The system in Fig. <ref type="figure">2</ref> is called BV (Basic system V ).</p><formula xml:id="formula_10">•↓ • S{•} a↓ S [a, ā] S([R, T ], U) s S [(R, U ), T ] S [R, T ]; [R , T ] q↓ S [ R; R , T ; T ] Fig. 2 System BV 2.</formula><p>12 Definition A proof, denoted by Π, is a finite derivation whose top is an instance of a logical axiom. A system S proves R if there is in S a proof Π whose conclusion is R, written R S Π</p><p>. A rule ρ is admissible for the system S if ρ / ∈ S and for every proof R</p><p>S ∪{ρ} there exists a proof R S . Two systems are equivalent if they prove the same structures.</p><p>To get cut elimination, so as to have a system whose rules all enjoy the subformula property, we could just get rid of a↑, by proving its admissibility for the other rules. But we can do more than that: the whole up fragment of SBV , except for s (which also belongs to the down fragment), is admissible. This suggests a modular scheme for proving cut elimination, which, as a matter of fact, scales up to the much more complex case of MELL, in Sect. 3:</p><formula xml:id="formula_11">1</formula><p>rules in the non-core up fragment of the system are trivially admissible for the core, plus interaction and their (down) corules (see 2.8); 2 prove admissibility for the up rules in the core; 3 show admissibility of a↑.</p><p>The decomposition into several up rules is very beneficial when systems are extended: the cut elimination proof of the smaller system can be largely reused for the bigger one, since it relies on mutual permutability of rules. (There are no non-core rules in SBV , we will see the general case in Sect. 3.)</p><p>We have to prove the equivalence of SBV ∪ {•↓} and BV . The first step is to show the admissibility of q↑. The proof of the theorem outlines our typical technique, which uses super rules to keep track of the context while permuting up a rule to be eliminated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.13">Theorem The rule q↑ is admissible for BV ∪ {a↑}.</head><p>Proof The rule q↑ can be generalised by a certain rule m↑ (called comerge and derived from semantics); m↑ permutes by {s, q↓} over a↓, s and q↓. By 2.10 a given proof can be transformed into</p><formula xml:id="formula_12">P BV ∪{q↑} R {a↑} = T m↑ Q BV Π P SBV c R {a↑} ,</formula><p>where the top instance of q↑ has been called m↑. The m↑ instance can be permuted up until it disappears against •↓. Repeat inductively downward for all q↑ instances. The last step is getting rid of the a↑ instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.14">Theorem</head><p>The rule a↑ is admissible for BV .</p><p>Proof Similar to the previous one. We need the following fact: In BV , replace s by the rule</p><formula xml:id="formula_13">S([R, T ], U) ds↓ S [(R, U ), T ] (deep switch),</formula><p>where R is not a proper times structure (i.e., there are no non-unit P and Q such that R = (P, Q)); the resulting system, called BV d, is equivalent to BV (the argument is not trivial). Transform the upper BV portion of the given proof into a BV d one. Then drive up the topmost a↑ instance by using the super rule</p><formula xml:id="formula_14">S(R{a}, T {ā}) sa↑ S [R{•}, T {•}] ,</formula><p>which permutes by {s, q↓} over a↓, ds↓ and q↓. The two a↓ instances that apply to the principal literals created by the a↑ instance must be permuted up preliminarily, until they reach the top of the proof. Proceed inductively downward.</p><p>This completes the proof of cut elimination. The strategy we followed is completely deterministic, so the procedure is confluent.</p><p>Here comes consistency; a similar argument, exploiting the top-down symmetry, becomes hard in the sequent calculus, due to the difficulty in flipping derivations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.15">Theorem</head><formula xml:id="formula_15">If R is provable in BV then R is not provable, provided R = •. Proof A proof of R is like •↓ • a↓ [a, ā] R BV . Get R (a, ā)</formula><p>SBV by flipping the given proof. If R is provable, then (a, ā) is provable in SBV ∪ {•↓} and, by 2.13 and 2.14, in BV : impossible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.16">Remark</head><p>If we restrict BV by disallowing seq structures, we get a system equivalent to MLL (Multiplicative Linear Logic) plus mix and nullary mix <ref type="bibr" target="#b0">[1]</ref>. The proof of this is very similar to the proof of 3.12. Systems equivalent to MLL with constants and without mix can be easily designed in our calculus, but they are not extensible to seq. Other reasons for collapsing the constants into • come from external semantic arguments (see <ref type="bibr" target="#b7">[8]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Multiplicative Exponential Linear Logic</head><p>All general notions from Sect. 2 apply here. In the following, only what changes in the systems for MELL is defined. The main differences between our presentation and the sequent calculus one are: rules apply anywhere deep into structures, the switch rule replaces times, the promotion rule is decomposed into a local variant. Details can be found in <ref type="bibr" target="#b16">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definition</head><p>We denote by MELL (Multiplicative Exponential Linear Logic) the system in the sequent calculus whose formulae are generated by</p><formula xml:id="formula_16">A ::= a | ⊥ | 1 | A A | A A | ?A | !A | A ⊥ ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>whose sequents are expressions of the kind</head><p>A 1 , . . . , A h , for h 0 , where the commas between formulae stand for multiset union, and whose rules are shown in Fig. <ref type="figure">3</ref>. Formulae are denoted by A and B, multisets of formulae by Φ and Ψ . Negation obeys De Morgan rules.</p><p>Let us define the language of structures ELS (multiplicative Exponential Linear logic in the calculus of Structures). The multiplicatives are denoted as in Sect. 2; for the exponentials we use ? and !. Structures of ELS and formulae of MELL are in a trivial, mutual correspondence. where ⊥ and 1 are units; [S, . . . , S] is a par structure, (S, . . . , S) is a times structure; ?S is a why-not structure and !S is an of-course structure; S is the negation of S.</p><formula xml:id="formula_17">id A, A ⊥ A, Φ A ⊥ , Ψ cut Φ, Ψ A, B, Φ A B, Φ A, Φ B, Ψ A B, Φ, Ψ Φ ⊥ ⊥, Φ Φ wk ?A, Φ ?A, ?A, Φ ct ?A, Φ A, Φ dr ?A, Φ A, ?B 1 , . . . , ?B h pr !A, ?B 1 , . . . , ?B h 1 1 h 0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Definition</head><p>The functions • S and • L , from formulae to structures and vice versa, are as follows: </p><formula xml:id="formula_18">a S = a , ⊥ S = ⊥ , 1 S = 1 , A B S = [A S , B S ] , A B S = (A S , B S ) , ?A S = ?A S , !A S = !A S , A ⊥ S = A S , a L = a , ⊥ L = ⊥ , 1 L = 1 , [R 1 , . . . , R h ] L = R 1 L • • • R h L , (R 1 , . . . , R h ) L = R 1 L • • • R h L , ?R L = ?R L , !R L = !R L , RL = (R L ) ⊥ ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. . , A h S ] ,</head><p>for h &gt; 0 . It would be entirely possible to take MELL as presented above and transport it trivially into the calculus of structures. At that point, all of the proof theory possible in the sequent calculus would still be possible in our calculus. Instead, we collapse dereliction (dr) and contraction (ct) into absorption (which is a known, easy trick) and use the peculiarities of the calculus of structures to deal differently with times ( ) and promotion (pr). This way we get new properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Definition</head><p>The structures of ELS are considered equivalent modulo the relation =, defined at the left of Fig. <ref type="figure">4</ref>. There, R and T stand for finite, non-empty sequences of structures. At the right of the figure, system SELS is shown (Symmetric, or Selfdual, multiplicative Exponential Linear logic in the calculus of Structures). The rules a↓, a↑ and s are called, as in system SBV , atomic interaction, atomic cut (or atomic cointeraction) and switch. The rules p↓, w↓ and b↓ are called, respectively, promotion, weakening and absorption, and their corules get a prefix co-before their name. The down fragment of SELS is {a↓, s, p↓, w↓, b↓}, the up fragment is {a↑, s, p↑, w↑, b↑}.</p><p>The reader can check that the equations in Fig. <ref type="figure">4</ref> are equivalences in MELL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Definition</head><p>The following rules are interaction and cut (or cointeraction): Like for system SBV , we have the following two propositions, which say: 1) the general interaction and cut rules can be decomposed into their atomic forms; 2) the cut rule is as powerful as the whole up fragment of the system, and vice versa (and the same holds for the interaction rule with respect to the down fragment).</p><formula xml:id="formula_19">S{1} i↓ S [R, R] and S(R, R) i↑ S{⊥} . Associativity [ R, [ T ]] = [ R, T ] ( R, ( T )) = ( R, T ) Units [⊥, R] = [ R] (1, R) = ( R) Singleton [R] = (R) = R Exponentials ?⊥ = ⊥ !1 = 1 ??R = ?R !!R = !R Commutativity [ R, T ] = [ T , R] ( R, T ) = ( T , R) Negation R = R ⊥ = 1 1 = ⊥ [R 1 , . . . , R h ] = ( R1 , . . . , Rh ) (R 1 , . . . , R h ) = [ R1 , . . . , Rh ] ?R = ! R !R = ? R R = R Contextual Closure if R = T then S{R} = S{T } S{1} a↓ S [a, ā] S(a, ā) a↑ S{⊥} Interaction Structure S([R, T ], U) s S [(R, U ), T ] S{![R, T ]} p↓ S [!R, ?T ] S(?R, !T ) p↑ S{?(R, T )} core non-core S{⊥} w↓ S{?R} S{!R} w↑ S{1} S [?R, R] b↓ S{?R} S{!R} b↑ S(!R, R)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Proposition</head><p>The rules i↓ and i↑ are strongly admissible for systems {a↓, s, p↓} and {a↑, s, p↑}, respectively.</p><p>Proof Similar to the proof of 2.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Proposition</head><p>Every rule ρ↑ in system SELS is strongly admissible for the system {i↓, i↑, s, ρ↓}.</p><p>Proof See 2.8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Definition</head><p>The core of SELS is the system {s, p↓, p↑}, denoted by SELSc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.9">Definition</head><p>The following (logical axiom) rule is called one: 1↓</p><p>1 .</p><p>As we did in Sect. 2, we put our logical axiom into the down fragment of SELS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.10">Definition</head><p>System ELS is shown in Fig. <ref type="figure">5</ref>.</p><p>As a quick consequence of 3.6 and 3.7 we get:</p><p>3.11 Theorem ELS ∪ {i↑} and SELS ∪ {1↓} are strongly equivalent.</p><p>The system SELS ∪ {1↓} is equivalent to MELL: An argument along these lines shows that for every cut free proof in MELL we can obtain a proof in ELS. Therefore, i↑ is admissible for ELS, by the cut elimination theorem for MELL <ref type="bibr" target="#b5">[6]</ref>. In other words, the whole up fragment of SELS is admissible for ELS. However, we obtain this result for the calculus of structures by using the sequent calculus. Since we want to use our calculus for logics that cannot be captured by the sequent calculus, we must be able to prove cut elimination within our calculus, with no detour. The first step is a decomposition theorem.</p><formula xml:id="formula_20">3.12 Theorem If R is provable in SELS∪ {1↓} then R L is provable in MELL,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.13">Theorem For every derivation</head><formula xml:id="formula_21">T R SELS there is a derivation T T 1 {b↑} T 2 {w↓} T 3 {a↓} R 3 SELSc R 2 {a↑} R 1 {w↑} R {b↓} , for some structures R 1 , R 2 , R 3 , T 1 , T 2 , T 3 .</formula><p>Proof The decomposition is done in three steps: b↑ and b↓ instances are separated, then w↓ and w↑, and then a↓ and a↑. The first step is very difficult (see <ref type="bibr" target="#b16">[16]</ref>), the other two are rather trivial.</p><p>If we just consider proofs instead of derivations, all top instances of b↑ become trivial: their premises and conclusions are equal to 1. Moreover, all w↑ instances can be removed by using 3.7 and 3.6. </p><formula xml:id="formula_22">1↓ 1 R 4 {w↓} R 3 {a↓} R 2 {s,p↓,p↑} R 1 {a↑} R {b↓} 1 = 1↓ 1 R 4 {w↓} R 3 {a↓} R 2 {ds↓,ns↑,p↓,sp↑} R 1 {sa↑} R {b↓} 2 → 1↓ 1 R 4 {w↓} R 3 {a↓} R 3 {ns↑,sp↑,sr↑} R 2 {ds↓,p↓,r↓} R 1 {sa↑} R {b↓} 3 → 1↓ 1 R 4 {w↓} R 3 {a↓} R 2 {ds↓,p↓,r↓} R 1 {sa↑} R {b↓} 4 → 1↓ 1 R 4 {w↓} R 3 {a↓} R 2 {ds↓,p↓} R 1 {sa↑} R {b↓} 5 → 1↓ 1 R 3 {w↓} R 2 R 1 {ds↓,p↓}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.14">Theorem For every proof R</head><p>SELS∪{1↓} there is a proof</p><formula xml:id="formula_23">1↓ 1 R 4 {w↓} R 3 {a↓} R 2 SELSc R 1 {a↑} R {b↓} , for some struc- tures R 1 , R 2 , R 3 , R 4 .</formula><p>Proof It is a trivial variation of 3.13.</p><p>The decomposition theorem is of great value for the cut elimination proof, because all instances of b↓ are already below the instances of p↑ and a↑ that have to be eliminated. This means that we do not have to deal with absorption (nor contraction), which are known to be most problematic in a cut elimination proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.15">Theorem</head><p>The systems SELS ∪ {1↓} and ELS are equivalent.</p><p>Proof The proof is similar to that for BV : we eliminate in order w↑, b↑, p↑ and a↑. For w↑ and b↑ we use 3.14. For a↑ and p↑ we use the super rules:</p><formula xml:id="formula_24">S([a, P ], [ā, Q]) sa↑ and S [P, Q] S([?R, P ], [!T, Q]) sp↑ . S [?(R, T ), P, Q]</formula><p>We also need the rule r↓ and its super corule sr↑:</p><formula xml:id="formula_25">S{?[R, T ]} r↓ and S [?R, ?T ] S([!R, P ], [!T, Q]) sr↑ . S [!(R, T ), P, Q]</formula><p>We then use the rule ns↑ (non-deep switch) which defines all instances of s that are not instances of ds↓ (see 2.14). Fig. <ref type="figure" target="#fig_5">6</ref> shows the steps of the transformation. We start from a decomposed proof produced by 3.14. Then we replace all instances of s either by ds↓ or ns↑, and all instances of p↑ and a↑ by sp↑ and sa↑, respectively. While permuting up the rules ns↑ and sp↑ over ds↓ and p↓ in Step 2, the rules sr↑ and r↓ are introduced. In Steps 3 and 4, the rules ns↑, sp↑ and sr↑, and then the rule r↓ are eliminated. In the last step the rule sa↑ is eliminated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions and Future Work</head><p>We have shown, in the calculus of structures, the system BV , which is an extension of MLL (Multiplicative Linear Logic) and which is not expressible in the sequent calculus in any known way. Research is currently going on finally to prove that it is impossible to capture BV in the sequent calculus. System BV is interesting for computer science because it models a typical notion of sequentialisation. We then extended MLL to MELL in our calculus, and we got a system whose promotion rule is local, as opposed to what is possible in the sequent calculus, where promotion is global. The new system does not present unnecessary non-determinism in dealing with the times connective.</p><p>The question is whether a new calculus is justified, given that competition is the venerable sequent calculus. We answer yes for the following reasons: 1</p><p>Simplicity: The calculus of structures is more general than the sequent calculus (for logics with involutive negation), but is not more complicated. The case of multiplicative exponential linear logic shows that a simple system, deeply different than MELL, can be designed. System BV yields with very simple means a logic that defeats sequent calculus. 2</p><p>Power : The calculus of structures unveils properties and possibilities of analyses, like decomposition, that are not available in the sequent calculus. 3</p><p>Modularity: Proving cut-elimination is modular; if one enlarges a system, the work done for the smaller system can be used for the bigger. Moreover, the cut elimination argument for any given system is decomposed into separate pieces. This stems from the possibility of dealing with cut the same way we could with identity in the sequent calculus: our calculus makes use of a new symmetry. One reason for these achievements is the applicability of rules deeply into structures, which allows for a lazy bookkeeping of the context. For example, the times rule in the sequent calculus must make an early choice of the splitting of its context, which is not the case in our calculus. The same happens with promotion: pieces of context can be brought inside the scope of an of-course one by one.</p><p>Another reason behind our results is the dropping of the idea of connective. In the calculus of structures, instead of defining connectives, rules define mutual relations of logical relations. Typical rules in the up fragment of a system are not definable in the sequent calculus, yet they are just simple duals of ordinary sequent calculus rules. Without much complication, we can then decompose the cut rule into its atomic form, which is the key to modularity.</p><p>One possible problem with our calculus is that, since rules apply anywhere deep into structures, proof search can be very non-deterministic. Research is in progress in our group to focus proofs not only along lines induced by the logical relations <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">11]</ref>, but also based on the depth of structures.</p><p>Classical logic is also studied. One can easily port 'additive' rules to our calculus, but the question, again, is whether we can get decomposition and a modular cut elimination proof. Recent work, in preparation, by Brünnler and Tiu, shows that classical logic enjoys a presentation whose rules are all local, and cut is admissible <ref type="bibr" target="#b3">[4]</ref>.</p><p>The next step will be to bring exponentials (and contraction) to system BV . The experiment performed in this paper shows that the operation is entirely practical in our calculus, and it would yield better results than proof nets <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>, which have notorious difficulties with exponentials. The resulting calculus will be Turing equivalent. Our hope is that MELL will be proved decidable (the question is still open): if this happened, it would mean that the edge is crossed by our self-dual non-commutative logical relation (the tape of a Turing machine?).</p><p>Finally, we have a further prototype system, inspired by traces <ref type="bibr" target="#b7">[8]</ref>, in which also the contraction rule is atomic. We are not able yet to prove cut elimination for it. If we were successful, we would obtain a totally distributed formalism, in the sense of computer science, which would also be a first class proof theoretical system.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>SS</head><label></label><figDesc>A rule ρ is strongly admissible for the system S if ρ / ∈ . The systems S and S are strongly equivalent if for every derivation T R there exists a derivation T R S , and vice versa.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>structures P and Q.Proof The rule a↓ permutes over a↑ and permutes by SBV c over s, q↓ and q↑. Take the topmost instance of a↓ and move it upward until it reaches the top. Proceed inductively downward by moving up each a↓ instance until only a↓ instances are above it. Perform dually for a↑.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 MELL 3 . 2 Definition</head><label>332</label><figDesc>Fig. 3 System MELL</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>where h &gt; 0. The function • S extends to sequents by S = ⊥ and A 1 , . . . , A h S = [A 1 S , .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 Fig. 5</head><label>45</label><figDesc>Fig. 4 Left: Syntactic equivalence = for ELS Right: System SELS</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>RFig. 6</head><label>6</label><figDesc>Fig. 6 Cut elimination for SELS ∪ {1↓}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>2.1 Definition There</head><label></label><figDesc>1 , . . . , S h ] corresponds to a sequent in linear logic, whose formulae are connected by pars, and associativity and commutativity are taken into account. The structure (S 1 , . . . , S h ) corresponds to the times connection of S 1 , . . . , S h ; it is associative and commutative. The structure S 1 ; . . . ; S h is associative and non-commutative: this corresponds to the new logical relation we introduce. All the details for this section can be found in<ref type="bibr" target="#b7">[8]</ref>. Structures with a hole that does not appear in the scope of a negation are denoted by S{ }. The structure R is a substructure of S{R}, and S{ } is its context. We simplify the indication of context in cases where structural parentheses fill the hole exactly: for example, S [R, T ] stands for S{[R, T ]}.</figDesc><table /><note><p><p>are infinitely many positive literals and negative literals. Literals, positive or negative, are denoted by a, b, . . . . Structures are denoted by S, P , Q, R, T , U and V . The structures of the language BV are generated by S ::= a | • | [ S, . . . , S &gt;0 ] | ( S, . . . , S &gt;0 ) | S; . . . ; S &gt;0 | S ,</p>where •, the unit, is not a literal; [S 1 , . . . , S h ] is a par structure, (S 1 , . . . , S h ) is a times structure and S 1 ; . . . ; S h is a seq structure; S is the negation of the structure S.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>and if Φ is provable in MELL then Φ S is provable in SELS ∪ {1↓}.</figDesc><table><row><cell cols="5">Proof For every rule the sequent (S{T } L ) ⊥ , S{R} S{T } ρ S{R} L is provable. Use this and in SELS the sequent (T</cell><cell>L ) ⊥ , R S{T } L is provable in MELL. Then L (S{T } L ) ⊥ , S{R} L cut S{R} L</cell></row><row><cell></cell><cell></cell><cell cols="2">SELS∪{1↓}</cell></row><row><cell>inductively over a given proof</cell><cell>ρ</cell><cell>S{T } S{R}</cell><cell cols="2">. Conversely, given a proof in MELL, transform it by</cell></row><row><cell cols="5">an easy induction, proceeding from its root, into a proof in SELS ∪ {1↓}. We only show the</cell></row><row><cell cols="5">case of promotion, where the derivation ∆ exists by induction hypothesis:</cell></row><row><cell></cell><cell></cell><cell></cell><cell>1↓</cell><cell>!1</cell></row><row><cell cols="2">p↓ p↓</cell><cell cols="3">![A S , ?B 1 S , . . . , ?B h S ] . . . S p↓ [![A , ?B 1 S ], ??B 2 S , . . . , ??B h S ] [!A</cell><cell>.</cell></row></table><note><p>S , ??B 1 S , . . . , ??B h S ] SELS ∆</p></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Games and full completeness for multiplicative linear logic</title>
		<author>
			<persName><forename type="first">Samson</forename><surname>Abramsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radha</forename><surname>Jagadeesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="543" to="574" />
			<date type="published" when="1994-06">June 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Non-commutative logic I: The multiplicative fragment</title>
		<author>
			<persName><forename type="first">V</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Abrusci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Ruet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="64" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Logic programming with focusing proofs in linear logic</title>
		<author>
			<persName><forename type="first">Jean-Marc</forename><surname>Andreoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="297" to="347" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">A local system for classical logic</title>
		<author>
			<persName><forename type="first">Kai</forename><surname>Brünnler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alwen</forename><surname>Tiu</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In preparation</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The Collected Papers of Gerhard Gentzen</title>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Gentzen</surname></persName>
		</author>
		<editor>M. E. Szabo</editor>
		<imprint>
			<date type="published" when="1969">1969</date>
			<biblScope unit="page" from="68" to="131" />
			<pubPlace>North-Holland, Amsterdam</pubPlace>
		</imprint>
	</monogr>
	<note>Investigations into logical deduction</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Jean-Yves</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Linear logic. Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1" to="102" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<author>
			<persName><forename type="first">Jean-Yves</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proof Theory and Logical Complexity</title>
		<meeting><address><addrLine>Napoli</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">I</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A calculus of order and interaction</title>
		<author>
			<persName><forename type="first">Alessio</forename><surname>Guglielmi</surname></persName>
		</author>
		<idno>WV-99- 04</idno>
		<ptr target="http://www.ki.inf.tu-dresden.de/˜guglielm/Research/Gug/Gug.pdf" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
		<respStmt>
			<orgName>Dresden University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>On the</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Logic programming in a fragment of intuitionistic linear logic</title>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">S</forename><surname>Hodas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dale</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="327" to="365" />
			<date type="published" when="1994-05">May 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The π-calculus as a theory in linear logic: Preliminary results</title>
		<author>
			<persName><forename type="first">Dale</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1992 Workshop on Extensions to Logic Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Lamma</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Mello</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">660</biblScope>
			<biblScope unit="page" from="242" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Forum: A multiple-conclusion specification logic</title>
		<author>
			<persName><forename type="first">Dale</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">165</biblScope>
			<biblScope unit="page" from="201" to="232" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Robin</forename><surname>Milner</surname></persName>
		</author>
		<title level="m">Communication and Concurrency. International Series in Computer Science</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pomset logic: A non-commutative extension of classical linear logic</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Retoré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TLCA&apos;97</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Ph</forename><surname>De Groote</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Hindley</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1210</biblScope>
			<biblScope unit="page" from="300" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Pomset logic as a calculus of directed cographs</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Retoré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Dynamic Perspectives in Logic and Linguistics</title>
		<editor>
			<persName><forename type="first">V</forename><forename type="middle">M</forename><surname>Abrusci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Casadio</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="221" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Also available as INRIA Rapport de Recherche</title>
		<author>
			<persName><forename type="first">Roma</forename><surname>Bulzoni</surname></persName>
		</author>
		<idno>RR-3714</idno>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Non-commutative logic II: Sequent calculus and phase semantics</title>
		<author>
			<persName><forename type="first">Paul</forename><surname>Ruet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="277" to="312" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">MELL in the calculus of structures</title>
		<author>
			<persName><forename type="first">Lutz</forename><surname>Straßburger</surname></persName>
		</author>
		<idno>WV-2001- 03</idno>
		<ptr target="http://www.ki.inf.tu-dresden.de/˜lutz/els.pdf" />
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>Dresden University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>On the</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
