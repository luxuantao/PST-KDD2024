<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Component-Based Synthesis of Table Consolidation and Transformation Tasks from Examples *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yu</forename><surname>Feng</surname></persName>
							<email>yufeng@cs.utexas.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ruben</forename><surname>Martins</surname></persName>
							<email>rmartins@cs.utexas.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jacob</forename><surname>Van Geffen</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Isil</forename><surname>Dillig</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Swarat</forename><surname>Chaudhuri</surname></persName>
							<email>swarat@rice.edu</email>
							<affiliation key="aff4">
								<orgName type="institution">Rice University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Component-Based Synthesis of Table Consolidation and Transformation Tasks from Examples *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">E9D1D3701718ECC576D6BE9C06659623</idno>
					<idno type="DOI">10.1145/3062341.3062351</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T09:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Program synthesis</term>
					<term>Programming by example</term>
					<term>data preparation</term>
					<term>Component-based synthesis</term>
					<term>SMT-based deduction</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper presents a novel component-based synthesis algorithm that marries the power of type-directed search with lightweight SMT-based deduction and partial evaluation. Given a set of components together with their overapproximate first-order specifications, our method first generates a program sketch over a subset of the components and checks its feasibility using an SMT solver. Since a program sketch typically represents many concrete programs, the use of SMT-based deduction greatly increases the scalability of the algorithm. Once a feasible program sketch is found, our algorithm completes the sketch in a bottom-up fashion, using partial evaluation to further increase the power of deduction for rejecting partially-filled program sketches. We apply the proposed synthesis methodology for automating a large class of data preparation tasks that commonly arise in data science. We have evaluated our synthesis algorithm on dozens of data wrangling and consolidation tasks obtained from on-line forums, and we show that our approach can automatically solve a large class of problems encountered by R users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS Concepts</head><p>• Software and its engineering → Programming by example; Automatic programming; • Theory of computation → Program specifications * This work was supported in part by NSF Awards #1453386 and #1162076, and DARPA MUSE Award #8750-14-2-0270.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The problem of program synthesis from examples has received significant attention from researchers in the last few years. The central objective of this research area is to automate certain classes of programming tasks, either with the goal of helping end-users to "program" or absolving software developers from tedious coding tasks. To accomplish these goals, many program synthesis techniques define the space of relevant programs using a domain-specific language (DSL) and give methods to search the space of DSL programs that are consistent with the user-provided examples. Recent work has shown that such a methodology can be practical in many domains <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b29">30]</ref>.</p><p>A particularly interesting version of this problem concerns the synthesis of programs that manipulate tabular data. Such programs are especially important in an era where data analytics has gained enormous popularity across a wide range of disciplines, ranging from biology to business to the social sciences. Since raw data is rarely in a form that is immediately amenable to an analytics or visualization task, data scientists typically spend over 80% of their time performing tedious data preparation tasks <ref type="bibr" target="#b6">[7]</ref>. Such tasks include consolidating multiple data sources into a single table, reshaping data from one format into another, or adding new rows or columns to an existing table.</p><p>While data preparation tasks would seem to be natural targets for synthesis, many such tasks are too complex to be handled by existing techniques. If written in a low-level language, programs implementing these tasks would be simply too large to be discovered by combinatorial search. One way around this difficulty is to describe the relevant computations using a set of predefined library functions, or compo-Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions@acm.org. nents, and then synthesize programs that use these high-level primitives. Another advantage of such a component-based synthesis approach is its flexibility: Since the reasoning of the synthesizer is not hard-wired to a fixed set of DSL constructs, the underlying algorithm can generate more complex programs as new libraries emerge or as more components are added to its knowledge base.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sketch Generation Examples</head><note type="other">Components</note><p>Unfortunately, a key challenge in developing such a general component-based synthesis algorithm for automating data preparation tasks is scalability: Since many languages (e.g., R) provide a large number of components that are typically used in data preparation, the size of the search space that must be explored by the underlying synthesis algorithm can be very large. Due to this difficulty, prior techniques for automating table transformations (e.g., <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b36">37]</ref>) focus on narrowly-defined DSLs, such as subsets of the Excel macro language <ref type="bibr" target="#b16">[17]</ref> or fragments of SQL <ref type="bibr" target="#b36">[37]</ref>. Unfortunately, many common data preparation tasks (e.g., those that involve reshaping tables or require performing nested table joins) fall outside the scope of these previous approaches.</p><p>In this paper, we propose a general component-based synthesis algorithm for automating a large class of data preparation tasks. Specifically, our synthesis algorithm is parametrized over a set of components, which can include both higher-order and first-order combinators. The set of components used by the synthesizer can be customized by the user or extended over time as new libraries emerge.</p><p>In order to address the scalability challenges that arise from our more general formulation of the problem, we propose a new synthesis algorithm that combines type-directed enumerative search with lightweight SMT-based deduction and partial evaluation. In our formulation of the synthesis problem, each component C is equipped with a logical, incomplete specification that over-approximates C's behavior. These specifications are utilized by the synthesizer to perform lightweight SMT-based reasoning, with the goal of rejecting infeasible partial programs. Furthermore, specifications are provided per component, so they can be re-used across arbitrarily many synthesis tasks. Since our technique does not depend on hard-coded component-specific reasoning, our approach significantly generalizes prior uses of deduction in example-guided synthesis (e.g., <ref type="bibr" target="#b9">[10]</ref>).</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows a schematic illustration of our synthesis algorithm, implemented in a tool called MORPHEUS. To fa-cilitate effective use of SMT-based deduction, our algorithm decomposes the synthesis task into two separate sketch generation and sketch completion phases. In particular, a sketch specifies the top-level combinators used in the program, but not their corresponding arguments. Our algorithm uses typedirected enumerative search to lazily explore the space of all possible program sketches and infers a specification of each candidate sketch using the specifications of the underlying components. Hence, once we have a candidate sketch S, we can use an SMT solver to test whether S is consistent with the provided input-output examples. Because a program sketch typically represents many concrete programs, the rejection of program sketches using SMT-based reasoning dramatically improves the scalability of the synthesis algorithm.</p><p>Once our algorithm finds a feasible program sketch, it then tries to complete it in a bottom-up, type-directed way. In particular, the synthesizer evaluates sub-terms of the partial program P to infer a more precise specification for P and again uses SMT-based reasoning with the goal of refuting the partially-completed sketch. Hence, the use of partial evaluation further improves the scalability of the synthesis algorithm by allowing us to refute partial programs obtained during sketch completion.</p><p>While the core ideas underlying our algorithm are generally applicable to any component-based synthesizer, we have used these ideas to automate table consolidation and transformation tasks that commonly arise in data science. Specifically, our implementation, MORPHEUS, takes as input a set of source data frames in R, as well as the target data frame that should be generated using the synthesized program. Additionally, the user can also provide a set of components (i.e., library methods), optionally with their corresponding firstorder specifications. However, since our implementation already comes with a built-in set of components that are commonly used in data preparation, the user does not need to provide any additional components but can do so if she so desires. Using the ideas outlined above, MORPHEUS then automatically synthesizes an R program that can now be applied to other data frames.</p><p>To evaluate our techniques, we have collected a suite of data preparation tasks for the R programming language, drawn from discussions among R users in on-line forums such as Stackoverflow. The "components" in our evaluation are methods provided by two popular R libraries, namely tidyr and dplyr, for data tidying and manipulation. Our experiments show that MORPHEUS can successfully synthesize a diverse class of real-world data preparation programs. We also evaluate the performance of MORPHEUS using component specifications of different granularities and demonstrate that SMT-based deduction and partial evaluation are crucial for the scalability of our approach.</p><p>To summarize, this paper makes the following key contributions:</p><p>• We describe a novel component-based synthesis algorithm that uses SMT-based deduction and partial evaluation to dramatically prune the search space. • We apply the proposed ideas to automate a diverse class of data wrangling and consolidation tasks that commonly arise in data science. • We implement these ideas in a tool called MORPHEUS and empirically evaluate our approach in a number of ways. First, we show that MORPHEUS can successfully automate 98% of R-related data preparation tasks collected from on-line forums. Second, we perform a small user study showing that the class of tasks that can be automated by MORPHEUS are difficult even for expert R programmers. Finally, we also show that MORPHEUS can synthesize non-trivial SQL queries and that it performs better than the SQLSYNTHESIZER tool on their own dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Motivating Examples</head><p>In this section, we illustrate the diversity of data preparation tasks using a few examples collected from Stackoverflow.</p><p>Example 1. An R user has the data frame in Figure <ref type="figure">2</ref>(a), but wants to transform it to the following format <ref type="bibr" target="#b0">[1]</ref>: Observe that this example involves selecting a subset of the data and performing some computation on that subset. Example 3. A data analyst has the following raw data about the position of vehicles for a driving simulator <ref type="bibr" target="#b2">[3]</ref>: Here, Table <ref type="table" target="#tab_8">1</ref> contains the unique identification number for each vehicle (e.g., <ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b14">15)</ref>, with 0 indicating the absence of a vehicle. The column labeled "frame" in Table <ref type="table" target="#tab_8">1</ref> measures the time step, and the columns "X1", "X2", "X3" track which vehicle is closer to the driver. For example, at frame 3, the vehicle with ID 15 is the closest to the driver. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Problem Formulation</head><p>In order to precisely describe our synthesis problem, we first present some definitions that we use throughout the paper. ) A table T is a tuple (r, c, τ, ς) where:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1. (Table</head><p>• r, c denote number of rows and columns respectively • τ : {l 1 : τ 1 , . . . , l c : τ c } denotes the type of T. In particular, each l i is the name of a column in T and τ i denotes the type of the value stored in T. We assume that each τ i is either num or string.</p><formula xml:id="formula_0">• ς is a mapping from each cell (i, j) ∈ ([0, r) × [0, c)) to a value v stored in that cell</formula><p>Given a table T = (r, c, τ, ς), we write T.row and T.col to denote r and c respectively. We also write T i,j as shorthand for ς(i, j) and type(T) to represent τ . We refer to all record types {l 1 : τ 1 , . . . , l c : τ c } as type tbl. In addition, tables with only one row are referred to as being of type row.</p><formula xml:id="formula_1">Definition 2. (Component) A component X is a triple (f, τ, φ)</formula><p>where f is a string denoting X 's name, τ is the type signature (see Figure <ref type="figure">3</ref>), and φ is a first-order formula that specifies X 's input-output behavior.</p><p>Given a component X = (f, τ, φ), the specification φ is over the vocabulary x 1 , . . . , x n , y, where x i denotes X 's i'th argument and y denotes X 's return value. Note that specification φ does not need to precisely capture X 's inputoutput behavior; it only needs to be an over-approximation. Thus, true is always a valid specification for any component.</p><p>With slight abuse of notation, we sometimes write X (. . .) to mean f (. . .) whenever X = (f, τ, φ). Also, given a component X and arguments c 1 , . . . , c n , we write [[X (c 1 , . . . , c n )]] to denote the result of evaluating X on arguments c 1 , . . . , c n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. (Problem specification)</head><p>The specification for a synthesis problem is a pair (E, Λ) where:</p><p>• E is an input-output example ( T in , T out ) such that T in denotes a list of input tables, and T out is the output table,</p><formula xml:id="formula_2">• Λ = (Λ T ∪ Λ v ) is a set of components, where Λ T , Λ v</formula><p>denote table transformers and value transformers respectively. We assume that Λ T includes higher-order functions, but Λ v consists of first-order operators.</p><p>Given an input-output example E = ( T in , T out ), we write E in , E out to denote T in , T out respectively. Also, we classify components Λ into two disjoint classes Λ T and Λ v , where Λ T denotes table transformer components that take at least one table as an argument and return a table. Components of all other types are value transformers Λ v . While table transformers can be higher-order combinators, value transformers are always first-order. In the rest of the paper, we assume that table transformers only take tables and first-order functions (constructed using constants and components in Λ v ) as arguments. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Hypotheses as Refinement Trees</head><p>Before we can describe our synthesis algorithm, we first introduce hypotheses that represent partial programs with unknown expressions (i.e., holes). More formally, hypotheses H are defined by the grammar presented in Figure <ref type="figure">5</ref>. In the simplest form, a hypothesis (? i : τ ) represents an unknown expression of type τ . More complicated hypotheses are constructed using table transformation components X ∈ Λ T . In particular, if X = (f, τ, φ) ∈ Λ T , a hypothesis of the form</p><formula xml:id="formula_3">? X i (H 1 , . . . , H n ) represents an expression f (e 1 , . . . , e n ).</formula><p>During the course of our synthesis algorithm, we will progressively fill the holes in the hypothesis with concrete expressions. For this reason, we also allow hypotheses of the form (? i : τ )@Q where qualifier Q specifies the term that is used to fill hole ? i . Specifically, if ? i is of type tbl, then its corresponding qualifier has the form (x, T), which means that ? i is instantiated with input variable x, which is in turn bound to table T in the input-output example provided by the user. On the other hand, if ? i is of type (τ 1 × . . . × τ n ) → τ , then the qualifier must be a first-order function λy 1 , . . . y n .t constructed using components Λ v . <ref type="foot" target="#foot_1">1</ref>Our synthesis algorithm starts with the most general hypothesis and progressively makes it more specific. Therefore, we now define what it means to refine a hypothesis: Definition 5. (Hypothesis refinement) Given two hypotheses H, H ′ , we say that H ′ is a refinement of H if it can be obtained by replacing some subterm ? i : τ of H by</p><formula xml:id="formula_4">? X i (H 1 , . . . , H n ) where X = (f, τ ′ → τ, φ) ∈ Λ T .</formula><p>In other words, a hypothesis H ′ refines another hypothesis H if it makes it more constrained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[[(?</head><formula xml:id="formula_5">i : τ )]] ∂ =? i [[(? i : τ )@(x, T)]] ∂ = T [[(? i : τ )@t]] ∂ = t [[? χ i (H 1 , . . . , H n )]] ∂ = X ([[H 1 ]] ∂ , . . . , [[H n ]] ∂ ) if ∃i ∈ [1, n]. PARTIAL([[H i ]] ∂ ) [[X ([[H 1 ]] ∂ , . . . , [[H n ]] ∂ )]] otherwise Figure 4. Partial evaluation of hypothesis. We write PARTIAL([[H]] ∂ ) if [[H]] ∂ contains at least one question mark. Term t := const| y i | X (t 1 , ..., t n ) (X ∈ Λ v ) Qualifier Q := (x, T) | λy 1 , . . . y n . t Hypothesis H := (? i : τ ) | (? i : τ )@Q | ? X i (H 1 , ..., H n ) (X ∈ Λ T )</formula><p>Figure <ref type="figure">5</ref>. Context-free grammar for hypotheses</p><formula xml:id="formula_6">? π 0 : tbl ? σ 1 : tbl ? 3 : tbl ? 4 : row → bool ? 2 : cols Figure 6.</formula><p>Representing hypotheses as refinement trees The hypothesis H 1 =? σ 0 (? 1 : tbl, ? 2 : row → bool) is a refinement of H 0 =? 0 : tbl because H 1 is more specific than H 0 . In particular, H 0 represents any arbitrary expression of type tbl, whereas H 1 represents expressions whose top-level construct is a selection.</p><formula xml:id="formula_7">? π 0 : tbl ? 1 : tbl@(x 1 ,T) ? 2 : cols ? π 0 : tbl ? 1 : tbl@ (x 1 ,T) ? 2 : cols@ [name, year]</formula><p>Since our synthesis algorithm starts with the hypothesis ? 0 : tbl and iteratively refines it, we will represent hypotheses using refinement trees <ref type="bibr" target="#b23">[24]</ref>. Effectively, a refinement tree corresponds to the abstract syntax tree (AST) for the hypotheses from Figure <ref type="figure">5</ref>. In particular, note that internal nodes labeled ? χ i of a refinement tree represent hypotheses whose top-level construct is χ. If an internal node ? χ i has children labeled with unknowns ? j , . . . , ? j+n , this means that hypothesis ? i was refined to χ(? j , . . . , ? j+n ). Intuitively, a refinement tree captures the history of refinements that occur as we search for the desired program. Example 6. Consider the refinement tree from Figure <ref type="figure">6</ref>, and suppose that π, σ denote the standard projection and selection operators in relational algebra. This refinement tree represents the partial program π(σ(?, ?), ?).The refinement tree also captures the search history in our synthesis algorithm. Specifically, it shows that our initial hypothesis was ? 0 , which then got refined to π(? 1 , ? 2 ), which in turn was refined to π(σ(? 3 , ? 4 ), ? 2 ). As mentioned in Section 1, our approach decomposes the synthesis task into two separate sketch generation and sketch completion phases. We define a sketch to be a special kind of hypothesis where there are no unknowns of type tbl.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6. (Sketch) A sketch is a special form of hypothesis where all leaf nodes of type tbl have a corresponding qualifier of the form (x, T).</head><p>In other words, a sketch completely specifies the table transformers used in the target program, but the first-order functions supplied as arguments to the table transformers are yet to be determined.</p><p>Example 7. Consider the refinement tree from Figure <ref type="figure">6</ref>. This hypothesis is not a sketch because there is a leaf node (namely ? 3 ) of type tbl that does not have a corresponding qualifier. On the other hand, the refinement tree shown in Figure <ref type="figure" target="#fig_1">7</ref> (left) is a sketch and corresponds to the partial program π(x 1 , ?) where ? is a list of column names. Furthermore, this sketch states that variable x 1 corresponds to table T from the input-output example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7. (Complete program)</head><p>A complete program is a hypothesis where all leaf nodes are of the form (? i : τ )@Q.</p><p>In other words, a complete program fully specifies the expression represented by each ? in the hypothesis. For instance, a hypothesis that represents a complete program is shown in Figure <ref type="figure" target="#fig_1">7</ref> (right) and represents the relational algebra term λx 1 .π name, year (x 1 ).</p><p>As mentioned in Section 1, our synthesis procedure relies on performing partial evaluation. Hence, we define a function [[H]] ∂ , shown in Figure <ref type="figure">4</ref>  <ref type="figure">9</ref>, where T 1 is Table <ref type="table" target="#tab_8">1</ref> from Figure <ref type="figure" target="#fig_2">8</ref>. The refinement tree on the right-hand-side of Figure <ref type="figure">9</ref> shows the result of partially evaluating H, where T 2 is Table <ref type="table" target="#tab_2">2</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Synthesis Algorithm</head><p>In this section, we describe the high-level structure of our synthesis algorithm, leaving the discussion of SMT-based deduction and sketch completion to the next two sections. As illustrated schematically in Figure <ref type="figure" target="#fig_0">10</ref>, our synthesis algorithm maintains a priority queue of hypotheses, which are either converted into a sketch or refined to a more specific hypothesis during each iteration. Specifically, the synthesis procedure picks the most promising hypothesis H according to some heuristic cost metric (explained in Section 8) and asks the deduction engine if H can be successfully converted into a sketch. If the deduction engine refutes this conjecture, we then discard H but add all possible (one-level) refinements of H into the worklist. Otherwise, we convert hypothesis H into a sketch S and try to complete it using the sketch completion engine.</p><p>Algorithm 1 describes our top-level synthesis algorithm in more detail. Given an example E and a set of components Λ, SYNTHESIZE either returns a complete program that satisfies E or yields ⊥, meaning that no such program exists.</p><p>Internally, the SYNTHESIZE procedure maintains a priority queue W of all hypotheses. Initially, the only hypothesis  </p><formula xml:id="formula_8">T j ∈ T in H = (? i : tbl) H@(x j , T j ) ∈ Sketches(H, T in )<label>(1)</label></formula><formula xml:id="formula_9">H =? i : τ i τ i = tbl H ∈ Sketches(H, T in )<label>(2)</label></formula><formula xml:id="formula_10">H =? X i (H 1 , ..., H n ) H ′ i ∈ Sketches(H i , T in ) ? X i (H ′ 1 , ..., H ′ n ) ∈ Sketches(H, T in )<label>(3)</label></formula><formula xml:id="formula_11">W := W \{H} 8: if DEDUCE(H, E) = ⊥ then ⊲ Contradiction 9:</formula><p>goto refine; </p><formula xml:id="formula_12">H ′ := H[? X j (? j : τ )/? i ]</formula><p>18:</p><formula xml:id="formula_13">W := W ∪ H ′ 19:</formula><p>return ⊥ in W is ? 0 , which represents any possible program. In each iteration of the while loop (lines 5-18), we pick a hypothesis H from W and invoke the DEDUCE procedure (explained later) to check if H can be directly converted into a sketch by filling holes of type tbl with the input variables. Note that our deduction procedure is sound but, in general, not complete: Since component specifications are over-approximate, the deduction procedure can return ⊤ (i.e., true) even though no valid completion of the sketch exists. However, DEDUCE returns ⊥ only when the current hypothesis requires further refinement. Hence, the use of deduction does not lead to a loss of completeness in our overall synthesis approach. If DEDUCE does not find a conflict, we then convert the current hypothesis H into a set of possible sketches (line 11). The function SKETCHES used at line 11 is presented using inference rules in Figure <ref type="figure" target="#fig_3">11</ref>. Effectively, we convert hypothesis H into a sketch by replacing each hole of type tbl with one of the input variables x j , which corresponds to table T j in the input-output example. Now, given a candidate sketch S, we try to complete it using the call to FILLSKETCH at line 12 (explained in Section 7). FILLSKETCH returns a set of complete programs P such that each p ∈ P is valid with respect to our deduction procedure. However, as our deduction procedure is incomplete, p may not satisfy the input-output examples. Hence, we only return p as a solution if p satisfies E (line 14).</p><p>Lines 16-18 of Algorithm 1 perform hypothesis refinement. The idea behind hypothesis refinement is to replace one of the holes of type tbl in H with a component from Λ T , thereby obtaining a more specific hypothesis. Each of the refined hypotheses is added to the worklist and possibly converted into a sketch in future iterations.</p><formula xml:id="formula_14">Φ(Hi) = α([[Hi]] ∂ )[?i/x] if ¬PARTIAL([[Hi]] ∂ ) Φ(Hi) = ⊤ else if ISLEAF(Hi) Φ(? X 0 (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SMT-based Deduction</head><p>In the previous section, we described the structure of the synthesis algorithm, but did not yet explain the underlying deductive reasoning engine. The key idea here is to generate an SMT formula that corresponds to the specification of the current sketch and to check whether the input-output example satisfies this specification.</p><p>Component specifications. We use the specifications of individual components to derive the overall specification for a given hypothesis. As mentioned earlier, these specifications need not be precise and can, in general, over-approximate the behavior of the components. For instance, Table <ref type="table" target="#tab_8">1</ref> shows sample specifications for a subset of methods from two popular R libraries. Note that these sample specifications do not fully capture the behavior of each component and only describe the relationship between the number of rows and columns in the input and output tables. <ref type="foot" target="#foot_2">2</ref> For example, consider the filter function from the dplyr library for selecting a subset of the rows that satisfy a given predicate in the data frame. The specification of filter, which is effectively the selection operator σ from relational algebra, is given by:</p><formula xml:id="formula_15">T out .row &lt; T in .row ∧ T out .col = T in .col</formula><p>In other words, this specification expresses that the table obtained after applying the filter function contains fewer rows but the same number of columns as the input table. <ref type="foot" target="#foot_3">3</ref>Generating specification for hypothesis. Given a hypothesis H, we need to generate the specification for H using the specifications of the individual components used in H. Towards this goal, the function Φ(H) defined in Figure <ref type="figure" target="#fig_4">12</ref> returns the specification of hypothesis H.</p><p>In the simplest case, H i corresponds to a complete program (line 1 of Figure <ref type="figure" target="#fig_4">12</ref>) <ref type="foot" target="#foot_4">4</ref> . In this case, we evaluate the hy-pothesis to a table T and obtain Φ(H i ) as the "abstraction" of T. In particular, the abstraction function α used in Figure <ref type="figure" target="#fig_4">12</ref> takes as input a concrete table T and returns a constraint describing that table. In general, the definition of the abstraction function α depends on the granularity of the component specifications. For instance, if our component specifications only refer to the number of rows and columns, then a suitable abstraction function for an m × n table would yield x.row = m ∧ x.col = n. In general, we assume variable x is used to describe the input table of α.</p><p>Let us now consider the second case in Figure <ref type="figure" target="#fig_4">12</ref> where H i is a leaf, but not a complete program. In this case, since we do not have any information about what H i represents, we return ⊤ (i.e., true) as the specification.</p><p>Finally, let us consider the case where the hypothesis is of the form ? X 0 (H 1 , . . . , H n ). In this case, we first recursively infer the specifications of sub-hypotheses H 1 , . . . , H n . Now suppose that the specification of X is given by φ X ( x, y), where x and y denote X 's inputs and output respectively. If the root variable of each hypothesis H i is given by ? i , then the specification for the overall hypothesis is obtained as:</p><formula xml:id="formula_16">1≤i≤n Φ(H i ) ∧ φ χ [? 0 /y, ? i / x i ]</formula><p>Example 9. Consider hypothesis H from Figure <ref type="figure">6</ref>, and suppose that the specifications for relational algebra operators π and σ are the same as select and filter from Table 1 respectively. Then, Φ(H) corresponds to the following Presburger arithmetic formula: ? 1 .row &lt;? 3 .row ∧ ? 1 .col =? 3 .col ∧ ? 0 .row =? 1 .row ∧ ? 0 .col &lt;? 1 .col Here, ? 3 , ? 0 denote the input and output tables respectively, and ? 1 is the intermediate table obtained after selection. Deduction using SMT. Algorithm 2 presents our deduction algorithm using the constraint generation function Φ defined in Figure <ref type="figure" target="#fig_4">12</ref>. Given a hypothesis H and input-output example E, DEDUCE returns ⊥ if H does not correspond to a valid sketch. In other words, DEDUCE(H, E) = ⊥ means that we cannot obtain a program that satisfies the inputoutput examples by replacing holes with inputs.</p><p>As shown in Algorithm 2, the DEDUCE procedure generates a constraint ψ and checks its satisfiability using an SMT solver. If ψ is unsatisfiable, hypothesis H cannot be unified with the input-output example and can therefore be rejected.</p><p>Let us now consider the construction of SMT formula ψ in Algorithm 2. First, given a hypothesis H, the corresponding sketch must map each of the unknowns of type tbl to one of the arguments. Hence, the constraint ϕ in generated at line 5 indicates that each leaf with label ? j corresponds to some argument x i . Similarly, ϕ out expresses that of the SYNTHESIZE procedure (Algorithm 1), it can be a complete program when DEDUCE is invoked through the sketch completion engine. </p><formula xml:id="formula_17">ϕ in := ?j ∈S 1≤i≤|Ein| (? j = x i ) 6:</formula><p>ϕ out := (y =ROOTVAR(H))</p><p>7:</p><formula xml:id="formula_18">ψ := Φ(H) ∧ ϕ in ∧ ϕ out ∧ Ti∈Ein (α(T i )[x i /x]) ∧ α(T out )[y/x] 8:</formula><p>return SAT(ψ)</p><p>the root variable of hypothesis H must correspond to the return value y of the synthesized program. Hence, the constraint Φ(H) ∧ ϕ in ∧ ϕ out expresses the specification of the sketch in terms of variables x 1 , . . . , x n , y. Now, to check if H is unifiable with example E, we must also generate constraints that describe each table T i in in terms of x i and T out in terms of y. Recall from earlier that the abstraction function α(T) generates an SMT formula describing T in terms of variable x. Hence, the constraint</p><formula xml:id="formula_19">Ti∈Ein (α(T i )[x i /x]) ∧ α(T out )[y/x]</formula><p>expresses that each T i in must correspond to x i and T out must correspond to variable y. Thus, the unsatisfiability of formula ψ at line 7 indicates that hypothesis H can be rejected. Example 10. Consider the hypothesis from Figure <ref type="figure">6</ref>, and suppose that the input and output tables are T 1 and T 2 from Figure <ref type="figure" target="#fig_2">8</ref> respectively. The DEDUCE procedure from Algorithm 2 generates the following constraint ψ:</p><formula xml:id="formula_20">? 1 .row &lt;? 3 .row ∧ ? 1 .col =? 3 .col ∧? 0 .row =? 1 .row ∧ ? 0 .col &lt;? 1 .col ∧ x 1 =? 3 ∧ y =? 0 ∧ x 1 .row = 3 ∧ x 1 .col = 4 ∧ y.row = 2 ∧ y.col = 4</formula><p>Observe that Φ(H) ∧ ϕ in ∧ ϕ out implies y.col &lt; x 1 .col, indicating that the output table should have fewer columns than the input table. Since we have x 1 .col = y.col, constraint ψ is unsatisfiable, allowing us to reject the hypothesis.</p><formula xml:id="formula_21">τ = (τ1 × . . . × τn → τ ′ ) Γ ′ = Γ ∪ {x1 : τ1, . . . xn : τn} Γ ′ ⊢ t ∈ Ω(τ ′ , T) Γ ⊢ (λx1, . . . , xn. t) ∈ Ω(τ, T) (Lambda)</formula><p>Figure <ref type="figure" target="#fig_0">13</ref>. Table-driven type inhabitation rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Sketch Completion</head><p>The goal of sketch completion is to fill the remaining holes in the hypothesis with first-order functions constructed using components in Λ v . For instance, consider the sketch π(σ(x, ? 1 ), ? 2 ) where π, σ are the familiar projection and selection operators from relational algebra. Now, in order to fill hole ? 1 , we need to know the columns in table x. Similarly, in order to fill hole ? 2 , we need to know the columns in the intermediate table obtained using selection.</p><p>As this example illustrates, the vocabulary of first-order functions that can be supplied as arguments to table transformers often depends on the shapes (i.e., schemas) of the other arguments of type tbl. For this reason, our sketch completion algorithm synthesizes the program bottom-up, evaluating terms of type tbl before synthesizing the other arguments. Furthermore, as discussed in Section 1, the completion of program sketches in a bottom-up manner allows us to perform partial evaluation, which in turn increases the effectiveness of the deductive reasoning engine.</p><formula xml:id="formula_22">S = (?i : τi) t ∈ Ω(τi, T, ∅) DEDUCE(S f [S@t/S], E) = ⊥ S@t ∈ Cv(S, S f , E, T)<label>(1)</label></formula><p>S = (?i, tbl)@(x, T)</p><formula xml:id="formula_23">(S, T) ∈ C T (S, S f , E)<label>(2)</label></formula><formula xml:id="formula_24">S =? X i ( H : tbl, H ′ : τ ) (τ = tbl) (Pj, Tj) ∈ C T (Hj, S f , E) P ′ j ∈ Cv(H ′ j , S f [ P/ H], E, T1 × . . . × Tn) DEDUCE(S f [ P/ H, P ′ / H ′ ], E) = ⊥ P * = S[ P/ H, P ′ / H ′ ] (P * , [[P * ]] ∂ ) ∈ C T (S, S f , E)<label>(3)</label></formula><p>(P, T) ∈ C T (S, S, E) P ∈ FILLSKETCH(S, E)  We formalize this variant of the type inhabitation problem using the inference rules shown in Figure <ref type="figure" target="#fig_0">13</ref>. Specifically, these rules derive judgments of the form Γ ⊢ t ∈ Ω(τ, T) where Γ is a type environment mapping variables to types. The meaning of this judgment is that, under type environment Γ, term t is a valid inhabitant of type τ with respect to table T. Observe that we need the type environment Γ due to the presence of function types: That is, given a function type τ 1 → τ 2 , we need Γ to enumerate valid inhabitants of τ 2 . Since the typing rules from Figure <ref type="figure" target="#fig_0">13</ref> resemble those for the simply-typed lambda calculus, we do not explain them in detail. The main difference is that constants of type cols are drawn from lists of column names from the table schema, and constants of type num and string are drawn from values in the table.</p><p>Example 11. Consider table T 1 from Figure <ref type="figure" target="#fig_2">8</ref> and the type environment Γ : {x → string}. Assuming eq : string × string → bool is a component in Λ v , we have eq(x, "Alice") ∈ Ω(bool, T 1 ) using the App, Const, Var rules. Similarly, λx.eq(x, "Bob") is also a valid inhabitant of string → bool with respect to T 1 . Sketch completion algorithm. Our sketch completion procedure is described using the inference rules shown in Figure <ref type="figure" target="#fig_5">14</ref>. As mentioned previously, the algorithm is bottom-up and first synthesizes all arguments of type tbl before syn- thesizing other arguments. Given sketch S and example E, FILLSKETCH(S, E) returns a set of hypotheses representing complete well-typed programs that are valid with respect to our deduction system. The first rule in Figure <ref type="figure" target="#fig_5">14</ref> corresponds to a base case of the FILLSKETCH procedure and is used for completing hypotheses that are not of type tbl. Here, S represents a subpart of the sketch that we want to complete, T is the table that should be used in completing S, and S f is the full sketch. Since S represents an unknown expression of type τ i , we use the type inhabitation rules from Figure <ref type="figure" target="#fig_0">13</ref> to find a welltyped instantiation t of τ i with respect to table T. Given completion t of ? i , the full sketch now becomes S f [S@t/S], and we use the deduction system to check whether the new hypothesis is valid. Since our deduction procedure uses partial evaluation, we may now be able to obtain a concrete table for some part of the sketch, thereby enhancing the power of deductive reasoning.</p><p>The second rule from Figure <ref type="figure" target="#fig_5">14</ref> is also a base case of the FILLSKETCH procedure. Since any leaf ? i of type tbl is already bound to some input variable x in the sketch, there is nothing to complete; hence, we just return S itself.</p><p>Rule (3) corresponds to the recursive step of the FILLS-KETCH procure and is used to complete a sketch with topmost component χ. Specifically, consider a sketch of the form ? χ i ( H, H ′ ) where H denotes arguments of type tbl and H ′ represents first-order functions. Since the vocabulary of H ′ depends on the completion of H (as explained earlier), we first recursively synthesize H and obtain a set of complete programs P, together with their partial evaluation T 1 , . . . , T n . Now, observe that each H ′ j ∈ H ′ can refer to any of the columns in T 1 ×...×T n ; hence we recursively synthesize the remaining arguments H ′ using table T 1 × ... × T n . Now, suppose that the hypotheses H and H ′ are completed using terms P and P ′ respectively, and the new (partially filled) sketch is now S f [ P/ H, P ′ / H ′ ]. Since there is an opportunity for rejecting this partially filled sketch, we again check whether S f [ P/ H, P ′ / H ′ ] is consistent with the inputoutput examples using deduction.</p><p>Example 12. Consider hypothesis H from Figure <ref type="figure">6</ref>, the input table T 1 from Figure <ref type="figure" target="#fig_2">8</ref>, and the output table T 3 from Figure <ref type="figure" target="#fig_6">15</ref>. We can successfully convert this hypothesis into the sketch λx.? π 0 (? σ 1 (? 3 @(x, T 1 ), ? 4 ), ? 2 ). Since FILLS-KETCH is bottom-up, it first tries to fill hole ? 4 . In this case, suppose that we try to instantiate hole ? 4 with the predicate age &gt; 12 using rule (1) from Figure <ref type="figure" target="#fig_5">14</ref>. However, when we call DEDUCE on the partially-completed sketch λx.? π 0 (? σ 1 (? 3 @(x, T 1 ), age &gt; 12), ? 2 ), ? 1 is refined as T 4 in Figure <ref type="figure" target="#fig_6">15</ref> and we obtain the following constraint:</p><formula xml:id="formula_26">? 1 .row &lt;? 3 .row ∧ ? 1 .col =? 3 .col ∧? 0 .row =? 1 .row ∧ ? 0 .col &lt;? 1 .col ∧ x 1 =? 3 ∧ x 1 .row = 3 ∧ x 1 .col = 4 ∧ y =? 0 ∧ y.row = 2 ∧ y.col = 3 ∧ ?1.col = 4 ∧ ?1.row = 1</formula><p>Note that the last two conjuncts (underlined) are obtained using partial evaluation. Since this formula is unsatisfiable, we can reject this hypothesis without having to fill hole ? 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Implementation</head><p>We have implemented our synthesis algorithm in a tool called MORPHEUS, written in C++. MORPHEUS uses the Z3 SMT solver <ref type="bibr" target="#b7">[8]</ref> with the theory of Linear Integer Arithmetic for checking the satisfiability of constraints generated by our deduction engine.</p><p>Recall from Section 5 that MORPHEUS uses a cost model for picking the "best" hypothesis from the worklist. Inspired by previous work on code completion <ref type="bibr" target="#b27">[28]</ref>, we use a cost model based on a statistical analysis of existing code. Specifically, MORPHEUS analyzes existing code snippets that use components from Λ T and represents each snippet as a 'sentence' where 'words' correspond to components in Λ T . Given this representation, MORPHEUS uses the 2-gram model in SRILM <ref type="bibr" target="#b33">[34]</ref> to assign a score to each hypothesis. Specifically, we train our language model by collecting approximately 15,000 code snippets from Stackoverflow using the search keywords tidyr and dplyr. For each code snippet, we ignore its control flow and represent it using a "sentence" where each "word" corresponds to an API call. Based on this training data, the hypotheses in the worklist W from Algorithm 1 are then ordered using the scores obtained from the n-gram model.</p><p>Following the Occam's razor principle, MORPHEUS explores hypotheses in increasing order of size. However, if the size of the correct hypothesis is a large number k, MOR-PHEUS may end up exploring many programs before reaching length k. In practice, we have found that a better strategy is to exploit the inherent parallelism of our algorithm. Specifically, MORPHEUS uses multiple threads to search for solutions of different sizes and terminates as soon as any thread finds a correct solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Evaluation</head><p>To evaluate our method, we collected 80 data preparation tasks, all of which are drawn from discussions among R users on Stackoverflow. The MORPHEUS project webpage <ref type="bibr" target="#b3">[4]</ref> contains (i) the Stackoverflow post for each benchmark, (ii) an input-output example, and (iii) the solution synthesized by MORPHEUS.</p><p>Our evaluation aims to answer the following questions:</p><p>Q1. Can MORPHEUS successfully automate real-world data preparation tasks and what is its running time?</p><p>Q2. How big are the benefits of SMT-based deduction and partial evaluation in the performance of MORPHEUS?</p><p>Q3. How complex are the data preparation tasks that can be successfully automated using MORPHEUS?</p><p>Q4. Are there existing synthesis tools that can also automate the data preparation tasks supported by MORPHEUS?</p><p>To answer these questions, we performed a series of experiments on the 80 data preparation benchmarks, using the input-output examples provided by the authors of the Stackoverflow posts. In these experiments, we use the table transformation components provided by two popular table manipulation libraries, namely tidyr and dplyr. The value transformers we use in our evaluation include standard comparison operators such as &lt; , &gt; as well as aggregate functions like MEAN and SUM. In total, our experiments make use of a total of 20 different components. All experiments are conducted on an Intel Xeon(R) computer with an E5-2640 v3 CPU and 32G of memory, running the Ubuntu 16.04 operating system and using a timeout of 5 minutes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of results.</head><p>The results of our evaluation are summarized in Figure <ref type="figure" target="#fig_0">16</ref>. Here, the "Description" column provides a brief English description of each category, and the column "#" shows the number of benchmarks in each category. The "No deduction" column indicates the running time of a version of MORPHEUS that uses purely enumerative search without deduction. (This basic version still uses the statistical analysis described in Section 8 to choose the "best" hypothesis.) The columns labeled "Spec 1" and "Spec 2" show variants of MORPHEUS using two different component specifications. Specifically, Spec 1 is less precise and only constrains the relationship between the number of rows and columns, as shown in Table <ref type="table" target="#tab_8">1</ref>. On the other hand, Spec 2 is strictly more precise than Spec 1 and also uses other information, such as cardinality and number of groups.</p><p>Performance. As shown in Figure <ref type="figure" target="#fig_0">16</ref>, the full-fledged version of MORPHEUS (using the more precise component specifications) can successfully synthesize 78 out of the 80 benchmarks and times out on only 2 problems. Hence, overall, MORPHEUS achieves a success rate of 97.5% within a 5-minute time limit. MORPHEUS's median running time on these benchmarks is 3.59 seconds, and 86.3% of the benchmarks can be synthesized within 60 seconds. However, it is worth noting that running time is actually dominated by the R interpreter: MORPHEUS spends roughly 68% of the time in the R interpreter, while using only 15% of its running time to perform deduction (i.e., solve SMT formulas). Since the overhead of the R interpreter can be significantly reduced with sufficient engineering effort, we believe there is considerable room for improving MORPHEUS's running time. However, even in its current form, these results show that MORPHEUS is practical enough to automate a diverse class of data preparation tasks within a reasonable time limit.  <ref type="figure" target="#fig_0">16</ref> shows, deduction has a huge positive impact on the algorithm. The basic version of MORPHEUS that does not perform deduction times out on 32.5% of the benchmarks and achieves a median running time of 95.53 seconds. On the other hand, if we use the coarse specifications given by Spec 1, we already observe a significant improvement. Specifically, using Spec 1, MOR-PHEUS can successfully solve 68 out of the 80 benchmarks, with a median running time of 8.57 seconds. These results show that even coarse and easy-to-write specifications can have a significant positive impact on synthesis.</p><p>Impact of partial evaluation. . Impact of language model tial evaluation, MORPHEUS can only solve 62 benchmarks with median running time of 34.75 seconds using Spec 1 and 64 benchmarks with median running time of 17.07 seconds using Spec 2. When using partial evaluation, MORPHEUS can prune 72% of the partial programs without having to fill all holes in the sketch, thereby resulting in significant performance improvement.</p><p>Impact of language model. As described in Section 8, MORPHEUS uses a statistical language model (namely 2grams) for choosing the most promising hypothesis in its worklist. Even though the idea of using statistical language models is not a contribution of this paper and is inspired by the prior work of Raychev et al. <ref type="bibr" target="#b27">[28]</ref>, we nevertheless evaluate its impact on our benchmark set consisting of various data preparation tasks. Specifically, Figure <ref type="figure" target="#fig_2">18</ref> shows the percentage of benchmarks solved by MORPHEUS with and without a language model for ordering the hypotheses. As shown in Figure <ref type="figure" target="#fig_2">18</ref>, the use of the language model has a significant positive impact on the performance of MOR- Complexity of benchmarks. To evaluate the complexity of tasks that MORPHEUS can handle, we conducted a small user study involving 9 participants. Of the participants, four are senior software engineers at a leading data analytics company and do data preparation "for a living". The remaining 5 participants are proficient R programmers at a university and specialize in statistics, business analytics, and machine learning. We chose 5 representative examples from our 80 benchmarks and asked the participants to solve as many of them as possible within one hour. These benchmarks belong to four categories (C2, C3, C4, C7) and take between 0.22 and 204.83 seconds to be solved by MORPHEUS.</p><p>In our user study, the average participant completed 3 tasks within the one-hour time limit; however, only 2 of these tasks were solved correctly on average. These results suggest that our benchmarks are challenging even for proficient R programmers and expert data analysts.</p><p>Comparison with λ 2 . To demonstrate the advantages of our proposed approach over previous component-based synthesis techniques, we compared MORPHEUS with λ 2 <ref type="bibr" target="#b9">[10]</ref>, which is a general-purpose tool for synthesizing higherorder functional programs over data structures. Since λ 2 does not have built-in support for tables, we evaluated λ 2 on the benchmarks from Figure <ref type="figure" target="#fig_0">16</ref> by representing each table as a list of lists. Even though we confirmed that λ 2 can synthesize very simple table transformations involve projection and selection, it was not able to successfully synthesize any of the benchmarks used in our evaluation. Upon further inspection, we believe that λ 2 fails to synthesize many of our benchmarks for two reasons: First, hypotheses in λ 2 are restricted to be of the form λx. F e x, where F is a higher-order combinator, e is an expression and x is the input. However, many of our benchmarks re-quire more general hypotheses of the form λx.F e 1 e 2 where e 1 , e 2 are arbitrary expressions. Furthermore, λ 2 can only perform deduction for a built-in set of higher-order combinators for which it is possible to infer concrete input-output examples for the sub-components. However, many of the benchmarks used in our evaluation are difficult to express concisely using the set of combinators supported by λ 2 .</p><p>Comparison with SQLSynthesizer. Since MORPHEUS is a general tool that can be used to synthesize many kinds of table transformations, we also compare it against SQLSYN-THESIZER, which is a specialized tool for synthesizing SQL queries from examples <ref type="bibr" target="#b36">[37]</ref>. To compare MORPHEUS with SQLSYNTHESIZER, we used two different sets of benchmarks. First, we evaluated SQLSYNTHESIZER on the 80 data preparation benchmarks from Figure <ref type="figure" target="#fig_0">16</ref>. Note that some of the data preparation tasks used in our evaluation cannot be expressed using SQL, and therefore fall beyond the scope of tool like SQLSYNTHESIZER. Among our 80 benchmarks, SQLSYNTHESIZER was only able to successfully solve one.</p><p>To understand how MORPHEUS compares with SQL-SYNTHESIZER on a narrower set of table transformation tasks, we also evaluated both tools on the 28 benchmarks used in evaluating SQLSYNTHESIZER <ref type="bibr" target="#b36">[37]</ref>. To solve these benchmarks using MORPHEUS, we used the same inputoutput tables as SQLSYNTHESIZER and used a total of eight higher-order components that are relevant to SQL. As shown in Figure <ref type="figure" target="#fig_0">19</ref>, MORPHEUS also outperforms SQLSYNTHE-SIZER on these benchmarks. In particular, MORPHEUS can solve 96.4% of the SQL benchmarks with a median running time of 1 second whereas SQLSYNTHESIZER can solve only 71.4% with a median running time of 11 seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Related Work</head><p>In this section, we compare and contrast our approach with prior synthesis techniques.</p><p>PBE for table transformations. This paper is related to a line of work on programming-by-example (PBE) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b35">36]</ref>. Of particular relevance are PBE techniques that focus on table transformations <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b36">37]</ref>. Among these techniques, FLASHEXTRACT and FLASHRELATE address the specific problem of extracting structured data from spreadsheets and do not consider a general class of table transformations. More closely related are Harris and Gulwani's work on synthesis of spreadsheet transformations <ref type="bibr" target="#b16">[17]</ref> and Zhang et al.'s work on synthesizing SQL queries <ref type="bibr" target="#b36">[37]</ref>. Our approach is more general than these methods in that they use DSLs with a fixed set of primitive operations (components), whereas our approach takes a set of components as a parameter. For instance, Zhang et al. cannot synthesize programs that perform table reshaping while Harris et al. supports data reshaping, but not computation or consolidation. Hence, these approaches cannot automate many of the data preparation tasks that we consider. Data wrangling. Another term for data preparation is "data wrangling", and prior work has considered methods to facilitate such tasks. For instance, WRANGLER is an interactive visual system that aims to simplify data wrangling <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20]</ref>. OPENREFINE is a general framework that helps users perform data transformations and clean messy data. Tools such as WRANGLER and OPENREFINE facilitate a larger class of data wrangling tasks than MORPHEUS, but they do not automatically synthesize table transformations from examples.</p><p>Synthesis using deduction and search. Our work builds on recent synthesis techniques that combine enumeration and deduction <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b35">36]</ref>. The closest work in this space is λ 2 , which synthesizes functional programs using deduction and cost-directed enumeration <ref type="bibr" target="#b9">[10]</ref>. Like λ 2 , we differentiate between higher-order and first-order combinators and use deduction to prune partial programs. However, the key difference from prior techniques is that our deduction capabilities are not customized to a specific set of components. For example, λ 2 only supports a fixed set of higher-order combinators and uses "baked-in" deductive reasoning to reject partial programs. Furthermore, as described in Section 9, λ 2 restricts hypotheses to be of a certain shape and can only perform deduction in cases where it is possible to infer concrete input-output examples for the nested hypotheses. In contrast, our approach supports any higher-order component and can utilize arbitrary first-order specifications to reject hypotheses using SMT solving. Also related is FLASHMETA, which gives a generic method for constructing example-driven synthesizers for user-defined DSLs <ref type="bibr" target="#b26">[27]</ref>. The methodology we propose in this paper is quite different from FLASHMETA. FLASH-META uses version space algebras to represent all programs consistent with the examples and employs deduction to decompose the synthesis task. In contrast, we use enumerative search to find one program that satisfies the examples and use SMT-based deduction to reject partial programs.</p><p>Component-based synthesis. Component-based synthesis refers to generating (straight-line) programs from a set of components, such as methods provided by an API <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b29">30]</ref>. Some of these efforts <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18]</ref> use an SMTsolver to search for a composition of components. In contrast, our approach uses an SMT-solver as a pruning tool in enumerative search and does not require precise specifications of components. Another related work in this space is SYPET <ref type="bibr" target="#b8">[9]</ref>, which searches for well-typed programs using a Petri net representation. Similar to this work, SYPET can also work with any set of components and decomposes synthesis into two separate sketch generation and sketch completion phases. However, both the application domains (Java APIs vs. table transformations) and the underlying techniques (Petri net reachability vs. SMT-based deduction) are very different. Finally, another related approach is Bigλ <ref type="bibr" target="#b29">[30]</ref>, which can synthesize non-trivial data-parallel programs using a set of pre-defined components. However, unlike MORPHEUS, Bigλ does not incorporate deductive reasoning to prune the search space.</p><p>Synthesis as type inhabitation. Our approach also resembles prior work that has framed synthesis as type inhabitation <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26]</ref>. Of these approaches, INSYNTH <ref type="bibr" target="#b15">[16]</ref> is type-directed rather than example-directed. MYTH <ref type="bibr" target="#b23">[24]</ref> and its successors <ref type="bibr" target="#b10">[11]</ref> cast type-and example-directed synthesis as type inhabitation in a refinement type system. In contrast to these techniques, our approach only enumerates type inhabitants in the context of sketch completion and uses table contents to finitize the universe of constants.</p><p>Another work that is closely related to MORPHEUS is SYNQUID <ref type="bibr" target="#b25">[26]</ref>, which takes advantage of recent advances in polymorphic refinement types <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b34">35]</ref>. Similar to our approach, SYNQUID also adopts a type-directed SMT-based deduction system to prune its search space. However, unlike our system which can work with any incomplete (overapproximate) specification, SYNQUID requires precise specifications of the underlying components. In other words, SYNQUID fails to synthesize the desired program if the component specifications are over-approximate. Since it is difficult to write precise specifications of many library methods, we believe that MORPHEUS's ability to perform lightweight deduction using incomplete specifications can be useful in many different contexts.</p><p>Sketch. In program sketching, the user provides a partial program containing holes, which are completed by the synthesizer in a way that respects user-provided invariants (e.g., assertions) <ref type="bibr" target="#b30">[31]</ref><ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref>. While we also use the term "sketch" to denote partial programs with unknown expressions, the holes in our program sketches can be arbitrary expressions over first-order components. In contrast, holes in the SKETCH system typically correspond to constants <ref type="bibr" target="#b32">[33]</ref>. Furthermore, our approach automatically generates program sketches rather than requiring the user to provide the sketch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">Conclusion</head><p>We have presented a new component-based synthesis algorithm that combines type-directed enumerative search with lightweight SMT-based deduction and partial evaluation. Given a set of components equipped with over-approximate logical specifications, our approach automatically infers logical specifications of partial programs and uses SMT-based reasoning to prune the search space. Our approach further increases the power of its deductive reasoning engine by employing partial evaluation. We have applied the proposed ideas to automate a large class of data preparation tasks that involve table consolidation and reshaping. As shown in our experimental evaluation, our tool, MORPHEUS, can automate challenging data wrangling tasks that are difficult even for proficient R programmers. Our tool is publicly available <ref type="bibr" target="#b3">[4]</ref> and will also be released as an RStudio plug-in.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Overview of our approach</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. A sketch (left) and a complete program (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Tables for Example 8</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Converting a hypothesis into a sketch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. Constraint generation for hypotheses. ?i denotes the root variable of Hi and the specification of X is φX . Function α generates an SMT formula describing its input table.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Sketch completion rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 15 .</head><label>15</label><figDesc>Figure 15. Tablesfor Example 12</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 17 2 Figure 18</head><label>17218</label><figDesc>Figure 18. Impact of language model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>sum(n))</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>flight origin</cell><cell>dest</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>id year A B</cell><cell>11</cell><cell>EWR</cell><cell>SEA</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>1 2007 5 10</cell><cell>725</cell><cell>JFK</cell><cell>BQN</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>2 2009 3 50</cell><cell>495</cell><cell>JFK</cell><cell>SEA</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>1 2007 5 17</cell><cell>461</cell><cell>LGA</cell><cell>ATL</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>2 2009 6 17</cell><cell>1696 EWR ORD</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1670 EWR</cell><cell>SEA</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>(a)</cell><cell>(b)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Figure 2. (a) Data frame for Example 1; (b) for Example 2.</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">MORPHEUS can automatically synthesize the following R</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">program to extract the desired information:</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">df1=filter(input, dest == "SEA")</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">df2=summarize(group by(df1, origin), n = n())</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">df3=mutate(df2, prop = n /</cell></row><row><cell cols="5">id A 2007 B 2007 A 2009 B 2009</cell></row><row><cell>1</cell><cell>5</cell><cell>10</cell><cell>5</cell><cell>17</cell></row><row><cell>2</cell><cell>3</cell><cell>50</cell><cell>6</cell><cell>17</cell></row><row><cell cols="5">Even though the user is quite familiar with R libraries for</cell></row><row><cell cols="5">data preparation, she is still not able to perform the desired</cell></row><row><cell cols="5">task. Given this example, MORPHEUS can automatically</cell></row><row><cell cols="4">synthesize the following R program:</cell><cell></cell></row><row><cell cols="4">df1=gather(input,var,val,id,A,B)</cell><cell></cell></row><row><cell cols="4">df2=unite(df1,yearvar,var,year)</cell><cell></cell></row><row><cell cols="4">df3=spread(df2,yearvar,val)</cell><cell></cell></row><row><cell cols="5">Observe that this example requires both reshaping the</cell></row><row><cell cols="5">table and appending contents of some cells to column names.</cell></row><row><cell cols="5">Example 2. Another R user has the data frame from Fig-</cell></row><row><cell cols="5">ure 2(b) and wants to compute, for each source location L,</cell></row><row><cell></cell><cell cols="2">origin n</cell><cell>prop</cell><cell></cell></row><row><cell></cell><cell>EWR</cell><cell cols="2">2 0.6666667</cell><cell></cell></row><row><cell></cell><cell>JFK</cell><cell cols="2">1 0.3333333</cell><cell></cell></row></table><note><p><p><p>the number and percentage of flights that go to Seattle (SEA) from L</p><ref type="bibr" target="#b1">[2]</ref></p>. In particular, the output should be as follows:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :Table 2 :</head><label>12</label><figDesc></figDesc><table><row><cell cols="4">frame X1 X2 X3</cell><cell>frame</cell><cell>X1</cell><cell>X2</cell><cell>X3</cell></row><row><cell>1</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell>2</cell><cell cols="2">10 15</cell><cell>0</cell><cell>2</cell><cell cols="2">14.53 12.57</cell><cell>0</cell></row><row><cell>3</cell><cell cols="2">15 10</cell><cell>0</cell><cell>3</cell><cell cols="2">13.90 14.65</cell><cell>0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 has a similar structure as Table 1 but contains the speeds of the vehicles instead of their identification number. For example, at frame 3, the speed of the vehicle with ID 15 is 13.90 m/s. The data analyst wants to consolidate these two data frames into a new table with the following shape:</head><label>2</label><figDesc></figDesc><table><row><cell cols="4">frame pos carid speed</cell></row><row><cell>2</cell><cell>X1</cell><cell>10</cell><cell>14.53</cell></row><row><cell>3</cell><cell>X2</cell><cell>10</cell><cell>14.65</cell></row><row><cell>2</cell><cell>X2</cell><cell>15</cell><cell>12.57</cell></row><row><cell>3</cell><cell>X1</cell><cell>15</cell><cell>13.90</cell></row><row><cell cols="4">Despite looking into R libraries for data preparation, the</cell></row><row><cell cols="4">analyst still cannot figure out how to perform this task and</cell></row><row><cell cols="4">asks for help on Stackoverflow. MORPHEUS can synthesize</cell></row><row><cell cols="4">the following R program to automate this complex task:</cell></row><row><cell cols="4">df1=gather(table1,pos,carid,X1,X2,X3)</cell></row><row><cell cols="4">df2=gather(table2,pos,speed,X1,X2,X3)</cell></row><row><cell cols="2">df3=inner join(df1,df2)</cell><cell></cell><cell></cell></row><row><cell cols="3">df4=filter(df3,carid != 0)</cell><cell></cell></row><row><cell cols="3">df5=arrange(df4,carid,frame)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>In contrast, an aggregate function such as sum that takes a list of values and returns their sum is a value transformer. Similarly, the boolean operator ≥ is also a value transformer.</figDesc><table><row><cell>Cell type γ</cell><cell>:= num | string</cell></row><row><cell cols="2">Primitive type β := γ | bool | cols</cell></row><row><cell>Table type tbl</cell><cell>:= {l1 : γ1, ..., ln : γn} (row &lt;: tbl)</cell></row><row><cell>Type τ</cell><cell>:= β | tbl | τ1 → τ2 | τ1 × τ2</cell></row><row><cell cols="2">Figure 3. Types used in components; cols represents a list</cell></row><row><cell cols="2">of strings where each string is a column name in some table.</cell></row><row><cell cols="2">Example 4. Consider the selection operator σ from rela-</cell></row><row><cell cols="2">tional algebra, which takes a table and a predicate and re-</cell></row><row><cell cols="2">turns a table. In our terminology, such a component is a ta-</cell></row><row><cell>ble transformer.</cell><cell></cell></row></table><note><p>Definition 4. (Synthesis problem) Given specification (E, Λ) where E = ( T in , T out ), the synthesis problem is to infer a program λ x.e such that (a) e is a well-typed expression over components in Λ, and (b) (λ x.e) T in = T out .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>, for partially evaluating hypothesis H. Observe that, if H is a complete program, then [[H]] ∂ evaluates to a concrete table. Otherwise, [[H]] ∂ returns a partially evaluated hypothesis. We write PARTIAL([[H]] ∂ ) if [[H]] ∂ does not evaluate to a concrete term (i.e., contains question marks).</figDesc><table /><note><p>Example 8. Consider hypothesis H on the left-hand side of Figure</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>from Figure8. Partial evaluation on hypothesis from Figure6; age&gt;8 stands for ? 4 : row → bool@λx. (x.age &gt; 8).</figDesc><table><row><cell></cell><cell></cell><cell cols="2">? π 0 : tbl</cell><cell>? π 0 : tbl</cell></row><row><cell cols="2">? σ 1 : tbl</cell><cell></cell><cell cols="2">? 2 : cols</cell><cell>(x 1 , T 2 ) ? 1 : tbl@</cell><cell>? 2 : cols</cell></row><row><cell cols="2">? 3 : tbl@(x 3 ,T 1 )</cell><cell>age&gt;8</cell><cell></cell></row><row><cell>Figure 9. Hypothesis</cell><cell cols="2">✗ candidate</cell><cell cols="2">SMT-based</cell></row><row><cell>Refinement</cell><cell cols="2">sketch</cell><cell cols="2">Deduction</cell></row><row><cell></cell><cell></cell><cell cols="2">sketch</cell><cell>✓</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Sketch Completion</cell><cell>✓</cell><cell>Program</cell></row></table><note><p>✗ Figure 10. Illustration of the top-level synthesis algorithm</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 1 .</head><label>1</label><figDesc>T out .row ≤ T in .row T out .col ≥ T in .col gather Takes multiple columns and collapses into keyvalue pairs, duplicating all other columns as needed. T out .row ≥ T in .row T out .col ≤ T in .col dplyr select Project a subset of columns in a data frame. T out .row = T in .row T out .col &lt; T in .col filter Select a subset of rows in a data frame. T out .row &lt; T in .row T out .col = T in .col Sample specifications of a few components</figDesc><table><row><cell></cell><cell cols="2">Lib Component</cell><cell>Description</cell><cell>Specification</cell></row><row><cell></cell><cell>tidyr</cell><cell>spread</cell><cell>Spread a key-value pair across multiple columns.</cell></row><row><cell cols="4">Algorithm 2 SMT-based Deduction Algorithm</cell></row><row><cell cols="3">1: procedure DEDUCE(H, E)</cell></row><row><cell>2:</cell><cell cols="3">input: Hypothesis H, input-output example E</cell></row><row><cell>3:</cell><cell cols="3">output: ⊥ if cannot be unified with E; ⊤ otherwise</cell></row><row><cell>4:</cell><cell></cell><cell></cell></row></table><note><p>S := {? j | ? j : tbl ∈ LEAVES(H)} 5:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table -</head><label>-</label><figDesc></figDesc><table /><note><p><p><p>driven type inhabitation. At a high level, our sketch completion procedure is type-directed and synthesizes an argument of type τ by enumerating all inhabitants of τ . However, as argued earlier, the valid inhabitants of type τ are determined by a particular table. Hence, we consider the table-driven variant of the standard type inhabitation problem: That is, given a type τ and a concrete table</p>T</p>, what are all valid inhabitants of τ with respect to the universe of constants used in T?</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>Figure 16. Summary of experimental results. All times are median in seconds and ✗ indicates a timeout (&gt; 5 minutes).</figDesc><table><row><cell></cell><cell>Category</cell><cell cols="2">Description</cell><cell></cell><cell>#</cell><cell cols="2">No deduction #Solved Time</cell><cell cols="2">Spec 1 #Solved Time</cell><cell>Spec 2 #Solved Time</cell></row><row><cell></cell><cell>C1</cell><cell cols="3">Reshaping dataframes from either "long" to "wide" or "wide" to "long"</cell><cell>4</cell><cell>2</cell><cell>198.14</cell><cell>4</cell><cell>15.48</cell><cell>4</cell><cell>6.70</cell></row><row><cell></cell><cell>C2</cell><cell cols="3">Arithmetic computations that produce values not present in the input tables</cell><cell>7</cell><cell>6</cell><cell>5.32</cell><cell>7</cell><cell>1.95</cell><cell>7</cell><cell>0.59</cell></row><row><cell></cell><cell>C3</cell><cell cols="3">Combination of reshaping and string manip-ulation of cell contents</cell><cell>34</cell><cell>28</cell><cell>51.01</cell><cell>31</cell><cell>6.53</cell><cell>34</cell><cell>1.63</cell></row><row><cell></cell><cell>C4</cell><cell cols="3">Reshaping and arithmetic computations</cell><cell>14</cell><cell>9</cell><cell>162.02</cell><cell>10</cell><cell>90.33</cell><cell>12</cell><cell>15.35</cell></row><row><cell></cell><cell></cell><cell cols="3">Combination of arithmetic computations</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>C5</cell><cell cols="3">and consolidation of information from mul-</cell><cell>11</cell><cell>7</cell><cell>8.72</cell><cell>10</cell><cell>3.16</cell><cell>11</cell><cell>3.17</cell></row><row><cell></cell><cell></cell><cell cols="2">tiple tables into a single table</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>C6</cell><cell cols="3">Arithmetic computations and string manipu-lation tasks</cell><cell>2</cell><cell>1</cell><cell>280.61</cell><cell>2</cell><cell>49.33</cell><cell>2</cell><cell>3.03</cell></row><row><cell></cell><cell>C7</cell><cell cols="3">Reshaping and consolidation tasks</cell><cell>1</cell><cell>0</cell><cell>✗</cell><cell>1</cell><cell>135.32</cell><cell>1</cell><cell>130.92</cell></row><row><cell></cell><cell>C8</cell><cell cols="3">Combination of reshaping, arithmetic com-putations and string manipulation</cell><cell>6</cell><cell>1</cell><cell>✗</cell><cell>3</cell><cell>198.42</cell><cell>6</cell><cell>38.42</cell></row><row><cell></cell><cell>C9</cell><cell cols="3">Combination of reshaping, arithmetic com-putations and consolidation</cell><cell>1</cell><cell>0</cell><cell>✗</cell><cell>0</cell><cell>✗</cell><cell>1</cell><cell>97.3</cell></row><row><cell></cell><cell></cell><cell>Total</cell><cell></cell><cell></cell><cell>80</cell><cell>54 (67.5%)</cell><cell>95.53</cell><cell>68 (85.0%)</cell><cell>8.57</cell><cell>78 (97.5%)</cell><cell>3.59</cell></row><row><cell></cell><cell>4,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>No deduction</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>3,000</cell><cell cols="2">Spec 1 (no p. eval) Spec 2 (no p. eval)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Time</cell><cell>2,000</cell><cell>Spec 1 (p. eval) Spec 2 (p. eval)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>1,000</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>20</cell><cell>40</cell><cell>60</cell><cell>80</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">Benchmarks</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="4">Figure 17. Cumulative running time of MORPHEUS</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">Impact of deduction. As Figure</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>PLDI'17, June 18-23, 2017, Barcelona, Spain c 2017 ACM. 978-1-4503-4988-8/17/06...$15.00 http://dx.doi.org/10.1145/3062341.3062351</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>We view constants as a special case of first-order functions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>The actual specifications used in our implementation are slightly more involved. In Section 9, we compare the performance of MORPHEUS using two different specifications.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>In principle, the number of rows may be unchanged if the predicate does not match any row. However, we need not consider this case since there is a simpler program without filter that satisfies the example.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>Recall that the DEDUCE procedure will also be used during sketch completion. While H can never be a complete program when called from line 8</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>type(T) = {l1 : τ1, ..., ln: τn} c = [li | i ∈ Ci] for Ci ∈ P([1, n]) Γ ⊢ c ∈ Ω(cols, T) (Cols) c ∈ T, type(c) = τ τ ∈ {num, string} Γ ⊢ c ∈ Ω(τ, T) (Const) Γ ⊢ x : τ Γ ⊢ x ∈ Ω(τ, T) (Var) Γ ⊢ t1 ∈ Ω(τ1, T) Γ ⊢ t2 ∈ Ω(τ2, T) Γ ⊢ (t1, t2) ∈ Ω(τ1 × τ2, T) (Tuple) (f, τ ′ → τ, φ) ∈ Λv Γ ⊢ t ∈ Ω(τ ′ , T) Γ ⊢ f (t) ∈ Ω(τ, T)(App)</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://stackoverflow.com/questions/30399516/complex-data-reshaping-in-r" />
		<title level="m">Motivating Example 1</title>
		<imprint>
			<date type="published" when="2017-03-27">27-Mar-2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://stackoverflow.com/questions/33207263/finding-proportions-in-flights-dataset-in-r" />
		<title level="m">Motivating Example 2</title>
		<imprint>
			<date type="published" when="2017-03-27">27-Mar-2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://stackoverflow.com/questions/32875699/how-to-combine-two-data-frames-in-r-see-details" />
		<title level="m">Motivating Example 3</title>
		<imprint>
			<date type="published" when="2017-03-27">27-Mar-2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName><surname>Morpheus</surname></persName>
		</author>
		<ptr target="https://utopia-group.github.io/morpheus/" />
		<imprint>
			<date type="published" when="2017-03-27">27-Mar-2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Recursive Program Synthesis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Kincaid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Computer Aided Verification</title>
		<meeting>International Conference on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="934" to="950" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">FlashRelate: extracting relational data from semi-structured spreadsheets using examples</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Barowy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Zorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="218" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Exploratory data mining and data cleaning</title>
		<author>
			<persName><forename type="first">T</forename><surname>Dasu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>John Wiley &amp; Sons</publisher>
			<biblScope unit="volume">479</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Z3: An efficient SMT solver</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Tools and Algorithms for Construction and Analysis of Systems</title>
		<meeting>Tools and Algorithms for Construction and Analysis of Systems</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Component-Based Synthesis for Complex APIs</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symposium on Principles of Programming Languages</title>
		<meeting>Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Synthesizing data structure transformations from input-output examples</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Feser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="229" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exampledirected synthesis: a type-theoretic interpretation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Frankle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Osera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symposium on Principles of Programming Languages</title>
		<meeting>Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="802" to="815" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Automating string processing in spreadsheets using input-output examples</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symposium on Principles of Programming Languages</title>
		<meeting>Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="317" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automating string processing in spreadsheets using input-output examples</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="317" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Synthesis of loop-free programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Proactive Wrangling: Mixed-initiative End-user Programming of Data Transformation Scripts</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kandel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symposium on User Interface Software and Technology</title>
		<meeting>Symposium on User Interface Software and Technology</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Complete completion using types and weights</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gvero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuncak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kuraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Piskac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Spreadsheet table transformations from examples</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">R</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="317" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Oracle-guided component-based program synthesis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Software Engineering</title>
		<meeting>International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Context-sensitive domainindependent algorithm composition and selection</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Eigenmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Wrangler: Interactive visual specification of data transformation scripts</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kandel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Paepcke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Human Factors in Computing Systems</title>
		<meeting>International Conference on Human Factors in Computing Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="3363" to="3372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A combined analytical and search-based approach for the inductive synthesis of functional programs</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kitzelmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Künstliche Intelligenz</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="182" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">FlashExtract: a framework for data extraction by examples</title>
		<author>
			<persName><forename type="first">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="542" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Jungloid mining: helping to navigate the API jungle</title>
		<author>
			<persName><forename type="first">D</forename><surname>Mandelin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kimelman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="48" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Type-and-example-directed program synthesis</title>
		<author>
			<persName><forename type="first">P.-M</forename><surname>Osera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="619" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Testdriven synthesis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Perelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Provost</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page">43</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Program synthesis from polymorphic refinement types</title>
		<author>
			<persName><forename type="first">N</forename><surname>Polikarpova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kuraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="522" to="538" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">FlashMeta: A framework for inductive program synthesis</title>
		<author>
			<persName><forename type="first">O</forename><surname>Polozov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>International Conference on Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="107" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Code completion with statistical language models</title>
		<author>
			<persName><forename type="first">V</forename><surname>Raychev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="419" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Liquid types</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Rondon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kawaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="159" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Mapreduce program synthesis</title>
		<author>
			<persName><forename type="first">C</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Albarghouthi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="326" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Programming by sketching for bit-streaming programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Rabbah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ebcioglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="281" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Combinatorial sketching for finite programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Saraswat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="404" to="415" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Sketching stencils</title>
		<author>
			<persName><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Saraswat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">SRILM -an extensible language modeling toolkit</title>
		<author>
			<persName><forename type="first">A</forename><surname>Stolcke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Spoken Language Processing</title>
		<meeting>International Conference on Spoken Language essing</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="901" to="904" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Refinement types for typescript</title>
		<author>
			<persName><forename type="first">P</forename><surname>Vekris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Cosman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="310" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Synthesizing transformations on hierarchically structured data</title>
		<author>
			<persName><forename type="first">N</forename><surname>Yaghmazadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Klinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conference on Programming Language Design and Implementation</title>
		<meeting>Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="508" to="521" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Automatically synthesizing sql queries from input-output examples</title>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Automated Software Engineering</title>
		<meeting>International Conference on Automated Software Engineering</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="224" to="234" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
