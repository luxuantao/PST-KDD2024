<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sub-linear Zero-Knowledge Argument for Correctness of a Shuffle</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jens</forename><surname>Groth</surname></persName>
							<email>j.groth@ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
							<email>yuvali@cs.technion.ac.il</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Technion</orgName>
								<orgName type="institution" key="instit2">University of California Los Angeles</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Sub-linear Zero-Knowledge Argument for Correctness of a Shuffle</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">943B1103A72D5A503711B799C7AE02B1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Shuffle</term>
					<term>zero-knowledge argument</term>
					<term>sub-linear communication</term>
					<term>homomorphic encryption</term>
					<term>mix-net</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A shuffle of a set of ciphertexts is a new set of ciphertexts with the same plaintexts in permuted order. Shuffles of homomorphic encryptions are a key component in mix-nets, which in turn are used in protocols for anonymization and voting. Since the plaintexts are encrypted it is not directly verifiable whether a shuffle is correct, and it is often necessary to prove the correctness of a shuffle using a zero-knowledge proof or argument.</p><p>In previous zero-knowledge shuffle arguments from the literature the communication complexity grows linearly with the number of ciphertexts in the shuffle. We suggest the first practical shuffle argument with sub-linear communication complexity. Our result stems from combining previous work on shuffle arguments with ideas taken from probabilistically checkable proofs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A shuffle of ciphertexts e 1 , . . . , e N is a new set of ciphertexts E 1 , . . . , E N with the same plaintexts in permuted order. Shuffles are used in many protocols for anonymous communication and voting. It is usually important to verify the correctness of the shuffle. Take for instance a voting protocol where the ciphertexts are encrypted votes; it is important to avoid that some of the ciphertexts in the shuffle are substituted with encryptions of other votes. There has therefore been much research on designing zero-knowledge arguments 1 for the correctness of a shuffle <ref type="bibr" target="#b38">[37,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b18">17,</ref><ref type="bibr" target="#b31">30,</ref><ref type="bibr" target="#b32">31,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b17">16,</ref><ref type="bibr" target="#b34">33,</ref><ref type="bibr" target="#b35">34,</ref><ref type="bibr" target="#b33">32,</ref><ref type="bibr" target="#b16">15,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b39">38]</ref>.</p><p>When designing shuffle arguments, efficiency is a major concern. It is realistic to have elections with millions of encrypted votes, in which case the statement to be proven is very large. In this paper, our main goal is to get a practical shuffle argument with low communication complexity. A theoretical solution to this problem would be to use Kilian's communication-efficient zero-knowledge argument <ref type="bibr" target="#b27">[26]</ref> (see also <ref type="bibr">Micali [29]</ref>). This method, however, requires a reduction to Circuit Satisfiability, a subsequent application of the PCP-theorem <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b13">12]</ref>, and using a collision-free hash-function to build a hash-tree that includes the entire PCP. Even with the best PCP constructions known to date (cf. <ref type="bibr" target="#b7">[7]</ref>), such an approach would be inefficient in practice. OUR CONTRIBUTION. We present a sublinear-communication 7-move public coin perfect zero-knowledge argument of knowledge for the correctness of a shuffle of ElGamal ciphertexts <ref type="bibr" target="#b14">[13]</ref>. (The protocol is presented in the common random string model, but can also be implemented in the plain model at the cost of a slightly higher constant number of rounds.) All shuffle arguments previously suggested in the literature have communication complexity Ω(N )κ, where N is the number of ciphertexts in the shuffle and κ is a security parameter specifying the finite group over which the scheme works. Our shuffle argument has communication complexity O(m 2 + n)κ for m and n such that N = mn. (The constant in the expression is low as well, see Section 8 for a more precise efficiency analysis.) With m = N 1/3 this would give a size of O(N 2/3 )κ bits, but in practice a smaller choice of m will usually be better for computational reasons. Our shuffle argument moderately increases the prover's computational burden and reduces the amount of communication and the verifier's computational burden in comparison with previous work.</p><p>For practical purposes it will be natural to use the Fiat-Shamir heuristic <ref type="bibr" target="#b15">[14]</ref> (i.e. compute the verifier's public-coin challenges using a cryptographic hash-function) to make our shuffle argument non-interactive. The Fiat-Shamir heuristic justifies reducing the communication and verifier computation at the cost of increased prover computation, since the non-interactive shuffle argument needs to be computed only once by the prover but may be distributed to and checked by many verifiers. Letting the prover do some extra work in order to reduce the communication and the computational burden of each verifier is therefore a good trade-off in practice. To the best of our knowledge, our protocol is the first practical instance of a sublinear-communication argument for any interesting nontrivial statement.</p><p>We have some further remarks on our result. Our technique also applies to other homomorphic cryptosystems, for instance Paillier encryption <ref type="bibr" target="#b36">[35]</ref>; a more general treatment of a wider class of homomorphic encryptions can be obtained along the lines of <ref type="bibr" target="#b22">[21]</ref>. For simplicity we focus just on ElGamal encryption in this paper. Similarly to previous shuffle arguments from the literature, we will present our protocol as an honest verifier zero-knowledge argument. There are very efficient standard techniques for converting honest verifier zero-knowledge arguments into fully zero-knowledge arguments <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b23">22]</ref>. TECHNIQUES. Our starting point is the honest verifier zero-knowledge shuffle argument by Groth <ref type="bibr" target="#b22">[21]</ref>, which builds on ideas by Neff <ref type="bibr" target="#b31">[30]</ref>. Borrowing some of the ideas underlying the PCP theorem, namely the use of Hadamard codes and batch-verification techniques, we reduce the size of the shuffle argument. We note that unlike Kilian <ref type="bibr" target="#b27">[26]</ref> we do not reduce the shuffle statement to an NP-complete language such as SAT; instead we work directly with the ciphertexts in the shuffle statement. Moreover, while we use ideas behind the PCP theorem we do not make use of a full-blown PCP.</p><p>In particular, our argument avoids any use of linearity testing, low-degree testing, or other forms of code proximity testing that appear in all known PCPs. RELATED WORK. Our work was inspired by the recent work of Ishai, Kushilevitz, and Ostrovsky <ref type="bibr" target="#b26">[25]</ref>, which introduced an approach for constructing sublinearcommunication arguments using exponentially long but succinctly described PCPs. Similarly to <ref type="bibr" target="#b26">[25]</ref> we use short homomorphic commitments as the main cryptographic building block. There are, however, several important differences between our techniques and those from <ref type="bibr" target="#b26">[25]</ref>. In particular, the arguments obtained in <ref type="bibr" target="#b26">[25]</ref> do not address our zero-knowledge requirement (and are only concerned with soundness), they inherently require the verifier to use private coins (which are undesirable in the context of our application), and they employ linearity testing that subsequently requires soundness amplification. Finally, the approach of <ref type="bibr" target="#b26">[25]</ref> is generic and does not account for the special structure of the shuffle problem; this structure is crucial for avoiding an expensive reduction to SAT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Notation</head><p>We let Σ N denote the symmetric group on {1, 2, . . . , N}. Given two functions f, g :</p><formula xml:id="formula_0">N → [0, 1] we write f (κ) ≈ g(κ) when |f (κ) -g(κ)| = O(κ -c</formula><p>) for every constant c. We say that the function f is negligible when f (κ) ≈ 0 and that it is overwhelming when f (κ) ≈ 1.</p><p>Algorithms in our shuffle argument will get a security parameter κ as input, which specifies the size of the group we are working over. Sometimes we for notational simplicity avoid writing this explicitly, assuming κ can be deduced indirectly from other inputs given to the algorithms.</p><p>All our algorithms will be probabilistic polynomial time algorithms. We will assume that they can sample randomness from sets of the type Z q . We note that such randomness can be sampled from a source of uniform random bits in expected polynomial time (in log q). We write A(x; r) = y when A, on input x and randomness r, outputs y. We write y ← A(x) for the process of picking randomness r at random and setting y := A(x; r). We also write y ← S for sampling y uniformly at random from the set S.</p><p>When defining security, we assume that there is an adversary attacking our scheme. This adversary is modeled as a non-uniform polynomial time stateful algorithm. By stateful, we mean that we do not need to give it the same input twice, it remembers from the last invocation what its state was. This makes the notation a little simpler, since we do not need to explicitly write out the transfer of state from one invocation to the next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Group Generation</head><p>We will work over a group G q of a prime order q. This could for instance be a subgroup of Z * p , where p is a prime and gcd(q<ref type="foot" target="#foot_0">2</ref> , p-1) = q; or it could be an elliptic curve group or subgroup. We will assume the discrete logarithm problem is hard in G q . More precisely, let G be a generating algorithm that takes a security parameter κ as input and outputs gk := (q, G q , g), where by G q we denote a computationally efficient representation of the group and g is a random generator for G q . The discrete logarithm assumption says that for any non-uniform polynomial time adversary A:</p><formula xml:id="formula_1">Pr (q, G q , g) ← G(1 κ ); x ← Z q ; h := g x : A(q, G q , g, h) = x ≈ 0.</formula><p>(When the randomness of G is taken from a common random string, the above definition needs to be strengthened so that A is given the randomness used by G.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Generalized Pedersen Commitment</head><p>We will use a variant of the Pedersen commitment scheme <ref type="bibr" target="#b37">[36]</ref> that permits making a commitment to a length-n vector in Z n q rather than a single element of Z q as in Pedersen's original commitment. A crucial feature of this generalization is that the amount of communication it involves does not grow with n. The generalized scheme proceeds as follows. The key generation algorithm K com takes (q, G q , g) as input and outputs a commitment key ck := (g 1 , . . . , g n , h), where g 1 , . . . , g n , h are randomly chosen generators of G q . The message space is M ck := Z n q , the randomizer space is R ck := Z q and the commitment space is C ck := G q . (The parameter n will be given as an additional input to all algorithms; however, we prefer to keep it implicit in the notation.)</p><p>To commit to an n-tuple (m 1 , . . . , m n ) ∈ Z n q we pick randomness r ← Z q and compute the commitment C := h r n i=1 g mi i . The commitment is perfectly hiding since no matter what the messages are, the commitment is uniformly distributed in G q . The commitment is computationally binding under the discrete logarithm assumption; we will skip the simple proof.</p><p>The commitment key ck will be part of the common random string in our shuffle argument. We remark that it can be sampled from a random string. We write C := com ck (m 1 , . . . , m n ; r) for making a commitment to m 1 , . . . , m n using randomness r. The commitment scheme is homomorphic, i.e., for all m 1 , m 1 , . . . , m n , m n , r, r ∈ Z q we have</p><formula xml:id="formula_2">com ck (m 1 ,. . ., m n ; r)• com ck (m 1 ,. . ., m n ; r )= com ck (m 1 +m 1 ,. . ., m m +m n ; r+r ).</formula><p>In some cases we will commit to less than n elements; this can be accomplished quite easily by setting the remaining messages to 0.</p><p>We will always assume that parties check that commitments are valid, meaning they check that C ∈ G q . If G q is a subgroup of Z * p this can be done by checking that C q = 1, however, batch verification techniques can be used to lower this cost when we have multiple commitments to check. 2 If G q is an elliptic curve of order q, then the validity check just consists of checking that C is a point on the curve, which is very inexpensive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">ElGamal Encryption</head><p>ElGamal encryption <ref type="bibr" target="#b14">[13]</ref> in the group G q works as follows. The public key is pk := y = g x with a random secret key sk := x ← Z * q . The message space is M pk := G q , the randomizer space is R pk := Z q and the ciphertext space is C pk := G q × G q . To encrypt a message m ∈ G q using randomness R ∈ Z q we compute the ciphertext</p><formula xml:id="formula_3">E pk (m; R) := (g R , y R m). To decrypt a ciphertext (u, v) we compute m = vu -x .</formula><p>The semantic security of ElGamal encryption is equivalent to the DDH assumption. Semantic security may be needed for the shuffle itself to be secure; however, the security of our shuffle argument will rely on the discrete logarithm assumption only. In particular, our shuffle argument is still sound and zero-knowledge even if the cryptosystem is insecure or the decryption key has been exposed.</p><p>ElGamal encryption is homomorphic with entry-wise multiplication in the ciphertext space. For all (m, R), (m , R ) ∈ M pk × R pk we have</p><formula xml:id="formula_4">E pk (mm ; R + R ) = (g R+R , y R+R mm ) = (g R , y R m) • (g R , y R m ) = E pk (m; R) • E pk (m ; R ).</formula><p>We will always assume that the ciphertexts in the shuffle are valid, i.e., (u, v) ∈ G q × G q . Batch verification techniques can reduce the cost of verifying validity when we have multiple ciphertexts. To further reduce the cost of ciphertext verification, Groth <ref type="bibr" target="#b22">[21]</ref> suggests a variant of ElGamal encryption that makes batch-checking ciphertext validity faster. Our shuffle argument works also for this variant of ElGamal encryption.</p><p>Our shuffle argument works with many types of cryptosystems; the choice of El-Gamal encryption is made mostly for notational convenience. Our technique can be directly applied with any homomorphic cryptosystem that has a message space of order q. We are neither restricted to using the same underlying group (q, G q , g) as the commitment scheme nor restricted to using ElGamal encryption or variants thereof. Using techniques from <ref type="bibr" target="#b22">[21]</ref> it is also possible to generalize the shuffle argument to work for cryptosystems that do not have message spaces of order q. This latter application does require a few changes to the shuffle argument though and does increase the complexity of the shuffle argument, but the resulting protocol still has the same sub-linear asymptotic complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Special Honest Verifier Zero-Knowledge Arguments of Knowledge</head><p>We will assume there is a setup algorithm G that generates some setup information gk. This setup information could for instance be a description of a group that we will be working in. Consider a pair of probabilistic polynomial time interactive algorithms (P, V ) called the prover and the verifier. They may have access to a common random string σ generated by a probabilistic polynomial time key generation algorithm K. We consider a polynomial time decidable ternary relation R. For an element x we call w a witness if (gk, x, w) ∈ R. We define a corresponding group-dependent language L gk consisting of elements x that have a witness w such that (gk, x, w) ∈ R. We write tr ← P (x), V (y) for the public transcript produced by P and V when interacting on inputs x and y together with the randomness used by V . This transcript ends with V either accepting or rejecting. We sometimes shorten the notation by saying P (x), V (y) = b if V ends by accepting, b = 1, or rejecting, b = 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Argument). The triple (K, P, V ) is called an argument for relation R with setup G if for all non-uniform polynomial time interactive adversaries A we have</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Completeness</head><formula xml:id="formula_5">Pr gk ← G(1 κ ); σ ← K(gk); (x, w) ← A(gk, σ) : (gk, x, w) / ∈ R or P (gk, σ, x, w), V (gk, σ, x) = 1 ≈ 1.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computational soundness</head><formula xml:id="formula_6">Pr gk ← G(1 κ ); σ ← K(gk); x ← A(gk, σ) : x / ∈ L gk and A, V (gk, σ, x) = 1 ≈ 0.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Public coin argument</head><p>). An argument (K, P, V ) is public coin if the verifier's messages are chosen uniformly at random independently of the messages sent by the prover and the setup parameters gk, σ.</p><p>We define special honest verifier zero-knowledge (SHVZK) <ref type="bibr" target="#b9">[9]</ref> for a public coin argument as the ability to simulate the transcript for any set of challenges without access to the witness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Perfect special honest verifier zero-knowledge).</head><p>The public coin argument (K, P, V ) is called a special honest verifier zero-knowledge argument for R with setup G if there exists a probabilistic polynomial time simulator S such that for all non-uniform polynomial time adversaries A we have</p><formula xml:id="formula_7">Pr gk ← G(1 κ ); σ ← K(gk); (x, w, ρ) ← A(gk, σ); tr ← P (gk, σ, x, w), V (gk, σ, x; ρ) : (gk, x, w) ∈ R and A(tr) = 1 = Pr gk ← G(1 κ ); σ ← K(gk); (x, w, ρ) ← A(gk, σ); tr ← S(gk, σ, x, ρ) : (gk, x, w) ∈ R and A(tr) = 1 .</formula><p>We remark that there are efficient techniques to convert SHVZK arguments into zeroknowledge arguments for arbitrary verifiers in the common random string model <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b23">22]</ref>. In this paper, we will therefore for simplicity focus just on the special honest verifier zero-knowledge case. WITNESS-EXTENDED EMULATION. We shall define an argument of knowledge<ref type="foot" target="#foot_1">3</ref> through witness-extended emulation, the name taken from Lindell <ref type="bibr" target="#b29">[28]</ref>. Whereas Lindell's definition pertains to proofs of knowledge in the plain model, we will adapt his definition to the setting of public coin arguments in the common random string model. Informally, our definition says: given an adversary that produces an acceptable argument with probability , there exists an emulator that produces a similar argument with probability , but at the same time provides a witness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Witness-extended emulation).</head><p>We say the public coin argument (K, P, V ) has witness-extended emulation if for all deterministic polynomial time P * there exists an expected polynomial time emulator E such that for all non-uniform polynomial time adversaries A we have</p><formula xml:id="formula_8">Pr gk ← G(1 κ ); σ ← K(gk); (x, s) ← A(gk, σ); tr ← P * (gk, σ, x, s), V (gk, σ, x) : A(tr) = 1 ≈ Pr gk ← G(1 κ ); σ ← K(gk); (x, s) ← A(gk, σ);</formula><p>(tr, w) ← E P * (gk,σ,x,s),V (gk,σ,x) (gk, σ, x) :</p><formula xml:id="formula_9">A(tr) = 1 and if tr is accepting then (gk, x, w) ∈ R ,</formula><p>where E has access to a transcript oracle P * (gk, σ, x, s), V (gk, σ, x) that can be rewound to a particular round and run again with the verifier using fresh randomness.</p><p>We think of s as being the state of P * , including the randomness. Then we have an argument of knowledge in the sense that the emulator can extract a witness whenever P * is able to make a convincing argument. This shows that the definition implies soundness. We remark that the verifier's randomness is part of the transcript and the prover is deterministic. So combining the emulated transcript with gk, σ, x, s gives us the view of both the prover and the verifier and at the same time gives us the witness. Damgård and Fujisaki <ref type="bibr" target="#b11">[11]</ref> have suggested an alternative definition of an argument of knowledge in the presence of a common random string. Witness-extended emulation as defined above implies knowledge soundness as defined by them <ref type="bibr" target="#b23">[22]</ref>. THE FIAT-SHAMIR HEURISTIC. The Fiat-Shamir heuristic <ref type="bibr" target="#b15">[14]</ref> can be used to make public coin SHVZK arguments non-interactive. In the Fiat-Shamir heuristic the verifier's challenges are computed by applying a cryptographic hash-function to the transcript of the protocol. Security can be formally argued in the random oracle model <ref type="bibr" target="#b6">[6]</ref>, in which the hash-function is modeled as a completely random function that returns a random string on each input it has not been queried before. While the Fiat-Shamir heuristic is not sound in general <ref type="bibr" target="#b20">[19]</ref>, it is still commonly believed to be a safe practice when applied to "natural" protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Problem Specification and Setup</head><p>We will construct a 7-move public coin perfect SHVZK argument for the relation R = (gk = (q, G q , g), (pk = y, e 1 , . . . , e N , E 1 , . . . , E N ), (π, R 1 , . . . , R N ))</p><formula xml:id="formula_10">y ∈ G q ∧ π ∈ Σ N ∧ R 1 , . . . , R N ∈ R pk ∧ ∀i : E i = e π -1 (i) E pk (1; R i ) .</formula><p>In our SHVZK argument, the common random string σ will be generated as a public key (g 1 , . . . , g n , h) for the n-element Pedersen commitment scheme described in Section 2.3. Depending on the applications, there are many possible choices for who generates the commitment key and how this generation is done. For use in a mix-net, we could for instance imagine that there is a setup phase, where the mix-servers run a multi-party computation protocol to generate the setup and the commitment key. Another option is to let the verifier generate the common random string, since it is easy to verify whether a commitment key is valid or not. This option yields an 8-move (honestverifier zero-knowledge) argument in the plain model. <ref type="foot" target="#foot_2">4</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Polynomial Identity Testing</head><p>For completeness we state a variation of the well-known Schwartz-Zippel lemma that we use several times in the paper.</p><p>Lemma 1 (Schwartz-Zippel). Let p be a non-zero multivariate polynomial of degree d over Z q , then the probability of p(x 1 , . . . , x ν ) = 0 for randomly chosen x 1 , . . . , x ν ← Z q is at most d/q.</p><p>The Schwartz-Zippel lemma is frequently used in polynomial identity testing. Given two multi-variate polynomials p 1 and p 2 we can test whether p 1 (x 1 , . . . , x ν )p 2 (x 1 , . . . , x ν ) = 0 for random x 1 , . . . , x ν ← Z q . If the two polynomials are identical this will always be true, whereas if the two polynomials are different then there is only probability max(d 1 , d 2 )/q for the equality to hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Product of Committed Elements</head><p>Consider a sequence of commitments A 1 , . . . , A m and a value a ∈ Z q . We will give an SHVZK argument of knowledge of {a ij } m,n i=1,j=1 and {r i } m i=1 such that a ij mod q.</p><formula xml:id="formula_11">A 1 = com ck (</formula><p>The argument is of sub-linear size; the prover will send m 2 commitments and 2n elements from Z q , where N = mn is the total number of committed elements a ij . For m = N 1/3 this gives a size of O(N 2/3 )κ bits. The argument is quite complex so let us first describe some of the ideas that go into it. In our argument, the prover will prove knowledge of the contents of the commitments.</p><p>For the sake of simplicity we will first describe the argument assuming the prover knows the contents of the commitments and by the computational binding property of the commitment scheme is bound to these values. We will also for the sake of simplicity just focus on soundness and later when giving the full protocol add extra parts that will give us honest verifier zero-knowledge and witness-extended emulation. (Note that even completeness and soundness alone are nontrivial to achieve when considering sublinear communication arguments.)</p><p>Consider first commitments A 1 , . . . , A m as described above. The verifier will pick a random challenge s 1 , . . . , s m . By the homomorphic property</p><formula xml:id="formula_12">m i=1 A si i = com ck ( m i=1 s i a i1 , . . . , m i=1 s i a in ; m i=1 s i r i ).</formula><p>In our argument the prover will open this commitment multi-exponentiation as</p><formula xml:id="formula_13">f 1 := m i=1 s i a i1 , . . . , f n := m i=1 s i a in , z := m i=1 s i r i .</formula><p>Consider now the case where we have three sets of commitments</p><formula xml:id="formula_14">{A i } m i=1 , {B } m =1 , {C i } m,m i=1, =1</formula><p>containing respectively m × n matrices A, B and m 2 × n matrix C. The verifier will choose random challenges s 1 , . . . , s m , t 1 , . . . , t m ← Z q . The prover can open the commitment products</p><formula xml:id="formula_15">m i=1 A si i , m =1 B t , m i=1 m =1 C sit i</formula><p>as described above. This gives us for each of the n columns</p><formula xml:id="formula_16">f j := m i=1 s i a ij , F j := m =1 t b j , φ j := m i=1 m =1 s i t c i j .</formula><p>In our proofs the verifier will check for each column that φ j = f j F j . These checks can be seen as quadratic equations in variables s 1 , . . . , s m , t 1 , . . . , t m of the form</p><formula xml:id="formula_17">( m i=1 s i a ij )( m =1 t b j ) = m i=1 m =1 s i t c i j .</formula><p>If c i j = a ij b j for all i, , j the check will always pass, whereas if this is not the case, then by the Schwartz-Zippel lemma there is overwhelming probability over the choice of s 1 , . . . , s m , t 1 , . . . , t m that the check will fail. (This type of checking is also used in the Hadamard-based PCP of Arora et al. <ref type="bibr" target="#b3">[3]</ref>.) We therefore have an argument for C ii being a commitment to {a ij b ij } n j=1 . The commitments C i for i = are just fillers that make the argument work, we will not need them for anything else. In the argument we only reveal O(n) elements in Z q to simultaneously prove N = mn equalities c iij = a ij b ij ; this is what will give us sub-linear communication complexity.</p><p>Let us now explain how we choose the matrix B. We have now described B extended with a 0th column vector. Write B for the matrix with the 0th column and the first n -1 columns of B. We will apply the A, B, C matrix argument we described before to the matrices A, B, C, where we use commitments</p><formula xml:id="formula_18">C ii := B i . This argument demonstrates for each 1 ≤ j ≤ n that b ij = a ij b i,j-1 .</formula><p>Putting everything together we now have:</p><formula xml:id="formula_19">b 10 = 1, b ij = a ij b i,j-1 , b i0 = b i-1,n and b mn = a, which is sufficient to conclude that a = m i=1 n j=1 a ij .</formula><p>We will now describe the full protocol. The most significant change from the description given above is that we now add also elements a 0j , b 0j that are chosen at random to the matrices. The role of these elements is to give honest verifier zero-knowledge. The prover reveals elements of the form f j := a 0j + </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial message</head><p>a 01 , . . . , a 0n ← Z q ; r 0 ← R ck ; A 0 := com ck (a 01 , a 02 , . . . , a 0n ; r 0 ) </p><formula xml:id="formula_20">For 1 ≤ I ≤ m, 1 ≤ J ≤ n : b IJ := I-1 i=1 n j=1 a ij • J j=1 a Ij b 01 , . . . , b 0n ← Z q ; r b0 , r b1 . . . , r bm ← R ck</formula><formula xml:id="formula_21">; r m ) b 00 ← Z q ; r 0 ← R ck ; B 0 := com ck (b 00 ; r 0 ) r ← R ck ; B := com ck (b 0n ; r) For 0 ≤ i, ≤ m : r i ← R ck and for 1 ≤ i ≤ m : r ii := r bi .</formula><p>For 0 ≤ i, ≤ m :</p><formula xml:id="formula_22">C i := com ck (a i1 b 0 , . . . , a in b ,n-1 ; r i ) Since b ij = a ij b i,j-1 and r ii = r bi we have for 1 ≤ i ≤ m that C ii = B i . Send (A 0 , B 0 , B 0 , B 2 , . . . , B m , B, C 00 , . . . , C mm ) to the verifier Challenge: s 1 , . . . , s m , t 1 , . . . , t m ← Z q Answer For 1 ≤ j ≤ n : f j := a 0j + m i=1 s i a ij ; F j := b 0j + m =1 t b j ; F 0 := b 00 + m =1 t b 0 z := r 0 + m i=1 s i r i ; z b := r b0 + m =1 t r b ; z := r 0 + m =2 t r ; ẑ := r + m =2 t -1 r z ab := r 00 + m i=1 s i r i0 + m =1 t r 0 + m i=1 m =1 s i t r i Send (f 1 , . . . , f n , F 0 , . . . , F n , z, z b , z , ẑ, z ab ) to the verifier Verification Check A 0 m i=1 A si i = com ck (f 1 , . . . , f n ; z) For 1 ≤ ≤ m set B := c . Check B 0 m =1 B t = com ck (F 1 , . . . , F n ; z b ) Set B 1 := com ck (1; 0). Check B 0 m =1 (B ) t = com ck (F 0 ; z ). Check B m =2 (B ) t -1 = com ck (F n -t m a; ẑ) Check C 00 • m i=1 C si i0 • m =1 C t 0 • m i=1 m =1 C sit i = com ck (f 1 F 0 , . . . , f n F n-1 ; z ab )</formula><p>Theorem 1. The protocol described above is a 3-move public-coin perfect SHVZK argument of knowledge of a ij and r i such that a = m i=1 n j=1 a ij and for all i we have</p><formula xml:id="formula_23">A i = com ck (a i1 , . . . , a in ; r i ).</formula><p>The proof can be found in the full paper <ref type="bibr" target="#b24">[23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Committed Permutation of Known Elements</head><p>Consider a vector of commitments B 1 , . . . , B m and a set of values {a ij } m,n i=1,j=1 . In this section we will give an argument of knowledge of π ∈ Σ N and {r i } m i=1 such that:</p><formula xml:id="formula_24">B 1 = com ck (a π -1 (11) , a π -1 (12) , . . . , a π -1 (1n) ; r 1 ) . . . B m = com ck (a π -1 (m1) , a π -1 (m2) , . . . , a π -1 (mn) ; r m ) (Here we identify [N ] with [m] × [n].)</formula><p>Our argument uses Neff's idea <ref type="bibr" target="#b31">[30]</ref>, which is to let the verifier pick a value x at random and let the prover argue that the committed values b ij satisfy</p><formula xml:id="formula_25">m i=1 n j=1 (x - b ij ) = m i=1 n j=1 (x -a ij ).</formula><p>If the committed b ij are a permutation of a ij this equation holds, since polynomials are invariant under permutation of their roots. On the other hand, if b ij are not a permutation of a ij , then by the Schwartz-Zippel lemma there is negligible chance over the choice of x for the equality to hold.</p><formula xml:id="formula_26">Initial challenge: x ← Z q Answer: Define B 1 := com ck (x, . . . , x; 0)B -1 1 , . . . , B m := com ck (x, . . . , x; 0)B -1 m and a := m i=1 n j=1 (x -a ij )</formula><p>. Make a 3-move argument of knowledge of openings of B 1 , . . . , B m such that the product of all the entries is a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. The protocol is a 4-move public coin perfect SHVZK argument of knowledge of a</head><formula xml:id="formula_27">ij , r i , π such that B i := com ck (a π -1 (i1) , . . . , a π -1 (in) ; r i ).</formula><p>We refer to the full paper <ref type="bibr" target="#b24">[23]</ref> for a proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Multi-exponentiation to Committed Exponents</head><p>Consider a set of commitments A 1 , . . . , A m , a matrix of ciphertexts E 11 , . . . , E mn and a ciphertext E. In this section we will give an argument of knowledge of {a ij } m,n i=1,j=1 , {r i } m i=1 and R such that:</p><p>A 1 = com ck (a 11 , a 12 , . . . , a 1n ; r 1 ) . . .</p><formula xml:id="formula_28">A m = com ck (a m1 , a m2 , . . . , a mn ; r m ) and E = E pk (1; R) m i=1 n j=1 E aij ij .</formula><p>argument will contain m 2 commitments, m 2 ciphertexts and n elements in Z q , where N = mn. Choosing m = N 1/3 gives a communication complexity of O(N 2/3 )κ bits.</p><p>When describing the idea, let us first just consider how to get soundness and ignore the issue of zero-knowledge for a moment. In the argument, the prover will prove knowledge of the committed exponents, so let us from now on assume the committed values are well-defined. The prover can compute m 2 ciphertexts</p><formula xml:id="formula_29">D i = n j=1 E aij j .</formula><p>We have</p><formula xml:id="formula_30">E = E pk (1; R) m i=1 D ii = E pk (1; R) m i=1 n j=1 E aij ij .</formula><p>Ignoring R that can be dealt with using standard zero-knowledge techniques all that remains is for the verifier to be convinced D i have been correctly computed. For this purpose the verifier will select challenges t 1 , . . . , t m ← Z q at random. The prover will open</p><formula xml:id="formula_31">m i=1 A ti i to the values f 1 := m i=1 t i a i1 , . . . , f n := m i=1 t i a in . The verifier now checks for each 1 ≤ ≤ m that n j=1 E fj j = m i=1 D ti i . Writing this out we have m i=1 ( n j=1 E aij j ) ti = m i=1 D ti i .</formula><p>Since t i are chosen at random, there is overwhelming probability for one of these checks to fail unless for all i, we have</p><formula xml:id="formula_32">D i = n j=1 E aij j .</formula><p>In the argument, we wish to have honest verifier zero-knowledge. We will therefore multiply the D i ciphertexts with random encryptions to avoid leaking information about the exponents. This, however, makes it possible to encrypt anything in D i , so to avoid cheating we commit to the plaintexts of those random encryptions and use the commitments to prove that they all cancel out against each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial message</head><p>a 01 , . . . , a 0n ← Z q ; r 0 ← R ck ; A 0 = com ck (a 01 , a 02 , . . . , a 0n ; r 0 ) b 01 , . . . , b mm ← Z q ; r 01 , . . . , r mm ← R ck ; b mm := - </p><formula xml:id="formula_33">C m1 := com ck (b m1 ; r m1 ) . . . C mm := com ck (b mm ; r mm ) R 01 , . . . , R mm ← R pk ; R mm := R -m-1 i=1 R ii D 01 := E pk (g b01 ; R 01 ) n j=1 E a0j 1j • • • D 0m := E pk (g b0m ; R 0m ) n j=1 E a0j mj . . . . . . D m1 := E pk (g bm1 ; R m1 ) n j=1 E amj 1j • • • D mm := E pk (g bmm ; R mm ) n j=1 E amj mj</formula><p>Send (A 0 , C 01 , . . . , C mm , D 01 , . . . , D mm ) to the verifier Challenge: t 1 , . . . , t m ← Z q Answer For 1 ≤ j ≤ n : We refer to the full paper <ref type="bibr" target="#b24">[23]</ref> for the proof.</p><formula xml:id="formula_34">f j := a 0j + m i=1 t i a ij ; z := r 0 + m i=1 t i r i For 1 ≤ ≤ m : F := b 0 + m i=1 t i b i ; z := r 0 + m i=1 t i r i ; Z := R 0 + m i=1 t i R i Send (f 1 , . . . , f n , F 1 , . . . , F m , z, z 1 , . . . , z m , Z 1 , . . . , Z m ) to the verifier Verification Check A 0 m i=1 A ti i = com ck (f 1 , . . . , f n ; z) For 1 ≤ ≤ m check C 0 m i=1 C ti i = com ck (F ; z ) and E pk (g F ; Z ) n j=1 E fj j = D 0 m i=1 D ti i Check m i=1 C ii = com ck (0; 0) Check E = m i=1 D ii</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Shuffle Argument</head><p>Given ciphertexts {e ij } m,n i=1,j=1 and {E ij } m,n i=1,j=1 we will give an argument of knowledge of π ∈ Σ N and {R ij } m,n i=1,j=1 such that for all i, j we have</p><formula xml:id="formula_35">E ij = e π -1 (ij) E pk (1; R ij ).</formula><p>The most expensive components of the argument will be a product of committed elements argument and a multi-exponentiation to committed elements argument described in the previous sections. The total size of the argument is therefore O(m 2 + n)κ bits, where N = mn. With m = N 1/3 this gives an argument of size O(N 2/3 )κ bits.</p><p>The argument proceeds in seven steps. First the prover commits to the permutation π, by making a commitment to 1, . . . , N in permuted order. Then the verifier picks challenges s 1 , . . . , s m , t 1 , . . . , t n at random. The prover commits to the challenges s i t j in permuted order. The prover now proves that she has committed to s i t j permuted in the same order as the permutation committed to in the initial commitment. The point of the argument is that since the permutation is committed before seeing the challenges, the prover has no choice in creating the commitment, the random challenges have already been assigned unique slots in the commitment. . With the permutation fixed before the challenges are chosen at random there is overwhelming probability that the argument fails unless for all i, j we have M ij = m π -1 (ij) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial message:</head><p>The prover sets a π(ij) := m(i -1) + j. The prover picks r a1 , . . . , r am ← R ck and sets  </p><formula xml:id="formula_36">A 1 := com ck (</formula><formula xml:id="formula_37">R ij ∈ R pk so E ij = e π -1 (ij) E pk (1; R ij ).</formula><p>We refer to the full paper <ref type="bibr" target="#b24">[23]</ref> for the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Efficient Verification</head><p>The small size of the argument gives a corresponding low cost of verification. There are, however, 2N ciphertexts that we must exponentiate in the verification. In this section we show that the verifier computation can be reduced to making multi-exponentiations of the ciphertexts to small exponents. for randomly chosen α j . Since the check is done off-line, the verifier can use small exponents α j , say, 32-bit exponents. This trick reduces the amount of verifier computation that is needed for computing</p><formula xml:id="formula_38">m i=1 n i=1 e sitj ij</formula><p>to one m-exponentiation to exponents from Z q and m + 1 n-exponentiations to small exponents.</p><p>When m is small, this strategy may actually end up increasing the communication complexity of the shuffle. However, the exact same method can be employed when we let the verifier compute the t j -values as products the n products of ψ 1 , . . . , ψ n1 and τ 1 , . . . , τ n2 where n = n 1 n 2 . If we choose n 2 = √ N for instance, we get that the prover only sends √ N ciphertexts to the verifier. The verifier then makes √ N -multiexponentiations to small exponents α 1 , . . . , α √ N .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Randomized Verification</head><p>In the argument for multi-exponentiation to committed exponents, the verifier must check m equalities of the form E pk (g F ; Z ) This way, we make n m-multi-exponentiations to small exponents α and one n-multiexponentiation to larger exponents f j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Comparison</head><p>Let us compare our shuffle argument with the most efficient arguments for correctness of a shuffle of ElGamal ciphertexts in the literature. Furukawa and Sako <ref type="bibr" target="#b18">[17]</ref> suggested an efficient argument for correctness of a shuffle based on committing to a permutation matrix. This scheme was further refined by Furukawa <ref type="bibr" target="#b16">[15]</ref>. We will use Groth and Lu's <ref type="bibr" target="#b25">[24]</ref> estimates for the complexity of Furukawa's scheme. Neff <ref type="bibr" target="#b31">[30,</ref><ref type="bibr" target="#b32">31]</ref> gave an efficient interactive proof for correctness of a shuffle. Building on those ideas Groth <ref type="bibr" target="#b22">[21]</ref> suggested a perfect SHVZK argument for correctness of a shuffle. Our shuffle argument builds on Neff's and Groth's schemes. We will compare the schemes using an elliptic curve of prime order q. We use |q| = 256 so SHA256 can be used to choose the public coin challenges. We measure the communication complexity in bits and measure the prover and verifier computation in single exponentiations. By this we mean that in all schemes, we count the cost of a multi-exponentiation to n exponents as n single exponentiations. We compare the most efficient shuffle arguments in Table <ref type="table" target="#tab_2">1</ref>. Section 7 offer a couple of speedup techniques. If we employ the randomization techniques from Section 7 then the prover's cost increases by 2N exponentiations, whereas the verifier's complexity reduces to 4N small exponentiations and m 2 + 3n exponentiations to full size exponents from Z q . For all schemes it holds that multi-exponentiation techniques can reduce their cost, see e.g. Lim <ref type="bibr" target="#b28">[27]</ref>. We refer to the full paper of Groth <ref type="bibr" target="#b22">[21]</ref> for a discussion of randomization techniques and other tricks that can be used to reduce the computational complexity of all the shuffle arguments. An additional improvement of our scheme is to let the prover assist the verifier in computing the multi-exponentiation  <ref type="table" target="#tab_3">2</ref> has back-of-the-envelope estimates when we compare an optimized version of our scheme to that of Groth <ref type="bibr" target="#b22">[21]</ref>. We assume that we are shuffling N = 100, 000 ElGamal ciphertexts with parameters m = 10, n = 10, 000 so N = mn. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>For 1 ≤</head><label>1</label><figDesc>I ≤ m, 1 ≤ J ≤ n we set b IJ := I-1 i=1 n j=1 a ij • J j=1 a Ij . This means that B is a matrix chosen such that b ij is the previous element in the matrix B multiplied with a ij . In particular, we have b mn = m i=1 n j=1 a ij = a. In addition, we will have an extra column with b 10 := 1 and for 1 &lt; i ≤ m : b i0 := b i-1,n . In other words, the 0th column vector is the nth column vector of B shifted one step down. The prover will make a separate set of m commitments B 1 , . . . , B m to this column. Choosing B 1 := com ck (1; 0) it is straightforward to verify that b 10 = 1. To show that the rest of the 0th column is correctly constructed the prover will open m-1 =2 (B ) t -1 to the message F n -t m a. The linear equations give us m-1 =2 t -1 b 0 + t m a = m =1 t b n , which by the Schwartz-Zippel lemma has negligible probability of being true unless b mn = a and b +1,0 = b n for 1 ≤ &lt; m.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>m i=1 s i a ij and F j := b 0j + m =1 t b j , which reveal nothing about m i=1 s i a ij and m =1 t b j when a 0j and b 0j are random.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>B 0 :</head><label>0</label><figDesc>= com ck (b 01 , b 02 , , . . . , b 0n ; r b0 ) B 1 := com ck (b 11 , b 12 , . . . , b 1n ; r b1 ) . . . B m := com ck (b m1 , b m2 , . . . , b mn ; r bm ) Define b 10 := 1, b 20 := b 1n , . . . , b m0 := b m-1,n r 2 , . . . , r m ← R ck ; B 2 := com ck (b 20 ; r 2 ), . . . , B m := com ck (b m0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>m- 1 i=1</head><label>1</label><figDesc>b ii ; r mm := -m-1 i=1 r ii C 01 := com ck (b 01 ; r 01 ) . . . C 0m := com ck (b 0m ; r 0m ) . . . . . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 3 .</head><label>3</label><figDesc>The protocol above is a 3-move public coin perfect SHVZK argument of knowledge of a 11 , . . . , a mn , r 1 , . . . , r m , R so E = E pk (1; R) A i = com ck (a i1 , . . . , a in ; r i ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>The other part of the argument is to use the committed exponentiation technique to show that ) for some known R. If we look at the plaintext, this implies</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>BTheorem 4 .</head><label>4</label><figDesc>m := com ck (b m1 , b m2 , . . . , b mn ; r bm ) Second challenge: λ ← Z q Answer: Make a 4-move argument of knowledge of π ∈ Σ N and openings of A λ 1 B 1 , . . . , A λ m B m so they contain a permutation of the N values λ(m(i -1) + j) + s i t j . Observe, the first move of this argument can be made in parallel with the second challenge so we only use three additional moves. Make a 3-move argument of knowledge of b ij , r bi , R so B 1 = com ck (b 11 , b 12 , . . . , b 1n ; r b1 ) . . . B m = com ck (b m1 , b m2 , . . . , b mn ; r bm ) The protocol is a 7-move public coin perfect SHVZK argument of knowledge of π ∈ Σ and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>7. 1</head><label>1</label><figDesc>Prover-Assisted Multi-exponentiationIn our shuffle argument, the verifier has to computeThe prover can assist this computation by computing D 1 , . . . , D n as D j := m i=1 e si ij . The verifier can then compute What remains is for the verifier to check that the ciphertexts are correct, which can be done by verifying</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>This can be done off-line in a randomized way by picking α 1 , . . . , α m at random and testing whether</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>a 11 , a 12 , . . . , a 1n ; r a1 ) . . . A m := com ck (a m1 , a m2 , . . . , a mn ; r am ) First challenge: s 1 , . . . , s m , t 1 , . . . , t n ← Z</figDesc><table /><note><p><p><p>q First answer: We define b π(ij) := s i t j . The prover picks r b1 , . . . , r bn ← R ck and sets</p>B 1 := com ck (b 11 , b 12 , . . . , b 1n ; r b1 )</p>. . .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Comparison of shuffle arguments for N = mn ElGamal ciphertexts</figDesc><table><row><cell>Elliptic curve</cell><cell cols="4">Furukawa-Sako Groth Furukawa proposed</cell></row><row><cell>Group order: |q| = 256</cell><cell>[17]</cell><cell>[21]</cell><cell>[15,24]</cell><cell></cell></row><row><cell>Prover (single expo.)</cell><cell>8N</cell><cell>6N</cell><cell>7N</cell><cell>3mN + 5N</cell></row><row><cell>Verifier (single expo.)</cell><cell>10N</cell><cell>6N</cell><cell>8N</cell><cell>4N + 3n</cell></row><row><cell cols="2">Prover's communication (bits) 1280N</cell><cell cols="2">768N 768N</cell><cell>768m 2 + 768n</cell></row><row><cell>Rounds</cell><cell>3</cell><cell>7</cell><cell>3</cell><cell>7</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>Comparison of shuffle arguments for 100, 000 ElGamal ciphertexts Groth [21] proposed Prover's computation 18 • 10 6 mults (18 sec.) 143 • 10 6 mults (143 sec.) Verifier's computation 14 • 10 6 mults (14 sec.) 5 • 10 6 mults ( 5 sec.) Prover's communication 77 Mbits 8 Mbits</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>See also<ref type="bibr" target="#b22">[21]</ref> for a variant of the Pedersen commitment scheme over Z * p that makes it possible to completely eliminate the cost of verifying validity.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The standard definition of proofs of knowledge by Bellare and Goldreich<ref type="bibr" target="#b5">[5]</ref> does not apply in our setting, since we work in the common random string model and are interested in arguments of knowledge. See Damgård and Fujisaki<ref type="bibr" target="#b11">[11]</ref> for a discussion of this issue.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>We can also get full zero-knowledge in the plain model. The verifier picks the common random string as above and also picks an additional key for a trapdoor commitment scheme. The verifier then makes engages in a zero-knowledge proof of knowledge of the trapdoor. We can now use the standard techniques for converting honest verifier zero-knowledge arguments to full zero-knowledge arguments<ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b23">22]</ref>. By running the two proofs in parallel, the round complexity is only 8. Note, however, that since the verifier must know the secret trapdoor of the additional commitment scheme, the protocol is no longer public coin.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We count the computational cost in the number of multiplications. In parenthesis we are giving timing estimates assuming the use of equipment where a multiplication takes 1µs, which is conservative given today's equipment. We only count the cost of the shuffle argument in Table <ref type="table">2</ref>, not the cost of computing the shuffle or the size of the shuffle (51 Mbits).</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Research done in part while visiting IPAM. Part of work done while at UCLA supported by NSF ITR/Cybertrust grant 0456717. Research done in part while visiting IPAM. Supported by BSF grant 2004361, ISF grant 1310/06, and NSF grants 0205594, 0430254, 0456717, 0627781, 0716835, 0716389. <ref type="bibr" target="#b0">1</ref> By zero-knowledge arguments <ref type="bibr" target="#b8">[8]</ref> we refer to computationally-sound zero-knowledge proofs <ref type="bibr" target="#b21">[20]</ref>.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Universally verifiable mix-net with verification work independent of the number of mix-servers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1998</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Nyberg</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">1403</biblScope>
			<biblScope unit="page" from="437" to="447" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Remarks on mix-network based on permutation networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hoshino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2001</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">1992</biblScope>
			<biblScope unit="page" from="317" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Proof verification and the hardness of approximation problems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="501" to="555" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Probabilistic checking of proofs: A new characterization of NP</title>
		<author>
			<persName><forename type="first">S</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Safra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="70" to="122" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On defining proofs of knowledge</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1992</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Brickell</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">740</biblScope>
			<biblScope unit="page" from="390" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>ACM CCS</publisher>
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Short PCPs verifiable in polylogarithmic time</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Harsha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Computational Complexity</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="120" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Minimum disclosure proofs of knowledge</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brassard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crèpeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="156" to="189" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Proofs of partial knowledge and simplified design of witness hiding protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schoenmakers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1994</title>
		<editor>
			<persName><forename type="first">Y</forename><forename type="middle">G</forename><surname>Desmedt</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">839</biblScope>
			<biblScope unit="page" from="174" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient concurrent zero-knowledge in the auxiliary string model</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2000</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Preneel</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1807</biblScope>
			<biblScope unit="page" from="418" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A statistically-hiding integer commitment scheme based on groups with hidden order</title>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fujisaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2002</title>
		<editor>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2501</biblScope>
			<biblScope unit="page" from="125" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The PCP theorem by gap amplification</title>
		<author>
			<persName><forename type="first">I</forename><surname>Dinur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A public key cryptosystem and a signature scheme based on discrete logarithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Elgamal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="469" to="472" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">How to prove yourself: Practical solutions to identification and signature problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1986</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Odlyzko</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="volume">263</biblScope>
			<biblScope unit="page" from="186" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient and verifiable shuffling and shuffle-decryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Furukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Trans. Fundam. Electron. Commun. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="172" to="188" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An implementation of a universally verifiable electronic voting scheme based on shuffling</title>
		<author>
			<persName><forename type="first">J</forename><surname>Furukawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Miyauchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Mori</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Obana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FC 2002</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Blaze</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2357</biblScope>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An efficient scheme for proving a shuffle</title>
		<author>
			<persName><forename type="first">J</forename><surname>Furukawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2001</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2139</biblScope>
			<biblScope unit="page" from="368" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Strengthening zero-knowledge protocols using signatures</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Mackenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="169" to="209" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the (in)security of the Fiat-Shamir paradigm</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2003/034" />
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="102" to="113" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The knowledge complexity of interactive proofs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="186" to="208" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A verifiable secret shuffle of homomorphic encryptions</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2005/246" />
	</analytic>
	<monogr>
		<title level="m">PKC 2003</title>
		<editor>
			<persName><forename type="first">Y</forename><forename type="middle">G</forename><surname>Desmedt</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2567</biblScope>
			<biblScope unit="page" from="145" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Honest verifier zero-knowledge arguments applied</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<idno>DS-04-3</idno>
	</analytic>
	<monogr>
		<title level="j">BRICS</title>
		<imprint>
			<biblScope unit="page">119</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Sub-linear zero-knowledge argument for correctness of a shuffle</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<ptr target="http://www.brics.dk/∼jg/PCPShuffle.pdf" />
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Verifiable shuffle of large size ciphertexts</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC 2007</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Okamoto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4450</biblScope>
			<biblScope unit="page" from="377" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Efficient arguments without short PCPs</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="278" to="291" />
		</imprint>
		<respStmt>
			<orgName>CCC</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A note on efficient zero-knowledge proofs and arguments</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="723" to="732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Efficient multi-exponentiation and application to batch verification of digital signatures</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Lim</surname></persName>
		</author>
		<ptr target="http://dasan.sejong.ac.kr/∼chlim/pub/multiexp.ps" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Parallel coin-tossing and constant-round secure two-party computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="143" to="184" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Computationally sound proofs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal of Computing</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1253" to="1298" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">A verifiable secret shuffle and its application to e-voting</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Neff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>ACM CCS</publisher>
			<biblScope unit="page" from="116" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Verifiable mixing (shuffling) of ElGamal pairs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Neff</surname></persName>
		</author>
		<ptr target="http://www.votehere.net/vhti/documentation/egshuf.pdf" />
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A provably secure and effcient verifiable shuffle based on a variant of the Paillier cryptosystem</title>
		<author>
			<persName><forename type="first">L</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="986" to="1010" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Verifiable shuffles: a formal model and a Paillier-based three-round construction with provable security</title>
		<author>
			<persName><forename type="first">L</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Safavi-Naini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kurosawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Information Security</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="241" to="255" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Shufle for Paillier&apos;s encryption scheme</title>
		<author>
			<persName><forename type="first">T</forename><surname>Onodera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tanaka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Trans. Fundam. Electron. Commun. Comput. Sci. E</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="page" from="1241" to="1248" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite residuosity classes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1999</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Stern</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1592</biblScope>
			<biblScope unit="page" from="223" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Non-interactive and information-theoretic secure verifiable secret sharing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 1991</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">576</biblScope>
			<biblScope unit="page" from="129" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Receipt-free mix-type voting scheme -a practical solution to the implementation of a voting booth</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sako</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 1995</title>
		<editor>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Guillou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-J</forename><surname>Quisquater</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">921</biblScope>
			<biblScope unit="page" from="393" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A sender verifiable mix-net and a new proof of a shuffle</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wikström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT 2005</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Roy</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3788</biblScope>
			<biblScope unit="page" from="273" to="292" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
