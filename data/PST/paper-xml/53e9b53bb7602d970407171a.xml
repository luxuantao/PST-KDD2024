<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Synthesis of Reactive(1) designs ✩,✩✩</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011-08-18">18 August 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Roderick</forename><surname>Bloem</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Graz University of Technology</orgName>
								<address>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Barbara</forename><surname>Jobstmann</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">CNRS/Verimag</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Nir</forename><surname>Piterman</surname></persName>
							<email>nir.piterman@le.ac.uk</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Leicester</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amir</forename><surname>Pnueli</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Weizmann Institute of Science</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yaniv</forename><surname>Sa'ar</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Weizmann Institute of Science</orgName>
								<address>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Synthesis of Reactive(1) designs ✩,✩✩</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2011-08-18">18 August 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">3284208EF7ACFF32AE40F1DA2C7F6E4D</idno>
					<idno type="DOI">10.1016/j.jcss.2011.08.007</idno>
					<note type="submission">Received 21 April 2010 Received in revised form 25 May 2011 Accepted 5 August 2011</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T13:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Property synthesis Realizability Game theory</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We address the problem of automatically synthesizing digital designs from linear-time specifications. We consider various classes of specifications that can be synthesized with effort quadratic in the number of states of the reactive system, where we measure effort in symbolic steps. The synthesis algorithm is based on a novel type of game called General Reactivity of rank 1 (gr(1)), with a winning condition of the form</p><p>where each p i and q i is a Boolean combination of atomic propositions. We show symbolic algorithms to solve this game, to build a winning strategy and several ways to optimize the winning strategy and to extract a system from it. We also show how to use gr(1) games to solve the synthesis of ltl specifications in many interesting cases. As empirical evidence to the generality and efficiency of our approach we include a significant case study. We describe the formal specifications and the synthesis process applied to a bus arbiter, which is a realistic industrial hardware specification of modest size.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>One of the most ambitious and challenging problems in computer science is the automatic synthesis of programs and (digital) designs from logical specifications. A solution to this problem would lift programming from the current level, which is mostly imperative, to a declarative, logical style. There is some evidence that this level is preferable, in particular when concurrency plays an important role.</p><p>The synthesis problem was first identified by Church <ref type="bibr" target="#b4">[5]</ref>. Several methods have been proposed for its solution <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>. The two prevalent approaches to solving the synthesis problem were by reducing it to the emptiness problem of tree automata, and viewing it as the solution of a two-person game. In these preliminary studies of the problem, the logical specification that the synthesized system should satisfy was given as an S1S formula and the complexity of synthesis is non-elementary.</p><p>The problem was considered again in <ref type="bibr" target="#b7">[8]</ref> in the context of synthesizing reactive modules from a specification given in Linear Temporal Logic (ltl). This followed two previous attempts <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref> to synthesize programs from temporal specifications, which reduced the synthesis problem to satisfiability, ignoring the fact that the environment should be treated as an adversary. The method proposed in <ref type="bibr" target="#b7">[8]</ref> for a given ltl specification ϕ starts by constructing a Büchi automaton B ϕ , which is then determinized into a deterministic Rabin automaton. This double translation necessarily causes a doubly exponential time complexity <ref type="bibr" target="#b10">[11]</ref>.</p><p>The high complexity established in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b10">11]</ref> caused the synthesis process to be identified as hopelessly intractable and discouraged many practitioners from ever attempting to use it for any sizeable system development. Yet there exist several interesting cases where the synthesis problem can be solved in polynomial time, by using simpler automata or partial fragments of ltl <ref type="bibr" target="#b11">[12]</ref><ref type="bibr">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref>. Representative cases are the work in <ref type="bibr" target="#b15">[16]</ref> which presents an efficient quadratic solution to games (and hence synthesis problems) where the acceptance condition is one of the ltl formulas 1p, Eq, 1 Ep, or E 1q. The work in <ref type="bibr">[13]</ref> presents efficient synthesis approaches for various ltl fragments.</p><p>This paper can be viewed as a generalization of the results of <ref type="bibr" target="#b15">[16]</ref> and <ref type="bibr">[13]</ref> into the wider class of Generalized Reactivity(1) formulas (gr(1)), i.e., formulas of the form</p><formula xml:id="formula_0">(1 E p 1 ∧ • • • ∧ 1 E p m ) → (1 Eq 1 ∧ • • • ∧ 1 Eq n ).</formula><p>(1)</p><p>Here, we assume that the specification is an implication between a set of assumptions and a set of guarantees. <ref type="foot" target="#foot_0">1</ref> Following the results of <ref type="bibr" target="#b18">[18]</ref>, we show how any synthesis problem whose specification is a gr(1) formula can be solved with effort O (mnN 2 ), where N is the size of the state space of the design and effort is measured in symbolic steps, i.e., in the number of preimage computations <ref type="bibr" target="#b19">[19]</ref>. Furthermore, we present a symbolic algorithm for extracting a design (program) which implements the specification.</p><p>We show that gr <ref type="bibr" target="#b0">(1)</ref> formulas can be used to represent a relatively wide set of specifications. First, we show that we can include past ltl formulas in both the assumptions and the guarantees. Second, we show that each of the assumptions and guarantees can be a deterministic "Just Discrete System" (Büchi automaton). Thus, our method does not incur the exponential blow-ups incurred in ltl synthesis for the translation of the formula to an automaton and for the determinization of the automaton because the user provides the specification as a set of deterministic automata. (But note that the state space of the system is the product of the sizes of the automata, which may cause an exponential blowup.) Furthermore, a symbolic implementation of our algorithm is easily obtained when the automata are represented in symbolic form. One drawback is that our formalism is less expressive than ltl. In particular, Reactivity (Streett) conditions can not be expressed.</p><p>The reader may suspect that gr(1) specifications place an undue burden on the user or that the expressivity is too limited. We argue that this is not the case. Intuitively, many specifications can naturally be split into assumptions on the environment and guarantees on the system. (Cf. <ref type="bibr" target="#b20">[20]</ref>.) Often, assumptions and guarantees can naturally be written as conjunctions of simple properties that are easily expressed as deterministic automata. We substantiate this view by presenting two case studies of small but realistic industrial modules. We show that the specifications for these modules can be expressed in gr <ref type="bibr" target="#b0">(1)</ref>, that their specifications are compact and easy to read, and that they can be synthesized relatively efficiently.</p><p>The first case study concerns a generalized buffer from ibm, a tutorial design for which a good specification is available. The second concerns the arbiter for one of the amba buses <ref type="bibr" target="#b21">[21]</ref>, a characteristic industrial design that is not too big. This is the first time realistic industrial examples have been tackled; previous work has only considered toy examples such as a simple mutual exclusion protocol, an elevator controller, or a traffic light controller <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b22">22]</ref>.</p><p>Our work stresses the compositionality of synthesis from ltl specifications and the structure of specifications as a guide to efficient synthesis. At the same time, it emphasizes the symbolic analysis of the state space through the usage of bdds. Sohail et al. removed some of the restrictions on the expressive power imposed by our work <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b24">24]</ref>. They present a compositional approach in which each property is translated to a Büchi or parity automaton and the resulting generalized parity game is solved symbolically. They also show how in some cases to circumvent the construction of deterministic automata based on <ref type="bibr" target="#b25">[25]</ref>. Morgenstern and Schneider present a similar approach. They construct an automaton that is minimal in the automata hierarchy for each of the properties in the specification <ref type="bibr" target="#b26">[26]</ref>.</p><p>In recent years significant theoretical progress has been made in approaches that emphasize the treatment of full ltl. One key result is that ltl realizability and synthesis can be reduced to games that are easier to solve than Rabin or parity games, when bounding the size of the resulting system. In <ref type="bibr" target="#b27">[27]</ref>, Kupferman and Vardi show a reduction to Büchi games that avoids the determinization procedure by going through universal co-Büchi automata. Their approach is further extended to work compositionally for specifications that are a conjunction of properties <ref type="bibr" target="#b28">[28]</ref>. The algorithm of <ref type="bibr" target="#b27">[27]</ref> was implemented directly in <ref type="bibr" target="#b22">[22]</ref>. Schewe and Finkbeiner extend the reduction to co-Büchi winning conditions introduced in <ref type="bibr" target="#b27">[27]</ref> to a reduction to Safety games <ref type="bibr" target="#b29">[29]</ref>. They show how to use these insights to solve distributed synthesis, where the size of components is bounded. Filiot, Jin, and Raskin <ref type="bibr" target="#b30">[30]</ref> give the same reduction to safety games and implement this approach using antichains to efficiently encode sets of states <ref type="bibr" target="#b30">[30]</ref>. To date, these approaches are still very restricted in the scale of systems they can handle.</p><p>The paper is structured as follows. We start with presenting the notation and recalling known results (Section 2). Then, we show how to solve Generalized Reactive(1) games symbolically (Section 3), compute a winning strategy, and extract a correct program, if it exists (Section 4). In Section 5, we show how the techniques developed in Sections 3 and 4 are used to synthesize systems from temporal specifications. In Section 6, we describe the amba ahb arbiter case study. We give its formal specification, and show the results of synthesizing it. Finally, we discuss lessons learned and conclude in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Linear temporal logic</head><p>We assume a countable set of Boolean variables (propositions) V. Without loss of generality, we assume that all variables are Boolean. The general case in which a variable ranges over arbitrary finite domains can be reduced to the Boolean case. ltl formulas are constructed as follows:</p><formula xml:id="formula_1">ϕ ::= p | ¬ϕ | ϕ ∨ ϕ | ! ϕ | ϕ U ϕ | ! ϕ | ϕ S ϕ.</formula><p>A model σ for a formula ϕ is an infinite sequence of truth assignments to propositions. Namely, if P is the set of propositions appearing in ϕ, then for every finite set P such that P ⊆ P , a word in (2 P ) ω is a model. Given a model σ = σ 0 , σ 1 , . . . , we denote by σ i the set of propositions at position i. For a formula ϕ and a position i 0, we say that ϕ holds at position i of σ , written σ , i | ϕ, and define it inductively as follows:</p><formula xml:id="formula_2">• For p ∈ P we have σ , i | p iff p ∈ σ i , • σ , i | ¬ϕ iff σ , i | ϕ, • σ , i | ϕ ∨ ψ iff σ , i | ϕ or σ , i | ψ , • σ , i | !ϕ iff σ , i + 1 | ϕ, • σ , i | ϕ U ψ iff there exists k i such that σ , k | ψ and σ , j | ϕ for all j, i j &lt; k, • σ , i | ! ϕ iff i &gt; 0 and σ , i -1 | ϕ, • σ , i | ϕ S ψ iff there exists k, 0 k i such that σ , k | ψ and σ , j | ϕ for all j, k &lt; j i.</formula><p>If σ , 0 | ϕ, then we say that ϕ holds on σ and denote it by σ | ϕ. A set of models M satisfies ϕ, denoted M | ϕ, if every model in M satisfies ϕ.</p><p>We use the usual abbreviations of the Boolean connectives ∧, → and ↔ and the usual definitions for true and false. We use the temporal abbreviations E (eventually), 1 (globally), W (weakuntil), and for the past fragment 1 (historically), E (once), and B (backto) which are defined as follows:</p><formula xml:id="formula_3">• Eϕ = true U ϕ, • 1ψ = ¬E¬ψ , • ϕ W ψ = (ϕ U ψ) ∨ 1ϕ, • Eϕ = true S ϕ, • 1 ψ = ¬ E ¬ϕ, and • ϕ B ψ = (ϕ S ψ) ∨ 1 ϕ.</formula><p>The following abbreviations are used in Section 6. They are inspired by the ones designed in psl <ref type="bibr" target="#b31">[31]</ref>. Given an atomic proposition p and two ltl formulas ϕ and ψ , we define</p><formula xml:id="formula_4">• raise(p) = ¬p ∧ !p, • fall(p) = p ∧ !¬p, and • ϕ W [i]ψ = ϕ W (ψ ∧ !(ϕ W [i -1]ψ)) for i &gt; 1 and ϕ W [1]ψ = ϕ W ψ .</formula><p>That is raise(p) indicates the raising edge of signal p, fall(p) indicates the falling edges of signal p, and the nested weak until ϕ W [i]ψ indicates that ϕ waits for ψ to hold i times or forever.</p><p>We distinguish between safety and liveness properties. An ltl-definable property ϕ is a safety property if for every model σ that violates ϕ, i.e., σ | ϕ, there exists an i such that for every σ that agrees with σ up to position i, i.e., ∀0 j i, σ i = σ i , σ also violates ϕ. An ltl-definable property ϕ is a liveness property if for every prefix of a model σ 0 , . . . , σ i there exists an infinite model σ that starts with σ 0 , . . . , σ i and σ | ϕ. Intuitively, safety properties specify bad things that should never happen and liveness properties specify good things that should occur. We distinguish between properties that are (i) safety, (ii) liveness, or (iii) combinations of safety and liveness.</p><p>A formula that does not include temporal operators is a Boolean formula (or an assertion). Given non-overlapping sets of</p><formula xml:id="formula_5">Boolean variables V 1 , . . . , V k , we use the notation ϕ(V 1 , . . . , V k ) to indicate that ϕ is a Boolean formula over V 1 ∪ • • • ∪ V k .</formula><p>For Boolean formulas we consider models representing only a single truth assignment, i.e., given a Boolean formula ϕ(V), we say that s ∈ 2 V models (or satisfies) ϕ, written as s | ϕ, if the formula obtained from ϕ by replacing all variables in s by true and all other variables by false is valid. Formally, we define s | ϕ inductively by (i</p><formula xml:id="formula_6">) for v ∈ V, s | v iff v ∈ s, (ii) s | ¬ϕ iff s | ϕ, and (iii) s | ϕ ∨ ψ iff s | ϕ or s | ψ .</formula><p>We call the set of all possible assignments to variables V states and denote them by Σ V (or simply Σ , if V is clear from the context), i.e., Σ V = 2 V . We say that s is a ϕ-state if s | ϕ. </p><formula xml:id="formula_7">V 1 ∪ • • • ∪ V k ∪ V 1 ∪ • • • ∪ V k , where V i is the set of primed versions of variables in V i , i.e., V i = {v | v ∈ V i }. Given an assertion ϕ(V 1 , . . . , V k , V 1 , . . . , V k ) and assignments s i , t i ∈ Σ V i , we use (s 1 , . . . , s k , t 1 , . . . , t k ) | ϕ to abbreviate s 1 ∪ • • • ∪ s 2 ∪ t 1 ∪ • • • ∪ t k | ϕ, where t i = {v ∈ V i | v ∈ t i }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Fair discrete systems</head><p>A fair discrete system (fds) <ref type="bibr" target="#b32">[32]</ref> is a symbolic representation of a transition system with finitely many states and weak and strong fairness constraints. We use fds to represent reactive systems such as concurrent systems that communicate by shared variables or digital circuits. Formally, an fds D = V, θ, ρ, J , C consists of the following components.</p><p>• V = {v 1 , . . . , v n }: A finite set of Boolean variables. We define a state s to be an interpretation of V, i.e., s ∈ Σ V .</p><p>• θ : The initial condition. This is an assertion over V characterizing all the initial states of the fds. A state is called initial if it satisfies θ .</p><p>• ρ: A transition relation. This is an assertion ρ(V ∪ V ), relating a state s ∈ Σ to its D-successors s ∈ Σ , i.e., (s, s ) | ρ.</p><p>• J = { J 1 , . . . , J m }: A set of justice requirements (weak fairness). Each requirement J ∈ J is an assertion over V that is intended to hold infinitely many times in every computation.</p><formula xml:id="formula_8">• C = {(P 1 , Q 1 ), . . . , (P n , Q n )}: A set of compassion requirements (strong fairness). Each requirement (P , Q ) ∈ C consists</formula><p>of a pair of assertions, such that if a computation contains infinitely many P -states, it should also hold infinitely many Q -states.</p><p>We define a run of the fds D to be a maximal sequence of states σ = s 0 , s 1 , . . . satisfying (i) initiality, i.e., s 0 | θ , and (ii) consecution, i.e., for every j 0, (s j , s j+1 ) | ρ. A sequence σ is maximal if either σ is infinite or σ = s 0 , . . . , s k and s k has no D-successor, i.e., for all s k+1 ∈ Σ , (s k , s k+1 ) | ρ.</p><p>A run σ is called a computation of D if it is infinite and satisfies the following additional requirements: (i) justice (or weak fairness), i.e., for each J ∈ J , σ contains infinitely many J -positions, i.e., positions j 0, such that s j | J , and (ii) compassion (or strong fairness), i.e., for each (P , Q ) ∈ C, if σ contains infinitely many P -positions, it must also contain infinitely many Q -positions.</p><p>We say that an fds D implements specification ϕ, denoted D | ϕ, if every run of D is infinite, and every computation of D satisfies ϕ. An fds is said to be fairness-free if J = C = ∅. It is called a just discrete system (jds) if C = ∅. When J = ∅ or C = ∅ we simply omit them from the description of D. Note that for most reactive systems, it is sufficient to use a jds (i.e., compassion-free) model. Compassion is only needed in cases, in which the system uses built-in synchronization constructs such as semaphores or synchronous communication.</p><p>An fds D is deterministic with respect to X ⊆ V, if (i) D has deterministic initial states, i.e, for all states s, t ∈ Σ V , if s | θ , t | θ , and s| X = t| X , then s = t holds, and (ii) D has deterministic transitions, i.e., for all states s, s , s ∈ Σ V , if (s, s ) | ρ, (s, s ) | ρ, and s | X = s | X , then s = s holds.</p><p>An fds D is complete with respect to X ⊆ V, if (i) for every assignment s X ∈ Σ X , there exists a state s ∈ Σ V such that s| X = s X and s | θ , and (ii) for all states s ∈ Σ V and assignments s X ∈ Σ X , there exists a state s ∈ Σ V such that s | X = s X and (s, s ) | ρ. For every fds and every X ⊆ V, we can construct an fds that is complete w.r.t. X whose set of computations is the same as that of the original. We simply add a Boolean variable sf and set θ := sf ↔ θ and ρ := sf ↔ (ρ ∧ sf ) and add sf as an additional justice requirement. The set of computations of the two fds (when projecting the value of sf ) are the same.</p><p>Given an fds D that is deterministic and complete w.r.t. X , for every possible sequence σ = s 0 , s 1 , . . . of states in Σ X , D has a unique run τ = t 0 , t 1 , . . . such that for all j 0, s j | X = t j | X holds. We call τ the run of D on σ . Note that D can be seen as a symbolic representation of a Mealy machine with input signal X and output signals V \ X . We say that a sequence σ ∈ (Σ X ) ω is accepted by D, if the run of D on σ is a computation.</p><p>For every fds D, there exists an ltl formula ϕ D , called the temporal semantics of D, which characterizes the computations of D. It is given by</p><formula xml:id="formula_9">ϕ D : θ ∧ 1 ρ(V, !V) ∧ J ∈J 1 E J ∧ (P ,Q )∈C (1 EP → 1 EQ ),</formula><p>where ρ(V, !V) is the formula obtained from ρ by replacing each instance of primed variable v by the ltl formula !v.</p><p>Note that in the case that D is compassion-free (i.e., it is a jds), then its temporal semantics has the form</p><formula xml:id="formula_10">ϕ D : θ ∧ 1 ρ(V , !V ) ∧ J ∈J 1 E J .</formula><p>Here, we are interested in open systems. That is, systems that interact with their environment: that receive some inputs and react to them. For such systems specifications are usually partitioned into assumptions and guarantees. The intended meaning is that if all assumptions hold then all guarantees should hold as well. That is, if the environment behaves as expected then the system will behave as expected as well. In many cases, when we consider the conjunction of all assumptions (or all guarantees) the resulting formula is the temporal semantics of a jds. That is, it is common to get specifications of the form ϕ e and ϕ s , where (i) ϕ e and ϕ s are conjunctions of smaller properties, (ii) ϕ e and ϕ s are the temporal semantics of jdss, and (iii) the intended meaning is that the system should satisfy ϕ e → ϕ s .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Game structures</head><p>We consider two-player games played between a system and an environment. The goal of the system is to satisfy the specification regardless of the actions of the environment. Formally, a game structure G = V, X , Y, θ e , θ s , ρ e , ρ s , ϕ consists of the following components.</p><p>• V = {v 1 , . . . , v n }: A finite set of typed state variables over finite domains. Without loss of generality, we assume they are all Boolean. A state and the set of states Σ V are defined as before. • X ⊆ V is a set of input variables. These are variables controlled by the environment.</p><p>• Y = V \ X is a set of output variables. These are variables controlled by the system.</p><p>• θ e is an assertion over X characterizing the initial states of the environment.</p><p>• θ s is an assertion over V characterizing the initial states of the system.</p><p>• ρ e (V, X ) is the transition relation of the environment. This is an assertion relating a state s ∈ Σ to a possible next input value s X ∈ Σ X by referring to unprimed copies of V and primed copies of X . The transition relation ρ e identifies a valuation s X ∈ Σ X as a possible input in state s if (s, s X ) | ρ e . • ρ s (V, X , Y ) is the transition relation of the system. This is an assertion relating a state s ∈ Σ and an input value s X ∈ Σ X to an output value s Y ∈ Σ Y by referring to primed and unprimed copies of V. • ϕ is the winning condition, given by an ltl formula.</p><p>A state s is initial if it satisfies both θ e and θ s , i.e., s | θ e ∧ θ s . For two states s and s of G, s is a successor of s if (s, s ) | ρ e ∧ ρ s . A play σ of G is a maximal sequence of states σ = s 0 , s 1 , . . . satisfying (i) initiality, i.e., s 0 is initial and (ii) consecution, i.e., for each j 0, s j+1 is a successor of s j . Let G be a game structure and σ be a play of G. Initially, the environment chooses an assignment s X ∈ Σ X such that s X | θ e and the system chooses an assignment s Y ∈ Σ Y such that (s X , s Y ) is initial. From a state s, the environment chooses an input s X ∈ Σ X such that (s, s X ) | ρ e and the system chooses an output s Y ∈ Σ Y such that (s, s X , s Y ) | ρ s . We say that a play starting in state s is an s-play.</p><p>A play σ = s 0 , s 1 , . . . is winning for the system if either (i) σ is finite and there is no assignment s X ∈ Σ X such that (s n , s X ) | ρ e , where s n is the last state in σ , or (ii) σ is infinite and it satisfies ϕ. Otherwise, σ is winning for the environment.</p><p>A strategy for the system is a partial function f :</p><formula xml:id="formula_11">M × Σ V × Σ X → M × Σ Y ,</formula><p>where M is some memory domain with a designated initial value m 0 ∈ M, such that for every s ∈ Σ V , every s X ∈ Σ X , and</p><formula xml:id="formula_12">m ∈ M if (s, s X ) | ρ e then (s, s X , s Y ) | ρ s ,</formula><p>where f (m, s, s X ) = (m , s Y ). Let f be a strategy for the system. A play s 0 , s 1 , . . . is said to be compliant with strategy f if for all i 0 we have f (m i , s i , s i+1 | X ) = (m i+1 , s i+1 | Y ). Notice, that the sequence m 0 , m 1 , . . . is implicitly defined. Strategy f is winning for the system from state s ∈ Σ V if all s-plays (plays starting from s) which are compliant with f are winning for the system. We denote by W s the set of states from which there exists a winning strategy for the system. We treat W s as an assertion as well. For player environment, strategies, winning strategies, and the winning set W e are defined dually.</p><p>A game structure G is said to be winning for the system, if for all s X ∈ Σ X , if s X | θ e , then there exists</p><formula xml:id="formula_13">s Y ∈ Σ Y such that (s X , s Y ) | θ s and (s X , s Y ) | W s .</formula><p>We say that f uses finite memory or is finite when M is finite. When M is a singleton, we say that f is memoryless.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1.">Realizability and synthesis</head><p>Given an ltl formula ϕ over sets of input and output variables X and Y, we say that an fds D = V, θ, ρ, J , C realizes ϕ if (i) V contains X and Y, (ii) D is complete with respect to X , and (iii) D | ϕ. Such an fds is called a controller for ϕ, or just a controller. We say that the specification is realizable <ref type="bibr" target="#b7">[8]</ref>, if there exists a fairness-free fds D that realizes it.</p><p>Otherwise, we say that the specification is unrealizable. If the specification is realizable, then the construction of such a controller constitutes a solution for the synthesis problem. <ref type="foot" target="#foot_1">2</ref>Given an ltl formula over sets of input and output variables X and Y, respectively, its realizability problem can be reduced to the decision of winner in a game. Formally, G ϕ = X ∪ Y, X , Y, true, true, true, true, ϕ is the game where the initial conditions and the transition relations are true and the winning condition is ϕ. If the environment is winning in G ϕ , then ϕ is unrealizable. If the system is winning in G ϕ , then ϕ is realizable. Furthermore, from the winning strategy of the system it is possible to extract a controller that realizes ϕ. Realizability for general ltl specifications is 2EXPTIMEcomplete <ref type="bibr" target="#b33">[33]</ref>. It is well known that for ltl specifications it is sufficient to consider finite memory strategies. In this paper we are interested in a subset of ltl for which we solve realizability and synthesis in time exponential in the size of the ltl formula and polynomial in the resulting controller.</p><p>More generally, consider a game G : V, X , Y, θ e , θ s , ρ e , ρ s , ϕ . The system wins in G iff the following formula is realizable 3 :</p><formula xml:id="formula_14">ϕ G = (θ e → θ s ) ∧ θ e → 1 (1ρ e ) → ρ s ∧ (θ e ∧ 1ρ e → ϕ).</formula><p>Formally, we have the following.</p><p>Theorem 1. The system wins in a game G iff ϕ G is realizable.</p><p>The proof of this theorem resembles the proof of Theorem 4 and is omitted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Generalized Reactive(1) games</head><p>In <ref type="bibr" target="#b18">[18]</ref>, we consider the case of Generalized Reactive(1) games (called there generalized Streett(1) games). In these games the winning condition is an implication between conjunctions of recurrence formulas (1 E J where J is a Boolean formula).</p><p>We repeat the main ideas from <ref type="bibr" target="#b18">[18]</ref> and show how to solve gr(1) games, by computing the winning states of each of the players. We start with a definition of μ-calculus over game structures. We then give the μ-calculus formula that characterizes the set of winning states of the system; and explain how to implement this solution symbolically. We defer the extraction of a controller from this computation to Section 4. We finish this section by explaining the straightforward usage of gr(1) games in synthesis from ltl. In Section 5 we include a thorough discussion of usage of gr(1) games for ltl synthesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">μ-Calculus over game structures</head><p>We define μ-calculus <ref type="bibr" target="#b34">[34]</ref> over game structures. Consider a game structure G : V, X , Y, θ e , θ s , ρ e , ρ s , ϕ . For every variable v ∈ V the formulas v and ¬v are atomic formulas. Let Var = {X, Y , . . .} be a set of relational variables. The μ-calculus formulas are constructed as follows:</p><formula xml:id="formula_15">ϕ ::= v | ¬v | X | ϕ ∨ ϕ | ϕ ∧ ϕ | ϕ | ϕ | μXϕ | ν Xϕ.</formula><p>A formula ψ is interpreted as the set of G-states in Σ in which ψ is true. We write such set of states as [[ψ]] E G where G is the game structure and E : Var → 2 Σ is an environment. The environment assigns to each relational variable a subset of Σ . We denote by E</p><formula xml:id="formula_16">[X ← S] the environment such that E[X ← S]( X) = S and E[X ← S](Y ) = E(Y ) for Y = X . The set [[ψ]] E G is defined inductively as follows. 4 • [[v]] E G = {s ∈ Σ | s[v] = 1}. • [[¬v]] E G = {s ∈ Σ | s[v] = 0}. • [[X]] E G = E(X). • [[ϕ ∨ ψ]] E G = [[ϕ]] E G ∪ [[ψ]] E G . • [[ϕ ∧ ψ]] E G = [[ϕ]] E G ∩ [[ψ]] E G . • [[ ϕ]] E G = s ∈ Σ ∀s X ∈ Σ X , (s, s X ) | ρ e → ∃s Y ∈ Σ Y such that (s, s X , s Y ) | ρ s and (s X , s Y ) ∈ [[ϕ]] E G . A state s is included in [[ ϕ]] E G if the system can force the play to reach a state in [[ϕ]] E G .</formula><p>That is, regardless of how the environment moves from s, the system can choose an appropriate move into</p><formula xml:id="formula_17">[[ϕ]] E G . • [[ ϕ]] E G = s ∈ Σ ∃s X ∈ Σ X such that (s, s X ) | ρ e and ∀s Y ∈ Σ Y , (s, s X , s Y ) | ρ s → (s X , s Y ) ∈ [[ϕ]] E G . A state s is included in [[ ϕ]] E G if the environment can force the play to reach a state in [[ϕ]] E G .</formula><p>As the environment moves first, it chooses an input s X ∈ Σ X such that for all choices of the system the successor is in</p><formula xml:id="formula_18">[[ϕ]] E G .</formula><p>3 Technically, ρ e and ρ s contain primed variables and are not ltl formulas. This can be easily handled by using the next operator (!). We ignore this issue in the rest of the paper. 4 Only for finite game structures.</p><p>•</p><formula xml:id="formula_19">[[μXϕ]] E G = i S i where S 0 = ∅ and S i+1 = [[ϕ]] E[X←S i ] G . • [[ν Xϕ]] E G = i S i where S 0 = Σ and S i+1 = [[ϕ]] E[X←S i ] G .</formula><p>When all the variables in ϕ are bound by either μ or ν the initial environment is not important and we simply write</p><formula xml:id="formula_20">[[ϕ]] G . In case that G is clear from the context we write [[ϕ]].</formula><p>The alternation depth of a formula is the number of alternations in the nesting of least and greatest fixpoints. A μ-calculus ) <ref type="bibr" target="#b36">[36]</ref>. In general, if the number of transitions of G is m, then it is known that a μ-calculus formula over G can be evaluated in time proportional</p><formula xml:id="formula_21">formula</formula><p>to O (m|Σ| k</p><p>2 ) <ref type="bibr" target="#b37">[37]</ref>. For a full exposition of μ-calculus we refer the reader to <ref type="bibr" target="#b38">[38]</ref>. We often abuse notations and write a μ-calculus formula ϕ instead of the set <ref type="bibr">[[ϕ]</ref>].</p><p>In some cases, instead of using a very complex formula, it may be more readable to use vector notation as in Eq. ( <ref type="formula" target="#formula_22">2</ref>):</p><formula xml:id="formula_22">ϕ = ν Z 1 Z 2 μY ( Y ∨ p ∧ Z 2 ) μY ( Y ∨ q ∧ Z 1 ) . (<label>2</label></formula><formula xml:id="formula_23">)</formula><p>Such a formula, may be viewed as the mutual fixpoint of the variables Z 1 and Z 2 or equivalently as an equal formula where a single variable Z replaces both Z 1 and Z 2 and ranges over pairs of states <ref type="bibr" target="#b39">[39]</ref>. The formula above characterizes the set of states from which system can force the game to visit p-states infinitely often and q-states infinitely often. We can characterize the same set of states by the following 'normal' formula <ref type="foot" target="#foot_2">5</ref> :</p><formula xml:id="formula_24">ϕ = ν Z μY ( Y ∨ p ∧ Z ) ∧ μY ( Y ∨ q ∧ Z ) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Solving gr(1) games</head><p>Let G be a game where the winning condition is of the following form:</p><formula xml:id="formula_25">ϕ = m i=1 1 E J e i → n j=1 1 E J s j .</formula><p>Here J e i and J s j are Boolean formulas. We refer to such games as Generalized Reactivity(1) games, or gr(1) in short. In <ref type="bibr" target="#b18">[18]</ref> we term these games as generalized Streett(1) games and provide the following μ-calculus formula to solve them. Let</p><formula xml:id="formula_26">j ⊕ 1 = ( j mod n) + 1, ϕ gr = ν ⎡ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎣ Z 1 Z 2 . . . . . . Z n ⎤ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎦ ⎡ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎣ μY ( m i=1 ν X( J s 1 ∧ Z 2 ∨ Y ∨ ¬ J e i ∧ X)) μY ( m i=1 ν X( J s 2 ∧ Z 3 ∨ Y ∨ ¬ J e i ∧ X)) . . . . . . μY ( m i=1 ν X( J s n ∧ Z 1 ∨ Y ∨ ¬ J e i ∧ X)) ⎤ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎦ . (<label>3</label></formula><formula xml:id="formula_27">)</formula><p>Intuitively, for j ∈ [1.</p><p>.n] and i ∈ [1.</p><p>.m] the greatest fixpoint ν X( J s j ∧ Z j⊕1 ∨ Y ∨ ¬ J e i ∧ X) characterizes the set of states from which the system can force the play either to stay indefinitely in ¬ J e i states (thus violating the left-hand side of the implication) or in a finite number of steps reach a state in the set J s j ∧ Z j⊕1 ∨ Y . The two outer fixpoints make sure that the system wins from the set J s j ∧ Z j⊕1 ∨ Y . The least fixpoint μY makes sure that the unconstrained phase of a play represented by the disjunct Y is finite and ends in a J s j ∧ Z j⊕1 state. Finally, the greatest fixpoint ν Z j is responsible for ensuring that, after visiting J s j , we can loop and visit J s j⊕1 and so on. By the cyclic dependence of the outermost greatest fixpoint, either all the sets in J s j are visited or, getting stuck in some inner greatest fixpoint, some J e i is visited only finitely many times. We include in Fig. <ref type="figure" target="#fig_1">1</ref> a (slightly simplified) code of the implementation of this μ-calculus formula in Jtlv ( <ref type="bibr" target="#b40">[40]</ref>). We denote the system and environment players by sys and env, respectively. We denote J e i and J s j by env.Ji(i) and sys.Ji(j), respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. (See [18].) W s = [[ϕ]].</head><p>is denoted by cox. We use Fix to iterate over the fixpoint values. The loop terminates if two successive values are the same. We use mem to collect the intermediate values of Y and X. We denote by mY the two dimensional vector ranging over 1..n, and 1..k, where k is the depth of the least fixpoint iteration of Y. We denote by mX a three dimensional vector ranging over 1..n, 1..k, and 1..m. We use the sets mY[ j][r] and their subsets mX[ j][r][i] to define n memoryless strategies for the system. The strategy f j is defined on the states in Z j . We show that the strategy f j either forces the play to visit J s j and then proceed to Z j⊕1 , or eventually avoid some J e i . We show that by combining these strategies, either the system switches strategies infinitely many times and ensures that the play be satisfies the right-hand side of the implication or eventually uses a fixed strategy ensuring that the play does not satisfy the left-hand side of the implication. Essentially, the strategies are "go to mY[ j][r] for minimal r" until getting to a J s j state and then switch to</p><formula xml:id="formula_28">strategy j ⊕ 1 or "stay in mX[ j][r][i]".</formula><p>It follows that we can solve realizability of ltl formulas in the form that interests us in polynomial (quadratic) time. <ref type="bibr" target="#b18">[18]</ref>.) A game structure G with a gr(1) winning condition of the form ϕ = m i=1 1 E J e i → n j=1 1 E J s j can be solved by a symbolic algorithm that performs O (nm|Σ| 2 ) next step computations, where Σ is the set of all possible assignments to the variables in ϕ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3. (See</head><p>A straightforward implementation of the fixpoint computation gives a cubic upper bound. Implementing the approach of <ref type="bibr" target="#b36">[36]</ref> reduces the complexity in |Σ| to quadratic, as stated. Their approach starts computations of fixpoints from earlier approximations of their values. Thus, the fixpoint is not restarted from scratch leading to significant savings. An enumerative algorithm (i.e., an algorithm that handles states individually and not sets of states) can solve a gr(1) game structure in time</p><formula xml:id="formula_29">O (nm|Σ||T |)</formula><p>, where |T | is the number of transitions in the game <ref type="bibr" target="#b41">[41]</ref>. <ref type="foot" target="#foot_3">6</ref>Following Theorem 1, we prove the following about the connection between solving gr(1) games and realizability. Consider a gr(1) game G: V, X , Y, θ e , θ s , ρ e , ρ s , ϕ , where</p><formula xml:id="formula_30">ϕ = m i=1 1 E J e i → n j=1 1 E J s j . Let ϕ G = (θ e → θ s ) ∧ θ e → 1 (1ρ e ) → ρ s ∧ (θ e ∧ 1ρ e ) → ϕ .</formula><p>Intuitively, this formula is split into three levels: initial, safety, and liveness levels. In order to realize this formula the system needs to satisfy the same levels the environment does. For instance, if the environment chooses an initial assignment satisfying θ e , the system cannot choose an initial assignment violating θ s even if the environment later violates ρ e . Theorem 4. The system wins in G iff ϕ G is realizable.</p><p>Proof. Recall that if the system wins G finite memory suffices. Let M be some memory domain and m 0 its designated initial value. Suppose that f : M × Σ × Σ X → M × Σ Y is a winning strategy for the system in G. Furthermore, for every s X ∈ Σ X such that s X | θ e there exists a s Y ∈ Σ Y such that (s X , s Y ) | θ e ∧ θ s and (s X , s Y ) ∈ W s . We use f to construct a fairness-free fds that realizes ϕ G .</p><p>Let |M| = k and let M = {m 1 , . . . ,m log(k) } be Boolean variables. It follows that an assignment to M characterizes a value in M. By abuse of notations, we denote by m the value in M, the assignment to M that represents that value, and the assertion over M whose unique satisfying assignment is m. Similarly, for a state s ∈ Σ , we denote by s the assertion whose unique satisfying assignment is s. Consider the fairness-free fds D = V, θ, ρ with the following components.</p><formula xml:id="formula_31">• V = X ∪ Y ∪ M. • θ = θ e → (θ s ∧ m 0 ∧ W s ).</formula><p>That is, if the assignment to X satisfies θ e then the assignment to Y ensures θ s and the joint assignment to X and Y (i.e., the state) is in W s . Furthermore, the initial memory value is m 0 . If the assignment to the input variables does not satisfy θ e then the choice of m and s Y is arbitrary. • For the definition of ρ we write the strategy f as an assertion as follows:</p><formula xml:id="formula_32">f = m∈M s∈W s s X ∈Σ X m ∧ s ∧ s X → f m, s, s X .</formula><p>That is, depending on the current value of m, s, and s X , the assignment to m and s Y respects the strategy f . Finally, ρ is the following assertion:</p><formula xml:id="formula_33">ρ = (W s ∧ ρ e ) → f .</formula><p>That is, if the current state s is winning for system (W s ) and the environment chooses an input s X such that (s, s X ) | ρ e , then the system is going to update the memory and choose outputs s Y according to f . If the current state is winning for the environment or the environment does not satisfy its transition, the choice of memory value and output is arbitrary.</p><p>We have to show that D is complete with respect to X and that D | ϕ G . Completeness of D follows from the definition of winning in G and from the definition of the strategy f . Indeed, as system wins G, for every s X ∈ Σ X such that s X | θ e there exists a state s ∈ Σ such that s ∈ W s and s | θ e ∧ θ s . Furthermore, if s X | θ e then, by definition of θ , for every state s such that s| X = s X we have s | θ . Similarly, for every m ∈ M, s ∈ Σ , and</p><formula xml:id="formula_34">s X ∈ Σ X , if s ∈ W s and (s, s X ) | ρ e then f defines values s Y and m such that (s, m, s X , m , s Y ) | ρ. If s / ∈ W s or (s, s X ) | ρ e then for every s Y ∈ Σ Y we have (s, m, s X , m , s Y ) | ρ. We have to show that D | ϕ G . Consider an infinite computation σ : s 0 , s 1 , . . . of D. Clearly, if s 0 | θ e then σ | ϕ G .</formula><p>Assume that s 0 | θ e , then by definition of θ we have s 0 | θ s and s 0 ∈ W s as well. Suppose now that for some i we have (s i , s i +1 ) | ρ e . Let i 0 be the minimal such that (s i 0 , s i 0 +1 ) | ρ e . We can show by induction that for every i &lt; i 0 we have s i ∈ W s and (s i , s i+1 ) | ρ s . It follows that σ | 1(1 ρ e → ρ s ) as required. Finally, as σ | 1ρ e the third clause holds as well. The remaining case is when σ | 1ρ e . We can show by induction that for every i 0 we have</p><formula xml:id="formula_35">(s i , s i+1 ) | ρ s . We have to show that σ | ϕ as well. However, σ | X ∪Y is a play in G that is compliant with f . It follows that σ | ϕ as required. Overall, D | ϕ G .</formula><p>Suppose that there exists a fairness-free fds D = V, θ, ρ that is complete with respect to X and such that D | ϕ. We use the states of D as the memory domain for construction of a strategy f . Let t in be a new state to be used as the initial value of the memory. Formally, for a memory value t we define f (t, s, s X ) = (t , s Y ) as follows.</p><p>• If t = t in then we define t and s Y as follows.</p><p>-If s | θ e ∧ θ s and there exists a state t 0 | θ such that t 0 | X ∪Y = s then, by completeness of D, there exists a successor t of t 0 such that t | X = s X and we set s</p><formula xml:id="formula_36">Y = t | Y . -If s | θ e ∧ θ s</formula><p>or there is no state t 0 | θ such that t 0 | X ∪Y = s then we choose arbitrary t and s Y (if at all).</p><p>• If t = t in then we define t and s Y as follows.</p><p>-If t| X ∪Y = s, then, by completeness of D, the state t has a successor t such that t | X = s X . We set t = t and</p><formula xml:id="formula_37">s Y = t | Y . -If t| X ∪Y = s, then t and s Y are arbitrary.</formula><p>We claim that this strategy is winning from every state s for which there exists a state t 0 such that t 0 | θ and t 0 | X ∪Y = s.</p><p>Consider such a state s 0 . Then for every s X such that (s 0 , s X ) | ρ e there exists a t 1 and s Y such that (t 0 , t 1 ) | ρ s , t 1 | X = s X , and t 1 | Y = s Y . Consider a play σ : s 0 , . . . , s n compliant with f , where the sequence of memory values is τ : t 0 , . . . , t n . It is simple to show by induction that for every j 1 we have t j | X ∪Y = s j . Consider a value s X such that (s n , s X ) | ρ e . By completeness of D there exists a memory value t n+1 such that (t n , t n+1 ) | ρ, t n+1 | X = s X so the strategy f is defined. Furthermore, from D | ϕ G it follows that (t n , t n+1 ) | ρ s . Thus, t n+1 | Y is a valid choice of the strategy f . Consider an infinite play σ : s 0 , . . . compliant with f , where τ : t 0 , . . . is the associated sequence of memory values. Then, as τ is a computation of D (modulo the initial state), it follows that τ | ϕ G . We conclude that σ | ϕ.</p><p>Finally, we have to show that for every value s X such that s X | θ e there exists a value s Y such that (s X , s Y ) | θ e ∧ θ s . However, this follows from the completeness of D and from the inclusion of θ e on the left-hand side of every implication in ϕ G . 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Symbolic Jds specifications</head><p>We would like to use gr(1) games to solve realizability directly from ltl formulas. In many practical cases, the specification is partitioned to assumptions and guarantees. Each assumption or guarantee is relatively simple; and together they have the semantics that the conjunction of all assumptions implies the conjunction of all guarantees. To support this claim, we will demonstrate in Section 6 the application of the synthesis method to a realistic industrial specification. Here we suggest to embed such specifications directly into a gr(1) game, giving rise to the strict semantics of the implication. In Section 5 we discuss the differences between the strict semantics and the simple implication.</p><p>Recall that a temporal semantics of a jds D has the following form:</p><formula xml:id="formula_38">ϕ D : θ ∧ 1 ρ(V, !V) ∧ J ∈J 1 E J .</formula><p>Let X and Y be finite sets of typed input and output variables, respectively and let V = X ∪ Y. We say that a jds is output independent if θ does not relate to Y and ρ does not depend on the value of Y in the next state. That is, ρ can be expressed as an assertion over X ∪ Y ∪ X . A jds can be represented by a triplet ϕ i , Φ t , Φ g with the following parts.</p><p>• ϕ i is an assertion which characterizes the initial states (i.e., θ above).</p><p>• Φ t = {ψ i } i∈I t is a set of Boolean formulas ψ i , where each ψ i is a Boolean combination of variables from X ∪ Y and expressions of the form !v where v ∈ X if the jds is output independent, and v ∈ X ∪ Y otherwise.</p><p>That is ρ(V, !V) is the conjunction of all the assertions in Φ t .</p><p>• Φ g = { J i } i∈I g is a set of Boolean formulas (i.e, Φ g is a different name for J ).</p><p>The intended semantics of the triplet ϕ i , Φ t , Φ g is</p><formula xml:id="formula_39">ϕ i ∧ i∈I t 1ψ i ∧ i∈I g 1 E J i .</formula><p>Consider the case where assumptions and guarantees have the following forms: (i) ψ for an assertion over V, (ii) 1ψ for an assertion over V ∪ V , or (iii) 1 Eψ for an assertion over V. Then, we can partition the Boolean components of assumptions or guarantees to triplets as explained above.</p><formula xml:id="formula_40">Let S α = ϕ α i , Φ α t , Φ α</formula><p>g for α ∈ {e, s} be two specifications as described above, where S e is output independent. Here S e is a description of the environment (i.e., results from the assumptions) and S s is the description of the system (i.e., results from the guarantees). The specifications S e and S s naturally give rise to the following game. The strict realizability game for S e and S s is G sr e,s : V, X , Y, θ e , θ s , ρ e , ρ s , ϕ with the following components. 7   • V = X ∪ Y.</p><p>• θ e = ϕ e i .</p><p>• θ s = ϕ s i .</p><p>• ρ e = i∈I e t ψ e i .</p><p>• ρ s = i∈I s t</p><formula xml:id="formula_41">ψ s i . • ϕ = i∈I e g 1 E J e i → i∈I s g 1 E J s i .</formula><p>By Theorem 4 the game G sr e,s is winning for system iff the following formula is realizable 7 The name strict realizability when referring to such a composition was coined in <ref type="bibr" target="#b43">[43]</ref>.</p><formula xml:id="formula_42">ϕ sr e,s = ϕ e i → ϕ s i ∧ ϕ e i ∧ 1 (1ρ e ) → ρ s ∧ ϕ e i ∧ 1ρ e ∧ i∈I e g 1 E J e i → i∈I s g 1 E J s i .</formula><p>The proof of Theorem 4 also tells us how to extract an implementation for ϕ sr e,s from the winning strategy in G sr e,s .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Example: Lift controller</head><p>As an example, we consider a simple lift controller. We specify a lift controller serving n floors. We assume the lift has n button sensors (b 1 , . . . , b n ) controlled by the environment. The lift may be requested on every floor, once the lift has been called on some floor the request cannot be withdrawn. Initially, on all floors there are no requests. The location of the lift is modeled by n Boolean variables ( f 1 , . . . , f n ) controlled by the system. Once a request has been fulfilled it is removed.</p><p>Formally, the specification of the environment is S e = ϕ e i , {ψ </p><formula xml:id="formula_43">ϕ e i = j ¬b j , ψ e 1, j = b j ∧ f j → !¬b j , ψ e 2, j = b j ∧ ¬ f j → !b j .</formula><p>We expect the lift to initially start on the first floor. We model the location of the lift by an n bit array. Thus we have to demand mutual exclusion on this array. The lift can move at most one floor at a time, and eventually satisfy every request. Formally, the specification of the system is</p><formula xml:id="formula_44">S s = ϕ s i , {ψ s 1 , ψ s 2,1 , . . . , ψ s 2,n , ψ s 3,1 , . . . , ψ s 3,n }, { J s 1 , . . . , J s n+1 }</formula><p>, where the components of S s are as follows:</p><formula xml:id="formula_45">ϕ s i = j ( j = 1 ∧ f j ) ∨ ( j = 1) ∧ ¬ f j , ψ s 1 = up → sb, ψ s 2, j = k = j ¬( f j ∧ f k ), ψ s 3, j = f j → !( f j ∨ f j-1 ∨ f j+1 ), J s j = b j → f j , J s n+1 = f 1 ∨ sb,</formula><p>where up = i ( f i ∧ ! f i+1 ) denotes that the lift moves one floor up, and sb = i b i denotes that at least one button is pressed. The requirement ψ s 1 states that the lift should not move up unless some button is pressed. The liveness requirement J s n+1 states that either some button is pressed infinitely many times, or the lift parks at floor f 1 infinitely many times. Together they imply that when there is no active request, the lift should move down and park at floor f 1 .</p><p>The strict realizability game for S e and S s is won by system, implying that there is a controller realizing ϕ sr e,s .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">GR(1) strategies</head><p>In this section we discuss how to extract a program from the solution of the gr(1) game. First, we show how to analyze the intermediate values and how to extract from them a winning strategy for the system. Then, we show how this strategy can be reduced in size in some cases. Finally, we show how to extract from the symbolic bdd representation of the strategy a deterministic strategy that can be used for creating an hdl description of a resulting circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Extracting the strategy</head><p>We show how to use the intermediate values in the computation of the fixpoint to produce an fds that implements ϕ.</p><p>The fds basically follows the strategies explained in Section 3.2. Recall that the combined strategy does one of two things.</p><p>It either iterates over strategies f 1 , .., f n infinitely often, where strategy f j ensures that the play reaches a J s j state. Thus, the play satisfies all liveness guarantees. Or, it eventually uses a fixed strategy ensuring that the play does not satisfy one of the liveness assumptions. Let Z n = {z 0 , . . . , z k } be a set of Boolean variables that encode a counter ranging over <ref type="bibr">[1.</ref>.n]. We denote by Z n = j the variable assignment that encodes the value j. Let X and Y be finite sets of input and output variables, respectively, and ϕ be a gr(1) winning condition. Let G = V, X , Y, θ e , θ s , ρ e , ρ s , ϕ be a game structure (where V = X ∪ Y). We show how to construct a fairness-free fds D = V D , θ D , ρ , where V D = V ∪ Z n , such that D is complete with respect to X . the BDD representing the set of winning states. Following Theorem 4, we set θ D = θ e → (θ s ∧ Z n = 1 ∧ Z). Recall, that Z is the variable representing the winning states for the system (as in Fig. <ref type="figure" target="#fig_1">1</ref>). The variable Z n is used to store internally which strategy should be applied. The transition relation ρ is (ρ e ∧ Z) → (ρ 1 ∨ ρ 2 ∨ ρ 3 ), where ρ 1 , ρ 2 , and ρ 3 are formally defined in Fig. <ref type="figure" target="#fig_2">2</ref>, and described below.</p><formula xml:id="formula_46">ρ 1 = j∈[1..n] (Z n = j) ∧ J e j ∧ ρ s ∧ Z ∧ (Z n = j ⊕ 1), ρ 2 ( j) = r&gt;1 mY[ j][r] ∧ ¬mY[ j][&lt;r] ∧ ρ s ∧ mY [ j][&lt;r], ρ 2 = j∈[1..n] (Z n = Z n = j) ∧ ρ 2 ( j), ρ 3 ( j) = r i∈[1..m] mX[ j][r][i] ∧ ¬mX[ j][≺(r, i)] ∧ ¬ J s i ∧ ρ s ∧ mX [ j][r][i], ρ 3 = j∈[1..n] (Z n = Z n = j) ∧ ρ 3 ( j).</formula><p>We use the sets mY[ j][r] and their subsets mX[ j][r][i] to construct the strategies f 1 , . . . , f n collected for the system, where j ranges over the number of strategies, r ranges over the number of iterations of the least fixpoint at the j th strategy, and i ranges over the number of assumptions. Let mY</p><formula xml:id="formula_47">[ j][&lt;r] denote the set l∈[1..r-1] mY[ j][l]. We write (r , i ) ≺ (r, i) to denote that the pair (r , i ) is lexicographically smaller than the pair (r, i). That is, either r &lt; r or r = r and i &lt; i. Let mX[ j][≺(r, i)] denote the set (r ,i )≺(r,i) mX[ j][r ][i ].</formula><p>Transitions in ρ 1 are taken when a J s j state is reached and we change strategy from f j to f j⊕1 . The counter Z n is updated accordingly. Transitions in ρ 2 are taken when we can get closer to a J s j state. These transitions go from states in mY[ j][r] to states in mY[ j][r ] where r &lt; r. We require that r is strictly smaller than r to ensure that the phase of the play, where neither the guarantees are satisfied nor the assumptions are violated, is bounded. Note that there is no need to add transitions that start from states in mY[ j] [1] to ρ 2 ( j), because these transitions are already included in ρ 1 . The conjunct ¬mY[ j][&lt;r] appearing in ρ 2 ( j) ensures that each state is considered once in its minimal entry.</p><p>Transitions </p><formula xml:id="formula_48">∈ mX[ j][r][i]. The conjuncts ¬mX[ j][≺(r, i)] appearing in transitions ρ 3 ( j)</formula><p>ensure that each state is considered once in its minimal entry. Note that the above transition relation can be computed symbolically. We show the Jtlv code that symbolically constructs the transition relation of the synthesized fds in Fig. <ref type="figure" target="#fig_3">3</ref>. We denote the resulting controller by ctrl. The functionality of all used methods is self-explanatory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Minimizing the strategy</head><p>In the previous section, we have shown how to create an fds that implements an ltl goal ϕ. The set of variables of this fds includes the given set of input and output variables as well as the 'memory' variables Z n . This fds follows a very liberal policy when choosing the next successor in the case of a visit to J s j , i.e., it chooses an arbitrary successor in the winning set. In the following, we use this freedom to minimize (symbolically) the resulting fds. Notice, that our fds is deterministic with respect to X ∪ Y. That is, for every state and every possible assignment to the variables in X ∪ Y there exists at most one successor state with this assignment. <ref type="foot" target="#foot_4">8</ref> As X and Y and the restrictions on their possible changes are part of the specification, removing transitions seems to be of lesser importance. We concentrate on removing redundant states.</p><p>Since we are using the given sets of variables X and Y the only possible candidate states for merging are states that agree on the values of variables in X ∪ Y and disagree on the value of Z n . If we find two states s and s such that ρ(s, s ), s| X ∪Y = s | X ∪Y , and s | Z n = s| Z n ⊕1, we remove state s. We direct all its incoming arrows to s and remove its outgoing arrows. Intuitively, we can do that because the specification does not relate to the variable Z n . Consider a computation where the sequence (s 0 , s , s 1 ) appears and results from separate transitions (s 0 , s) and (s , s 1 ). Consider the case that there is no successor s 1 of s such that s 1 | X ∪Y = s 1 | X ∪Y and similarly for a predecessor s 0 of s . By s| X ∪Y = s X ∪Y we conclude that (s 0 , s ) | ρ e ∧ ρ s . Furthermore, if some J is visited in s then the same J is visited in s and the progress of Z n ensures that an infinite computation satisfies all required liveness constraints.</p><p>The symbolic implementation of the minimization is given in Fig. <ref type="figure" target="#fig_4">4</ref>. The transition obseq includes all possible assignments to V and V such that all variables except Z n maintain their values. It is enough to consider the transitions from Z n = j to Z n = j⊕1 for all j and then from Z n = n to Z n = j for all j to remove all redundant states. This is because the original transition just allows to increase Z n by one. This minimization can significantly reduce the numbers of states and so lead to smaller explicit-state representations of a program. However, it turns out that the minimization increases the size of the symbolic representation, i.e., the bdds. Depending on the application, we may want to keep the size of bdds minimal rather than minimize the fds. In the next section, we minimize the symbolic representation to reduce the size of the resulting circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Generating circuits from bdds</head><p>In this section, we describe how to construct a Boolean circuit from the strategy in Section 4.1. A strategy is a bdd over the variables X , Y, Z n , X , Y , and Z n where X are input variables, Y are output variables, Z n are the variables encoding the memory of the strategy, and the primed versions represent next state variables. The corresponding circuit contains |X | + |Y| + |Z n | flipflops to store the values of the inputs and outputs in the last clock tick as well as the extra memory needed for applying the strategy (see Fig. <ref type="figure" target="#fig_5">5</ref>). In every step, the circuit reads the next input values X and determines the next output values Y (and Z n ) using combinational logic with inputs I = X ∪ Y ∪ Z n ∪ X . Note that the strategy does not prescribe a unique combinational output for every combinational input. In most cases, multiple outputs are possible, in states that do not occur when the system adheres to the strategy, no outputs may be allowed. Both issues need to be solved before translation to a combinational circuit. That is, we have to fix exactly one possible output for every possible value of the flipflops and the inputs.</p><p>The extant solution <ref type="bibr" target="#b44">[44]</ref> yields a circuit that can generate, for a given input, any output allowed by the strategy. To this end, it uses a set of extra inputs to the combinational logic. Note that this is more general than what we need: a circuit  that always yields one valid output given an input. Our experience shows that this may come at a heavy price in terms of the size of the logic <ref type="bibr" target="#b2">[3]</ref>.</p><p>Due to these scalability problems of <ref type="bibr" target="#b44">[44]</ref>, we devised the following method to extract a combinational circuit from a bdd that matches our setting. Our method uses the pseudo code shown in Fig. <ref type="figure" target="#fig_6">6</ref>.</p><p>We write outputs and inputs to denote the set of all combinational outputs and inputs, respectively. We denote by set_minus(outputs,y) the functionality which excludes y from the set outputs. For every combinational output y we construct a function f_y in terms of X that is compatible with the given strategy bdd. The algorithm proceeds through the combinational outputs y one by one: First, we build trans_y to get a bdd that restricts only y in terms of X . Then we build the positive and negative cofactors (p,n) of trans_y with respect to y, that is, we find the sets of inputs for which y can be 1 and the sets of inputs for which y can be 0. For the inputs that occur both in the positive cofactor and in the negative cofactor, both 0 and 1 are possible values. The combinational inputs that are neither in the positive cofactor nor in the negative cofactor are outside the winning states and thus represent situations that cannot occur (as long as the environment satisfies the assumptions). Thus, f_y has to be 1 in p ∩ !n and 0 in (!p ∩ n), which give us the set of care states. We minimize the positive cofactors with the care set to obtain the function f_y. Finally, we substitute variable y in comb by f_y, and proceed with the next variable. The substitution is necessary since a combinational output may also depend on other combinational outputs.  The resulting circuit is constructed by writing the bdds for the functions using cudd's DumpBlif command <ref type="bibr" target="#b45">[45]</ref>. In the following we describe two extensions that are simple and effective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1.">Optimizing the cofactors</head><p>The algorithm presented in Fig. <ref type="figure" target="#fig_6">6</ref> generates a function in terms of the combinational inputs for every combinational output. Some outputs may not depend on all inputs and we would like to remove unnecessary inputs from the functions.</p><p>Consider the positive cofactor and the negative cofactor of a variable y. If the cofactors do not overlap when we existentially quantify variable x, then variable x is not needed to distinguish between the states where y has to be 1 and where y has to be 0. Thus, variable x can be simply left out. We adapt the algorithm in Fig. <ref type="figure" target="#fig_6">6</ref> by inserting the code shown in Fig. <ref type="figure" target="#fig_7">7</ref> at the spot marked with (*).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2.">Removing dependent variables</head><p>After computing the combinational logic, we perform dependent variables analysis <ref type="bibr" target="#b46">[46]</ref> on the set of reachable states to simplify the generated circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1. (See [46].) Given a Boolean function</head><formula xml:id="formula_49">f over v 0 , v 1 , . . . v n , a variable v i is functionally dependent in f iff ∀v i . f = 0.</formula><p>Note that if v i is functionally dependent, it is uniquely determined by the remaining variables of f . Thus, the value of v i can be replaced by a function g(v 0 , . . .</p><formula xml:id="formula_50">v i-1 , v i+1 • • • v n ).</formula><p>Suppose our generated circuit has the set R(X ∪ Y) of reachable states. If a state variable y is functionally dependent in R, we can remove the corresponding flipflop in the circuit. The value of s is instead computed as a function of the values of the other flipflops. This will reduce the number of flipflops in the generated circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">LTL Synthesis</head><p>In this section we show that the techniques developed in Sections 3 and 4 are strong enough to handle synthesis of ltl specifications in many interesting cases. In particular, the specifications of many hardware designs that we encountered as part of the Prosyd project fall into this category <ref type="bibr" target="#b47">[47]</ref>. Given a specification of a realizability problem, we show how to embed this problem into the framework of gr(1) games. We start from a simple subset of ltl (that is interesting in its own right) and show how to extend the types of specifications that can be handled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Implication of Symbolic Jds over input and output variables</head><p>We have already argued that in many practical cases the specification calls for a jds that realizes the environment and a jds that realizes the system. We suggested to embed the different parts of such specifications into a gr(1) game and defined the strict realizability of the implication of such specifications. Here we highlight the differences between strict realizability of the implication and realizability of the implication; show how to embed the implication of the specifications as a gr(1) game; and (in the following subsections) explain how to extend the fragment of ltl handled by these techniques.</p><p>Recall, that the temporal semantics of a jds D has the following form:</p><formula xml:id="formula_51">θ ∧ 1ρ ∧ J ∈J 1 E J .</formula><p>Accordingly, when assumptions or guarantees taken together give rise to a jds they can be arranged as a specification as follows. Let S α = ϕ α i , Φ α t , Φ α g be a specification, where ϕ α i is an assertion over V,</p><formula xml:id="formula_52">Φ α t = {ψ i } i∈I α t is a set of assertions over V ∪ V , and Φ α g = { J i } i∈I α g is a set of assertions over V.</formula><p>Given S e and S s of this form, we defined strict realizability in Section 3. Consider now the implication between these two specifications. Formally, let ϕ → e,s be the following formula</p><formula xml:id="formula_53">ϕ e i ∧ 1ρ e ∧ i∈I e g 1 E J e i → ϕ s i ∧ 1ρ s ∧ i∈I s g 1 E J s i , (<label>4</label></formula><formula xml:id="formula_54">)</formula><p>where ρ e = i∈I e g ψ i and ρ s = i∈I s g ψ i . Namely, ϕ → e,s says that if the environment satisfies its specification then the system guarantees to satisfy its specification. The formula ϕ → e,s seems simpler and more intuitive than ϕ sr e,s . This simplified view, however, leads to dependency between the fulfillment of the systems safety and the liveness of the environment. Thus, specifications that should intuitively be unrealizable turn out to be realizable.</p><p>Notice that ϕ sr e,s implies ϕ → e,s . Thus, if ϕ sr e,s is realizable, a controller for ϕ sr e,s is also a controller for ϕ → e,s . The following example shows that the other direction is false.</p><p>Example 1. Let X = {x} and Y = {y}, where both x and y are Boolean variables. Let S e = true, {!x}, {x ↔ y} and S s = true, {!x ↔ !y}, {¬y} . Intuitively, the environment specification says that the environment should keep x asserted and make sure that x and y are equal infinitely often. <ref type="foot" target="#foot_5">9</ref> The system specification says that the system should keep y equal to x and make sure that y is off infinitely often. Consider the two specifications ϕ → e,s and ϕ sr e,s ,</p><formula xml:id="formula_55">ϕ → e,s = 1 ! x ∧ 1 E(x ↔ y) → 1(!x ↔ !y) ∧ 1 E¬y , ϕ sr e,s = 1 1 ! x → (!x ↔ !y) ∧ 1 ! x ∧ 1 E(x ↔ y) → 1 E¬y .</formula><p>While ϕ → e,s is realizable, ϕ sr e,s is unrealizable. Indeed, in the first case, the strategy that always sets y to the inverse of x is a winning strategy. The system may violate its safety but it ensures that the environment cannot fulfill its liveness. On the other hand, ϕ sr e,s is unrealizable. Indeed, as long as the environment does not violate its safety the system has to satisfy safety. An infinite play that satisfies safety will satisfy the liveness of the environment but not of the system. We find that ϕ sr e,s better matches what we want from such a system. Indeed, if the only way for the system to satisfy its specification is by violating its safety requirement, then we would like to know that this is the case. Using ϕ sr e,s and its unrealizability surfaces this problem to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We now contrast two examples. 10</head><p>Example 2. Consider the case where X = {x} and Y = {y} but this time x ranges over {1, . . . , 10} and y ranges over {1, . . . , 5}. Let S e = x = 0, {!x &gt; x}, {true} and S s = y = 0, {!y &gt; y}, {true} . Intuitively, both the system and the environment are doomed. Both cannot keep increasing the values of x and y as both variables range over a finite domain. In this case ϕ → e,s is realizable and ϕ sr e,s is unrealizable. Dually, if x ranges over {1, . . . , 5} and y ranges over {1, . . . , 10} both ϕ → e,s and ϕ sr e,s are realizable. Again, we find that the behavior of ϕ sr e,s matches better our intuition of what it means to be realizable. Indeed, only when the environment is the first to violate its safety the specification is declared realizable.</p><p>In general, the kind of dependency that is created in the realizability of ϕ → e,s is related to machine closure of specifications <ref type="bibr" target="#b48">[48]</ref> (cf. also discussion in <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b50">50]</ref>). In general, we find that specifications that allow this kind of dependency between safety and liveness are not well structured and using strict realizability informs us of such problems.</p><p>We now turn to the question of realizability of ϕ → e,s and show how to reduce it to the solution of a gr(1) game. Intuitively, we add to the game a memory of whether the system or the environment violate their initial requirements or their safety requirements. Formally, we have the following.</p><p>Let S α = ϕ α i , Φ α t , Φ α g for α ∈ {e, s} be two specifications. The realizability game for ϕ → e,s is G → e,s : V, X , Y , θ e , θ s , ρ e , ρ s , ϕ with the following components.</p><formula xml:id="formula_56">• X = X . • Y = Y ∪ {sf e , sf s }. • V = X ∪ Y . • θ e = true. • θ s = (ϕ e i ↔ sf e ) ∧ (ϕ s i ↔ sf s ).</formula><p>• ρ e = true.</p><p>• ρ s = (( i∈I e t</p><formula xml:id="formula_57">ψ e i ∧ sf e ) ↔ sf e ) ∧ (( i∈I s t ψ s i ∧ sf s ) ↔ sf s ). • ϕ = (1 Esf e ∧ i∈I e g 1 E J e i ) → (1 Esf s ∧ i∈I s g 1 E J s i ).</formula><p>We show that the game G → e,s realizes the goal ϕ → e,s .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5. The game G →</head><p>e,s is won by system iff ϕ → s,e is realizable.</p><p>Proof. By Theorem 4 we have that G → e,s is won by system iff the following specification ψ sr is realizable</p><formula xml:id="formula_58">ψ sr = (ϕ e i ↔ sf e ) ∧ (ϕ s i ↔ sf s ) ∧ 1 i∈I e t ψ e i ∧ sf e ↔ sf e ∧ i∈I s t ψ s i ∧ sf s ↔ sf s ∧ 1 Esf e ∧ i∈I e g 1 E J e i → 1 Esf s ∧ i∈I s g 1 E J s i .</formula><p>Consider an fds that realizes ψ sr . Let σ : s 0 , s 1 , . . . be a computation of this fds. We show that σ | ϕ → e,s . If σ does not satisfy one of the conjuncts on the left-hand side of ϕ → e,s then clearly σ | ϕ → e,s . Assume that σ satisfies all the conjuncts on the left-hand side of ϕ → e,s </p><formula xml:id="formula_59">ψ s i ∧ sf s ) ↔ sf s ) we conclude that σ | 1sf s and σ | 1( i∈I s t ψ s i ).</formula><p>Finally, as σ | sf s we conclude that σ | ϕ s i . Thus, σ satisfies all the conjuncts on the right-hand side of ϕ → e,s as well.</p><p>In the other direction, consider an fds D that satisfies ϕ → e,s . We create the system D by adding to D the variables sf e and sf s and use the augmented initial condition θ = θ ∧ θ s and the augmented transition relation ρ = ρ ∧ ρ s . The addition of sf e and sf s does not restrict the behavior of D. • Suppose that σ satisfies all the conjuncts on the left-hand side of ϕ → e,s . Then, σ also satisfies all the conjuncts on the right-hand side of ϕ → e,s . It follows that σ</p><formula xml:id="formula_60">| ϕ s i implying σ | sf s . It follows that σ | 1( i∈I s t ψ s i ) implying σ | 1sf s .</formula><p>Finally, σ | 1 Esf s and ϕ holds as well. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Incorporating the past</head><p>We have discussed the case where the specification is a combination of assumptions and guarantees of the forms 1ψ and 1 E J , where ψ is a Boolean formula restricting transitions of the environment or of the system, and J is a Boolean formula. In this subsection we show how to reduce to gr(1) games the case where specifications include parts J and ψ containing past temporal formulas (or temporal patterns that can be translated to past temporal formulas). As before, one could distinguish between realizability and strict realizability. To simplify presentation we concentrate on strict realizability.</p><p>An ltl formula ϕ is a past formula if it does not use the operators ! and U . That is, it belongs to the following grammar.</p><formula xml:id="formula_61">ϕ ::= p | ¬ϕ | ϕ ∨ ϕ | !ϕ | ϕ S ϕ.</formula><p>For example, the formula ψ = (¬g) S r is a past formula. If r is a request and g is a grant, then ψ holds at time i if there is a pending request in the past that was not granted.</p><p>For every ltl formula ϕ over variables V, one can construct a temporal tester, a jds T ϕ , which has a distinguished Boolean variable x ϕ such that the following hold.</p><p>• T ϕ is complete with respect to V.</p><formula xml:id="formula_62">• For every computation σ : s 0 , s 1 , s 2 , . . . of T ϕ , s i [x ϕ ] = 1 iff σ , i | ϕ.</formula><p>• For every sequence of states σ : s 0 , s 1 , s 2 , . . . there is a corresponding computation σ : s 0 , s 1 , s 2 , . . . of T ϕ such that for every i we have s i and s i agree on the interpretation of the variables of ϕ.</p><p>For further details regarding the construction and merits of temporal testers, we refer the reader to <ref type="bibr" target="#b51">[51,</ref><ref type="bibr" target="#b52">52]</ref>. It is well known that temporal testers for past ltl formulas are fairness-free and deterministic. It follows that for every past ltl formula ϕ, there exists a fairness-free fds T ϕ : V, θ, ρ such that V contains the set of variables of ϕ and θ and ρ are deterministic.</p><p>Using these fairness-free fds we can now handle assumptions and guarantees that contain past ltl formulas.</p><p>Let X and Y be the set of input and output variables, respectively, and let V = X ∪ Y. Consider an assumption or guarantee 1ψ , where ψ is a Boolean combination of past formulas over V and expressions of the form !v, where v ∈ X if 1ψ is an assumption, and v ∈ X ∪ Y if 1ψ is a guarantee. For every maximal past temporal formula γ appearing in ψ , <ref type="foot" target="#foot_6">11</ref> there is a temporal tester T γ with the distinguished variable x γ . Consider the following specification 1 ψ , where ψ is obtained from ψ by replacing γ by x γ . It follows that the specification 1 ψ is of the required form as in Section 3. Given an assumption or guarantee 1 E J , where J is a past formula over V, we treat it in a similar way.</p><p>Here we extend the specifications described previously by incorporating referral to past in them. The specifications we consider are</p><formula xml:id="formula_63">S α = ϕ α i , Φ α t , Φ α g for α ∈ {e, s}, where Φ α t = ψ α i i∈I α t and Φ α g = J α i i∈I α j</formula><p>and ψ α i and J α i may relate to past formulas.</p><p>Given such a specifications S e and S s , let Ŝα denote the specification obtained by treating S α as explained above. Namely, replacing referral to past formulas by referral to the outputs of temporal testers. In particular, let ψα i denote the specification obtained from ψ α i by replacing maximal past formulas γ by x γ and similarly for ˆJ α i . Let T γ 1 , . . . , T γ n be the temporal testers whose variables are used in Ŝα for α ∈ {e, s}. The strict realizability game for S e and S s is G sr e,s :</p><p>V ∪ V t , X , Y ∪ V t , θ e , θ s , ρ e , ρ s , ϕ with the following components.</p><p>• V t is the set of variables of T γ 1 , . . . , T γ n that are not in V.</p><p>• θ e = ϕ e i .</p><p>• θ s = ϕ s i ∧ n i=1 θ i , where θ i is the initial condition of T γ i .</p><p>• ρ e = i∈I e t ψe i .</p><p>• ρ s = ( i∈I s t</p><formula xml:id="formula_64">ψ s i ) ∧ ( n i=1 ρ i ), where ρ i is the transition of T γ i . • ϕ = i∈I e g 1 E ˆJ e i → i∈I s g 1 E ˆJ s i .</formula><p>That is, all the variables of T γ 1 , . . . , T γ n are added as variables of the system. The initial condition of the system is extended by all the initial conditions of the temporal testers and the transition of the system is extended by the transitions of the temporal testers. Notice, that variables and transitions of temporal testers that come from assumptions as well as guarantees are added to the system side of the game. This is important as the next state of temporal testers may depend on the next state of both the inputs and the outputs.</p><p>Theorem 6. The game G sr e,s is won by system iff ϕ sr e,s is realizable.</p><p>Notice that ϕ sr e,s uses ψ α i and not ψα i , and similarly for J α i .</p><p>Proof. This follows from Theorem 4 and the correctness of the temporal testers T ψ 1 , . . . , T ψ n . The argument relies on temporal testers for past being fairness-free, deterministic, and complete with respect to X ∪ Y. 2</p><p>We note that the inclusion of the past allows us to treat many interesting formulas. For example, consider formulas of the form 1(r → Eg), where r is a request and g a guarantee. As this formula is equivalent to 1 E¬(¬g S (¬g ∧ r)), it is simple to handle using the techniques just introduced. Similarly, 1(a</p><formula xml:id="formula_65">∧ !b → ! 2 c) can be rewritten to 1(!a ∧ b → !c) and 1(a → a U b) is equivalent to 1 1 (! (a ∧ ¬b) → (a ∨ b)) ∧ 1 E(¬a ∨ b).</formula><p>In practice, many interesting future ltl formulas (that describe deterministic properties) can be rewritten into the required format.</p><p>In the next subsection we use deterministic fds to describe very expressive specifications whose realizability can be reduced to gr(1) games.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Implication of symbolic Jds</head><p>We now proceed to an even more general case of specifications, where each of the assumptions or guarantees is given as (or can be translated to) a deterministic jds. The main difference between this section and previous sections is in the inclusions of additional variables as part of the given specifications. These variables are then added to the game structure and enable a clean treatment of this kind of specifications. Notice that it is hard to impose strict realizability as there is no clean partition of specifications to safety and liveness.</p><p>Let X and Y be finite sets of typed input and output variables, respectively. In this subsection we consider the case where specifications are given as a set of complete deterministic jds. Formally, let S α = {D α i } i∈I α for α ∈ {e, s} be a pair of specifications, where</p><formula xml:id="formula_66">D α i = V α i , θ α i , ρ α i , J α</formula><p>i is a complete and deterministic jds with respect to X ∪ Y for every i and α.</p><p>The realizability game for S e and S s is G d e,s : V, X , Y , true, θ s , true, ρ s , ϕ with the following components.</p><formula xml:id="formula_67">• V = X ∪ Y ∪ ( i∈I e V e i ) ∪ ( i∈I s V s i ). • X = X . • Y = Y ∪ ( i∈I e V e i ) ∪ ( i∈I s V s i ). • θ s = ( i∈I e θ e i ) ∧ ( i∈I s θ s i ).</formula><p>• ρ s = ( i∈I e ρ e i ) ∧ ( i∈I s ρ s i ).</p><formula xml:id="formula_68">• ϕ = ( i∈I e ( J ∈J e i 1 E J )) → ( i∈I s ( J ∈J s i 1 E J )).</formula><p>We show that the game G d e,s realizes the goal of implication between these sets of deterministic jds. Let We say that σ | ϕ d e,s if either (i) there exists an i ∈ I e such that there is no computation of D i that agrees with σ on the variables in X ∪ Y or (ii) for every i ∈ I s there is a computation of D i that agrees with σ on the variables in X ∪ Y. The specification ϕ d e,s is realizable if there exists an fds that is complete with respect to X that implements this specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 7. The game G d</head><p>e,s is won by system iff ϕ d e,s is realizable.</p><p>Proof. By Theorem 4 we have that G d e,s is won by system iff the following specification ψ sr is realizable.</p><formula xml:id="formula_69">ψ sr = i∈I e θ e i ∧ i∈I s θ s i ∧ 1 i∈I e ρ e i ∧ i∈I s ρ s i ∧ i∈I e J ∈J e i 1 E J → i∈I s J ∈J s i 1 E J .</formula><p>Consider an fds that realizes ψ sr . Let σ : s 0 , s 1 , . . . be a computation of this fds. Let τ : t 0 , t 1 , . . . be the computation over X ∪ Y such that for every j 0 we have s j | X ∪Y = t j . We show that σ | ϕ d e,s . Consider an fds D i . As D i is deterministic the assignment to the variables in V i in σ is the unique assignment that is possible to accompany τ . It follows that τ</p><formula xml:id="formula_70">| D i iff the σ | J ∈J i 1 E J . It follows that σ | ϕ d e,s .</formula><p>In the other direction, consider an fds D that satisfies ϕ d e,s . From determinism and completeness of D i for every i it follows that D also satisfies ψ sr . 2</p><p>To summarize, we have presented three possible fragments of specifications and their translation to gr(1) games. In general, when one is presented with specifications in ltl or psl, a combination of the approaches in the previous sections should be taken. Simple specifications of the form 1ψ or 1 E J , where ψ or J are either Boolean formulas or past formulas, should be treated by adding them to the game as explained previously. More complicated specifications should be translated to deterministic jds and treated by inclusion of the additional variables in this jds as part of the game. In a sense, the treatment of past formulas and of deterministic jds is very similar in that it requires the inclusion of additional variables (except the input and the output) in the structure of the game.</p><p>For some specifications, it may be impossible to translate them to deterministic jds. We find that these specifications are not very common. Generalizations of our techniques as presented, e.g., in <ref type="bibr" target="#b23">[23]</ref> might be applicable. Otherwise, techniques that handle general ltl formulas may be required <ref type="bibr" target="#b53">[53,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b24">24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">AMBA AHB case study</head><p>We demonstrate the application of the synthesis method by shortly summarizing a case study that we performed on one of the amba (Advanced Microcontroller Bus Architecture) <ref type="bibr" target="#b21">[21]</ref> buses of arm. More details about this case study can be found in <ref type="bibr" target="#b1">[2]</ref>. In order to obtain further insights on the applicability and performance of the method, we refer the interested reader to a second case study <ref type="bibr" target="#b2">[3]</ref> based on a tutorial design from ibm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Protocol</head><p>Arm's Advanced Microcontroller Bus Architecture (amba) <ref type="bibr" target="#b21">[21]</ref> defines the Advanced High-Performance Bus (ahb), an on-chip communication standard connecting such devices as processor cores, cache memory, and dma controllers. Up to 16 masters and up to 16 slaves can be connected to the bus. The masters initiate communication (read or write) with a slave of their choice. Slaves are passive and can only respond to a request. Master 0 is the default master and is selected whenever there are no requests for the bus.</p><p>The ahb is a pipelined bus. This means that different masters can be in different stages of communication. At one instant, multiple masters can request the bus, while another master transfers address information, and a yet another master transfers data. A bus access can be a single transfer or a burst, which consists of a specified or unspecified number of transfers. Access to the bus is controlled by the arbiter, which is the subject of this section. All devices that are connected to the bus are Moore machines, that is, the reaction of a device to an action at time t can only be seen by the other devices at time t + 1.</p><p>The amba standard leaves many aspects of the bus unspecified. The protocol is at a logic level, which means that timing and electric parameters are not specified; neither are aspects such as the arbitration protocol.</p><p>We will now introduce the signals used in the ahb. The notation S[n:0] denotes an (n + 1)-bit signal.</p><p>• HBUSREQ[i] -A request from master i to access the bus. Driven by the masters.</p><p>• HLOCK[i] -A request from master i to receive a locked (uninterruptible) access to the bus (raised in combination with HBUSREQ[i]). Driven by the masters.</p><p>• HMASTER[3:0] -The master that currently owns the address bus (binary encoding). Driven by the arbiter.</p><p>• HREADY -High if the slave has finished processing the current data. Change of bus ownership and commencement of transfers only takes place when HREADY is high. Driven by the slave.</p><p>• HGRANT[i] -Signals that if HREADY is high, HMASTER = i will hold in the next tick. Driven by the arbiter.</p><p>• HMASTLOCK -Indicates that the current master is performing a locked access. If this signal is low, a burst access may be interrupted when the bus is assigned to a different master. Driven by the arbiter</p><p>The following set of signals is multiplexed using HMASTER as the control signal. For instance, although every master has an address bus, only the address provided by the currently active master is visible on HADDR.</p><p>• HADDR[31:0] -The address for the next transfer. The address determines the destination slave.</p><p>• HBURST[1:0] -One of SINGLE (a single transfer), BURST4 (a four-transfer burst access), or INCR (unspecified length burst).</p><p>The list of signals does not contain the data transfer signals as these do not concern the arbiter (ownership of the data bus follows ownership of the address bus in a straightforward manner). Bursts of length 8 or 16 are not taken into account, nor are the different addressing types for bursts. Adding longer bursts only lengthens the specification and the addressing types do not concern the arbiter. Furthermore, as an optional feature of the ahb, a slave is allowed to "split" a burst access and request that it be continued later. We have left this feature out for simplicity, but it can be handled by our approach.</p><p>A typical set of accesses is shown in Fig. <ref type="figure" target="#fig_10">8</ref> Signals DECIDE, START, and LOCKED should be ignored for now. At time 1, masters 1 and 2 request an access. Master 1 requests a locked transfer. The access is granted to master 1 at the next time step, and master 1 starts its access at time 3. Note that HMASTER changes and HMASTLOCK goes up. The access is a BURST4 that cannot be interrupted. At time 6, when the last transfer in the burst starts, the arbiter prepares to hand over the bus to master 2 by changing the grant signals. However, HREADY is low, so the last transfer is extended and the bus is only handed over in time step 8, after HREADY has become high again. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Formal specification</head><p>This section contains the specification of the arbiter. To simplify the specification, we have added three auxiliary variables, START, LOCKED, and DECIDE, which are driven by the arbiter. Signal START indicates the start of an access. The master only switches when START is high. The signal LOCKED indicates if the bus will be locked at the next start of an access. Signal DECIDE is described below.</p><p>We group the properties into three sets. The first set of properties defines when a new access is allowed to start, the second describes how the bus has to be handed over, and the third describes which decisions the arbiter makes.</p><p>All properties are stated using ltl formulas. Some properties are assumptions on the environment, the others are guarantees the system has to satisfy. As explained in Section 5, not all ltl specifications can be synthesized directly using gr(1) games. In order to apply the presented synthesis approach, we aim for a specification that can be expressed using Eq. ( <ref type="formula" target="#formula_53">4</ref>) in Section 5. The separation of the properties into assumptions and guarantees facilitates this translation: the conjunction of all formulas used to describe assumptions form the premiss (left part) of the implication in Eq. ( <ref type="formula" target="#formula_53">4</ref>). Formulas describing guarantees form to the consequent (right part). Now, we only need to ensure that every formula that we use can be mapped into one of the parts of Eq. ( <ref type="formula" target="#formula_53">4</ref>), i.e., into (1) ϕ x i , (2) 1ρ x , or (3) i∈I x g 1 E J x i with x = {e, s}. (Recall that ϕ x i and J x i are Boolean formulas over the variables, and ρ x is a Boolean formula over the variables potentially prefixed with the next operator !.) Furthermore, note that 1ϕ 1 ∧ 1ϕ 2 = 1(ϕ 1 ∧ ϕ 2 ) for arbitrary ϕ 1 and ϕ 2 . Therefore, we can write Part (2) also as conjunction of formulas starting with the always operator 1.</p><p>Most formulas we use to describe the desired properties of the arbiter are already in the required format. For the properties (Assumption 1, Guarantees 2 and 3) that are initially not in the right format, we give a corresponding translation.  As explained in Section 5.2, for every past ltl formula, there exists a corresponding fairness-free<ref type="foot" target="#foot_7">12</ref> fds. Fig. <ref type="figure">9</ref>(b) shows an automaton that encodes Guarantee (G2.1) and corresponds to the fds that is given by the formulas (G2.2), (G2.3), and (G2.4) referring to the new Boolean variable t. t = 0, (G2.2)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1.">Starting an access</head><formula xml:id="formula_71">1 t = 0 ∧ ¬(HMASTLOCK ∧ HBURST = INCR ∧ START) → !(t = 0) ∧ 1 t = 0 ∧ HMASTLOCK ∧ HBURST = INCR ∧ START → !(t = 1) ∧ 1 t = 1 ∧ ¬START ∧ ¬BUSREQ → !(t = 0) ∧ 1 t = 1 ∧ ¬START ∧ BUSREQ → !(t = 1) ∧ 1 t = 1 ∧ START → !(t = 2) 1 t = 2 → !(t = 2) , (G2.3)</formula><p>1 E(t = 0 ∨ t = 1).</p><p>(G2.4) Guarantee 3. When a length-four locked burst starts, no other accesses start until the end of the burst. We can only transfer data when HREADY is high, so the current burst ends at the fourth occurrence of HREADY (in the formula, we treat the cases where HREADY is true initially separately from the case in which it is not).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">(HMASTLOCK ∧</head><formula xml:id="formula_72">HBURST = BURST4 ∧ START ∧ HREADY) → ! ¬START W [3](¬START ∧ HREADY) , (G3.1) 1 (HMASTLOCK ∧ HBURST = BURST4 ∧ START ∧ ¬HREADY) → ! ¬START W [4](¬START ∧ HREADY) . (G3.2)</formula><p>In order to express Guarantee (G3.1) and (G3.2) in the right format, we translate them into a deterministic fds in the same way as for Guarantee (G2.1). Fig. <ref type="figure" target="#fig_12">10</ref> shows the automaton this fds encoding. We use a new variable u, ranging over {0, 1, 2, 3, 4, 5}, and three formulas (G3.3), (G3.4), and (G3.5) to encode the initial, transition, and final condition of the corresponding fds, respectively. Since the encoding is done in the same way as the encoding for Assumption (A1.2) and Guarantee (G2.1), we omit the detailed descriptions of (G3.3), (G3.4), and (G3.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2.">Granting the bus</head><p>Guarantee 4. The HMASTER signal follows the grants: When HREADY is high, HMASTER is set to the master that is currently granted. This implies that no two grants may be high simultaneously and that the arbiter cannot change HMASTER without giving a grant. (G4) Guarantee 5. Whenever HREADY is high, the signal HMASTLOCK copies the signal LOCKED.</p><p>1 HREADY → LOCKED ↔ !(HMASTLOCK) .</p><p>(G5) Guarantee 6. If we do not start an access in the next time step, the bus is not reassigned and HMASTLOCK does not change.</p><p>For each master i, 1 !(¬START) → HMASTER = i ↔ !(HMASTER = i) ∧ HMASTLOCK ↔ !(HMASTLOCK) .</p><p>(G6)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3.">Deciding the next access</head><p>Signal DECIDE indicates the time slot in which the arbiter decides who the next master will be, and whether its access will be locked. The decision is based on HBUSREQ[i] and HLOCK[i]. For instance, DECIDE is high in Step 1 and 6 in Fig. <ref type="figure" target="#fig_10">8</ref>. Note that a decision is executed at the next START signal, which can occur at the earliest two time steps after the HBUSREQ[i] and HLOCK[i] signals are read. See Fig. <ref type="figure" target="#fig_10">8</ref>, the signals are read in Step 1 and the corresponding access starts at Step 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Guarantee 7.</head><p>When the arbiter decides to grant the bus, it uses LOCKED to remember whether a locked access was requested.  </p><formula xml:id="formula_73">1 ¬DECIDE → i HGRANT[i] ↔ !(HGRANT[i]) ∧ 1 ¬DECIDE → LOCKED ↔ !(LOCKED) . (G8) Guarantee 9.</formula><p>We have a fair bus. Note that this is not required by the amba standard, and there are valid alternatives, such as a fixed-priority scheme (without this property, there is no need for the arbiter to serve any master at all).</p><formula xml:id="formula_74">i 1 E ¬HBUSREQ[i] ∨ HMASTER = i . (G9)</formula><p>Guarantee 10. We do not grant the bus without a request, except to master 0. If there are no requests, the bus is granted to master 0. (A4)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Synthesis</head><p>The final specification in the right form is an implication ϕ e → ϕ s , where ϕ e is the conjunction of all the formulas referring to assumptions and ϕ s is the conjunction of all the formulas referring to guarantees. In the following we use the equation numbers to abbreviate for the corresponding formulas. ϕ e = (A1.1) ∧ (A1.3) ∧ ( A1.4) ∧ (A1.5) ∧ (A2) ∧ (A3) ∧ (A4), ϕ s = (G1) ∧ (G2.2) ∧ ( G2.3) ∧ (G2.4) ∧ (G3.3) ∧ (G3.4) ∧ (G3.5) ∧ (G4) ∧ (G5) ∧ ( G6) ∧ (G7) ∧ (G8) ∧ (G9) ∧ (G10.1) ∧ ( G10.2) ∧ (G11). Given a specification in the right form, we synthesize a strategy and construct a circuit as described in Section 4.3. Subsequently, the circuit is optimized and mapped to standard cells using abc <ref type="bibr" target="#b54">[54]</ref>.</p><p>We note that using an extra variable (BUSREQ) for Assumption 1 afforded a considerable increase in capacity of the technique. The time for synthesis is shown in Fig. <ref type="figure" target="#fig_17">11</ref>(a) and ranges from a few seconds for 2 masters to about 1.5 h for 10 masters and 21 h for 12 masters. Computing the set of winning states, which allows us to decide if the specification is realizable, takes only a small fraction of the total time. Most of the time is spent in constructing the winning strategy. A more precise analysis showed that our tool spends most of this time reordering bdds to keep them small. We do not know why synthesis for ten masters is faster than for nine.</p><p>In Fig. <ref type="figure" target="#fig_17">11</ref>(b), we show the areas of the arbiter as a function of the number of masters using our algorithm compared with a manual implementation. For one master the manual and the automatically generated implementation have approximately the same size. The automatically generated implementations grow rapidly with the number of masters, while the manual implementations are nearly independent of the number of masters. The automatically generated implementation for ten master is about a hundred times larger than the manual implementation. We do not know why size of arbiter for nine masters is smaller than for eight.</p><p>The automatically generated arbiter implements a round-robin arbitration scheme. This can be explained from the construction of the strategy in the synthesis algorithm, but it is also the simplest implementation of a fair arbiter. We have validated our specification by combining the resulting arbiter with manually written masters and clients, with which it cooperates without problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Discussion and conclusions</head><p>In this section we discuss the most important benefits and drawbacks of automatic synthesis, as we perceive them, and we discuss extensions of the approach presented here.</p><p>Writing a complete formal specification for the amba arbiter was not trivial. Many aspects of the arbiter are not defined in arm's standard. Such ambiguities would lead to long discussions on how someone implementing a bus device could read the standard, and which behavior the arbiter should allow. Note that the same problem occurs when writing a verilog implementation for the arbiter.</p><p>Second, it was not trivial to translate the informal specification to formulas. One of the important insights when writing the specification of the arbiter was that additional signals were needed. This problem also occurs when we attempt to formally verify a manually coded arbiter, in which case the same signals are useful. In fact, these signals occur, in one form or other, in our manual implementation as well.</p><p>The effort for and the size of a manual implementation of the amba arbiter does not depend much on the number of senders. The same is not true for automatic synthesis: the time to synthesize the arbiter grows quickly with the number of masters as does the size of the generated circuit. Moreover, the size of the system depends strongly on the formulation of the specification. Godhal, Chatterjee, and Henzinger present a formulation of the ahb specification that can be synthesized more efficiently than ours, and present recommendation for writing specifications for synthesis <ref type="bibr" target="#b55">[55]</ref>.</p><p>The gate-level output that our tool produces is complicated and cannot be easily modified manually. The resulting circuit can likely be improved further by using more intelligent methods to generate the circuits, which is an important area for future research. The problem is related to synthesis of partially specified functions <ref type="bibr" target="#b56">[56]</ref> with the important characteristic that the space of allowed functions is very large.</p><p>On the upside, the resulting specification is short, readable, and easy to modify, much more so than a manual implementation in verilog. There is anecdotal evidence that the specification in the form given in this paper can easily be understood by people with no experience in formal methods: The arm helpdesk very quickly found some errors in the specification in a preliminary version of this paper. 13 For the arbiter, we expect that it is easier to learn the way the design functions from the formal specification than from a manual verilog implementation. The synthesis algorithm was also a great tool to get the specifications to be consistent and complete. We doubt whether we would have gotten to a complete and consistent specification without it.</p><p>Automatic synthesis is first and foremost applicable to control circuitry. We are looking into methods to beneficially combine manually coded data paths with automatically synthesized control circuitry.</p><p>Although this approach removes the need for verification of the resulting circuit, the specification itself still needs to be validated. This is not quite trivial, as the specification is not executable. In our experience, mistakes in the specification are immediately apparent: either the specification becomes unrealizable, or the resulting system behaves nonsensically. Finding the cause, however, is not at all easy. Debugging of specifications has been addressed in <ref type="bibr" target="#b57">[57]</ref>. In <ref type="bibr" target="#b58">[58]</ref> and <ref type="bibr" target="#b43">[43]</ref>, methods were developed to extract a core from an unrealizable (or incorrect) specification and to extract a compact explanation of unrealizability. Chatterjee, Henzinger, and Jobstmann consider the modification of unrealizable specifications by making the environment assumptions (minimally) stricter <ref type="bibr" target="#b59">[59]</ref>.</p><p>A need for quantitative specifications to state that an event should happen "as soon as possible," "as infrequently" as possible, etc. was identified in <ref type="bibr" target="#b60">[60]</ref>, but requires a more expensive synthesis algorithm.</p><p>The algorithm presented in this paper has the disadvantage that the resulting system can behave arbitrarily as soon as the environment assumptions are violated. In <ref type="bibr" target="#b61">[61,</ref><ref type="bibr" target="#b42">42]</ref>, we developed algorithms that synthesize systems that behave "reasonably" in the presence of environment failures.</p><p>The algorithm presented here generates synchronous systems. Pnueli and Klein <ref type="bibr" target="#b62">[62]</ref> show an incomplete algorithm to reduce asynchronous synthesis <ref type="bibr" target="#b63">[63]</ref> of gr <ref type="bibr" target="#b0">(1)</ref> properties to the problem of synchronous gr(1) synthesis, making the algorithm presented here applicable to that domain as well.</p><p>The work described in this paper has given rise to several implementations. The algorithm is implemented as part of tlv <ref type="bibr" target="#b64">[64]</ref> and Jtlv <ref type="bibr" target="#b40">[40]</ref>, as a stand-alone tool called Anzu <ref type="bibr" target="#b3">[4]</ref>, as a realizability checker in the requirements analysis tool rat <ref type="bibr" target="#b65">[65]</ref> and in the synthesis tool ratsy <ref type="bibr" target="#b66">[66]</ref>. Ratsy in particular allows for graphical input of the specification automata and contains the debugging algorithm described above.</p><p>Finally, our algorithm and its implementation have been used also for applications in robotics and user programming. Kress-Gazit, Conner, et al. use our algorithm to produce robot controllers <ref type="bibr" target="#b67">[67,</ref><ref type="bibr" target="#b68">68]</ref>. They combine the discrete controller with continuous control and achieve, for example, controllers for cars that autonomously search for parking. Further, they start exploring domain-specific languages for synthesis of robot controllers <ref type="bibr" target="#b69">[69]</ref>. Similar applications are considered in <ref type="bibr" target="#b70">[70]</ref><ref type="bibr" target="#b71">[71]</ref><ref type="bibr" target="#b72">[72]</ref>, where additional effort is exerted to analyze huge state spaces. In the context of user programming our algorithm is used to produce programs from live sequence charts <ref type="bibr" target="#b73">[73,</ref><ref type="bibr" target="#b74">74]</ref>, and to develop AspectLTL -an aspect-oriented programming language for LTL specifications <ref type="bibr" target="#b75">[75]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>defines a symbolic algorithm for computing [[ϕ]] [35] (i.e., an algorithm that manipulates sets of states rather than individual states). For a μ-calculus formula of alternation depth k, this symbolic algorithm requires the computation of at most O (|Σ| k+1 ) symbolic next step operations. By saving intermediate results of the symbolic computation it is possible to reduce the number of symbolic next step operations of the symbolic algorithm to O (|Σ| k+1 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Jtlv implementation of Eq. (3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. The transitions definition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. The symbolic construction of the fds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. The symbolic algorithm of the minimization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Diagram of generated circuit.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Algorithm to construct a circuit from a bdd.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Extension to algorithm in Fig. 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Furthermore, the values of sf s and sf e are determined according to the values of other variables of D. Consider a computation σ : s 0 , s 1 , . . . of the augmented system D. By definition of D we have σ | θ s and σ | 1((1 ρ e ) → ρ S ). We have to show σ | ϕ . As σ is also a computation of D we have σ | ϕ → e,s . • Suppose that σ | ϕ e i . Then, σ | 1¬sf e and σ | ϕ . • Suppose that σ | ϕ e i and σ | 1 i∈I e t ψ e i . Then, σ | E 1¬sf e and σ | ϕ . • Suppose that σ | ϕ e i ∧ 1 i∈I e t ψ e i , and that σ | i∈I e g 1 E J e i . Then, σ | ϕ as the left-hand side of the implication does not hold.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. An example of amba bus behavior.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Assumption 1 .</head><label>1</label><figDesc>During a locked unspecified length burst, leaving HBUSREQ[i] high locks the bus. This is forbidden by the standard.1 (HMASTLOCK ∧ HBURST = INCR) → ! E¬HBUSREQ[HMASTER] .The expression HBUSREQ[HMASTER] is not part of the ltl syntax. The formula can be replaced by adding for every master i, the formula1((HMASTLOCK∧ HBURST = INCR ∧ HMASTER=i) → ! E¬HBUSREQ[i]). Alternative, we can introduce a new variable (e.g., BUSREQ) and add the following two formulas:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 10 .</head><label>10</label><figDesc>Fig.10. Automaton encoding Guarantee (G3.1) and (G3.2). We use burst, start, and rdy to abbreviate HMASTLOCK∧HBURST = BURST4, START, and HREADY, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>i 1 HREADY</head><label>1</label><figDesc>→ HGRANT[i] ↔ !(HMASTER = i) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>i 1 DECIDE</head><label>1</label><figDesc>∧ !(HGRANT[i]) → HLOCK[i] ↔ !(LOCKED) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Guarantee 8 .</head><label>8</label><figDesc>We do not change the grant or locked signals if DECIDE is low.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Guarantee 11 .Assumption 4 .</head><label>114</label><figDesc>An access by master 0 starts in the first clock tick and simultaneously, a decision is taken. Thus, the signals DECIDE, START, and HGRANT[0] are high and all others are low. DECIDE ∧ START ∧ HGRANT[0] ∧ HMASTER = 0 ∧ ¬HMASTLOCK ∧ We assume that all input signals are low initially. i ¬HBUSREQ[i] ∧ ¬HLOCK[i] ∧ ¬HREADY.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Synthesis of amba arbiter results.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The transition relation ρ s identifies a valuation s Y ∈ Σ Y as a possible output in state s reading input s X if (s, s X , s Y ) | ρ s .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>. As σ | ϕ e i it follows that σ | sf e . As σ | 1( i∈I e</figDesc><table><row><cell>i∈I e g 1 E J e</cell></row><row><cell>i∈I s g 1 E J s</cell></row></table><note><p>t ψ e i ) it follows that σ | 1sf e . As σ | i and clearly σ | 1 Esf e if follows that σ | 1 Esf s and σ | i . As there are infinitely many positions where sf s holds, by using 1(( i∈I s t</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The source of the name reactivity and the rank follow from the definitions of the temporal hierarchy in<ref type="bibr" target="#b16">[17]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>As all the variables of fdss are Boolean, this definition calls for realizability by a finite state system. It is well known that for ltl specifications realizability and realizability by finite state systems are the same.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>This does not suggest a canonical translation from vector formulas to plain formulas. The same translation works for the formula in Eq. (3) below. Note that the formula in Eq. (2) and the formula in Eq. (3) have a very similar structure.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>We note that in the previous versions<ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b0">1]</ref> the analysis of complexity was not accurate and in particular higher than stated above. This led to some confusion in the exact complexity of solving gr(1) games. In particular, in<ref type="bibr" target="#b42">[42]</ref> an enumerative algorithm for gr(1) games is suggested whose complexity is higher than the complexity stated above. It is, however, better than the stated complexity in previous publications.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>On the other hand, the fds may be non-deterministic with respect to X . That is, for a given state s and a given assignment s X to X , there may be multiple s Y such that (s, s X , s Y ) satisfies the transition of D.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_5"><p>This example and the observation that the implication between strict realizability and realizability is only one way is due to M. Roveri, R. Bloem, B. Jobstmann, A. Tchaltsev, and A. Cimatti.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_6"><p>Subformula γ is a maximal past formula in ψ if every subformula γ of ψ that contains γ includes the operator !.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_7"><p>Note that if we remove the state t = 2, which has an empty language, from the automaton shown in Fig.9(b), then the automaton is fairness-free. However, in order to ensure that the semantics of realizability and strict realizability are the same for our specification (cf. Section 5.1) we give the translation for the complete automaton with fairness.</p></note>
		</body>
		<back>

			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>✩ This work was supported by the European Commission under contracts 507219 (PROSYD), 217069 (COCONUT), and 248613 (DIAMOND). ✩✩ This paper is based on the following papers: <ref type="bibr" target="#b0">Piterman et al. (2006)</ref>  <ref type="bibr" target="#b0">[1]</ref> and Bloem et al. (2007)   <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We chose the latter option, since it made the synthesis computation more efficient.</p><p>Assumption (A1.1) is in the right format. We translated Assumption (A1.2) into a deterministic fds encoding the automaton shown in Fig. <ref type="figure">9</ref>(a), i.e., we replace Assumption (A1.2) by the three formulas (A1.3), (A1.4), and (A1.5) referring to a new variable s ranging over {0, 1, 2}. (See Section 5.3 for references on how to obtain this fds.) s = 0, (A1.3)</p><p>(A1.5)</p><p>Assumption 2. Leaving HREADY low locks the bus, the standard forbids it.</p><p>1 EHREADY.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(A2)</head><p>Assumption 3. The lock signal is asserted by a master at the same time as the bus request signal. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">(HMASTLOCK</head><p>We treat the expression HBUSREQ[HMASTER] in the same way as in Assumption 1, i.e., we use the variable BUSREQ introduced previously and obtain the following formula. (G2.1)</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sa'ar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Synthesis of reactive(1) designs, in: Proc. of the 7th Int. Conf. on Verification, Model Checking, and Abstract Interpretation</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3855</biblScope>
			<biblScope unit="page" from="364" to="380" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automatic hardware synthesis from specifications: A case study</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Galler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weiglhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design Automation and Test in Europe</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1188" to="1193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Galler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weiglhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Specify, compile, run: Hardware from PSL, in: 6th Int. Workshop on Compiler Optimization Meets Compiler Verification</title>
		<title level="s">Electron. Notes Theor. Comput. Sci.</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">190</biblScope>
			<biblScope unit="page" from="3" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Anzu: A tool for property synthesis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Galler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weiglhofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 19th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4590</biblScope>
			<biblScope unit="page" from="258" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Logic, arithmetic and automata</title>
		<author>
			<persName><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint>
			<date type="published" when="1962">1962. 1963</date>
			<biblScope unit="page" from="23" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Solving sequential conditions by finite-state strategies</title>
		<author>
			<persName><forename type="first">J</forename><surname>Büchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Landweber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Amer. Math. Soc</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="295" to="311" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automata on Infinite Objects and Churc&apos;s Problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">CBMS Reg. Conf. Ser. Math.</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<date type="published" when="1972">1972</date>
			<publisher>Amer. Math. Soc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the synthesis of an asynchronous reactive module</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 16th Int</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 16th Int</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">372</biblScope>
			<biblScope unit="page" from="652" to="671" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Design and synthesis of synchronization skeletons using branching time temporal logic</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IBM Workshop on Logics of Programs</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>IBM Workshop on Logics of Programs</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">131</biblScope>
			<biblScope unit="page" from="52" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Synthesis of communicating processes from temporal logic specifications</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Prog. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="68" to="93" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Modular synthesis of reactive systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
		<respStmt>
			<orgName>Weizmann Institute of</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Symbolic synthesis of finite-state controllers for request-response specifications</title>
		<author>
			<persName><forename type="first">N</forename><surname>Wallmeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hütten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on the Implementation and Application of Automata</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>the International Conference on the Implementation and Application of Automata</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2759</biblScope>
			<biblScope unit="page" from="11" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Deterministic generators and games for LTL fragments</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">L</forename><surname>Torre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Log</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="25" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A new algorithm for strategy synthesis in LTL games, in: Tools and Algorithms for the Construction and the Analysis of Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Harding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schobbens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<imprint>
			<biblScope unit="volume">3440</biblScope>
			<biblScope unit="page" from="477" to="492" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Program repair as a game</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Griesmayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 17th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 17th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3576</biblScope>
			<biblScope unit="page" from="226" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Controller synthesis for timed automata</title>
		<author>
			<persName><forename type="first">E</forename><surname>Asarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Maler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFAC Symposium on System Structure and Control</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="469" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A hierarchy of temporal properties</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th ACM Symp. Princ. of Dist. Comp</title>
		<meeting>9th ACM Symp. Princ. of Dist. Comp</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="377" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">We take this opportunity to acknowledge the help of Margaret Rugira, Chris Styles, and Colin Campbell at the arm helpdesk</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Bridging the gap between fair simulation and trace inclusion</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kesten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">200</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="36" to="61" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An algorithm for strongly connected component analysis in n log n symbolic steps</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">N</forename><surname>Gabow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods Syst. Des</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="56" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logics Models Concurrent Syst</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="123" to="144" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
	<note>transition from global to modular temporal reasoning about programs</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Ltd</surname></persName>
		</author>
		<title level="m">AMBA specification (rev. 2), available from www.arm.com</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimizations for LTL synthesis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th Int. Conf. on Formal Methods in Computer-Aided Design</title>
		<meeting>of the 6th Int. Conf. on Formal Methods in Computer-Aided Design</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="117" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A hybrid algorithm for LTL games</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sohail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ravi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Int. Conf. on Verification, Model Checking, and Abstract Interpretation</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 9th Int. Conf. on Verification, Model Checking, and Abstract Interpretation</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4905</biblScope>
			<biblScope unit="page" from="309" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Safety first: A two-stage algorithm for LTL games</title>
		<author>
			<persName><forename type="first">S</forename><surname>Sohail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Int. Conf. on Formal Methods in Computer-Aided Design</title>
		<meeting>of the 9th Int. Conf. on Formal Methods in Computer-Aided Design</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="77" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Solving games without determinization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th Annual Conf. of the European Association for Computer Science Logic</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 15th Annual Conf. of the European Association for Computer Science Logic</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4207</biblScope>
			<biblScope unit="page" from="394" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Symbolic controller synthesis for LTL specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Morgenstern</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>Universität Kaiserslautern</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Safraless decision procedures</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 46th IEEE Symp. on Foundations of Computer Science</title>
		<meeting>of the 46th IEEE Symp. on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="531" to="542" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Safraless compositional synthesis</title>
		<author>
			<persName><forename type="first">O</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 18th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4144</biblScope>
			<biblScope unit="page" from="31" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Automated Technology for Verification and Analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schewe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="474" to="488" />
		</imprint>
	</monogr>
	<note>Bounded synthesis</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An antichain algorithm for ltl realizability</title>
		<author>
			<persName><forename type="first">E</forename><surname>Filiot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Raskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 21st Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="263" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">A Practical Introduction to PSL</title>
		<author>
			<persName><forename type="first">C</forename><surname>Eisner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fisman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Verification by augmented finitary abstraction</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kesten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. and Comput</title>
		<imprint>
			<biblScope unit="volume">163</biblScope>
			<biblScope unit="page" from="203" to="243" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Distributed reactive systems are hard to synthesize</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 31st IEEE Symp. Found. of Comp. Sci</title>
		<meeting>of the 31st IEEE Symp. Found. of Comp. Sci</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="746" to="757" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Results on the propositional μ-calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="333" to="354" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Efficient model-checking in fragments of the propositional modal μ-calculus</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1st IEEE Symp. Logic in Comp. Sci</title>
		<meeting>of the 1st IEEE Symp. Logic in Comp. Sci</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="267" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">An improved algorithm for the evaluation of fixpoint expressions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Marrero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 6th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 6th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">818</biblScope>
			<biblScope unit="page" from="338" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Small progress measures for solving parity games</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jurdzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 17th Symp. on Theoretical Aspects of Computer Science</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 17th Symp. on Theoretical Aspects of Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1770</biblScope>
			<biblScope unit="page" from="290" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">E</forename><surname>Emerson</surname></persName>
		</author>
		<title level="m">Descriptive Complexity and Finite Models</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Kolaitis</surname></persName>
		</editor>
		<imprint>
			<publisher>American Mathematical Society</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="185" to="214" />
		</imprint>
	</monogr>
	<note>Model checking and the μ-calculus</note>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Decidability, completeness, and extensions of linear time temporal logic</title>
		<author>
			<persName><forename type="first">O</forename><surname>Lichtenstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
		<respStmt>
			<orgName>Weizmann Institute of Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">JTLV: A framework for developing verification algorithms</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sa'ar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Zuck</surname></persName>
		</author>
		<ptr target="http://jtlv.ysaar.net/" />
	</analytic>
	<monogr>
		<title level="m">Proc. of the 22nd Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 22nd Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6174</biblScope>
			<biblScope unit="page" from="171" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Minimizing generalized Büchi automata</title>
		<author>
			<persName><forename type="first">S</forename><surname>Juvekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Piterman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 18th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 18th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4144</biblScope>
			<biblScope unit="page" from="45" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Robustness in the presence of liveness</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Greimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 22nd Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 22nd Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6174</biblScope>
			<biblScope unit="page" from="410" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Debugging formal specifications using simple counterstrategies</title>
		<author>
			<persName><forename type="first">R</forename><surname>Koenighofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hofferek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Int. Conf. on Formal Methods in Computer-Aided Design</title>
		<meeting>of the 9th Int. Conf. on Formal Methods in Computer-Aided Design</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="152" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Building circuits from relations</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Kukula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Shiple</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 12th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1855</biblScope>
			<biblScope unit="page" from="113" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">CUDD: CU Decision Diagram package</title>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
		<ptr target="ftp://vlsi.colorado.edu/pub/" />
		<imprint/>
		<respStmt>
			<orgName>University of Colorado at Boulder</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Reducing BDD size by exploiting functional dependencies</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Design Automation Conference</title>
		<meeting>of the Design Automation Conference<address><addrLine>Dallas, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="266" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<ptr target="http://www.prosyd.org/,EUgrant507219" />
		<title level="m">Prosyd -Property-Based System Design</title>
		<imprint>
			<date type="published" when="2004">2004-2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The existence of refinement mappings</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="253" to="284" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Safety and liveness from a methodological point of view</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dederichs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="30" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Preserving liveness: Comments on &quot;safety and liveness from a methodological point of view</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Alpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Francez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="141" to="142" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Algorithmic verification of linear temporal logic specifications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kesten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Raviv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25th Int</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 25th Int</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1443</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">On the merits of temporal testers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zaks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25 Years of Model Checking</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5000</biblScope>
			<biblScope unit="page" from="172" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">On the synthesis of a reactive module</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 16th ACM Symp. Princ. of Prog. Lang</title>
		<meeting>of the 16th ACM Symp. Princ. of Prog. Lang</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="179" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Abc: A system for sequential synthesis and verification</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">L</forename><surname>Synthesis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Group</surname></persName>
		</author>
		<ptr target="http://www.eecs.berkeley.edu/~alanmi/abc/" />
		<imprint>
			<biblScope unit="page">61208</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Synthesis of AMBA AHB from formal specification</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Godhal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<idno>abs/1001.2811</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>CORR</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Logic Synthesis and Verification Algorithms</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Hachtel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Somenzi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Kluwer Academic Publishers</publisher>
			<pubPlace>Boston, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Formal analysis of hardware requirements</title>
		<author>
			<persName><forename type="first">I</forename><surname>Pill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Semprini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cavada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Design Automation Conference</title>
		<meeting>of the Design Automation Conference</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="821" to="826" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Diagnostic information for realizability</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Schuppan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tchaltsev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Int. Conf. on Verification, Model Checking, and Abstract Interpretation</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 9th Int. Conf. on Verification, Model Checking, and Abstract Interpretation</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4905</biblScope>
			<biblScope unit="page" from="52" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Environment assumptions for synthesis</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. on Concurrency Theory (CONCUR)</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5201</biblScope>
			<biblScope unit="page" from="147" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Better quality in synthesis through quantitative objectives</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 21st Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5643</biblScope>
			<biblScope unit="page" from="140" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Synthesizing robust systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Greimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Jobstmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th Int. Conf. on Formal Methods in Computer-Aided Design</title>
		<meeting>of the 9th Int. Conf. on Formal Methods in Computer-Aided Design</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="85" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Synthesis of programs from temporal property specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Formal Methods and Models for Co-Design (MEMOCODE)</title>
		<meeting>Formal Methods and Models for Co-Design (MEMOCODE)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Realizable and unrealizable specifications of reactive systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wolper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 16th Int</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 16th Int</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">372</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A platform for combining deductive with algorithmic verification</title>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shahar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 8th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 8th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1102</biblScope>
			<biblScope unit="page" from="184" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Rat: A tool for the formal analysis of requirements</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cavada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Pill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tchaltsev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 19th Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 19th Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4590</biblScope>
			<biblScope unit="page" from="263" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">RATSY -a new requirements analysis tool with synthesis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Greimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hofferek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Koenighofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Schuppan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Seeber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 22nd Int. Conf. on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 22nd Int. Conf. on Computer Aided Verification</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6174</biblScope>
			<biblScope unit="page" from="425" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Where&apos;s waldo? sensor-based temporal logic motion planning</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kress-Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Fainekos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Robotics and Automation</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="3116" to="3121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Valet parking without a valet</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">C</forename><surname>Conner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kress-Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Choset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Rizzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Intelligent Robots and Systems</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="572" to="577" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">From structured English to robot motion</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kress-Gazit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fainekos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pappas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/RSJ Int. Conf. on Intelligent Robots and Systems</title>
		<meeting>IEEE/RSJ Int. Conf. on Intelligent Robots and Systems</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="2717" to="2722" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Receding horizon temporal logic planning for dynamical systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wongpiromsarn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 48th IEEE Conf. on Decision and Control</title>
		<meeting>of the 48th IEEE Conf. on Decision and Control</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="5997" to="6004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Receding horizon control for temporal logic specifications</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wongpiromsarn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 13th ACM Int. Conf. on Hybrid Systems: Computation and Control</title>
		<meeting>of the 13th ACM Int. Conf. on Hybrid Systems: Computation and Control</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Automatic synthesis of robust embedded control software</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wongpiromsarn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Topcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Murray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI Spring Symposium on Embedded Reasoning: Intelligence in Embedded Systems</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="104" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Controller synthesis from LSC requirements</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kugler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Plock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Fundamental Approaches to Software Engineering</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>Fundamental Approaches to Software Engineering</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5503</biblScope>
			<biblScope unit="page" from="79" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Compositional synthesis of reactive systems from live sequence chart specifications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kugler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Segall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 15th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<title level="s">Lecture Notes in Comput. Sci.</title>
		<meeting>of the 15th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5505</biblScope>
			<biblScope unit="page" from="77" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Aspectltl: an aspect language for ltl specifications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Maoz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sa'ar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 10th Int. Conf. on Aspect-Oriented Software Development</title>
		<meeting>of the 10th Int. Conf. on Aspect-Oriented Software Development</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="19" to="30" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
