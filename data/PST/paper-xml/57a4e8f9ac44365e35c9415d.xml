<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Breaking the Circuit Size Barrier for Secure Computation Under DDH</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Elette</forename><surname>Boyle</surname></persName>
							<email>elette.boyle@idc.ac.il</email>
							<affiliation key="aff0">
								<orgName type="institution">IDC Herzliya</orgName>
								<address>
									<settlement>Herzliya</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Niv</forename><surname>Gilboa</surname></persName>
							<email>gilboan@bgu.ac.il</email>
							<affiliation key="aff1">
								<orgName type="institution">Ben Gurion University</orgName>
								<address>
									<settlement>Beersheba</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
							<email>yuvali@cs.technion.ac.il</email>
							<affiliation key="aff2">
								<orgName type="department">Technion and UCLA</orgName>
								<address>
									<settlement>Haifa</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Breaking the Circuit Size Barrier for Secure Computation Under DDH</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DAC95927D8651AFBEA4624136F7FB44B</idno>
					<idno type="DOI">10.1007/978-3-662-53018-4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:24+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Under the Decisional Diffie-Hellman (DDH) assumption, we present a 2-out-of-2 secret sharing scheme that supports a compact evaluation of branching programs on the shares. More concretely, there is an evaluation algorithm Eval with a single bit of output, such that if an input w ∈ {0, 1} n is shared into (w 0 , w 1 ), then for any deterministic branching program P of size S we have that Eval(P, w 0 ) ⊕ Eval(P, w 1 ) = P (w) except with at most δ failure probability. The running time of the sharing algorithm is polynomial in n and the security parameter λ, and that of Eval is polynomial in S, λ, and 1/δ. This applies as a special case to boolean formulas of size S or boolean circuits of depth log S. We also present a public-key variant that enables homomorphic computation on inputs contributed by multiple clients. The above result implies the following DDH-based applications:</p><p>-A secure 2-party computation protocol for evaluating any branching program or formula of size S, where the communication complexity is linear in the input size and only the running time grows with S. -A secure 2-party computation protocol for evaluating layered boolean circuits of size S with communication complexity O(S/ log S). -A 2-party function secret sharing scheme, as defined by Boyle et al.</p><p>(Eurocrypt 2015), for general branching programs (with inverse polynomial error probability). -A 1-round 2-server private information retrieval scheme supporting general searches expressed by branching programs. Prior to our work, similar results could only be achieved using fully homomorphic encryption. We hope that our approach will lead to more practical alternatives to known fully homomorphic encryption schemes in the context of low-communication secure computation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In this paper we introduce a simple new technique for low-communication secure computation that can be based on the Decisional Diffie-Hellman (DDH) assumption and avoids the use of fully homomorphic encryption. We start with some relevant background.</p><p>Since the seminal feasibility results of the 1980s <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b38">38]</ref>, a major challenge in the area of secure computation has been to break the "circuit size barrier." This barrier refers to the fact that all classical techniques for secure computation required a larger amount of communication than the size of a boolean circuit representing the function to be computed, even when the circuit is much bigger than the inputs. The circuit size barrier applied not only to general circuits, but also to useful restricted classes of circuits such as boolean formulas (namely, circuits with fan-out 1) or branching programs (a stronger computational model capturing non-uniform logarithmic-space computations). Moreover, the same barrier applied also to secure computation protocols that can rely on a trusted source of correlated randomness, provided that this correlated randomness needs to be reusable.</p><p>The first significant progress has been made in the context of private information retrieval (PIR), where it was shown that for the bit-selection function f (x, i) = x i it is possible to break the circuit size barrier either in the multiserver model <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b10">11]</ref>, where a client holds i and two or more servers hold x, or in the two-party model <ref type="bibr" target="#b26">[27]</ref> under standard cryptographic assumptions. However, progress on extending this to other useful computations has been slow, with several partial results <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30]</ref> that do not even cover very simple types of circuits such as general DNF or CNF formulas, let alone more expressive ones such as general formulas or branching programs. <ref type="foot" target="#foot_0">1</ref>All this has changed with Gentry's breakthrough on fully homomorphic encryption (FHE) <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b32">33]</ref>. FHE enables local computations on encrypted inputs, thus providing a general-purpose solution to the problem of low-communication secure computation. On the down side, even the best known implementations of FHE <ref type="bibr" target="#b23">[24]</ref> are still quite slow. Moreover, while there has been significant progress on basing the feasibility of FHE on more standard or different assumptions <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b35">36]</ref>, the set of cryptographic assumptions on which FHE can be based is still very narrow, and in particular it does not include any of the "traditional" assumptions that were known in the 20th century.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contribution</head><p>Our new approach was inspired by the recent work on function secret sharing (FSS) <ref type="bibr" target="#b5">[6]</ref>. A (2-party) FSS scheme for a function class F allows a client to split (a representation of) f ∈ F into succinctly described functions f 0 and f 1 such that for any input x we have that f (x) = f 0 (x) + f 1 (x) (over some Abelian group), but each f b hides f . The notion of FSS was originally motivated by applications to m-server PIR and related problems. FSS schemes for simple classes of functions such as point functions were constructed from one-way functions in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b21">22]</ref>. However, a result from <ref type="bibr" target="#b5">[6]</ref> shows that 2-party FSS for richer circuit classes, from AC 0 and beyond, would imply (together with a mild additional assumption) breaking the circuit size barrier for similar classes.</p><p>The idea is that by encrypting the inputs and applying FSS to the function f that first decrypts the inputs and then computes f , the parties can shift the bulk of the work required for securely evaluating f to local evaluations of f 0 and f 1 . Thus, breaking the circuit size barrier reduces to securely distributing the generation of f 0 and f 1 from f and the secret decryption keys, which can be done using standard secure computation protocols and reused for an arbitrary number of future computations. This was viewed in <ref type="bibr" target="#b5">[6]</ref> as a negative result, providing evidence against the likelihood of basing powerful forms of FSS on assumptions that are not known to imply FHE.</p><p>We turn the tables by constructing FSS schemes for branching programs under DDH, which implies low-communication secure 2-party computation protocols under DDH.</p><p>Homomorphic secret sharing. For the purpose of presenting our results, it is more convenient to consider a dual version of FSS that can also be viewed as a form of "homomorphic secret sharing," or alternatively a variant of threshold FHE <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">19]</ref>. Concretely, a client wants to split a secret input w ∈ {0, 1} n into a pair of shares (w 0 , w 1 ), each of which is sent to a different server. Each individual share should computationally hide w. Each server, holding (a representation of) a function f ∈ F, can apply an evaluation algorithm to compute y b = Eval(f, w b ), so that y 0 + y 1 = f (w). Note that this is precisely the original notion of FSS with the roles of the function and input reversed. <ref type="foot" target="#foot_1">2</ref>Cast in the this language, our main technical contribution is such a homomorphic secret sharing scheme, based on DDH, with output group Z 2 (or any other Z p ), and the class F of functions represented by deterministic 3 branching programs. The scheme only satisfies a relaxed form of the above correctness requirement: for every input w and branching program P , the probability of producing local outputs that do not add up to the correct output P (w) is upper bounded by an error parameter δ &gt; 0 which affects the running time of Eval. This probability is over the randomness of the sharing. The running time of the sharing algorithm is n • poly(λ), where λ is a security parameter. The running time of Eval is polynomial in S, λ, and 1/δ.</p><p>We would like to stress that branching programs are quite powerful and capture many useful real-life computations. In particular, a branching program of size S can simulate any boolean formula of size S or boolean circuit of depth log 2 S, and polynomial-size branching programs can simulate any computation in the complexity classes NC 1 or (non-uniform) deterministic log-space.</p><p>We also present a public-key variant of the homomorphic secret sharing scheme. This variant can be viewed as a threshold homomorphic encryption scheme with secret evaluation keys and additive reconstruction. That is, there is a key generation algorithm that outputs a single public key and a pair of secret evaluation keys. Given the public key, an arbitrary number of clients can encrypt their inputs. Each server, given the public ciphertexts and its secret evaluation key, can locally compute an additive share of the output.</p><p>The above results imply the following applications, all based on the DDH assumption alone.</p><p>Succinct secure computation of branching programs. The general transformation from FSS to secure two-party computation described above can be used to obtain succinct two-party protocols for securely evaluating branching programs with reusable preprocessing. However, the public-key variant of our construction implies simpler and more efficient protocols. The high level approach is similar to that of other low-communication secure protocols from different flavors of FHE <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b28">29]</ref>, except for requiring secret homomorphic evaluation keys and an additional error-correction sub-protocol. For a two-party functionality with a total of n input bits and m = m(n) output bits, where each output can be computed by a polynomial-size branching program (alternatively, logarithmic space Turing Machine or NC 1 circuit), the protocol can be implemented with a constant number of rounds and n + m • poly(λ) bits of communication, where λ is a security parameter. To reduce the n • poly(λ) cost of a bit-by-bit encryption of the inputs, the protocol employs a hybrid homomorphic encryption technique from <ref type="bibr" target="#b19">[20]</ref>.</p><p>Breaking the circuit size barrier for "well structured" circuits. In the case of evaluating general boolean circuits, we can make the total communication slightly sublinear in the circuit size by breaking the computation into segments of logarithmic depth and homomorphically computing additive shares of the outputs of each segment given additive shares of the inputs. For instance, we can evaluate a layered circuit of size S using O(S/ log S) bits of communication (ignoring lower order additive terms; see Sect. 4 for a more precise statement). We employ error-correcting codes with encoding and decoding in NC 1 to ensure that errors introduced by the computation of a segment are corrected before propagating to the next segment.</p><p>Function secret sharing. Using a universal branching program we can reverse the roles of P and w in the above homomorphic secret sharing scheme, obtaining a polynomial-time 2-party FSS scheme for branching programs. Unlike the main definition of FSS from <ref type="bibr" target="#b5">[6]</ref> here we can only satisfy a relaxed notion that allows an inverse polynomial error probability. However, the error probability can be made negligible in the context of natural applications. An m-party FSS scheme for circuits was recently obtained by Dodis et al. <ref type="bibr" target="#b14">[15]</ref> under the Learning with Errors (LWE) assumption, by making use of multi-key FHE <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b28">29]</ref>.</p><p>Our construction gives the first FSS scheme that applies to a rich class of functions and does not rely on FHE.</p><p>Private information retrieval. Following the application of FSS to PIR from <ref type="bibr" target="#b5">[6]</ref> with a simple repetition-based error-correction procedure, a consequence of the above result is a 1-round 2-server (computational) PIR scheme in which a client can privately search a database consisting of N documents for existence of a document satisfying a predicate P , where P is expressed as a branching program applied to the document. For instance, any deterministic finite automaton can be succinctly expressed by such a branching program. The length of the query sent to each server is polynomial in the size of the branching program and a computational security parameter, whereas the length of the answer is a statistical security parameter times log N .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview of Techniques</head><p>We now describe the main ideas behind our construction. It will be convenient to use the homomorphic secret sharing view: a client would like to share an input w between 2 servers so that the servers, on input P , can locally compute additive shares of P (w).</p><p>Let G be a DDH group of prime order q with generator g. Our construction employs three simple ideas.</p><p>The first is that a combination of a threshold version of ElGamal and linear secret sharing allows the servers to locally multiply an encrypted input x with a linearly secret-shared value y, such that the result z = xy is shared multiplicatively between the servers; namely the servers end up with elements z i ∈ G such that the product of the z i is g z . This idea alone is already useful, as it gives an (m -1)-private m-server protocol for computing any degree-2 polynomial P with small integer coefficients held by the servers on a vector w of small integers held by the client, where the communication complexity in each direction is essentially optimal.</p><p>To see how this step is possible, consider a simplified version of the world, where (instead of requiring ElGamal) it held that g w is a secure encryption of w. In this world, we can secret share input w by giving both servers a copy of the encryption g w . Then, given an additive secret sharing x 0 , x 1 of another value x, the servers can generate a multiplicative sharing of wx, by each computing (g w ) x b . Indeed, (g wx0 ) • (g wx1 ) = g wx . Extending this idea to ElGamal (as, alas, g w is not a secure encryption) can be done via comparable "linear algebra in the exponent" given additive shares of x as well as for xc, where c is the ElGamal secret key.</p><p>What seems to stop us at degree-2 polynomials is the fact that z is now shared multiplicatively rather than linearly, so the servers cannot multiply z by a new input encrypted by the client. Moreover, converting multiplicative shares to additive shares seems impossible without the help of the client, due to the intractability of computing discrete logarithms in G. The second, and perhaps most surprising, idea is that if we allow for an inverse polynomial error probability, and assuming there are only m = 2 servers, the servers can convert multiplicative shares of g z into linear shares of z without any interaction. For simplicity, suppose z ∈ {0, 1}. Taking the inverse of the second server's share, the servers now hold group elements g 0 , g 1 such that g 0 = g 1 if z = 0 and g 1 = g • g 0 if z = 1. Viewing the action of multiplication by g as a cycle over Z q , the elements g 0 , g 1 are either in identical positions, or g 1 is one step ahead. Conversion is done by picking a pseudo-random δ-sparse <ref type="foot" target="#foot_3">4</ref> subset G ⊂ G and having each server b ∈ {0, 1} locally find the minimal integer z b ≥ 0 such that g b • g z b ∈ G . The first such z b is expected to be found in roughly 1/δ steps and if it is not found in (1/δ) log(1/δ) steps, we set z b = 0. The key observation is that except with O(δ) probability, both searches will find the same point in G and the servers end up with integers z 1 , z 2 such that z 1z 2 = z, yielding the desired linear sharing of z.</p><p>Once we have a linear sharing of z, we can freely add it with other values that have a similar linear representation. We cannot hope to multiply two linearly shared values, but only to multiply them with another encrypted input. However, in order to perform another such a multiplication, we need additive shares not only of z, but also of zc for the ElGamal key c.</p><p>The third idea is that the client can assist the conversion by also providing an encryption of each input w multiplied by the secret key. This introduces two problems: the first is that semantic security may break down given a circular encryption of the secret key, which we handle either by assuming circular security of ElGamal or (with some loss of efficiency) by using the circular-secure variant of Boneh et al. <ref type="bibr" target="#b4">[5]</ref> instead of standard ElGamal. A more basic problem is that for the conversion to produce correct results with high probability, the secrets must be small integers, whereas c (and so zc) is a large number. This is handled by providing an encryption of each input x multiplied by each bit of the secret key, and applying a linear combination whose coefficients are powers of 2 to the linear shares of the products of x and the bits of the key.</p><p>These ideas allow the servers to compute a restricted type of "straight-line programs" on the client's input, consisting of a sequence of instructions that either: load an input into memory, add the values of two memory locations, or multiply a memory location by an input. (Note that we cannot multiply two memory locations, which would allow evaluation of arbitrary circuits.) Such programs can emulate any branching program of size S by a sequence of O(S) instructions.</p><p>It is instructive to note that the only limit on the number of instructions performed by the servers is the accumulation of error probabilities. This is analogous to the accumulation of noise in FHE schemes. However, the mechanisms for coping with errors are very different: in the context of known FHE schemes the simplest way of coping with noise is by using larger ciphertexts, whereas here we can reduce the error probability by simply increasing the running time of the servers, without affecting the ciphertext size or the complexity of encryption and decryption at all. We can also further trade running time for succinctness: the share size in our basic construction can be reduced by replacing the binary representation of the secret key with a representation over a larger basis, which leads to a higher homomorphic evaluation time.</p><p>The surprising power of local share conversions, initially studied in <ref type="bibr" target="#b13">[14]</ref>, has already been observed in the related contexts of information-theoretic PIR and locally decodable codes <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b39">39]</ref>. However, the type of share conversion employed here is very different in nature, as it is inherently tied to efficient computation rather than information.</p><p>Interestingly, our share conversion technique has resemblance to a cryptanalytic technique introduced by van Oorschot and Weiner for the purpose of parallel collision finding <ref type="bibr" target="#b37">[37]</ref>, where a set of "distinguished points" is used to synchronize two different processors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Future Directions</head><p>This work gives rise to many natural open questions and future research directions. Can one bootstrap from branching programs to general circuits without relying on FHE? Can similar results be obtained for more than 2 parties? Can similar results be based on other assumptions that are not known to imply FHE? Can the dependence on the error parameter δ be eliminated or improved? To what extent can our protocols be optimized for practical use?</p><p>We hope that our approach will lead to faster solutions for some practical use-cases of FHE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We describe the necessary primitives and assumptions we rely on.</p><p>Function representations. We capture a function representation (such as a circuit, formula, or branching program) by an infinite collection P of bit strings P (called "programs"), each specifying an input length n and an output length m, together with an efficient algorithm Evaluate, such that y ← Evaluate(P, w) (denoted by shorthand notation "P (w)"), for any input w ∈ {0, 1} n , defines the output of P on w. Homomorphic secret sharing. A (2-party) Homomorphic Secret Sharing (HSS) for a class of programs P consists of algorithms (Share, Eval), where Share(1 λ , (w 1 , . . . , w n )) splits the input w into a pair of shares (share 0 , share 1 ), and Eval(b, share, P, δ, β) homomorphically evaluates P on share, where the correct output is additively shared over Z β except with error probability δ. When β is omitted it is understood to be β = 2. We allow Eval to run in time polynomial in its input length and in 1/δ and require that each share b output by Share keeps w semantically secure.</p><p>Public-Key Variant. We further consider a stronger variant of the homomorphic secret sharing primitive that supports homomorphic computations on inputs contributed by different clients. In fact, what we achieve is stronger: there is a single public key that can be used to encrypt inputs as in a standard publickey encryption scheme. However, similar to the original notion of homomorphic secret sharing (and in contrast to standard homomorphic encryption schemes), homomorphic computations on encrypted inputs are done in a distributed way and require two separate (secret) evaluation keys. As before, we require the reconstruction of the output to be additive.</p><p>The corresponding security notion guarantees "semantic"-style secrecy of an encrypted value, given only the evaluation key of a single server. In a setting consisting of two servers and an arbitrary number of clients, the above security notion implies that inputs contributed by a set of uncorrupted clients remain secure even if one of the two servers colludes with all the remaining clients.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Distributed-Evaluation Homomorphic Encryption).</head><p>A (2-party) Distributed-Evaluation Homomorphic Encryption (DEHE) for a class of programs P consists of algorithms (Gen, Enc, Eval) with the following syntax:</p><p>-Gen(1 λ ): On input a security parameter 1 λ , the key generation algorithm outputs a public key pk and a pair of evaluation keys (ek 0 , ek 1 ). -Enc(pk, w): On a public key pk and a secret input value w ∈ {0, 1}, the encryption algorithm outputs a ciphertext ct. -Eval(b, ek, (ct 1 , . . . , ct n ), P, δ, β): On input party index b ∈ {0, 1}, an evaluation key ek, vector of n ciphertexts, a program P ∈ P with n input bits and m output bits, error bound δ &gt; 0, and an integer β ≥ 2, the homomorphic evaluation algorithm outputs y b ∈ Z m β , constituting party b's share of an output y ∈ {0, 1} m . When β is omitted it is understood to be β = 2.</p><p>The algorithms Gen and Enc are PPT algorithms, whereas Eval can run in time polynomial in its input length and in 1/δ. The algorithms (Gen, Enc, Eval) should satisfy the following correctness and security requirements:</p><p>-Correctness: There exists a negligible function ν such that for every positive integer λ, input (w 1 , . . . , w n ) ∈ {0, 1} n , program P ∈ P with input length n, error bound δ &gt; 0, and integer</p><formula xml:id="formula_0">β ≥ 2, Pr[(pk, (ek 0 , ek 1 )) ← Gen(1 λ ); (ct 1 , . . . , ct n ) ← (Enc(pk, w 1 ), . . . , Enc(pk, w n )); y b ← Eval(b, pk(ct 1 , . . . , ct n ), P, δ, β) ∀b ∈ {0, 1} : y 0 + y 1 = P (w 1 , . . . , w n )] ≥ 1 -δ -ν(λ),</formula><p>where addition of y 0 and y 1 is carried out modulo β. -Security: The two distribution ensembles C 0 (λ) and C 1 (λ) are computationally indistinguishable, where C w (λ) is obtained by letting (pk, (ek 0 , ek 1 )) ← Gen(1 λ ) and outputting (pk, ek b , Enc(pk, w)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">DDH and Circular Security Definition 2 (DDH).</head><p>Let G = {G ρ } be a set of finite cyclic groups, where |G ρ | = q and ρ ranges over an infinite index set. We use multiplicative notation for the group operation and use g ∈ G ρ to denote a generator of G ρ . Assume that there exists an algorithm running in polynomial time in log q that computes the group operation of G ρ . Assume further that there exists a PPT instance generator algorithm IG that on input 1 λ outputs an index ρ which determines the group G ρ and a generator g ∈ G ρ . We say that the Decisional Diffie-Hellman assumption (DDH) is satisfied on G if IG(1 λ ) = (ρ, g) and for every non-uniform PPT algorithm A and every three random a, b, c ∈ {0, . . . , q -1} we have</p><formula xml:id="formula_1">|Pr[A(ρ, g a , g b , g ab ) = 1] -Pr[A(ρ, g a , g b , g c ) = 1]| &lt; ε(λ),</formula><p>for a negligible function ε. We will sometimes write (G, g, q) ← IG(1 λ ).</p><p>A more efficient variant of our construction requires a circular security assumption on the underlying bit encryption scheme, in which an efficient adversary cannot distinguish encryptions of the bits of the secret key from encryptions of 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Circular Security).</head><p>We say that a public-key encryption scheme (Gen, Enc, Dec) with key length (λ) and message space containing {0, 1} is circular secure if there exists a negligible function ν(λ) for which the following holds for every non-uniform PPT A:</p><formula xml:id="formula_2">Pr[(pk, sk) ← Gen(1 λ ), b ← {0, 1}, b ← A O b (pk) : b = b] ≤ 1 2 + ν(λ),</formula><p>where the oracle O b takes no input and outputs the following (where sk (i) denotes the ith bit of sk):</p><formula xml:id="formula_3">(C 1 , . . . , C ), where ∀i ∈ [ ], C i ← Enc(pk, 0) if b = 0 ∀i ∈ [ ], C i ← Enc(pk, sk (i) ) if b = 1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Homomorphic Secret Sharing for Branching Programs</head><p>In this section, we present constructions of homomorphic secret sharing schemes that enable non-interactive evaluation of a certain class of programs, known as restricted-multiplication straight-line programs. In particular, this class will include deterministic branching programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (RMS programs). The class of Restricted Multiplication</head><p>Straight-line (RMS) programs consists of an arbitrary sequence of the four following instructions, each with a unique identifier id:</p><p>-Load an input into memory: (id, ŷj ← ŵi ).</p><p>-Add values in memory: (id, ŷk ← ŷi + ŷj ).</p><p>-Multiply value in memory by an input value: (id, ŷk ← ŵi • ŷj ).</p><p>-Output value from memory, as element of Z β : (id, β, Ôj ← ŷi ).</p><p>Our construction will support homomorphic evaluation of straight-line programs of this form over inputs w i ∈ Z, provided that all intermediate computation values in Z remain "small" (where the required runtime grows with this size bound). Our final result is a public-key variant-i.e., a homomorphic encryption scheme with distributed evaluation (as per Definition 1)-based on DDH, with ciphertext size O( ) group elements per input (for the logarithm of the DDH group size), and where runtime for homomorphic evaluation of an RMS program of size S with intermediate computation values bounded by M is poly(λ, S, M, 1/δ).</p><p>An important sub-procedure of our homomorphic share evaluation algorithms is a local share conversion algorithm DistributedDLog, which intuitively converts a multiplicative secret sharing of g x to an additive secret sharing of the value x, with inverse polynomial probability of error.</p><p>In the following subsections, we present: (1) The share conversion procedure DistributedDLog, (2) a simplified version of the homomorphic secret sharing scheme (in the secret-key setting), assuming circular security of ElGamal encryption, (3) the analogous public-key construction, and (4) the final publickey construction based on standard DDH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Share Conversion Procedure</head><p>We now describe the local share conversion algorithm DistributedDLog, which receives as input a group element h ∈ G and outputs an integer w. Loosely speaking, DistributedDLog outputs the distance on the cycle generated by g ∈ G between h and the first z ∈ G such that a pseudo-random function outputs 0 on z. DistributedDLog is a deterministic algorithm and consequently two invocations of the algorithm with the same element h result in the same output w. Two invocations of the algorithm on inputs h and h•g μ for a small μ result, with good probability, in outputs w and wμ. Therefore, the DistributedDLog algorithm converts a difference of small μ in the cycle generated by g in G to the same difference over Z.</p><p>The detailed description of DistributedDLog G,g follows. The algorithm is hardwired with ρ defining a group G = G ρ and a generator g ∈ G. DistributedDLog G,g receives as input h ∈ G, an allowable error probability δ, maximum difference μ ∈ N, and a pseudo-random function φ : G → {0, 1} log(4μ/δ) . The difference μ specifies the maximum distance from h, along the cycle that g generates, of an element that is the input to a parallel invocation of DistributedDLog G,g within a given application. Proposition 1. Let λ be a security parameter, let G = {G ρ } be a set of finite cyclic groups and let the instance generator algorithm of the set running on input 1 λ return a group G = G ρ with generator g. Let δ &gt; 0, let μ ∈ N, let F r be a family of PRF defined over G and let φ : G → {0, 1} log(4/δ) be randomly chosen Algorithm 1. DistributedDLog G,g (h, δ, μ, φ)</p><formula xml:id="formula_4">1: Set z ← h, w ← 0. 2: while (φ(z) = 0 log(4μ/δ) and w &lt; 4μ ln(4/δ) δ ) do 3: z ← z • g, w ← w + 1. 4: end while 5: Output w.</formula><p>from all the members of F r with domain G. Then, for any h ∈ G and μ ≤ μ we have that</p><formula xml:id="formula_5">DistributedDLog G,g (h, δ, μ, φ) -DistributedDLog G,g (h • g μ , δ, μ, φ) = μ with probability greater than 1 -δ.</formula><p>Proof. The values of φ on the sequence of elements traversed by the variable z in an execution of DistributedDLog G,g (h, δ, μ, φ) can be divided into three cases. The first case is that φ(h</p><formula xml:id="formula_6">• g c ) = 0 log(4μ/δ) for some c in the range 0 ≤ c ≤ μ -1, the second case is that φ(h • g c ) = 0 log(4μ/δ) for c = 0, . . . , μ -1, but φ(h • g c ) = 0 log(4μ/δ) for some c in the range μ ≤ c ≤ 4μ ln(4/δ) δ</formula><p>and the last case is that neither of the former occurs, i.e. φ(h • g c ) = 0 log(4μ/δ) for every c = 0, 1, . . . , 4μ ln(4/δ) δ . In the second case, since φ(h • g c ) = 0 log(4μ/δ) for any c = 0, . . . , μ -1, the execution of DistributedDLog G,g (h, δ, μ, φ) returns the smallest c, μ ≤ c ≤ 4μ ln(4/δ) δ such that φ(h) = 0 log(4μ/δ) . In DistributedDLog G,g (h • g μ , δ, μ, φ) the variable z ranges over the elements h•g μ , . . . , h•g c+μ and the return value is c-μ. Therefore, DistributedDLog G,g (h, δ, μ, φ) -DistributedDLog G,g (h • g μ , δ, μ, φ) = μ. By showing that the second case occurs with probability at least 1-δ we complete the proof.</p><p>If R is a random function then the probability that R(h</p><formula xml:id="formula_7">• g c ) = 0 log(4μ/δ) for some c, 0 ≤ c ≤ μ -1 is exactly 1 -(1 -δ/4μ) μ , which by induction is at most 1 -(1 -μδ/4μ) = δ/4. In addition, Pr[∀c ∈ {0, . . . , 4μ ln 4 δ δ } R(hg c ) = 0 log(4μ/δ) ] ≤ (1 - δ 4μ ) 4μ ln(4/δ) δ &lt; e -ln 4/δ = δ 4</formula><p>Since φ is selected randomly from an appropriate family of pseudo-random functions any non-uniform PPT algorithm can distinguish between R and φ with negligible probability. Specifically, the probability of the first case is bound by</p><formula xml:id="formula_8">|Pr[∃c, 0 ≤ c ≤ μ -1 φ(h • g c ) = 0 log(4/δ) ] -δ/4| &lt; ε(δ) (for a negligible function ε(δ))</formula><p>, since otherwise an efficient non-uniform algorithm can distinguish between R and φ by testing their value on hard-coded element (h, δ, μ, φ) and returning 1 if the result is 0 log(4μ/δ) . Similarly, the probability of the third case is bound by |Pr[∀c ∈ {0, . . . , 4 ln(4/δ) δ } φ(hg c ) = 0 log(4/δ) ]δ/4| &lt; ε(δ). The probability of the second case is therefore at least 1 -δ 2 -2ε(δ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Homomorphic Secret Sharing</head><p>We now construct a simple version of the homomorphic secret sharing scheme, using the procedure DistributedDLog as a sub-routine. The resulting scheme will be a "secret-key" version. Further, the security of the scheme will rely on the assumption that ElGamal encryption is circular secure. These restrictions will be removed in the following subsections. Consider a DDH group G of prime order q (with λ bits of security) with generator g, and = log 2 q . We will use c = c (1) , . . . , c ( ) to denote bits of an element c ∈ Z q (i.e., c = -1</p><formula xml:id="formula_9">i=0 2 i c (i+1) ).</formula><p>Overview of construction. All values generated within the secret sharing and homomorphic evaluation sit within three "levels." We will maintain notation as in the top portion of Fig. <ref type="figure" target="#fig_0">1</ref>. Namely,</p><formula xml:id="formula_10">Level 1: ElGamal Ciphertexts [[w]] c .</formula><p>Initial input values w will be "uploaded" into the homomorphic evaluation system by generating an ElGamal encryption [[w]] c of the value w with respect to a common secret key c, as well as encryptions [[c (i) w]] c of each of the products c (i) w for the bits c (i) of the corresponding key c. Level 2: Additive secret shares y .</p><p>Each value y in memory of the RMS program will be maintained via two sets of additive secret shares: y itself, and cy secret sharing the product of y with the ElGamal secret key c of the system. We start with secret shares of this form for each input value (e.g., in the secret-key setting, these will be generated as part of the Share procedure). Then, after each emulated RMS instruction, we will maintain the invariant that each newly computed memory value is stored as secret shares in this fashion. Level 3: Multiplicative secret shares xy .</p><p>Multiplicative secret shares appear only as intermediate values during the execution of homomorphic evaluation (of multiplication), and are then converted back to additive shares via DistributedDLog.</p><p>Remark 1 (Valid vs Random). We emphasize that a "valid" encoding (e.g., <ref type="bibr">[[x]</ref>] c , x , or x ) speaks only to the correctness of decoding, and does not imply that the encoding is a random such encoding (e.g., a randomly sampled ciphertext, or fresh secret shares).</p><p>The bottom portion of Fig. <ref type="figure" target="#fig_0">1</ref> describes two pairing operations that constitute cross-level computations. The first, MultShares, "multiplies" a level-1 encoding by a level-2 encoding. Namely, it takes as input a level-1 (ElGamal ciphertext) encoding of x under key c, and level-2 (additive secret sharing) encodings of y, and of cy (the product of y with the ElGamal secret key), and outputs a level-3 (multiplicative secret sharing) encoding of the product xy. The second, ConvertShares, converts from a level-3 (multiplicative) encoding back down to a level-2 (additive) encoding, with some probability of error, as dictated by given parameters.</p><p>Roughly, the intermediate values of homomorphic evaluation will be maintained in level-2 (additive) secret shared form. Any linear combination of such shares can be performed directly. Multiplication between a value in memory and an input value will be performed by performing the MultShares between the input value (encoded in level 1) and the relevant memory value (encoded in level 2). This will yield an encoding of the product, but in level 3 (i.e., as multiplicative shares). To return the computed product back to level 2, the parties will execute the pairing procedure ConvertShares, which essentially runs the DistributedDLog procedure from the previous subsection.</p><p>Remark 2 (Variable Types). Note that the relevant values are nearly all elements of G (e.g., elements of ElGamal ciphertexts) or of Z q (e.g., the values cy i , as well as shares of SubtShare). An important exception to this are the values w i , y i , which are interpreted as (small) integers. When necessary for computation, we will sometimes perform a type cast back and forth between Z and Z q , using the notation (int)(x) ∈ Z for x ∈ Z q , and (x mod q) ∈ Z q for x ∈ Z.</p><p>A few calculations provides us with the following two claims on these pairing procedures (see full version of this work for details). A slight subtlety arises in the case of ConvertShares, regarding the PRF. Namely, the share values on which we run ConvertShares are the results of partial computations and previous ConvertShares executions, meaning in particular that they depend on the choice of the sampled PRF φ. However, this is not an issue due to two reasons: (1) this dependence is efficiently computable given oracle access to the PRF outputs, as specified in the algorithm DistributedDLog, and (2) we will explicitly ensure the PRF is never used on the same input twice, by use of nonces id. In such case, the PRF will still act as a random function in each ConvertShares invocation, and yield the required share conversion correctness guarantee.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim (Pairing Operations).</head><p>1. MultShares: For all values x, y ∈ Z q and any key c ∈ Z q , then on input a valid level- </p><formula xml:id="formula_11">For every id ∈ {0, 1} λ , δ &gt; 0, M ∈ N, PPT A, Pr[φ ← PRFGen(1 λ ); (h, μ) ← A φ(id ,•) (1 λ ) : μ &lt; M ∧ ConvertShares(0, h, id, δ, M) + ConvertShares(1, h -1 g μ , id, δ, M) = μ] ≤ Mδ,</formula><p>where φ(id , •) is an oracle to the PRF φ on any input with prefix id = id. We present our secret sharing scheme Share in Fig. <ref type="figure" target="#fig_1">2</ref>, and the corresponding homomorphic operations on shares Eval in Fig. <ref type="figure">3</ref>.</p><p>We remark that our combined construction obtains a generalization of the notion of HSS from Sect. 2 both extending beyond the Boolean setting to support arithmetic computations over small integers, and allowing multiple outputs of the Fig. <ref type="figure">3</ref>. Procedures for performing homomorphic operations on secret shares. Note that we distinguish variables of the straight-line program from the actual values by using ŷi as opposed to yi, etc. Here, notation y is used to represent this party's share of the corresponding subtractive secret shared pair. Evaluation maintains the invariant that each of the additive secret shares yi encode the correct current computation value of ŷi.</p><p>program from possibly different groups Z β (as specified by the program description P ). The restricted case of the definition coincides with our construction with size bound M set to 1 and all program outputs in a fixed group Z β . <ref type="bibr">Definition 3)</ref>. Then the scheme (Share, Eval) as specified in Figs. <ref type="figure" target="#fig_8">2,</ref><ref type="figure"></ref> 3 is a secure homomorphic secret sharing scheme for the class of deterministic branching programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 (Homomorphic Secret Sharing). Assume that ElGamal is circular secure (as per</head><p>The theorem follows from the next two correctness and security lemmas. In particular, correctness is proved for the broader class of RMS programs with bounded-size intermediate computation values, which captures deterministic branching programs. We provide proof sketches and refer the reader to the full version for a complete analysis.</p><p>Lemma 1 (Correctness of Eval). For every input w 1 , . . . , w n ∈ Z q and every RMS program P (as in Definition 4) of size S for which all intermediate values y i ∈ Z in the execution of P are bounded by</p><formula xml:id="formula_12">|y i | ≤ M , Pr[(share 0 , share 1 ) ← Share G,g (1 λ , w 1 , . . . , w n ) :</formula><p>Eval G,g (share 0 , P, M, δ) + Eval G,g (share 1 , P, M, δ)</p><formula xml:id="formula_13">= P (w 1 , . . . , w n )] ≥ 1 -δ.</formula><p>Proof Sketch. We first address the probability of error due to execution of the Share Conversion Procedure ConvertShares. Observe that the homomorphic evaluation of program P performs at most S( +1) executions of the Share Conversion Procedure (with error parameter δ = δ/( +1)MS). By Claim 3.2, together with a union bound, this implies that no conversion errors will occur with probability δ ( + 1)MS = δ. Assume, then, that every ConvertShares execution returns without error. We prove that following invariant is maintained at each step of homomorphic evaluation:</p><p>For every memory item ŷi , let y i ∈ Z denote the correct value that should be presently stored in memory. Then the shares y i = (y A i , y B i ) ∈ Z 2 q and cy i = (v A , v B ) ∈ Z 2 q held by the parties satisfy:</p><formula xml:id="formula_14">(a) (int)(y A i + y B i ) = y i ∈ Z (where addition is in Z q ). (b) v A + v B = cy i ∈ Z q .</formula><p>Note that this invariant holds vacuously at the start of Eval, as all memory locations are empty, and is preserved directly by our actions in each Load Input Into Memory and Add Values In Memory instructions, due to the structure of the additive secret sharing and since all intermediate values y i ∈ Z in the execution are bounded by M &lt; q (so that relations over Z align with relations over the shares Z q ).</p><p>For each instruction Multiply Input By Memory Value, consider the resulting shares y k and cy k . By Claim 3.2, the shares w i y j computed via MultShares constitute a valid level-3 sharing of the product w i y j (as per Fig. <ref type="figure" target="#fig_0">1</ref>). Since we are in the case where ConvertShares does not err, the resulting converted shares w i y j encode exactly the value w i y j ∈ Z q . Since w i y j is an intermediate computation value y k in the evaluation of P , we have 0 ≤ w i y j ≤ M &lt; q. Thus, invariant (a) holds. Consider now cy k . From precisely the same argument (since we are in the case where ConvertShares does not err), we have for each t ∈ [ ] that the computed intermediate value c (t) y k is a level-2 encoding of the corresponding value v t := c (t) y k ∈ Z q (where y k = w i y j ). Since y k is an intermediate computation value in P we have 0 ≤ y k ≤ M &lt; q, and so for c (t) ∈ {0, 1}, then 0 ≤ c (t) y k ≤ M &lt; q. Thus, it holds (int</p><formula xml:id="formula_15">)(v A t -v B t ) = c (t) w i y j ∈ Z. Combin- ing the respective values over t ∈ [ ], it holds t∈[ ] 2 t v A t + t∈[ ] 2 t v B t = t∈[ ] 2 t (v A t + v B t ) = t∈[ ] 2 t c (t) w i y j = cw i y j ∈ Z q . Therefore, invariant (b) holds.</formula><p>Finally, for each Output Memory Value instruction, the shares of both parties are deliberately shifted by a (pseudo-)random value to avoid the bad "edge case" in which the shares y A , y B of the desired output value y satisfy (int)y B ≥ q -M and (int)(y A ) -(int)(y B ) = yq (where locally modding each share by β may disrupt correctness), as opposed to the almost-everywhere case that (int)(y A ) -(int)(y B ) = y. The error probability is bounded by M/q + negl(λ), which is negligible.</p><p>Lemma 2 (Security of Share). Based on the assumption that ElGamal is a weakly circular secure encryption scheme (as per Definition 3), then Share is a computationally secure secret sharing scheme.</p><p>Proof Sketch. We prove that the distribution of a single party's share resulting from Share is computationally indistinguishable from a distribution that is independent of the shared values w 1 , . . . , w n , via three hybrids. In Hybrid 1, we replace all additive secret shares by random values. This yields an identical distribution, by the perfect security of the 2-out-of-2 additive secret sharing scheme. In Hybrid 2, we replace all ciphertexts of the form {[[c (t) w i ]] c } with encryptions of 0, which we address below. In Hybrid 3, we rely on standard semantic security to further replace all ciphertexts of the form [[w i ]] c with encryptions of 0.</p><p>We now demonstrate that an efficient adversary A who distinguishes between Hybrids 2 and 3 for some choice of inputs w 1 , . . . , w n can be used to break the circular security of ElGamal. In the circular security challenge, the adversary B receives an ElGamal public key pk and access to an oracle which provides either vectors of encryptions of the bits of the secret key, or vectors of encryptions of 0. To simulate the ciphertext vectors for A as either {[[c (t) </p><formula xml:id="formula_16">w i ]] c } (Hybrid 2) or {[[0]] c } (Hybrid 3</formula><p>), B (with w 1 , . . . , w n hardcoded) considers two cases. If w i = 0 then anyway c (t) w i = 0, so he simply generates a vector of 0 ciphertexts. For each w i = 0, he: queries his circular security oracle, receives a vector of ciphertexts</p><formula xml:id="formula_17">[[x i,1 ]] c , . . . , [[x i, ]</formula><p>] c , and then exponentiates each ciphertext (that is, each of the 2 group elements) by the corresponding input w i . This operation maps ciphertexts of 0 to ciphertexts of 0, and ciphertexts of 1 to ciphertexts of w i ; further, since w i = 0 and Z q is a field, the resulting distribution of encryption randomness is also equally distributed (i.e., uniform). Therefore, either Hybrid 2 or 3 is exactly simulated, and so the adversary A enables B to distinguish, breaking circular security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Public-Key HSS for Branching Programs</head><p>In the construction of the previous section, secret shares of an input w consisted of ElGamal encryptions [[w]] c , {[[c (t) w]] c } t∈[ ] and additive secret shares w , cw , where c was a (freshly sampled) key for ElGamal. At face value, it would seem that one must know the value of the key c in order to generate these valuesmeaning, in turn, that homomorphic computation can only be performed on the data of a single user who generates the key c. In this section, we demonstrate that by leveraging the homomorphic properties of ElGamal encryption, we can in fact generate all required values for a secret sharing of w while maintaining security, given only "public key" information independent of the input w. That is, we obtain homomorphic encryption with distributed evaluation, as discussed in Sect. 2.</p><p>More formally, we now consider a separate procedure Gen for generating common setup information pk and secret evaluation keys ek 0 , ek 1 (which we consider to be given to two servers). Given access to pk, a user can "upload" his input w to the system via Enc. Then, given their respective evaluation keys, two servers can perform non-interactive homomorphic computations on all users' inputs via Eval.</p><p>In our construction, the algorithm Gen samples an ElGamal key pair, and outputs pk consisting of encryptions [ <ref type="bibr" target="#b0">[1]</ref>] c , {[[c (t) ]] c } t∈[ ] and evaluation keys ek b corresponding to additive secret shares of c . In Enc, a user computes the necessary ciphertexts [[w]] c and {[[c (t) w]] c } t∈[ ] for his input w by exponentiating the ciphertexts in pk component-wise by w, (i.e., using multiplicative homomorphism of ElGamal). The final required values w , cw can be obtained directly by the servers within Eval by performing the procedure for a homomorphic multiplication between the "input value" w (i.e., given <ref type="bibr">[[w]</ref>] c , {[[c (t) ]] c } t∈[ ] ) together with "memory value" 1 (i.e., given a trivial sharing 1 together with c from ek).</p><p>A formal description of the algorithms Gen, Enc, Eval is given in Fig. <ref type="figure" target="#fig_2">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 (DEHE).</head><p>Assume that ElGamal is circular secure (as per Definition 3). Then the scheme (Gen, Enc, Eval) as given in Fig. <ref type="figure" target="#fig_2">4</ref>   t) w]] c . Property (2): Holds by the correctness of homomorphic RMS multiplication evaluation of Eval as per Theorem 1.</p><formula xml:id="formula_18">) for (h 1 , h 2 ) a valid level-1 encoding of 1. This means h 2 h -c 1 = g 1 , which implies (h w 2 )(h w 2 ) -c = g w , as desired. Same for each [[c<label>(</label></formula><p>Security. Semantic security of the scheme follows as in Theorem 1, assuming circular security of ElGamal. Namely, the view of a server holding ek b consists of information theoretically hiding secret shares, ciphertexts of values independent of the secret key, and vectors of ciphertexts encrypting the vector (c (1) w, . . . , c ( ) w) for various inputs w. An adversary distinguishing between this view and one consisting of random share elements and ciphertexts of 0 can be used to break the circular security of ElGamal, precisely as in Theorem 1. Comparing the complexity of the public-key scheme (Gen, Enc, Eval) to that of the secret-key scheme (Share, Eval) from the previous section, we see that the computation cost to the user for uploading inputs w 1 , . . . , w n via Enc is essentially equivalent to the cost of sharing the inputs via Share (exponentiating given ciphertexts by the respective inputs in one case, versus encrypting the values directly in the other), but the cost of each "load input" instruction (id, ŷj ← ŵi ) within the homomorphic evaluation now incurs the cost of a multiplication step to generate additive secret shares w i , cw i given only c and the uploaded ElGamal ciphertexts associated with w i , as opposed to being essentially for free for the client to generate w i , cw i when he knew the values of w i , cw i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Removing the Circular Security Assumption</head><p>We now show how to remove the ElGamal circular security assumption in the construction in the previous section, yielding a scheme that relies solely on DDH. As in the setting of FHE, this can be achieved directly in exchange for a multiplicative blowup of the computation depth in the share size, by considering a leveled version of the scheme (i.e., replacing the circular encryptions of bits of c under key c by bits of c i under key c i+1 for a depth-length sequence of keys). However, we now demonstrate an alternative approach, which does not require increasing the share size with respect to the size of computation.</p><p>Our new construction replaces ElGamal encryption with the ElGamal-like cryptosystem of Boneh, Halevi, Hamburg, and Ostrovsky (BHHO) <ref type="bibr" target="#b4">[5]</ref>, which is provably circular secure based on DDH. At a high level, BHHO ciphertexts possess an analogous structure of "linear algebra in the exponent," which allows us to mirror the procedure we used with ElGamal for multiplicatively pairing a ciphertext with an additively shared value.</p><p>It will be convenient to consider a slightly modified version of the BHHO scheme, given below, in which the message space is a subset of the exponent space Z q instead of the group G itself (i.e., the multiplication by message m in standard encryption is replaced by g m ). Since decryption of such scheme requires taking discrete log, efficient decryption will hold for a polynomial-size message space. <ref type="bibr" target="#b4">[5]</ref>). Let G be a group of prime order q and g a fixed generator of G. The size of G is determined by a security parameter λ, in particular, 1/q is negligible in λ. The BHHO public-key encryption scheme for polynomial-size message space Msg ⊂ Z q is as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (BHHO Encryption</head><p>-Key Generation. Let := 3 log 2 q . Choose random g 1 , . . . , g ← G and a random secret key vector s = (s 1 , . . . , s</p><formula xml:id="formula_19">) ← {0, 1} . Let h = (g s1 • • • g s ) -1</formula><p>and define the public and secret keys to be pk BHHO := (g 1 , . . . , g , h), sk BHHO = (g s1 , . . . , g s ).</p><p>-Encryption. To encrypt m ∈ Msg, choose a random r ← Z q and output the ciphertext <ref type="figure">,</ref><ref type="figure">c ,</ref><ref type="figure">d</ref>) be a ciphertext and sk BHHO = (v 1 , . . . , v ) a secret key. Do:</p><formula xml:id="formula_20">(g r 1 , . . . , g r , h r • g m ). -Decryption. Let (c 1 , . . .</formula><p>• Decode the secret key:</p><formula xml:id="formula_21">For i = 1, . . . , , set s i ← 0 if v i = 1 and s i ← 1 otherwise. • Output m ∈ Msg for which g m = d • (c s1 1 • • • c s ).</formula><p>Theorem 3 (Circular Security of BHHO <ref type="bibr" target="#b4">[5]</ref>). Assuming DDH, the BBHO encryption scheme satisfies circular security, as per Definition 3.</p><p>In order to emulate the homomorphic evaluation procedure of the previous sections, there are two steps we must modify: First, we must provide a means for pairing a BHHO ciphertext of an input w with additive secret sharings of a value x to obtain a multiplicative secret sharing of g wx . For ElGamal this was done given x and cx , and computing h</p><formula xml:id="formula_22">x 2 h -cx 1</formula><p>. Now, for BHHO, we can perform an analogous "partial decryption" procedure given shares x and { s i x } i∈[ ] , for the bits s i of the BHHO secret key. The corresponding pairing computation is given as MultShares in Fig. <ref type="figure" target="#fig_3">5</ref>.</p><p>Once we obtain a multiplicative secret sharing of g wx , we can perform the same share-conversion procedure DistributedDLog from the previous sections to  return to an additive secret sharing of wx (with some error probability δ). But, to be able to perform a future pairing as above, we additionally must generate additive secret sharings wxs i for each of the bits s i of the secret key (analogous to generating cwx in the ElGamal case). Conveniently, this BHHO task is actually slightly simpler than that for ElGamal: whereas before we had to deal with the large size of the secret key c ∈ Z q by operating on a bit decomposition of c and then reconstructing, here the secret key (s 1 , . . . , s ) is already interpreted as a binary vector. This means we can perform the multiplication steps directly without requiring the decomposition/reconstruction steps.</p><p>We remark that BHHO ciphertexts are multiplicatively homomorphic in the same fashion as ElGamal, which allows us to obtain a public-key variant of the secret sharing scheme precisely as in the previous section. The required procedure of modifying a ciphertext of some message x to one encrypting xy given y is explicitly described as ([[x]] s ) y in Fig. <ref type="figure" target="#fig_3">5</ref>.</p><p>In Fig. <ref type="figure" target="#fig_3">5</ref>, we provide the modified notation and pairing procedures for this setting. The remaining notations x , x and pairing operation ConvertShares will remain as in the previous sections (Fig. <ref type="figure" target="#fig_0">1</ref>). Given these sub-procedures, we present in Figs. <ref type="figure" target="#fig_4">6</ref> and<ref type="figure" target="#fig_5">7</ref> the corresponding algorithms Gen, Enc, Eval. The resulting share size is roughly λ times larger than in the previous section, as BHHO ciphertexts are λ + 1 group elements in comparison to ElGamal which is 2. We refer the reader to the full version for a full proof of the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 4 (DEHE from DDH).</head><p>Assuming DDH, then the scheme (Gen, Enc, Eval) as given in Figs. 6, 7 is a secure Distributed-Evaluation Homomorphic Encryption scheme for the class of deterministic branching programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Applications</head><p>In this section we describe applications of our homomorphic secret sharing scheme and its public-key variant in the context of secure computation. We restrict attention to security against semi-honest parties; to obtain similar asymptotic efficiency in the presence of malicious parties, one can apply generalpurpose compilation techniques <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b29">30]</ref>. For lack of space, formal protocol descriptions and security proofs are postponed to the full version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Succinct Protocols for Branching Programs</head><p>Our protocols for branching programs can be based either on the weaker HSS primitive via the transformation from <ref type="bibr" target="#b5">[6]</ref>, or can be built more directly from the public-key variant. We present here the latter approach, which is more direct. For simplicity, we restrict attention to the case of evaluating a single branching program P on inputs x 0 , x 1 held by Party 0 and Party 1 respectively. This can be extended in a straightforward way to functions with m bits of output that are computed either by m separate branching programs or by a single RMS program. The simplest protocol proceeds as follows. The two parties run a generalpurpose protocol (such as Yao's protocol) to jointly evaluate the key generation Gen. In the end of this sub-protocol, both parties hold a public key pk and each holds a secret evaluation key ek b . While this step may be expensive, its complexity depends (polynomially) only on the security parameter λ, and moreover the same key setup can be used for evaluating an arbitrary number of branching programs on an arbitrary number of inputs. In this basic version of the protocol, the key generation protocol is the only step that does not make a black-box use of the underlying DDH group.</p><p>Next, each party uses Enc(pk, •) to encrypt every bit of its input, and sends the encryptions to the other party. Finally, the two parties locally run Eval to generate additive (mod-2) shares of the output P (x 0 , x 1 ). If Eval had negligible error, the parties could simply exchange their shares of the output, since the share sent to Party b is determined by the output and the share computed by Party b.</p><p>The fact that Eval has a non-negligible error δ is problematic for two reasons. First, it poses a correctness problem. This can be fixed by setting δ to be a constant (say, δ = 1/4), running σ independent instances of Eval, for a statistical security parameter σ, 5 and outputting the majority value. However, this modification alone will not suffice, because the existence of errors within the homomorphic evaluation is dependent on the computation values, and as such the σ output bits may leak information about the inputs. Instead, the parties apply the σ instances of Eval locally (as before), and distribute the reconstruction function (computing majority of XORs) using general-purpose secure computation. This ensures that only the correct output is revealed (and no further information) with negligible correctness and secrecy error.</p><p>The communication complexity of the above protocol is n • poly(λ), where n = |x 0 | + |x 1 | is the combined length of the two parties' inputs. This can be improved to n+poly(λ) by using the following hybrid encryption techniques <ref type="bibr" target="#b19">[20]</ref>. Let F r be a pseudorandom function computable in NC 1 , which can be based on DDH <ref type="bibr" target="#b30">[31]</ref>. Following the key generation phase, each party encrypts a random key r b for F . Then, instead of separately encrypting each bit of x b using Enc, Party b simply masks each bit i of its input using F r b (i) and sends to the other party the encryption of r b and all of the masked bits. The value of program P on the inputs can now be expressed as the value of a (polynomially larger) publicly known branching program P on the inputs r 0 , r 1 , where P is determined by P and the masked inputs. The evaluation of P is repeated σ times as before. This yields the following: Theorem 5. Under the DDH assumption, there exists a constant-round secure 2-party protocol for evaluating branching programs of size S on inputs (x 0 , x 1 ) of total length n, using n + poly(λ) bits of communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Breaking the Circuit Size Barrier for "Well Structured" Circuits</head><p>We turn to the question of reducing the communication complexity of evaluating a deep boolean circuit C of size S and depth D. We assume for simplicity that the circuit is layered in the sense that its S gates can be partitioned into D + 1 layers such that the gates from layer i (except input gates) receive their inputs from gates of layer i -1. This can be generalized to a broader class of "wellstructured" circuits that captures most instances of circuits that arise naturally. 5 Here we assume that the events of error in different instances of Eval are independent. This can be enforced by using a fresh set of pseudorandom values for each share conversion.</p><p>Given a layered circuit as above, we divide the layers into intervals of log S consecutive layers, and pick for every interval the layer that has the smallest number of gates (except for the input layer). Overall, we have at most D/ log S "special" layers, whose total size is at most S/ log S. In addition, the output layer is considered the last special layer.</p><p>The crucial observation is that each output of a new special layer can be expressed as a circuit of depth O(log S) applied to values of the previous special layer. The protocol will compute the values of the special layers one at a time, by using the previous protocol for branching programs, except that the reconstruction protocol is only applied in the end. That is, given additive shares of special layer i, each party encrypts his shares and the parties apply Eval on a function (computable by polynomial-size branching programs) that first reconstructs the value and then computes the outputs of special layer i + 1.</p><p>To avoid a multiplicative factor of σ in communication, we need to apply a more efficient error correction procedure for intermediate layers. To this end, we apply an asymptotically good error-correcting code, with encoding and decoding in NC 1 , for encoding the values of each special layer. (Many such codes are known to exist; see, e.g., <ref type="bibr" target="#b33">[34]</ref>; moreover, by using a Las-Vegas type algorithm for the share conversion it suffices to correct erasures.) The computation performed by Eval will start by reconstructing the noisy encoding of layer i (using XOR), then apply a decoder to recover the actual values of layer i, then compute the outputs of layer i + 1, and then encode these outputs. If the error probability δ of Eval is smaller than the relative error correction radius of the code, the error rate in the encoded output will be within the error-correction radius with overwhelming probability. Thus, we can use a general-purpose protocol for decoding the correct outputs from the shared noisy encoding. This approach yields the following theorem. Theorem 6. Under the DDH assumption, there exists a secure 2-party protocol for evaluating any layered boolean circuit of size S, depth D, input length n, and output length m using O(S/logS) + O(Dσ/ log D) + n + m • poly(λ) bits of communication (for σ, λ statistical and computational security parameters).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Function Secret Sharing and Generalized PIR</head><p>Function Secret Sharing. As discussed in the Introduction, homomorphic secret sharing can be viewed as a "dual" notion of function secret sharing, as defined in <ref type="bibr" target="#b5">[6]</ref>. In a homomorphic secret sharing scheme for a class of programs P, given a share of a secret input w and a public program P ∈ P, one can locally compute a share of Π(w). In a function secret sharing (FSS) scheme for function class F, given a share of a secret function (represented by a "program"') and a public input x, one can locally compute a share of f (x). In particular, given a homomorphic secret sharing scheme supporting a class of programs P containing a universal program U , one can directly obtain a FSS scheme for P, by secret sharing a description of the secret program P ∈ P, and then shares of the evaluation of P on an input x can be obtained by homomorphically evaluating the universal program U x (•) on the given shares. If for each program P ∈ P the homomorphic secret sharing scheme produces output error on the evaluation of P with probability δ (over the randomness of the secret sharing), then for each input x in the domain of f , the resulting FSS scheme will also yield an output error with probability δ.</p><p>Thus, as a corollary of our homomorphic secret sharing scheme, we obtain a DDH-based FSS scheme for branching program with an arbitrary inverse polynomial error. The resulting FSS key size corresponds to the size of a homomorphic secret share of a description of the secret function: namely, a fixed polynomial in the size of the branching program S and security parameter λ.</p><p>Private Information Retrieval. A motivating application regime of function secret sharing (and thus our homomorphic secret sharing scheme) is that of 2-server private information retrieval (PIR) for expressive query classes <ref type="bibr" target="#b5">[6]</ref>. As we demonstrate, such applications can be achieved with negligible error even when starting with FSS with inverse-polynomial error δ. Together with our construction of such δ-FSS, this gives us DDH-based 2-server PIR for queries expressed by branching programs. Useful examples include counting or retrieving matches that are specified by conjunction queries or fuzzy match predicates (e.g., requiring that a document contains at least a given threshold of keywords from a given list).</p><p>A (standard) FSS scheme for a program class P can be used to obtain secure 2-server PIR schemes for classes of queries related to P, via three basic steps. For simplicity, we focus our treatment to querying the count of database entries satisfying a (secret) predicate f ∈ F. <ref type="foot" target="#foot_4">6</ref> (1) The client generates FSS shares P 0 , P 1 of the desired query P and sends one share to each server. (2) The servers locally compute, and reply with, the linear combination x∈DB P b (x) for database DB (where the output group of P, P 0 , P 1 is Z N for N = |DB|). (3) Then, leveraging the linearity of FSS reconstruction, the client can recover the desired output x∈DB P (x) = x∈DB P 0 (x) + x∈DB P 1 (x). To extend this approach to δ-FSS, we execute several independent parallel instances of the δ-FSS scheme, and compute the majority of the resulting execution outputs. Note that here, unlike the secure computation application, there is no danger of releasing the (potentially noisy) outcomes of the parallel executions directly, as no hiding guarantees are required against the PIR client.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Examples and Optimizations</head><p>We now introduce several optimizations and trade-offs between computation and communication within our HSS construction, and describe their applications within two examples of using homomorphic secret sharing. We first consider a toy example of a client who computes the AND of n bits x 1 , . . . , x n by homomorphic secret sharing. We then describe a partial match search in a PIR setting. All the examples and optimizations within this section assume the circular security of ElGamal.</p><p>The communication of our homomorphic secret sharing scheme is dominated by the + 1 ElGamal ciphertexts, or 2( + 1) group elements encoding each input bit (where = log 2 |G| for DDH group G). The computation is dominated by running MultShares and ConvertShares + 1 times for each product of a memory variable and input variable.</p><p>MultShares consists of raising a group element to the power of a secret share, which given a sliding window implementation requires less than 3 /2 group operations. The computation time of ConvertShares with target error δ and maximum difference between two shares M is dominated by 4M ln(4/δ ) δ group operations. Consider the following optimizations and trade-offs.</p><p>1. Ciphertext description reduction. The first optimization is heuristically secure (or alternatively, secure in the random oracle model) and uses a PRG G : {0, 1} → G +1 to reduce the communication by almost half. Let G(σ) = (g r , g r1 , . . . , g r ) for a seed σ ∈ {0, 1} . To encode an input bit, instead of sending + 1 complete ElGamal ciphertexts, a party will now send (a random) σ and the + 1 group elements (g rc+wi , g r1c+wic1 , . . . , g r c+wic ), corresponding to the second terms of the prescribed ciphertexts, using the outputs of G(σ) implicitly as the first terms. Given this information, each party can locally generate the full + 1 ciphertexts, and compute as before. ConvertShares potentially induces an error in one of two situations (these are the two error cases in the proof of Proposition 1) which can both be identified by the second party. In the proposed optimization, the second party outputs a flag indicating failure in each of these cases. The client is sure that the result is correct if the second player does not return a failure. Given target error probabilities δ for the whole protocol and, e.g., 1/4 for a single execution, we require that the number of independent executions of the algorithm γ satisfies (1/4) γ &lt; δ, or γ &gt; ln 1/δ ln 4 . Note that this optimization may reveal to the client information on intermediate computation values, since errors are input dependent. However, this type of leakage is harmless for applications like PIR. Homomorphic n-bit AND. In the first (toy) example application, the communication complexity is dominated by 2( + 1)n group elements, to encode n bits. The operations are n -1 homomorphic evaluations of AND of bits, which amount to less than n applications of MultShares and ConvertShares or a total of less than 3n </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Notation for components of the homomorphic secret sharing scheme, and pairing operations for transforming between different components.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Share generation procedure Share G,g for secret sharing an input w via the homomorphic secret sharing scheme.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Construction of "public-key" variant of homomorphic secret sharing: i.e., homomorphic encryption with distributed evaluation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Modified DDH-based notation and pairing operations, making use of BHHO encryption [5].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. DDH-based homomorphic encryption with distributed evaluation, making use of the BHHO cryptosystem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7.Procedures for performing homomorphic operations on secret shares. Here, notation y is used to represent this party's share of the corresponding subtractive secret shared pair. Evaluation maintains the invariant that each of the additive secret shares yi encode the correct current computation value of ŷi.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>2 . 1 j=0 c j 2 j in base 2 to - 1 j=0</head><label>211</label><figDesc>Modified key representation. A trade-off reducing communication and increasing computation is possible by changing the representation of the key c from c j B j in base B = 2 b for some b &gt; 1. Communication complexity and the number of MultShares and ConvertShares are reduced by a factor of b, as the encryptions of {c j w i } j∈[ ] encoding input w i can be replaced by encryptions of {c j w i } j ∈[ ] . However, in ConvertShares the possible difference M between the shares held by the two parties (equivalently, the size of encoded values) increases from 1 to B -1, increasing the computation time by a factor of B -1. 3. Las-Vegas algorithm. A Las-Vegas type algorithm for share conversion can be used to relax the target error probability and reduce the computation time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>4 .</head><label>4</label><figDesc>Breaking computation into chunks. The final trade-off increases communication and decreases computation by breaking the computation into "chunks" and encrypting (and communicating) the input to each chunk separately. Loosely speaking, if the computation is split into ζ chunks, then the required communication increases by a factor of ζ, and computation is reduced by a factor of ζ because the quadratic overhead in computing n gates is reduced to ζ times computing a quadratic overhead in n/ζ gates. In general this method requires up to ζ communication rounds, but in certain applications (like PIR) it does not require additional interaction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>2 2 +</head><label>2</label><figDesc>4n 2 ln 4n/δ δ group operations. In this example, communication is minimized by using the ciphertext reduction optimization and by representing c in base B = 2 b . Communication complexity is about ( +1)n b group elements and computation is dominated by 3n 2 2b 2 + 4Bn 2 ln 4n/δ bδ group operations. Computation is minimized using ciphertext reduction, the Las-Vegas algorithm, and breaking into chunks. The communication complexity is increased by a factor of ζ for each of the ln 1/δ ln 4 invocations of the Las Vegas algorithm or ln 1/δ ln 4 ζn group elements altogether. The computation requires at most ln 2PC formula evaluation. The second example is a two-party computation of a formula ψ. This application requires the public-key variant of our protocol. The unoptimized version of this protocol is roughly similar in performance to the unoptimized version of homomorphic secret sharing. However, two of the optimizations, ciphertext reduction and the Las-Vegas algorithm do not apply in this case. Communication can be minimized by representing c in base B, reducing communication by log B and increasing computation by B compared to the unoptimized version. Computation can be minimized by breaking ψ into ζ chunks increasing communication by ζ and reducing computation by ζ compared to the unoptimized version.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In the homomorphic encryption for branching programs from<ref type="bibr" target="#b24">[25]</ref> (see also<ref type="bibr" target="#b25">[26]</ref>), the size of the encrypted output must grow with the length of the branching program. When simulating a boolean formula by a branching program, the length of the branching program is typically comparable to the formula size.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>While one can always switch between the notions by changing the definition of F , for classes F that contain universal functions[13,  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p><ref type="bibr" target="#b34">35]</ref> the switch can be done with polynomial overhead without changing F . This will be the case for all function classes considered in this work.<ref type="bibr" target="#b2">3</ref> In fact, our construction can handle a larger class of arithmetic branching programs over the integers, but correctness only holds as long as all integers involved in intermediate computations are bounded by some fixed polynomial.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Ideally, such a sparse subset would include each g ∈ G independently with probability δ. To emulate this efficiently we include each g ∈ G in G if φ(g) = 0 log 1/δ , where φ is a pseudorandom function.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_4"><p>Using sketching or coding techniques (e.g.,<ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b31">32]</ref>), this approach can be extended to recovery of data entries satisfying a hidden predicate.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. We thank an anonymous reviewer for pointing out the relevance of <ref type="bibr" target="#b37">[37]</ref>.</p><p>Research done in part while visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467. Supported by ERC starting grant 259426. First author was additionally supported by ISF grant 1709/14 and ERC starting grant 307952. Second author was additionally supported by ISF grant 1638/15, a grant by the BGU Cyber Center, the Israeli Ministry Of Science and Technology Cyber Program and by the European Union's Horizon 2020 ICT program (Mikelangelo project). Third author was additionally supported by ISF grant 1709/14, BSF grant 2012378, a DARPA/ARL SAFEWARE award, NSF Frontier Award 1413955, NSF grants 1228984, 1136174, 1118096, and 1065276. This material is based upon work supported by the Defense Advanced Research Projects Agency through the ARL under Contract W911NF-15-C-0205. The views expressed are those of the author and do not reflect the official policy or position of the Department of Defense, the National Science Foundation, or the U.S. Government.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multiparty computation with low communication, computation and interaction via threshold FHE</title>
		<author>
			<persName><forename type="first">G</forename><surname>Asharov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>López-Alt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2012</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Pointcheval</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Johansson</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7237</biblScope>
			<biblScope unit="page" from="483" to="501" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Share conversion and private information retrieval</title>
		<author>
			<persName><forename type="first">A</forename><surname>Beimel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Orlov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CCC</title>
		<meeting>CCC</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="258" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Completeness theorems for noncryptographic fault-tolerant distributed computation (extended abstract)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Evaluating 2-DNF formulas on ciphertexts</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E.-J</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2005</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3378</biblScope>
			<biblScope unit="page" from="325" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Circular-secure encryption from decision Diffie-Hellman</title>
		<author>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2008</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5157</biblScope>
			<biblScope unit="page" from="108" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Function secret sharing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Boyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2015</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9057</biblScope>
			<biblScope unit="page" from="337" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Efficient fully homomorphic encryption from (standard) LWE</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multiparty unconditionally secure protocols (extended abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedigs of STOC</title>
		<meeting>eedigs of STOC</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="11" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Computationally private information retrieval (extended abstract)</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 29th Annual ACM Symposium on the Theory of Computing</title>
		<meeting>29th Annual ACM Symposium on the Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="304" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Private information retrieval by keywords</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Private information retrieval</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="965" to="981" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multi-identity and multi-key leveled fhe from learning with errors</title>
		<author>
			<persName><forename type="first">M</forename><surname>Clear</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mcgoldrick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2015</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Robshaw</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9216</biblScope>
			<biblScope unit="page" from="630" to="656" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A depth-universal circuit</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hoover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="833" to="839" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Share conversion, pseudorandom secretsharing and applications to secure computation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">B</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2005</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Kilian</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3378</biblScope>
			<biblScope unit="page" from="342" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Spooky encryption and its applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Rothblum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">272</biblScope>
			<date type="published" when="2016">2016. 2016. 2016</date>
		</imprint>
	</monogr>
	<note>To appear in Crypto</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">3-query locally decodable codes of subexponential length</title>
		<author>
			<persName><forename type="first">K</forename><surname>Efremenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="39" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Secure multiparty computation of approximations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Feigenbaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Malkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2001</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Orejas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Spirakis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2076</biblScope>
			<biblScope unit="page" from="927" to="938" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Private stream search at the same communication cost as a regularsearch: role of LDPC codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Finiasz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ISIT</title>
		<meeting>ISIT</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2556" to="2560" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption using ideal lattices</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using fully homomorphic hybrid encryption to minimize non-interative zero-knowledge proofs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptol</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="820" to="843" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Homomorphic encryption from learning with errors: conceptually-simpler, asymptotically-faster, attribute-based</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sahai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2013, Part I</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Garay</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8042</biblScope>
			<biblScope unit="page" from="75" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Distributed point functions and their applications</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gilboa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2014</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">Q</forename><surname>Nguyen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8441</biblScope>
			<biblScope unit="page" from="640" to="658" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">How to play any mental game or a completeness theorem for protocols with honest majority</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Bootstrapping for HElib</title>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2015</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Oswald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9056</biblScope>
			<biblScope unit="page" from="641" to="670" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Evaluating branching programs on encrypted data</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Paskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC 2007</title>
		<editor>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Vadhan</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4392</biblScope>
			<biblScope unit="page" from="575" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Optimal rate private information retrieval from homomorphic encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kiayias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leonardos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pavlyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PoPETs</title>
		<imprint>
			<biblScope unit="volume">2015</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="222" to="243" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Replication is NOT needed: SINGLE database, computationally-private information retrieval</title>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FOCS 1997</title>
		<meeting>FOCS 1997</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="364" to="373" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On-the-fly multiparty computation on the cloud via multikey fully homomorphic encryption</title>
		<author>
			<persName><forename type="first">A</forename><surname>López-Alt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC 2012</title>
		<meeting>STOC 2012</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1219" to="1234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Two round multiparty computation via multi-key FHE</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mukherjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wichs</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-49896-5_26</idno>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2016</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9666</biblScope>
			<biblScope unit="page" from="735" to="763" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Communication preserving protocols for secure function evaluation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nissim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="590" to="599" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Number-theoretic constructions of efficient pseudo-random functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FOCS</title>
		<meeting>FOCS</meeting>
		<imprint>
			<biblScope unit="volume">997</biblScope>
			<biblScope unit="page" from="458" to="467" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Private searching on streaming data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ostrovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename><surname>Skeith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO 2005</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3621</biblScope>
			<biblScope unit="page" from="223" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">On data banks and privacy homomorphisms</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Adleman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Dertouzos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations of Secure Computation</title>
		<imprint>
			<biblScope unit="page" from="169" to="179" />
			<date type="published" when="1978">1978</date>
			<publisher>Academic</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Linear-time encodable and decodable error-correcting codes</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Spielman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1723" to="1731" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Universal circuits (preliminary report)</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC 1976</title>
		<meeting>STOC 1976</meeting>
		<imprint>
			<date type="published" when="1976">1976</date>
			<biblScope unit="page" from="196" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Fully homomorphic encryption over the integers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vaikuntanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2010</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Gilbert</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6110</biblScope>
			<biblScope unit="page" from="24" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<pubPlace>Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Parallel collision search with cryptanalytic applications</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Wiener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptol</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="28" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">How to generate and exchange secrets (extended abstract)</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FOCS</title>
		<meeting>FOCS</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="162" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Towards 3-query locally decodable codes of subexponential length</title>
		<author>
			<persName><forename type="first">S</forename><surname>Yekhanin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of STOC</title>
		<meeting>STOC</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="266" to="274" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
