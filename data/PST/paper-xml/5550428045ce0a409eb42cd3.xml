<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Revisiting the Complexity of Hardware Cache Coherence and Some Implications</title>
				<funder>
					<orgName type="full">DARPA</orgName>
				</funder>
				<funder>
					<orgName type="full">Center for Future Architectures Research (C-FAR</orgName>
				</funder>
				<funder>
					<orgName type="full">Qualcomm Innovation Fellowship</orgName>
				</funder>
				<funder>
					<orgName type="full">Microsoft</orgName>
				</funder>
				<funder ref="#_3jczwAx #_UkzfnHE">
					<orgName type="full">National Science Foundation</orgName>
				</funder>
				<funder ref="#_tVYgH2j">
					<orgName type="full">International Conference on Architectural Support for Programming Languages and Operating Systems</orgName>
				</funder>
				<funder>
					<orgName type="full">MARCO</orgName>
				</funder>
				<funder ref="#_xDYFWYu #_U5Xy8NC #_A9CUxrV #_unvgtm6 #_5TwsF2B #_WkhN5fD #_tSDKkMr #_CMzWVpr #_TR2dEmb #_PgRbX9q #_SUMRGZX #_6zHdnkr #_dbFFw3t #_9s3rYub #_TunDpFY #_7AZBGD8 #_RFxyNdz #_HY85GQt #_2aVYJRb">
					<orgName type="full">unknown</orgName>
				</funder>
				<funder ref="#_QbH5ZXB #_3EDbNwr">
					<orgName type="full">International Conference on Parallel and Distributed Computing. Information Processing Society, Tokyo, Japan</orgName>
				</funder>
				<funder>
					<orgName type="full">Intel</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rakesh</forename><surname>Komuravelli</surname></persName>
						</author>
						<author role="corresp">
							<persName><forename type="first">Sarita</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
							<email>sadve@illinois.edu</email>
						</author>
						<author>
							<persName><forename type="first">N</forename><surname>Goodwin</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Illinois at Urbana-Champaign CHING</orgName>
								<orgName type="institution" key="instit2">TSUN CHOU</orgName>
								<orgName type="institution" key="instit3">Intel Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<postCode>61801</postCode>
									<settlement>Urbana</settlement>
									<region>IL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Intel Corporation</orgName>
								<address>
									<addrLine>3600 Juliette Lane</addrLine>
									<postCode>95054</postCode>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Publications Dept</orgName>
								<orgName type="institution">ACM, Inc</orgName>
								<address>
									<addrLine>2 Penn Plaza, Suite 701</addrLine>
									<settlement>New York</settlement>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Revisiting the Complexity of Hardware Cache Coherence and Some Implications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/2663345</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-01-03T09:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>B.3.2 [Design Styles]: Cache memories</term>
					<term>B.3.2 [Design Styles]: Shared memory</term>
					<term>B.3.3 [Performance Analysis and Design Aids]: Formal models</term>
					<term>C.0 [General]: Modeling of computer architecture Design, Performance, Verification Cache coherence, multicore, shared memory, software-hardware co-design, protocol verification, model checking</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Cache coherence is an integral part of shared-memory systems but is also widely considered to be one of the most complex parts of such systems. Much prior work has addressed this complexity and the verification techniques to prove the correctness of hardware coherence. Given the new multicore era with increasing number of cores, there is a renewed debate about whether the complexity of hardware coherence has been tamed or whether it should be abandoned in favor of software coherence. This article revisits the complexity of hardware cache coherence by verifying a publicly available, state-of-the-art implementation of the widely used MESI protocol, using the Mur? model checking tool. To our surprise, we found six bugs in this protocol, most of which were hard to analyze and took several days to fix. To compare the complexity, we also verified the recently proposed DeNovo protocol, which exploits disciplined software programming models. We found three relatively easy to fix bugs in this less mature protocol. After fixing these bugs, our verification experiments showed that, compared to DeNovo, MESI had 15X more reachable states leading to a 20X increase in verification (model checking) time. Although we were eventually successful in verifying the protocols, the tool required making several simplifying assumptions (e.g., two cores, one address). Our results have several implications: (1) they indicate that hardware coherence protocols remain complex;</p><p>(2) they reinforce the need for protocol designers to embrace formal verification tools to demonstrate correctness of new protocols and extensions; (3) they reinforce the need for formal verification tools that are both scalable and usable by non-expert; and (4) they show that a system based on hardware-software co-design can offer a simpler approach for cache coherence, thus reducing the overall verification effort and allowing verification of more detailed models and protocol extensions that are otherwise limited by computing resources.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Shared memory continues to be one of the most widely used parallel programming models due to the advantages offered by a global address space. Today's multicores directly support shared memory and form the heart of a variety of computing systems, ranging from smartphones to data centers to the largest supercomputers. One of the main challenges of shared memory hardware is to keep caches coherent, and this is usually addressed by hardware cache coherence protocols. Traditionally, a major problem with such protocols has been that they have been extremely complex, and implementing bug-free protocols has been a challenge <ref type="bibr" target="#b1">[Abts et al. 2003</ref>]. Increasing on-chip core counts in manycores exacerbates this problem because it demands moving to variants of directory-based protocols. Methods like trace-driven or other simulationbased testing are insufficient for ensuring the correctness of such complex protocols since they often do not hit the difficult corner cases. Formal verification techniques have therefore been proposed and deployed to prove the correctness of these protocols <ref type="bibr" target="#b0">[Abts et al. 2000;</ref><ref type="bibr" target="#b16">Burckhardt et al. 2005;</ref><ref type="bibr" target="#b23">Gjessing et al. 1989;</ref><ref type="bibr">McMillan and J. 1991;</ref><ref type="bibr">Nanda and Bhuyan 1992;</ref><ref type="bibr">Park and Dill 1995;</ref><ref type="bibr">Pong et al. 1998</ref>].</p><p>Over the past several decades, there has been much experience accumulated in both designing cache coherence protocols and building formal methods based tools to verify them. Nevertheless, as the number of cores on a chip grows, the power, performance, and area inefficiencies of hardware cache coherence (e.g., directory storage, indirection through the directory, invalidation and acknowledgment messages, false sharing, cache line based granularities, and so on) are potential obstacles to scalability. To reduce these inefficiencies, researchers continue to propose enhancements to basic coherence protocols-these enhancements typically come at the cost of even further complexity <ref type="bibr" target="#b39">[Zebchuk et al. 2009;</ref><ref type="bibr" target="#b42">Zhao et al. 2013]</ref>.</p><p>There is a debate in the community about whether we have tamed the complexity of hardware cache coherence enough to continue building increasingly larger hardware cache coherent systems or whether we must abandon hardware coherence in favor of other alternatives. Thus, on the one hand, companies like Tilera have built hardware cache coherent systems with as many as 64 cores, making the resulting familiar programming model a key differentiator for their product line. A recent position paper makes the case that hardware coherence is here to stay <ref type="bibr">[Martin et al. 2012]</ref>. Other researchers continue to extend current protocols in new ways that make them even more complex <ref type="bibr" target="#b2">[Aisopos and Peh 2011]</ref>. On the other hand, Intel has recently built a 48-core Single-Chip Cloud Computer (SCC) <ref type="bibr" target="#b27">[IntelSCC 2009</ref>] that abandons hardware cache coherence, replacing it with software managed caches and their attendant programming complexity. Academic and industry researchers have also proposed systems that eliminate dependence on hardware coherence in various ways <ref type="bibr" target="#b14">[Borkar 2011;</ref><ref type="bibr" target="#b18">Choi et al. 2011;</ref><ref type="bibr" target="#b30">Kelm et al. 2009;</ref><ref type="bibr" target="#b33">Lin et al. 2012]</ref>.</p><p>In this article, we revisit the complexity of hardware cache coherence by asking the following questions. Has our experience with hardware cache coherence in the past few decades enabled us to conquer its complexity? If not, what are the implications for future system design?</p><p>To answer these questions, ideally, we would use an industry-strength cache coherence protocol specification and quantitative metrics for its complexity. Given the proprietary nature of industry protocols, we instead use a state-of-the-art, mature, publicly available protocol, the MESI protocol implemented in the Wisconsin GEMS simulation</p><p>Revisiting the Complexity of Hardware Cache Coherence and Some Implications 37:3 suite (version 2.1.1) <ref type="bibr" target="#b16">[Martin et al. 2005</ref>].<ref type="foot" target="#foot_1">1</ref> GEMS was released in 2005 and remains a widely used simulation package in the computer architecture community. Unfortunately, however, there are no currently accepted quantitative metrics to measure complexity. Instead, we report on our experiences verifying the GEMS MESI protocol using the Mur? model checking tool (version 3.1, slightly modified to exploit 64-bit machines) <ref type="bibr" target="#b21">[Dill et al. 1992;</ref><ref type="bibr">Ip and</ref><ref type="bibr">Dill 1993, 1996]</ref>. Although more advanced verification techniques exist, we chose Mur? for its easy-to-use interface and robustness. Mur? has also been the tool of choice for many hardware cache-related studies <ref type="bibr" target="#b0">[Abts et al. 2000;</ref><ref type="bibr" target="#b16">Burckhardt et al. 2005;</ref><ref type="bibr">Park and Dill 1995;</ref><ref type="bibr">Pong et al. 1998;</ref><ref type="bibr" target="#b41">Zhang et al. 2010]</ref>.</p><p>Our results from applying Mur? to the GEMS MESI protocol were surprising. We found six bugs in the protocol, even though it is a mature protocol used by a large number of architecture researchers. More significantly, some of these bugs involved subtle races and took several days to debug and fix. We contacted the developers of the GEMS simulation team with our bug findings in 2011. They had seen one of the six bugs, bug #4 in Section 4.1, but were surprised by the other bugs. Some of these bugs were also present in the GEM5 simulator <ref type="bibr" target="#b8">[Binkert et al. 2011]</ref>, an extension to the GEMS simulator that incorporates the M5 CPU core simulator, at that time. After we showed our fixes, the GEMS group fixed the bugs and released new patches. These fixes needed the addition of multiple new state transitions and extra buffer space for stalling requests in the protocol. After fixing the protocol, we were able to successfully run Mur?, but the tool required making several simplifying assumptions typical of such tools today (e.g., two cores, single cache line per core, and one address). With these assumptions, the verification process explored 1,257,500 reachable states and took 173 seconds using the default breadth-first search option of Mur?. We ran out of memory on our machine (with 32GB of RAM) when we tried to model a system containing two memory addresses.</p><p>Our conclusion from this experience is that hardware cache coherence protocols still remain difficult to design, understand, and prove correct. Although formal verification techniques have been embraced by industry, their use is not yet common practice for architecture researchers. Our results reinforce the need to use formal verification tools to assess the correctness and complexity of coherence protocols. Conversely, our work also motivates the need for verification tools that are scalable to larger systems and usable by non-expert.</p><p>An extreme solution to the hardware complexity problem is represented by the Intel SCC <ref type="bibr" target="#b27">[IntelSCC 2009</ref>]. The SCC eliminates the hardware complexity of cache coherence but imposes significant programming complexity due to the requirement of managing the caches in software. Recently, we proposed an alternate method, called DeNovo, that is based on a tighter hardware/software co-design approach <ref type="bibr" target="#b18">[Choi et al. 2011]</ref>. For easier programmability, this approach espouses disciplined shared-memory programming languages that eliminate data races by design, provide determinism-by-default, and provide safe nondeterminism only when explicitly requested. With a guarantee of datarace-freedom from software, DeNovo is able to avoid races in hardware and the resulting transient states and their complexity. The simplicity of the protocol, coupled with the disciplined software, provides performance and power advantages to DeNovo as well; furthermore, various enhancements (optimizations) can be incorporated without adding new states or transitions <ref type="bibr" target="#b18">[Choi et al. 2011]</ref>. We report our experiences with using Mur? to verify the DeNovo protocol and compare them with the MESI experiences.</p><p>To verify DeNovo, we first extended the canonical coherence protocol modeling technique in Mur? to model the software constraints that DeNovo hardware expects. In particular, this extension is able to guarantee the data-race-free property and a disciplined parallel phase behavior. Using this extension, we verified the base DeNovo protocol. Despite DeNovo's immaturity, we found only three bugs in the implementation. Furthermore, these bugs were simple to fix and turned out to be mistakes in translating the high level description of the protocol into the implementation (i.e., their solutions were already present in the internal high level description of the protocol). After fixing the bugs, we found that, compared to MESI, Mur? had to explore 15X fewer reachable states for DeNovo, taking 20X less time to fully model check DeNovo. It is difficult to define a metric to quantify the relative verification complexity of coherence protocols; nevertheless, our results demonstrate that hardware-software co-designed approaches like DeNovo can lead to much simpler protocols than conventional hardware cache coherence (while providing an easy programming model, extensibility, and competitive or better performance <ref type="bibr" target="#b18">[Choi et al. 2011]</ref>). <ref type="foot" target="#foot_3">2</ref>Overall, this article shows that despite the accumulated experience in designing hardware cache coherence, these protocols remain complex. It reinforces the need to use formal verification by protocol designers, motivating scalable and easy-to-use tools for non-experts. Finally, the article motivates hardware-software co-designed protocols that are much simpler to design and verify than pure hardware coherence and that exploit simpler programming models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">COMPLEXITY OF CACHE COHERENCE</head><p>Cache coherence is usually defined as a mechanism that ensures writes to the same memory location appear in the same order to all cores. In this section, we discuss two directory based protocols, the MESI protocol, which is based on a state-of-the-art implementation obtained from the publicly available GEMS simulator <ref type="bibr" target="#b16">[Martin et al. 2005]</ref>, and the recent DeNovo protocol <ref type="bibr" target="#b18">[Choi et al. 2011]</ref>, which is based on our own implementation. Without loss of generality, we assume a multicore system with n cores, private L1 caches, a shared L2 cache, and a general (nonbus, unordered) interconnect on chip.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">MESI</head><p>MESI, also known as the Illinois protocol <ref type="bibr">[Papamarcos and Patel 1984]</ref>, stands for Modi f ied (locally modified and no other cache has a copy), Exclusive (unmodified and no other cache has a copy), Shared (unmodified and some other caches may have a copy), and Invalid. Over the MSI protocol, the Exclusive state has the added advantage of avoiding invalidation traffic on write hits. For scalability, we assume a directory protocol <ref type="bibr" target="#b32">[Lenoski et al. 1992</ref>]. Given our shared (inclusive) L2 cache-based multicore, we assume a directory entry per L2 cache line, referred to as an in-cache directory <ref type="bibr" target="#b17">[Censier and Feautrier 1978]</ref>. We use L2 and directory interchangeably.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows the simple textbook state transition diagram for an L1 cache with the MESI protocol. The L2 cache also has four (textbook) states: L1 Modi f ied (modified in a local L1), L2 Modi f ied (modified at L2 and not present in any L1), Shared (valid data at L2 and present in one or more L1s), and Invalid. It also has a dirty bit (set on receiving a writeback from L1) that indicates whether data is dirty or not. When in Shared state, the L2/directory contains the up-to-date copy of the cache block data along with a list of sharers. On a read miss request, the directory services the request Revisiting the Complexity of Hardware Cache Coherence and Some Implications 37:5 if it has the up-to-date copy, or else it forward the request to the core that has the exclusive or modified copy. On a write miss or upgrade request, the directory sends invalidation requests to all the sharers (if any). If a request misses in the L2, the block is fetched from the main memory.</p><p>In reality, this seemingly simple protocol is a lot more complex. The hardware implementation of the protocol has many transient states in addition to the four states just described. These transient states lead to various subtle races and are the root cause of complexity in the protocol. We now illustrate the need for transient states with an example. Figure <ref type="figure" target="#fig_1">2</ref>(a) shows a code snippet with two parallel phases accessing a shared variable A. <ref type="foot" target="#foot_5">3</ref>In the first phase, cores P2 through Pn read the shared variable A, and, in the second phase, core P1 writes to A. In this example, we focus mainly on the state transitions related to this write by core P1.</p><p>Figure <ref type="figure" target="#fig_1">2</ref>(b) shows the timeline of the state transitions at both the individual L1s and the L2. Figure <ref type="figure" target="#fig_1">2(c</ref>) and (d) show the state transition table for L1 and L2, respectively, for the states encountered in this example. The names of the states and the events are taken directly from the GEMS implementation. At the beginning of the second phase, cores P2 through Pn are in Shared state and they are recorded in the sharer list at the directory. On receiving the write request, L1 P1 issues a GETX request to L2 and transitions to the first transient state, I M, where it awaits the data response from L2. L2, on receiving the GETX request, sends the data response (including the number of Acks to expect) to L1 P1 ; sends invalidation requests to all the sharers (L1 P2 through L1 Pn ); and then transitions to a transient state, SS MB, where it awaits an unblock message from the original requestor indicating the completion of the request. L1 P1 , on receiving the data response from L2, transitions to the second transient state, SM, where it waits for all the Ack messages from the sharers. Every sharer, then, on receiving the invalidation message from L2, transitions to the Invalid state and responds directly to the requestor, L1 P1 , with an Ack message. When L1 P1 receives the last Ack message (Ack all event), it transitions to the Modi f ied state and unblocks L2 by sending an Exclusive U nblock message. Other cases (e.g., some of the Acks arriving at L1 P1 before it receives the data response from L2, etc.) are covered in the state This example illustrates the need for transient states and the additional complexities introduced by them in the MESI protocol. The larger the number of transient states, the more complex the protocol becomes. In the GEMS implementation of the MESI protocol, there are 7 transient states in L1 and 14 transient states in L2. Optimizations to the described baseline protocol usually incur additional transient states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">DeNovo</head><p>One of the main difficulties in writing and debugging parallel programs is data races. These software data races are also responsible for races in hardware with conventional hardware cache coherence protocols. These hardware races are directly responsible for most transient states in hardware protocols, and they form the root cause of much of the complexity in such protocols.</p><p>There has been a lot of software work on disciplined shared-memory programming models <ref type="bibr" target="#b4">[Anderson et al. 2008;</ref><ref type="bibr" target="#b24">Gustafsson 2009;</ref><ref type="bibr" target="#b6">Berger et al. 2009;</ref><ref type="bibr" target="#b9">Blumofe et al. 1995;</ref><ref type="bibr" target="#b15">Budimlic et al. 2009;</ref><ref type="bibr" target="#b22">Ghuloum et al. 2007;</ref><ref type="bibr">Bocchino et al. 2011</ref><ref type="bibr">Bocchino et al. , 2009;;</ref><ref type="bibr">Olszewski et al. 2009;</ref><ref type="bibr" target="#b31">Kulkarni et al. 2007;</ref><ref type="bibr" target="#b3">Allen et al. 2009</ref>] to eliminate or alleviate the impact of data races, with the goal of providing better programmability, debuggability, and concurrency safety of parallel programs. Along with addressing the data race problem, much of this work also provides strong safety properties, such as determinism and various disciplined forms of nondeterminism, to simplify parallel programming. DeNovo is a hardware architecture that exploits the properties of such disciplined software</p><p>Revisiting the Complexity of Hardware Cache Coherence and Some Implications 37:7 programming models to additionally simplify hardware while also providing performance, power, and scalability benefits <ref type="bibr" target="#b18">[Choi et al. 2011</ref>].</p><p>2.2.1. Software Model. DeNovo currently uses Deterministic Parallel Java (DPJ) <ref type="bibr">[Bocchino et al. 2011</ref><ref type="bibr">[Bocchino et al. , 2009] ]</ref> as an example of a disciplined programming language to drive its design. DPJ is an extension to Java that provides properties like structured parallel control, data-race-freedom, and explicit specification of the effects of shared memory accesses. In a DPJ program, the programmer partitions the heap into named "regions" and annotates methods with summaries of read and write operations on these regions ("effects"). The DPJ compiler uses this region and effect information to guarantee determinism.</p><p>This article does not quantify software complexity; however, our software philosophy and DPJ are motivated entirely by the goal of reducing software complexity. Even today, the C++ <ref type="bibr" target="#b13">[Boehm and Adve 2008]</ref> and Java <ref type="bibr">[Manson et al. 2005</ref>] memory models do not provide any reasonable semantics for data races; therefore, a data race in these programs is a bug and imposes significant verification complexity. In contrast, DPJ provides strong safety guarantees of data-race-freedom and determinism-by-default. Programmers can reason about deterministic programs as if they were sequential. There is certainly an additional up-front burden of writing region and effect annotations in DPJ; however, arguably, this burden is mitigated by the lower debugging and testing time afforded by deterministic-by-default semantics. There is also ongoing work on partly automating the insertion of these annotations <ref type="bibr">[Vakilian et al. 2009</ref>]. Overall, there is a growing part of the community that is working toward similar goals of more disciplined programming practices <ref type="bibr" target="#b38">[WoDET 2013]</ref>.</p><p>In this article, we focus on the baseline DeNovo protocol <ref type="bibr" target="#b18">[Choi et al. 2011</ref>] targeted to deterministic codes based on the original DPJ language proposed in <ref type="bibr">Bocchino et al. [2009]</ref>. DPJ and DeNovo are ongoing projects that continue to incorporate support for increasingly wider classes of programs <ref type="bibr">[Bocchino et al. 2011;</ref><ref type="bibr">Bocchino and Adve 2011;</ref><ref type="bibr" target="#b25">Heumann et al. 2013;</ref><ref type="bibr">Sung et al. 2013</ref><ref type="bibr">Sung et al. , 2014]]</ref>. We discuss this ongoing work and implications for general codes in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2.">DeNovo</head><p>Hardware. DeNovo exploits disciplined language features for a more efficient, scalable, and simpler hardware. Specifically, structured parallel control and explicit read and write effect information enable caches to self-invalidate stale data (communicated through a compiler-inserted self-invalidate instruction for each region with write effects) and thus remove the need to maintain sharer lists and to send invalidation and acknowledgment messages. In addition, the data-race-freedom guarantee makes it possible to completely eliminate transient states from the cache coherence protocol and thus greatly reduce its complexity. As shown in <ref type="bibr" target="#b18">[Choi et al. 2011</ref>], these benefits do not compromise the performance of the DeNovo protocol; instead, they provide opportunities for improved performance and energy without increasing complexity.</p><p>The DeNovo protocol has three states at L1, Registered (locally modified), V alid, and Invalid. L2 has the same states, too, with obvious meaning. The handling of read requests is straightforward. On a write, if the line is not registered, L1 issues a registration request to L2 and transitions to Registered state immediately because there are no races in the program. Similar to MESI, DeNovo also has a dirty bit at L2, which is set to indicate dirty data. The complete state transition table and a detailed description of the DeNovo protocol can be found in <ref type="bibr" target="#b18">Choi et al. [2011]</ref>.</p><p>Let us revisit the code segment from Figure <ref type="figure" target="#fig_1">2</ref>. Figure <ref type="figure" target="#fig_2">3</ref>(a) shows the changes to the code required to prove data-race-freedom. Specifically, the shared variable A is placed in a region R A , both the parallel phases are annotated with read and write effect summaries, and, finally, a self-invalidation instruction is inserted at the end of the second phase.  Focusing again on the write instruction in the second phase, L1 P1 transitions directly to the Registered state without transitioning to any transient state and sends a registration request to L2. L2, on receiving the registration request, transitions to the Registered state. We do not show the registration response message from L2 here because it is not in the critical path and is handled by the request buffer at L1. As explained in <ref type="bibr" target="#b18">Choi et al. [2011]</ref>, the functionality of the request buffer is similar to that of a uniprocessor system and is invisible to the outside world. At the end of the phase, each core executes a self-invalidate instruction on region R A . This instruction triggers the invalidation of all the data in region R A in the L1 cache of its core (except for data in Registered state since this data is known to be up-to-date).</p><p>As an optimization, the L1 maintains an additional touched bit for each word. This bit is set on a read, indicating that this data will stay up-to-date until the end of the phase. This is guaranteed by data-race-freedom because there cannot be concurrent writers to the same location. The self-invalidation operation now skips invalidating the data that is both V alid and touched. These touched bits are reset at the end of the parallel phase.</p><p>This example illustrates how the absence of transient states makes the DeNovo protocol simpler than MESI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">MODELING FOR PROTOCOL VERIFICATION</head><p>We use the Mur? model checking tool <ref type="bibr" target="#b21">[Dill et al. 1992;</ref><ref type="bibr">Ip and</ref><ref type="bibr">Dill 1993, 1996]</ref> to verify the simple word-based protocols (equal address, communication and coherence granularity as explained in <ref type="bibr" target="#b18">Choi et al. [2011]</ref>) of DeNovo and MESI. We derived the MESI model from the GEMS implementation <ref type="bibr" target="#b16">[Martin et al. 2005]</ref>. We derived the DeNovo model from our implementation. To keep the number of states explored (by Mur?) tractable, as is common practice, we used a single address, single region (only for DeNovo), two data values, and two cores. We modeled private L1 caches, a unified</p><p>Revisiting the Complexity of Hardware Cache Coherence and Some Implications 37:9 Fig. <ref type="figure">4</ref>. State transitions for AccessStatus data structure in a given phase. An access for which there is no transition cannot occur and is dropped.</p><p>L2, an in-cache directory (for MESI), and an unordered full network with separate request and reply links. Both models allow only one request per L1 in the rest of the memory hierarchy. Because we modeled only one address, we modeled replacements as unconditional events that can be triggered at any time. To enable interactions across multiple parallel phases (cross-phase) in both the models, we introduced the notion of a phase boundary by modeling it as a sense-reversing barrier. Finally, we modeled the data-race-free guarantee for DeNovo by limiting conflicting accesses. We explain each of these attributes in detail in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Abstract Model</head><p>To reduce the amount of time and memory used in verification, we modeled the processors, addresses, data values, and regions as scalarsets <ref type="bibr" target="#b29">[Ip and Dill 1996]</ref>, a datatype in Mur? that takes advantage of the symmetry in these entitites while exploring the reachable states. A processor is modeled as an array of cache entries consisting of L1 state information along with protocol-specific fields like the region field and the touched bit for DeNovo. L1 state is one of three possible states for DeNovo or one of 11 possible states for MESI. Similarly, L2 is also modeled as an array of cache entries, each with L2 state information, a dirty bit, and other protocol-specific details like sharer lists for MESI. L2 state is one of three possible states for DeNovo or one of 18 possible states for MESI. Memory is modeled as an array of addresses storing data values.</p><p>3.1.1. Data-Race-Free Guarantee for DeNovo. To model the data-race-free guarantee from software for DeNovo, we used an additional data structure called AccessStatus. As shown in Figure <ref type="figure">4</ref>, this data structure maintains the current status (read, readshared, or written) and the core id of the last requestor for every address in the model. The current status and the last requestor determine the reads and writes that cannot occur in a data-race-free program and are thus disallowed in the model.</p><p>On any read, if it is the first access to this address in this phase, then status is set to read. If status is already set to read and the requesting core is not the same as the last requestor, then status is set to readshared. If status is readshared, then it stays the same on the read. If status is written and the requesting core is the same as the last requestor, it stays as written. On the other hand, if the requesting core is not the same as the last requestor, then this access is not generated in the model since it violates the data-race-freedom guarantee.</p><p>Similarly, on any write, if it is the first access to this address or if the requesting core is the same as the last requestor, then status is set to write. If status is either readshared or the requesting core is not the same as the last requestor, then this access is not generated to adhere to the data-race-free guarantee.</p><p>The AccessStatus data structure is reset for all the addresses at the end of a phase.</p><p>3.1.2. Cross-phase Interactions. We modeled the end of a parallel phase (and the start of the next phase) using a sense-reversing barrier implementation <ref type="bibr">[Mellor-Crummey and Scott 1991]</ref>. This event (end-of-phase) can be triggered at any time; that is, with no condition. The occurrence of end-of-phase is captured by a flag, release f lag. This event occurs per core and stalls the core from issuing any more memory requests until (1) all the pending requests of this core are completed (i.e., the L1 request buffer is empty), and (2) all other cores reach the barrier. The completion of end-of-phase is indicated by resetting the release f lag flag. Figure <ref type="figure" target="#fig_4">5</ref> shows the Mur? code for end-ofphase implementation for the DeNovo protocol. The spinwaiting flag indicates that the current core is waiting for other cores to reach the barrier. When a core enters the barrier for the first time, the local sense of the barrier (localsense) is reversed, thus indicating entering a new barrier; barrier count (barcount) is updated; and the spinwaiting flag is set. If it is the last one to enter the barrier, the core also notifies all other cores about the end of barrier by assigning barrier its localsense. It also resets the barcount and release f lag. Once a core reaches the barrier, we also modeled self-invalidations and unsetting touched bits for DeNovo. The code for MESI is similar except for DeNovo-specific operations like self-invalidation and unsetting touched bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Invariants</head><p>This section discusses the invariants we checked to verify the MESI and DeNovo protocols. The MESI invariants are based on prior work in verification of cache coherence protocols <ref type="bibr" target="#b21">[Dill et al. 1992;</ref><ref type="bibr">McMillan and J. 1991</ref>]. The DeNovo invariants are analogous as further described later. (Adding more invariants does not affect the verification time appreciably because the number of system states explored is still the same.) 3.2.1. MESI Invariants. We used five invariants to verify the MESI protocol <ref type="bibr" target="#b21">[Dill et al. 1992;</ref><ref type="bibr">McMillan and Schwalbe 1991]</ref>.</p><p>-Empty sharer list in Invalid state. This invariant asserts that the sharer list is empty when L2 transitions to Invalid state, and it ensures that there are no L1s sharing the line after L2 replaces the line. -Empty sharer list in Modified state. This invariant asserts that the sharer list is empty when L2 transitions to Modi f ied state. -Only one modifiable or exclusive cache copy. This invariant checks that there is only one cache copy in either Modi f ied or Exclusive state. It is also a violation for a cache line to be in both these states at the same time. -Data value consistency at L1. When L1 is in Shared state and L2 is also in Shared state, the data values should be the same at both L1 and L2. Indirectly, this invariant also makes sure that all the L1s have the same data value when in Shared state. -Data value consistency at L2. This invariant checks that when L2 is in Shared state and dirty bit is not set, L2's data value should be the same as at memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2.">DeNovo Invariants.</head><p>We modeled six invariants for the DeNovo protocol. Because there is no sharer list maintained in the DeNovo protocol, we do not check for the first two invariants of the MESI protocol. The first three invariants of the DeNovo protocol are similar to the last three invariants of the MESI protocol. The last three invariants of the DeNovo protocol are checks on the touched bit functionality.</p><p>-Only one modifiable cache copy. There cannot be two modifiable L1 cache copies in the system at the same time. This invariant checks that there are never two L1 caches in Registered state for the same line at the same time. -Data value consistency at L1. This invariant has two parts: (1) If L1 is in V alid state and touched bit is set (value is read in this phase) and L2 is also in V alid state, then the data values should be the same at both L1 and L2.</p><p>(2) If L1 is in V alid state and touched bit is set and some other L1 is in Registered state,<ref type="foot" target="#foot_7">4</ref> the data values should match. -Data value consistency at L2. This invariant checks that when L2 is in V alid state and dirty bit is not set, L2's data value should be the same as at memory. -Touched bit on a write. On a write, this invariant checks that no other cache has the touched bit set to true. This verifies that the touched bit is implemented correctly. -Touched bit on a read. Similar to the above, on a read, this invariant checks that the only cache lines that can have the touched bit set to true (for cores other than the requestor) are the ones in V alid state. -Unsetting touched bits. Finally, this invariant checks that all the touched bits are set to false at the end of the phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">RESULTS</head><p>Through model checking, we found six bugs (including two deadlock scenarios) in MESI and three bugs in DeNovo. <ref type="foot" target="#foot_8">5</ref> A deadlock occurs when all the entities in the system (all L1s and L2) stop making any forward progress. Mur? checks for deadlock by default. In MESI, all the bugs except one of the deadlocks were caused by protocol races between L1 writebacks and other cache events. The other deadlock was caused by incorrect handling of clean replacement at the L2.</p><p>Most of these bugs found in MESI involved subtle data races and took several days to track, debug, and fix. All three bugs found in DeNovo were simple to fix and showed mistakes in translating our internal high level specification into the implementation (i.e., their solutions were already present in our internal high level description of the protocol).</p><p>Each of the bugs found in MESI and DeNovo is described in detail next. In all these descriptions, consider a single address. L1 P1 , L1 P2 , and L2 indicate the cache lines corresponding to this address in core P1, core P2, and L2, respectively. As mentioned in Section 2, we assume an in-cache directory at L2, and hence we use the words directory and L2 interchangeably.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">MESI Bugs</head><p>We first discuss the six bugs found in the MESI protocol. We list them in decreasing order of complexity and the amount of change to the code required to fix them.<ref type="foot" target="#foot_9">6</ref> Bug 1. The first bug is caused by a race between an L1 writeback and a write request by some other L1. Figure <ref type="figure">6</ref> shows the events that lead to this bug. Let us assume that initially L1 P1 is in Modi f ied state, L1 P2 is in Invalid state, and L2 records that the Revisiting the Complexity of Hardware Cache Coherence and Some Implications 37:13 Fig. <ref type="figure">6</ref>. MESI Bug 1 showing a race between an L1 writeback and a remote write request. cache entry is modified in L1 P1 . Then L1 P1 issues a replacement (event 1 in Figure <ref type="figure">6</ref>) triggering a writeback (PUTX) and transitions to a transient state waiting for an acknowledgment to this writeback request. Meanwhile, L1 P2 issues a write request (event 2) triggering GETX to L2. L2 first receives GETX from L1 P2 (event 3). It forwards the request to L1 P1 and waits for an acknowledgment from L1 P2 . L1 P1 , on receiving the GETX request (event 4), forwards the data to L1 P2 and transitions to Invalid state. Then L1 P2 , on receiving the data from L1 P1 (event 5) transitions to Modi f ied state and unblocks the directory, which in turn records that the cache entry is now modified in L1 P2 . But the writeback (PUTX) sent by L1 P1 is still in the network and it can reach the directory at any time because we have an unordered network (event 7), causing an error. For example, suppose L1 P1 later services a write request invalidating L1 P2 and the directory is appropriately updated (not shown in the figure). L1 P1 's writeback (PUTX) then reaches the directory, which is clearly an error. The bug was found when the writeback acknowledgment from L2 reached L1 P1, triggering a "missing transition" failure (L1 P1 does not expect a writeback acknowledgment in Modi f ied state).</p><p>We solved this problem by not transitioning L1 P1 to Invalid state on receiving L1 P2 's GETX request. L1 P1 now sends DAT A to L1 P2 as before, but continues to stay in the transient state, M_I. The write request from L1 P1 , which triggered the bug in the previous example, is now kept pending because L1 P1 is in a transient state. We also added a transition at the L2 to send a writeback acknowledgment when the requester is not the owner in the directory's record. L1 P1 transitions to Invalid state on receiving the writeback acknowledgment from L2. With this, there is no longer a dangling PUTX in the network and the problem is solved. The trace for this bug involved multiple writes to the same memory location in a parallel phase. This scenario does not arise in DeNovo because the software guarantees data-race-freedom.</p><p>Bug 2. The second bug is similar to the first except that it is caused by a race between an L1 writeback and a read request by some other L1.</p><p>The first two bugs were the most complex to understand and fix. Most of the time was spent in discovering the root cause of the bugs and developing a solution in an already complex protocol. The solutions to these bugs required adding two new cache events and eight new transitions to the protocol. Bug 3. The third bug is caused by an unhandled protocol race between L2 and L1 replacements. To begin with, L1 P1 is in Exclusive state and L2 records that P1 is the exclusive owner. Then, both L2 and L1 replace the lines simultaneously, triggering invalidation and writeback messages, respectively. L1 P1 , on receiving the invalidation message, transitions to Invalid state and sends its data to L2. On receiving this data, L2 completes the rest of the steps for the replacement. In the end, both L1 and L2 have transitioned to Invalid states, but the initial writeback message from L1 is still in the network and this is incorrect. The bug was found when the writeback acknowledgment (issued by L2 on receiving the dangling writeback message) reaches L1 P1 when it is not expecting one and hence triggers a "missing transition" error.</p><p>This bug can be fixed by not sending the when L1 receives an invalidation message and by treating the invalidation message itself as the acknowledgment for L1's earlier writeback message. Also, the L1 writeback message is treated as the data response for the invalidation message at L2. The fix required adding four new transitions to the protocol. Bug 4. The fourth bug results in a deadlock situation. It is caused by an incorrectly handled protocol race between an Exclusive unblock (response sent to unblock L2 on receiving an exclusive access) and an L1 writeback issued by the same L1 (issued after sending Exclusive unblock). Initially, L2 is waiting for an Exclusive unblock in a transient state transitioned from Invalid state. In this transient state, when L2 receives an L1 writeback, it checks whether this writeback came from the current owner or not. The owner information is updated at L2 on receiving the Exclusive unblock message. Here, L1 writeback (racing with Exclusive unblock from the same L1) reached L2 first and L2 incorrectly discarded the L1 writeback because the owner information at L2 did not match the sender of the L1 writeback. This incorrect discarding of the L1 writeback results in a deadlock.</p><p>This bug can be fixed by holding the L1 writeback to be serviced until Exclusive unblock is received by L2. This requires adding a new transition and additional buffering to hold the stalled request to the protocol. Bug 5. The fifth bug is similar to the fourth (race between Exclusive unblock and L1 writeback), but instead L2 is initially in Shared state. The fix for this bug required adding two new transitions and additional buffering to hold the stalled requests to the protocol. Bug 6. The last bug results in a deadlock scenario due to an incorrect transition by L2 on a clean replacement. It transitions to a transient state awaiting an acknowledgment from memory even though the transition did not trigger any writeback. The fix was simple and required transitioning to Invalid state instead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">DeNovo Bugs</head><p>We next discuss the three bugs found in the DeNovo protocol. The first bug is a performance bug and the last two are correctness bugs, both of which are caused by races related to writebacks.</p><p>Bug 1. The first of the three bugs found was caused by not unsetting the dirty bit on replacement of a dirty L2 cache line. Assume that L2 is initially in V alid state and the dirty bit is set to true. Then, on L2 replacement, it transitions to Invalid state and writes back data to memory. But the dirty bit is mistakenly not unset. This bug was found when Mur? tried to replace the line in Invalid state as the dirty bit was set to true (the model triggers a replacement event by only checking the dirty bit). The model, legitimately, did not have an action specified for a replacement event in the Invalid state, thus resulting in a "missing transition" error. However, the actual implementation did have an action (incorrectly) that triggered unnecessary writebacks to memory, which should be silent replacements instead. This turned out to be a rare case to hit in the simulation runs.</p><p>Bug 2. This occurs because an L2 initiated writeback and future requests to the same cache line are not serialized. Initially, L1 P1 is in Registered state and L2 knows P1 as the registrant. On replacing the line, L2 sends a writeback request to L1. L1 replies to this writeback request by sending the data to L2 and transitions to V alid state. <ref type="foot" target="#foot_10">7</ref>Then, on receiving the writeback from L1, L2 sends an acknowledgment to L1 and, in parallel, sends a writeback to memory and waits for an acknowledgment. Meanwhile, let us assume that L1 issued a registration request (on receiving a store request) and successfully registers itself with L2. At this point, yet another L2 replacement was triggered, finally leading to multiple writebacks to memory in flight. This is incorrect because the writebacks can be serviced out of order. Mur? found this bug when an assertion failed inside the implementation of L2's request buffer.</p><p>The real source of this bug is allowing L1 registration to be serviced at L2 while a writeback to memory is pending. The fix involves serializing requests to the same location at L2-in this case, the L1 registration request behind the writeback to memory. This was already present in our high level specification but was missed in the actual protocol implementation. It did not involve adding any new states or transitions to the protocol.</p><p>Bug 3. The last bug is due to a protocol race where both the L1s and the L2 replace the line. This bug involves both cores and cross-phase interactions. The events that lead to the bug are shown in Figure <ref type="figure" target="#fig_5">7</ref>. At the beginning of the phase, let us assume that L1 P1 is in Invalid state and L1 P2 is in Registered state (from the previous phase). L1 P2 replaces the line (event 1 in Figure <ref type="figure" target="#fig_5">7</ref>) and issues a writeback (PUTX) to L2. While this writeback is in flight, L1 P1 successfully registers itself with L2 (events 2-4) (L2 redirects the request to L1 P2 because it is the current registrant). This is followed by a replacement by L1 P1 (event 5), thus triggering another writeback (PUTX) to L2. L2 first receives the writeback from L1 P1 (event 6) and responds by sending an acknowledgment and transitioning to V alid state while setting the dirty bit to true. Now, L2 also replaces the line (event 7) transitioning to Invalid state and issues a writeback to memory. But the writeback from L1 P2 is still in flight. This writeback now reaches L2 (event 8) while in Invalid state (because we model an unordered network). The implementation did not handle this case and resulted in a "missing transition" failure. This bug can be easily fixed by adding a transition to send an acknowledgment to L1 P2 's writeback without the need for triggering any actions at L2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Analysis</head><p>The bugs just described for both MESI and DeNovo show that cache line replacements and writebacks, when interacting with other cache events, cause subtle races and add to the complexity of cache coherence protocols. Fixes to bugs in the MESI protocol needed adding new events and several new transitions. On the other hand, fixing bugs in the DeNovo protocol was relatively easy since it lacks transient states even for races related to writebacks. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Verification Time</head><p>After fixing all the bugs, we ran the models for both MESI and DeNovo on Mur? as described in Section 3. The model for MESI explores 1,257,500 states in 173 seconds, whereas the model for DeNovo explores 85,012 states in 8.66 seconds. These are the number of distinct system states exhaustively explored by the model checking tool. The state space and runtime both grow significantly when we increase the parameters in the verification model. For example, when we modeled two addresses, we were able to finish running DeNovo without any bugs being reported, but we ran out of system memory (32GB) for MESI. This indicates (1) the simplicity and reduced verification overhead for DeNovo compared to MESI, and (2) the need for more scalable tools amenable to non-expert to deal with more conventional hardware coherence protocols in a more comprehensive way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>Hardware cache coherence protocols are inherently complex. There is an ongoing debate about whether we have tamed the complexity of hardware coherence protocols or whether we should abandon them and replace them with their software counterparts. While some predict that hardware cache coherence is here to stay <ref type="bibr">[Martin et al. 2012</ref>] and continue to extend such protocols in newer, more complex ways <ref type="bibr" target="#b2">[Aisopos and Peh 2011;</ref><ref type="bibr" target="#b42">Zhao et al. 2013]</ref>, others propose and build systems with software-directed coherence <ref type="bibr" target="#b14">[Borkar 2011;</ref><ref type="bibr" target="#b18">Choi et al. 2011;</ref><ref type="bibr" target="#b26">Howard et al. 2010;</ref><ref type="bibr" target="#b27">IntelSCC 2009;</ref><ref type="bibr" target="#b30">Kelm et al. 2009]</ref>. Our work offers an objective case study to show that hardware coherence remains quite complex and that a hardware-software co-design approach can provide a simpler alternative. This section first discusses several existing techniques to verify hardware coherence protocols (Section 5.1). Next, we discuss related work on redesigning conventional hardware coherence protocols specifically to address verification complexity (Section 5.2).</p><p>Revisiting the Complexity of Hardware Cache Coherence and Some Implications 37:17</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Verification Techniques</head><p>Hardware coherence protocols have numerous transient states and hard-to-cover race conditions making it very difficult to find all the bugs using just simulations or random testing. Hence, formal methods like model checking are often employed to verify their correctness. Model checking is a technique to verify the properties of a system by exhaustive exploration of the state space <ref type="bibr" target="#b20">[Clarke and Emerson 1982;</ref><ref type="bibr">Queille and Sifakis 1982]</ref>. McMillan and Schwalbe's seminal work on model checking the Encore Gigamax protocol <ref type="bibr">[McMillan and Schwalbe 1991]</ref> was the first to apply model checking to verify cache coherence protocols.</p><p>Complex systems often exhibit a lot of regularity and symmetry. Ip and Dill developed Mur? <ref type="bibr" target="#b21">[Dill et al. 1992;</ref><ref type="bibr">Ip and</ref><ref type="bibr">Dill 1993, 1996]</ref>, which exploits these characteristics by grouping together similar states to verify a reduced state graph instead of the full one. This helps to greatly reduce the amount of time and memory used in verification. Mur? is a widely used tool to formally verify cache coherence protocols; for example, Sun RMO memory model [Park and <ref type="bibr">Dill 1995]</ref>, Sun S3.mp multiprocessor <ref type="bibr">[Pong et al. 1998</ref>], Cray SV2 protocol <ref type="bibr" target="#b0">[Abts et al. 2000]</ref>, and Token coherence protocol <ref type="bibr" target="#b16">[Burckhardt et al. 2005]</ref>.</p><p>In this article, we use Mur? for our protocol verification work. Using model checking tools like Mur? for verifying cache coherence protocols is not new per se. This article, nevertheless, does discuss some extensions to the canonical coherence protocol modeling technique to model the guarantees provided by disciplined programming languages (namely, data-race-freedom and a disciplined parallel phase behavior). The main contribution of this work is to provide a detailed experience of the verification process of a state-of-the-art, publicly available, mature, modern hardware coherence protocol implementation (MESI). We further compare this experience with that of verifying a protocol driven by a hardware-software co-design approach (DeNovo), motivated by simplifying both software and hardware through the same mechanisms (while providing opportunities for performance and energy improvements).</p><p>Explicit state exploration model checking tools traditionally have the problem of state space explosion limiting the scalability of such tools. As mentioned in Section 4.4, we ran out of system memory when we increased the verification parameters. We tried a distributed model checker based on Mur?, Preach <ref type="bibr" target="#b7">[Bingham et al. 2010</ref>] (similar to Eddy Murphi <ref type="bibr">[Melatti et al. 2009]</ref>). But PReach did not help us reduce the number of states explored, and hence the memory footprint stayed the same.</p><p>There are other verification techniques that do not have this state explosion problem and can scale to larger systems. Parametric verification <ref type="bibr" target="#b19">[Chou et al. 2004;</ref><ref type="bibr">McMillan 2001;</ref><ref type="bibr">O'Leary et al. 2009</ref>] and theorem proving [Seungjoon and <ref type="bibr" target="#b29">David 1996]</ref> are two such techniques. Several of these techniques are sometimes combined together to verify a given system. For example, the verification of Token Coherence <ref type="bibr" target="#b16">[Burckhardt et al. 2005</ref>] is achieved by combining assume-guarantee reasoning and structural induction (in addition to model checking). Even though the techniques employed were able to verify the protocol, in practice, these techniques are either hard for nonspecialists to use or error-prone because of laborious manual intervention <ref type="bibr" target="#b40">[Zhang et al. 2014]</ref>. There have been proposals to automate parametric verification techniques and minimize manual intervention <ref type="bibr" target="#b19">[Chou et al. 2004</ref>], but such techniques impose severe limitations on the protocols that can be verified. DeNovo, in contrast, is a simpler protocol and makes it feasible to verify with easy-to-use verification techniques, such as an explicit state model checker. A general survey of various techniques used to verify cache coherence protocols can be found in Pong and Dubois <ref type="bibr">[1997]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Redesigning Hardware Coherence Protocols</head><p>There has been some work on redesigning the hardware cache coherence protocol itself to address the verification problem. A recent proposal, PVCoherence <ref type="bibr" target="#b40">[Zhang et al. 2014]</ref>, lists various guidelines for designing cache coherence protocols so that they can be verified using existing automatic parametric verification techniques. The verification technique used in the paper, Simple-PV, uses an automatic tool to generate the parametric model and then Mur? to verify the generated model. When the proposed guidelines were applied to the MOESI protocol to make it amenable to parametric verification (in the process also making it even more complex), the authors noticed that the resulting protocol could not be verified by Mur? and needed even more changes. The final protocol was verifiable but showed performance degradation (e.g., average 5% and up to 13.8% increase in network traffic). In Fractal Coherence <ref type="bibr" target="#b41">[Zhang et al. 2010;</ref><ref type="bibr" target="#b34">Voskuilen and Vijaykumar 2014]</ref>, the verification for arbitrary number of cores is made possible by just verifying the minimum system for correctness and verifying that the whole system has fractal behavior. But Fractal Coherence requires addition of states and messages to an existing cache coherence protocol (MOSI, as described in <ref type="bibr" target="#b41">Zhang et al. [2010]</ref>) to maintain fractal behavior. Thus, it enables verification of the entire system at the expense of increasing the complexity of the base protocol. Also, a specific implementation of Fractal Coherence, TreeFractal, shows a performance degradation (&gt;10%) when compared to traditional protocols. FlatFractal <ref type="bibr" target="#b34">[Voskuilen and Vijaykumar 2014]</ref> proposes techniques to eliminate some of the limitations of TreeFractal, making FlatFractal's performance comparable to the base implementation on 16 cores. But when scaled to 32 cores, FlatFractal shows up to 40% degradation in total execution time. Atomic Coherence <ref type="bibr">[Vantrease et al. 2011</ref>] attempts to simplify the coherence protocol by separating out the races from the protocol. The design avoids the protocol races by requiring each coherence action to be guarded by a mutex. It uses nanophotonics for performing these mutex operations with low latency because they are now on the critical path. As a result, Atomic Coherence eliminates transient states in the coherence protocol but heavily relies on a specific type of on-chip network.</p><p>In contrast to these approaches, DeNovo reduces the complexity of the cache coherence protocol by following a hardware-software co-design approach that eliminates races and thereby reduces the overall verification overhead. The basic DeNovo protocol is shown to be performance-competitive with MESI, and its simplicity enables optimizations that significantly improve performance and network traffic, thereby also potentially saving energy. The DeNovo coherence protocol used in this article assumes deterministic software. DeNovo is an ongoing research project seeking to broaden the class of software supported by such simple protocols. Recently, we extended DeNovo to support disciplined lock-based programs using dynamically generated access signatures to guide self-invalidations <ref type="bibr">[Bocchino et al. 2011;</ref><ref type="bibr">Sung et al. 2013</ref><ref type="bibr">Sung et al. , 2014]]</ref>. These extensions are rather small, and we believe can be verified independently. We are also developing simple extensions to support more complex lock-free synchronization algorithms. With these extensions, DeNovo will be able to support all codes correctly as long as synchronization operations are explicit. <ref type="foot" target="#foot_11">8</ref> For legacy codes that do not contain annotations for self-invalidations or generating dynamic access signatures, performance (but not correctness) may be affected. DeNovo's vision of using disciplined parallel programming practices for better performance and programmability is shared by other projects as well, including for complex system code such as operating systems (e.g., Barrelfish <ref type="bibr" target="#b5">[Baumann et al. 2009]</ref>). This paper provides an objective study to quantify the complexity advantages of such approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION</head><p>With the era of manycores, there is a renewed debate in the community as to whether we have tamed the complexity of hardware coherence enough to employ it in systems</p><p>Revisiting the Complexity of Hardware Cache Coherence and Some Implications 37:19 with hundreds of cores or whether we should abandon it for other software alternatives. Although some have argued that hardware coherence is here to stay <ref type="bibr">[Martin et al. 2012</ref>] and continue to work on even more complex extensions <ref type="bibr" target="#b2">[Aisopos and Peh 2011]</ref>, others are proposing systems that use software-directed coherence <ref type="bibr" target="#b14">[Borkar 2011;</ref><ref type="bibr" target="#b18">Choi et al. 2011;</ref><ref type="bibr" target="#b26">Howard et al. 2010;</ref><ref type="bibr" target="#b27">IntelSCC 2009;</ref><ref type="bibr" target="#b30">Kelm et al. 2009</ref>]. This article adds objective results from a concrete case study to this debate. We attempted to formally verify a publicly available, state-of-the-art implementation of the MESI protocol. Surprisingly, we found that after four years of extensive use in the architecture community, the protocol implementation still had several bugs. These bugs were hard to diagnose and fix, requiring new state transitions. In contrast, verifying a far less mature, hardwaresoftware co-designed protocol, DeNovo, revealed fewer bugs that were much easier to fix. After the bug fixes, we found that MESI took 20X longer to model check and required significant simplifying assumptions for the verification to be tractable. We conclude that even with a multitude of prior work, hardware coherence protocols are still difficult to design and understand. Furthermore, although it is difficult to define a single metric to quantify the relative complexity of protocols or to generalize from two design points, our results indicate that hardware-software co-designed protocols may offer a simpler alternative. This article also reinforces the necessity of employing formal verification techniques to prove the correctness of these protocols, but these techniques still require simplifying assumptions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Textbook state transition diagram for L1 cache of core i for the MESI protocol. Read i = read from core i, Read k = read from another core k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Example state transitions for MESI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Example state transitions for DeNovo.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3</head><label>3</label><figDesc>Figure3(b)  shows the timeline of the state transitions for the DeNovo protocol and the state transition tables for the states encountered in this example are shown in Figure3(c) and (d). Focusing again on the write instruction in the second phase, L1 P1 transitions directly to the Registered state without transitioning to any transient state and sends a registration request to L2. L2, on receiving the registration request, transitions to the Registered state. We do not show the registration response message from L2 here because it is not in the critical path and is handled by the request buffer at L1. As explained in<ref type="bibr" target="#b18">Choi et al. [2011]</ref>, the functionality of the request buffer is similar to that of a uniprocessor system and is invisible to the outside world. At the end of the phase, each core executes a self-invalidate instruction on region R A . This instruction triggers the invalidation of all the data in region R A in the L1 cache of its core (except for data in Registered state since this data is known to be up-to-date).As an optimization, the L1 maintains an additional touched bit for each word. This bit is set on a read, indicating that this data will stay up-to-date until the end of the phase. This is guaranteed by data-race-freedom because there cannot be concurrent writers to the same location. The self-invalidation operation now skips invalidating the data that is both V alid and touched. These touched bits are reset at the end of the parallel phase.This example illustrates how the absence of transient states makes the DeNovo protocol simpler than MESI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Mur? code for end-of-phase implementation for DeNovo as a sense-reversing barrier. (a) Rule that gets triggered when inside the barrier indicated by release f lag and empty L1 request buffer (no outstanding requests) and (b) implementation of the sense-reversing barrier, including calls to end-of-phase operations like sel f -invalidation instruction and unsetting of touched bits.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. DeNovo Bug 3 showing a race between replacements at both the L1s and the L2. This figure doesn't show the request buffer entries for L2 and for writeback entries at L1.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Architecture and Code Optimization, Vol. 11, No. 4, Article 37, Publication date: December 2014.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>We chose MESI over a more complicated MOESI from GEMS because the GEMS web site says that the CMP version of the latter has bugs. Although we specifically study the MESI protocol in this article, we believe our insights apply to other protocols, such as MOESI, as well. ACM Transactions on Architecture and Code Optimization, Vol. 11, No. 4, Article 37, Publication date: December</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2014" xml:id="foot_2"><p></p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_3"><p>The paper proposing DeNovo<ref type="bibr" target="#b18">[Choi et al. 2011]</ref> showed that the basic DeNovo protocol is performancecompetitive with MESI, and its simplicity enables optimizations that significantly improved performance and network traffic (and thereby energy)<ref type="bibr" target="#b18">[Choi et al. 2011</ref>]. That paper focused on performance, but as evidence of DeNovo's simplicity, it also briefly summarized some of the key results of this article. That paper only gave the number of bugs found in each protocol, the number of states explored, and the verification times. It did not describe the nature of the bugs in MESI or DeNovo, the fixes involved, or the modification to standard Mur? modeling required to verify a hardware/software co-designed protocol like DeNovo.ACM Transactions on Architecture and Code Optimization, Vol. 11, No. 4,</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>Article 37, Publication date: December 2014.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_5"><p>For the purpose of this article, we assume a phase is a computation between two successive barriers (e.g., a parallel for loop).ACM Transactions on Architecture and Code Optimization, Vol. 11, No.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>4, Article 37, Publication date: December 2014.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_7"><p>This is possible in DeNovo because registration at the other L1 may have happened in a previous parallel phase.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_8"><p>We note that these bugs were discovered in 2011 when DeNovo was (and still is) much less mature than the GEMS MESI protocol. The latter was released in 2007 and had been used by many researchers over the course of four years when we found the bugs.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_9"><p>We confirmed the fixes for the MESI bugs in a personal email exchange with Arkaprava Basu, one of the developers of the GEMS simulation suite. ACM Transactions on Architecture and Code Optimization, Vol. 11, No. 4, Article 37, Publication date: December 2014.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_10"><p>In DeNovo, the L2 cache is inclusive of only the registered lines in any L1. Hence, it is possible for L1 to transition from Registered to V alid on receiving a writeback request from L2. ACM Transactions on Architecture and Code Optimization, Vol. 11, No. 4, Article 37, Publication date: December 2014.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_11"><p>Recent standards efforts for popular languages like Java, C, and C++ already require making synchronizations explicit. ACM Transactions on Architecture and Code Optimization, Vol. 11, No. 4, Article 37, Publication date: December 2014.</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>This work was supported in part by <rs type="funder">Intel</rs> and <rs type="funder">Microsoft</rs> through the <rs type="institution">Universal Parallel Computing Research Center (UPCRC) at Illinois</rs>, by <rs type="funder">Intel</rs> through the <rs type="institution">Illinois/Intel Parallelism Center at Illinois</rs>, by the <rs type="funder">National Science Foundation</rs> under grants <rs type="grantNumber">CCF-1018796</rs> and <rs type="grantNumber">CCF-1302641</rs>, and by the <rs type="funder">Center for Future Architectures Research (C-FAR</rs>), one of six centers of STARnet, a Semiconductor Research Corporation program sponsored by <rs type="funder">MARCO</rs> and <rs type="funder">DARPA</rs>. <rs type="person">Rakesh Komuravelli</rs> was also supported by a <rs type="funder">Qualcomm Innovation Fellowship</rs>.</p></div>
			</div>
			<div type="funding">
<div><head>37:21</head><p>Support for Programming Languages and <rs type="person">Operating Systems</rs> (<rs type="grantNumber">ASPLOS'12</rs>). <rs type="institution">ACM, New York, NY, USA</rs>, <rs type="grantNumber">13-24</rs>. DOI:http://dx.doi.org/10. 1145/2150976.2150979 <rs type="person">Jeremy Manson</rs>, <rs type="person">William Pugh</rs>, and <rs type="person">Sarita V. Adve</rs>. 2005. The Java memory model. <rs type="person">In POPL. Milo M. K. Martin</rs>, <rs type="person">Mark D. Hill</rs>, and <rs type="person">Daniel J. Sorin</rs>. 2012. Why on-chip cache coherence is here to stay. Commununications of the ACM 55, 7 (July 2012), <rs type="grantNumber">78-89</rs>. DOI:http://dx.doi.org/10.1145/2209249.2209269 <rs type="person">Milo M. K. Martin</rs>, <rs type="person">Daniel J. Sorin</rs>, <rs type="person">Bradford M. Beckmann</rs>, <rs type="person">Michael R. Marty</rs>, <rs type="person">Min Xu</rs>, <rs type="person">Alaa R. Alameldeen</rs>, <rs type="person">Kevin E. Moore</rs>, <rs type="person">Mark D. Hill</rs>, and <rs type="person">David A. Wood</rs>. 2005. Multifacet's general execution-driven multiprocessor simulator (GEMS) toolset. SIGARCH Computer Architecture News 33, 4 (2005), <rs type="grantNumber">92-99</rs>. DOI:http://dx.doi.org/10.1145/1105734.1105747 Kenneth L. McMillan. 2001. Parameterized verification of the FLASH cache coherence protocol by compositional model checking. In Proceedings of the 11th IFIP WG 10.5 Advanced Research Working Conference on <rs type="person">Correct Hardware Design</rs> and <rs type="person">Verification Methods</rs> (<rs type="grantNumber">CHARME'01</rs>). Springer-Verlag, London, <rs type="grantNumber">179-195</rs>. http://dl.acm.org/citation.cfm?id=646705.702177 K. L. McMillan and Schwalbe J. 1991. Formal verification of the gigamax cache consistency protocol. In Proceedings of the <rs type="funder">International Conference on Parallel and Distributed Computing. Information Processing Society, Tokyo, Japan</rs>, <rs type="grantNumber">242-251</rs>. <rs type="person">I. Melatti</rs>, <rs type="person">R. Palmer</rs>, <rs type="person">G. Sawaya</rs>, <rs type="person">Y. Yang</rs>, <rs type="person">R. M. Kirby</rs>, and G. Gopalakrishnan. 2009. Parallel and distributed model checking in Eddy. International Journal of Software Tools Technology Transfer 11, 1 (January 2009), <rs type="grantNumber">13-25</rs>. DOI:http://dx.doi.org/10.1007/s10009-008-0094-x J. <rs type="person">M. Mellor-Crummey</rs> and <rs type="person">M. L. Scott</rs>. April 1991. Synchronization without contention. In Proceedings of the 4th <rs type="funder">International Conference on Architectural Support for Programming Languages and Operating Systems</rs>. <rs type="person">A. K. Nanda</rs> and <rs type="person">L. N. Bhuyan</rs>. 1992. A formal specification and verification technique for cache coherence protocols. In ICPP. <rs type="grantNumber">I22-I26</rs>. <rs type="person">J. O'Leary</rs>, <rs type="person">M. Talupur</rs>, and M. R. Tuttle. 2009. Protocol verification using flows: An industrial experience. In Formal Methods in Computer-Aided Design, 2009. FMCAD 2009. IEEE, <rs type="grantNumber">172-179</rs>. http:/<rs type="grantName">/scholar. google.com/scholar</rs>.bib?q=info:h_Ok5nemssQJ:scholar.google.com/&amp;output=citation&amp;hl=en&amp;as_sdt= 2001&amp;as_ylo=1999&amp;ct=citation&amp;cd=1 <rs type="person">Marek Olszewski</rs>, <rs type="person">Jason Ansel</rs>, and <rs type="person">Saman Amarasinghe</rs>. 2009. Kendo: Efficient deterministic multithreading in software. In ASPLOS. <rs type="grantNumber">97-108</rs>. <rs type="person">Mark S. Papamarcos</rs> and <rs type="person">Janak H. Patel</rs>. <rs type="grantNumber">1984</rs>. A low-overhead coherence solution for multiprocessors with private cache memories. In Proceedings of the 11th <rs type="projectName">Annual International Symposium on Computer Architecture (ISCA'84</rs>). ACM, New York, NY, 348-354. DOI:http://dx.doi.org/10.1145/800015.808204 <rs type="person">Seungjoon Park</rs> and <rs type="person">David L. Dill</rs>. 1995. An executable specification, analyzer and verifier for RMO (relaxed memory order). In Proceedings of the 7th Annual <rs type="institution">ACM Symposium on Parallel Algorithms and Architectures (SPAA'95). ACM, New York, NY</rs>, <rs type="grantNumber">34-41</rs>. DOI:http://dx.doi.org/10.1145/215399.215413 <rs type="person">Fong Pong</rs>, <rs type="person">Michael Browne</rs>, <rs type="person">Andreas Nowatzyk</rs>, <rs type="person">Michel Dubois</rs>, and G ?nes Aybay. 1998. Design verification of the S3.mp cache-coherent shared-memory system. IEEE Transactions on Computing 47, 1 (January 1998), <rs type="grantNumber">135-140</rs>. DOI:http://dx.doi.org/10.1109/12.656100 <rs type="person">Fong Pong</rs> and <rs type="person">Michel Dubois</rs>. 1997. Verification techniques for cache coherence protocols. ACM Computing Survey 29, 1 (March 1997), <rs type="grantNumber">82-126</rs>. DOI:http://dx.doi.org/10.1145/248621.248624 <rs type="person">Jean-Pierre Queille</rs> and <rs type="person">Joseph Sifakis</rs>. 1982. Specification and verification of concurrent systems in CESAR. In Proceedings of the 5th Colloquium on International Symposium on Programming. Springer-Verlag, London, <rs type="grantNumber">337-351</rs>. <rs type="person">Park Seungjoon</rs> and <rs type="person">Dill David</rs>. 1996. Verification of FLASH cache coherence protocol by aggregation of distributed transactions. In Proceedings of the 8th Annual <rs type="institution">ACM Symposium on Parallel Algorithms and Architectures (SPAA'96). ACM, New York, NY</rs>, <rs type="grantNumber">288-296</rs>. DOI:http://dx.doi.org/10.1145/237502.237573 <rs type="person">Hyojin Sung</rs>, <rs type="person">Rakesh Komuravelli</rs>, and <rs type="person">Sarita V. Adve</rs>. 2013. DeNovoND: Efficient hardware support for disciplined non-determinism. In Proceedings of the 18th International Conference on Architectural Support for Programming Languages and <rs type="person">Operating Systems</rs> (<rs type="grantNumber">ASPLOS'13</rs>). ACM, New York, NY, <rs type="grantNumber">13-26</rs>. DOI:http://dx.doi.org/10.1145/2451116.2451119 <rs type="person">Hyojin Sung</rs>, <rs type="person">Rakesh Komuravelli</rs>, and <rs type="person">Sarita V. Adve</rs>. 2014. DeNovoND: Efficient hardware for disciplined nondeterminism. Micro, IEEE 34, 3 (May 2014), <rs type="grantNumber">138-148</rs>. DOI:http://dx.doi.org/10.1109/MM.2014.5 <rs type="person">Mohsen Vakilian</rs>, <rs type="person">Danny Dig</rs>, <rs type="person">Robert Bocchino</rs>, <rs type="person">Jeffrey Overbey</rs>, <rs type="person">Vikram Adve</rs>, and <rs type="person">Ralph Johnson</rs>. 2009. Inferring method effect summaries for nested heap regions. In Proceedings of the 2009 <rs type="projectName">IEEE/ACM International Conference on Automated Software Engineering</rs> (<rs type="grantNumber">ASE'09</rs>). <rs type="institution">IEEE Computer Society, Washington, DC</rs>, <rs type="grantNumber">421-432</rs>. DOI:http://dx.doi.org/10.1109/ASE.2009.68 <rs type="person">Dana Vantrease</rs>, <rs type="person">Mikko H. Lipasti</rs>, and <rs type="person">Nathan Binkert</rs>. 2011. Atomic coherence: Leveraging nanophotonics to build race-free cache coherence protocols. In Proceedings of the 2011 IEEE 17th International</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_3jczwAx">
					<idno type="grant-number">CCF-1018796</idno>
				</org>
				<org type="funding" xml:id="_UkzfnHE">
					<idno type="grant-number">CCF-1302641</idno>
				</org>
				<org type="funding" xml:id="_xDYFWYu">
					<idno type="grant-number">ASPLOS&apos;12</idno>
				</org>
				<org type="funding" xml:id="_U5Xy8NC">
					<idno type="grant-number">13-24</idno>
				</org>
				<org type="funding" xml:id="_A9CUxrV">
					<idno type="grant-number">78-89</idno>
				</org>
				<org type="funding" xml:id="_unvgtm6">
					<idno type="grant-number">92-99</idno>
				</org>
				<org type="funding" xml:id="_5TwsF2B">
					<idno type="grant-number">CHARME&apos;01</idno>
				</org>
				<org type="funding" xml:id="_QbH5ZXB">
					<idno type="grant-number">179-195</idno>
				</org>
				<org type="funding" xml:id="_3EDbNwr">
					<idno type="grant-number">242-251</idno>
				</org>
				<org type="funding" xml:id="_tVYgH2j">
					<idno type="grant-number">13-25</idno>
				</org>
				<org type="funding" xml:id="_WkhN5fD">
					<idno type="grant-number">I22-I26</idno>
				</org>
				<org type="funding" xml:id="_tSDKkMr">
					<idno type="grant-number">172-179</idno>
					<orgName type="grant-name">/scholar. google.com/scholar</orgName>
				</org>
				<org type="funding" xml:id="_CMzWVpr">
					<idno type="grant-number">97-108</idno>
				</org>
				<org type="funded-project" xml:id="_TR2dEmb">
					<idno type="grant-number">1984</idno>
					<orgName type="project" subtype="full">Annual International Symposium on Computer Architecture (ISCA&apos;84</orgName>
				</org>
				<org type="funding" xml:id="_PgRbX9q">
					<idno type="grant-number">34-41</idno>
				</org>
				<org type="funding" xml:id="_SUMRGZX">
					<idno type="grant-number">135-140</idno>
				</org>
				<org type="funding" xml:id="_6zHdnkr">
					<idno type="grant-number">82-126</idno>
				</org>
				<org type="funding" xml:id="_dbFFw3t">
					<idno type="grant-number">337-351</idno>
				</org>
				<org type="funding" xml:id="_9s3rYub">
					<idno type="grant-number">288-296</idno>
				</org>
				<org type="funding" xml:id="_TunDpFY">
					<idno type="grant-number">ASPLOS&apos;13</idno>
				</org>
				<org type="funding" xml:id="_7AZBGD8">
					<idno type="grant-number">13-26</idno>
				</org>
				<org type="funded-project" xml:id="_RFxyNdz">
					<idno type="grant-number">138-148</idno>
					<orgName type="project" subtype="full">IEEE/ACM International Conference on Automated Software Engineering</orgName>
				</org>
				<org type="funding" xml:id="_HY85GQt">
					<idno type="grant-number">ASE&apos;09</idno>
				</org>
				<org type="funding" xml:id="_2aVYJRb">
					<idno type="grant-number">421-432</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Toward complexity-effective verification: A case study of the Cray SV2 cache coherence protocol</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Abts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Lilja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Complexity-Effective Design held in conjunction with the 27th Annual International Symposium on Computer Architecture (ISCA2000)</title>
		<meeting>the Workshop on Complexity-Effective Design held in conjunction with the 27th Annual International Symposium on Computer Architecture (ISCA2000)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">So many states, so little time: Verifying memory coherence in the cray X1</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Abts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Lilja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPDPS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A systematic methodology to develop resilient cache coherence protocols</title>
		<author>
			<persName><forename type="first">Konstantinos</forename><surname>Aisopos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li-Shiuan</forename><surname>Peh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 44th IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 2011 44th IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Serialization sets: A dynamic dependencebased parallel execution model</title>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">D</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinath</forename><surname>Sridharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gurindar</forename><forename type="middle">S</forename><surname>Sohi</surname></persName>
		</author>
		<idno type="DOI">10.1145/1504176.1504190</idno>
		<ptr target="http://dx.doi.org/10.1145/1504176.1504190" />
	</analytic>
	<monogr>
		<title level="m">PPoPP</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="85" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">SharC: Checking data sharing strategies for multithreaded C</title>
		<author>
			<persName><forename type="first">Zachary</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Ennals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Brewer</surname></persName>
		</author>
		<idno type="DOI">10.1145/1375581.1375600</idno>
		<ptr target="http://dx.doi.org/10.1145/1375581.1375600" />
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The multikernel: A new OS architecture for scalable multicore systems</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre-Evariste</forename><surname>Dagand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rebecca</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Roscoe</surname></persName>
		</author>
		<idno type="DOI">10.1145/1375581.1375600</idno>
		<ptr target="http://dx.doi.org/10.1145/1629575.1629579" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles (SOSP&apos;09)</title>
		<meeting>the ACM SIGOPS 22nd Symposium on Operating Systems Principles (SOSP&apos;09)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="29" to="44" />
		</imprint>
	</monogr>
	<note>Adrian Sch ?pbach, and Akhilesh Singhania</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Grace: Safe multithreaded programming for C/C++</title>
		<author>
			<persName><forename type="first">D</forename><surname>Emery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ting</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tongping</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gene</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><surname>Novark</surname></persName>
		</author>
		<idno type="DOI">10.1145/1640089.1640096</idno>
		<ptr target="http://dx.doi.org/10.1145/1640089.1640096" />
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="81" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Industrial strength distributed explicit state model checking</title>
		<author>
			<persName><forename type="first">Brad</forename><surname>Bingham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesse</forename><surname>Bingham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Flavio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>De Paula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><surname>Reitblatt</surname></persName>
		</author>
		<idno type="DOI">10.1145/1640089.1640096</idno>
		<ptr target="http://dx.doi.org/10.1109/PDMC-HiBi.2010.13" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 9th International Workshop on Parallel and Distributed Methods in Verification, and 2nd International Workshop on High Performance Computational Systems Biology (PDMC-HIBI&apos;10)</title>
		<meeting>the 2010 9th International Workshop on Parallel and Distributed Methods in Verification, and 2nd International Workshop on High Performance Computational Systems Biology (PDMC-HIBI&apos;10)<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="28" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The gem5 simulator</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Binkert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bradford</forename><surname>Beckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">K</forename><surname>Reinhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Saidi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arkaprava</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Hestness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Derek</forename><forename type="middle">R</forename><surname>Hower</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tushar</forename><surname>Krishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Somayeh</forename><surname>Sardashti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rathijit</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Korey</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Muhammad</forename><surname>Shoaib</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nilay</forename><surname>Vaish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1109/PDMC-HiBi.2010.13</idno>
		<ptr target="http://dx.doi.org/10.1145/2024716.2024718" />
	</analytic>
	<monogr>
		<title level="j">SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2011-08">2011. August 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Cilk: An efficient multithreaded runtime system</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">D</forename><surname>Blumofe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><forename type="middle">F</forename><surname>Joerg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bradley</forename><forename type="middle">C</forename><surname>Kuszmaul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><forename type="middle">H</forename><surname>Randall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuli</forename><surname>Zhou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="207" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Types, regions, and effects for safe programming with objectoriented parallel frameworks</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">L</forename><surname>Bocchino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><surname>Adve</surname></persName>
		</author>
		<idno type="DOI">10.1145/2024716.2024718</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th European Conference on Object-oriented Programming(ECOOP&apos;11)</title>
		<meeting>the 25th European Conference on Object-oriented Programming(ECOOP&apos;11)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="306" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">L</forename><surname>Bocchino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jr</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Dig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarita</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Heumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Komuravelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Overbey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Simmons</surname></persName>
		</author>
		<idno type="DOI">10.1145/1639949.1640097</idno>
		<ptr target="http://dx.doi.org/10.1145/1639949.1640097" />
		<title level="m">Hyojin Sung, and Mohsen Vakilian. 2009. A type and effect system for deterministic parallel Java</title>
		<imprint>
			<biblScope unit="page" from="97" to="116" />
		</imprint>
	</monogr>
	<note>OOPSLA</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Safe nondeterminism in a deterministic-by-default parallel language</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">L</forename><surname>Bocchino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jr</forename><surname>Stephen Heumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nima</forename><surname>Honarmand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarita</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tatiana</forename><surname>Welc</surname></persName>
		</author>
		<author>
			<persName><surname>Shpeisman</surname></persName>
		</author>
		<idno type="DOI">10.1145/1639949.1640097</idno>
		<ptr target="http://dx.doi.org/10.1145/1926385.1926447" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages(POPL&apos;11)</title>
		<meeting>the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages(POPL&apos;11)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="535" to="548" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Foundations of the C++ concurrency memory model</title>
		<author>
			<persName><forename type="first">Hans-J</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarita</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="68" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The exascale challenge</title>
		<author>
			<persName><forename type="first">S</forename><surname>Borkar</surname></persName>
		</author>
		<idno type="DOI">10.1145/1926385.1926447</idno>
	</analytic>
	<monogr>
		<title level="m">Keynote at 20th International Conference on Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multi-core implementations of the concurrent collections programming model</title>
		<author>
			<persName><forename type="first">Zoran</forename><surname>Budimlic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aparna</forename><surname>Chandramowlishwaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathleen</forename><surname>Knobe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoff</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vivek</forename><surname>Sarkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leo</forename><surname>Treggiari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IWCPC</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Verifying safety of a token coherence implementation by parametric compositional refinement</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Milo</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VMCAI</title>
		<meeting>VMCAI</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A new solution to coherence problems in multicache systems</title>
		<author>
			<persName><forename type="first">Lucien</forename><forename type="middle">M</forename><surname>Censier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Feautrier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computing C-27</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1112" to="1118" />
			<date type="published" when="1978-12">December 1978. December 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">DeNovo: Rethinking the memory hierarchy for disciplined parallelism</title>
		<author>
			<persName><forename type="first">Byn</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Komuravelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hyojin</forename><surname>Sung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Smolinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nima</forename><surname>Honarmand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarita</forename><forename type="middle">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">P</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ching-Tsun</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName><surname>Chou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Parallel Architectures and Compilation Techniques (PACT&apos;11)</title>
		<meeting>the 20th International Conference on Parallel Architectures and Compilation Techniques (PACT&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">A simple method for parameterized verification of cache coherence protocols</title>
		<author>
			<persName><forename type="first">Ching-Tsun</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phanindra</forename><forename type="middle">K</forename><surname>Mannava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seungjoon</forename><surname>Park</surname></persName>
		</author>
		<idno>FMCAD. 382-398</idno>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Design and synthesis of synchronization skeletons using branching-time temporal logic</title>
		<author>
			<persName><forename type="first">Edmund</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Allen</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic of Programs, Workshop</title>
		<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="52" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Protocol verification as a hardware design aid. In ICCD&apos;92</title>
		<author>
			<persName><forename type="first">L</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><forename type="middle">J</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">J</forename><surname>Drexler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">Han</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><surname>Yang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>IEEE Computer Society</publisher>
			<biblScope unit="page" from="522" to="525" />
			<pubPlace>Washington, DC</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">Anwar</forename><surname>Ghuloum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Sprangle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesse</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gansha</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Zhou</surname></persName>
		</author>
		<title level="m">Ct: A Flexible Parallel Programming Model for Tera-Scale Architectures. Intel White Paper</title>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Formal Specification and Verification of SCI Cache Coherence: The Top Layers</title>
		<author>
			<persName><forename type="first">Stein</forename><surname>Gjessing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stein</forename><surname>Krogdahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ellen</forename><surname>Munthe-Kaas</surname></persName>
		</author>
		<ptr target="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.8390" />
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Axum: Language Overview</title>
		<author>
			<persName><forename type="first">Niklas</forename><surname>Gustafsson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Microsoft Language Specification</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The tasks with effects model for safe concurrency</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">T</forename><surname>Heumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vikram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shengjie</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1145/2442516.2442540</idno>
		<ptr target="http://dx.doi.org/10.1145/2442516.2442540" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP&apos;13)</title>
		<meeting>the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP&apos;13)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="239" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">A 48-core IA-32 message-passing processor with DVFS in 45nm CMOS</title>
		<author>
			<persName><forename type="first">J</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dighe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hoskote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vangal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Finan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ruhl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jenkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Borkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Schrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pailet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Marella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Salihundam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Erraguntla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Konow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Riepen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Droege</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lindemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Henriss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lund-Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Steibl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Borkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Der Wijngaart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mattson</surname></persName>
		</author>
		<idno type="DOI">10.1145/2442516.2442540</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="108" to="109" />
		</imprint>
	</monogr>
	<note>In ISSCC</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">The SCC Platform Overview</title>
		<author>
			<persName><surname>Intelscc</surname></persName>
		</author>
		<ptr target="http://communities.intel.com/servlet/JiveServlet/downloadBody/5512-102-2-22524/SCC_Platform_Overview.pdf" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficient verification of symmetric concurrent systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Ip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICCD.1993.393375</idno>
		<ptr target="http://dx.doi.org/10.1109/ICCD.1993.393375" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1993 IEEE International Conference on Computer Design: VLSI in Computers and Processors (ICDD&apos;93)</title>
		<meeting>the 1993 IEEE International Conference on Computer Design: VLSI in Computers and Processors (ICDD&apos;93)</meeting>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="230" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Better verification through symmetry</title>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Norris</forename><surname>Ip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
		<idno type="DOI">BF0062596810.1007/BF00625968</idno>
		<ptr target="http://dx.doi.org/10.1007/" />
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="41" to="75" />
			<date type="published" when="1996">1996. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Rigel: An architecture and scalable programming interface for a 1000-core accelerator</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">H</forename><surname>Kelm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neal</forename><forename type="middle">C</forename><surname>Crago</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Tuohy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aqeel</forename><surname>Mahesri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><forename type="middle">S</forename><surname>Lumetta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">I</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjay</forename><forename type="middle">J</forename><surname>Patel</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICCD.1993.393375</idno>
		<ptr target="http://dx.doi.org/10.1145/1555754.1555774" />
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Optimistic parallelism requires abstractions</title>
		<author>
			<persName><forename type="first">Milind</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Walter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ganesh</forename><surname>Ramanarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kavita</forename><surname>Bala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">Paul</forename><surname>Chew</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF00625968</idno>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="211" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The Stanford DASH multiprocessor</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Lenoski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Laudon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kourosh</forename><surname>Gharachorloo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolf-Dietrich</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anoop</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Horowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Monica</forename><surname>Lam</surname></persName>
		</author>
		<idno type="DOI">10.1145/1555754.1555774</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="63" to="79" />
			<date type="published" when="1992-03">March 1992. March 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Reflex: Using low-power processors in smartphones without knowing them</title>
		<author>
			<persName><forename type="first">Felix</forename><surname>Xiaozhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Zhen</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Likamwa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lin</forename><surname>Zhong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Conference on Architectural Symposium on High Performance Computer Architecture (HPCA&apos;11)</title>
		<meeting>the 17th International Conference on Architectural Symposium on High Performance Computer Architecture (HPCA&apos;11)</meeting>
		<imprint>
			<publisher>IEEE Computer Society, Washington</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="132" to="143" />
		</imprint>
		<respStmt>
			<orgName>DC</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">High-performance fractal coherence</title>
		<author>
			<persName><forename type="first">Gwendolyn</forename><surname>Voskuilen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Vijaykumar</surname></persName>
		</author>
		<idno type="DOI">10.1145/2541940.2541982</idno>
		<ptr target="http://dx.doi.org/10.1145/2541940.2541982" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;14)</title>
		<meeting>the 19th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS&apos;14)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="701" to="714" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Workshop on determinism and correctness in parallel programming</title>
		<author>
			<persName><surname>Wodet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><surname>Wodet</surname></persName>
		</author>
		<title level="m">Workshop on determinism and correctness in parallel programming</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Workshop on determinism and correctness in parallel programming</title>
		<author>
			<persName><surname>Wodet</surname></persName>
		</author>
		<idno type="DOI">10.1145/2541940.2541982</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Workshop on determinism and correctness in parallel programming</title>
		<author>
			<persName><surname>Wodet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">A tagless coherence directory</title>
		<author>
			<persName><forename type="first">Jason</forename><surname>Zebchuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijayalakshmi</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moinuddin</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Moshovos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>In MICRO</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">PVCoherence: Designing flat coherence protocols for scalable verification</title>
		<author>
			<persName><forename type="first">Meng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jesse</forename><forename type="middle">D</forename><surname>Bingham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 IEEE International Symposium on High Performance Computer Architecture</title>
		<meeting>the 2014 IEEE International Symposium on High Performance Computer Architecture</meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Fractal coherence: Scalably verifiable cache coherence</title>
		<author>
			<persName><forename type="first">Meng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alvin</forename><forename type="middle">R</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Sorin</surname></persName>
		</author>
		<idno type="DOI">10.1109/MICRO.2010.11</idno>
		<ptr target="http://dx.doi.org/10.1109/MICRO.2010.11" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 43rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO&apos;43)</title>
		<meeting>the 2010 43rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO&apos;43)<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="471" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Protozoa: Adaptive granularity cache coherence</title>
		<author>
			<persName><forename type="first">Hongzhou</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arrvindh</forename><surname>Shriraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Snehasish</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandhya</forename><surname>Dwarkadas</surname></persName>
		</author>
		<idno type="DOI">10.1109/MICRO.2010.11</idno>
		<ptr target="http://dx.doi.org/10.1145/2485922.2485969" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual International Symposium on Computer Architecture (ISCA&apos;13)</title>
		<meeting>the 40th Annual International Symposium on Computer Architecture (ISCA&apos;13)<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="547" to="558" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
