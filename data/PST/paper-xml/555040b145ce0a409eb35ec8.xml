<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Science of Computer Programming ••• (••••) •••-•••</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Zoltán</forename><surname>Ujhelyi</surname></persName>
							<email>ujhelyiz@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gábor</forename><surname>Bergmann</surname></persName>
							<email>bergmann@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ábel</forename><surname>Hegedüs</surname></persName>
							<email>hegedusa@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ákos</forename><surname>Horváth</surname></persName>
							<email>ahorvath@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benedek</forename><surname>Izsó</surname></persName>
							<email>izso@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">István</forename><surname>Ráth</surname></persName>
							<email>rath@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zoltán</forename><surname>Szatmári</surname></persName>
							<email>szatmari@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dániel</forename><surname>Varró</surname></persName>
							<email>varro@mit.bme.hu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Measurement and Information Systems</orgName>
								<orgName type="institution">Budapest University of Technology and Economics</orgName>
								<address>
									<addrLine>Magyar tudósok krt. 2</addrLine>
									<postCode>H-1117</postCode>
									<settlement>Budapest</settlement>
									<country key="HU">Hungary</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Science of Computer Programming ••• (••••) •••-•••</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A70003E3C28822778487C7EBDB858C35</idno>
					<idno type="DOI">10.1016/j.scico.2014.01.004</idno>
					<note type="submission">Received 16 November 2012 Received in revised form 22 November 2013 Accepted 7 January 2014</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Live model query EMF Integrated development environment</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>As model management platforms are gaining industrial attention, the importance of automated model querying techniques is also increasing. Several important engineering tasks supported by model-based tools -such as well-formedness constraint validation or model transformations -rely on efficiently evaluating model queries. If the models change rapidly or frequently, it is beneficial to provide live and incrementally evaluated queries that automatically propagate model changes to keep query results consistent. The current paper reports on the of EMF-IncQuery framework focusing on new features of its integrated development environment (such as query validation and visualization) and its support for integrating queries to existing applications (e.g. by auto-generated data bindings) built on top of the industry standard Eclipse Modeling Framework (EMF). Our approach is illustrated on a case study integrating well-formedness constraints to the Papyrus UML tool by live model queries of EMF-IncQuery with negligible additional manual programming effort.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>As model management platforms are gaining more and more industrial attention, the importance of automated model querying techniques is also increasing. Queries form the underpinning of various technologies such as model transformation, code generation, domain-specific model execution and well-formedness validation that are all essential in state-of-the-art modeling tools and toolchains.</p><p>The leading industrial modeling ecosystem, the Eclipse Modeling Framework (EMF <ref type="bibr" target="#b0">[1]</ref>), provides different ways for querying the contents of models. These approaches range from manually coded model traversal to high-level declarative constraint languages such as Eclipse OCL <ref type="bibr" target="#b1">[2]</ref>. However, industrial experience <ref type="bibr" target="#b2">[3]</ref> shows strong evidence of scalability problems in complex query evaluation over large EMF models, and manual query optimization is time consuming to implement on a case-by-case basis.</p><p>In order to overcome this limitation, the EMF-IncQuery framework (first introduced in <ref type="bibr" target="#b2">[3]</ref>) proposes to use declaratively specified queries over EMF models, executing them efficiently without manual coding using incremental graph pattern matching techniques <ref type="bibr" target="#b3">[4]</ref>. The benefits of EMF-IncQuery with respect to the state-of-the-art of querying EMF models <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">5]</ref> include: (i) a high-level and powerful declarative graph pattern based query language <ref type="bibr" target="#b5">[6]</ref>, (ii) a highly efficient query engine capable of evaluating queries over models with millions of elements <ref type="bibr" target="#b2">[3]</ref>, and (iii) an advanced integrated development environment <ref type="bibr" target="#b6">[7]</ref>  to ease the construction and validation of model queries. In addition, (iv) the EMF-IncQuery efficiently addresses several shortcomings of the EMF API (such as instance enumeration of a certain type and backward navigation). Furthermore, (v) its modular architecture enables easy integration with existing EMF-based modeling tools <ref type="bibr" target="#b7">[8]</ref>. Finally, (vi) its underlying implementation supports multi-threaded and parallel processing, node sharing and other low-level optimization strategies <ref type="bibr" target="#b8">[9]</ref>.</p><p>In the current paper, we present the state-of-the-art EMF-IncQuery framework by focusing on the integrated development environment and integration aspects. As a novel contribution with respect to previous papers <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> we present novel visualizations of queries, new validations for queries and the new data binding features for EMF integration. Furthermore, we significantly extend the description of the underlying tool architecture. Additionally, we compare the query evaluation performance of the Eclipse OCL project <ref type="bibr" target="#b1">[2]</ref> and the EMF-IncQuery framework using a new, incremental query evaluation benchmark. As a new case study, we illustrate how EMF-IncQuery can be integrated into the Papyrus UML modeling tool <ref type="bibr" target="#b9">[10]</ref> to provide advanced querying, visualization and on-the-fly model validation over UML models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Structure of the paper</head><p>The rest of the paper is structured as follows. In Section 2 we give a brief overview of the query language and a high level overview of the EMF-IncQuery framework. In Section 3, we present the novel features of the development environment targeted at the specification, visualization and debugging of live model queries. As a follow-up, in Section 4 we elaborate the case study to highlight the most important integration features of EMF-IncQuery. Section 5 features an incremental query evaluation benchmark that is used to compare the query performance of EMF-IncQuery and the Eclipse OCL project. Section 6 summarizes related work, and Section 7 concludes the paper discussing directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background: incremental model queries</head><p>In this section we give a quick overview of the EMF-IncQuery framework. After a short presentation of the UML Class Diagram formalism, we describe the query language together with the basics of graph patterns in Section 2.1. Then we introduce the query engine, including the change reporting facilities, in Section 2.2, and finally the development environment for model queries in Section 2.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1.</head><p>In this paper we rely on UML class diagrams to introduce the technicalities of our approach. The corresponding subset of the UML metamodel is depicted in Fig. <ref type="figure">1</ref>(a) using the representation of the EMF Ecore language. The central element is an EClass named Class that has two EAttributes isAbstract and isLeaf . Additionally, it can contain any number of Operation and Property objects along two containment EReferences. Each of these inherits a name attribute from the NamedElement class. Finally, two classes can be in a Generalization relation expressed by an EClass Generalization leading from a child Class (specific) to a parent Class (general).</p><p>Fig. <ref type="figure">1</ref>(b) presents a UML class diagram conforming to the metamodel definition in Fig. <ref type="figure">1</ref>(a) based on an Eclipse EMFbased tree editor with five classes providing a multiple inheritance hierarchy. Each model object is represented by a tree item, attributes are either displayed in the labels, or only visible in a dedicated Properties view. Fig. <ref type="bibr">1(c)</ref> shows the same instance model in a graphical concrete syntax of UML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Defining model queries with graph patterns</head><p>The EMF-IncQuery framework aims at the efficient definition and evaluation of incremental model queries over EMFbased model, building on the idea of graph patterns <ref type="bibr" target="#b5">[6]</ref>. A graph pattern is a graph-like structure representing a condition (or constraint) matched against a large instance model graph. The graph pattern formalism is usable for various purposes in model-driven development, such as defining declarative graph transformation rules or capturing general-purpose model queries including model validation constraints <ref type="bibr" target="#b10">[11]</ref>.</p><p>A basic graph pattern consists of structural constraints prescribing the interconnection of nodes and edges of a given type, as well as expressions to define attribute constraints. A negative application condition (NAC) defines cases when the original pattern is not valid (even if all other constraints are met), in the form of a negative sub-pattern.</p><p>The nodes and attributes used in the constraints are referenced using pattern variables. The parameter variables of a graph pattern are a subset of the pattern variables that represent the model elements and attributes that are interesting from the perspective of the query user. Pattern variables that are not parameters are called local variables.</p><p>It is possible to check for only the existence (or non-existence in case of negative subpatterns) of a reference or subpattern by the use of single use variables. As such local variables are only used once in the pattern body, commonly as a parameter of a relation definition or a pattern call, their values are not interesting for any other constraint.</p><p>It is also possible to extend the capabilities of the declarative pattern definitions by the addition of imperative, Java-like check constraints. However, to support efficient incremental evaluation, it is expected that these check expressions are pure, deterministic functional methods (no side-effects), and model traversal is disallowed. These constraints are partially enforced by the language by only allowing to refer to variables storing EAttributes values from the pattern body.</p><p>A match of a graph pattern is a tuple of parameter variables that fulfills all the following three conditions: (1) have the same structure as the pattern; (2) satisfy all structural and attribute constraints; and (3) does not satisfy any NAC.</p><p>By default, the result of a model query expressed as a graph pattern is the set of all matches with different bindings for the pattern parameter variables. However, by binding parameter variables to model elements or attribute values it is possible to filter the returned values. This binding process allows the use of the same pattern for getting all possible matches and for checking whether a selected match is present in the result set.</p><p>The query language of EMF-IncQuery is a textual language describing graph patterns as a set of constraints. The entire language was specified in <ref type="bibr" target="#b5">[6]</ref>, in this paper we only give short example related to UML class diagrams.</p><p>Example 2. To illustrate the pattern language of EMF-IncQuery we present a set of patterns in Fig. <ref type="figure" target="#fig_1">2</ref>(a) for identifying empty classes in UML: classes that do not have operations or properties (not even in their superclasses), suggesting an incomplete model. However, if the name of the class is postfixed with the string "Empty", we consider the class empty by design, so it is not returned. Fig. <ref type="figure" target="#fig_1">2</ref>(b) shows an instance model, where the single empty class A is emphasized with a different background color. The SupEmpty class is not considered empty because of its name, while the classes B, C and D either define or inherit the property called refers.</p><p>The pattern superClass in Line 1 consists only of structural constraints: it describes the direct superclass relation by a generalization node (local variable gen) that is connected both to the classes referenced as sub and sup.</p><p>The pattern hasOperation in Line 7 consists of the disjunction of two bodies: one represents the fact that the selected class cl holds an Operation. The second body uses the transitive closure of the relation defined by the superClass pattern in Line 10 to select the indirect superclasses of a selected class, and then declares that the superclass owner holds an Operation.</p><p>Finally, the pattern emptyClass in Line 14 selects classes without operations and properties by evaluating two corresponding NACs (the hasProperty pattern is omitted as it works exactly the same as the presented hasOperation). The second parameters of the pattern calls are single-use variables (starting with the '_' symbol), so these NACs are simple non-existence checks. The check expression in the Line 18 reuses the String.endsWith Java method on a local variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">The runtime components of the EMF-IncQuery framework</head><p>The EMF-IncQuery framework provides an efficient incremental query engine based on Rete networks <ref type="bibr" target="#b11">[12]</ref>. At its core, the engine manages the incremental evaluation and lifecycle management of queries based on the Rete engine implementation originally developed for the VIATRA2 model transformation framework <ref type="bibr" target="#b3">[4]</ref>.</p><p>Fig. <ref type="figure" target="#fig_2">3</ref> gives an architectural overview of the EMF-IncQuery runtime components. In Fig. <ref type="figure" target="#fig_2">3</ref>(a) the subcomponents of pattern matchers and their data flow are depicted, while Fig. <ref type="figure" target="#fig_2">3</ref>(b) presents the internal states of the matcher. In the following, we give a brief overview of the entire matching process.</p><p>Incremental graph pattern matching by Rete Rete-based pattern matching relies on a network of nodes storing partial matches of a graph pattern. A partial match enumerates the model elements that satisfy a subset of the constraints of the graph pattern. Pattern matches are readily available at any time as they are updated incrementally at model changes.</p><p>Input nodes are used to represent the underlying model elements (e.g., EClasses, EReferences or EAttributes). Intermediate nodes are used to execute some basic operations -such as filtering, projection or join -on the outputs of connected Rete nodes (either input or other intermediate ones), and store and output the results. Finally, the match set of the entire pattern is available as an output (or production) node.</p><p>When a pattern matcher is initialized in EMF-IncQuery, the entire input model is traversed, setting up the Rete network. After the network is initialized, the pattern matcher becomes active, and returns the current query results on demand. Additionally, after a matcher is not required it can be disposed, removing the Rete network and freeing up used memory.</p><p>The EMF-IncQuery base indexer The contents of EMF instance models (and the corresponding change notifications) are connected to the query engine using a model indexer component called EMF-IncQuery Base. <ref type="foot" target="#foot_0">1</ref>The indexer creates and maintains caches of frequently used low-level incremental queries such as instant enumeration of all instances of a given EClass, or reverse navigation along unidirectional EReferences together with advanced features such as calculating the transitive closure of elements reachable using a set of EReferences.</p><p>The separation of the indexer from the Rete network is useful for two different reasons: (1) the indexer can be reused without the main query engine component in EMF applications, and (2) the indexer can extend the capabilities provided by the query engine with features cumbersome to implement inside Rete networks, such as the transitive closure.</p><p>Processing updates in an EMF context Upon creation, the indexer is set up to receive notifications about all changes affecting the opened EMF models, such as the creation or deletion of model elements. When receiving a notification, at first the Base index is updated, then the corresponding input nodes of the Rete network are notified. Each time an input node receives notifications, an update token is released on each of their outgoing edges. Upon receiving an update token, a Rete node determines how (or whether) the set of stored tuples will change, and release update tokens accordingly. This way, the effects of an update will propagate through the network, eventually influencing the result set stored in production nodes. To receive notifications of result changes, Delta monitors can be attached to output nodes that provide Query Result Deltas representing the added or removed matches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">The EMF-IncQuery development environment</head><p>The development workflow of the EMF-IncQuery framework focuses on the specification and evaluation of queries and the automatic generation of integration code for plugging into existing EMF-based applications. As depicted in Fig. <ref type="figure" target="#fig_3">4</ref>, the development environment offers three major components: (1) the Pattern Editor, (2) the Query Explorer and (3) the Code Generator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pattern editor</head><p>The EMF-IncQuery development environment provides an Xtext-based <ref type="bibr" target="#b12">[13]</ref> editor for the pattern language with syntax highlighting, code completion and well-formedness validation. The editor is tightly integrated with the other components: the code generator is integrated into the Eclipse builder framework, and is executed after changes in pattern definitions are saved (unless Eclipse automatic builders are turned off), while the Query Explorer updates the displayed query results. The well-formedness validation of queries is described in more detail in Section 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Query explorer</head><p>In order to evaluate complex model queries the EMF-IncQuery development environment provides the Query Explorer. This component visualizes live query results of both interpretative and generated pattern matchers in a generic view, and provides a quick feedback cycle during transformation development. The Query Explorer is presented in more detail in Section 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Code generator</head><p>The environment also helps the integration of queries into a Java application by maintaining a project with pattern-specific generated matcher code. The generated matcher is semantically equivalent of the interpretative one, but provides an easy-to-integrate type-safe Java API, and some performance optimizations are also executed.</p><p>Furthermore, the generator may also produce code for various integration components, such as the data binding support, validation framework or query-based features. These integration scenarios are detailed in Section 4.</p><p>Example 3. Fig. <ref type="figure" target="#fig_4">5</ref> shows the EMF-IncQuery development environment while developing the case study. On the left side the used model and plug-in projects are shown. As EMF-IncQuery projects are plug-in projects, their management relies on already existing Eclipse features (a). In the center, the Query Editor (b) is open next to the Papyrus UML editor (c) that contains a sample model for evaluating the queries currently developed. Finally, in the bottom of the screen the Query Explorer (d) has already loaded the model and the queries from the editors, and reacts on changes in any of the editors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Developing live model queries with EMF-INCQUERY</head><p>The EMF-IncQuery development environment supports the development of live model queries by (i) providing early feedback for possible errors in query definitions and (ii) providing various visualizations for queries and query results to help to understand and debug live model queries.</p><p>In this section, we introduce the main features of the EMF-IncQuery development environment targeting at the validation and understandability of live queries. At first, we present well-formedness constraint validation rules for graph patterns (Section 3.1), then the query explorer components for manual query evaluation (Section 3.2) and finally we present some graph visualizations for the various models used in EMF-IncQuery (Section 3.3). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Validation of model queries</head><p>The high-level, declarative nature of graph patterns combined with complex structures (e.g. transitive closures or pattern composition) still makes it possible to write erroneous queries that may lead to unexpected runtime behavior. Some of these flaws can be detected by static validators resulting in early feedback. In this paper, we present three useful well-formedness rules the environment validates that were implemented using as Xtext validators.</p><p>Type inference Type inference and type checking is used to identify pattern variables with inconsistent type constraints (e.g. stating that a variable has multiple incompatible EMF types). These issues are often introduced by a misparameterized pattern composition, such as incorrect ordering of parameters. In Fig. <ref type="figure" target="#fig_5">6</ref>(a) the parameters of the hasOperation call are swapped, resulting in ambiguous type constraints that is reported as an error.</p><p>As patterns with inconsistent type constraints always evaluate to empty result sets, these issues are marked as errors.</p><p>Connectedness The defined patterns are also checked for connectedness: if there are independent constraints in the pattern, the size of the result set and the memory consumption of the pattern matching increases as the Cartesian product. Such issues are often caused by a missing constraint. E.g., in Fig. <ref type="figure" target="#fig_5">6</ref>(b), two operations are selected from two classes, but neither the classes nor the operations are connected by any constraint.</p><p>In most cases, such connectedness problems represent an undesired behavior, however, as in some cases this may be intended, only a warning is reported containing the connected subsets of variables.</p><p>Detecting unused variables As a variable used only a single time frequently indicates a misspelled variable, a variable usage counter is implemented that checks the number of uses of variables in all pattern bodies. In Fig. <ref type="figure" target="#fig_5">6(c)</ref>, a new single-use variable c1 is introduced in the pattern body instead of the very similarly named parameter variable cl, altering the pattern to check existence whether the Operation is contained in any class.</p><p>As single-use variables are often useful, this issue is reported only as a warning with the suggestion that names singleuse variables should be prefixed with an '_' symbol. If the '_' prefix is used, the validator works differently: if the variable is used only once, nothing is reported, but if it used again, an error is reported.</p><p>Although unused variables are also reported by the connectedness validator, the variable counter is still useful as its more specific error messages of the usage counters guide the pattern developers how to fix these issues.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Applying queries to instance models</head><p>In addition to static analysis of the defined queries, the EMF-IncQuery development environment also supports the manual evaluation of query results by the Query Explorer. The component is already presented in greater detail in <ref type="bibr" target="#b6">[7]</ref>, now we only describe its architecture briefly, and discuss its integration of the query development workflow.</p><p>The Query Explorer is capable of loading input models from various sources, and execute the queries on them. The component reacts to both model and query changes, providing instant feedback during query development.</p><p>Architecture To support all these cases, we implemented the architecture depicted in Fig. <ref type="figure" target="#fig_6">7</ref>. The defined queries are loaded to a Query Repository that creates filtered groups of them. These definitions are referenced in the user interface and added to the Query Engine that also loads models. To load these models from various model sources, model source connectors were introduced that load models from existing editors, and allows navigating back to the model element definitions as needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Development workflow</head><p>To evaluate a query in the Query Explorer, both the query definitions and some sample models are to be loaded. The Query Explorer provides a single-button interface for loading both the query definitions and models from the currently open editor (regardless of their type). Traceability links are also maintained to support navigation to the pattern definition or model element in their corresponding editors when they are double-clicked in the Query Explorer.</p><p>When both queries and instance models are loaded, the Query Explorer groups matches by model source and query definition, and allows result filtering by binding query parameters (by default, all parameters are unbound). In case of model and query updates, the Query Explorer updates the displayed matches incrementally to have an always up-to-date results without blocking the user interface. Upon model changes the query result deltas provide sufficient information to update the displayed matches. However, in case of query updates, the created Rete network has to be re-created that might include a re-traversal of the input models. To avoid such re-traversals, the Query Explorer uses specialized Base indexers referring all possible model elements. The drawback of this approach is that it results in higher memory footprint for the EMF-IncQuery framework than standard execution, where query-specific indexers are created only from elements interesting for the current set of queries. For more details about incremental update procedure of the component please consult <ref type="bibr" target="#b6">[7]</ref>.</p><p>This incremental update feature allows updating queries in the pattern editor, saving the changes and the match results are instantly updated. This results in a short feedback cycle, making the Query Explorer a key component of our query definition workflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Visualizing graph patterns</head><p>In order to provide a graphical overview of the structure of defined queries, two graph-based visualizations were designed to depict the structure of the patterns: the connections between interdependent patterns and the internal constraint graph of single patterns.</p><p>All visualizations are created using the Zest graph visualization framework <ref type="bibr" target="#b13">[14]</ref> that simplifies the definitions of Eclipseintegrated visualizations. The framework comes with a set of graph layout algorithms that can be extended by custom algorithms. Visualized graphs can also be rearranged by the query developer manually to ease understanding of the more complex cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1.">Call graph visualization</head><p>To visualize the connection between the interdependent patterns, a simple call graph is created: its nodes are the patterns, and two patterns are connected by a directed edges if the first pattern contains a reference to the second one (both positive and negative constraints are considered).</p><p>Example 4. The call graph of the patterns mentioned in Fig. <ref type="figure" target="#fig_1">2(a</ref>) is presented in Fig. <ref type="figure" target="#fig_7">8(a)</ref>. The outgoing NACs of the empty-Class pattern are presented with red lines, while other connections with blue ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2.">Constraint graph visualization</head><p>A different way to visualize graph patterns is to create a constraint graph <ref type="bibr" target="#b14">[15]</ref> similar to the one used to visualize constraint satisfaction problems. A constraint graph is a hypergraph, whose nodes are the pattern variables and constant values used inside a graph pattern; hyperedges between nodes represent a constraint referring all corresponding variables. Unary (type) constraints are included inside the label of the variable node.</p><p>Example 5. The constraint graph of the superClass pattern (displayed in Fig. <ref type="figure" target="#fig_7">8(b</ref>)) consists of three nodes: the parameter variables sub and sup, and the local variable gen that are connected with two references (namely Generalization.general and Generalization.specific).</p><p>Pattern composition constraints could refer to any number of variables, so the hyperedge needs to connect several nodes. This is displayed in the constraint graph of the hasOperation pattern in Fig. <ref type="figure" target="#fig_7">8(c</ref>): both the ownsProperty and the superClass patterns are connected to two variables -one in common and one unique. Negative pattern composition constraints are displayed in a different color (in this case red), as seen in the visualization of the emptyClass pattern in Fig. <ref type="figure" target="#fig_7">8(d)</ref>. Additionally, that pattern uses anonym variables as well, that are also represented using a lighter grey color. Such constraint graphs are useful for giving a quick overview of how the various variables interact while calculating the results of a graph query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Integrating EMF-INCQUERY into EMF-based applications</head><p>When developing EMF-based applications, there are some common tasks that are easy to express with live query evaluation. In order to support these cases, EMF-IncQuery provides integration components. An integration component may extend the language with a new annotation (and some corresponding validation) and adds a new code generator fragment that generates the required integration code for the selected framework.</p><p>EMF-IncQuery already includes three different integration frameworks: (i) data binding support eases user interface development for EMF applications by supporting the display of model elements in forms; (ii) the validation framework provides live well-formedness constraint validation for custom EMF editors; and (iii) query-based derived features allows enriching EMF models by new attribute values or references calculated (and updated) by model queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Data binding support</head><p>Data binding overview Data binding, supported in Eclipse applications by the JFace Data binding <ref type="bibr" target="#b15">[16]</ref> framework, is a generic, declarative technique for binding and synchronizing data between data sources called Observables. An Observable has a set of Observable (property) values representing its current state. A Binding synchronizes two Observable values, either uni-or bidirectionally.</p><p>The JFace Data Binding framework already supports the creation of Observables from EMF model elements. For each model element, the list of observable values include all declared attributes and references, and it can be extended using simple, path-based traversals. However, creating a filtered observable list is not supported directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Queries as data sources</head><p>The result deltas of model queries allows an efficient implementation of bindings, as it is possible to get notified about only the relevant model changes. There are two ways to bind query results: (1) binding the entire match set into a table or list component, or (2) binding a single match into any selected UI component (e.g., a label or a tree item). It is also possible to combine these approaches, e.g., in the "master-detail data binding" scenario the selection of a selected list or table (master) acts as the source element of some other UI components (detail) bindings.</p><p>Fig. <ref type="figure" target="#fig_8">9</ref> depicts the architectural overview of query-based data bindings. When setting up the bindings, a Match Set Observer is created from the result set of the selected pattern, together with Match Observer for every match.</p><p>The update process goes as follows: in case of model modifications (1) the pattern matcher is notified (2). If a new match appears or disappears during the processing of the changes, the Match Set Observer is notified (3.a) to propagate the changes using the data binding framework into the UI by adding or removing displayed items (4.a). Similarly, the created match observers listen to property updates of existing matches (3.b). These changes are also transferred into the UI by the data binding framework, updating existing UI components (4.b). Example 6. To illustrate the concept of observable matchers, we will collect all the empty classes of the model. Additionally, we created two observable values storing whether the selected class is abstract or a leaf class. The required annotations are presented in Fig. <ref type="figure" target="#fig_9">10(a)</ref>.  Based on the annotated patterns the data binding generator creates pattern-specific Observables that can be bound to the user interface using the standard JFace Data Binding API. This allows user interface programmers to bind the results of the pattern matcher of the emptyClass pattern to a table or list widget. Fig. <ref type="figure" target="#fig_9">10(b</ref>) depicts a table viewer filled with this observable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Validation framework</head><p>Well-formedness constraint validation is important for domain-specific language editors, as it allows correcting problems before they cause problems in the developed applications. The EMF Validation Framework project <ref type="bibr" target="#b16">[17]</ref> supports the definition of well-formedness constraints that can be executed manually. However, an incremental query engine could provide live validation by reporting errors during editing, instantly when they are introduced.</p><p>EMF-IncQuery allows the definition of such live model validation <ref type="bibr" target="#b10">[11]</ref> as depicted in Fig. <ref type="figure" target="#fig_10">11</ref>. The EMF-IncQuery Validation Framework consists of a dedicated service that manages the defined constraints, loads models and creates (and updates) problem markers of the constraint violations. Although EMF-IncQuery does not depend on the EMF Validation Framework, the created problem markers are the same. This means, if an editor, such as the Papyrus UML editor <ref type="bibr" target="#b9">[10]</ref>, displays violations graphically, it will also work with the markers of EMF-IncQuery.</p><p>Constraints are generated from annotated patterns from the query language to describe the erroneous model element, the error message and its severity.</p><p>Example 7. The validation annotations for empty classes is presented in Fig. <ref type="figure" target="#fig_1">12(a)</ref>.</p><p>To associate error markers to empty classes, a Constraint annotation needs to be added. The annotation parameters specify the severity of the issue, the model element that the marker needs to be attached to (location), the error message. Additionally, setting the optional editor identifier parameter generates the initialization code for the selected editor.</p><p>During runtime, after running the generated initialization code (available from the menu), the found markers are displayed, as presented in Fig. <ref type="figure" target="#fig_1">12(b</ref>). The Problems view on the right lists all errors (including the ones of the Validation Framework), while based on the support of Papyrus UML red icons are used to visually present the error locations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Query-based features</head><p>A third integration scenario we considered is enriching EMF models with derived features, that is representing information that can be calculated from other elements. EMF allows defining such derived features via Java code, however, it is challenging to provide an implementation with transparent EMF notification mechanism and reasonable performance. EMF-IncQuery queries were proposed as an implementation for the features in <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>, as the use of generic adapter code (provided by EMF-IncQuery) makes it possible to return the results of an arbitrary query as an EMF derived feature.</p><p>Example 8. To illustrate query-based feature support we defined a traceability metamodel between UML classes in Fig. <ref type="figure" target="#fig_2">13(a)</ref>. The metamodel consists of only a single TraceElement class that refers to a source and a target class. However, as the traceability relation is related to the subtypes of the referred classes, we introduce two derived features that list all classes that extend the source and target classes respectively. Fig. <ref type="figure" target="#fig_2">13(b</ref>) describes the pattern we use to define the inheritedTarget feature. The pattern finds the Class at the target reference of the TraceElement and returns all its subclasses (using the previously defined superClass pattern). Then the QueryBasedFeature annotation is used to select the EMF derived feature to provide the adapter. The generator fragment for query-based features is capable of finding and modifying the Java code generated from the metamodel, making the integration seamless from the model users perspective, while change notifications rely on the query result delta feature of EMF-IncQuery.</p><p>Finally, Fig. <ref type="figure" target="#fig_2">13(c</ref>) shows the derived feature in a UML context: by setting the Target reference in a Trace Element, all</p><p>Inherited Targets are calculated automatically.</p><p>The support for query-based features complements data binding support. In both cases, existing models are extended with automatically calculated features together with change notification. However, data binding support is used outside the boundaries of the metamodel, while query-based features extend existing ones transparently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Query performance benchmark</head><p>When integrating model queries into off-the-shelf applications, a very important aspect is the scalability of the approach. For this purpose, we first introduce a benchmark that is motivated by well-formedness constraint validation executed on user-performed editing steps in Section 5.1. Then we present the comparison results between EMF-IncQuery and the OCL in Section 5.2. In this paper only the main results are published, for detailed measurement values and installation artefacts please refer to our benchmark website <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Benchmark specification</head><p>Our macrobenchmark addresses on-the-fly model validation in (domain-specific) model editors: at first, the entire model is validated, then after each model manipulation (e.g., the deletion of a reference) is followed by an immediate re-validation.</p><p>Instead of relying on the UML example used throughout the paper, a new metamodel and corresponding model queries motivated by our industrial experiences <ref type="bibr" target="#b20">[21]</ref> are defined for benchmarking purposes. This domain enables the definition of both simple and more complex model queries while it is uncomplicated enough to incorporate solutions from other technological spaces (e.g. ontologies, relational databases and RDF). This allows the comparison of the performance aspects of wider range of query tools from a constraint validation viewpoint.</p><p>As opposed to database query measurements, such as <ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref>, our benchmark focuses more on response time than throughput based on predefined queries on evolving models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1.">Benchmark process</head><p>To measure performance also when the underlying model is changing, four benchmark phases were defined, as illustrated in Fig. <ref type="figure" target="#fig_12">14.</ref> 1. During the read phase, the previously generated instance model is loaded from hard drive to memory. This includes the parsing of the input as well as initializing data structures of the tool. The time for tool initialization normally increases with the amount of caching used in a specific tool. 2. In the check phase, the instance model is queried to identify invalid elements. This can be as simple as reading the results from cache, or the model can be traversed based on some index. By the end of this phase, erroneous objects need to made available in a list. 3. In the edit phase, the model is modified to simulate effects of manual user edits. Here the change set is small, compared to modifications by model transformations tool. 4. The re-validation of the model is carried out in the re-check phase similarly to the check phase.</p><p>When executing the benchmark, the time of each phases is recorded separately, but form the perspective of user experience, two aggregated values are interesting. The first time called batch validation is the time that the user must wait to start to use the tool, represented by the sum of the read and check phases. The incremental validation is consists of the edit and re-check phases performed 100 times, expressing the time that the user spent waiting for the tool validation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2.">Railway domain</head><p>The railway domain is presented in Fig. <ref type="figure" target="#fig_13">15</ref> with a metamodel (enhanced with statistics). TrackElements can be connected to each other, which are Segments (with length) or Switches (characterized by their actual state). A Route is defined by a series of Sensors (installed next to TrackElements), with an entry and exit Signal.</p><p>To show some characteristics of the generated instance models, the distribution of the object types and the average number of edges for each object is also presented in Fig. <ref type="figure" target="#fig_13">15</ref>. In case of classes the percentage of instances is shown: e.g., 3.4% of the model elements are instance of the class Switch, 77.0% is Segment, thus 80.4% of the model is TrackElement. The average number of the given relation for an instance is displayed for associations: e.g., there are 9.5 switchPosition relations in average for every instance of the Route class.</p><p>This railway domain (and defined queries) developed for this benchmark were also tested and used previously by our academic partner <ref type="bibr" target="#b24">[25]</ref> for evaluating a local search based pattern matching algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3.">Instance model generation</head><p>In the first phase of the benchmark, a previously generated instance model is loaded from the file system. These models are systematically generated based on the metamodel and the defined complex model queries: small instance model fragments are generated based on the queries, and then they are placed, randomized and connected to each other. The methodology takes care of controlling the number of matches of all defined model queries.</p><p>To break symmetry, the exact number of elements and cardinalities are randomized. This brings artificially generated models closer to real world instances, and prevents query tools from efficiently storing or caching of instance models. During the generation of the railway system model, errors are injected at random positions. These errors can be found in the check phase of the benchmark, which are reported, and can be corrected during the edit phase.</p><p>The initial number of constraint violating elements are low (e.g. 0.3% of model elements for the RouteSensor case). The exact match count of each generated instance model and query is presented in the benchmark website <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.4.">Queries</head><p>In the validation and re-validation phase of the benchmark, elements violating well-formedness constraints are returned by the queries. These constraints are first defined informally in plain text (in a tool independent way) and then formalized using the standard OCL language as a reference implementation (available on the benchmark website <ref type="bibr" target="#b19">[20]</ref>). Finally, the functionally equivalent variants of these queries are formalized using the query language of different tools applying tool based optimizations. As a result, all query implementation must return (the same set of) invalid instance model elements.</p><p>Two simple queries (involving at most two objects) and two complex queries (involving 4-7 variables and joins) were defined and the graphical representation of each queries can be seen in Fig. <ref type="figure" target="#fig_14">16</ref>. More detailed, technical-level query definitions are available at the benchmark website <ref type="bibr" target="#b19">[20]</ref>.</p><p>• The constraint PosLength checks, whether Segments have non-negative length. Violation can occur, for example, when the length remained on a default (zero or negative) value since the object's creation. This query realizes a simple integer attribute check.</p><p>• The following SwitchSensor query is a safety requirement, and the textual definition is: Every switch must have at least one sensor connected to it. This validation query checks for a missing sensor reference, represented by a negative application condition (depicted as NEG).</p><p>• The RouteSensor constraint is used to check for broken cycles as follows: All sensors that are associated with a switch that belongs to a route (along a predefined switch position), must also be associated directly with the same route. This is enforced by describing the missing route Definition edges (NEG).</p><p>• The most complex query in the benchmark is called SignalNeighbor, which specifies the following constraint: A route is incorrect, if it has an exit signal, and a sensor connected to another sensor (which is in a definition of another route) by two track elements, but there is no other route that connects the same signal and the other sensor (NEG).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.5.">Query implementation</head><p>These queries are implemented in OCL (for Eclipse OCL and Impact Analyzer) and in EMF-IncQuery, detailed on the benchmark website <ref type="bibr" target="#b19">[20]</ref>. Although, some important aspects are illustrated in Fig. <ref type="figure" target="#fig_15">17</ref> by the SwitchSensor query.</p><p>In this case, the OCL implementation described in Fig. <ref type="figure" target="#fig_15">17</ref>(a) only checks the attribute for all switches. On the other hand, when backward navigation is needed (imagine that the Switch class has no sensor relation, but only the Sensor class has a switch relation), only target individuals can be enumerated with the (resource intensive) allInstances() operation, and navigation can start from these target objects. Such OCL query (with the same meaning) is depicted in Fig. <ref type="figure" target="#fig_15">17(b</ref>), but the same construct was needed for the SignalNeighbor query (Fig. <ref type="figure" target="#fig_14">16(d)</ref>), because all objects cannot be navigated starting from a Route context object.</p><p>For the EMF-IncQuery query implementation such enumerations are indexed by default (which means that it is a cheap operation), and the language enables navigation in both ways (see Line 8, where named relations are used, and variables are written in the correct order). An important feature is that commonly used subpatterns can be extracted (by giving them a name), and referred from other patterns, like the pattern switchSensor which calls hasSensor (negatively). Subpatterns can be called positively also, which is extensively used in the SignalNeighbor pattern (Fig. <ref type="figure" target="#fig_14">16(d)</ref>), as e.g. the Route-Sensor-TrackElement subpattern occurs twice. Such subpattern reuse is resulted in lower memory usage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.6.">Model modification</head><p>In the edit phase the model is modified to change the result set to be returned by the query in the re-check phase. During the modification the simulated user always performs hundred random edits (fixed low constant) which increases the number of erroneous elements. An edit operation only modify single model elements at once -more complex model manipulation is modeled as a series of edits.</p><p>In the PosLength query's modify phase a randomly selected segment's length is updated to 0, which means that an error is injected. In the case of SwitchSensor query, errors are injected by deleting sensor relations of randomly selected switches which became invalid. In the case of the RouteSensor query, the route definition connection between the randomly selected routes and their first connected sensors are removed. In the fourth, the SignalNeighbor case, errors are introduced by unconnecting the entry edge of the selected routes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Performance comparison of EMF-IncQuery and Eclipse OCL</head><p>In this section, we compare the performance of the Eclipse OCL tool with EMF-IncQuery focusing on the execution times of batch validation and incremental validation. This approach focuses on the user-visible aspects of the benchmark, thus demonstrating the usefulness of the query tools in the integration use-case presented in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1.">An overview of the Eclipse OCL Project</head><p>The OCL <ref type="bibr" target="#b25">[26]</ref> language is commonly used for querying EMF model instances in validation frameworks. It is a standardized navigation-based query language, applicable over a range of modeling formalisms. Taking advantage of the expressive features and wide-spread adoption of this query language, the project Eclipse OCL <ref type="bibr" target="#b1">[2]</ref> provides a powerful query interface that evaluates such expressions over EMF models.</p><p>The project also supports incremental evaluation by including an Impact Analyzer (IA) <ref type="bibr" target="#b26">[27]</ref> that calculates the constraints to be reevaluated based on a model change. During EMF modifications it looks for possible context objects that could change the match set, and re-evaluation can be executed only for those objects. As it is intended only for incremental use, Eclipse OCL is used for calculating the first result set (batch mode).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2.">Environment and measurement methodology</head><p>In order to measure tool efficiency instead of some bottlenecks (e.g. the lack of memory) or transient effects (like random CPU hogs), we payed attention to the hardware-software environment. The benchmark was executed on a physical machine that contains two quad core Intel Xeon L5420 CPU (2.50 GHz), 32 GBs of RAM. 64 bit Ubuntu 12.04 OS with OpenJDK JVM version 1.6.0_24 was used. To avoid external influences, such as swapping, trashing or parallel software execution, swap support, and unnecessary operating system services (like cron) were turned off, and disk caches were cleared between executions. Similarly, to avoid Java garbage collection, an extra large heap limit (15 GB) was set.</p><p>Before acquiring memory usage (free heap space) from the JVM, GC calls were triggered five times to sweep unfreed objects from the RAM. The time of each phase was recorded with millisec precision and recorded to CSV format for offline evaluation.</p><p>To measure the scalability of the tools the implemented queries were executed on a set of generated models between sizes 30 k and 14 M model elements. Each total time was limited to 12 minutes.</p><p>To make the performance measurements of a tool for a given query-model pair was independent from the others, every measurement was run in a different JVM. This large degree of isolation was required to reduce the effects of complex interference between queries and instance models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3.">Measurement results</head><p>The measurement results of the benchmark is displayed in Fig. <ref type="figure" target="#fig_16">18</ref>. These diagrams show the batch query performance, incremental evaluation time, and memory usage of each tools, for different model sizes. Additionally, the initial and the updated result set size is displayed under the model sizes in the batch and incremental queries, respectively.</p><p>The left column shows charts of the RouteSensor query, while the more complex SignalNeighbor is presented in the right column. The remaining PosLength and SwitchSensor queries are only presented at the benchmark website <ref type="bibr" target="#b19">[20]</ref>, as their results are very similar to the RouteSensor case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Batch query evaluation</head><p>In case of batch query evaluation, both OCL implementations use the same algorithm, thus their execution time is roughly the same. The roughly negligible differences are due to the initialization of the OCL Impact Analyzer.</p><p>For the batch query evaluation of the RouteSensor query Fig. <ref type="figure" target="#fig_16">18</ref>(a) shows that EMF-IncQuery performs similarly to Eclipse OCL. It is slightly faster for small models (2 s and 3 s respectively), but is slower for large models (up to 125 s and 78 s), where this 50% slowdown (once in the whole scenario) can be attributed to the initial (Rete) cache build.</p><p>For the more complex SignalNeighbor query Fig. <ref type="figure" target="#fig_16">18</ref>(b) depicts that EMF-IncQuery (somewhat surprisingly) outperforms OCL solutions: it is noticeably faster for small models (2 s and 4 s), and over 435 k model elements OCL did not finish with the initial analysis in 12 minutes. This performance gain might be attributed to the more efficient (cached) enumeration of instances, and the possibility of backward navigation (with the help of auxiliary structures) on unidirectional references used by this query.</p><p>Incremental query evaluation In the incremental case, Eclipse OCL evaluates the query on each issue (i.e.: hundred times) from scratch, its execution time increases linearly with model size, resulting slow overall evaluation.</p><p>For the RouteSensor query (Fig. <ref type="figure" target="#fig_16">18(c</ref>)), the Impact Analyzer performs the 100 modifications in 50 ms regardless of the model size. On the same query, EMF-IncQuery starts much faster, but its speed reduces on the larger models (from 9 to 220 ms). On the other hand, the Impact Analyzer is an order of magnitude slower on the SignalNeighbor query (Fig. <ref type="figure" target="#fig_16">18(d)</ref>) The performance of the Impact Analyzer is most likely affected by the previously mentioned unidirectional references. The slowdown of EMF-IncQuery is probably caused by the increased number of matches (from 116 to 8592), as query results are always available in the output nodes of Rete networks, and only a linear traversal of these stored matches is needed to return them. Memory usage Fig. <ref type="figure" target="#fig_16">18</ref>(e) and Fig. <ref type="figure" target="#fig_16">18</ref>(f) show the memory usage of the measured tools. As batch OCL evaluation does not need extra data structures (e.g.: caches), its memory measurements show basically the amount of memory needed to load the models, from 4 MB up to 660 MB in case of the largest model. Impact Analyzer needed up to 50% more memory, from 6 MB to 1 GB. The size of Rete networks created by EMF-IncQuery are largely query-dependant, increasing memory usage between a factor of 3 and 5, loading the largest models between 1.5 and 6 GB of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4.">Threats to validity</head><p>We tried to mitigate internal validity threats by reducing the number of uncontrolled variables during measurements: a physical machine was used with all unnecessary software components turned off and every execution was isolated into a freshly initialized JVM.</p><p>The queries are semantically equivalent in the different query languages and the result sets are the same for every model. Additionally, to ensure comparable results the created high-quality query implementations were reviewed: the OCL implementation by Ed Willink from the Eclipse OCL project, the usage of Impact Analyzer by Axel Uhl from the Impact Analyzer developer team. The graph patterns were written by the developers of EMF-IncQuery.</p><p>Considering external validity, the generalization of the results largely depends on how representative the metamodels, the models and the queries are compared to real use cases. In this paper, only a limited query feature set was measured, however the follow-up paper <ref type="bibr" target="#b27">[28]</ref> details how to define the complexity of various query-instance model combinations.</p><p>The metamodel and the query specifications were motivated by an industrial case study, and the selected queries feature commonly used validation tasks such as attribute and reference checks or cycle detection. We tried to ensure that the instance models have a similar structure and distribution to other models by parameterizing the generation process based on our experience with other domains. To summarize, we believe that the train domain and the generated instance models represent other domain-specific languages and available instance models well.</p><p>Our current measurements only loaded and executed a single query in each run. When loading multiple queries, query interference may change the results greatly. A more detailed evaluation of this issue is planned for the future.</p><p>Considering resource-constrained environments, we believe that limiting available memory will alter the results the most, as the memory management overhead will reduce the performance of EMF-IncQuery.</p><p>It is important to note that heap usage were measured after executing a garbage collection, so these measurements do not contain memory usage of temporary constructs. This means that maximum heap usage might have been larger. Furthermore, limiting heap space by the maximum usage results in excessive garbage collection and thus an increased runtime. However, in our experience setting the limit to two times the measured values, such issues do not occur.</p><p>In case of the benchmark queries, we measured a 1.5 GB heap size in case of a model with 3.5 M model elements that we believe is manageable in a developer machine with 4-8 GB of RAM. On the other hand, when handling such large models the existing user interface itself could become a bottleneck. Thus we believe, our measurement results hold also in the integrated development environments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.5.">Summary</head><p>To summarize our results, by comparing the query performance of EMF-IncQuery and OCL we have demonstrated that EMF-IncQuery is capable of maintaining query results efficiently, even on models with 14 million model elements.</p><p>In case of simpler queries, the batch query time is comparable to OCL-based solution, while in case of complex queries it performs better. After incremental updates the Rete algorithm makes the updated results available quickly, clearly outperforming the OCL-based solutions.</p><p>From resource usage it can be said that while EMF-IncQuery uses more memory, it is clearly not an issue for models smaller than 100 K elements. Although larger (a few hundred MBs) of memory is required for models from 100 K to 1 M elements, can be handled with careful implementations (e.g., by avoiding unconnected patterns that increase the memory usage). However, this queries are executed faster than in case of OCL. For models larger than 1 M elements, several GBs of heap space is required, but the response times of EMF-IncQuery scale better for complex queries and model sizes.</p><p>To summarize, batch query response times are comparable for all implementations. However, for incremental cases (and complex queries), EMF-IncQuery performed faster at the cost of higher memory usage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related work</head><p>General purpose database tools In the database community, several development environments were proposed for SQL queries, such as the MySQL Workbench <ref type="bibr" target="#b28">[29]</ref>, the InfoSphere Data Architect <ref type="bibr" target="#b29">[30]</ref> or the Oracle Enterprise Manager <ref type="bibr" target="#b30">[31]</ref>. The tools have various capabilities, but in general they provide query editing and evaluation support, often including static and dynamic validation to detect performance bottlenecks. Additionally, the Enterprise Manager tool can also generate a Graphical Explain Plans to give an insight to the performance of queries. For the comparison of MySQL and EMF-IncQuery see our preliminary results at our benchmark webpage <ref type="bibr" target="#b19">[20]</ref>.</p><p>In case of graph databases, similar environments are available, such as the Neoclipse environment <ref type="bibr" target="#b31">[32]</ref> for the Neo4j database. The environment allows to edit and evaluate queries, and additionally provides a graph visualization tool for the underlying models. The first performance results of this tool in context of our benchmark is available online <ref type="bibr" target="#b19">[20]</ref>.</p><p>A simultaneous visualization for multiple query results were proposed in <ref type="bibr" target="#b32">[33]</ref>. The query structures can also be presented as proposed in <ref type="bibr" target="#b33">[34]</ref>.</p><p>Furthermore, these solutions require significant additional integration effort to embed into existing EMF applications compared to EMF-IncQuery.</p><p>Model queries over EMF There are several technologies for providing declarative model queries over EMF. Here we give a brief summary of the mainstream techniques, none of which support incremental behavior.</p><p>EMF Model Query 2 <ref type="bibr" target="#b4">[5]</ref> provides query primitives for selecting model elements that satisfy a set of conditions; these conditions range from type and attribute checks to enforcing similar condition checks on model elements reachable through references. Unfortunately, the limited expressive power of Model Query 2 permits only simple queries. For example, more complex patterns involving circles of references or attribute comparisons between nodes cannot be detected. However, Query 2 can also evaluate queries on instance models that have not been loaded into memory (using indices).</p><p>EMF Search <ref type="bibr" target="#b34">[35]</ref> is a framework for searching over EMF resources, with controllable scope, several extension facilities, and GUI integration. Unfortunately, only simple textual search (for model element name/label) is available by default; advanced search engines can be provided manually in a metamodel-specific way.</p><p>Both Query 2 and Search rely on simple, standard Eclipse UI features to invoke queries and present the results to the user. Incremental evaluation is not supported, and thus presentation features that would rely on dynamically updated are not feasible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>OCL-based approaches</head><p>The OCL development environment of the Eclipse OCL project <ref type="bibr" target="#b1">[2]</ref> provides different ways to edit OCL constraints: an Xtext-based editor for file-based editing, an embedded editor inside Ecore model editors. Additionally, it provides an OCL Console that allows quick specification and (batch) evaluation of constraints. Cabot et al. <ref type="bibr" target="#b35">[36]</ref> present an advanced three-step optimization algorithm for incremental runtime validation of OCL constraints that ensures that constraints are re-evaluated only if changes may induce their violation and only on elements that caused this violation. However, the approach only works on boolean constraints, and as such it is less expressive than our technique.</p><p>An interesting model validator over UML models is presented in <ref type="bibr" target="#b36">[37]</ref>, which incrementally re-evaluates constraint instances whenever they are affected by changes using an evaluation network. A limitation of this approach is that it only supports a subset of OCL and only permits constraints with a single free variable; therefore, general-purpose model querying is not viable.</p><p>To summarize, OCL tools only focus on pure query functionality and only provide simple development aids for detecting syntax errors. Advanced validation and visualization features have, to our best knowledge, not yet been developed. Additionally, while some OCL tools do support incremental evaluation, their current update processing API requires a significant manual coding effort to build data binding and visualization on top of them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EMF-based model transformation tools</head><p>For the sake of completeness, we also briefly overview model transformation tools that can be used to provide model queries (even though this is not their primary use case).</p><p>EMF-IncQuery is not the first tool to apply graph pattern matching to EMF <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b38">39]</ref>, but its incremental (graph) pattern matching feature is unique in an EMF context.</p><p>The development environment of EMF-based model transformation tools such as ATL <ref type="bibr" target="#b39">[40]</ref>, Henshin <ref type="bibr" target="#b37">[38]</ref>, QVTo <ref type="bibr" target="#b40">[41]</ref> or eMoflon <ref type="bibr" target="#b41">[42]</ref> provide support for specifying, executing and evaluation of transformations. While the sophistication and quality of the development tools provided for model transformation frameworks varies greatly, it can be noted as they focus rather on the more general transformation problem than query development support.</p><p>For the ATL (ATL Transformation Language) an incremental transformation approach was published in <ref type="bibr" target="#b42">[43]</ref> using OCL impact analysis techniques. Although the solution extends non-incremental ATL, many restrictions were applied: queries and in-place transformations are not supported. Additionally, some OCL constructs were excluded, like the predefined operation allInstances used in the benchmark.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion and future work</head><p>In previous work, we presented various aspects of EMF-IncQuery technology, focusing on query evaluation efficiency <ref type="bibr" target="#b2">[3]</ref>, the query language <ref type="bibr" target="#b5">[6]</ref>, integration of queries using derived features <ref type="bibr" target="#b7">[8]</ref> and well-formedness validation rules <ref type="bibr" target="#b10">[11]</ref>.</p><p>In the current paper, building on these previous contributions we presented an evolved and mature integrated development environment that augments the core features with a powerful integrated development environment that leverages various Eclipse technologies to provide advanced query development, integration and visualization features.</p><p>The core contributions of the current paper with regard to query development are (i) advanced query validation features that provide instant validation feedback for the most common challenges encountered by EMF-IncQuery users, and (ii) several advanced visualization of query structures and query result that aid developers in fine-tuning query performance.</p><p>Additionally, using a case study based on the Papyrus UML tool <ref type="bibr" target="#b9">[10]</ref>, we highlighted how tool developers can use standard interfaces such as JFace data binding, Ecore derived features and EMF Validation to integrate efficient queries based on EMF-IncQuery into their applications.</p><p>Finally, we compared the query evaluation performance of the EMF-IncQuery framework with the Eclipse OCL project, and found that the Rete-based query evaluation of EMF-IncQuery results in very fast incremental query evaluation at a higher (but manageable) memory overhead.</p><p>Future work As a main direction for future development work on the existing EMF-IncQuery features, we are planning to support the query-based abstract visualization of instance models. Two use cases of this idea would be the parameterization of tree and/or graph viewer so that tuples in the query result may correspond to tree elements, parent-child relationships, or graph nodes and edges, respectively. This technique, analogously with the data binding concept, allows to create abstract visualization of instance models where only important aspects of the model are shown (as defined by a query) and the rest is hidden to improve clarity.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 Z.Fig. 1 .</head><label>21</label><figDesc>Fig. 1. A Simplified presentation of UML class diagrams.</figDesc><graphic coords="2,257.77,94.74,119.03,118.90" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Graph patterns for detecting empty UML classes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Incremental graph pattern matchers in EMF-IncQuery.</figDesc><graphic coords="4,134.78,55.09,313.20,159.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Overview of EMF-IncQuery development environment.</figDesc><graphic coords="5,111.86,55.39,313.44,157.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. The EMF-IncQuery development environment.</figDesc><graphic coords="6,43.98,54.48,460.56,288.24" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Well-formedness validation of model queries.</figDesc><graphic coords="7,41.31,54.50,457.92,211.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The architecture of the query explorer.</figDesc><graphic coords="7,133.48,315.92,271.20,136.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Visualizing graph patterns (screenshots). (For interpretation of the references to color in this figure, the reader is referred to the web version of this article.)</figDesc><graphic coords="8,92.28,54.63,364.56,150.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Data binding of model queries.</figDesc><graphic coords="9,114.77,54.84,310.08,136.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Data binding support.</figDesc><graphic coords="10,296.98,55.15,163.67,99.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. The architecture of validation framework projects.</figDesc><graphic coords="10,155.05,201.78,193.20,180.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 12 .Fig. 13 .</head><label>1213</label><figDesc>Fig. 12. The validation framework. (For interpretation of the references to color in this figure, the reader is referred to the web version of this article.)</figDesc><graphic coords="11,291.82,54.72,174.95,112.93" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. The benchmark process.</figDesc><graphic coords="12,120.36,66.84,298.56,54.88" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Train metamodel and instance model characteristics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Queries in graphical representation.</figDesc><graphic coords="14,69.72,55.27,410.37,227.71" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 17 .</head><label>17</label><figDesc>Fig. 17. SwitchSensor query in various languages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 18 .</head><label>18</label><figDesc>Fig. 18. Benchmark results.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://wiki.eclipse.org/EMFIncQuery/UserDocumentation/API/BaseIndexer.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors would like to thank Ed Willink of the Eclipse OCL project for his help in validating the OCL queries of the published train benchmark and Axel Uhl from the Impact Analyzer developer team for assessing our use of their tool.</p><p>This work was partially supported by the CERTIMOT project (ERC_HU-09-1-2010-0003), by the grant TÁMOP -4.2.2.B-10/1-2010-0009 and the János Bolyai Scholarship. This research was partially realized in the frames of TÁMOP 4.2.4. A/1-11-1-2012-0001 "National Excellence Program -Elaborating and operating an inland student and researcher personal support system". The project was subsidized by the European Union and co-financed by the European Social Fund.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Installation guide</head><p>The EMF-IncQuery development environment requires an Eclipse installation with EMF and Xtext installed. To support existing installed domain editors (such as graphical editors based on the GMF or Graphiti projects) further integration options are available. The visualization feature also require the Zest library to be installed.</p><p>EMF-IncQuery can be installed using the usual installation methods from the update site http://incquery.net/update/ incquery-etsdemo.</p><p>Example projects for EMF-IncQuery, including an extended version of the UML example presented here are available in the form of source projects. These projects can be imported into an EMF-IncQuery installation where they can be evaluated without modification.</p><p>For more detailed, technical-level guide please consult the web site created to supplement this paper. 2 Further documentation is available in the EMF-IncQuery website, 3 including query examples with detailed description. 4  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<ptr target="http://www.eclipse.org/emf" />
	</analytic>
	<monogr>
		<title level="j">The Eclipse Project, Eclipse modeling framework</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>Mdt Ocl</surname></persName>
		</author>
		<ptr target="http://www.eclipse.org/modeling/mdt/?project=ocl" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Incremental evaluation of model queries over EMF models</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Horváth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Balogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Balogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ökrös</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Driven Engineering Languages and Systems</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Petriu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Rouquette</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ø</forename><surname>Haugen</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6394</biblScope>
			<biblScope unit="page" from="76" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ökrös</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Varró</surname></persName>
		</author>
		<title level="m">Incremental pattern matching in the VIATRA transformation system, in: GRaMoT&apos;08, 3rd International Workshop on Graph and Model Transformation, 30th International Conference on Software Engineering</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<ptr target="http://wiki.eclipse.org/EMF/Query2" />
	</analytic>
	<monogr>
		<title level="m">EMF model query 2</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A graph query language for EMF models</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ujhelyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Practice of Model Transformations</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Cabot</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6707</biblScope>
			<biblScope unit="page" from="167" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Developing and visualizing live model queries</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Ujhelyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Szabó</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st Workshop on the Analysis of Model Transformations (AMT) @ MoDELS&apos;12, AMT&apos;12, ACM</title>
		<meeting>the 1st Workshop on the Analysis of Model Transformations (AMT) @ MoDELS&apos;12, AMT&apos;12, ACM<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Integrating efficient model queries in state-of-the-art EMF tools</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hegedüs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Horváth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ujhelyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Objects, Models, Components, Patterns</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Furia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Nanz</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin; Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7304</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Parallelization of graph transformation based on incremental pattern matching</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of GT-VMT</title>
		<meeting>GT-VMT</meeting>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="http://www.eclipse.org/modeling/mdt/papyrus/" />
		<title level="m">The Eclipse Project, MDT papyrus</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Implementing efficient model validation in EMF tools</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hegedüs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Horváth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Ujhelyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th IEEE/ACM International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="580" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Rete: A fast algorithm for the many pattern/many object pattern match problem</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Forgy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="17" to="37" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<ptr target="http://www.eclipse.org/Xtext" />
	</analytic>
	<monogr>
		<title level="j">The Eclipse Project, Xtext</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Model driven visualization: Towards a model driven engineering approach for information visualization</title>
		<author>
			<persName><forename type="first">I</forename><surname>Bull</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Victoria, BC, Canada</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Victoria</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Network-based heuristics for constraint-satisfaction problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="1" to="38" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="http://wiki.eclipse.org/JFace_Data_Binding" />
		<title level="m">The Eclipse Project, JFace data binding</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<ptr target="http://eclipse.org/modeling/emf/?project=validation" />
		<title level="m">The Eclipse Project, EMF validation framework</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Derived features for EMF by integrating advanced model queries</title>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hegedüs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modelling Foundations and Applications</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Vallecillo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J.-P</forename><surname>Tolvanen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Kindler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Störrle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Kolovos</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin; Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7349</biblScope>
			<biblScope unit="page" from="102" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Query-driven soft interconnection of EMF models</title>
		<author>
			<persName><forename type="first">Á</forename><surname>Hegedüs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Á</forename><surname>Horváth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Varró</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">th ACM/IEEE International Conference on Model Driven Engineering Languages &amp; Systems</title>
		<meeting><address><addrLine>Innsbruck</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7590</biblScope>
			<biblScope unit="page">23</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<ptr target="https://incquery.net/publications/trainbenchmark/full-results" />
		<title level="m">The train benchmark website</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Model-based generation of tests for dependable embedded systems</title>
		<ptr target="http://www.mogentes.eu/" />
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>7th EU framework programme</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The Berlin SPARQL benchmark</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schultz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Semantic Web Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">SP2Bench: A SPARQL performance benchmark</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hornung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pinkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 25th International Conference on Data Engineering</title>
		<meeting>of the 25th International Conference on Data Engineering<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="222" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m">Transaction Processing Performance Council (TPC), TPC-C benchmark</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An algorithm for generating model-sensitive search plans for EMF models</title>
		<author>
			<persName><forename type="first">G</forename><surname>Varró</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Deckwerth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wieber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schürr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Practice of Model Transformations</title>
		<editor>
			<persName><forename type="first">Z</forename><surname>Hu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Lara</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin; Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7307</biblScope>
			<biblScope unit="page" from="224" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<ptr target="http://www.omg.org/spec/OCL/2.0/" />
		<title level="m">Object constraint language</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>The Object Management Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Using an OCL impact analysis algorithm for view-based textual modelling</title>
		<author>
			<persName><forename type="first">A</forename><surname>Uhl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Goldschmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Holzleitner</surname></persName>
		</author>
		<ptr target="http://incquery.net/publications/incquery-development-environment.3http://eclipse.org/incquery.4http://wiki.eclipse.org/EMFIncQuery/UserDocumentation/Examples" />
	</analytic>
	<monogr>
		<title level="j">ECEASST</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Towards precise metrics for predicting graph query performance</title>
		<author>
			<persName><forename type="first">B</forename><surname>Izsó</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Szatmári</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Á</forename><surname>Horváth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ráth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM 28th International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<date type="published" when="2013-11">2013. Nov. 2013</date>
			<biblScope unit="page" from="421" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title/>
		<ptr target="http://www.mysql.com/why-mysql/white-papers/mysql-wp-workbench.php" />
	</analytic>
	<monogr>
		<title level="j">MySQL workbench database design. Development. Administration. Migration</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<ptr target="http://www-01.ibm.com/software/data/optim/data-architect/" />
		<title level="m">InfoSphere data architect</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Enterprise</forename><surname>Manager</surname></persName>
		</author>
		<ptr target="http://www.oracle.com/technetwork/oem/enterprise-manager/overview/index.html" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><surname>Neoclipse</surname></persName>
		</author>
		<ptr target="http://neo4j.org/" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Interactive visualization of multiple query results</title>
		<author>
			<persName><forename type="first">S</forename><surname>Havre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hetzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Perrine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Jurrus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualization</title>
		<meeting>the IEEE Symposium on Information Visualization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page">105</biblScope>
		</imprint>
	</monogr>
	<note>INFOVIS&apos;01</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Queryscope: visualizing queries for repeatable database tuning</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1488" to="1491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<ptr target="http://www.eclipse.org/modeling/emft/?project=search" />
		<title level="m">The Eclipse Project, EMFT search</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Incremental integrity checking of UML/OCL conceptual schemas</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cabot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Teniente</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Softw</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="1459" to="1478" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Incremental consistency checking for complex design rules and larger model changes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Reder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Egyed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Model Driven Engineering Languages and Systems</title>
		<editor>
			<persName><forename type="first">R</forename><surname>France</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Kazmeier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Breu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Atkinson</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin; Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7590</biblScope>
			<biblScope unit="page" from="202" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Precise semantics of EMF model transformations by graph transformation</title>
		<author>
			<persName><forename type="first">E</forename><surname>Biermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ermel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Taentzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MoDELS&apos;08</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Improved flexibility and scalability by interpreting story diagrams</title>
		<author>
			<persName><forename type="first">H</forename><surname>Giese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hildebrandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seibel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of GT-VMT</title>
		<meeting>GT-VMT</meeting>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<ptr target="http://www.eclipse.org/atl/" />
		<title level="m">The Eclipse Project, ATL -A model transformation technology</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<ptr target="http://www.eclipse.org/m2m/" />
		<title level="m">The Eclipse Project, Model to model project</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<ptr target="http://www.moflon.org/" />
		<title level="m">eMoflon</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Towards incremental execution of ATL transformations</title>
		<author>
			<persName><forename type="first">F</forename><surname>Jouault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tisi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Practice of Model Transformations</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Tratt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Gogolla</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6142</biblScope>
			<biblScope unit="page" from="123" to="137" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
