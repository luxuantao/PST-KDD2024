<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Aspect-Oriented Approach for Developing Self-Adaptive Fractal Components</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Pierre-Charles</forename><surname>David</surname></persName>
							<email>pierrecharles.david@francetelecom.com</email>
							<affiliation key="aff0">
								<orgName type="department">France Télécom, Recherche &amp; Développement 28</orgName>
								<address>
									<addrLine>chemin du vieux chêne</addrLine>
									<postCode>F-38243</postCode>
									<settlement>Meylan</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Thomas</forename><surname>Ledoux</surname></persName>
							<email>thomas.ledoux@emn.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">OBASCO Group</orgName>
								<orgName type="institution">EMN / INRIA</orgName>
								<address>
									<addrLine>Lina École des Mines de Nantes 4 rue Alfred Kastler</addrLine>
									<postCode>F-44307</postCode>
									<settlement>Nantes CEDEX 3</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Aspect-Oriented Approach for Developing Self-Adaptive Fractal Components</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2EC689851C384C0CF23E87373AF8F4DB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Nowadays, application developers have to deal with increasingly variable execution contexts, requiring the creation of applications able to adapt themselves autonomously to the evolutions of this context. In this paper, we show how an aspect-oriented approach enables the development of self-adaptive applications where the adaptation code is well modularized, both spatially and temporally. Concretely, we propose SAFRAN, an extension of the Fractal component model for the development of the adaptation aspect as reactive adaptation policies. These policies detect the evolutions of the execution context and adapt the base program by reconfiguring it. This way, SAFRAN allows the modular development of adaptation policies and their dynamic weaving into running applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Nowadays, application developers have to deal with increasingly variable execution contexts. On the one hand, we find a large diversity of platforms covering a wide spectrum in terms of available resources (from embedded systems to grids), these heterogeneous machines being increasingly interconnected, and hence interdependent. On the other hand, even on a particular host the execution context of an application changes during its execution (hardware and software resources availability, mobility. . . ). This situation makes application development more and more complex, as it is often difficult to know at development-time the conditions in which applications will be used, especially when these conditions can change unpredictably during execution. Instead of trying to hide the execution context under an abstraction layer (middleware), we believe that applications must become context-aware so that they can adapt to their context <ref type="bibr" target="#b0">[1]</ref>. Such self-adaptive applications are able to adapt themselves autonomously <ref type="bibr" target="#b1">[2]</ref> to the evolutions of their execution context, not only to continue functioning but also to leverage new possibilities which can appear dynamically.</p><p>The need to build applications which adapt to their environment is not new. However, the ad hoc techniques generally used, in which adaptation decisions are hardwired in applications, are not sufficient: they mix business concerns with adaptation policies, which makes both initial development and maintenance more difficult <ref type="bibr" target="#b2">[3]</ref>. Furthermore, it is generally impossible to predict during the development phase the actual circumstances in which applications will be used, even less the appropriate reaction. Ideally, we would like to be able to develop the adaptation code separately and then integrate it dynamically inside the business code so as to decouple these two kinds of code, both spatially and temporally.</p><p>In this paper, we use an aspect-oriented approach <ref type="bibr" target="#b3">[4]</ref> to modularize the adaptation code in self-adaptive applications. Aspect-Oriented Programming (AOP) gives us an interesting framework to separate the adaptation concern from business code and then to dynamically weave and un-weave them. The system we propose, SAFRAN, allows to develop self-adaptive applications based on the Fractal component model <ref type="bibr" target="#b4">[5]</ref>. SAFRAN is designed around three main principles: (i) the use of a dynamic component model (Fractal) to build applications which can be adapted at runtime; (ii) the use of AOP concepts and techniques to develop the adaptation logic separately from business code and then to dynamically weave them to yield self-adaptive applications; (iii) and finally the use of a Domain (or Aspect) Specific Language <ref type="bibr" target="#b5">[6]</ref> to express this adaptation logic.</p><p>Section 2 shows how the software adaptation concern can be -conceptuallyconsidered as an aspect. Section 3 then presents our contribution, SAFRAN, showing how this approach translates in the concrete design and architecture of SAFRAN. We finally illustrate the use of SAFRAN on a simple example (Section 4), and discuss some related work (Section 5) before concluding (Section 6).</p><p>2 Software Adaptation as an Aspect</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Adaptation as a Cross-Cutting Concern</head><p>In the most general sense, an adaptation is a modification triggered by changing circumstances, by which a system becomes better suited to its new environment. In the case of software, an adaptation will be implemented by a program responsible for (i) observing the environment in which the target software is running to detect new conditions, (ii) deciding about the appropriate modifications to apply to the target software, and (iii) applying these modifications, adapting the target to the new conditions. With the advent of ubiquitous computing, new applications must be able to adapt themselves autonomously <ref type="bibr" target="#b1">[2]</ref> to the various execution contexts in which they can be running. Such self-adaptive software applications are both the agent and the target of the adaptation.</p><p>The main issue with building such self-adaptive software is that integrating the code dealing with the adaptation concern into the application increases its complexity: the business code becomes "polluted" by non-functional concerns like observing the environment and deciding which reconfiguration is more appropriate. This also impedes the reusability of the system, which can then function properly only in the few, fixed set of situations which have been anticipated during its development. To solve these issues, we need a looser and more dynamic coupling between business code and adaptation logic.</p><p>Software adaptation thus appears as a cross-cutting concern relative to business code, which we would like to modularize so as to offer more reusability and maintainability of the business code. Aspect-Oriented Programming (AOP) <ref type="bibr" target="#b3">[4]</ref> gives us adequate abstractions and composition mechanisms to solve these issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Towards an Adaptation Aspect</head><p>In "traditional" AOP systems (e.g. AspectJ <ref type="bibr" target="#b6">[7]</ref>), an aspect is a module which regroups pairs of the form (pointcut, advice) where pointcut denotes a set of joinpoints, i.e. points of interest in the execution of a base program (in which the aspect is to be weaved) and advice is a code fragment to be executed whenever the pointcut matches, i.e. at each of its join-points. Together, these constructs can be used to implement in a well-defined module a concern which can modify the semantics of a base program incrementally and transparently (from the base program's point of view) <ref type="bibr" target="#b7">[8]</ref>. The base program and the aspects are weaved into a consistent whole, either statically or dynamically. In the following, we propose to "aspectize" the adaptation concern.</p><p>The event-based nature of the adaptation process (when a significant change occurs, an adaptation decision is made taken and then applied) relates with the EAOP approach <ref type="bibr" target="#b8">[9]</ref> in which point-cuts are defined in terms of sequences of runtime events in the execution of the base program (method invocation, object creation. . . ). In EAOP, runtime events are only internal, i.e. related to the base program execution. This is not sufficient to trigger adaptations in the more general setting of context-aware applications, which must also react to external events regarding the evolutions of their execution context, like the appearance of a new device or the sudden decrease of the available bandwidth. Despite their different origin (the context instead of the application itself), we believe these events can also be considered as join points, as they trigger adaptation actions. Our join point model thus extends the domain of possible join points beyond internal events ("traditional" join points) to the whole execution context, which increases the expressive power of our system by allowing us to react to changes in the execution context.</p><p>Concerning the advice model, actions (triggered by events) indicate how to reconfigure the base program in order to adapt it to the new conditions. The role of the advice language is thus to adjust the target application (tuning, parameterization, architectural configuration. . . ) in order to make it more adapted. Note that contrary to AspectJ <ref type="bibr" target="#b6">[7]</ref> which is a general purpose Aspect-Oriented language, the advice language in SAFRAN is a domain-specific language whose expressive power is reduced so that it is not possible to reconfigure the application in an inconsistent state.</p><p>As for the aspect weaving model, our choice of considering adaptation in open and dynamic systems lead us to choose a dynamic approach, which is much more flexible than static weaving because the separation of concerns remains at runtime. This means that the adaptation aspect does not have to be anticipated, but can be loaded, modified and tuned at runtime, without stopping the application. This dynamic weaving process allows us to fully decouple the base program and the adaptation aspect (both spatially and temporally).</p><p>3 An Adaptation Aspect in SAFRAN SAFRAN (Self-Adaptive FRActal compoNents) <ref type="bibr" target="#b9">[10]</ref> is an extension to the Fractal component model <ref type="bibr" target="#b4">[5]</ref> allowing the creation of self-adaptive applications. One of the key principles in the design of SAFRAN is the treatment of the adaptation concern as an aspect. Following the structure of a generic AOP system, SAFRAN's main elements are:</p><p>a base program corresponding to a configuration of Fractal components (architecture); -point-cuts corresponding to the notification of internal events (message invocations on Fractal interfaces, changes in the architecture) or external events (thanks to a framework we designed to create context-aware applications); -advices voluntarily restricted to architectural reconfigurations; -and finally the adaptation aspect itself, linking join points to advices, and represented by modular adaptation policies dynamically weaved and unweaved into target components.</p><p>The rest of this section will present in more details each of these points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Fractal Components: The Base Program</head><p>Fractal <ref type="bibr" target="#b4">[5]</ref> is a component model developed by France Télécom R&amp;D and INRIA, and distributed through the ObjectWeb consortium. We chose Fractal over other component models because it is designed around a minimal but very extensible core, and is highly dynamic. A Fractal application (see Fig. <ref type="figure" target="#fig_0">1</ref>) is seen as an assembly of components, each made of two parts: a controller (in grey on the figure) and its content. This content can be either made of other components (composite) or of a single object of the underlying programming language (primitive). For example, the figure shows a single composite containing two primitive sub-components. The controller part of a component manages all the interactions of its content with the outside. To do this, it exposes internal and external interfaces (ports), which can represent services provided or required by a component. Two compatible interfaces can be connected together to create a one-way binding through which all communications must pass. On the figure, the rightmost sub-component provides a service of type "S" through an interface named "s". The other sub-component uses this service through a binding from its own required interface of a compatible type, and exposes another service "m" of a different type. This service is exported to the outside of the composite using a binding from a matching internal interface. When the composite receives an invocation on its interface "m", its controller intercepts the message, executes optional control behavior (depending on the controller configuration), and then forwards it to the sub-component through the internal binding. In addition to service interfaces, which depends on each application ("s" and "m" on the figure), Fractal components can offer a variety of standard control interfaces. These interfaces, represented on top of the components in the figure, enable dynamic introspection and modification of various aspects of the components: discovery of the set of interfaces of a component (component interface, C on the figure), lookup, creation and destruction of bindings (bindingcontroller, or BC), addition and removal of sub-components from composites (content-controller, or CC), etc.</p><p>Fractal offers a predefined set of such control interfaces to reflectively manipulate aspects of the components. This support for architectural reflection allows us to reconfigure the architecture of an application during its execution. Compared to other component models like ArchJava <ref type="bibr" target="#b10">[11]</ref>, which supports runtime reconfigurations only if they have been programmed at compile-time, Fractal's support for reflection enables the discovery and unanticipated modification of the structure of components. This feature is essential for the creation of selfadaptive applications <ref type="bibr" target="#b11">[12]</ref> as most of the adaptation we will want to perform are not known during the initial construction of the software.</p><p>Another advantage of Fractal is that the set of control interfaces is not fixed. Although there is a predefined set of such interfaces, all of them are optional. More importantly, Fractal and its default implementation are designed so that is is easy to add new control interfaces, thus extending the component model. We use this feature in SAFRAN to seamlessly integrate our extension into the standard model by adding a new control interface named adaptation-controller to manage the adaptation aspect associated to a component. Beyond the advantages inherent to the component-based approach, the specific features of Fractal make it an ideal candidate for the construction of adaptable applications, the first step towards fully autonomous self-adaptive applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Reconfiguration with FScript: The Advice Language</head><p>FScript is a domain-specific language <ref type="bibr" target="#b5">[6]</ref> we designed to program the Fractal components reconfigurations. FScript is a simple procedural language with dynamic typing and lexical scoping, which gives access to all the standard operations supported by Fractal components: creation of new components, architecture introspection and reconfiguration of this architecture by manipulating composites' content and bindings between interfaces. The main features of FScript are (i) a special notation to navigate easily in the Fractal architecture of the base program, and (ii) the guarantee that reconfigurations always leave the application in a consistent state. Although it has been designed to be used in SAFRAN, FScript can also be used by itself as a scripting language to program consistent Fractal components reconfigurations.</p><p>The FPath Notation. FScript uses a special syntax, FPath (inspired by the XPath language <ref type="bibr" target="#b12">[13]</ref>), to easily navigate in Fractal architectures without modifying it and select elements (components, interfaces or configuration attributes) matching certain criteria. The language is based on a model of Fractal architectures as a (virtual) directed graph where nodes represent components, their interfaces and attributes, and where arcs are annotated by labels to denote the kind of relation between two nodes (C1 "is a sub-component of " C2, I1 "is bound to" I2. . . ). In addition to basic expressions (arithmetic, boolean and comparison operators. . . ), FPath expression can denote relative paths (starting from an initial node). Such a path is a series of steps, each made of three elements: axis: :test[predicate]. On each step, an initial set of nodes is converted to a new set by following all the arcs with a label corresponding to the axis, then filtering the result using the test (on the node names) and optional predicates (boolean FPath expressions applied to each candidate). More precisely, the evaluation algorithm for one step is the following: </p><formula xml:id="formula_0">P1. [Initialisation] result ← ∅. P2. [</formula><formula xml:id="formula_1">(x) ∧ • • • ∧ pred n (x)}. P5.</formula><p>[End] The algorithm finishes and returns result.</p><p>For a multi-step path, this algorithm is repeated with the result of the previous step as the current node-set of the next.</p><p>FPath offers a set of axes to navigate in Fractal architectures, by selecting a component's interfaces (interface axis), configuration attributes (attribute), direct sub-components (child) or parents<ref type="foot" target="#foot_0">1</ref> (parent), and following the binding of an interface (binding). It is also possible to select in one step all the direct and indirect sub-components (resp. parents) of a component with the descendant (resp. ancestor) axis, which is the transitive closure of child (resp. parent).</p><p>For example, the FPath expression child::server/attribute::cache-Enabled first selects all the sub-components of the initial node(s) named server (test on the node name), then selects its configuration attribute named cache-Enabled. Using the same logic, the expression count(interface::*[required (.) and not(bound(.))]) &gt; 0 returns true if and only if the initial component has required interfaces which are not yet connected (the dot "." in predicates denote the current node to which it is applied).</p><p>FScript Actions. FScript is used to define reconfiguration actions, combining FPath expressions, primitive actions, simple control structures (sequence, choice, finite iteration) and variables manipulation. All the dynamic reconfiguration operations supported by Fractal components are available to FScript program as predefined, primitive actions, including the attach() and detach() actions introduced by SAFRAN to control the (runtime) weaving of adaptation policies to components. The following example shows an FScript action which could be used to adapt a component. This action can be used to change the replacement strategy used by a cache component by modifying the binding between the cache and the strategy component. It uses FPath expressions to navigate in the application's structure, and primitive actions corresponding to operations supported by Fractal components (bind(), stop(). . . ). Although this action is relatively specific to a given application, FScript can be used to program more generic reconfigurations (replacing a component by another for example) which can then be reused in multiple application (architectural patterns).</p><p>Guarantees. FScript's design and implementation guarantee the consistency of reconfigurations. Because these reconfigurations are meant to adapt running applications, we must guarantee that reconfiguration will not break the target application. To this end, we have chosen a set of consistency criterion, in particular transactional integrity (atomicity, consistency of the final state, isolation) and termination of the reconfigurations. The validation of these criteria is guaranteed in part by the language's structure itself, whose expressive power has been limited, and in part by the implementation. More precisely:</p><p>-The definition of (directly or indirectly) recursive actions is forbidden, and the only control structure available for iteration, a for each loop, iterates on the result of an FPath expression, which always returns a finite set of nodes. These constraints guarantee actions' termination, although they do not provide a time bound. -During the execution of a reconfiguration, the language interpreter keeps a complete journal of all the primitive actions performed, together with enough information to revert them. As soon as an error occurs, the interpreters uses this journal to roll-back the current reconfiguration and return to the initial state. Given that all the primitive Fractal reconfigurations are themselves atomic and reversible, this guarantees the atomicity of FScript reconfigurations. -At the end of a reconfiguration, the interpreter checks that the current configuration is consistent, i.e. that all the required client interfaces are correctly bound to a corresponding server interfaces and that all the components which have been temporarily stopped during the reconfiguration can safely be restarted. If this is not the case, the interpreters cancels the reconfiguration and rolls back to the initial state, thus ensuring the consistency of the application. -Finally, the isolation of reconfigurations is currently guaranteed by globally serializing them. This works, but is highly sub-optimal and may be enhanced in future works.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Internal and External Events as Join-Points</head><p>We now describe the join-points supported by SAFRAN to trigger the adaptation actions' execution. Following the EAOP approach <ref type="bibr" target="#b8">[9]</ref>, we consider these joinpoints as event occurrences. Although traditional join-points only account for the execution of the base program, we extended the domain of events to consider with external events corresponding to changes in the execution context. Whether they are internal or external, all event occurrences in SAFRAN are represented as objects with a set of properties. Some of these properties are present on every event while some are specific to certain kinds of events. Common properties are: the type of the event, as a string; the source of the event, which can be either a component or an element of the execution context (see below); and a timestamp indicating the time of occurrence of the event.</p><p>Event specification and detection is realized by event descriptors, for which the exact syntax depend on the type of event, but always follow the same general form event-type(parameters). Thus, the descriptor changed(sys:// storage/memory#free) allows to detect the variations in the quantity of memory available on the system. Internal Events. Internal events are execution points in the base program, which in our case is a set of Fractal components. The first three types of internal events, message-received, message-returned and message-failed, correspond respectively to the reception of a message, the successful return of a message and the throwing of an exception. The descriptors for these three kinds of events share the same parameters, expressed using FPath, to indicate which interfaces and methods should be monitored. For example, message-received( $c/interface::logger) can be used to detect invocations on any method of the logger interface of component $c, while message-failed($c/interface::*) detects errors on any interface of the same component.</p><p>The other internal event types correspond to the possible reconfigurations of Fractal components : component creation, life-cycle changes (component started or stopped), configuration (changes in configuration parameters), content manipulation (addition and removal of sub-components) and finally creation and destruction of bindings. Each of the corresponding descriptor takes arguments to specify which components, interfaces or attributes to monitor. Thus, the descriptor component-started($c/child::*) detects when any direct sub-component of $c is started.</p><p>The implementation of these events is based on the instrumentation of Fractal controllers, for example the components' lifecycle-controller is instrumented to generate component-{started,stopped} events.</p><p>External Events. In order to detect the occurrence of external events we first need to reify the application's execution context, which is normally implicit. To do this, we use WildCAT <ref type="bibr" target="#b13">[14]</ref>, a system we designed to ease the creation of context-aware applications <ref type="bibr" target="#b0">[1]</ref>. WildCAT is used by SAFRAN to observe the execution context and to notify the occurrence of the external events which can trigger the execution of reconfigurations. As was the case for FScript, WildCAT can actually be used independently.</p><p>WildCAT models the execution context as a set of context domains, each representing a particular aspect of the context, for example hardware resources, network, geo-physical information, etc. Each of these context domains is itself modeled as a tree of resources described by a set of attributes (simple (name, value) pairs). The syntax used to denote resources and attributes is inspired by that of uris: domain://path/to/resource#attribute (#attribute being optional). For example, sys://storage/drives/hdc#removable indicates whether the hdc drive is removable.</p><p>The context model provided by WildCAT changes dynamically to reflect changes in the actual execution context: attributes values can change, attributes and resources can appear or disappear at any moment. All these modifications generate external events which can be detected by an adaptation policy. The different types of external events supported by SAFRAN are: changed(expression) : detects any modification of the value of the expression, which can reference any attribute or resource in the context<ref type="foot" target="#foot_1">2</ref> , for example changed(geo://location/logical#room). Expressions to monitor are written in a simple language which, in addition to references to context locations, supports strings, numbers, arithmetic and boolean operations, comparisons and function calls. realized(condition) : detects the occurrence of a boolean condition, for example realized(sys://storage/memory#free &gt; 2*sys://storage/swap# used). This is actually a particular case of changed which only detects changes from false to true. appears(path) and disappears(path) : detects the appearance or disappearance of a resource or attribute in the context. The path expression can be a joker character "*" as its last element. For example appears(sys:// devices/input/*) detects the apparition of any new input device.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Adaptation Policies: The Adaptation Aspect Language</head><p>Adaptation Aspect Syntax. Conforming to the reactive nature of the adaptation process, adaptation policies in SAFRAN are structured as sets of reactive rules of the form</p><formula xml:id="formula_2">when &lt;event&gt; if &lt;condition&gt; do &lt;action&gt;</formula><p>where &lt;event&gt; is an (internal or external) event descriptor<ref type="foot" target="#foot_2">3</ref> (cf. Sect. 3.3) corresponding to a point-cut, &lt;condition&gt; is a boolean FPath expression (without side-effects), and &lt;action&gt; is an FScript reconfiguration (cf. Sect. 3.2) corresponding to the aspect's advice. This type of rules is inspired by what can be found in Active Databases <ref type="bibr" target="#b14">[15]</ref> under the name of ECA (Event, Condition, Action) rules. An adaptation rule indicates that when an event corresponding to the &lt;event&gt; expression occurs, if the &lt;condition&gt; expression holds, then the &lt;action&gt; reconfiguration is applied, thus adapting the target application to the new conditions resulting from the event.</p><p>In the SAFRAN system, the adaptation policies which are dynamically attached to Fractal components are made of (ordered) sequences of adaptation rules:</p><formula xml:id="formula_3">policy example = { rule { when &lt;event1&gt; if &lt;cond1&gt; do &lt;action1&gt; } rule { when &lt;event2&gt; if &lt;cond2&gt; do &lt;action2&gt; } ... }</formula><p>As an adaptation policy is always executed when attached to a target component, a special variable named $target can be used inside rules to access the component to which the policy is attached; it is akin to self of this in object-oriented languages.</p><p>Figure <ref type="figure">2</ref> summarizes the event/control flow between the different parts of SAFRAN. Internal events are generated by instrumentation code inside Fractal components, and external events are detected by WildCAT. These events are routed to the appropriate adaptation controllers, which uses its current rules to decide which adaptations to perform. These decisions are finally applied by executing FScript reconfigurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. Flow of events in SAFRAN</head><p>Weaving the Adaptation Aspect. SAFRAN introduces an extension to the Fractal model which enables the dynamic attachment (weaving) of adaptation policies (aspects) to components (base program). Like most Fractal extensions, it takes the form of a new control interface, in this case adaptation-controller. It is this controller, present on each self-adaptive component, which implements the weaving of adaptation policies into the target component, thus making it selfadaptive: whereas a standard Fractal component can be adapted by an external entity (through its standard control interfaces), a SAFRAN component embeds the adaptation code itself and becomes autonomous, actor of its own adaptation.</p><p>The AdaptationController interface (see below) enables the dynamic attachment (weaving) of one or several adaptation policies to each SAFRAN component. This interface can be seen as a special case of an aspect weaving interface, where attachFcPolicy() and detachFcPolicy() correspond to specialized versions of more general weave(Aspect) and unweave(Aspect) operations: public interface AdaptationController { void attachFcPolicy(AdaptationPolicy policy); void detachFcPolicy(AdaptationPolicy policy);</p><p>AdaptationPolicy[] getFcPolicies(); } When a policy is attached to a component, the component's adaptation controller analyzes it, and depending on the join-points mentioned in the rules, instruments the target component to generate the appropriate internal events and registers itself with WildCAT to be notified of the external events. After this initialization, when the adaptation controller receives events, be they internal or external, it determines the appropriate reaction according to the current set of policies and rules on the target component (see below), and then executes this reaction in order to adapt the component to the new circumstances. This execution schema matches the reactive nature of the adaptation process, with the same three phases: observation, decision, action.</p><p>Aspect Composition Model. To handle multiple advices affecting the same join-point, SAFRAN provides an ad hoc aspect composition model. Indeed, a policy (aspect) can be made of several rules, a component can have multiple policies attached at the same time, and of course an application can contain many self-adaptive components. SAFRAN defines the following composition rules to manage the interactions between these different elements when several rules are triggered by the same event:</p><p>-Inside a given policy, the rules' reactions are composed in sequence, in the textual order of their definition, and executed in a single reconfiguration transaction. The rationale is that a given policy should implement a consistent, self-contained adaptation, and its (single) author can be expected to foresee the rules' interactions. -On a single component, the competing reactions of multiple policies are also executed in sequence, but each in its own reconfiguration transaction. The effects of a single policy's failure is thus isolated. This is important as policies developped independently can be attached to the same component. The order in which the policies' reactions are executed depend in the order of their attachment: the oldest policies are executed first. The rationale is that once a policy P is attached to component C, the resulting component C must be considered as a self-contained black-box by the next policies, and hence P has a greater priority over the policies attached later. -Finally, when multiple components must react to a single event, their reactions are executed in an order defined by the components' composition relations: subcomponents are adapted before their parents. The rationale is similar to the previous one: in a component-base approach, when a composite includes a subcomponent, it should treat it as a black-box.</p><p>Although these rules are designed to be the most general possible, there are situations in which they are not appropriate. One of the main future directions of our work is the extend the execution model of our reactive rules to provide more flexibility on the semantics of composition. The challenge is to do this while without making the policies language too complex for the end users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Example</head><p>The example application we chose to illustrate the use of SAFRAN is a small web server named Comanche, implemented by É. Bruneton as a tutorial on the use of Fractal. Comanche, being extremely simple, does not integrate a file cache mechanism. In order to improve its performances, we thus add a new cache component in Comanche. The cache performances depends on the amount of adjusts the maximum cache size to use 80% of the total amount available, but only if this leaves enough free memory to the rest of the system. This example policy illustrates (i) a point-cut based on two types of external events (realized and changed); (ii) two kinds of reconfiguration actions: parameterization and bindings manipulation. Not only the reconfiguration is dynamic, but thanks to the dynamic weaving process in SAFRAN, the policy can be updated during the execution of the base application, which is essential when developing open systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>In the last few years, numerous works have tried to make software more adaptable, in particular to take into account the needs of mobile computing and autonomous applications <ref type="bibr" target="#b1">[2]</ref>. The most promising approach seems to be the use of dynamic and extensible component models, which enable the integration of non-functional services in a way that is adapted to the specific needs of applications, and most importantly allow dynamic reconfigurations of the application itself <ref type="bibr" target="#b15">[16]</ref>. Some works, like ACEEL <ref type="bibr" target="#b16">[17]</ref> or K-Components <ref type="bibr" target="#b2">[3]</ref> are based on custom component model which impose a specific way of structuring applications. Others use existing component models but restrict themselves to particular application domains: for example PLASMA <ref type="bibr" target="#b17">[18]</ref> which is based on Fractal like SAFRAN but limited to multimedia stream processing.</p><p>Concerning the adaptation aspect itself, Cilia et al. <ref type="bibr" target="#b18">[19]</ref> have shown the links existing between AOP and reactive rules from active databases, particularly in the context of autonomous applications. Indeed, applications must be reactive in order to adapt themselves to their context, and the underlying principles of AOP allow us to introduce this reactivity in base programs in a non-invasive way. However, the authors only present abstract concepts where SAFRAN provides a concrete implementation.</p><p>We can also note the existence of FAC <ref type="bibr" target="#b19">[20]</ref> and Fractal-AOP <ref type="bibr" target="#b20">[21]</ref>, two extensions of the Fractal model for general AOP. Although SAFRAN is heavily inspired by AOP, SAFRAN's goal is to enable the creation of self-adaptive applications, and AOP is simply a convenient framework used to structure and describe the system. The difference between the FAC/Fractal-AOP approach and SAFRAN' approach is essentially the same as between a general-purpose programming language, powerful but generic, and a DSL, more limited but better suited to its particular objective.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Future Works</head><p>In this paper, we have shown how AOP principles can be used to ease the creation of self-adaptive applications. On a conceptual level, we have shown that adaptation can be considered as a cross-cutting concern and that it is possible to use AOP's concepts (base program, point-cuts, advices and weaver) in this particular case to model the adaptation aspect. In order to support self-adaptive applications, we have extended the traditional notion of join-points beyond internal events related to the program's execution to include external events corresponding to changes in the execution context. Regarding the advices, we have on the contrary chosen to restrict the expressive power of our reconfiguration actions by designing a Domain-Specific Language (FScript) which can offer guarantees on the consistence of adaptations.</p><p>On a more concrete level, we have then described SAFRAN, an extension of the Fractal model which implements this approach and enables the modular development of reactive adaptation policies. The main features of SAFRAN are (i) the decoupling of adaptation policies from business components, (ii) a Domain-Specific Language based on reactive rules to express these policies, and (iii) a completely dynamic approach, where policies and reconfiguration actions -even ones which where not anticipated at compile-time -can be defined, loaded and applied during the execution of the target application without stopping it. Another interesting feature of SAFRAN is its modular design, with subsystems (WildCAT and FScript) which can be reused independently.</p><p>One of our future goals is to extend the principles of SAFRAN to allow the adaptation of distributed applications. We do not anticipate major structural changes in the system, but incremental evolutions of its different parts. A first step would be to extend FScript to support distribution-aware reconfigurations, like for example component migration and distributed bindings. New WildCAT context domains will have to be implemented to share information between remote nodes; different strategies are possible with varying degrees of invasiveness (see <ref type="bibr" target="#b13">[14]</ref>). Finally, the execution model of adaptation policies itself will have to be extended to support coordinated adaptation of remote components.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of a simple Fractal architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Selection] Select every node connected to any of the current ones through an arc whose label matches the axis part: result ← ∪ {n : c P3. [Test] If the test part is an identifier (as opposed to *), remove from result the nodes whose name do not match: result ← {n ∈ result : name(n) = test}. P4. [Filtering] Only keep the elements for which all predicates hold: result ← {x ∈ result : pred 1</figDesc><table /><note><p>axis -→ n, c ∈ current}.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Fractal supports component sharing, so a component can have multiple parents.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>WildCAT automatically re-evaluates expressions when any element it depends on changes.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>In the future, we plan to extend this model to support more complex point-cuts, especially hybrid point-cuts which mix internal and external events and would allow finer coordination between the execution of adaptation code and the base program.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>In practice, such an event is not generated each time the amount of free memory changes, but only when such a change is detected. The sampling rate and hence the system performance depends on how the corresponding sensor is configured.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>memory it can use. If this amount is too low, the system will not use all the cache potential. If it is too high, performances can be even lower, as the cache will force the operating system to use slow virtual memory (swap). The amount of memory we should allocate to the cache depends on the amount of free memory available on the host system, which varies dynamically and unpredictably. Our adaptation policy will thus have to dynamically adapt the maximum amount of memory allocated to the cache component in order to guarantee good performances in every circumstances. The introduction of a cache component in Comanche is very simple, as it only requires to modify the application architecture defined using Fractal's ADL (Architecture Description Language), after having coded the cache component itself, of course.</p><p>The cache component exposes two parameters accessible through its attribute-controller interface, currentSize and maximumSize, indicating respectively the current and maximum amount of memory the cache uses; only maximumSize is writable. The policy works by adjusting the value of maximumSize depending on the amount of free memory on the host system, which WildCAT makes available as sys://storage/memory#free. We now have all the information we need to write the adaptation policy: This file uses two user-defined FScript actions (code not shown for space reasons): the first one, disable-cache, disables the cache component by disconnecting it while the second action, enable-cache, re-introduces it in the components' pipeline. The first rule is triggered when the total amount of available memory drops below 10Mb. When this happens, the reconfiguration action tries to free memory by reducing the size of the cache, or even disabling it completely below a certain size. The second rule is triggered whenever the amount of memory changes 4 but is more than 10 Mb. In this case, the reconfiguration</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards a better understanding of context and contextawareness</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Abowd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on The What, Who, Where, When, and How of Context-Awareness, as part of CHI 2000</title>
		<meeting><address><addrLine>The Hague, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A vision of autonomic computing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kephart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Onward! proceedings from an OOPSLA 2002 track</title>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Gabriel</surname></persName>
		</editor>
		<meeting><address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="13" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The K-Component architecture meta-model for selfadaptive software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dowling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cahill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Third International Conference on Metalevel Architectures and Separation of Crosscutting Concerns</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">2192</biblScope>
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
	<note>Proceedings of Reflection</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mendhekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Loingtier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Irwin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>Volume 1241 of LNCS</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An open component model and its support in java</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bruneton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Coupaye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclercq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Quema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Stefani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Symposium on Component-Based Software Engineering</title>
		<meeting>the 7th International Symposium on Component-Based Software Engineering<address><addrLine>Edinburgh, Scotland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="volume">3054</biblScope>
			<biblScope unit="page" from="7" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Domain-specific languages: An annotated bibliography</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Deursen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Klint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="26" to="36" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An overview of AspectJ</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hilsdale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hugunin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Palm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Griswold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Knudsen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2072</biblScope>
			<biblScope unit="page" from="327" to="353" />
			<date type="published" when="2001">2001. 2001</date>
			<publisher>Springer-Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming is quantification and obliviousness</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Filman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Advanced Separation of Concerns</title>
		<imprint>
			<publisher>Minneapolis</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A framework for the detection and resolution of aspect interactions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Douence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fradet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Südholt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Volume 2487 of LNCS</title>
		<meeting><address><addrLine>Pittsburgh, PA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="page" from="173" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Développement de composants Fractal adaptatifs : un langage dédié à l&apos;aspect d&apos;adaptation</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>David</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
		<respStmt>
			<orgName>Université de Nantes / École des Mines de Nantes</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Architectural reasoning in ArchJava</title>
		<author>
			<persName><forename type="first">J</forename><surname>Aldrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ECOOP&apos;2002</title>
		<meeting>ECOOP&apos;2002<address><addrLine>Malaga, Spain, AITO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Supporting unanticipated dynamic adaptation of application behaviour</title>
		<author>
			<persName><forename type="first">B</forename><surname>Redmond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cahill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ECOOP 2002</title>
		<meeting>ECOOP 2002<address><addrLine>Malaga, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2374</biblScope>
			<biblScope unit="page" from="205" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">World Wide Web Consortium: XML path language (XPath) version 1.0. W3C Recommendation</title>
		<ptr target="http://www.w3.org/TR/xpath" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">WildCAT: a generic framework for context-aware applications</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ledoux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of MPAC&apos;05, the 3rd International Workshop on Middleware for Pervasive and Ad-Hoc Computing</title>
		<meeting>eeding of MPAC&apos;05, the 3rd International Workshop on Middleware for Pervasive and Ad-Hoc Computing<address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The active database management system manifesto: A rulebase of a ADBMS features</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Dittrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gatziu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Geppert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Rules in Database Systems</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">985</biblScope>
			<biblScope unit="page" from="3" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Composing adaptive software</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Sadjadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Kasten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="56" to="64" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Développement d&apos;applications en environnements mobiles à l&apos;aide du modèle de composant adaptatif ACEEL</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chefrour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>André</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LMO</title>
		<imprint>
			<date type="published" when="2003">2003. 2003</date>
			<pubPlace>Vannes, Hermès</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Designing self-adaptive multimedia applications through hierarchical reconfiguration</title>
		<author>
			<persName><forename type="first">O</forename><surname>Layaïda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hagimont</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Distributed Applications and Interoperable Systems (DAIS)</title>
		<meeting><address><addrLine>Athens, Greece</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3543</biblScope>
			<biblScope unit="page">95</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The convergence of AOP and active databases: Towards reactive middleware</title>
		<author>
			<persName><forename type="first">M</forename><surname>Cilia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Haupt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mezini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Buchmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of GPCE&apos;03</title>
		<meeting>GPCE&apos;03<address><addrLine>Erfurt, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2830</biblScope>
			<biblScope unit="page" from="169" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Components, ADL &amp; AOP: Towards a common approach</title>
		<author>
			<persName><forename type="first">N</forename><surname>Pessemier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Seinturier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reflection, AOP and Meta-Data for Software Evolution Workshop at ECOOP 2004 (RAM-SE&apos;04)</title>
		<meeting><address><addrLine>Oslo, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Les aspects et les composants logiciels : Etude de cas avec le modèle de composant Fractal. Numéro spécial de la revue</title>
		<author>
			<persName><forename type="first">H</forename><surname>Fakih</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bouraqadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Objet sur les aspects</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2005">2005</date>
			<pubPlace>French</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
