<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Performance Bounds for Peer-Assisted Live Streaming</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shao</forename><surname>Liu</surname></persName>
							<email>shaoliu@princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rui</forename><surname>Zhang-Shen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wenjie</forename><surname>Jiang</surname></persName>
							<email>wenjiej@princeton.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jennifer</forename><surname>Rexford</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Princeton University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mung</forename><surname>Chiang</surname></persName>
							<email>chiangm@princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">SIGMETRICS&apos;08</orgName>
								<address>
									<addrLine>June 2-6</addrLine>
									<postCode>2008</postCode>
									<settlement>Annapolis</settlement>
									<region>Maryland</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Performance Bounds for Peer-Assisted Live Streaming</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">930FE8F0A6CA2889EBACCE8AEDA1353F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T04:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>C.4 [Performance of Systems]: [Performance attributes] Algorithms</term>
					<term>Design</term>
					<term>Performance peer-to-peer</term>
					<term>video</term>
					<term>streaming</term>
					<term>tree construction</term>
					<term>IPTV</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Peer-assisted streaming is a promising way for service providers to offer high-quality IPTV to consumers at reasonable cost. In peerassisted streaming, the peers exchange video chunks with one another, and receive additional data from the central server as needed.</p><p>In this paper, we analyze how to provision resources for the streaming system, in terms of the server capacity, the video quality, and the depth of the distribution trees that deliver the content. We derive the performance bounds for minimum server load, maximum streaming rate, and minimum tree depth under different peer selection constraints. Furthermore, we show that our performance bounds are actually tight, by presenting algorithms for constructing trees that achieve our bounds.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The rapid growth in residential broadband capacity is enabling the delivery of high-quality video over the Internet. Server-based video delivery can provide performance guarantees, but the server infrastructure is expensive and may not scale well. Peer-to-peer (P2P) technology, already widely used for file-sharing applications, has the potential to reduce server and network load by allowing consumers to download live video content from each other <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b25">25]</ref>. However, existing P2P streaming applications suffer from low-quality video, periodic hiccups, and high delay <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b26">26]</ref>, making it difficult for service providers to leverage the technology directly in commercial offerings.</p><p>In this paper, we argue that service providers can deploy a peerassisted streaming architecture to offer high-quality video at a reasonable cost. Fortunately, in carrier-based streaming services, the provider has greater control over the peers, which may run on dedicated equipment like set-top boxes <ref type="bibr" target="#b28">[28]</ref>. This substantially reduces the churn introduced by peers joining and leaving the system; in fact, the provider may have the peers continue to distribute a stream after users stop watching the video. In addition, the provider can influence, or even control, how the peers are organized into distribution trees for delivering the content. When the peers do not have enough bandwidth to distribute all of the data, the provider can have the server transmit more than one copy of the stream, as needed. This allows the provider to ensure that all peers can download the content at the target streaming rate. We believe that such a hybrid, peer-assisted streaming architecture combines the best features of server-based and peer-based solutions.</p><p>In an emerging field like peer-assisted streaming, we need to lay the theoretical foundations that can drive the design of scalable systems in the future. In this paper, we derive performance bounds and present optimal tree-construction algorithms that service providers can use to provision scalable, peer-assisted streaming services. Our analytical models focus on three main metrics:</p><p>• Server capacity: To reduce cost, the service provider wants to minimize the upload rate of the server, while still ensuring that all peers can receive the live stream at the target rate.</p><p>• Streaming rate: To offer high video quality, the service provider wants the system to deliver video content at a high rate, subject to the capacity of the server and the peers.</p><p>• Tree depth: To improve robustness and minimize latency, the service provider needs distribution trees that limit the number of intermediate peers between server and consumer.</p><p>We optimize these three metrics as a function of the number of peers and their upload capacities, subject to different constraints on how peers connect to each other. In particular, we study the effects of restrictions on the number of downstream neighbors a peer can serve, or the outgoing degree of a peer, to limit the state that each peer must store and maintain, which is especially important as the system grows large. Our contributions in this paper are two-fold: Exploring a rich design space: We model practical constraints on the outgoing degrees of peers. We explore three types of constraints on this problem, as illustrated by the rows in Table <ref type="table" target="#tab_0">1</ref>. We first explore the two extreme design points where a peer can communicate with any neighbor, or only one neighbor. Then, we model arbitrary constraints on the outgoing degrees.</p><p>Tight bounds on performance metrics: We derive the optimal values for these metrics, and provide tree-construction algorithms Min. server load (s min ) Max. streaming rate (r max ) Min. tree depth <ref type="bibr">(</ref> Actual server load.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N:</head><p>Total number of users in the streaming system. N :</p><p>Index set of all the users,i.e., {1, 2, ••• , N} U i :</p><p>Uplink capacity of user i. u i :</p><p>Useri's aggregate uploading rate. d i :</p><p>Useri's aggregate downloading rate. x i j :</p><p>Streaming rate from user i to user j. s i :</p><p>Streaming rate from the server to user i. L:</p><p>Total number of trees in a multi-tree. y (l) : Rate of substream delivered by tree l. E (l) : Set of leaf users in tree l. F (l) : Set of non-leaf users in tree l. m (l) i : Fanout or outgoing degree of user i in tree l. D (l) : Depth of tree l. D: D = max l D (l) is the depth of the multi-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M:</head><p>Maximum fanout of a tree. M t :</p><p>Maximum fanout of a multi-tree. that achieve the optimal values, for minimum server load, maximum streaming rate, and minimum tree depth, as illustrated by the columns in Table <ref type="table" target="#tab_0">1</ref>. Our bounds are tight, except for the challenging case of minimizing tree depth under arbitrary constraints on the outgoing degree of each peer. The remainder of the paper is organized as follows. Section 2 presents our model and notation. Sections 3, 4, and 5 present the bounds and algorithms for the three rows of Table <ref type="table" target="#tab_0">1</ref>, respectively. Section 6 presents related work, and Section 7 concludes with a discussion of future research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PEER-ASSISTED STREAMING MODEL</head><p>In this section, we present our model of peer-assisted streaming, including the underlying assumptions and the notation (summarized in Table <ref type="table" target="#tab_1">2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Assumptions</head><p>In this paper, we analyze a peer-assisted live streaming application managed by a service provider. Therefore we make the following assumptions in our analysis:</p><p>• Peer churn can be ignored because provider-controlled settop boxes can be always on in the timescale of our problem.</p><p>• Each user receives each bit of the video stream only once. Any repetitive downloading would make the system inefficient.</p><p>• Uplink bandwidth is the only bottleneck, because the backbone network is well-provisioned and the residential users have asymmetric access bandwidths. In addition, if the downlinks were the bottleneck, the users would not be able to receive the entire video.</p><p>• We assume that the server can upload to as many users as needed, with no constraint on the number of simultaneous connections. In practice, the server may be implemented on a collection of machines that distribute the video content to different subsets of the users.</p><p>• We do not consider the location of the peers or the topology of the network, though a real system should take these issues into account to reduce congestion and delay.</p><p>When these assumptions hold, most bounds we derive in this paper are tight. In a more general setting, our bounds still hold but may not be tight; that is, our models still provide a lower bound for server load and tree depth, and an upper bound on the achievable streaming rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Constraints on Distributing the Stream</head><p>We consider a server that generates a video stream of rate r and N users who want to watch it. Throughout the paper we use user, peer, and node interchangeably. We treat the data stream as fluid so it is continuous and can be infinitely divided into substreams to any precision without loss of video quality or any overhead.</p><p>Let S denote the server capacity and s the actual server load. Denote the uplink capacity of user i by U i , the upload rate of user i by u i , and the download rate of user i by d i , for i = 1, 2, ••• , N. When convenient, we use N to represent the set of users. For simplicity of presentation, we assume that the uses are indexed according to their uplink capacities, i.e.,</p><formula xml:id="formula_0">U 1 ≥ U 2 ≥ ••• ≥ U N .</formula><p>Let x i j be the rate at which user i uploads to user j. For convenience define x ii = 0 for all i. Let s i be the rate at which user i downloads from the server. We then have the following:</p><formula xml:id="formula_1">s = N ∑ i=1 s i ≤ S (<label>1</label></formula><formula xml:id="formula_2">)</formula><formula xml:id="formula_3">u i = N ∑ j=1 x i j ≤ U i , for i = 1, ••• , N<label>(2)</label></formula><formula xml:id="formula_4">d i = s i + N ∑ j=1 x ji , for i = 1, ••• , N<label>(3)</label></formula><p>Since users never download any data more than once, we have</p><formula xml:id="formula_5">d i = r. (<label>4</label></formula><formula xml:id="formula_6">)</formula><p>User i should not send back anything it receives from user j, so we also have</p><formula xml:id="formula_7">x i j ≤ d i -x ji (5)</formula><p>One key feature of a P2P system is the conservation of flows, i.e., the total upload rate equals to the total download rate. Combining Equations ( <ref type="formula" target="#formula_1">1</ref>)-( <ref type="formula" target="#formula_5">4</ref>), we have</p><formula xml:id="formula_8">s + N ∑ i=1 u i = N ∑ i=1 s i + N ∑ i=1 N ∑ j=1 x i j = N ∑ i=1 d i = Nr (6)</formula><p>The above equations and inequalities are necessary conditions for the system to support a stream of rate r, and they will be used throughout the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Distribution Trees for Stream Delivery</head><p>For sufficient conditions we can specify how each substream is distributed among all the users. If we trace the forwarding of an infinitesimal substream, the delivery paths should form a tree rooted at the server and consisting of all the users, with each user appearing in the tree exactly once. We call this a substream tree, or simply a tree. Other substreams may traverse different trees. In each tree, a peer receives the substream from a single parent and uploads the substream to zero or more children.</p><p>Suppose there are L substream trees, and tree l is responsible for delivering a substream of rate y (l) . This means each edge in tree l represents a flow of rate y (l) . The superposition of these substream trees form a multi-tree. In order for the multi-tree to support a video stream of rate r, we need</p><formula xml:id="formula_9">L ∑ l=1 y (l) = r. (<label>7</label></formula><formula xml:id="formula_10">) Let m (l)</formula><p>i and m (l) s be the fanouts, or the outgoing degrees, which are the numbers of children, of user i and the server, respectively, in tree l. Denote by F (l) the set of non-leaf users in tree l, and E (l) the set of leaf users in tree l. Then we have</p><formula xml:id="formula_11">u i = ∑ l:i∈F (l) m (l) i y (l) , ∀i = 1, ••• , N s = ∑ L l=1 m (l)</formula><p>s y (l) .</p><p>(</p><p>Let D (l) be the depth of tree l, or the maximum number of hops in tree l from the server to the users, and let D = max l D (l) be the maximum depth of all the trees, or the multi-tree depth. Then D is the maximum number of hops a substream has to traverse to reach all users. A higher D means a larger number of hops, which potentially increases the end-to-end delay from the original source (the server) to a receiver. Furthermore, a particular peer stops receiving a substream when any of the ancestor nodes fail; thus a larger D (i.e., more ancestors per peer) also negatively affect the robustness of the content delivery tree structure. So we would like D as small as possible.</p><p>Let M be the substream tree degree bound, or the maximum allowed number of children a user has in any substream tree, and let M t be the multi-tree degree bound, or the maximum allowed number of distinct children a user has in the multi-tree. M reflects the complexity in constructing the substream trees; while M t reflects the total number of downstream peers a user has to serve. So clearly we would like M and M t small. But doing so may increase the tree depth D, so there is a tradeoff between system complexity (M and M t ) and performance (D). Note that for the same value, M t gives a stronger constraint, because M t ≤ a implies M ≤ a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">UNCONSTRAINED PEER SELECTION</head><p>In this section, we study the simplest case where there is no limit on the number of children each peer can have. This means, a user can forward a substream it receives to any number of peers. The maximum supported rate in this case has been studied in <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b18">18]</ref>:</p><formula xml:id="formula_13">r max (S) = min S, 1 N S + N ∑ i=1 U i . (<label>9</label></formula><formula xml:id="formula_14">)</formula><p>We now answer the other two questions in the first row of Table 1. The following theorem states the minimum server load as well as the minimum multi-tree depth needed, when supporting a streaming rate r:</p><p>Theorem 1. Let s min (r) denote the minimum server load that can support a stream of rate r, then</p><formula xml:id="formula_15">s min (r) = max r, Nr - N ∑ i=1 U i , (<label>10</label></formula><formula xml:id="formula_16">)</formula><p>and the minimum server load can be achieved by a multi-tree with depth D = 2.</p><p>Proof. Our proof technique is inspired by <ref type="bibr" target="#b17">[17]</ref>. We first show that Equation ( <ref type="formula" target="#formula_15">10</ref>) is a lower bound, and then show it is achievable by trees of depth 2.</p><p>The server has to supply the original stream, so s ≥ r. From (6) we have</p><formula xml:id="formula_17">s = Nr - N ∑ i=1 u i ≥ Nr - N ∑ i=1 U i . Therefore s ≥ max r, Nr - N ∑ i=1 U i .</formula><p>To show that the bound is achievable we consider two cases, and construct a multi-tree of depth 2 for each case. Case 1 is when the rate r is small enough to be supported by the peers' upload capacity and the server does not need to inject extra bandwidth into the system, i.e., s = r; Case 2 is when the rate is high enough that the server must inject extra bandwidth, i.e., s = Nr -</p><formula xml:id="formula_18">∑ N i=1 U i &gt; r. Case 1: r ≥ Nr -∑ N i=1 U i , or r ≤ 1 N -1 N ∑ i=1 U i . (<label>11</label></formula><formula xml:id="formula_19">)</formula><p>We divide the stream of rate r into N substreams, with the i-th substream having rate U i ∑ N j=1 U j r. The server sends substream i to user i, who distributes it to all the other N -1 users. The multi-tree implementation is shown in Figure <ref type="figure" target="#fig_0">1</ref> and it uses trees 1 through N. Now we check that the uplink capacity constraints are satisfied. The server uploads each substream only once, so its upload rate is s = r. The upload rate of user i is</p><formula xml:id="formula_20">u i = U i ∑ N j=1 U j r • (N -1) ≤ U i ∑ N j=1 U j • N ∑ j=1 U j = U i ,</formula><p>where the inequality is due to <ref type="bibr" target="#b11">(11)</ref>.</p><formula xml:id="formula_21">Case 2: r &lt; Nr -∑ N i=1 U i , or r &gt; 1 N -1 N ∑ i=1 U i .</formula><p>We divide the stream of rate r into N + 1 substreams, with the i-th substream having rate U i /(N -1) for i = 1, 2, ••• , N and the (N +1)-th stream having rate r -∑ N i=1 U i /(N -1). The server sends substream i to user i, for i = 1, 2, ••• , N, who distributes it to all other N -1 users. In addition, the server sends substream (N + 1) to all users. The multi-tree implementation is demonstrated in Figure <ref type="figure" target="#fig_0">1</ref> and it uses trees 1 through (N + 1). Now we check that the uplink capacity constraints are satisfied. For user i, the upload bandwidth is</p><formula xml:id="formula_22">u i = U i /(N -1) • (N -1) = U i .</formula><p>The server sends each of the first N substreams once and sends the last substream N times. So</p><formula xml:id="formula_23">s = N ∑ i=1 U i N -1 + N r - N ∑ i=1 U i N -1 = Nr - N ∑ i=1 U i .</formula><p>In both cases each substream traverses at most two hops so D = 2. Naturally, a system with unconstrained peer selection supports the highest streaming rate, and given a rate, it requires the lowest server load and the lowest multi-tree depth. Therefore, Theorem 1 provides a benchmark for the cases in the rest of this paper. Note that D = 2 is the minimum multi-tree depth that can utilize peer uplink bandwidth, since if D = 1, peers only download from the server and do not upload to each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SINGLE DOWNSTREAM PEER</head><p>Section 3 studied unconstrained peer selection, i.e., M = N -1. In a real system, we want to limit the number of peers because N can be large. A node should be allowed to upload to only a small number of peers to limit the amount of states it has to store and maintain. 1 So this section studies the other extreme case of single peer selection, i.e., M = 1 or M t = 1.</p><p>The constraint M = 1 means that a user can upload to one peer in each substream tree, but in the multi-tree (superposition of the substream trees) can upload to many peers. The constraint M t = 1 means that a user can upload to only one peer in the multi-tree. So, M t = 1 is a stronger constraint. Luckily, for minimum server load (Section 4.1) and maximum streaming rate (Section 4.2), the two constraints have the same optimal value. But for minimum tree depth, they give different answers (Section 4.3 for M = 1 and Section 4.4 for M t = 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Minimum Server Load</head><p>We first determine the minimum server load required to support a streaming rate r. Similar to the analysis in the unconstrained case, in order to achieve the minimum server load, we need to maximize each user's uploading rate. Since each user can upload to only one peer, the maximum upload rate of user i is Ûi := min(r,U i ) .</p><p>(</p><formula xml:id="formula_24">)<label>12</label></formula><p>1 For example, in BitTorrent <ref type="bibr" target="#b6">[6]</ref>, a node uploads to at most five peers simultaneously. Therefore, similar to the proof in Theorem 1, the lower bound for s min under the M = 1 constraint is: <ref type="bibr" target="#b13">(13)</ref> where a + := max(0, a).</p><formula xml:id="formula_25">s min (r) ≥ max r, Nr - N ∑ i=1 Ûi = max r, N ∑ i=1 (r -U i ) + ,</formula><p>This bound is in fact achievable so we have the theorem:</p><p>Theorem 2. When a user can upload to at most one peer in each substream tree, to support a streaming rate r, the minimum server load is</p><formula xml:id="formula_26">s min (r) = max r, N ∑ i=1 (r -U i ) + . (<label>14</label></formula><formula xml:id="formula_27">)</formula><p>In particular, if r ≥ U 1 , the M = 1 constraint does not affect the minimum server load.</p><p>Proof. We show that the bound is achievable by considering two cases.</p><p>Case 1: r ≤ U N-1 . We have s min (r) = r, which is achievable by a single tree in a chain topology server</p><formula xml:id="formula_28">→ 1 → 2 → ••• → N -1 → N with rate r. Case 2: r &gt; U N-1 . Suppose r lies between U k-1 and U k , i.e., U k-1 &gt; r ≥ U k (if k = 1 then we have r ≥ U 1 )</formula><p>. Then, Ûi = r, ∀i &lt; k, and Ûi = U i , ∀i ≥ k. This means that the M = 1 constraint reduces the maximum upload rate for peers 1 to k -1 (if k &gt; 1), but not for peers k to N, and the lower bound for s min is max r, ∑ N i=k (r -U i ) . We show that this bound is achievable by a multi-tree algorithm with the ring topology shown in Figure <ref type="figure" target="#fig_1">2</ref>. In this ring, we call node i -1 the predecessor of node i, and i + 1 the successor of i. 2  Each node uploads only to its successor, and downloads from its predecessor, and if necessary, the server as well. Node i's download rate is</p><formula xml:id="formula_29">d i = r, ∀i = 1, 2, ••• , N.</formula><p>For the download/upload rates, we have</p><formula xml:id="formula_30">u i-1 = x i-1,i = r ≤ U i-1 and s i = 0, ∀i = 2, •••k (if k &gt; 1) , u i-1 = x i-1,i = U i-1 and s i = r -U i-1 , ∀i = k + 1, ••• , N , u N = x N,1 = U N if ∑ N i=k (r -U i ) &gt; r , ∑ N-1 i=k (r -U i ) if ∑ N i=k (r -U i ) ≤ r , s 1 = r -u N .</formula><p>2 For the compactness of presentation, let i -1 represent N, when i = 1; and let i + 1 represent 1 when i = N.</p><p>The Bottleneck Removal Algorithm <ref type="bibr" target="#b1">(1)</ref> u</p><formula xml:id="formula_31">(0) i = u i = min(r,U i ), s (0) i = r -u i-1 , ∀i (2) for l = 0 to L -1 do (3) k (l) = arg min{u (l) i , s (l) i : u (l) i &gt; 0, s (l) i &gt; 0} (4)</formula><p>Case (I): min{u</p><formula xml:id="formula_32">(l) i , s (l) i : u (l) i &gt; 0, s (l) i &gt; 0} = u (l) k (5) Let y (l) = u (l) k . (6) Let p (l) be k (l) 's closest ancestor, or p (l) = k (l) , s.t. s (l) p (l) &gt; 0. Construct a tree branch as s → p (l) → ••• → k (l) → ••• → q (l)</formula><p>, where q (l) = p (l) -1 or u (l)</p><formula xml:id="formula_33">q (l) = 0. (7)</formula><p>If q (l) = p (l) -1, let k (l) = q (l) + 1, repeat <ref type="bibr" target="#b6">(6)</ref>. <ref type="bibr" target="#b8">(8)</ref> Assign the constructed tree l a streaming rate of y (l) . ( <ref type="formula" target="#formula_13">9</ref>)</p><p>Case (II): min{u <ref type="bibr" target="#b11">(11)</ref>. <ref type="bibr" target="#b13">(13)</ref> Assign the constructed tree l a streaming rate of y (l) . ( <ref type="formula" target="#formula_26">14</ref>)</p><formula xml:id="formula_34">(l) i , s (l) i : u (l) i &gt; 0, s (l) i &gt; 0} = s (l) k (10) Let y (l) = s (l) k . (11) Let p (l) be k (l) 's furthest descendant, or p (l) = k (l) , s.t. u (l) p (l) = 0. Construct a tree branch as s → k (l) → k (l) + 1 → ••• → p (l) . (12) If p (l) = k (l) -1, let k (l) = p (l) + 1, repeat</formula><p>for i = 1 to N do <ref type="bibr" target="#b15">(15)</ref> u <ref type="bibr" target="#b16">(16)</ref> end for (15) end for</p><formula xml:id="formula_35">(l+1) i = u (l) i -y (l) , if (i, i + 1) is in tree l. s (l+1) i = s (l) i -y (l) , if (s, i) is in tree l.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 3: The Bottleneck Removal algorithm for the construction of a multi-tree to achieve the lower bound on the minimum server load.</head><p>There are two cases for u N because if ∑ N i=k (r -U i ) &gt; r, then s &gt; r and all the peers from k to N should upload at their capacities in order to minimize the server load, and thus u N = U N , while if ∑ N i=k (r -U i ) ≤ r, then the server load is bounded by the streaming rate r, and thus peer N need not upload at capacity. Now all peers have the download rate r, and the server load is</p><formula xml:id="formula_36">s = N ∑ i=1 s i = max r, N ∑ i=k (r -U i ) ,</formula><p>which is the lower bound on s min . So we only need to design a multi-tree that achieves this rate allocation. Figure <ref type="figure" target="#fig_2">3</ref> illustrates an example of constructing a multi-tree for a streaming system with N = 6 users, by applying the Bottleneck Removal algorithm described in detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Bottleneck Removal Multi-tree Construction Algorithm:</head><p>Consider the multi-tree construction algorithm in Table <ref type="table">3</ref>. In each iteration we construct one tree that consumes the bottleneck link capacity on the ring or the spoke. The residual capacity of that edge becomes zero and will be omitted in the following iterations. The algorithm terminates after at most N iterations and produces at most N substream trees. The residual capacities on the ring and the spoke are initialized to the rates in Figure <ref type="figure" target="#fig_1">2</ref>. In each iteration we pick an edge with the minimum residual capacity. Let u (l) i denote the residual bandwidth on edge (i, i + 1) after the l-th iteration and s (l) i denote the residual bandwidth of edge (server, i) after the l-th iteration. For convenience, we define u</p><formula xml:id="formula_37">(0) i = u i and s (0) i = s i .</formula><p>Consider the following two cases: (I) If the bottleneck edge is on . We build a tree branch as s → 3 → ... → 2, and the residual capacities of edges on the branch are reduced by y 1 = 2. When l = 3, the bottleneck is <ref type="bibr" target="#b5">(5,</ref><ref type="bibr" target="#b6">6)</ref> and case I applies (k = 5, p = 5, q = 6). We build a tree branch from s to 5 and get stuck at 6. We forward to the next user 1, and repeat the same process, which results in another tree branch s → 1 → 2 → 3 → 4. Note that in each iteration, all users will be covered in the spanning tree rooted at s. the ring, we search counter-clockwise for the first user (say p (l) ) to whom the server's residual bandwidth is non-zero. We build a tree branch starting from s to p (l) and stop at a user (say q (l) ) where we cannot expand anymore. We repeat the same process from the next user q (l) + 1, till all the users are spanned. (II) If the bottleneck edge is on the spoke, we build a branch of the tree starting from the spoke until we cannot expand anymore. We move on from where we get stuck to the next user and repeat the same process. After building a tree, the residual capacities on the ring and the radius are deducted by the streaming rate of the tree.</p><formula xml:id="formula_38">u 1 =12 u 2 =10 u 3 =8 u 4 =5 u 5 =4 u 6 =3 s 1 =9 s 2 =0 s 3 =2 s 4 =4 s 5 =7 s 6 =8</formula><p>In the ring topology (Figure <ref type="figure" target="#fig_1">2</ref>), and the multi-tree we constructed above, each user has at most one child, therefore satisfying the M = 1 constraint. The correctness of our multi-tree construction is shown by the following lemma: Lemma 1. The rate allocation in the ring topology, as illustrated in Figure <ref type="figure" target="#fig_1">2</ref>, can be achieved by applying the Bottleneck Removal algorithm to construct a multi-tree within N iterations.</p><p>Due to space limitation, we omit the proof to this and all later lemmas, and all the proofs are available in the expanded version of this paper <ref type="bibr" target="#b20">[20]</ref>. The proof shows that the Bottleneck Removal algorithm runs in polynomial time. This lemma shows that the lower bound of s min in ( <ref type="formula">13</ref>) is achievable, proving Theorem 2.</p><p>Remark: Theorem 2 gives the minimum server load under the M = 1 constraint. In either the chain or the ring topology which achieves the minimum server load, the multi-tree maximum fanout is also 1. Since under the stronger M t = 1 constraint, the minimum server load should be greater than or equal to that under the M = 1 constraint, this implies that when M t = 1, the minimum server load is also given by Equation ( <ref type="formula" target="#formula_26">14</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Maximum Streaming Rate</head><p>Finding the maximum supported rate is in some sense the dual of finding the minimum server load. Similar to minimizing the server load, to achieve the maximum streaming rate, the peer uplink bandwidth should be utilized as much as possible. Under the M = 1 constraint, the upper bound for a supported streaming rate r is</p><formula xml:id="formula_39">r ≤ min(S, 1 N (S + N ∑ i=1 Ûi )) , (<label>15</label></formula><formula xml:id="formula_40">)</formula><p>where the maximum upload rate of user i is Ûi given in <ref type="bibr" target="#b12">(12)</ref>. The bound is achievable but Ûi is a function of r, so the expression for r is not straightforward. We have the following theorem: Theorem 3. When a user can upload to at most one peer in each substream tree, for a given server upload capacity S, the maximum supported streaming rate is</p><formula xml:id="formula_41">r max (S) = S i f S ≤ U N , min(S, g(k * )) if S &gt; U N , (<label>16</label></formula><formula xml:id="formula_42">)</formula><p>where</p><formula xml:id="formula_43">g(k) := S + ∑ N i=k U i N -k + 1 . (<label>17</label></formula><formula xml:id="formula_44">)</formula><p>and k * is the minimum k such that</p><formula xml:id="formula_45">S ≥ N ∑ i=k (U k -U i ) and S ≥ U k . (<label>18</label></formula><formula xml:id="formula_46">)</formula><p>In particular, if k * = 1, then the M = 1 constraint does not affect the maximum supported rate.</p><p>Note that k * is well defined if S &gt; U N , because <ref type="bibr" target="#b18">(18)</ref> holds for k = N. The index k * is the dividing point between peers with uplink capacities smaller than or equal to r max and peers with uplink capacities larger than</p><formula xml:id="formula_47">r max . If U k-1 &gt; r ≥ U k , then 1 N (S + N ∑ i=1 Ûi ) = 1 N (S + kr + N ∑ i=k+1</formula><p>Ûi ) , so we have r = g(k). Now we give the detailed proof.</p><p>Proof. Case 1 is when the maximum upload rates of all nodes are affected by the single peer restriction. Case 2 is when none of the maximum upload rates are affected by the single peer restriction. Case 3 is when some maximum upload rates are affected while others are not. We combine cases 2 and 3 at the end. Case 1: if S ≤ U N , i.e., if the server uplink capacity is smaller than the smallest peer uplink capacity, then the streaming rate is limited by server uplink capacity, and we have r max = S. This r max is obviously achievable, as a simple chain topology (s</p><formula xml:id="formula_48">→ 1 → 2 → ••• → N) works.</formula><p>Case 2: if S is very large, such that a rate r ≥ U 1 can be supported, then Ûi = U i , ∀i ∈ N , and thus the M = 1 constraint does not reduce the maximum upload rate of each user. Therefore, we can achieve the same maximum supported rate as in the unconstrained case (Equation ( <ref type="formula" target="#formula_13">9</ref>)). The necessary condition for r</p><formula xml:id="formula_49">≥ U 1 is min(S, 1 N (S + N ∑ i=1 U i )) ≥ U 1 ⇔ S ≥ N ∑ i=1 (U 1 -U i ) and S ≥ U 1 , (<label>19</label></formula><formula xml:id="formula_50">)</formula><p>which means that the rate r = U 1 can be supported.</p><formula xml:id="formula_51">Case 3: if U N &lt; S &lt; max(U 1 , ∑ N i=1 (U 1 -U i ))</formula><p>, then U N can be supported while U 1 cannot, and thus we have U 1 &gt; r max &gt; U N . Consider a given rate r ∈ (U N ,U 1 ), suppose r lies between U k-1 and U k , i.e., U k-1 &gt; r ≥ U k . Then, Ûi = r, ∀i &lt; k and Ûi = U i , ∀i ≥ k. This means that the M = 1 constraint reduces the upload rate for peers 1 to k -1, but not for peers k to N. From (15), we have</p><formula xml:id="formula_52">r ≤ min(S, 1 N (S + k-1 ∑ i=1 r + N ∑ i=k U i )) ⇒ r ≤ min(S, g(k)) . (<label>20</label></formula><formula xml:id="formula_53">)</formula><p>Since r ≥ U k , we have min(S, g(k)) ≥ U k , which means</p><formula xml:id="formula_54">S ≥ U k and g(k) ≥ U k ⇒ S ≥ N ∑ i=k (U k -U i ) .</formula><p>So if k satisfies <ref type="bibr" target="#b18">(18)</ref>, min(S, g(k)) gives an upper bound for r. Now we look for the tightest such upper bound, which happens to be reached if k = k * . We have the following property for g(k):</p><p>Lemma 2. Let g(k) be defined as in <ref type="bibr" target="#b17">(17)</ref>, then for any k &lt; N,</p><formula xml:id="formula_55">g(k) ≥ U k ⇒ g(k) ≤ g(k + 1) , (<label>21</label></formula><formula xml:id="formula_56">)</formula><formula xml:id="formula_57">g(k) ≤ U k ⇒ g(k) ≥ g(k + 1) . (<label>22</label></formula><formula xml:id="formula_58">)</formula><p>From Lemma 2, if k * is the minimum k such that (18) holds, then U k * -1 &gt; r max ≥ U k * , and the tightest bound on r is</p><formula xml:id="formula_59">r max ≤ min(S, g(k * )) . (<label>23</label></formula><formula xml:id="formula_60">)</formula><p>Under case 3, U 1 &gt; r and k * &gt; 1. However, if we remove the U 1 &gt; r condition, and allow S to be sufficiently large such that k * = 1, then <ref type="bibr" target="#b18">(18)</ref> reduces to <ref type="bibr" target="#b19">(19)</ref>, and thus we can think of case 2 as a special case of case 3 when k * = 1.</p><p>The above analysis gives an upper bound for r max . We already mentioned that a simple chain topology achieves the upper bound for case 1. For case 2 and 3, it is easy to see that the upper bound in <ref type="bibr" target="#b23">(23)</ref> can be achieved by the same ring topology as illustrated in Figure <ref type="figure" target="#fig_1">2</ref>, where r = min(S, g(k * )), and this ring topology can be derived by the same Bottleneck Removal multi-tree construction algorithm.</p><p>Remark: Similar to the minimum server load problem, the multitree construction to achieve the maximum supported rate is either a chain or a ring topology and the multi-tree fanout for each user is 1, so we have M t = 1. Therefore, the maximum supported rate under a stronger M t = 1 constraint is also given by Equation ( <ref type="formula" target="#formula_41">16</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Minimum Tree Depth for M = 1</head><p>In this subsection, we find the minimum multi-tree depth D min that achieves the minimum server load s min under the constraint M = 1. We first give a lower bound for D min , and then show that the lower bound is achievable.</p><p>Suppose a multi-tree has L substream trees, and the server uploads to H (l) peers in substream tree l, which has rate y (l) , l = 1, 2, ••• , L. We say there are H (l) branches in this tree. After receiving the substream from the server, these H (l) peers further upload to the other peers. Since each peer has at most one child, there are H (l) leaf nodes and N -H (l) non-leaf nodes in tree l. Recall that the set of leaf nodes is E (l) and the set of non-leaf nodes is F (l) .</p><p>The depth of tree l, denoted by D (l) , is lower bounded by N/H (l) , since there exists a branch containing at least N/H (l) nodes, and in this branch the nodes form a chain. This lower bound is tight, since evenly distributing all nodes among the H (l) branches achieves it.</p><p>The depth of the multi-tree, denoted by D, is lower bounded as in the following equation:</p><formula xml:id="formula_61">D = max l D (l) ≥ max l N H (l) = N min l H (l) , (<label>24</label></formula><formula xml:id="formula_62">)</formula><p>and by evenly distributing nodes among branches in any tree, this bound is also tight. Note that for simplicity of notation, throughout the paper, max l or min l represents the maximization or minimization over all substream trees l = 1, 2, ••• , L in a given multi-tree. From <ref type="bibr" target="#b24">(24)</ref>, in order to minimize D, we need to minimize the largest D (l) , or equivalently, maximize min l H (l) . We first give an upper bound on min l H (l) and thus a lower bound on D. Suppose we construct a set of substream trees to support r with minimum server load s min , we have Therefore we have the following lower bound on multi-tree depth:</p><formula xml:id="formula_63">r = L ∑ l=1 y (l) , s min = L ∑ l=1 H (l) y (l) . So s min ≥ min l H (l) L ∑ l=1 y (l) = min l H (l) r ,</formula><formula xml:id="formula_64">D ≥ N min l H (l) ≥ N s min r . (<label>25</label></formula><formula xml:id="formula_65">)</formula><p>This gives a lower bound on D for any multi-tree depth. The bound is in fact achievable, so we have the following theorem: Theorem 4. For a given streaming rate r, under the M = 1 constraint, the minimum depth among all multi-trees that achieves the minimum server load s min is</p><formula xml:id="formula_66">D min = N s min r . (<label>26</label></formula><formula xml:id="formula_67">)</formula><p>Proof. From (25), we have D ≥ D min , where D min is defined in <ref type="bibr" target="#b26">(26)</ref>. We now prove that D = D min is achievable. Recall that s min = max(r, ∑ N i=1 (r -U i ) + ). We consider two cases. Case 1: s min &lt; 2r. There is a substream tree with only one branch, so D min = N. The tree depth of N can be achieved with the ring topology in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>Case 2: s min ≥ 2r. It is sufficient to construct a multi-tree such that the streaming rate r is supported by s min and in each substream tree l = 1, 2, ••• , L, H (l) ≥ s min r . Consider tree l with H (l) branches. The N -H (l) non-leaf nodes upload to peers at rate y (l) , and the H (l) leaf nodes do not upload. Since each branch is a chain, once the leaf nodes are fixed, the nonleaf nodes can be evenly distributed among the branches so that the depth of tree l is N H (l) . This indicates that constructing a substream tree with H (l) branches is equivalent to selecting H (l) leaf nodes and subtracting y (l) from the other N -H (l) nodes' capacities.</p><p>Since the server load is larger than r, from Section 4.1 we must have that peer i uploads at Ûi = min(r,U i ). For a given rate r, let k be the smallest index such that U k &lt; r, i.e.,</p><formula xml:id="formula_68">U 1 ≥ U 2 ≥ ••• ≥ U k-1 ≥ r &gt; U k ≥ ••• ≥ U N .</formula><p>Note that we must have U N &lt; r; otherwise we would have s min = max(r, ∑ N i=1 (r -U i ) + ) = r, contradicting s min ≥ 2r. Then the nodes 1, 2, ••• , k -1 upload at rate r and the nodes k, k + 1, ••• , N upload at rates less than r. So only the nodes k, k + 1, ••• , N can be leaf nodes in substream trees and we only need to consider them when constructing the trees. Therefore without loss of generality, we assume r &gt; U 1 .</p><p>Now we need an algorithm to construct the trees. Let</p><formula xml:id="formula_69">H 1 := s min r , J := N - s min r . (<label>27</label></formula><formula xml:id="formula_70">)</formula><p>Then J is the maximum number of non-leaf nodes whose uplink capacities will be used in a tree. We reduce the uplink capacity of these nodes and the remaining is called residual capacity. The idea is to equalize the residual capacities of the nodes so that in the end they can all be consumed. We start with a particular node in the middle and make more and more adjacent nodes have the same residual capacity. Since the group grows like a snowball, we call this the Snowball Algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Snowball Algorithm for Tree Construction:</head><p>We first introduce some notations on multi-tree construction. Suppose we construct the multi-tree step by step, and by slightly abusing notation, we use l to index the steps. In each step, there may be one, or multiple substream trees constructed, but within one step, the branch number in any substream tree is the same, denoted by H (l) . We use y (l) to denote the supported rate in step l; use U (l) i to denote the residual capacity for peer i, i = 1, 2, ••• , N after the l-th step; use δ (l) , s (l) , and r (l) to denote the total supported rate, the residual server load, and the remaining streaming rate to support, respectively, after the l-th step. Initially, for l = 0, we define δ (0) = 0, U</p><formula xml:id="formula_71">(0) i = U i , i = 1, 2, ••• , N, s (0) =</formula><p>s min , and r (0) = r.</p><p>Then we have the following equations:</p><formula xml:id="formula_72">δ (l) = δ (l-1) + y (l) , s (l) = s (l-1) -y (l) H (l) , r (l) = r (l-1) -y (l) , U (l) i = U (l-1) i if i ∈ E (l) , U (l-1) i -y (l) if i ∈ F (l) , y (l+1) ≤ min( s H (l) ,U (l) i , i = 1, 2, ••• , N) .</formula><p>After L steps in a successful multi-tree construction (by successful, we mean that the streaming rate r is supported by the minimum server load), we have the final stage, at which s (L) = r (L) = 0, and</p><formula xml:id="formula_73">U (l) i = 0, ∀i = 1, 2, ••• , N.</formula><p>With the above notations at hand, we introduce the following algorithm on the multi-tree construction: at step 1, we trim node 1 to J, i.e., nodes J + 1 to N are leaf nodes, such that U (1)</p><formula xml:id="formula_74">J = U (1) J+1 .</formula><p>Here, by "trim" we mean "reduce the residual uplink capacity of the node". This is easily done as we can set y (1) = U J -U J+1 . At step 2, we construct two trees with the same rate, one trims nodes 1 to J and the other trims node 1 to J -1 and J + 1, and the trimming stops when one of the two following cases occurs: either</p><formula xml:id="formula_75">U (2) J-1 = U (2) J = U (2) J+1 , or U (2) J = U (2) J+1 = U (2) J+2 .</formula><p>The first case occurs if</p><formula xml:id="formula_76">U (1) J-1 -U (1) J ≤ U (1) J+1 -U (1)</formula><p>J+2 , and the second case occurs otherwise. In both cases, after step 2, including the J-th node, there are at least 3 nodes that have the same residual capacity. We use the term snowball to represent the set of nodes whose residual capacities are the same as that of the J-th node. Let similar trimming continue in latter steps: suppose before the l-th step, the snowball contains m 1 nodes, and there are m 2 nodes in front of the snowball and their residual capacities are larger than that of the snowball. Since J-th node is in the snowball, m 1 + m 2 ≥ J. In the l-th step, m 1 substream trees with the same rate are constructed, where each tree trims J nodes. The m 2 nodes in front of the snowball are trimmed in each tree, while each node inside the snowball is trimmed in Jm 2 &lt; m 1 trees. This way, the nodes in front of the snowball are trimmed faster than the nodes inside the snowball, and the nodes after the snowball are not trimmed at all. The l-th step stops if the node just before or just after the snowball is absorbed into the snowball.</p><p>Two examples of this algorithm are given in Figure <ref type="figure" target="#fig_5">4</ref>. A feature of the Snowball algorithm is that the order of the residual capacities of all nodes at any stage is the same as the order of the original capacities, i.e.,</p><formula xml:id="formula_77">U (l) 1 ≥ U (l) 2 ≥ ••• ≥ U (l) N .</formula><p>After a sufficient number of steps, say K steps, the Snowball algorithm stops at one of the following: either</p><formula xml:id="formula_78">U (K) 1 = U (K) 2 = ••• = U (K) N = u , or U (K) J +1 = U (K) J +1 = ••• = U (K) N = 0 for some J &lt; J .</formula><p>In the first case, the snowball finally contains all the nodes; and in the second case, before the snowball contains all the nodes, all the Example 1: N = 5, r = 11, s = 34, H 1 = 3, J = 2, q = 0.</p><p>Step (l) ( 1 Step (l) In example 1, the snowball finally includes all nodes, and the multi-tree construction is successful: it achieves the minimum server load s min = 34, and its minimum branch number is H 1 = 3. In example 2, all nodes have zero residual capacity before the snowball includes all nodes, and the multi-tree construction is successful: it achieves the minimum server load s min = 30, and its minimum branch number is</p><formula xml:id="formula_79">U (l) 1 U (l) 2 U (l) 3 U (l) 4 U (l) 5 δ (l) r (l) s (l) 0 10 5 (<label>3</label></formula><formula xml:id="formula_80">U (l) 1 U (l) 2 U (l) 3 U (l) 4 U (l) 5 δ (l) r (l) s (l) 0 10 9 3 (2) 1 0 11 30 1 9 9 (<label>2 2</label></formula><formula xml:id="formula_81">H 1 = 2.</formula><p>nodes in the snowball have zero residual capacity. Since the J-th node is in the snowball, in the second case, only J &lt; J nodes have positive residual capacities.</p><p>After the snowball algorithm stops, in both cases, we can further construct trees with at least H 1 branches, i.e., with at most J nodes trimmed, and we can prove that we can achieve both the minimum server load and the H min = H 1 property for both cases. That result is summarized in the following lemma: Lemma 3. Using the Snowball algorithm, we can construct a multi-tree where in any substream tree, the branch number is at least H 1 , and achieve the minimum server load.</p><p>From the proof in <ref type="bibr" target="#b20">[20]</ref>, the algorithm runs in polynomial time. Lemma 3 completes the proof of Theorem 4.</p><p>We have found the lower bound on D min for M = 1. If we let the server upload rate be bigger than s min , then following similar steps, we can show that an equation similar to <ref type="bibr" target="#b26">(26)</ref> holds:</p><formula xml:id="formula_82">D min = N s r . (<label>28</label></formula><formula xml:id="formula_83">)</formula><p>Equation <ref type="bibr" target="#b28">(28)</ref> gives a tradeoff between D min and s, or the delay and the server load. This means in real systems, by increasing the server capacity, we can achieve a smaller tree depth and a lower delay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Minimum Tree Depth for M t = 1</head><p>We now study the minimum tree depth under the M t = 1 constraint. We show that the best strategy to reduce tree depth under the M t = 1 constraint is to divide the original ring (see Figure <ref type="figure" target="#fig_1">2</ref>) into multiple rings while maintaining the minimum server load. Since the tree depth of a ring is the number of nodes in this ring, by dividing the N nodes into multiple rings, the multi-tree depth is the maximum ring size. And to achieve a minimum tree depth, we need to minimize the maximum ring size.</p><p>Before we give the minimum value of maximum ring size, we first introduce further notation and terminology. Any subset P ⊂ N is an index set, and we denote the number of its element by |P|. We say P is isolated if no node in P uploads to or downloads from any nodes outside P. If the nodes in P form a ring topology, then the depth of P is |P|. For an integer H ≤ |P|, we call a set of index sets</p><formula xml:id="formula_84">{P 1 , P 2 , ••• , P H } a division, or an H-division, of P, if all P i , i = 1, 2, ••• , H,</formula><p>are mutually exclusive and their union equals P.</p><p>We define the two sets A and B: A contains the nodes whose capacities are at least r, and B contains the rest. Suppose</p><formula xml:id="formula_85">A = {1, 2, ••• , k -1} and B = {k, k + 1, ••• , N}, then |A| = k -1 and |B| = N -k + 1. Consider an H-division of N into {G 1 , G 2 , •••, G H }, and define A h = G h ∩ A and B h = G h ∩ B, then {A h , h = 1, 2, ••• , H} is an H-division of A and {B h , h = 1, 2, ••• , H} is an H-division of B. If the H sets G 1 , G 2 , •••, G H are isolated, i.e., no cross set uploading/downloading, then we call {G 1 , G 2 , ••• , G H } an isolated H-division of N . We call an isolated H-division of N to be efficient, if the minimum server load is not affected by mak- ing G 1 , G 2 , ••• , G H isolated. If the nodes in each G h connect to be a ring, by efficiently dividing N into G 1 , G 2 , ••• , G H , the multi-tree depth is reduced from N to max(|G h |, h = 1, 2, ••• , H).</formula><p>The condition for an isolated division to be efficient is given in the following lemma:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4. The necessary and sufficient condition for an isolated H-division to be efficient is</head><formula xml:id="formula_86">∑ i∈B h (r -U i ) ≥ r, ∀h ∈ 1, 2, ••• , H . (<label>29</label></formula><formula xml:id="formula_87">)</formula><p>Note that for an efficient H-division, there are only requirements on B h , h = 1, 2, ••• , H, and no requirements on A h , h = 1, 2, ••• , H. This means that once we divide B into H bins such that (29) is satisfied, we can arbitrarily put the nodes in A into the H bins. Given an efficient H-division of B, the best strategy of putting A nodes into the bins is the waterfilling strategy, illustrated in Figure <ref type="figure" target="#fig_6">5</ref>, which minimizes max(|G h |, h = 1, 2, ••• , H). From the waterfilling strategy, for any fixed efficient division of B into {B h , h = 1, 2, ••• , H}, without loss of generality, suppose B 1 has the most elements, i.e.,</p><formula xml:id="formula_88">|B 1 | = max h |B h |, then the minimum multi-tree depth is D w = N/H if |A| ≥ ∑ H h=2 (|B 1 | -|B h |) , max(|B h |, h = 1, 2, ••• , H) otherwise , (<label>30</label></formula><p>) where the subscript w stands for waterfilling. The first case corresponds to the scenario that the H bins are filled to be flat, and the second corresponds to the scenario that the bins are not flattened so the highest original bin gives the largest height of the filled bins.</p><p>The problem of finding the minimum D w is strongly-NP hard, because the first case, i.e., when</p><formula xml:id="formula_89">|A| ≥ ∑ H h=2 (|B 1 | -|B h |)</formula><p>, is strongly-NP hard. In the first case, minimizing D w is equivalent to maximizing the number of bins H, such that in each bin h, ∑ i∈B h (r -U i ) ≥ r. This is the classic bin covering problem, or the dual bin packing problem <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b2">2,</ref><ref type="bibr" target="#b7">7]</ref>, which is known to be strongly-NP hard <ref type="bibr" target="#b12">[12]</ref>. There are polynomial time approximation algorithms <ref type="bibr" target="#b8">[8,</ref><ref type="bibr">9,</ref><ref type="bibr" target="#b10">10]</ref>.</p><p>Suppose we can find min D w , then we get a upper bound on D min . Since the set of multi-trees under the M t = 1 constraint is a subset of that under the M = 1 constraint, from <ref type="bibr" target="#b26">(26)</ref>, we know that the N s min r lower bounds D min . Then, we have the following theorem:</p><p>Theorem 5. For a given streaming rate r, under the M t = 1 constraint, the minimum depth among all multi-trees that achieve the minimum server load s min satisfies the following bounds:</p><formula xml:id="formula_90">N s min r ≤ D min ≤ min D w , (<label>31</label></formula><formula xml:id="formula_91">)</formula><p>where the minimum of D w is over all efficient divisions.</p><p>Lemma 4 is the condition for achieving minimum server load. If the server uploads at a rate higher than s min , then the condition in Lemma 4 can be relaxed, and not all divisions need to satisfy <ref type="bibr" target="#b29">(29)</ref>. This way we may be able to have more divisions and therefore reduce the tree depth. This is a tradeoff between server load and delay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">MULTIPLE DOWNLOADING PEERS</head><p>We have studied the two extreme cases in Sections 3 and 4, where the peer selection has the most and least freedom, respectively. In this section, we study the general case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Homogenous Users: Maximum Streaming Rate and Minimum Server Upload</head><p>We start with a homogeneous users scenario, where</p><formula xml:id="formula_92">U 1 = U 2 = ••• = U N = U.</formula><p>Perhaps surprisingly, when all the peers have the same uplink capacity, the peer number constraint does not change the minimum server load and the maximum supported rate. Theorem 6. When user uplink capacities are homogeneous, the minimum server load and maximum supported rate are the same as in the unconstrained case, independent of M or M t .</p><p>Proof. The unconstrained peer selection case gives performance bounds for constrained peer selection. We show that these bounds are achievable in the homogeneous uplink case even with the most strict peer selection constraint: M t = 1. Therefore the bounds must be achievable for all M and M t , because the multi-tree for M t = 1 is also a valid multi-tree for general M and M t values.</p><p>When peers have the same uplink capacity, Theorem 2 reduces to s min (r) = max(r, N(r -U)) , <ref type="bibr" target="#b32">(32)</ref> and Theorem 3 reduces to r max (S) = min(S, S + NU N ) .</p><p>(33)</p><p>These values for M t = 1 is the same as the values for unconstrained peer selection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Homogeneous Users: Minimum Tree Depth</head><p>We have seen in Section 4 that the biggest effect of restricting peer selection is the increase in tree depth. We now study the tree depth for general 1 ≤ M ≤ N -1 and homogeneous uplinks. Sometimes the exact value of the minimum tree depth cannot be given analytically, and we give upper and lower bounds that are very close to each other.</p><p>The server has no limit on the number of connections, but a user can upload to at most M peers, so a substream tree is a number of M-ary trees with the roots connected to the server. In order to minimize the tree depth, we need to divide the users into as many groups as possible where each group forms an M-ary tree without increasing the server load. We give upper and lower bounds on the maximum number of groups: H max and H min , and the maximum number of peers in a group is bounded by</p><formula xml:id="formula_93">N min := N H max ,<label>(34)</label></formula><p>and</p><formula xml:id="formula_94">N max := N H min . (<label>35</label></formula><formula xml:id="formula_95">)</formula><p>Since all the users are identical, we can build different substream trees by rotating the users within each group. So the substream trees all have the same depth, which is also the multi-tree depth. The following lemma gives the tree depth: Lemma 5. If a group of n homogeneous users form an M-ary tree with the root connected to the server, then the minimum tree depth is given by f</p><formula xml:id="formula_96">(n, M) := n i f M = 1 , log M ((M -1)n + 1) if M &gt; 1 .</formula><p>When different substream trees are formed by rotating the users in the M-ary tree, then the minimum multi-tree fanout M t has the following upper bound:</p><formula xml:id="formula_97">min M t ≤ M + ( f (n, M) -2)(M -1) ,</formula><p>We have the following theorem for the minimum tree depth with identical users: Theorem 7. Suppose one user has at most M children in any substream tree, and that all users have the same uplink capacity U. Then, the minimum depth that achieves the minimum server load is where N min and N max are defined in ( <ref type="formula" target="#formula_93">34</ref>) and ( <ref type="formula" target="#formula_94">35</ref>), and</p><formula xml:id="formula_98">1. If N ≤ 2, then D min = N. 2. If N &gt; 2 and r &lt; NU N-2 , then D min = f (N, M), and min M t ≤ M + ( f (N, M) -2)(M -1) . 3. If N &gt; 2 and r ≥ NU N-2 , then f (N min , M) ≤ D min ≤ f (N max , M) , and min M t ≤ M + ( f (N max , M) -2)(M -1) ,</formula><formula xml:id="formula_99">H max = N r -U r , H min = N r r-U .</formula><p>Proof. We prove this theorem under the three different cases. In the first two cases we cannot divide the N nodes into groups; in case 3 we can.</p><p>Case 1:</p><formula xml:id="formula_100">If N = 1, then D min = 1. If N = 2, then D min = 2. For both, D min = N.</formula><p>Case 2: When N &gt; 2 and r &lt; NU/(N -2), we have</p><formula xml:id="formula_101">s min = max(r, N(r -U)) &lt; 2r .</formula><p>So there exists at least one substream tree in which the server uploads to only one user, i.e., there is only one branch; otherwise, if the server uploads every substream at least twice, we would have s ≥ 2r and there is a contradiction. From Lemma 5 the minimum depth is f (N, M). Case 3: We first check the lower bound. If N(r -U) ≥ r, then there is a substream that the server transmits to at most N(r -U)/r users. This means that there is a substream that the server transmits to at most H max users. Therefore at least one user who receives the substream from the server is responsible for passing it (possibly through multiple hops) to at least N min -1 other users. From Lemma 5, we have D min ≥ f (N min , M).</p><p>We then look at the upper bound. We have</p><formula xml:id="formula_102">N H min (r -U) ≥ r r -U (r -U) ≥ r .</formula><p>Therefore we can divide the users into H min groups without increasing the server load. From Lemma 5, we have D min ≤ f (N max , M).</p><p>Theorem 7 gives an upper bound and a lower bound, rather than the exact expression, on D min for case 3. We check numerically whether the bounds are tight and Figure <ref type="figure" target="#fig_7">6</ref> shows the result. For N = 100 and N = 300, we vary U/r from 0 to 1. The plots show that the bounds are very tight: N min and N max are close to each other, and they grow closer for larger N. This means f (N min , M) and f (N max , M) are close to each other. In Section 4, we already saw the tradeoff between server load and minimum tree depth for M = 1 and M = 1. Theorem 7 further shows the tradeoff between M and the minimum tree depth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Heterogeneous Users</head><p>We have considered single downloading peer and heterogeneous users case in Section 4.1. Similar to ( <ref type="formula" target="#formula_24">12</ref>) and ( <ref type="formula">13</ref>), for general M &gt; 1, the maximum upload rate of user i is</p><formula xml:id="formula_103">Ûi (M) := min(Mr,U i ) ,<label>(36)</label></formula><p>and the lower bound for s min (r, M) under M &gt; 1 degree bound is:</p><formula xml:id="formula_104">s min (r, M) ≥ max r, Nr - N ∑ i=1 Ûi (M) = max r, Nr - N ∑ i=1 min(Mr,U i ) . (<label>37</label></formula><formula xml:id="formula_105">)</formula><p>It is shown in <ref type="bibr" target="#b19">[19]</ref> that this bound is in fact tight. Similar to Theorem 3 in Section 4.2, given the minimum server load, we have the following result on maximum supported rate:</p><formula xml:id="formula_106">r max (S, M) = S if S ≤ U N M , min(S, g(k * , M)) if S &gt; U N M ,<label>(38)</label></formula><p>where</p><formula xml:id="formula_107">g(k, M) := S+∑ N i=k U i N-Mk+M if k &lt; N M + 1 , ∞ otherwise, (<label>39</label></formula><formula xml:id="formula_108">)</formula><p>and k * is the minimum k such that</p><formula xml:id="formula_109">U k ≤ Mg(k, M) and U k ≤ MS . (<label>40</label></formula><formula xml:id="formula_110">)</formula><p>Given the minimum server load, similar to Theorem 4, we can also show that, for a given streaming rate r, under the degree bound M &gt; 1, the minimum depth among all trees that achieve the minimum server load s min (r, M) is</p><formula xml:id="formula_111">f (N , M) ≤ D min ≤ f (N, M) , (<label>41</label></formula><formula xml:id="formula_112">)</formula><p>where N := N s min (r,M) r</p><p>. The proofs of the maximum streaming rate and the bounds on the minimum tree depth are omitted here and are available in <ref type="bibr" target="#b20">[20]</ref>.</p><p>Some numerical examples on the maximum supported rate as functions of server load, user uplink bandwidths, and degree bounds are plotted in Figure <ref type="figure" target="#fig_8">7</ref>. The figure on the left is the maximum streaming rate as a function of server capacity, under different tree out-degree bounds and user uplink capacities. This plot shows that when user uplink capacities are close, the tree outdegree bound has little effect. The bound has effect when the user uplink capacities differ significantly. This is because the constraint on peer selection causes some high user uplink capacity to be under-utilized. The figure on the right is the maximum streaming rate as a function of tree out-degree bound, for different user uplink capacities. We observe that in each case, there is a value of M that if the degree bound is increased beyond this value, there is no gain in maximum supported streaming rate. This is because when enough peers download from high capacity users to fully utilize their uplink capacities, allowing more connections does not help the maximum streaming rate. In addition, when the maximum streaming rate is limited by the server capacity, increasing user uplink capacity or the degree bound cannot help.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>The concept of peer-assisted live streaming has received a lot of attention in recent years. The application scenarios include IPTV <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b1">1,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b21">21]</ref>, video-on-demand <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b24">24]</ref>, and video conferencing <ref type="bibr" target="#b5">[5]</ref>. Our effort focuses on the analysis of large-scale IPTV systems. Peer-assisted IPTV systems can be tree-based <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b4">4,</ref><ref type="bibr" target="#b18">18]</ref>, where the tree structure is constructed and maintained centrally and explicitly, mesh-based <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b31">31]</ref>, where each peer selects partners to trade packets like BitTorrent and the system does not explicitly construct and maintain a tree structure, or tree-mesh hybridbased <ref type="bibr" target="#b30">[30]</ref>. For a comparison of tree and mesh, see <ref type="bibr" target="#b22">[22]</ref>; for an overview of challenges and approaches in current large-scale P2P streaming, see <ref type="bibr" target="#b14">[14]</ref>.</p><p>While there is much work on system design and measurement studies of a peer-to-peer streaming system, few papers work on theoretical analysis and fundamental limitations of peer-assisted live streaming system. In <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b18">18]</ref>, the maximum supported rate without degree bound is studied; <ref type="bibr" target="#b17">[17]</ref> further develops a stochastic fluid model to consider peer churn; and <ref type="bibr" target="#b5">[5]</ref> extends the unconstrained performance study to video conferencing scenario. In this paper, we first bring peer selection constraint or outgoing degree bound into the framework, and derive the optimal performance under different peer selection constraints by first giving the performance bounds and then constructing multi-trees to achieve the bounds. Note that although the bounds are achieved by tree-based algorithms, they also apply to mesh-based algorithms. Therefore, these bounds not only are optimal values for tree-based algorithms, but also can server as a benchmark to compare mesh-based algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION AND FUTURE WORK</head><p>In this paper, we have studied three performance metrics: minimum server load, maximum supported rate, and minimum tree depth, under three cases: unconstrained peer selection, single peer selection, and constrained peer selection. We derive bounds on these metrics and prove the bounds are tight. The analysis on the performance bounds also suggest the tradeoffs between tree depth, server load, and degree bound.</p><p>There are several directions to extend this work. First, we consider a single streaming rate in this paper, and we can extend the discussion to multi-layer streams, where users with different downlink capacities receive different number of layers of the stream. Second, we consider a single session, and we can extend to multisession conferential scenario. Finally, we can study more on the tradeoffs between tree depth, server load and degree bound, like exploring the 3-D tradeoff region.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The content distribution multi-tree to minimize the server load in Theorem 1. Case 1 uses tree 1 to N, and case 2 uses tree 1 to N + 1. For both cases, the multi-tree depth is 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The optimal logical topology for single downloading peer constraint.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure3: An example to illustrate the construction of a multitree using the Bottleneck Removal algorithm. When l = 1, the bottleneck is (s, 3) and case II applies (k = 3, p = 2). We build a tree branch as s → 3 → ... → 2, and the residual capacities of edges on the branch are reduced by y 1 = 2. When l = 3, the bottleneck is<ref type="bibr" target="#b5">(5,</ref><ref type="bibr" target="#b6">6)</ref> and case I applies (k = 5, p = 5, q = 6). We build a tree branch from s to 5 and get stuck at 6. We forward to the next user 1, and repeat the same process, which results in another tree branch s → 1 → 2 → 3 → 4. Note that in each iteration, all users will be covered in the spanning tree rooted at s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Example 2 :</head><label>2</label><figDesc>N = 5, r = 11, s = 30, H 1 = 2, J = 3, q = 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Two examples for the Snowball algorithm. In the tables, (•) indicates the snowball. In example 1, the snowball finally includes all nodes, and the multi-tree construction is successful: it achieves the minimum server load s min = 34, and its minimum branch number is H 1 = 3. In example 2, all nodes have zero residual capacity before the snowball includes all nodes, and the multi-tree construction is successful: it achieves the minimum server load s min = 30, and its minimum branch number is H 1 = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: An example to show the waterfilling strategy. Here, H = 3, |B 1 | = 7, |B 2 | = 5, |B 3 | = 3, A = {1, 2, ••• , k -1}, and the height of each bin represents the number of elements in the bin. One-by-one, the elements of A are put into the bin with the least element (waterfilling). If |A| &lt; 6, as in the left figure, then the three bins are not flattened, and max(|G h |, h = 1, 2, 3) = |B 1 |. If |A| ≥ 6, a in the right figure, then the three bins are not flattened, and max(|G h |, h = 1, 2, 3) = N/H .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The values of H max , H min , N min and N max versus U/r for N = 100 and N = 300. We can see that N min and N max are close to each other which means the bounds in Theorem 7 are tight.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The maximum supported rate as functions of server load (left figure) and degree bound (right figure). In both figures, we have N = 9 users, fix the upload bandwidths for users 2 to 9, and vary user 1's bandwidth. The last two curves overlap in both plots.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Summary of results (" √ " indicates upper and lower bounds, and " √√ " indicates an exact optimal value).</head><label>1</label><figDesc>D min )</figDesc><table><row><cell cols="2">Unconstrained peer selection (Sec. 3) Single downstream peer (Sec. 4) Multiple downstream peers (Sec. 5)</cell><cell>√√ √√ √√</cell><cell>√√</cell><cell>[17, 18] √√ √√</cell><cell>√√ √√ √</cell></row><row><cell>r:</cell><cell>Data rate of the streaming video.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>S:</cell><cell>Server capacity.</cell><cell></cell><cell></cell><cell></cell></row><row><cell>s:</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 : Main notation used in this paper.</head><label>2</label><figDesc></figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENT</head><p>We thank Jiayue He, Professor Gary Chan, and Dr. David Johnson for their useful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Measurement of commercial peer-to-peer live video streaming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop in Recent Advances in Peer-to-Peer Streaming (WRAIPS)</title>
		<meeting>the Workshop in Recent Advances in Peer-to-Peer Streaming (WRAIPS)</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Problems in Discrete Applied Mathematics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Assmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983">1983</date>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On a Dual Version of the One-Dimensional Bin Packing Problem</title>
		<author>
			<persName><forename type="first">S</forename><surname>Assmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kleitman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="502" to="525" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Splitstream: High-bandwidth content distribution in a cooperative environment</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-M</forename><surname>Kermarrec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SOSP&apos;03</title>
		<meeting><address><addrLine>Lake Bolton, New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Utility maximization in peer-to-peer systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ponec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Chou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigmetrics</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Incentives Build Robustness in BitTorrent</title>
		<author>
			<persName><forename type="first">B</forename><surname>Cohen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">First Workshop on the Economics of Peer-to-Peer Systems</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A dual version of bin packing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Csirik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Frenk</surname></persName>
		</author>
		<idno>9029</idno>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>Erasmus University of Rotterdam -Econometric Institute</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Two Simple Algorithms for Bin Covering</title>
		<author>
			<persName><forename type="first">J</forename><surname>Csirik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B G</forename><surname>Frenk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Labbé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Cybern</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="13" to="25" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Online Algorithms for a Dual Version of Bin Packing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Csirik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Totik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Appl. Math</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="163" to="167" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">In Developments from a June 1996 seminar on Online algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Csirik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Woeginger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="147" to="177" />
			<pubPlace>London, UK</pubPlace>
		</imprint>
	</monogr>
	<note>On-line Packing and Covering Problems</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the Performance of Multiple-Tree-Based Peer-to-Peer Live Streaming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Dan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Fodor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Chatzidrossos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE INFOCOM</title>
		<imprint>
			<biblScope unit="page" from="2556" to="2560" />
			<date type="published" when="2007-05">May 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Strong&quot; NP-Completeness Results: Motivation, Examples, and Implications</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="499" to="508" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Insights into PPLive: A Measurement Study of a Large-Scale P2P IPTV System</title>
		<author>
			<persName><forename type="first">X</forename><surname>Hei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IPTV Workshop, International World Wide Web Conference</title>
		<meeting>of IPTV Workshop, International World Wide Web Conference</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Measurement Study of a Large-Scale P2P IPTV System</title>
		<author>
			<persName><forename type="first">X</forename><surname>Hei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Multimedia</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Peer-Assisted VoD: Making Internet Video Distribution Cheap. IPTPS&apos;07</title>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ross</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<pubPlace>Redmond</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Can Internet Video-on-Demand be Profitable?</title>
		<author>
			<persName><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Ross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="133" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Stochastic Fluid Theory for P2P Streaming Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ross</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
			<pubPlace>Anchorage, Alaska</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Mutualcast: An efficient mechanism for one-to-many content distribution</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGCOMM ASIA Workshop</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Achieving streaming capacity in P2P</title>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Chou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-04">April 2008</date>
			<publisher>Microsoft Research Technical Report</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Performance bounds for peer-asssited live streaming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zhang-Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chiang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008-03">March 2008</date>
		</imprint>
		<respStmt>
			<orgName>Princeton University Technical</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Push-to-Pull Peer-to-Peer Live Streaming</title>
		<author>
			<persName><forename type="first">T</forename><surname>Locher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wattenhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st International Symposium on Distributed Computing (DISC)</title>
		<imprint>
			<date type="published" when="2007-09">September 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Mesh or multiple-tree: A comparative study of live P2P streaming approaches</title>
		<author>
			<persName><forename type="first">N</forename><surname>Magharei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rejaie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Infocom</title>
		<meeting><address><addrLine>Anchorage, AK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05">May 2007</date>
			<biblScope unit="page" from="1424" to="1432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Distributing streaming media content using cooperative networking</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">N</forename><surname>Padmanabhan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sripanidkulchai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM NOSSDAV</title>
		<meeting><address><addrLine>Miami Beach, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Peer-to-Peer Streaming of Stored Media: The Indirect Approach. SIGMETRICS Perform</title>
		<author>
			<persName><forename type="first">T</forename><surname>Piotrowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bhatnagar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ganguly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Izmailov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eval. Rev</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="371" to="372" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the Feasibility of Commercial, Legal P2P Content Distribution</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-M</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gkantsidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="75" to="78" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Measuring P2P IPTV Systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Silverston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Fourmaux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International workshop on Network and Operating Systems Support for Digital Audio &amp; Video</title>
		<meeting>the 17th International workshop on Network and Operating Systems Support for Digital Audio &amp; Video</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Scaling laws and tradeoffs in peer-to-peer live multimedia streaming</title>
		<author>
			<persName><forename type="first">T</forename><surname>Small</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MULTIMEDIA &apos;06: Proceedings of the 14th annual ACM international conference on Multimedia</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="539" to="548" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Push-to-Peer Video-on-Demand system: Design and Evaluation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Diot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kurose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Massoulie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valleo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>special issue on Advances in Peer-to-Peer Streaming Systems</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An analytical study of peer-to-peer media streaming systems</title>
		<author>
			<persName><forename type="first">Y.-C</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hefeeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Prabhakar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Multimedia Comput. Commun. Appl</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="354" to="376" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">mTreebone: A Hybrid Tree/Mesh Overlay for Application-Layer Live Video Multicast</title>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 27th International Conference on Distributed Computing Systems table of contents</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">R2: Random push with random network coding in live peer-to-peer streaming</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications, Special Issue on Advances in Peer-to-Peer Streaming Systems</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1655" to="1666" />
			<date type="published" when="2007-12">December 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">DONet/CoolStreaming: A data-driven overlay network for live media streaming</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-S</forename><forename type="middle">P</forename><surname>Yum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE INFOCOM</title>
		<meeting><address><addrLine>Miami, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-03">March 2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
