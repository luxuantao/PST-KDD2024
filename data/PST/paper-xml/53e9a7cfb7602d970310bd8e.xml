<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">XML schema refinement through redundancy detection and normalization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-09-22">22 September 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Cong</forename><surname>Yu</surname></persName>
							<email>congy@eecs.umich.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
								<orgName type="institution">University of Michigan</orgName>
								<address>
									<settlement>Ann Arbor</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">XML schema refinement through redundancy detection and normalization</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-09-22">22 September 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">6BAEB0AAC719490F7C3E540618E30328</idno>
					<idno type="DOI">10.1007/s00778-007-0063-0</idno>
					<note type="submission">Received: 20 February 2007 / Revised: 21 May 2007 / Accepted: 2 July 2007 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>XML</term>
					<term>Schema design</term>
					<term>Functional dependency</term>
					<term>Normal form</term>
					<term>Data redundancy</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>As XML becomes increasingly popular, XML schema design has become an increasingly important issue. One of the central objectives of good schema design is to avoid data redundancies: redundantly stored information can lead not just only to a higher data storage cost but also to increased costs for data transfer and data manipulation. Furthermore, such data redundancies can lead to potential update anomalies, rendering the database inconsistent. One strategy to avoid data redundancies is to design redundancy-free schema from the start on the basis of known functional dependencies. We observe that XML databases are often "casually designed" and XML FDs may not be determined in advance. Under such circumstances, discovering XML data redundancies from the data itself becomes necessary and is an integral part of the schema refinement (or re-design) process. We present the design and implementation of the first system, DiscoverXFD, for efficient discovery of XML data redundancies. It employs a novel XML data structure and introduces a new class of partition-based algorithms. The XML data redundancies are defined on the basis of a new notion of XML functional dependency (XML FD) that (1) extends previous notions by incorporating set elements into the XML FD specification, and (2) maintains tuple-based semantics through the novel concept of Generalized Tree Tuple (GTT). Using this comprehensive XML FD notion, we introduce a new normal form (GTT-XNF) for XML documents, and provide comprehensive comparisons with previous studies. Given the set of data redundancies (in the form of redundancy-indicating XML FDs) discovered by DiscoverXFD,</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Redundant data take up unnecessary storage, inflates data transfer cost, and can lead to update anomalies. A central objective of database design is to ensure that there are no unintended redundancies. As XML databases have become more common, good design of XML schemas has become increasingly important, especially in complex scientific databases. Furthermore, one of the benefits of XML (whether intended or not) is the ease of generating XML data: compared with relational data, XML data can be created by ordinary users (e.g. individual scientists) with minimal training in database schema design. Such casual design of XML schemas, while important for encouraging data generation, is likely to lead to many data redundancies in the resulting XML databases. <ref type="foot" target="#foot_0">1</ref> Designing a good XML schema is therefore often a two-stage process. In the first stage, data are generated according to the casually designed schema and redundancies are being discovered and recorded. In the second stage, the original schema is re-designed to eliminate unintended data redundancies, and the original data are transformed into the new schema.</p><p>The notion of functional dependency (FD) plays an important role in defining redundancies <ref type="bibr" target="#b6">[7]</ref> in relational databases, and should play a correspondingly important role in XML databases as well. Redundancies in XML data have several distinct features due to the heterogeneous nature of XML data, which makes them richer in semantics as compared with redundancies in relational data. As a result, standard relational FD discovery algorithms are insufficient to find all XML FDs (this is true whether we consider classic relational FD discovery algorithms such as <ref type="bibr" target="#b15">[16]</ref>, or more recent proposals such as Dep-Miner <ref type="bibr" target="#b14">[15]</ref>, TANE <ref type="bibr" target="#b10">[11]</ref>, and FUN <ref type="bibr" target="#b18">[19]</ref>). In this paper, we develop a new algorithm DiscoverXFD, for efficient discovery of XML data redundancies in terms of redundancy-indicating XML FDs.</p><p>XML functional dependency (i.e., constraints which specify that values of certain XML elements are determined by others-to be formally defined later), and the related notion of XML normal form, have recently become an important research topic. In <ref type="bibr" target="#b0">[1]</ref>, Arenas and Libkin adopted a tree tuplebased approach and were the first to formally define XML FD and normal form (XNF). In <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b24">25]</ref>, the authors took a path-based approach and built their XML FD notion in a fashion similar to the XML Key notion proposed in <ref type="bibr" target="#b3">[4]</ref>. In this paper, we show that these XML FD notions are insufficient, and propose a Generalized Tree Tuple-based XML FD notion that can fully capture XML data redundancies with unambiguous semantics. Based on the new XML FD notion, we introduce a new XML normal form called GTT-XNF, and design an algorithm for converting any XML schema into one in GTT-XNF given a set of redundancy-indicating XML FDs.</p><p>The unique challenge in defining XML data redundancies can be illustrated using the example XML document shown in Fig. <ref type="figure" target="#fig_3">1</ref>. The document maintains information about books sold at various book stores within a book warehouse, grouped by states. Each store records its contact information and the books it is selling, and for each book, the ISBN, author, title, and price are maintained. Two intuitive constraints, which the example satisfies, are the following: two books with the same ISBN must have the same title and the same set of authors; and likewise, two books with the same set of authors and the same title must share the same ISBN. Both constraints cause some information in the XML document to become redundant (e.g., the title DBMS and the set of authors Ramakrishnan and Gehrke are stored multiple times for ISBN 0072465638, and vice versa). One important characteristic that distinguishes such XML redundancies from their relational counterparts is the involvement of set elements: it is the set of authors, rather than an individual author, that are being compared and duplicated. This class of FDs is not covered by the definitions in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b24">[25]</ref>. A third constraint is equally interesting: for any two books sold at the same store chain (i.e., stores with the same name), if they have the same ISBN, they will be sold at the same price. The price 79.90 of book 0072465638, therefore, is stored redundantly for the store chain Borders (one in Seattle and the other in Lexington). Such a redundancy is special in that while it is the books on which the comparison is specified, the constraint actually involves an element (i.e., store name) that is not a descendant of book.</p><p>Main contributions and paper outline. We make the following main contributions: <ref type="bibr" target="#b0">(1)</ref> We study the examples of redundancy-inducing (i.e., potentially redundancy indicating) constraints in the XML data model (Sect. 2.2) and show that existing XML FD notions are insufficient for capturing certain XML data redundancies (Sect. 2.3). <ref type="bibr" target="#b1">(2)</ref> We propose a new Generalized Tree Tuple-based XML FD notion, which improves upon the notion introduced in <ref type="bibr" target="#b0">[1]</ref>. We show that more XML data redundancies can now be effectively captured by interesting XML FDs (Sect. 3). <ref type="bibr" target="#b2">(3)</ref> We introduce a new XML normal form (GTT-XNF) based on our proposed XML FD and XML Key notions and provide comprehensive comparisons with a previous XML Key notion <ref type="bibr" target="#b3">[4]</ref> and a previous normal form notion XNF <ref type="bibr" target="#b0">[1]</ref> (Sect. 4). ( <ref type="formula">4</ref>) We design and implement the DiscoverXFD system, which employs a new XML data structure and several novel partition-based algorithms that can efficiently discover XML FDs and detect XML data redundancies (Sect. 5); <ref type="bibr" target="#b4">(5)</ref> We describe a normalization algorithm for converting any XML schema into GTT-XNF given a set of redundancy-indicating XML FDs (Sect. 6). <ref type="bibr" target="#b5">(6)</ref> We demonstrate the scalability and practicality of DiscoverXFD using a benchmark dataset and a variety of real life datasets (Sect. 7). We first present some necessary background.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and challenges</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Schema and data tree</head><p>Figure <ref type="figure" target="#fig_1">2</ref> illustrates the schema of the example XML document in Fig. <ref type="figure" target="#fig_3">1</ref>. It is shown in a nested relational representation <ref type="bibr" target="#b21">[22]</ref> that is used as a common data model to represent both relational and hierarchical (XML) schemas. Intuitively, keyword Rcd is used to indicate complex schema elements (i.e., elements that have children elements, e.g., contact), and keyword SetOf is used to indicate set schema elements (i.e., elements that can have multiple matching data elements sharing the same parent in the data, e.g., book). A set element is not necessarily complex: e.g., author is a set element with a domain of string (str). Formally: Definition 1 (Schema) A schema is defined to be S = E, T, r , where:</p><p>-E is a finite set of element labels; -T is a finite set of element types, and each e ∈ E is associated with a τ ∈ T , written as (e : τ ), τ has the form: τ ::= str | int | float | SetOf τ | Rcd[e 1 : τ 1 , . . . , e n : τ n ];</p><p>Fig. <ref type="figure" target="#fig_3">1</ref> Example XML document. Each node is assigned a key (shown in the bracket), which is referred to as @key, and the dashed boxes isolate data elements that correspond to complex set elements in the schema (Fig. <ref type="figure" target="#fig_1">2</ref>)</p><p>warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> book <ref type="bibr" target="#b19">[20]</ref> ISBN <ref type="bibr" target="#b20">[21]</ref> = state <ref type="bibr" target="#b9">[10]</ref> store <ref type="bibr">[72]</ref> name <ref type="bibr" target="#b10">[11]</ref> = WA  -r ∈ E is the label of the root element, whose associated element type can not be SetOf τ .</p><p>Definition 1 corresponds to the "core" constructs in XML Schema <ref type="bibr" target="#b25">[26]</ref>. Types str, int, and float are system defined simple types. Rcd is a complex type representing the "all" model-group in XML, respectively. Type SetOf is the set type associated with elements with maxOccurs greater than one in XML Schema. We ignore element order and represent the "sequence" model-group as the Rcd type. For simplicity, we treat attributes and elements in the same way, with a reserved "@" symbol to indicate attributes. For mixed-content elements, if there is exactly one textual value, we store it under a distinct new attribute "@value." Otherwise, we ignore the textual values and treat the mixed-content elements as regular complex elements.</p><p>A schema element e k can be identified through a path expression, path(e k ) = /e 1 /e 2 / . . . /e k , where e 1 = r , and e i is associated with type τ i ::= Rcd[. . . , e i+1 : τ i+1 , . . .] for all i ∈ [1, k -1]. Furthermore, if e k is a set element, we call path(e k ) a repeatable path, which is an important concept to be used later. Note that we do not consider path(e k ) to be a repeatable path if e k is not a set element, even if some e i (i &lt; k) is a set element. For example, /warehouse/state/name is not a repeatable path while /warehouse/state/store is. For convenience, we adopt XPath steps "•" (self) and "••" (parent) to form a relative path given an anchor path. For example, if the anchor path is /warehouse/state/store, the relative path ../name is equivalent to /warehouse/ state/name. Definition 2 (Data tree) An XML database is defined to be a rooted labeled tree T = N , P, V, n r , where:</p><p>-N is a set of labeled data nodes, each n ∈ N has a label e and a node key that uniquely identifies it in T ; -n r ∈ N is the root node; -P is a set of parent-child edges, there is exactly one p = (n , n) in P for each n ∈ N (except n r ), where n ∈ N , n = n , n is called the parent node, n is called the child node; -V is a set of value assignments, there is exactly one v = (n, s) in V for each leaf node n ∈ N , where s is a value of simple type.</p><p>We assign a node key, referred to as @key, to each data node in the data tree in a pre-order traversal (gaps in the numbering in Fig. <ref type="figure" target="#fig_3">1</ref> indicate omitted elements). Parent-child edges are represented as directed lines between two data nodes (with arrow pointing to the child node). Value assignments are represented as equality between the node label and the value. We adopt the notion of conformance as defined in <ref type="bibr" target="#b25">[26]</ref> and assume that all given data trees conform to their schemas.</p><p>A data element n k is a descendant of another data element n 1 if there exists a series of data elements n i , such that (n i , n i+1 ) ∈ P for all i ∈ [1, k -1]. Similar to schema elements, n k can also be addressed using a path expression, path(n k ) = /e 1 / . . . /e k , where e i is the label of n i for each i ∈ <ref type="bibr">[1, k]</ref>, n 1 = n r , and (n i , n i+1 ) ∈ P for all i ∈ [1, k -1]. It is possible that two distinct data elements can have the same path (e.g., node 11 and node 41). A data element n k is called repeatable if e k corresponds to a set element in the schema. Finally, n k is called a direct descendant of element n a , if n k is a descendant of n a , path(n k ) = . . . /e a /e 1 / . . . /e k-1 /e k , and e i is not a set element for any i ∈ [1, k -1]. For example, node 21 (ISBN) is a direct descendant of node 20 (book), but not node 12 (store).</p><p>In considering data redundancy, it is important to determine the equality between the "values" associated with two data elements <ref type="bibr" target="#b3">[4]</ref>, instead of comparing their "identities," which is represented by @key. Therefore, we have:</p><formula xml:id="formula_0">Definition 3 (Element-value equality) Two data elements n 1 of T 1 = N 1 , P 1 , V 1 , n r 1 and n 2 of T 2 = N 2 , P 2 , V 2 , n r 2</formula><p>are element-value equal (written as n 1 = ev n 2 ) if and only if:</p><p>-n 1 and n 2 both exist and have the same label; -There exists a set M, such that for every pair</p><formula xml:id="formula_1">(n 1 , n 2 ) ∈ M, n 1 = ev n 2 ,</formula><p>where n 1 , n 2 are children elements of n 1 , n 2 , respectively. Every child element of n 1 or n 2 appears in exactly one pair in M.</p><formula xml:id="formula_2">-(n 1 , s) ∈ V 1 if and only if (n 2 , s) ∈ V 2 ,</formula><p>where s is a simple value.</p><p>Intuitively, two data elements (e.g., node 30 and 50) are element-value equal if and only if the subtrees rooted at those two elements are identical when the order among sibling elements is ignored. Based on element-value equality, we can now define the path-value equality: Definition 4 (Path-value equality) Two data element paths</p><formula xml:id="formula_3">p 1 on T 1 = N 1 , P 1 , V 1 , n r 1 and p 2 on T 2 = N 2 , P 2 , V 2 , n r 2 are path-value equal (written as T 1 . p 1 = pv T 2 . p 2 ) if and only if there is a set M of matching pairs where -For each pair m = (n 1 , n 2 ) in M , n 1 ∈ N 1 , n 2 ∈ N 2 , path(n 1 ) = p 1 , path(n 2 ) = p 2 ,</formula><p>and n 1 = ev n 2 ; -All data elements with path p 1 in T 1 and path p 2 in T 2 participate in M , and each such data element participates in only one such pair.</p><p>Value equality between two paths is complicated by the fact that a single path can match multiple data elements in a data tree. Definition 4 requires that, for two paths to be considered value equal, each node that is pointed to by one path must have a corresponding node that is pointed to by the other path, where the two nodes are element-value equal.</p><p>Order consideration. In Definitions 3 and 4, we take extra steps to ignore the ordering among data elements. This is because ordering in a majority of the real life XML documents we have observed is not semantically significant. When order is important, Definitions 3 and 4 can be adjusted such that each matching pair always involves two data elements that have the same ordering position either among its siblings (Definition 3) or among the data elements with the same path (Definition 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Example XML data redundancies</head><p>We now illustrate data redundancies that can be caused by constraints on the XML data and describe the features of those redundancy-inducing constraints. All the examples are based on the data tree in Fig. <ref type="figure" target="#fig_3">1</ref>.</p><p>Constraint 1 Whenever two books (e.g., nodes 30 and 50) agree on their ISBN values, they will have the same title.</p><p>It is clear that Constraint 1 leads to redundancies if there are two distinct books in the data with the same ISBN value: their titles are redundantly stored. Intuitively, such XML constraints consist of three components. First, target elements, which is the set of data elements (e.g., the books) on which the constraints are imposed. Second, condition elements, which are the elements (e.g., ISBN) specified in the condition of the constraint. Third, implication elements, which are the elements (e.g., title) whose equality is implied if the condition is met. It is worth noting that not all constraints correspond to redundancies. For example, if each distinct book in the data has a unique ISBN value, then Constraint 1 will not result in any redundancy. We will explore the properties of redundancy-inducing constraints later in Sect. 3.3.</p><p>Constraint 1 is straight-forward because both ISBN and title are subelements of book, and each book has exactly one ISBN and one title. However, constraints on XML data can become more complicated. Consider: Constraint 2 Whenever two books are on sale at stores with the same name, if they agree on their ISBN values, they will have the same price.</p><p>Again, Constraint 2 indicates redundancies if there exist two distinct books that share the same ISBN value and that are being sold at the same store or at two stores with the same name. More importantly, Constraint 2 illustrates two important features for XML constraints. First, constraints can involve elements from multiple hierarchies. In this case, while the target elements are the set of books, the condition elements include not only a descendant element of book (i.e., title) but also a store name element that is neither an ancestor nor a descendant of book. Second, constraints can involve missing elements. Often, either the condition elements or the implication elements can be missing in the data instances. For example, the price of the book node 80 is not recorded. The following constraints illustrate yet another important feature of XML constraints: Constraint 3 Whenever two books agree on their ISBN values, they have the same set of authors.</p><p>Constraint 4 Whenever two books share the same set of authors and the same title, they agree on their ISBN values.</p><p>Constraints 3 and 4 indicate redundancies if there are two distinct books (e.g., book nodes 30 and 50) in the data with either the same ISBN values, or the same title values and the same set of author values. Most importantly, it is not any individual author, but rather the set of authors, that are being compared or redundantly stored because each book has a set of authors. The third important feature of XML constraints, therefore, is the involvement of set elements: each condition or implication element specification can, and often, resolve to a set of elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Previous proposals</head><p>The above constraints are essentially intuitive forms of functional dependencies (FDs). To capture redundancies indicated by those constraints, formal definitions of XML FD have been proposed and follow two main approaches: pathbased approach and tuple-based approach. They differ in how the target elements of the constraint are specified: the former implicitly encodes the target elements inside the FD specification, while the latter specifies the target elements independent of each individual FD specification.</p><p>Path-based approach. Proposed by Vincent et al. <ref type="bibr" target="#b24">[25]</ref> is representative of the path-based approach. An XML FD is of the form: {P x 1 , . . . , P x n } → P y , where P x i (also called LHS) are the paths specifying the condition elements, P y (also called RHS) is the path specifying the implication element, and the target elements are implicitly specified as the set of elements pointed to by P y . For example, Constraint 1 can be expressed as: {/warehouse/state/store/book/ ISBN}→/warehouse/state/store/book/title. The semantics of the FD is intuitively defined as the following: for any two distinct title nodes in the data tree, if the ISBN nodes they are associated with have the same value, then the title nodes themselves have the same value. A title node and an ISBN node are associated if they are the descendants of the same book node (book is chosen because its path is the longest common prefix of both title and ISBN). For example, the FD is satisfied in Fig. <ref type="figure" target="#fig_3">1</ref> because for any two titles (e.g., nodes 34 and 54), if their associated ISBNs (e.g., nodes 31 and 51, respectively) share the same value, they have the same value as well.</p><p>warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> name <ref type="bibr">[</ref>  <ref type="bibr" target="#b9">[10]</ref> name <ref type="bibr" target="#b10">[11]</ref> = WA contact <ref type="bibr" target="#b12">[13]</ref> warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> name <ref type="bibr">[</ref>  <ref type="bibr" target="#b9">[10]</ref> name <ref type="bibr" target="#b10">[11]</ref> = WA contact <ref type="bibr" target="#b12">[13]</ref> A B Fig. <ref type="figure">3</ref> (a) Original tree tuple example, and (b) generalized tree tuple example (book 30 is the pivot node)</p><p>Tuple-based approach. In <ref type="bibr" target="#b0">[1]</ref>, Arenas and Libkin proposed the first formal XML FD notion built upon the concept of tree tuples. Instead of specifying target elements from each individual FD as in <ref type="bibr" target="#b24">[25]</ref>, a set of tree tuples is defined independent of any FD and serves as the target for all FDs. Each tree tuple is a tree constructed by picking exactly one data node from the original data tree for each schema element and projecting away all the other nodes. Figure <ref type="figure">3a</ref> illustrates one such tree tuple. XML FDs are subsequently defined based on this tree tuple notion and take a form similar to the one in the pathbased approach. For example, Constraint 2 can be expressed as: {/warehouse/state/store/contact/ name, /warehouse/state/store/book/ISBN}→/warehouse/state/store/book/price. The semantics of the FD is defined as the following: for any two tree tuples, if they have the same values at the nodes specified in the LHS of the FD (i.e., the name and ISBN nodes), they will share the same values at their RHS nodes (i.e., the price nodes). It is worth noting that, if the original XML data tree is viewed as a set of nested relations <ref type="bibr" target="#b2">[3]</ref>, the set of tree tuples is conceptually equivalent to the set of fully unnested tuples. Compared with path-based approach, tuple-based XML FD notion has a semantics that is closer to the relational FD notion. It also suggests a natural technique for XML FD discovery: one can convert the XML data into a fully unnested relation and apply existing FD discovery algorithms directly.</p><p>Discussion: Both <ref type="bibr" target="#b24">[25]</ref> and <ref type="bibr" target="#b0">[1]</ref> effectively capture multihierarchical constraints like Constraint 2. In the former, elements from different hierarchies are associated with each other through the common ancestor node. In the latter, they are connected by belonging to the same tree tuple. Both proposals also adopt a similar semantics for missing elements, which roughly corresponds to the strong satisfaction of FD over incomplete relations as defined in <ref type="bibr" target="#b2">[3]</ref>.</p><p>However, neither notion can effectively capture constraints with set elements. Consider Constraint 3 for Fig.  The closest form to which it can be expressed under both <ref type="bibr" target="#b24">[25]</ref> and <ref type="bibr" target="#b0">[1]</ref> is the following: {/warehouse/ state/store/ book/ISBN}→/warehouse/state/store/book/ author. It is not difficult to see that the semantics of this FD under either notion are not the same as the semantics of the original constraint. The semantics under <ref type="bibr" target="#b24">[25]</ref> is that for any two authors, if they are associated with the same ISBN value, their values are the same. Under this semantics, the FD is violated since book 30 has two authors of different values and the two authors are clearly associated with the same ISBN value. The semantics under <ref type="bibr" target="#b0">[1]</ref> is that for any two tree tuples, if their ISBN nodes share the same value, then they have the same value for their author nodes. According to the construction of tree tuple, author 32 and author 33 belong to two different tree tuples. Since the ISBN nodes of the two tuples have the same value while the author nodes of the two tuples differ, the FD is again violated. The original constraint, however, is satisfied in Fig. <ref type="figure" target="#fig_3">1</ref>: two books with the same ISBN value always have the same set of authors. In the next section, we proposed Generalized Tree Tuple-based XML FD notion that overcomes the semantic limitations the previous proposals have in expressing constraints with set elements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Capturing XML data redundancy</head><p>While both tuple and path-based approaches are valid ways for defining XML FDs, the tuple-based approach has a clearer semantics and is conceptually similar to the relational FD notion. As such, we follow the tuple-based approach. In Sect. 3.1, we introduce the notion of Generalized Tree Tuple (GTT), which improves upon the tree tuple notion in <ref type="bibr" target="#b0">[1]</ref>. Based on this new tuple notion, we define GTT-Based XML FD and XML Key. In Sect. 3.2, we analyze the general form of XML FDs and show that only a subset of such XML FDs are considered interesting. Finally, in Sect. 3.3, XML data redundancy is defined formally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">GTT-based XML FD</head><p>Definition 5 (Generalized tree tuple) A generalized tree tuple of data tree T = N , P, V, n r , with regard to a particular data element n p (called pivot node), is a tree t T n p = N t , P t , V t , n r , where:</p><p>-N t ⊆ N is the set of nodes, n p ∈ N t ; -P t ⊆ P is the set of parent-child edges; -V t ⊆ V is the set of value assignments; -n r is the same root node in both t T n p and T ; -n ∈ N t if and only if: 1) n is a descendant or ancestor of n p in T , or 2) n is a non-repeatable direct descendant of an ancestor of n p in T ;</p><formula xml:id="formula_4">-(n 1 , n 2 ) ∈ P t if and only if n 1 ∈ N t , n 2 ∈ N t , (n 1 , n 2 ) ∈ P; -(n, s) ∈ V t if and only if n ∈ N t , (n, s) ∈ V .</formula><p>Similar to an original tree tuple, a generalized tree tuple is a data tree projected from the original data tree. However, instead of separating sibling nodes with the same path at all hierarchy levels, a generalized tree tuple has an extra parameter called a pivot node, and the separation is done only for data elements above the pivot node. As a result, ancestor and descendant nodes of the pivot node, as well as all the non-repeatable direct descendant nodes (previously defined in Sect. 2.1) of those ancestor nodes, are preserved in the tuple. Figure <ref type="figure">3b</ref> illustrates one such generalized tree tuple with node 30 as the pivot node. Note that both author nodes of the book are preserved in the tuple, while in Fig. <ref type="figure">3a</ref>, only one is kept. Based on the pivot node, we can categorize all generalized tree tuples into tuple classes:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6 (Tuple class) A tuple class C T</head><p>p of the data tree T is the set of all generalized tree tuples t T n , where path(n) = p. Path p is called the pivot path.</p><p>For example, the generalized tree tuple in Fig. <ref type="figure">3b</ref> belongs to the tuple class C /warehouse/state/store/book . <ref type="foot" target="#foot_1">2</ref> Finally, we introduce the notion of XML FD-based on tuple class:</p><formula xml:id="formula_5">Definition 7 (XML FD) An XML FD is a triple C p , L H S, R H S , written as L H S → R H S w.r.t. C p ,</formula><p>where C p denotes a tuple class, LHS is a set of paths (P li , i = [1, n]) relative to p, and RHS is a single path (P r ) relative to p.</p><p>An XML FD holds on a data tree T (or T satisfies an XML FD) if and only if for any two generalized tree tuples</p><formula xml:id="formula_6">t 1 , t 2 ∈ C p 3 -∃ i ∈ [1, n], t 1 .P li =⊥ or t 2 .P li =⊥, or -If∀ i ∈ [1, n], t 1 .P li = pv t 2 .P li , then t 1 .P r =⊥, t 2 .P r =⊥, t 1 .P r = pv t 2 .P r .</formula><p>A null value, ⊥, results from a path that matches no node in the tuple, and = pv is the path-value equality defined in Definition 4.</p><p>The expression t.P, where t is a tree tuple and P is a path expression, corresponds to (a set of) node(s) that are identified by following the path P starting with the pivot node of the tree t.</p><p>Because generalized tree tuples can be defined at any hierarchy level, with an appropriate tuple class specification, this new XML FD notion can effectively capture constraints involving set elements. For example, <ref type="bibr">Constraints</ref>   <ref type="bibr" target="#b24">[25]</ref>, where they are considered as different from each other and from all other existing elements (i.e., each FD must be strongly satisfied <ref type="bibr" target="#b2">[3]</ref>). We also note that FDs involving set elements only on the RHS can also be captured by incorporating multivalued dependencies (MVD) <ref type="bibr" target="#b7">[8]</ref> into the previous tuple-based approach. However, in general, FDs involving set elements cannot be captured using MVD. For example, FD 4 cannot be expressed using MVD because the set of author values must be considered together.</p><p>When the RHS of an XML FD is ./@key, the LHS then uniquely identifies each tuple in C p because the pivot node (and hence its key) for each tuple is unique. This naturally leads us to the following XML Key notion: Definition 8 (XML key) An XML Key of a data tree T is a pair C p , LHS , where T satisfies the XML FD C p , LHS, ./@key .</p><p>For example C state , {./name} is an XML Key for our running example, so is C store , {./contact/name, ./contact/address} . This new notion of XML Key shares many similarities with the notion proposed by Buneman et al. in <ref type="bibr" target="#b3">[4]</ref>, which contains a target path (which identifies a set of nodes) and a set of key paths (which uniquely identifies each node in the aforementioned set). There are also important differences that we will explore in Sect. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Interesting XML FD</head><p>The range of XML FDs expressible under the new notion are quite broad. However, not all expressible FDs are of interest. For example, some FDs may not be interesting because they are trivial or redundant with other FDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Trivial XML FDs</head><formula xml:id="formula_7">Definition 9 (Trivial XML FD) An XML FD C p , L H S, R H S is trivial if: 1. R H S ∈ L H S, or 2.</formula><p>For any generalized tree tuple in C p , there is at least one path in L H S that matches no data element.</p><p>The definition of trivial XML FDs partly follows the relational semantics, where an FD is trivial if the LHS contains the RHS, and partly follows the strong satisfaction semantics, where an FD is trivial if the LHS always contains at least one null value. Such a situation can arise, as mentioned in <ref type="bibr" target="#b0">[1]</ref>, because of the existence of Choice elements. For example, if contact is a Choice element instead of a Rcd element (i.e., it can have either name or address as its child, but not both) in Fig. <ref type="figure" target="#fig_1">2</ref>, then the XML FD {./contact/name, ./contact/address} → ./@key w.r.t. C store is trivial since no C store tuple will have both LHS nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Essential tuple classes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1 Given a tuple class C p , if p is not a repeatable path (see Sect. 2.1), and there exists a tuple class C p , where p is the longest repeatable path that is a prefix of p, then each tuple in C p corresponds to a distinct tuple in C p .</head><p>Proof Each data element matching p has at most one descendant matching p, and therefore each data element matching p has a distinct ancestor matching p . Following Definitions 5 and 6, data elements matching p and p have one-on-one correspondence to tuples in C p and C p , respectively. Hence, each tuple in C p corresponds to a distinct tuple in C p .</p><p>A direct implication of Theorem 1 is that C p is no longer necessary for the purpose of expressing FDs. Consider Fig. <ref type="figure" target="#fig_5">4</ref>, which illustrates example tuples in both C contact and C store . Each tuple in C contact has a distinct corresponding tuple in C store . A comparison between two tuples in C contact can also be performed on their corresponding tuples in C store , obtaining the same result. Therefore, all warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> name <ref type="bibr" target="#b13">[14]</ref> = Borders address <ref type="bibr" target="#b14">[15]</ref> = Seattle state <ref type="bibr" target="#b9">[10]</ref> name <ref type="bibr" target="#b10">[11]</ref> = WA contact <ref type="bibr" target="#b12">[13]</ref> warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> name <ref type="bibr">[</ref> In contrast, C book (with an example tuple in Fig. <ref type="figure">3</ref>) is an essential tuple class 123</p><p>FDs under C contact can be expressed under C store with the same semantics (tuples in C store without contact do not affect this conclusion because missing elements are treated as unknowns). The reverse, however, is not true. FDs that are expressible under C store may refer to data elements that do not exist in tuples in C contact , and are therefore not expressible under C contact . We call C p the lowest-repeatable-ancestor tuple class of C p . Since only tuple classes with repeatable pivot paths are essential for fully expressing all (non-redundant) XML FDs, we call them essential tuple classes. Intuitively, each essential tuple class corresponds to a distinct set element in the schema.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Structurally redundant XML FDs</head><formula xml:id="formula_8">Theorem 2 Let F D = C p , L H S,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R H S , if none of the paths in LHS and RHS specifies a data element that is a descendant of the pivot node in the tuple, then F D holds on a data tree T if and only if F D = C p , L H S , R H S holds on T , where C p is the lowest-repeatable-ancestor tuple class of C p , and paths in L H S and R H S are equivalent to paths in L H S and R H S (i.e., they correspond to the same absolute paths).</head><p>Proof Each tuple in C p has a corresponding tuple in C p and tuples with sibling pivot nodes in C p correspond to the same tuple in C p . If F D is satisfied, then F D is not violated by two tuples with non-sibling pivot nodes. Because two tuples with sibling pivot nodes never violates F D (they share the same LHS and RHS elements), F D is satisfied. The reverse direction can be proved similarly. This structural redundancy is best illustrated by the following example FD, which is structurally redundant to FD 1 in Sect. Another group of uninteresting FDs are those with an RHS path that does not match any descendant of the tuple pivot node, but with at least one LHS path that does match a descendant of the tuple pivot node. The satisfaction of such FDs either does not indicate redundancies or it indicates redundancies that are almost always indicated by other FDs. In the former case, for example, the satisfaction of {../@key, ./ISBN} → ../contact/name w.r.t. C book cannot cause any redundancy because for any two C book tuples with matching LHS, the RHS will always point to the same data element. In the latter case, for example, if {./ISBN} → ../contact/name w.r.t. C book were satisfied, it would have meant that any two stores selling two books with the same ISBN would have the same name. In most scenarios, this means that all the stores in the database have the same name, which is easily detected through {../../@key} → ./contact/name w.r.t. C store .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">Interesting XML FDs</head><p>Definition 10 (Interesting XML FD) An XML FD = C p , L H S, R H S is interesting if it satisfies the following conditions:</p><p>-RHS / ∈ LHS; -C p is an essential tuple class; -RHS matches to descendant(s) of the pivot node.</p><p>In summary, an interesting XML FD is a non-trivial XML FD with an essential tuple class, and is not structurally redundant to any other XML FD. We note here that Definition 10 focuses on distinguishing interesting XML FDs from uninteresting ones based on the FD specification alone. As a result, the second condition of Definition 9 is not incorporated here: checking for triviality based on the second condition requires either examining the schema or checking the data directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">XML data redundancy</head><p>Definition 11 (XML data redundancy) A data tree T contains a redundancy if and only if T satisfies an interesting XML FD C p , LHS, RHS , but does not satisfy the XML Key C p , LHS .</p><p>Intuitively, if C p , LHS is not a key for T , then there exist two distinct tuples in C p that share the same LHS. Since T satisfies C p , LHS, RHS , the RHS paths of the two tuples must be value equal. However, according to Definitions 5 and 10, the RHS paths match distinct data elements (because they are descendants of two distinct pivot nodes), which are therefore redundantly stored. For example, the data tree in Fig. <ref type="figure" target="#fig_3">1</ref> contains redundancies due to the satisfaction of FDs 1 and 3, where the book ISBN determines the title and author, but cannot uniquely identify an individual book in the set of books.</p><p>Definition 12 (GTT-XNF) An XML schema S is in GTT-XNF given the set of all satisfied interesting XML FDs if and only if for each such XML FD ( C p , L H S, R H S ), C p , L H S is an XML key.</p><p>Intuitively, GTT-XNF disallows any satisfied interesting XML FD that indicates data redundancies. The set of all satisfied interesting XML FDs needs to be either derived from an initial set of FDs specified independent of any database (XML FD inference) or extracted from the databases (XML FD detection). Section 5 describes XML FD detection, and here we briefly discuss XML FD inference.</p><p>The set of all interesting XML FDs for a given tuple class C p can be derived from existing interesting XML FDs for C p using the following inference rules. Those rules are similar to the Armstrong's axioms in the relational case, which are used to compute the closure of relational FDs <ref type="bibr" target="#b1">[2]</ref>. Deriving interesting XML FDs across different tuple classes, however, is more difficult. In general, no such axiom exists because the semantics of each path expression can change when their associated tuple class changes. For example, path /warehouse/state/store/ book/title matches a set of data elements within tuple class C store , but a single data element within tuple class C book . As a result, deriving all interesting XML FDs from an existing set of interesting XML FDs is often very difficult. This is in agreement with the nonaxiomatizability of XML FDs shown in <ref type="bibr" target="#b0">[1]</ref>. Fortunately, XML FD inference is often not necessary since XML FD detection is more practical and fits the casual nature of XML schema design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rule 1 (Reflexivity) L H S</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Comparison with previous key notion</head><p>Before we explore the differences between GTT-XNF and previously proposed normal forms, we analyze the difference between our XML Key notion and the notion proposed by Buneman et al. <ref type="bibr" target="#b3">[4]</ref> first.</p><p>In <ref type="bibr" target="#b3">[4]</ref>, an XML Key is defined as (Q, (Q , S)), where Q is a path specifying a set of data elements that are the roots of data subtrees, on which the key (Q , S) holds. Within the key, Q is a path specifying the set of data elements whose identities are to be compared (target elements), and S is a set of paths specifying the set of data elements whose values Fig. <ref type="bibr" target="#b4">5</ref>  When the paths in Q and Q are all simple paths (i.e., they do not contain XPath step "//", which can potentially match multiple schema elements), an XML Key in <ref type="bibr" target="#b3">[4]</ref> can be transformed into our GTT-based notion in the following way: first, set the tuple class to be C Q ; second, set the LHS to be {S ∪ Q/@key}. For example, the above relative key can be specified as C book , {./ISBN, ../@key} in our notion. Intuitively, the concept of "context" in <ref type="bibr" target="#b3">[4]</ref> is transformed into one of the condition elements in LHS.</p><p>There are two main differences between the two key notions. First, in <ref type="bibr" target="#b3">[4]</ref>, Q can involve an arbitrary path step and therefore specify a heterogeneous set of data elements. For example, consider an alternative schema in Fig. <ref type="figure">5</ref>, Q can be set to /warehouse/state//book and therefore match to book elements under both store and auction. In GTT-based XML Key notion, we only allow simple paths when specifying tuple classes, and therefore cannot express a key that holds for both sets of book elements. While allowing arbitrary paths for tuple classes gives us more powerful semantics, it introduces significant complexities into the specification of XML FDs. This is because a path in LHS that refers to ancestors of the pivot node can now match to a heterogeneous set of data elements as well. Furthermore, the redundancy detection algorithms will become significantly more complex when heterogeneous tree tuples need to be considered. We consider the benefits of this more flexible semantics not worth the significant complexities it introduces.</p><p>Second, the specification of the "context" of relative key is more flexible in GTT-based notion. While in <ref type="bibr" target="#b3">[4]</ref>, Q can only specify a path expression, we can in fact introduce more complex conditions. For example, consider the original example in Figs. <ref type="figure" target="#fig_3">1</ref> and<ref type="figure" target="#fig_1">2</ref>, the key C book , {./ISBN, ../contact/ name} specifies that ISBN is a key for book under all stores with the same name. Such relative notion is difficult, if not impossible, to specify with the definition of <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Comparison with previous normal form notion</head><p>XNF is a normal form introduced by Arenas and Libkin <ref type="bibr" target="#b0">[1]</ref> and our GTT-XNF generalizes XNF by allowing more flexible XML FD notions. As mentioned before, the main difference between the two XML FD notions is that XNF builds a single set of tree tuples by separating data elements of the same schema element at all levels, while GTT-XNF builds multiple sets of tree tuples, and within each set, data elements of the same schema element are only separated if they are not descendants of the pivot nodes.</p><p>Proposition 1 For any given XML FD that is expressible under XNF, it is either expressible under GTT-XNF, or its satisfaction is trivially implied from the satisfaction of an XML FD that is expressible under GTT-XNF.</p><p>Proof We prove the simple case first, where the XML schema contains a single hierarchy. In a "single-hierarchy" schema, every pair of set schema elements are in an ancestordescendant relationship. For example, the schema in Fig. <ref type="figure" target="#fig_1">2</ref> is a single hierarchy schema. It is easy to see that, in this case, the set of tree tuples generated in XNF is exactly the set of generalized tree tuples within the essential tuple class whose pivot path matches the lowest set schema element (e.g., C author ). As a result, all FDs expressible under XNF is expressible under GTT-XNF, although not all such FDs are considered interesting (see Sect. 3.2.4).</p><p>When the schema contains more than one hierarchy, tree tuples generated in XNF do not appear as generalized tree tuples in GTT-XNF. For example, consider the multihierarchy schema in Fig. <ref type="figure">5</ref>, both auction and store are set schema elements and they do not have an ancestordescendant relationship. Each tree tuple generated in XNF will have exactly one store data element and exactly one auction data element. No tuple class, however, in GTT-XNF contains those tree tuples as defined in Definition 5.</p><p>We divide FDs under XNF in this case into two categories. First, we consider single-hierarchy FDs. A single-hierarchy FD is one in which all the path expressions in LHS and RHS only involve set schema elements within a single hierarchy. For example, {/warehouse/state/ store/book/ ISBN}→/warehouse/state/store/ book/title is a single-hierarchy FD involving set schema elements state, store, book, all within a single hierarchy. Like in the simple case, those FDs are expressible in GTT-XNF within the appropriate tuple class (e.g., {./ISBN} → ./ title w.r.t. C /warehouse/state/store/book ).</p><p>Second, we consider FDs that involve set schema elements belong to multiple hierarchies. For example, {/warehouse/state/name,/warehouse/state/ store/ warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> name <ref type="bibr" target="#b13">[14]</ref> = Borders state <ref type="bibr" target="#b9">[10]</ref> name <ref type="bibr" target="#b10">[11]</ref> = WA contact <ref type="bibr" target="#b12">[13]</ref> …</p><formula xml:id="formula_9">auction[32] name[34] = Amazon contact[33]</formula><p>… warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> name <ref type="bibr" target="#b13">[14]</ref> = Borders state <ref type="bibr" target="#b9">[10]</ref> name <ref type="bibr" target="#b10">[11]</ref> = WA contact <ref type="bibr" target="#b12">[13]</ref> …</p><formula xml:id="formula_10">auction[32] name[34] = Amazon contact[33]</formula><p>… warehouse <ref type="bibr" target="#b0">[1]</ref> store <ref type="bibr" target="#b11">[12]</ref> name <ref type="bibr" target="#b13">[14]</ref> = Borders state <ref type="bibr" target="#b9">[10]</ref> name <ref type="bibr" target="#b10">[11]</ref> = WA contact <ref type="bibr" target="#b12">[13]</ref> … auction <ref type="bibr" target="#b21">[22]</ref> name <ref type="bibr" target="#b23">[24]</ref> = Amazon contact <ref type="bibr" target="#b22">[23]</ref> … auction <ref type="bibr" target="#b21">[22]</ref> name <ref type="bibr">[</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 7</head><p>Example flat tuples in the flat representation of the XML data in Fig. <ref type="figure" target="#fig_3">1</ref> (If L H S 1 is empty in the original FD, we set L H S 1 in the new FD to be /@key, meaning the R H S is a constant throughout the entire database).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3 Any data redundancy that can be detected based on the XML FD notion in XNF can be detected based on the XML FD notion in GTT-XNF.</head><p>Proof According to Definition 5.1 in <ref type="bibr" target="#b0">[1]</ref>, the RHS of a satisfied non-trivial FD is redundantly stored if the LHS of the FD does not determine the identity (i.e., @key) of the parent data element of the RHS. If the FD is expressible under both XNF and GTT-XNF, and it is interesting under GTT-XNF, then this definition and our Definition 12 express the same semantics. If the FD is not expressible under XNF, we identify a new FD with the same RHS under GTT-XNF that implies this FD (as discussed in the previous paragraph), and the redundancy of the RHS can then be detected based on this new FD (see Sect. 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Detecting XML data redundancy</head><p>In this section, we show how data redundancies in XML can be efficiently detected through the discovery of satisfied interesting XML FDs and Keys. Based on Definition 11, we design DiscoverXFD, an algorithm to discover interesting XML FDs with non-key LHSs, and several related algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">XML data representation</head><p>Flat Representation. The XML FD notion proposed in <ref type="bibr" target="#b0">[1]</ref> suggests a natural way of XML FD discovery: the original XML data tree can be represented as a single relational table, and existing relational FD discovery algorithms can be directly applied. As shown in Fig. <ref type="figure">7</ref>, the flat representation converts the XML data into a single relation of flat tuples, where each attribute in the relation corresponds to a distinct schema element and each tuple is generated by selecting one data value (or @key) from the data tree for each simple (or complex) element, following the notion of tree tuple in <ref type="bibr" target="#b0">[1]</ref>. For example, the tuple in Fig. <ref type="figure">3a</ref> is represented by the second tuple in Fig. <ref type="figure">7</ref>. There are, however, two major issues with applying existing relational FD discovery algorithms to this flat representation. First, it is not clear how certain interesting XML FDs  (i.e., those involving set elements) can be discovered. For example, those algorithms cannot discover previously mentioned XML FDs like FD 3 and FD 4. Second, relational FD discovery algorithms have exponential complexity in the number of attributes they have to consider. As a result, this implementation does not scale well when the XML schema is complex: the more complex the XML schema is, the more attributes there are in the transformed relational schema. Furthermore, the number of tuples in the single relation will increase multiplicatively if the schema contains multiple set elements that have no ancestor-descendant relationship with each other. For example, if each book had two review elements, the total number of tuples in Fig. <ref type="figure">7</ref> would double. Hierarchical representation. Inspired by the notion of essential tuple class (Sect. 3.2.2), and the concept of nested relation <ref type="bibr" target="#b17">[18]</ref>, a more compact representation of the XML data can be adopted. As shown in Fig. <ref type="figure" target="#fig_8">8</ref>, the original XML data tree can be converted into a set of relations based on the original XML schema, where each relation R p (e.g., R book ) corresponds to an essential tuple class C p (e.g., C book ).</p><p>Attributes in each relation match distinct non-repeatable schema elements, whose longest repeatable prefix path is the pivot path of C p . There are two additional attributes: (1) the @key attribute, which matches to the pivot path itself and serves as the key for the relation (since each generalized tree tuple has a unique pivot node); (2) the parent attribute, which matches to the pivot path of C p 's lowest-repeatableancestor tuple class (see Theorem 1). For example, the parent attribute of R book corresponds to the path /warehouse/ state/store since C store is the lowest-repeatableancestor tuple class of C book . Each tuple (called essential tuples) in the relations corresponds to a partial generalized tree tuple in C p . Any generalized tree tuple of an essential tuple class can be fully reconstructed by joining tuples from multiple relations (on the parent and @key attributes). For example, to generate the generalized tree tuple in Fig. <ref type="figure">3b</ref>, one can join t10 in R state with t12 in R store , then with t30 in R book , then with t32 and t33 in R author . We call R p1 a parent relation of R p2 , and R p2 a child relation of R p1 , if C p1 is the lowest-repeatable-ancestor tuple class of C p2 . For example, R store is a parent relation of R book . We can similarly define ancestor relation and descendant relation.</p><p>Compared with the flat representation, hierarchical representation avoids many redundancies because the common part of different tree tuples is represented only once. For example, title and price about a single book is stored once (in R book ) throughout the entire database, instead of once for each author as in Fig. <ref type="figure">7</ref>. Therefore, each individual relation in Fig. <ref type="figure" target="#fig_8">8</ref> is considerably smaller than the single relation in Fig. <ref type="figure">7</ref> in terms of both the number of tuples it has and the number of attributes it maintains. Interesting XML FDs, whose LHS and RHS paths are in the same relation (e.g., FD 1 in Sect. 3.1), can be discovered efficiently by applying existing relational FD discovery algorithms to individual relations in isolation. The problem, however, is that not all interesting XML FDs contain only LHS or RHS paths within the same relation. For example, all the other three FDs (FD 2-4) in Sect. 3.1 contain paths that appear in multiple relations. We call XML FDs/Keys that involve a single relation intra-relation FDs/Keys, and those that involve multiple relations inter-relation FDs/Keys. The challenge is how to efficiently discover interesting inter-relation XML FDs/Keys. In the rest of the section, we present algorithms for discovering inter-relation FDs (Sect. 5.3) and FDs involving set elements (Sect. 5.4) based on the concepts of partition target and set partition. Section 5.5 analyzes the complexities of those algorithms. We first briefly describe how relational algorithms are applied to discover intra-relation FDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Discovering intra-relation FDs</head><p>The algorithm for discovering intra-relation FDs is adopt-ed from existing partition-based algorithms, e.g., TANE <ref type="bibr" target="#b10">[11]</ref>, Dep-Miner <ref type="bibr" target="#b14">[15]</ref>, and FUN <ref type="bibr" target="#b18">[19]</ref>. There are two main data structures: attribute partition and attribute set lattice. Attribute partition: An attribute partition of an attribute set X ( X ) is a set of partition groups, where each group contains all tuples sharing the same values at X . For example, in R book , {ISBN,price} = {{t20}, {t30,t50}, {t80}}. 4,5 We say that X is a refinement of Y ( X → Y ) if whenever two tuples are in the same group in X , they are in the same group in Y , which leads to the following:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1 A given intra-relation FD: L H S → R H S w.r.t. C p holds if and only if L H S → R H S in R p .</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2 A given intra-relation FD: L H S → R H S w.r.t. C p holds if and only if L H S∪R H S = L H S in R p .</head><p>Lemma 1 is straightforward and Lemma 2 is true because</p><formula xml:id="formula_11">X →</formula><p>Y if and only if X ∪Y = X . Intuitively, Lemmas 1 and 2 provide a more efficient way of determining the satisfaction of a given intra-relation FD.</p><p>Attribute set lattice. An attribute set lattice (in short, lattice) of relation R p represents all intra-relation FDs in R p (except those involving @key and parent). As shown in Fig. <ref type="figure" target="#fig_9">9</ref>, each node in the lattice corresponds to an attribute set, and an edge goes from node X to node Y if Y contains X and has exactly one more attribute than X . Each edge, in fact, corresponds to an intra-relation FD: let Y = X ∪ {A}, edge (X, Y ) corresponds to the intra-relation FD:</p><formula xml:id="formula_12">X → A w.r.t. C p .</formula><p>The algorithm DiscoverFD (shown in Fig. <ref type="figure" target="#fig_3">10</ref>) aims to discover all intra-relation FDs that are not implied by other intra-relation FDs (i.e., minimal FDs). It traverses the lattice and discovers keys and satisfied minimal FDs by constructing and comparing the attribute partitions. The lattice is simulated with queue Q, which produces the nodes from Fig. <ref type="figure" target="#fig_3">10</ref> Algorithm DiscoverFD the lattice in level-order. For each node visited, the algorithm checks: (1) the associated partition to see if the attribute set is a Key. An attribute set is a Key if all groups in its partition contain exactly one tuple (line 11); (2) the set of associated edges to detect satisfied FDs. An FD corresponding to edge (X, X A) is satisfied if X = X A (lines <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>. The algorithm also produces new partitions by combining input partitions of smaller attribute sets (lines 9-10, see <ref type="bibr" target="#b18">[19]</ref>).</p><p>Since the objective is to discover minimal FDs only, the algorithm adopts several optimization rules to remove certain nodes and edges from the lattice, which also improves performance because constructing and comparing partitions is costly. Assume that X, Y are two possibly empty attributes sets, A, B are two single attributes, A, B / ∈ X , A, B / ∈ Y , and X ∩ Y = ∅, the rules are: ( <ref type="formula">1</ref></p><formula xml:id="formula_13">) Edge (XY, XY A) is removed if edge (X, X A) corresponds to a satisfied FD (line 23), because if X → A w.r.t. C p holds, then X ∪ Y → A w.r.t. C p is implied; (2) Edge (XY A, XY AB) is removed if edge (X, X A) corresponds to a satisfied FD (line 24). This is because if X → A w.r.t. C p holds, then X ∪ Y ∪ {A} → B w.r.t. C p is implied by X ∪Y → B w.r.t.</formula><p>C p and thus it would not be minimal. For example, in Fig. <ref type="figure" target="#fig_9">9a</ref>, after visiting edge (I, I T ) and detecting {ISBN} → ./title w.r.t. C p is satisfied, edge (I P, I T P) is removed by the first rule, while edge (I T, I T P) is removed by the second rule; (3) If X is detected as an XML Key, the algorithm removes all nodes XY from the lattice (lines 11, 18). For example, in Fig. <ref type="figure" target="#fig_9">9b</ref>, nodes C N , C A, and C N A are removed because C is an XML Key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Discovering inter-relation FDs</head><p>The number of all possible inter-relation FDs is usually significantly larger than the number of all possible intra-relation FDs. Fortunately, the number of minimal inter-relation FDs is limited as Lemma 3 shows:</p><formula xml:id="formula_14">Lemma 3 Let f d 0 = L H S → R H S w.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>r.t. C p be an interrelation FD. For a given relation R p , where R p = R p or R p is an ancestor relation of R p (R p is the relation corresponding to C p ), let L H S ⊂ L H S be the set of paths corresponding to attributes in R p and descendant relations of R p . We have: (1)</head><formula xml:id="formula_15">If f d 1 = L H S ∪{ p /parent} → R H S w.r.t. C p does not hold, then f d 0 cannot be satisfied; (2) If FD f d 2 = L H S → R H S w.r.t. C p holds, then f d 0 is implied by f d 2 .</formula><p>First, if an FD does not even hold for tuples with the same parent in a relation, any inter-relation FD that is generated by extending its LHS with attributes from ancestor relations cannot hold either. This is true because no ancestor attribute set can distinguish tuples with the same parent in the current relation. For example, {./title} → ./price w.r.t. C book does not hold for tuples t20 and t30, which share the same parent t12. No matter what attributes from R store and R state are added to the LHS, t20 and t30 will always violate the resulting FD. Second, if an FD is already satisfied, extending its LHS with ancestor attributes produces only implied inter-relation FDs. Therefore, any minimal inter-relation FD is built upon an intra-relation FD that is satisfied under individual parents but not throughout the entire relation (Fig. <ref type="figure" target="#fig_3">11</ref>).</p><p>Algorithm DiscoverXFD is designed based on the above lemmas. It treats the entire collection of relations as a tree with edges corresponding to their parent/child relationships. It proceeds from leaf level to top level relations (lines 5-6: children relations are visited before the parent relation). At each relation, the algorithm accomplishes two things by employing the data structure partition target (shown in Fig. <ref type="figure" target="#fig_3">12</ref>): First, it detects any intra-relation FD/Key that is satisfied under individual parents but not the entire relation. Those FDs/Keys will become candidate partial FDs/Keys. Second, it detects any attribute set in the relation that can form a satisfied inter-relation FD/Key with any candidate partial FD/Key from its descendant relations. A partition target, which is associated with a candidate partial FD and a candidate partial Key (the FD's LHS), contains two sets of inequalities: one corresponds to the FD satisfaction condition (FDTarget) while the other corresponds to the Key satisfaction condition (KeyTarget). The inequalities are constructed from partitions (Function createPT in Fig. <ref type="figure" target="#fig_3">12</ref>) and updated as Fig. <ref type="figure" target="#fig_3">11</ref> Algorithm DiscoverXFD the algorithm moves up the hierarchies (Function updatePT in Fig. <ref type="figure" target="#fig_3">12</ref>).</p><p>The details of the algorithm are shown in Figs. <ref type="figure" target="#fig_3">11</ref> and<ref type="figure" target="#fig_3">12</ref>. We illustrate how it works through a simple example: the discovery of FD 2 {../contact/name, ./ISBN} → ./price w.r.t. C book on data in Fig. <ref type="figure" target="#fig_8">8</ref>. When visiting Fig. <ref type="bibr" target="#b11">12</ref> Utility functions R book , the algorithm detects that {I SB N} is not the same as {I SB N, price} (see Fig. <ref type="figure" target="#fig_9">9a</ref>), which means that {./ISBN} → ./price w.r.t. C book is not satisfied. In fact, for this FD to be part of some inter-relation FD, two inequalities must be satisfied, namely t30 =t80 and t50 =t80. Because these inequalities will have to be satisfied in the parent relation, tuples in them are converted into their parent tuples, resulting in t12 =t72 and t42 =t72. Often, two tuples in the same inequality are converted into the same parent tuple: the inequality can never be satisfied and the FD is not considered as a candidate partial FD. In this case, however, both inequalities can potentially be satisfied (i.e., the FD holds for tuples sharing the same parent), therefore, the FD is regarded as a candidate partial FD. Furthermore, for the LHS of a potential inter-relation FD to be a Key, the inequality t30 =t50 must also be satisfied, which converts into t12 =t42. As a result, a partition target corresponding to {./ISBN} → ./price w.r.t. C book is created, with its FDTarget being {t12 =t72, t42 =t72} and KeyTarget being {t12 =t42}. The algorithm then visits R store and examines its attribute partitions. In particular, in contact/name (see Fig. <ref type="figure" target="#fig_9">9b</ref>), t72 is separated from t12 and t42, which means that the FDTarget is satisfied by the partition. On the other hand, t12 and t42 remain in the same group in contact/name , which means that the KeyTarget is not satisfied. As a result, {../contact/ name, ./ISBN} → ./price w.r.t. C book is reported as an inter-relation FD.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Handling set elements</head><p>Finally, to discover FDs involving set elements, like FD 3: {./ISBN} → ./author w.r.t. R book , we generate set partitions, which separate tuples according to those set attributes. We explain Algorithm CreateSetPartition (Fig. <ref type="figure" target="#fig_3">13</ref>) through a simple example based on the data in Fig. <ref type="figure" target="#fig_8">8</ref>. Consider attribute author in R author , author author = {{t22}, {t32,t52,t82}, {t33,t53,t83}}. The initial book author is set as {{t20, t30, t50,t80}} (line 1). The first group in author author is converted into {t20} (line 3), and since there is only one tuple, no group division is needed (line 4). Applying {t20} to book author (lines 5-6) results in a refined book author = {{t20}, {t30,t50,t80}}. Going through the next two groups in author author will not further refine book author . In a similar way, book author can be further turned into store author = {{t12}, {t42, t72}}. Each generated set partition, in fact, groups the tuples in the parent relation in the same way as an attribute partition, and can therefore be directly used in both discovery algorithms to detect satisfied FDs involving set elements. For example, book author is added to the attribute set lattice of R book , and FD 3 and FD 4 can be discovered just like any other interesting FDs.</p><p>It is easy to see that, in the worst case, a top-level relation will have to deal with a large number of set partitions coming from its descendant relations. In practice, however, this is less of a concern for the following two reasons: (1) most of the set partitions quickly become key partitions (the higher the partition moves, the more likely it becomes a key partition), where each group in the partition contains only one tuple. As discussed in Sect. 5.2, such partitions are optimized and have little effect on the performance; (2) higher level relations Algorithm CreateSetPartition Input: Π child A , the partition on attribute A in Rchild ID, the index maps @key to parent in Rchild 1. Init. Π parent A as a single group of all distinct parents in Rchild 2. foreach g∈Π child A : 3. foreach t∈g: t=ID.get(t) // convert @key to parent 4. divide g into a set G of duplicates eliminated groups, such that t1, t2 ∈ same group cnt(t1) = cnt(t2) in g 5. foreach g ∈Π parent A , g ∈G: 6.</p><p>divide g into g 1 g 2 , where g 1 =g and g 2 =g -g Output: Π parent A , the set partition on A in Rparent if if and only Fig. <ref type="bibr" target="#b12">13</ref> Algorithm CreateSetPartition contain significantly fewer tuples and are therefore less impacted by the increasing number of set partitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Complexity analysis and discussion</head><p>We briefly analyze the complexities of algorithms Discover-FD and DiscoverXFD. For DiscoverFD, the number of edges in the attribute set lattice and the number of partitions at each relation R are bounded by O(R k 2 R k ) and O(2 R k ), respectively, where R k is the number of attributes in R. For each edge visited in the lattice, a scan of the tuples in the relation is required. As a result, DiscoverFD has a worst case time complexity of O(R n R k 2 R k ), where R n is the number of tuples in R. For DiscoverXFD, at each relation R, partition targets and set partitions from its descendant relations must be examined for each partition of R. Since the number of such partition targets and set partitions can be in the worst case O(R d 2 R d ) (where R d is the total number of attributes of all descendant relations of R), the worst case complexity for DiscoverXFD at each relation is</p><formula xml:id="formula_16">O(R n R k 2 R k + R n R d 2 R k +R d ). This is in contrast with the complexity of O(R n (R k + R d )2 R k +R d ),</formula><p>where R n is the number of tuples in the flat representation, if we adopt the flat representation and use relational FD discovery algorithms. While the worst case complexity is only slightly better for DiscoverXFD and still exponential, the pruning strategies employed by Dis-coverXFD can often reduce the number of partition targets and set partitions to be examined to near linear (see Sect. 7), reducing the time cost of DiscoverXFD close to that of Dis-coverFD.</p><p>Discussion. First, order can be considered. It simply requires that, for two data nodes to be considered equal, their positions among the siblings (which can be obtained when establishing the hierarchical relations), in addition to their values, must be matched. While this increases the cost of computing partitions, it is also likely to produce more key partitions, which can be pruned away. As a result, we do not expect the impact of considering orders to be significant. We do not consider order in our system because we believe orderunaware redundancy is more meaningful in practice. Second, for XML data stored in native format, our algorithms cannot be applied directly. However, the general pruning principles as shown in Lemma 3 still apply. Finally, We note here that FDs really depend on inherent properties of the world being represented. It is not possible to "prove" that there is an FD based purely on the data. In this sense, any FD discovery algorithm must be viewed as merely suggesting FDs, which hold in the current instance of the database, rather than establishing FDs. Some suggested FDs may turn out to be spurious-artifacts of the current database instance. Where data collections are large and representative, it is unlikely that too many spurious FDs will be suggested. Nonetheless, a final manual verification is often required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Schema normalization</head><p>Given the set of discovered redundancies, our next objective is to eliminate those redundancies from the database. This redundancy elimination process involves three phases. The first phase is schema normalization, where the original schema is refined into a new schema such that all redundancyindicating FDs are eliminated. <ref type="foot" target="#foot_6">6</ref> The second phase is mapping generation, where a schema mapping is established between the original schema and the new schema. The last phase is data transformation, where the original database is transformed into the new format based on the schema mapping. The last two phases are studied extensively in the context of data integration <ref type="bibr" target="#b21">[22]</ref>, and therefore we only focus on schema normalization in this paper. In Sect. 6.1, we describe how individual redundancy-indicating XML FDs can be eliminated by modifying the schema. In Sect. 6.2, we present the overall algorithm for schema normalization, which uses a bottom-up strategy to systematically group and eliminate redundancy-indicating FDs.</p><p>For the rest of this section, we use the XML document and schema in Figs. <ref type="figure" target="#fig_3">1</ref> and<ref type="figure" target="#fig_1">2</ref> as an example, and assume that we have discovered a set of redundancy-indicating FDs that contains the following two FDs, both of which are interesting (Definition 10) and minimal (i.e., not implied by other FDs).</p><p>F To eliminate a global FD (e.g., F 1 ), we create a new schema element containing both its LHS elements (e.g., ISBN) and RHS element (e.g., title), and put this new element under the root. The RHS element is then removed from its original position. Figure <ref type="figure" target="#fig_5">14</ref> illustrates the new schema after eliminating F 1 .</p><p>Creating inclusion constraint. To avoid the loss of associations between P r and paths other than P i (i ∈[1, n]}), an implicit value-based inclusion constraint will now be created on the generalized tree tuples in C p and C e new : Let P i (i ∈ [1, n]}) be the set of paths (relative to e new ) for the schema elements e i (i ∈ <ref type="bibr">[1, n]</ref> to the pivot path of the ancestor tuple class (e.g., /warehouse/state/store). The RHS element is then removed from its original position. By creating the new schema element under the non-root ancestor, fewer elements needs to be copied under the new schema element and the overall schema becomes simpler. Figure <ref type="figure" target="#fig_3">15</ref> illustrates the new schema after eliminating F 2 .</p><p>Just like in the case of eliminating local FDs, after the modification of the schema, we impose a value-based inclusion constraint on tuples in C p and C new , and remove any FD that is affected by the move of P r .</p><p>Special case for Procedure 2. There is a special case for eliminating local FDs, that is when the entire LHS of the FD is a key for some ancestor tuple class. A classic example is the DBLP schema, where the year of an article (tuples in C article ) is determined by the identity (i.e., @key) of the issue containing the article. In this case, instead of creating a new schema element containing a single element year, we can simply move year directly under issue, making the result schema simpler. Note that by not creating a new (set) schema element, we can potentially introduce new redundancy-indicating FDs into . For example, year can be determined by some non-key elements under issue, and therefore still be redundant. This redundancy will then be eliminated when we analyze FDs for C issue .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Normalization algorithm</head><p>Figure <ref type="figure" target="#fig_10">16</ref> illustrates the overall schema normalization algorithm. The bulk of the algorithm is modifying the schema using either Procedures 1 or 2, which are described extensively before. There are several things worth mentioning here. First, we group FDs according to their LHS so that no unnecessary schema element is created. For example, consider our example FDs F 1 and F 3 , both of which have the LHS {./ISBN}. If they are dealt with separately, two new schema element will be created: one contains ISBN and title, the other contains ISBN and author. By grouping these two FDs, only one new schema element needs to be created: one contains ISBN, title, and author. Second, we process FDs according to the number of paths in their LHS as a heuristic strategy to reduce the storage cost. Consider F 1 and F 3 , plus a new FD F 5 = {./title, ./author} → ./ISBN w.r.t. C book . If F 5 is processed first, then the elements title and author, instead of ISBN, will remain under book. Even though there will be no data redundancy, it is intuitively undesirable since title and author are more complex elements being stored at a lower hierarchy (book instead of root). Ordering FDs according to the number of paths in LHS ensures that F 1 and F 3 will be processed before F 5 and therefore only ISBN will remain under book.</p><p>Third, we process FDs according to the hierarchy depth of their tuple class (i.e., in a bottom-up fashion). This is because during the process of FDs for a lower hierarchy tuple class, redundancy-indicating FDs for a higher hierarchy tuple class may be created. Processing FDs in the hierarchical order allows us to deal with each tuple class at most once.</p><p>Finally, the algorithm terminates because each application of Procedures 1 and 2 either removes at least one redundancyindicating FD, or converts one redundancy indicating FD into another one with a tuple class at a higher hierarchy (i.e., the special case for Procedure 2).</p><p>Figure <ref type="figure" target="#fig_3">17</ref> illustrates the final redundancy-free schema after eliminating all three FDs. Notice that eliminating F 1 and F 3 together results in only one new schema element (newbook), and that after the elimination of F 1 and F 3 , F 2 is no longer redundancy indicating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experimental evaluation</head><p>We implemented the redundancy detection algorithm, DiscoverXFD, on top of Berkeley DB <ref type="bibr" target="#b22">[23]</ref> using Java. The main data structures, including attribute partitions, partition  We performed redundancy detection on the datasets and measured three time costs: the loading time (parsing the document and converting it into the hierarchical representation), the partition time (creating partitions of single attributes for all the relations), and the discovery time (the time of actual FD and Key discovery i.e., Algorithm DiscoverXFD). As shown in the Table <ref type="table" target="#tab_10">2</ref>, redundancies in all datasets can be detected in a reasonable amount of time, ranging from 20 s for Mondial to 20 min for DBLP, demonstrating the practicality of the system.</p><p>More importantly, data redundancies were detected in all three datasets, as shown in Table <ref type="table" target="#tab_10">2</ref>. An example redundancyindicating FD in Mondial is shown in Fig. <ref type="figure" target="#fig_11">18</ref>. Here, in C cit y , the name element of province and the country attribute of city together determine the province attribute of city, but they are not an XML Key (e.g., they do not determine the name element of city). As a result, the province attribute of city is stored redundantly: once for each city in the same province. It is also worth noting that, for the PIR dataset, a significant number of discovered redundancy-indicating FDs (17% of all discovered FDs) involve set elements-those FDs can not be Scale Factor We performed this estimation on the PIR dataset and found that intra-relation FDs alone caused 104,507 data elements to be stored redundantly, about 10.4% of total data elements.</p><p>We have proposed modifications to the PIR schema to avoid these redundancies, and communicated this to the owners of the database. 7  We also analyzed the effect of FD grouping (Step 1 in Fig. <ref type="figure" target="#fig_10">16</ref>) of the SchemaNormalization algorithm by normalizing the PIR schema (given the set of discovered redundancy-indicating FDs) with or without FD grouping. While a total of 63 new schema elements are produced if we do not adopt FD grouping, only 23 new schema elements are produced when it is adopted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Benchmark dataset</head><p>We further evaluated DiscoverXFD on the XMark dataset to examine its scalability. The XMark schema shares similar schema characteristics with the nested real life datasets: 327 schema elements with a maximum depth of 9; 117 tuple classes with a maximum depth of 5; average and maximum number of attributes per relation at 2.8 and 17, respectively. The size of each dataset is linearly correlated to the scale factor used for its generation. At scale factor 1, the dataset contains about 2 million data elements and has a document size of 100 MB. As shown in Fig. <ref type="figure" target="#fig_12">19</ref>, the total time for redundancy detection (line Total) increases linearly with the scale factor, indicating that the system scales well with increasing data 7 PIR has been replaced by the new UniProt database, whose design has taken into consideration our suggestions. A rough comparison between the two schemas show that an estimated 20% of the discovered FDs pointing to unintended redundancies, 30% are intended redundencies, the rest of FDs are no longer applicable in the new schema. Comparison with relational algorithms. As mentioned in Sect. 5.1, XML FDs can also be discovered by applying relational algorithms on the flat representation of the XML data. While such an alternative implementation is limited due to its inability to discover FDs involving set elements, we nevertheless want to compare our system against it. Towards this objective, we implemented an alternative redundancy detection system, which converts XML data into flat representation and adopts the algorithm FUN <ref type="bibr" target="#b18">[19]</ref>  8 for FD and Key discovery (we made minor adjustments to avoid recording un-interesting FDs). We performed redundancy detection with this system on all three real-life datasets. Not surprisingly, it did not finish detection (within 24 h) even on the Mondial dataset. In fact, redundancy detection using this system took hours for the smallest XMark dataset (scale factor 0), which contains only 331 elements. As a result, we created three more datasets (S1-S3) based on the smallest XMark dataset and compared the performance of our system against this alternative system on these. The results are shown in Table <ref type="table" target="#tab_11">3</ref>. As expected, while the alternative system performs well on very small datasets, it degrades rapidly as the size increases and performs much worse than our DiscoverXFD system for larger datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related work</head><p>Designing XML Keys and XML FDs were first addressed in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b12">13]</ref>, respectively. Formal definitions of XML FDs and Normal Forms were later proposed in <ref type="bibr" target="#b0">[1]</ref> and <ref type="bibr" target="#b24">[25]</ref>, providing 8 FUN is chosen because it improves upon previous algorithms and is the fastest. significant improvements over relational FDs in capturing XML data redundancies. However, as discussed at length in Sect. 4, those proposals are limited in their ability to capture redundancies involving set elements and many do not utilize the formal tuple-based semantics. The redundancy detection problem, one of our main contributions, is not addressed in any of the above studies. Integrity constraints (including keys) in XML were studied extensively in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>, which proposed several notions (e.g., element-value equality) that are used here and in many other studies. However, they do not adopt the tree tuple notion that we and <ref type="bibr" target="#b0">[1]</ref> adopt here.</p><p>The hierarchical representation of XML data shares many similarities with nested relations <ref type="bibr" target="#b2">[3]</ref>. In <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b19">20]</ref>, data redundancies in nested relations are characterized using relational FDs and MVDs. However, as mentioned in Sect. 3.1, MVDs cannot fully capture XML redundancies involving set elements on both sides of the dependency, and a more comprehensive notion of XML FD is therefore necessary.</p><p>Several algorithms <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b18">19]</ref> have been proposed for relational FD discovery. The intra-relation FD discovery algorithm is an extension of these algorithms, and their notion of partition is used extensively in the inter-relation FD discovery algorithm. Several recent studies have also focused on validating known XML Keys and FDs <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b23">24]</ref>, which is a considerably simpler problem than our problem of redundancy detection through the discovery of FDs and Keys.</p><p>Designing normalization algorithms for schema refinement is an important problem and was studied in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b24">25]</ref>. We follow their directions in this paper and design normalization algorithms that are based on the our proposed normal form GTT-XNF.</p><p>In many real world scenarios, FDs are not always satisfied-an FD may hold a large subset of the data, but not on a small number of tuples. Several studies have looked at this, most recently in <ref type="bibr" target="#b11">[12]</ref>. While we do not consider this in the current study, data structures similar to those in <ref type="bibr" target="#b11">[12]</ref> can potentially be adopted for the discovery of approximate XML FDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>XML data redundancies have a richer semantics than redundancies in the relational context. We proposed generalized tree tuple-based XML FD and Key notions that improve upon previous proposals and capture a comprehensive set of XML data redundancies, including in particular redundancies involving set elements. Based on those new notions, we proposed a new XML normal form GTT-XNF. We designed and implemented DiscoverXFD, the first XML data redundancy detection system through the discovery of XML FDs and Keys. We further designed a normalization algorithm that converts any XML schema into one in GTT-XNF given the set of detected redundancy-indicating XML FDs. Experimental evaluation demonstrates that the system is practical in detecting redundancies in real datasets and scales well with increasing dataset size.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2</head><label>2</label><figDesc>Fig.2Example schema (S warehouse ) for the example XML document in Fig.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1</head><label>1</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4</head><label>4</label><figDesc>Fig.<ref type="bibr" target="#b3">4</ref> Example tuples in non-essential tuple class C contact (a) and C store (b). In contrast, C book (with an example tuple in Fig.3) is an essential tuple class</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>3 . 1 :</head><label>31</label><figDesc>FD 5 {../ISBN} → ../title w.r.t. C author For the purpose of verifying F D, tuples in C p with sibling pivot nodes are redundant to each other. Such redundancies are naturally eliminated in F D . As a result, we consider FDs like FD 5 as structurally redundant and therefore uninteresting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6</head><label>6</label><figDesc>Fig.<ref type="bibr" target="#b5">6</ref> Tuples under XNF with multiple hierarchies. (a) The partial data tree conform to the schema in Fig.5. (B, C) Two of the tree tuples generated from the data tree that contain the same store</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8</head><label>8</label><figDesc>Fig.<ref type="bibr" target="#b7">8</ref> Example essential tuples in the hierarchical representation of the XML data in Fig.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9</head><label>9</label><figDesc>Fig.<ref type="bibr" target="#b8">9</ref> Example attribute set lattices for R book (a) and R store (b). I, T, P, C, N, A stand for ISBN, title, price, contact, contact/name, contact/address, respectively. Shown along selected nodes are the attribute partitions. Bold edges correspond to satisfied FDs. Dashed nodes and edges are those not visited in algorithms DiscoverFD and DiscoverXFD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 16</head><label>16</label><figDesc>Fig. 16 Algorithm SchemaNormalization</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 18</head><label>18</label><figDesc>Fig. 18 Partial schema of the Mondial dataset and an example redundancy-indicating inter-relation FD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 19</head><label>19</label><figDesc>Fig.<ref type="bibr" target="#b18">19</ref> Cost of redundancy detection on XMark datasets with increasing scale factors</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>3 and 4 can now be expressed as: FD 3: {./ISBN} → ./author w.r.t. C book FD 4: {./author, ./title} → ./ISBN w.r.t. C book Note that their semantics are exactly as expected. And the other two example constraints (Constraints 1 and 2) can be expressed as: FD 1: {./ISBN} → ./title w.r.t. C book FD 2: {../contact/name, ./ISBN} → ./price w.r.t. C book . We treat missing elements (regarded as being null values) in the same way as in</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>→ P 1 w.r.t. C p is satisfied if P 1 ⊆ L H S. L H S → P 1 w.r.t. C p ⇒ {L H S, P 2 } → P 1 w.r.t. C p .</figDesc><table><row><cell>Rule 2 (Augmentation)</cell></row></table><note><p>Rule 3 (Transitivity) L H S → P 1 w.r.t. C p ∧. . .∧ L H S → P n w.r.t. C p ∧ {P 1 , . . . , P n } → P w.r.t. C p ⇒ L H S → P w.r.t. C p .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>The reason is that according to Definitions 3.1 and 3.6 in<ref type="bibr" target="#b0">[1]</ref>, each store under a state will pair with every auction under the same state (and vice versa), and there is one tuple for each such pair. Consider the set of such tuples with the same store, but different auctions as shown in Fig.6, the satisfaction of the above FD means those auctions all have the same name because they are all determined by the name of the same store. As a result, the satisfaction of this FD is trivially implied by the following FD under GTT-XNF: {../name} → ./contact/name w.r.t. C auction .Let the multi-hierarchy FD expressible under XNF be {L H S 1 ∪ L H S 2 } → R H S, where L H S 1 contains paths within the same hierarchy as R H S and L H S 2 contains all other paths in different hierarchies. Let FD {L H S 1 } → R H S w.r.t. C p , where p is the longest repeatable path that is a prefix of R H S, be an FD under GTT-XNF. The satisfaction of the former is always implied by the satisfaction of the latter.</figDesc><table><row><cell cols="8">warehouse state name store contact contact/name contact/address book</cell><cell>ISBN</cell><cell>author</cell><cell>title</cell><cell>price</cell></row><row><cell>1</cell><cell>10</cell><cell>WA</cell><cell>12</cell><cell>13</cell><cell>Borders</cell><cell>Seattle</cell><cell>20</cell><cell>00...269</cell><cell>Post</cell><cell cols="2">DBMS 126.99</cell></row><row><cell>1</cell><cell>10</cell><cell>WA</cell><cell>12</cell><cell>13</cell><cell>Borders</cell><cell>Seattle</cell><cell>30</cell><cell cols="3">00...638 Rama... DBMS</cell><cell>79.90</cell></row><row><cell>1</cell><cell>10</cell><cell>WA</cell><cell>12</cell><cell>13</cell><cell>Borders</cell><cell>Seattle</cell><cell>30</cell><cell>00...638</cell><cell cols="2">Gehrke DBMS</cell><cell>79.90</cell></row><row><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell><cell>...</cell></row></table><note><p>contact/name}→/warehouse/state/ auction/ contact/name. While we may be tempted to express this FD within tuple class C state since only tuples within C state contain both store and auction data elements, we in fact can not. Both ./store/contact/ name and ./auction/contact/name have set semantics (i.e., they match a set of data elements) for tuples within C state , which is not the semantics of the FD under XNF because XNF, by definition, does not allow set semantics. However, the satisfaction of this FD, under XNF, can only mean one thing: names of all the auctions under the same state are the same.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>1 = {./ISBN} → ./title w.r.t. C book ; F 2 = {../../name,../contact/name,./ISBN} → ./price w.r.t. C book ; F 3 = {./ISBN} → ./author w.r.t. C book ; We further assume that C store , {../name,./ contact/name} is an XML Key in our example. 6.1 Eliminating redundancy-indicating FDs As defined in Definition 11, if an XML FD, C p , L H S, R H S , holds on a database, while the XML Key C p , L H S does not, the data elements that are represented by RHS are redundantly stored. To eliminate such an FD, we move the schema element corresponding to RHS into an appropriate new schema location, such that those data elements are no longer redundantly stored. We first classify those FDs into two categories: local and global. , is local if there exists L H S ⊂ L H S such that C p , L H S is an XML Key, where C p is an ancestor tuple class of C p (i.e., p is a prefix of p). Otherwise, the FD is global. The distinction between global and local FDs can be illustrated through some examples. Consider F 1 , which is a global FD because no subset of its LHS is a key for any tuple class above C book . Intuitively, this FD means any two books, regardless whether they are under the same store or state, if they have the same ISBN, then they will have the same title. Consider F 2 , which is a local FD because {../name, ./contact/name} is a key for C store . Because the state name and store name uniquely identifies each store, this FD intuitively means any two books, if they have the same ISBN, they will have the same price, as long as they are under the same store. In other words, unlike global FDs, local FDs are satisfied within a single subtree, instead of across multiple subtrees. Because of this distinction, we adopt different procedures for eliminating global and local FDs, with the goal of minimal changes to the original schema. Both procedures de-couple the RHS schema element of the redundancy-indicating FD from the other schema elements within the tuple class, and create a new schema element that contains the de-coupled RHS schema element. The differences are where is the new schema element created and what are the type of this new schema element. Procedure 1 (Eliminate global FD) Let F = {P 1 , . . . , P n } → P r w.r.t. C p be a redundancy-indicating global FD on Schema S root ; {e i | i ∈ [1, n]} and {τ i | i ∈ [1, n]} be the sets of schema element labels and types, respectively, associated with each P i ; e r and τ r be the schema element label and type, respectively, associated with P r ; τ parent be the schema element type of the parent element of P r ; τ root = Rcd[e 1 : τ 1 , . . . , e m : τ m ] be the element type of the root element. We eliminate the redundancy by the following procedure: -Create a new schema element with label e new and type τ new = SetOf Rcd[e 1 : τ 1 , . . . , e n : τ n , e r : τ r ] -Set τ root = Rcd[e 1 : τ 1 , . . . , e m : τ m , e new : τ new ] -Remove (e r : τ r ) from τ parent .</figDesc><table><row><cell>Definition 13 (Local/global XML FD) An XML FD, C p ,</cell></row><row><cell>L H S, R H S</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>}) under e new ; for each tuple t ∈ C p , there exists a tuple t ∈ C e new , such that t.P i = nv t .P i This constraint is very much like the inclusion constraints that are adopted in relational data model.Adjusting FD. We first remove F from . The semantics of F is now captured by the new FD: {P 1 , . . . , P n } → P r w.r.t. C new . However, since {P 1 , . . . , P n } is a key for C new , this new FD is not redundancy indicating and therefore does not need to be added to . We then remove all FDs in that are affected by the move of P r . For example, if the FD F 4 = {./author, ./title} → ./ISBN w.r.t. C book is in , it will be removed because it is no longer valid. It is safe to do so because ISBN is no longer redundant and the semantics of this FD is now captured through the above-mentioned inclusion constraint. Procedure 2 (Eliminate local FD) Let F = {P 1 , . . . , P k-1 , P k , . . . , P n } → P r w.r.t. C p be a redundancy indicating local FD on Schema S root , where {P 1 , . . . , P k-1 } is the key for C p , C p is an ancestor tuple class of C p , and there is no other subset L of {P i | i ∈ [1, n]} such that L is a key for C p , C p is an ancestor tuple class of C p and a descendant tuple class of C p (i.e., C p is the lowest tuple class that can be identified ); Furthermore, let {e i| i ∈ [k, n]} and {τ i | i ∈ [k, n]} be the sets of schema element labels and types, respectively, associated with each P i ; e r and τ r be the schema element label and type, respectively, associated with P r ; τ parent be the schema element type of the parent element of P r ; τ p = Rcd[e 1 : τ 1 , . . . , e m : τ m ] be the element type of the schema element corresponding to the pivot path of C p . We eliminate the redundancy by the following procedure: -Create a new schema element with label e new and type τ new = SetOf Rcd[e k : τ k , . . . , e n : τ n , e r : τ r ] -Set τ p = Rcd[e 1 : τ 1 , . . . , e m : τ m , e new : τ new ] -Remove (e r : τ r ) from τ parent .To eliminate a local FD (e.g., F 2 ), we create a new schema element containing the subset of its LHS elements (e.g., ISBN) that are not part of the key for the ancestor tuple class (e.g., C store ) and RHS element (e.g., title), and put this new element under the schema element corresponding</figDesc><table><row><cell>Fig. 14 Resulting schema after eliminating F 1 for all i ∈ [1, n]. Fig. 15 Resulting schema warehouse: Rcd state: SetOf Rcd name: str store: SetOf Rcd contact: Rcd name: str address: str book: SetOf Rcd ISBN: str author: SetOf str price: str new-book: SetOf Rcd ISBN: str title: str after eliminating F 2</cell><cell>warehouse: Rcd state: SetOf Rcd name: str store: SetOf Rcd contact: Rcd name: str address: str book: SetOf Rcd ISBN: str title: str author: SetOf str new-book: SetOf Rcd ISBN: str price: str</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 1</head><label>1</label><figDesc>Statistics of real life datasets</figDesc><table><row><cell>Fig. 17 Resulting schema</cell><cell></cell><cell cols="2">warehouse: Rcd</cell></row><row><cell>after eliminating all three FDs</cell><cell></cell><cell cols="2">state: SetOf Rcd</cell></row><row><cell></cell><cell></cell><cell>name: str</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">store: SetOf Rcd</cell></row><row><cell></cell><cell></cell><cell cols="2">contact: Rcd</cell></row><row><cell></cell><cell></cell><cell cols="2">name: str</cell></row><row><cell></cell><cell></cell><cell cols="2">address: str</cell></row><row><cell></cell><cell></cell><cell cols="2">book: SetOf Rcd</cell></row><row><cell></cell><cell></cell><cell cols="2">ISBN: str</cell></row><row><cell></cell><cell></cell><cell cols="2">price: str</cell></row><row><cell></cell><cell></cell><cell cols="2">new-book: SetOf Rcd</cell></row><row><cell></cell><cell></cell><cell>ISBN: str</cell><cell></cell></row><row><cell></cell><cell></cell><cell>title: str</cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">author: SetOf str</cell></row><row><cell cols="4">targets, etc., are stored on disk and fetched when necessary,</cell></row><row><cell cols="4">and only a single attribute partition of a single relation is</cell></row><row><cell cols="4">required to fit in memory (for efficient generation of new par-</cell></row><row><cell cols="4">titions). This results in a small memory footprint. All exper-</cell></row><row><cell cols="4">iments were conducted on a PC with a 2.0-GHz P4 CPU and</cell></row><row><cell cols="4">1 GB RAM, running Windows XP (SP2) and JRE 1.4.2. The</cell></row><row><cell cols="4">JVM memory was 512 MB and the Berkeley DB cache size</cell></row><row><cell cols="4">was 128 MB. For timing measurements, each experiment was</cell></row><row><cell cols="4">run three times and the average reading was recorded.</cell></row><row><cell>7.1 Real life datasets</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">We first evaluated DiscoverXFD on three available real life</cell></row><row><cell cols="4">datasets to examine its practicality and to verify the exis-</cell></row><row><cell cols="4">tence of data redundancies in real world datasets. The data-</cell></row><row><cell cols="4">sets include: the Mondial [17] geography dataset; the human</cell></row><row><cell cols="4">subset of PIR protein information dataset from protein infor-</cell></row><row><cell cols="4">mation resource [21]; the DBLP [14] bibliography dataset.</cell></row><row><cell cols="4">The statistics of each dataset are shown in Table 1: the schema</cell></row><row><cell cols="4">and tuple class depth (the latter is usually smaller because of</cell></row><row><cell cols="4">the skipping of non-set schema elements) affect the discov-</cell></row><row><cell cols="4">ery of inter-relation FDs and Keys, and the average and max-</cell></row><row><cell cols="4">imum number of attributes per relation (in the hierarchical</cell></row><row><cell cols="4">representation) affect the discovery of both intra-relation and</cell></row><row><cell cols="4">inter-relation FDs and keys. While Mondial and PIR datasets</cell></row><row><cell cols="4">are similarly nested, the DBLP dataset stands out with a rel-</cell></row><row><cell cols="4">atively flat structure (tuple class depth of 3) and with more</cell></row><row><cell cols="4">complex relations (larger average and maximum number of</cell></row><row><cell></cell><cell>Mondial</cell><cell>PIR</cell><cell>DBLP</cell></row><row><cell>Schema elements</cell><cell>152</cell><cell>114</cell><cell>331</cell></row><row><cell>Max. schema depth</cell><cell>5</cell><cell>7</cell><cell>4</cell></row><row><cell>Tuple classes</cell><cell>31</cell><cell>31</cell><cell>73</cell></row><row><cell>Max. tuple class depth</cell><cell>5</cell><cell>5</cell><cell>3</cell></row><row><cell>Avg. attributes per relation</cell><cell>4.9</cell><cell>3 .7</cell><cell>4 .5</cell></row><row><cell>Max. attributes per relation</cell><cell>17</cell><cell>15</cell><cell>27</cell></row><row><cell>Data elements (in 000s)</cell><cell>48.7</cell><cell>1 , 001.1</cell><cell>3, 736.4</cell></row><row><cell>Document size (in MB)</cell><cell>1.2</cell><cell>3 1 .8</cell><cell>133.8</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 2</head><label>2</label><figDesc>Analyzing real life datasets</figDesc><table><row><cell></cell><cell>Mondial</cell><cell>PIR</cell><cell>DBLP</cell></row><row><cell>Loading time (seconds)</cell><cell>0.6</cell><cell>18.0</cell><cell>55.9</cell></row><row><cell>Partition time (seconds)</cell><cell>6.0</cell><cell>20.2</cell><cell>79.9</cell></row><row><cell>Discovery time (seconds)</cell><cell>11.1</cell><cell>253.6</cell><cell>1,093.5</cell></row><row><cell>Intra-relation Keys</cell><cell>98</cell><cell>41</cell><cell>205</cell></row><row><cell>Inter-relation Keys</cell><cell>25</cell><cell>6</cell><cell>5</cell></row><row><cell>Intra-relation FDs</cell><cell>21 (0)</cell><cell>73 (12)</cell><cell>313 (16)</cell></row><row><cell>Inter-relation FDs</cell><cell>9 (0)</cell><cell>8 (2)</cell><cell>0 (0)</cell></row><row><cell>Total discovered FDs</cell><cell>30</cell><cell>81</cell><cell>313</cell></row><row><cell cols="4">When counting FDs, only the ones whose LHS is not a key are counted-</cell></row><row><cell cols="4">the numbers of discovered FDs therefore refer to only redundancy</cell></row><row><cell cols="4">indicating FDs. Numbers in parentheses are the number of FDs that</cell></row><row><cell>involve set elements</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Mondial: Rcd</cell><cell></cell><cell></cell></row><row><cell>...</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">province: SetOf Rcd</cell><cell></cell></row><row><cell cols="2">name: str</cell><cell></cell><cell></cell></row><row><cell cols="2">city: SetOf Rcd</cell><cell></cell><cell></cell></row><row><cell></cell><cell>name: str</cell><cell></cell><cell></cell></row><row><cell></cell><cell>@province: str</cell><cell></cell><cell></cell></row><row><cell></cell><cell>@country: str</cell><cell></cell><cell></cell></row><row><cell>...</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>FD: {../name, ./@country} → ./@province w.r.t. Ccity</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 3</head><label>3</label><figDesc>Time cost (seconds) of redundancy detection on small XMark datasets using the alternative relational algorithm implementation and DiscoverXFD To investigate whether detection of redundancies caused by inter-relation FDs is becoming more significant, we performed the detection for intra-relation FDs only (because inter-relation FDs cannot be discovered without incurring the cost of discovering intra-relation FDs). Again, the cost of detecting intra-relation FDs (Fig.19line intra only) increases linearly to the scale factor and remains between 60-70% of the total (i.e, the cost of detecting redundancy-indicating inter-relation FDs stays about 30-40% of the total), indicating that manipulating partition targets and set partitions is efficient and does not dominate the overall detection process.</figDesc><table><row><cell></cell><cell>S1</cell><cell>S2</cell><cell>S3</cell><cell>XMark (sf = 0)</cell></row><row><cell>Data elements</cell><cell>118</cell><cell>153</cell><cell>192</cell><cell>331</cell></row><row><cell>Rel. algorithm</cell><cell>0.9</cell><cell>6.0</cell><cell>128.2</cell><cell>&gt;10,000</cell></row><row><cell>DiscoverXFD</cell><cell>2.1</cell><cell>2.3</cell><cell>2.5</cell><cell>4.2</cell></row><row><cell>size.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Anecdotal examples include some large, heavily used community resources, such as PIR<ref type="bibr" target="#b20">[21]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>While the definitions and algorithms throughout the rest of paper handle both types, we largely omit the "choice" type for the simplicity of discussion.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p><ref type="bibr" target="#b2">3</ref> The superscript is often omitted for brevity. The same for the subscript, which in this case can be abbreviated as book.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>XML normal form: GTT-XNFThe definition of our new XML normal form, called GTT-XNF, naturally follows Definition 11 and is inspired by the XNF normal form defined in<ref type="bibr" target="#b0">[1]</ref>. Formally, we have:</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>All examples are based on the data in Fig.8.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>If a group contains only one tuple, it can be removed from the partition, resulting in a striped partition<ref type="bibr" target="#b10">[11]</ref>. While we adopt striped partition in the implementation, we continue to use non-striped partition in the discussion for clarity.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Eliminate here means adjusting the schema such that those FDs no longer indicate redundancy. FDs are a property of the database and, as a result, can never be eliminated.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements This work was supported in part by the United States National Science Foundation (NSF) under grant IIS-0438909 and by National Institutes of Health (NIH) under grant 1-U54-DA021519. We would like to thank the anonymous reviewers for their constructive suggestions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A normal form for XML documents</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="195" to="232" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Dependency structures of database relationships</title>
		<author>
			<persName><forename type="first">W</forename><surname>Armstrong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIP</title>
		<meeting>IFIP</meeting>
		<imprint>
			<publisher>North Holland</publisher>
			<date type="published" when="1974">1974</date>
			<biblScope unit="page" from="580" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">P</forename><surname>Atzeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Deantonellis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<pubPlace>Benjamin Cummings</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Keys for XML</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WWW</title>
		<meeting>WWW<address><addrLine>Hong Kong; China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="201" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reasoning about keys for XML</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1037" to="1063" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">XKvalidator: a constraint validator for XML</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CIKM</title>
		<meeting>CIKM<address><addrLine>McLean, VA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="446" to="452" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A relational model of data for large shared data banks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="377" to="387" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multivalued dependencies and a new normal form for relational databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="262" to="278" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On XML integrity constraints in the presence of DTDs</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="368" to="406" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Integrity constraints for XML</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Simeon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JCSS</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="2554" to="2291" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">TANE: an efficient algorithm for discovering functional and approximate dependencies</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huhtala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Karkkainen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Porkka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">CORDS: automatic discovery of correlations and soft functional dependencies</title>
		<author>
			<persName><forename type="first">I</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Markl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="647" to="658" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Designing functional dependencies for XML</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">W</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Low</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EDBT</title>
		<meeting>EDBT<address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="124" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Ley</surname></persName>
		</author>
		<ptr target="http://dblp.uni-trier.de/" />
		<title level="m">DBLP Computer Science Bibliography</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient discovery of functional dependencies and Armstrong relations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Petit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lakhal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EDBT</title>
		<meeting>EDBT<address><addrLine>Konstanz, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="350" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Dependency inference</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K.-J</forename><surname>Raiha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB<address><addrLine>Brighton, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="155" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Information extraction and integration with Florid: the Mondial case study</title>
		<author>
			<persName><forename type="first">W</forename><surname>May</surname></persName>
		</author>
		<ptr target="http://www.dbis.informatik.uni-goettingen.de/lopix/lopix-mondial.html" />
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A normal form for precisely characterizing redundancy in nested relations</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">Y</forename><surname>Mok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-K</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Embley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="77" to="106" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Functional and embedded dependency inference: a data mining point of view</title>
		<author>
			<persName><forename type="first">N</forename><surname>Novelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cicchetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="477" to="506" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A new normal form for nested relations</title>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Ozsoyoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-Y</forename><surname>Yuan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="111" to="136" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<ptr target="http://pir.georgetown.edu/pirwww/search/textpsd.shtml" />
		<title level="m">PIR International Protein Sequence Database</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Translating Web data</title>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Velegrakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB<address><addrLine>Hong Kong; China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="598" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Sleepycat</forename><surname>Software</surname></persName>
		</author>
		<ptr target="http://www.sleepycat.com/" />
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Checking functional dependency satisfaction in XML</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. XSym</title>
		<meeting>XSym<address><addrLine>Trondheim, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="4" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Strong functional dependencies and their application to normal forms in XML</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="445" to="462" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName><surname>W3c</surname></persName>
		</author>
		<author>
			<persName><surname>Schema</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/xmlschema-0/" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
