<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Generating Euler Diagrams</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jean</forename><surname>Flower</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing and Mathematical Sciences</orgName>
								<orgName type="institution">University of Brighton</orgName>
								<address>
									<addrLine>Lewes Road</addrLine>
									<postCode>BN2 4GJ</postCode>
									<settlement>Brighton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><surname>Howse</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing and Mathematical Sciences</orgName>
								<orgName type="institution">University of Brighton</orgName>
								<address>
									<addrLine>Lewes Road</addrLine>
									<postCode>BN2 4GJ</postCode>
									<settlement>Brighton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Generating Euler Diagrams</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EEC9F5427B4FC67D6B73C8260B1BE687</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:56+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This article describes an algorithm for the automated generation of any Euler diagram starting with an abstract description of the diagram. An automated generation mechanism for Euler diagrams forms the foundations of a generation algorithm for notations such as Harel's higraphs, constraint diagrams and some of the UML notation. An algorithm to generate diagrams is an essential component of a diagram tool for users to generate, edit and reason with diagrams. The work makes use of properties of the dual graph of an abstract diagram to identify which abstract diagrams are "drawable" within given wellformedness rules on concrete diagrams. A Java program has been written to implement the algorithm and sample output is included.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction and background</head><p>Euler diagrams consist of contours, simple closed curves, which split the plane into zones. A concrete Euler diagram is a drawing which represents information about sets and their intersections. This information can be encapsulated by an abstract diagram. An abstract <ref type="bibr">(Euler)</ref> diagram consists of contours, which are just abstract notions, and information about how those contours are used to give a set of zones. An abstract diagram has zero or many concrete representations, and this paper is primarily concerned with the construction of concrete representations from an abstract description. An important consequence is the identification of a complete set of drawable abstract diagrams, with tests for drawability made at the abstract level. This work supports the development of a constraint diagram tool, and this application is discussed in subsection 1.1. Definitions of the terms "concrete <ref type="bibr">(Euler)</ref> diagram", "abstract <ref type="bibr">(Euler)</ref> diagram" are in subsection 1.3, and the algorithm for construction of concrete diagrams is in section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">An application to motivate the work</head><p>The construction of a concrete representation of an abstract diagram is useful in many environments. In this section we describe one application for the work. Constraint diagrams <ref type="bibr" target="#b5">[6]</ref> convey a subset of first-order predicate calculus concerning sets and their elements. The simplest kind of constraint diagrams are Euler diagrams <ref type="bibr" target="#b3">[4]</ref>, which make statements about the enclosure and intersection of sets in the system. The first of three diagrams in figure <ref type="figure" target="#fig_0">1</ref> is an Euler diagram which conveys the fact no book is both reserved and borrowed.</p><p>The second diagram in figure <ref type="figure" target="#fig_0">1</ref> is a spider diagram <ref type="bibr" target="#b4">[5]</ref> showing three states for a book: 'borrowed', 'on the shelf', or 'on hold'. No book may be in two states, and there is a book in one of the states. A further extension of the notation adds universal elements, and relational navigation <ref type="bibr" target="#b5">[6]</ref>, giving the full notation for constraint diagrams. The third diagram in figure <ref type="figure" target="#fig_0">1</ref> is a constraint diagram which states that reservations are only held on titles for which there is a copy in stock. Furthermore, there is a copy that is in stock and not in the borrowed state.</p><p>Textual notations (eg.OCL <ref type="bibr" target="#b16">[17]</ref>) and diagrammatic notations (eg. constraint diagrams) can be used for the same purpose. Many statements can be more clearly expressed in diagrammatic form. Diagrams can also be used fruitfully for reasoning ( <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>), with animation showing the logical steps involved in an argument.</p><p>Reasoning by transforming diagrams holds potential for the future, especially if are tools available to assist. Such a tool would be an editor (be able to assist the user with creation and editing of diagrams) but also needs an understanding of the diagram. This understanding determines whether two constraints are logically related and enables animated reasoning with diagrams. Flexible and combined use of textual and diagrammatic notations requires easy transformation from one notation to the other, in particular generating diagrams from textual notation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related work</head><p>There is much work on graph-drawing algorithms, see e.g. <ref type="bibr" target="#b0">[1]</ref>.</p><p>Euler diagrams are similar to the hypergraphs discussed in <ref type="bibr" target="#b1">[2]</ref>. A hypergraph is given by a set of contours, and a set of points. Each contour is specified as containing some points and excluding others. This is similar to the problem addressed here, except the description of an Euler diagram places conditions on the make-up of the regions of the diagram, and not just on a set of specific points. Our Euler diagrams could be thought of as examples of hypergraphs.</p><p>There is also work on string graphs in e.g. <ref type="bibr" target="#b13">[14]</ref>. The authors cast the problem of the drawability of Euler diagrams as equivalent in complexity to the problem of recognising string graphs.</p><p>In the above references the authors use weaker definitions of a well-formed diagram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Key definitions</head><p>An abstract Euler diagram comprises a set of contours and a set of zones which are subsets of the set of contours. This corresponds to type-syntax in <ref type="bibr" target="#b8">[9]</ref>.</p><formula xml:id="formula_0">Definition 1. An abstract (Euler) diagram is a pair: d = C(d), Z(d) where (i) C(d) is a finite set whose members are called contours. (ii) Z(d) ⊆ PC(d) is the set of zones of d, so z ∈ Z(d) is z ⊆ C(d). (iii) z∈Z(d) z = C(d) (iv) The empty set {} ∈ Z(d). The set of abstract diagrams is denoted D. Example 1 (An abstract diagram). {a, b, c} , {{} , {a} , {a, b} , {b} , {c}} ∈ D.</formula><p>The condition that the empty set is included as a zone could be omitted, and this work on converting abstract to concrete diagrams would hold for the subset of abstract diagrams which did include the empty set as a zone. In a concrete diagram, the zone corresponding to the empty set will be the zone outside all contours of the diagram.</p><p>A concrete Euler diagram is a set of labelled contours (simple closed curves) in the plane, each with a unique label. A zone is a connected component of the complement of the contour set. Each zone is contained in a set of contours. This corresponds to token-syntax in <ref type="bibr" target="#b8">[9]</ref>.</p><formula xml:id="formula_1">Definition 2. A concrete (Euler) diagram is a triple d = L( d), C( d), Z( d)</formula><p>whose components are defined as follows:</p><p>(i) C( d) is a finite set of simple closed curves, contours, in the plane R 2 . Each contour has a unique label from the set L( d).</p><p>1. Contours meet transversely and without triple points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Each component</head><formula xml:id="formula_2">ẑ ∈ R 2 - ĉ∈ b C( d)</formula><p>ĉ is uniquely identified by a set of contours</p><formula xml:id="formula_3">X ⊂ C( d) with ẑ = ĉ∈X interior (ĉ) ∩ ĉ∈ b C( d)-X exterior (ĉ) . (ii) A zone is a connected component of R 2 - ĉ∈ b C( d) ĉ. The set of zones of d is denoted Z( d).</formula><p>(iii) A zone ẑ is uniquely determined by the set of contour labels L(ẑ) for the contours which contain the zone. The set of concrete diagrams is denoted D. The rules about transverse crossing, absence of triple points and connectedness of zones are the chosen well-formedness rules for this paper. Figure <ref type="figure">2</ref>  This paper is about the construction of concrete representations of abstract diagrams. We seek an inverse of the map ab : D → D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">A sketch of the algorithm</head><p>We use the concept of a plane dual graph of a concrete diagram.</p><formula xml:id="formula_4">Definition 5. A concrete labelled graph Ĝ is a triple L( Ĝ), V( Ĝ), E( Ĝ)</formula><p>where the components are defined as follows:</p><formula xml:id="formula_5">(i) L( Ĝ) is a set of labels for the graph (ii) V( Ĝ) is a set of vertices. Each vertex v is labelled with L(v) ⊆ L( Ĝ)</formula><p>and each vertex has a position in the plane R 2 .</p><p>(iii) E( Ĝ) is a set of edges. Each edge ê is a pair of vertices from V( Ĝ). The label sets on adjacent vertices must have singleton symmetric difference (one set is the other with a single additional element). The edges can be associated with the label which distinguishes the labels of the end-vertices.</p><p>The set of concrete labelled graphs is denoted LG.</p><p>Note that although the vertices of a concrete labelled graph have a position in the plane, the edges are simply pairs of vertices. The edges are not associated with curves in the plane ie. we have a geometric graph in <ref type="bibr" target="#b0">[1]</ref>.</p><p>Definition 6. The map pdual : D → P LG ("pdual" for "plane dual") is defined by</p><formula xml:id="formula_6">Ĝ ∈ pdual L( d), C( d), Z( d) if and only if L( Ĝ) = L( d) and there is a bijection V( Ĝ) → Z( d); v → ẑ if</formula><p>and only if v is inside the part of the plane specified by ẑ and the labelling matches:</p><formula xml:id="formula_7">L(v) = L(ẑ).</formula><p>Finally, e ∈ E( Ĝ) if and only if the corresponding zones are topologically adjacent in the plane.</p><p>Any concrete labelled graph gives an abstract labelled graph, by forgetting vertex positions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7. An abstract labelled graph is a triple L(G), V(G), E(G)</head><p>where the components are defined as follows:</p><formula xml:id="formula_8">(i) L(G) is a set of labels for the graph (ii) V(G) is a set of vertices. Each vertex v is labelled with L(v) ⊆ L(G). (iii) E(G) is a set of edges. Each edge ê is a pair of vertices in V(G)</formula><p>, where the vertex labels must have a singleton symmetric difference (one vertex set exceeds the other by a single additional element). The label which distinguishes the end vertices can be used to label the edge. The set of abstract labelled graphs is denoted LG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5 (An abstract labelled graph).</head><p>The abstract labelled graph G has two labels: L(G) = {a, b}, three vertices:</p><formula xml:id="formula_9">V(G) = {v 1 , v 2 , v 3 }, the vertices labelled as follows: L(v 1 ) = {}, L(v 2 ) = {a}, L(v 3 ) = {a, b} and one edge: E(G) = {{v 1 , v 2 }}.</formula><p>Note that a second edge {v 2 , v 3 } could have been added to this example, but the pair {v 1 , v 3 } would not be admitted as an edge because of the labels on the vertices v 1 and v 3 . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8. The map f : LG → LG ('f ' for 'forgetful') is defined by forgetting positional information in the vertex set V( Ĝ)</head><note type="other">.</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10. The map diag : LG → D ("diag" for "diagrammise") is defined by L(G), V(G), E(G) → C(d), Z(d) where the abstract contour set is the label set L(G) = C(d) and the zones are the vertices V(G) = Z(d).</head><p>This map can be thought of as forgetting the edge information in an abstract labelled graph. What we have so far is illustrated in the following commutative diagram (shown on the left) which shows"forgetful" mappings as information is lost moving from a concrete environment to the abstract level.</p><formula xml:id="formula_10">D pdual ----→ LG D ← ----LG ab     f     D ← ---- diag LG D ----→ LG</formula><p>The strategy of the algorithm is to attempt to find inverses of the functions pdual, f and diag (inverses shown on the right). A mapping from abstract diagrams to concrete diagrams will be found which factors through abstract dual graphs and plane dual graphs. Factoring the problem through dual graphs reduces one task to three steps, and allows the use of existing knowledge from graph theory and graph drawing. As the work progresses, we will see that some inverse functions cannot be defined on the whole domain, and in this way, some abstract diagrams become classified as undrawable. The following three sections of the paper cover three key steps: (i) map from abstract diagrams to abstract labelled graphs: D → LG (ii) map from abstract labelled graphs to concrete labelled graphs: LG → LG (iii) map from concrete labelled graphs to concrete diagrams:  The proof of this result uses some results from topology concerning paths in the plane.</p><formula xml:id="formula_11">LG → D contours = { a , b } zones = {{}, { a }, { a , b }} vertices = {{}, { a }, { a , b }} edges = {{{},{ a }},{{ a },{ a , b }}} {} { a } { a , b } a b {} { a } { a , b } a b a b</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 1 (The connectivity test). If d is an abstract diagram whose super-dual fails the connectivity conditions then d is undrawable.</head><p>This corollary provides a practical condition for drawability at the abstract diagram level.</p><p>Example 7. The abstract diagram of example 4 {a, b} , {{} , {a, b}} has superdual with two vertices, labelled {} and {a, b} and no edges. The super-dual is disconnected, and so the abstract diagram is undrawable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Creation of a plane dual graph from an abstract labelled graph</head><p>If we are given an abstract labelled graph which passes the connectivity conditions, it is potentially the abstract graph of a concrete diagram. To begin the construction of such a concrete diagram (if it exists), assign points in the plane to vertices of the graph to give a concrete labelled graph. Recall that the vertices of a concrete labelled graph have positions in the plane, but the edges are simply pairs of vertices, rather than curves in the plane.</p><p>The dual of a concrete diagram can be drawn as a plane graph. Given an abstract labelled graph G, it is potentially the abstract graph of a concrete diagram only if it is planar. If G is non-planar, it may still be possible to remove edges from it to leave a reduced planar graph which still passes the connectivity conditions. For example, edge removal is necessary to produce a plane dual for the Venn diagram on four contours. Different choices of edge-removal lead to different concrete representations.</p><p>For non-planar abstract labelled graphs, further work is needed to ascertain a sound strategy for edge-removal (maintaining connectivity conditions) to give a planar graph where possible. Strategies exist in the literature for removing edges to gain planarity, but in this context, attention must be paid to the connectivity conditions.</p><p>Example 8 (Edge-removal and connectivity). The following abstract diagram has a superdual which passes the connectivity conditions. However, it is non-planar and if any edge is removed, the connectivity conditions fail. It has five contours {a, b, c, d, e} and fifteen zones. {{}, {b}, {c}, {d}, {e}, {a, b}, {a, c}, {a, d}, {a, e}, {a, b, c}, {a, b, d}, {a, b, e}, {a, c, d}, {a, c, e}, {a, d, e}} (inspired by an example in <ref type="bibr" target="#b13">[14]</ref>). The superdual is homeomorphic to the complete graph K 5 .</p><p>In the current implementation of the algorithm, an iterative planarising step is used which is not optimal but works in small cases. An improved planarising step should take account of the rich structure of the abstract graph given by the labelling on the vertices. Connectivity conditions reveal the graph as connected and bipartite (by cardinality of vertex labels). The fact that edges only join vertices with singleton symmetric difference provides more structure within the dual graph.</p><p>Whatever planarising step is used, the aesthetics of the result are unimportant at this stage. The placing of the vertices determines faces of the plane graph. The next step extracts the faces as as combinatorial constructions and makes a new embedding in the plane.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Creation of concrete contours from a plane labelled graph</head><p>Given a concrete labelled graph with labelled vertices and edges, the faces of the graph are the starting point for constructing the contours for a concrete diagram. We would like to be able to construct concrete contours which give one zone for each graph vertex, and no other zones. The labels on the zones should match the labels on the graph vertices. The strategy is to draw the edges of the concrete labelled graph, and to draw arcs across faces to join the midpoints of edges. These arcs will combine to create the closed contours of a concrete diagram (see figure <ref type="figure" target="#fig_6">5</ref>). The labels on the edges around each face determine how the arcs will intersect. For internal (bounded) faces of a concrete labelled graph G, there is a single face-cycle made up of a subset of the boundary edges. However, an outside (unbounded) face of G may have multiple face-cycles as shown in figure <ref type="figure" target="#fig_3">6</ref>.</p><formula xml:id="formula_12">{} { c } { a } { b } { a, b } {} { c } { a } { b } { a, b } {} { c } { a } { b } { a, b }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 13. A face-cycle of face f in concrete labelled graph G is a cycle of edges in the boundary of f which make up a cycle in G. The contour labels in a face-cycle can be cycled, or reversed, giving another representative of the same cycle.</head><formula xml:id="formula_13">{} { c } { a } { b } { a, b } a a b b {} { c } { a } { b } { a, b } a a b b c face-cycle = &lt; a , b , a , b &gt; face-cycle = &lt; a , b , a , b &gt; NB: not &lt; a , b , a , b , c , c &gt; {} { c } { a } { b } { a, b }</formula><p>Lemma 1. Let f be a face of a concrete labelled graph. For any contour label c, there is an even number of occurrences of c in a face-cycle of f . The proof uses a count of symbols in vertex-labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. Let G be a concrete labelled graph whose abstract labelled graph passes the connectivity conditions. Take a face f and a contour label c. There are zero or two occurrences of c in the face-cycle of f .</head><p>The proof of this result is similar to a proof of the five-colouring theorem which uses Kempe chains <ref type="bibr" target="#b2">[3]</ref>. Use connectivity and lemma 1.</p><p>When constructing the concrete contours, one zone will be constructed around each plane labelled vertex. It is important to ensure that the arcs across each face intersect so that no additional unwanted zone(s) appear in the face. Problematic cases with unwanted concrete zones are shown in figure <ref type="figure" target="#fig_8">7</ref>. The unwanted zones could be either zones which aren't specified by the vertex set, or a second component of an existing zone, giving disconnected zones. The first diagram in In the second diagram, however the arcs are placed without triple points, an unwanted zone will appear because of the sequence of edges around the face. The potential introduction of unwanted zones in this way provides another set of conditions for construction of a concrete diagram. The following definition and theorem set up enough notation to determine whether or not a concrete labelled graph can be used to construct a compliant concrete diagram. If a face-cycle has n symbols, each occurring twice, then its crossing index x is bounded by 0 ≤ x ≤ n(n-1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head><p>.</p><p>Theorem 2 (The face-conditions). Let d be a concrete diagram, and P a plane dual graph. For each face-cycle of a plane dual graph, with crossing index x and length 2n, the crossing index is x = n -1.</p><p>The proof uses Euler's formula for plane graphs and the handshaking lemma.</p><p>Corollary 2 (The face-cycle conditions). If P is a concrete labelled graph with a face-cycle whose crossing index is x and number of edges is 2n with x = n -1, then P cannot be used to construct concrete contours with one zone containing each vertex.</p><p>Example 10 (Face-conditions). In the left-hand diagram of figure <ref type="figure" target="#fig_10">8</ref>, there are three faces and two face-cycles. The four-sided faces have crossing index x = 1 and cycle length n = 2, and the six-sided face has crossing index x = 2 and cycle length n = 3. The concrete labelled graph passes the face-conditions.</p><p>The abstract diagram with zones {{} , {a} , {a, b} , {a, b, c} , {b, c} , {c}} is undrawable (see the second graph in figure <ref type="figure" target="#fig_10">8</ref>). Its plane dual graph is a cycle of six Proposition 4. If a concrete labelled graph passes the face-conditions and connectivity conditions, and removal of an edge maintains the connectivity conditions, then removal of that edge also maintains the face-conditions.</p><formula xml:id="formula_14">{ b , c } { a } c { c } { } c b b a a { a, b } face-cycle &lt; a , b , c , a , b , c &gt; has n = 3 and x = 3 this fails the face-conditions { a, b, c } { a , c } { a } c { c } { } c b b a a { a, b } { a, b, c } { a , c, d } { a , c, d, e } { a , c, d, f } { a , c, d, e, f }</formula><p>Removal of edges (e.g. to ease planarisation) cannot jeopardise the existence of a plane representation which passes the face-conditions. One might hope that, given an abstract dual graph, all plane representations of it either pass or fail the face-conditions. However, this is not the case. Figure <ref type="figure" target="#fig_11">9</ref> shows a dual of the Venn diagram on three contours, after removal of the edges {{a} , {a, c}} and {{b} , {b, c}}. The absence of these two edges does not cause failure of the seven connectivity conditions. The super-dual has a plane representation which passes the face-conditions (in fact all plane representations of the super-dual will pass the face conditions), so proposition 4 says that after removing two edges, there must also be a plane representation which passes the face conditions. This is shown on the left of the figure. But removal of these edges also introduces the existence of a plane representation which fails the face-conditions, shown on the right. This example shows that failure of the face-conditions in a single plane subgraph of superDual(d) does not necessarily render the underlying abstract diagram d undrawable. To complete the argument for example 10 we have to say that not only does the presented plane graph fail the face-conditions, but all plane representations of the abstract dual will fail the face conditions. For the example shown, this is easy, but for larger graphs, this kind of argument poses a problem.</p><formula xml:id="formula_15">{ b , c } { a } c { c { } { a , b , c } c b b a a { a, b } face-cycle &lt; a , b , c , a , b , c &gt; has n = 3 and x = 3 { a , c } { b } { b , c } { a } c { c } { } { a , b , c</formula><p>Future work on improving the planarising step in this algorithm should seek plane representations which pass the face-conditions, if they exist.</p><p>Given an abstract labelled graph which passes the connectivity conditions, and a plane graph representation which passes the face-conditions, to complete the construction of the contours we draw the plane graph with all faces convex and draw arcs linear across faces. Of course, it is impossible to draw a graph with all faces convex, but the faces can be placed as convex faces in a disc with one new non-convex outside face. This step, called circularisation of the dual, is discussed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Circularisation</head><p>Given a concrete labelled graph which passes the connectivity and face conditions, we seek a plane representation with convex faces. The barycentric approach to graph drawing <ref type="bibr" target="#b0">[1]</ref> gives all but one face convex. Circularisation reproduces all the faces of a graph inside a disc, introducing a new (non-convex) face outside the disc. Some vertices of the original graph may appear more than once, and some edges will be duplicated. Circularisation can be achieved by taking faces The edges which remain un-identified after all faces are inserted are the edges around the edge of the disc (polygon). These correspond to edges making up a spanning tree of the original graph.</p><formula xml:id="formula_16">abstract Euler diagram contours = { a , b , c } zones = {{}, { a }, { b }, { c }, { a , b }} { a , b } { b } { a } { } { a , b } { b } { } { c</formula><p>An alternative view of the same process begins by choosing a spanning tree of the original graph. Split the edges into pairs, and fatten the spanning tree into a new polygonal face. Move the infinity point into this new face and squeeze the original faces so that all vertices lie around a circle (the boundary of the new face). Edges in the chosen spanning tree are duplicated around the outside of the circularised graph whereas edges not in the spanning tree appear once each, across the disc.</p><p>The process of circularisation is illustrated in figure <ref type="figure" target="#fig_12">10</ref> as the second step (top right to bottom left diagram): a dual graph with two faces is circularised to give two faces in a disc and one additional non-convex face outside the disc.</p><p>The rewards of circularisation come from the construction of the concrete Euler contours. As in figure <ref type="figure" target="#fig_6">5</ref>, arcs will be constructed across faces of the concrete labelled graph, but now the arcs can be drawn as straight lines. A 2n-sided face will have n arcs drawn across it. The arcs join the midpoints of edges with shared labels. They are guaranteed to only cross other arcs in the same face (because the faces are convex), and they are guaranteed to meet transversely (because they are linear). The face-conditions guarantee that no new zones will appear as the linear arcs are added.</p><p>The added arcs contribute to piecewise-linear contours of the required concrete diagram. The contours need to be completed by drawing arcs outside the disc (the last step shown in figure <ref type="figure" target="#fig_12">10</ref>). Starting at a vertex labelled {}, read the labels from the edges around the circle, giving a word of contour labels. This word is made up of nested pairs of contour labels. In figure <ref type="figure" target="#fig_12">10</ref>, the nested word is babbabcc. Use the nesting to determine which labels are pairs. The labels which pair identify edges which will be joined by arcs outside the disc. Draw arcs outside the disc joining the innermost pairs: bb and cc. Join the two edges labelled a and join the remaining two edges labelled b.</p><p>The algorithm to this point has been implemented in the Java programming language, with outcomes shown in figure <ref type="figure" target="#fig_0">12</ref>. The results can be difficult to interpret by eye. The final proposition suggests one resolution of this problem. The resulting concrete diagram can appear somewhat convoluted. Measure the lengths of arcs drawn outside the disc, and take this to be a measure of convolution of the concrete diagram. Recall that the decisions made during circularisation give a spanning tree of the dual. Proposition 5. Convolution of the concrete diagram is minimised by choosing a spanning tree with the vertex labelled {} as its centre, with vertices as close as possible to the centre (for centre of a tree, see <ref type="bibr" target="#b2">[3]</ref>).</p><formula xml:id="formula_17">{ } { b } { a } { a,b } { c } { d } { c,d } { } { b } { a } { a,b } { c } { d } { c,d }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Conclusions</head><p>Figure <ref type="figure" target="#fig_0">12</ref> shows the outcome for all drawable diagrams with two or three contours. Some diagrams could be made less convoluted by application of the span-Fig. <ref type="figure" target="#fig_0">12</ref>. Program output ning tree with null centre (see prop 5). All other abstract diagrams with two or three contours were determined to be undrawable by testing for connectivity conditions and face-conditions.</p><p>The algorithm has been proved to be practical in small cases, as it has been implemented in the Java programming language. The program accepts a string description of a set of sets as zone descriptors. It first constructs the superdual graph (def 11) before checking the connectivity conditions (thm 1). If the connectivity conditions pass, then edges are removed to assist with an iterative planarising step (sec 2.2). If the face-cycle conditions (cor 2) fail, then alternative planarisations are sought. If a planar representation of the dual is found which passes the face conditions, then the circularisation process (sec 2.4) is applied to construct contours and resulting concrete diagram is drawn.</p><p>Remaining questions include: (i) If an abstract diagram has a non-planar super-dual (e.g. the Venn diagram on four contours), what is a good strategy for selecting edges (maintaining connectivity conditions) to get a planar dual graph? (ii) What is the most effective planarising algorithm for a labelled dual graph? (iii) Is it possible to adapt the algorithm to allow inclusion of triple points, or new zones, in the concrete diagrams? This would make more abstract diagrams drawable.</p><p>(iv) How can the resulting concrete diagram be manipulated to maintain the topological properties of contour intersection, and enhance the clarity of the concrete diagram?(prettification) One intended application of this work is to enable a constraint diagram tool to construct appropriate diagrams which are equivalent to textual constraints in software modelling. The kinds of constraints which occur normally have few contours. If a diagram is considered as a set of "nested" components -diagrams within diagrams -then the number of contours will be further reduced. The algorithm as it is presented here is effective for such small examples, and after more work on the planarising step, would be practical for larger examples too.</p><p>Current work includes the study of existing Venn diagram algorithms to address edge-removal and smart planarising steps for Euler duals. We are also looking at "nesting" diagrams and the impact this has on layout algorithms.</p><p>Thanks to John Taylor, Gem Stapleton, and the conference referees for constructive comments on drafts of this article. This work was partially supported by UK EPSRC grant GR/R63516.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. An Euler diagram, a spider diagram and a constraint diagram</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 2 (Fig. 2 .</head><label>22</label><figDesc>Fig. 2. Well-formed and not well-formed concrete diagrams</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Proposition 1 .Definition 9 .</head><label>19</label><figDesc>Given a concrete diagram d ∈ D, and two plane duals Ĝ1 , Ĝ2 ∈ pdual( d), their abstract labelled graphs are equal: f ( Ĝ1 ) = f ( Ĝ2 ). Although a concrete diagram d has many plane dual graphs given by the set pdual( d), we can refer to "the" abstract dual graph of a concrete diagram, abG( d) ∈ LG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 6 (</head><label>6</label><figDesc>The diag mapping). Let G be the abstract labelled graph given in example 5. The abstract diagram diag(G) = d has contours C(d) = {a, b, c} and zones {{} , {a} , {a, b}}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .Proposition 2 .</head><label>32</label><figDesc>Fig. 3. The steps of the algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 Fig. 4 . 3 .</head><label>343</label><figDesc>Figure 3 illustrates vertex and edge-labelling. In small cases (all examples with three or fewer contours), the abstract labelled dual graph of a concrete diagram abG( d) is exactly the super-dual of its abstract diagram superDual(ab( d)). However, figure 4 shows that vertex labels can differ by a single contour label even when the zones are not adjacent in the concrete diagram. The vertices {s} and {p, s} in superDual(ab( d)) are adjacent, but they are not adjacent in abG( d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Arcs across dual faces</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Face-cycles of a concrete labelled graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Introducing unwanted zones figure 7 can be resolved by rendering the face convex and using linear arcs across the face.In the second diagram, however the arcs are placed without triple points, an unwanted zone will appear because of the sequence of edges around the face. The potential introduction of unwanted zones in this way provides another set of conditions for construction of a concrete diagram. The following definition and theorem set up enough notation to determine whether or not a concrete labelled graph can be used to construct a compliant concrete diagram.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Definition 14 .</head><label>14</label><figDesc>Define the crossing index of a face-cycle. For each pair of contour labels which occur in the face-cycle, determine whether the pairs are nested. If the letters are not nested, the pair contributes 1 to the crossing index, otherwise the pair contributes 0 to the crossing index. Symbols a and b are nested in abba, but not nested in abab. Example 9 (Crossing index). The cycle a, b, c, a, b, c has crossing index equal to 3, because all pairs {a, b}, {b, c}, and {a, c} give non-nested sub-cycles a, b, a, b , b, c, b, c and a, c, a, c . Another example, a, b, c, b, a, c , has crossing index equal to 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Face-conditions edges. The faces both have face-cycles a, b, c, a, b, c with crossing indices x = 3, and the lengths given by n = 3. It is not the case that x = n -1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Face-conditions and layout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 10 .</head><label>10</label><figDesc>Fig.10. The circularisation process and addition of arcs in turn, inserting them into a disc. After the first face, further faces are chosen and inserted by identifying common edges which are already present in the disc. The edges which remain un-identified after all faces are inserted are the edges around the edge of the disc (polygon). These correspond to edges making up a spanning tree of the original graph.An alternative view of the same process begins by choosing a spanning tree of the original graph. Split the edges into pairs, and fatten the spanning tree into</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Spanning trees and circularisation</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Graph Drawing: algorithms for the visualization of graphs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Di Battista</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">G</forename><surname>Tollis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Drawing hypergraphs in the subset standard</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bertault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Eades</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph Drawing proceedings</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1984">1984. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Biggs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">K</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Wilson</surname></persName>
		</author>
		<title level="m">Graph Theory 1736-1936 OUP</title>
		<imprint>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Euler</surname></persName>
		</author>
		<idno>1761. Letters No. 102-108</idno>
		<title level="m">Lettres a Une Princesse d&apos;Allemagne</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Formalising Spider Diagrams</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symposium on Visual Languages (VL99)</title>
		<meeting>IEEE Symposium on Visual Languages (VL99)<address><addrLine>Tokyo</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Comp Soc Press</publisher>
			<date type="published" when="1999-09">Sept 1999</date>
			<biblScope unit="page" from="130" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Towards a formalisation of constraint diagrams</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc IEEE Symp on Human-Centric computing (HCC&apos;01)</title>
		<meeting>IEEE Symp on Human-Centric computing (HCC&apos;01)<address><addrLine>Stresa, Sept</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="72" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Logic and Visual Information</title>
		<author>
			<persName><forename type="first">E</forename><surname>Hammer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>CSLI Publications</publisher>
			<pubPlace>Stanford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the completeness and expressiveness of spider diagram systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Howse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Diagrams</title>
		<meeting>Diagrams<address><addrLine>Edinburgh</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2000-09">2000. Sept 2000</date>
			<biblScope unit="volume">1889</biblScope>
			<biblScope unit="page" from="26" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">On diagram tokens and types</title>
		<author>
			<persName><forename type="first">J</forename><surname>Howse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Taylor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Accepted for Diagrams</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Constraint diagrams: Visualising invariants in object oriented models. proceedings of OOPSLA97</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Reasoning with extended Venn-Peirce diagrammatic Systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Molina</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
		<respStmt>
			<orgName>University of Brighton</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD Thesis</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m">UML Specification</title>
		<imprint/>
		<respStmt>
			<orgName>Object Management Group</orgName>
		</respStmt>
	</monogr>
	<note>Version 1.3: www.omg.org</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Collected Papers</title>
		<author>
			<persName><forename type="first">C</forename><surname>Peirce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1933">1933</date>
			<publisher>Harvard University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Decidability of string graphs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Štefanikovič</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc 33rd ACM Symposium on the Thy of Comp</title>
		<meeting>33rd ACM Symposium on the Thy of Comp</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="241" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The Logical Status of Diagrams</title>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CUP</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the diagrammatic and mechanical representation of propositions and reasonings</title>
		<author>
			<persName><forename type="first">J</forename><surname>Venn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Phil.Mag</title>
		<imprint>
			<biblScope unit="page">123</biblScope>
			<date type="published" when="1880">1880</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The Object Constraint Language: Precise Modeling with UML</title>
		<author>
			<persName><forename type="first">J</forename><surname>Warmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kleppe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
