<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bounded approximate decentralised coordination via the max-sum algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010-11-03">3 November 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Electronics and Computer Science</orgName>
								<orgName type="institution">University of Southampton</orgName>
								<address>
									<settlement>Southampton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">A</forename><surname>Farinelli</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Electronics and Computer Science</orgName>
								<orgName type="institution">University of Southampton</orgName>
								<address>
									<settlement>Southampton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Verona</orgName>
								<address>
									<settlement>Verona</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>Stranders</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Electronics and Computer Science</orgName>
								<orgName type="institution">University of Southampton</orgName>
								<address>
									<settlement>Southampton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Electronics and Computer Science</orgName>
								<orgName type="institution">University of Southampton</orgName>
								<address>
									<settlement>Southampton</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Bounded approximate decentralised coordination via the max-sum algorithm</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2010-11-03">3 November 2010</date>
						</imprint>
					</monogr>
					<idno type="MD5">5D5AC1571946ECDCA7C28CAECE913B63</idno>
					<idno type="DOI">10.1016/j.artint.2010.11.001</idno>
					<note type="submission">Received 16 December 2009 Received in revised form 28 October 2010 Accepted 29 October 2010</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T05:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Decentralised coordination Max-sum algorithm DCOP</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we propose a novel approach to decentralised coordination, that is able to efficiently compute solutions with a guaranteed approximation ratio. Our approach is based on a factor graph representation of the constraint network. It builds a tree structure by eliminating dependencies between the functions and variables within the factor graph that have the least impact on solution quality. It then uses the max-sum algorithm to optimally solve the resulting tree structured constraint network, and provides a bounded approximation specific to the particular problem instance. In addition, we present two generic pruning techniques to reduce the amount of computation that agents must perform when using the max-sum algorithm. When this is combined with the above mentioned approximation algorithm, the agents are able to solve decentralised coordination problems that have very large action spaces with a low computation and communication overhead. We empirically evaluate our approach in a mobile sensor domain, where mobile agents are used to monitor and predict the state of spatial phenomena (e.g., temperature or gas concentration). Such sensors need to coordinate their movements with their direct neighbours to maximise the collective information gain, while predicting measurements at unobserved locations. When applied in this domain, our approach is able to provide solutions which are guaranteed to be within 2% of the optimal solution. Moreover, the two pruning techniques are extremely effective in decreasing the computational effort of each agent by reducing the size of the search space by up to 92%.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Recently, significant research effort has sought to apply coordination techniques to control physical devices that are able to acquire information from the environment. In these settings, decentralised coordination (i.e. no central system exists that controls the coordination process, but the devices coordinate amongst themselves) has proved to be a natural, robust and effective approach to organise the activities of the embedded agents that control the devices. For example, decentralised coordination techniques have been used to control the orientation of multiple fixed sensors deployed to localise and track a target <ref type="bibr" target="#b0">[1]</ref> and to coordinate sensing and communication in a sensor network deployed to collect environmental data <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>. In both of these domains, and many others besides, decentralised coordination is particularly challenging because of the constrained computational resources of the devices (due to the requirement of minimising power consumption) and because communication is limited to local neighbours (due to the use of low power wireless communication).</p><p>Given this background, the problem of decentralised coordination in these domains is often cast as a multi-agent distributed constraint optimisation problem (DCOP). In the constraint optimisation framework the aim is to find the assignment of a set of variables that optimises the aggregation of payoffs (or conversely costs) of a set of soft constraints defined over the values of the variables <ref type="bibr" target="#b3">[4]</ref>. In a distributed constraint optimisation problem a set of agents control the value of the variables in the system; jointly aiming to optimise the global reward. DCOP techniques can be directly used to address the decentralised coordination problem described above by representing the possible actions that an embedded agent can take with variables and by encoding payoffs (or costs) for taking joint actions with constraints. These DCOP techniques can be broadly divided into two classes: complete algorithms (i.e., algorithms that always find a solution that optimises the global objective function), such as ADOPT <ref type="bibr" target="#b4">[5]</ref>, OptAPO <ref type="bibr" target="#b5">[6]</ref>, DPOP <ref type="bibr" target="#b6">[7]</ref>, NCBB <ref type="bibr" target="#b7">[8]</ref> and AFB <ref type="bibr" target="#b8">[9]</ref>; and approximate algorithms such as the Distributed Stochastic Algorithm (DSA) <ref type="bibr" target="#b0">[1]</ref>, Maximum Gain Message (MGM) <ref type="bibr" target="#b9">[10]</ref>, and ALS_DisCOP <ref type="bibr" target="#b10">[11]</ref> that do not.</p><p>While complete algorithms guarantee that they will return the optimum solution, they also exhibit an exponentially increasing coordination overhead (either in the size and/or number of messages exchanged or in the computation required by each device <ref type="bibr" target="#b11">[12]</ref>) as the number of devices in the system increases. Thus, their use in practical applications such as those mentioned above is severely limited. This important issue is partially addressed by extensions of the above mentioned approaches. For example, MB-DPOP provides a memory bounded algorithm that trades-off the linear message number of DPOP with polynomial message size <ref type="bibr" target="#b12">[13]</ref>. In addition, BnB-ADOPT is an extension of ADOPT, using a different search strategy (depth first with branch and bound instead of best first) that consistently reduces computation time <ref type="bibr" target="#b13">[14]</ref>. However, while these approaches provide important improvements, to guarantee optimality of the solution, the overall time and/or message complexity is still necessarily exponential.</p><p>In contrast, approximate algorithms require very little local computation and communication, and are, as such, well suited for large scale practical distributed applications in which the optimality of the solution can be sacrificed in favour of computational and communication efficiency (see <ref type="bibr" target="#b3">[4]</ref> for a review of such algorithms). Furthermore, such approximate techniques, have been shown to provide solutions which are very close to optimality in several problem instances <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b9">10]</ref>. However, such approaches fail to provide guarantees on the solution quality in general settings. This is particularly troublesome because the quality of solution to which most approximate algorithms converge is highly dependent on many factors which cannot always be properly assessed before deploying the system. Therefore there is no guarantee against particularly negative behaviours of such techniques on specific pathological instances.</p><p>To rectify these shortcomings, we believe the answer is to develop approximate algorithms with quality guarantees. Such approaches can address the trade off between solution quality and computation effort while providing a guaranteed lower bound on the quality of the solution obtained with respect to the optimum. Addressing such trade-offs is particularly important in dynamic settings and when the agents have low computational power, which is usually the case for applications involving embedded devices (such as mobile robots or sensor networks). Moreover, having a bound on the quality of the provided solutions is particularly important for safety critical applications (such as disaster response, surveillance, etc.) because a pathological behaviour of the system is, in this case, simply unacceptable. Now, there has been some work on providing guarantees on the performance of approximate algorithms in the DCOP framework. In particular, Pearce and Tambe use the concept of k-optimal solutions, where a solution is k-optimal if the corresponding value of the objective function cannot be improved by changing the assignment of any k or less variables <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>. Specifically, Pearce and Tambe provide an approximation ratio (i.e., the ratio between the unknown optimal solution and the approximate solution <ref type="bibr" target="#b16">[17]</ref>) for k-optimal algorithms which is valid for any DCOP with non-negative reward structure <ref type="bibr" target="#b14">[15]</ref>. However, the accuracy of the approximation ratio, in any particular setting, depends on the number of agents, on the arity of the constraint functions and on the value of k. Specifically, the approximation bound is more accurate when k is higher but less accurate when the number of agents in the system grows. Thus, their approach provides a poor approximation bound when the number of agents grows. Moreover, finding a k-optimal solution of higher k requires, in general, exponentially more computation and communication. Better approximation bounds can be provided assuming some a priori knowledge on the reward structure. For example, <ref type="bibr">Bowring et al.</ref> show that the approximation bounds can be improved by assuming the knowledge of the ratio between the least minimum reward to the maximum reward <ref type="bibr" target="#b15">[16]</ref>. In this approach, the bound is significantly improved, and the bound decreases consistently when the number of agents grows. However, we will show in Section 4.3 that the resulting bound is still significantly larger than that produced by our approach.</p><p>Data dependent approximation approaches with guarantees have also been investigated. For example, Petcu and Faltings propose an approximate version of DPOP <ref type="bibr" target="#b17">[18]</ref>, and Yeoh et al. provide a mechanism to trade-off solution quality for computation time for the ADOPT and BnB-ADOPT algorithms <ref type="bibr" target="#b18">[19]</ref>. Such mechanisms work by fixing an approximation ratio and reducing computation or communication overhead as much as possible to meet that ratio. While empirical results show that such approaches significantly improve the efficiency of their complete counterparts (i.e., DPOP and BnB-ADOPT), there is no guarantee or bound on the computation time or communication overhead required to achieve the predetermined bound.</p><p>Against this background, here we propose a novel decentralised coordination approach that is able to make efficient use of constrained computational and communication resources, while providing accurate bounded approximate solutions. Our point of departure is recent work demonstrating that the max-sum algorithm is a very promising technique for decentralised coordination (and, more generally, constraint reasoning), providing solutions close to optimality while requiring very limited communication overhead and computation <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b19">20]</ref>. The max-sum algorithm belongs to the Generalised Distributive Law (GDL) framework <ref type="bibr" target="#b20">[21]</ref>, a family of techniques frequently used in information theory for decoding error correcting codes<ref type="foot" target="#foot_0">1</ref>  <ref type="bibr" target="#b21">[22]</ref> and to solve graphical models (e.g., to find the maximum a posteriori assignment in Markov random fields <ref type="bibr" target="#b22">[23]</ref> or compute the posterior probabilities <ref type="bibr" target="#b23">[24]</ref>). When applied to constraint networks that are trees, the max-sum algorithm is able to provide the optimal solution to the optimisation problem. However, when applied to general constraint networks which typically contain loops, only limited theoretical results hold for the solution quality. While empirical evidence shows that the algorithm is able to find solutions which are very close to the optimal in general problems, there is no guarantee that the algorithms will converge to a solution, and only very limited guarantees on the quality of the solution to which it might converge.</p><p>Thus, in this work, we build on the existing max-sum algorithm and propose a new algorithm that provides bounded approximate solutions on general constraint networks with bounded reward functions. We do so by removing cycles in the original constraint network, specifically by ignoring dependencies between functions and variables which have the least impact on the solution quality. We then use max-sum to optimally solve the resulting tree structured constraint network, whilst simultaneously computing the approximation ratio for the original problem instance. We note that the same guarantees can be obtained by using any distributed optimisation algorithm that runs in linear time on tree-structured network. Thus, the results in this paper pertaining to bounded approximate solutions are not limited to the max-sum algorithm. However, our specific choice of the max-sum algorithm here is driven by its efficiency in terms of low communication overhead (specifically in the number of messages), low computational requirement and ease of decentralisation. Other possible choice yielding the same results in term of efficiency would similar message passing algorithms such as DPOP or the cluster tree elimination algorithm <ref type="bibr" target="#b24">[25]</ref>. However, as shown in <ref type="bibr" target="#b25">[26]</ref>, the GDL framework (of which max-sum is an instance) generalises many optimisation algorithms based on dynamic programming, including both DPOP and cluster tree elimination.</p><p>Building on this result, we then go on to show that we can further improve the computational efficiency of our algorithm by reducing the search space that each agent needs to consider. This is important, since many practical problems exhibit search spaces which quickly become intractable even for approximated techniques. In order to achieve this, we develop two generic action pruning algorithms. The first attempts to discard dominated actions of individual agents (i.e. those that can never be part of an optimal solution) before the max-sum algorithm is run (and thus, this approach also generalises to other distributed optimisation algorithms). The second uses branch and bound to reduce the space of joint actions that needs to be considered whilst running the max-sum algorithm.</p><p>To evaluate the effectiveness of the two algorithms in a realistic application, we consider a disaster response scenario where a set of mobile sensors are tasked to gather information on spatial phenomena, such as temperature or the concentration of potentially toxic chemicals. To predict environmental conditions in parts of the environment that cannot be sensed directly, these sensors need to identify and model the spatial and temporal dynamics of the monitored phenomena. Moreover, the sensors need to coordinate their movements to collect the most informative measurements needed to predict these environmental conditions as accurately as possible <ref type="bibr" target="#b26">[27]</ref>. This problem is particularly challenging from a coordination standpoint because the sensors need a sophisticated model to represent the complex spatial and temporal correlations of the monitored phenomena (and here we use the Gaussian processes to perform this role), which results in a high computational overhead when evaluating the possible joint actions of the sensors. Moreover, to achieve effective solutions, mobile sensors have to coordinate on paths, rather than single actions, thus dealing with a large search space. <ref type="foot" target="#foot_1">2</ref> Thus, to effectively apply max-sum in a computationally challenging domain, such as the mobile sensors one, we can use these two new pruning algorithms to drastically reduce the required number of function evaluations, thus alleviating a major bottleneck of this algorithm for practical applications.</p><p>In more detail, this work makes the following contributions to the state of the art:</p><p>1. We propose a novel approach for decentralised coordination that provides bounded approximate solutions. This is the first approach to provide guarantees on convergence and solution quality for the max-sum algorithm in a decentralised coordination setting (and as noted, earlier, it is also applicable to other distributed optimisation algorithms that run in linear time on tree-structured network). In particular, our approach exploits the fact that we can calculate a weight for each edge of the original loopy constraint graph that characterises the maximum effect that the removal of that edge can have on the optimal value of the function to which it was connected. We formally prove that, if we remove edges to create a tree structured constraint network, our algorithm can then compute the approximation ratio for the original problem instance. Moreover, we present a fully decentralised algorithm (building on Gallager, Humblet and Spira's algorithm for finding minimum spanning trees <ref type="bibr" target="#b27">[28]</ref>) that forms a tree structured constraint network by removing those edges with the minimum total weighting (hence minimising the approximation ratio calculated above). The algorithm then initiates max-sum on the resulting tree structured constraint network and distributes the elements required to compute the approximation ratio to all nodes. 2. We empirically evaluate our bounded approximate approach in a synthetic scenario analysing the solution and approximation ratio obtained in a generalisation of the distributed graph colouring algorithm, which is a canonical problem frequently used to evaluate DCOP techniques (e.g., <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b5">[6]</ref>). We show that the approximate solutions that our algorithm provides are typically within 95% of the optimum and the approximation ratio that our algorithm provides is typically 1.23, and we show that this is much more accurate than the previous theoretical bound for k-optimal algorithms. 3. We develop two novel, generic pruning techniques to reduce the computational overhead of max-sum when applied to problems with a large action space. The first method attempts to reduce the number of actions that each agent needs to consider before running the max-sum algorithm. This algorithm prunes the dominated actions of each agent, which will never be selected by the decentralised coordination procedure, regardless of the actions of other agents. The second technique is based on a branch and bound search, which is performed when computing the joint actions that maximise the utility of the whole system. 4. Finally, we apply the developed decentralised coordination techniques to the mobile sensor domain. We show that our approach is able to provide an effective on-line coordination approach for the mobile sensors. In particular, we empirically show that a coordination algorithm based on max-sum outperforms a greedy non-coordinated algorithm by up to 50% in this domain. Moreover, the use of the bounded approximate algorithm results in solutions that are within 2% of the optimal. At the same time, by applying the two pruning techniques the action space is reduced by 92%, thus significantly reducing the computational overhead.</p><p>The rest of this paper is structured as follows: Section 2 formally defines the decentralised coordination problem we address and Section 3 provides a brief outline of the max-sum algorithm. Section 4 presents our approach to provide bounded approximate solutions and Section 5 then details our techniques to speed-up the computation performed by the max-sum approach. Section 6 empirically evaluates our approach in the mobile sensor domain. Section 7 puts our work in perspective with previous approaches and, finally, Section 8 concludes and discusses future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The decentralised coordination problem</head><p>We formulate the decentralised coordination problem we address as a DCOP. Following the standard DCOP formulation, we have a set of discrete variables x = {x 1 , . . . , x m }, which are controlled by a set of agents A = {A 1 , . . . , A k }, and a set of functions F = {F 1 , . . . , F n }. Each variable x i represents the possible actions that the controlling agents can execute and can take values over a finite domain d i . Each function F i (x i ) is dependent on a subset of variables x i ⊆ x defining the relationship among the variables in x i . Thus, function F i (x i ) denotes the value for each possible assignment of the variables in x i and represents the joint payoff that the corresponding agents achieve. Note that this setting is not limited to pairwise (binary) constraints and the functions may depend on any number of variables.</p><p>Within this setting, we wish to find the value of each variable, x * , such that the sum of all functions in the system is maximised (i.e., social welfare maximisation):</p><formula xml:id="formula_0">x * = arg max x n i=1 F i (x i ) (1)</formula><p>Furthermore, in order to enforce a truly decentralised solution, we assume that each agent can control only its local variable(s) and has knowledge of, and can directly communicate with, a few neighbouring agents. Two agents are neighbours if there is a relationship connecting variables and functions that the agents control.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Basics of the max-sum algorithm</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notation used in this section</head><p>• q i→ j (x i ) is the message sent from variable x i to function F j .</p><p>• α ij is the normalising constant for the message q i→ j (x i ).</p><p>• M i is set of function indexes, indicating which function nodes are connected to variable node x i . • r j→i (x i ) is the message sent from function F j to variable x i .</p><p>• N j is the set of variable indexes, indicating which variable nodes are connected to function node</p><formula xml:id="formula_1">F j x j \ x i ≡ {x k : k ∈ N j \ i}.</formula><p>In order to apply max-sum to the optimisation problem described in Eq. ( <ref type="formula">1</ref>), we represent it as a bipartite factor graph. <ref type="foot" target="#foot_2">3</ref>For example, Fig. <ref type="figure" target="#fig_0">1</ref> shows three interacting agents, A 1 , A 2 and A 3 . Variables represent actions that agents can execute, while functions assign utility values for all possible configurations of the variables they depend on, thus describing agent interactions. In general, each agent can be responsible for assigning values to a set of variables, and for performing computations associated to a set of functions. In the figure, for ease of presentation only, we show a situation where each agent is responsible for assigning a single variable and for performing the computation for a single function. However, this is not a requirement for the application of the max-sum algorithm and in general agents can be responsible for a set of variables for the computation of an arbitrary number of functions. In the example,</p><formula xml:id="formula_2">x 1 = {x 1 , x 2 }, x 2 = {x 1 , x 2 , x 3 } and x 3 = {x 2 , x 3 }. Notice that F 2 (x 2</formula><p>) is not a pairwise interaction and in general, there is no requirement that the utility functions should decompose into additive constraints between variables. The max-sum algorithm then operates directly on the factor graph representation described above, and does so by specifying the messages that should be passed from variable to function nodes, and from function nodes to variable nodes. These messages are defined as:</p><p>• From variable to function:</p><formula xml:id="formula_3">q i→ j (x i ) = α ij + k∈M i \ j r k→i (x i ) (2)</formula><p>where M i is a set of function indexes, indicating which function nodes are connected to variable node i, and α ij is a normalisation factor (the details of which will be discussed shortly).</p><p>• From function to variable:</p><formula xml:id="formula_4">r j→i (x i ) = max x j \x i F j (x j ) + k∈N j \x i q k→ j (x k )<label>(3)</label></formula><p>where N j is a set of variable indexes, indicating which variable nodes are connected to function node j and</p><formula xml:id="formula_5">x j \ i ≡ {x k : k ∈ N j \ i}.</formula><p>When the factor graph is cycle free, the algorithm is guaranteed to converge to the global optimal solution such that it finds the variable assignment that maximises the sum of the functions, thereby optimally solving the optimisation problem shown in Eq. <ref type="bibr" target="#b0">(1)</ref>. Furthermore, this convergence can be achieved in time equal to twice the depth of the tree by propagating messages from the leaf nodes of the tree to the root and back again. In this case, the optimal variable assignment is found by locally calculating the function, z i (x i ), once the variable node has received a message from each of its connected function nodes.</p><formula xml:id="formula_6">z i (x i ) = j∈M i r j→i (x i ) (<label>4</label></formula><formula xml:id="formula_7">)</formula><p>and hence finding arg max x i z i (x i ).</p><p>When applied to cyclic graphs, the messages within the graph may converge after multiple iterations, but there is no guarantee of this. In cyclic graphs, messages are usually normalised to prevent them from increasing endlessly. This is achieved by setting the normalising constant α ij in Eq. (2) such that x i q i→ j (x i ) = 0. <ref type="foot" target="#foot_3">4</ref> Extensive empirical evidence demonstrates that, despite the lack of convergence guarantees, the GDL algorithms (e.g., sum-product, max-product, maxsum, etc.) do in fact generate good approximate solutions when applied to cyclic graphs in this way <ref type="bibr" target="#b28">[29]</ref>. Interesting results have been obtained for characterising the quality of solutions at convergence. Specifically, for the max-product algorithm <ref type="foot" target="#foot_4">5</ref>it can be shown that when the algorithm converges, it does not converge to a simple local maximum, but rather, to a neighbourhood maximum that is guaranteed to be greater than all other maxima within a particular large region of the Fig. <ref type="figure">2</ref>. Execution example for the max-sum algorithm showing (a) the factor graph and messages exchanged in each iteration of the algorithm, and (b) the table form of the functions and computation of an exemplar function to variable message.</p><p>search space <ref type="bibr" target="#b22">[23]</ref>. Characterising the properties of these algorithms in terms of convergence and solution quality guarantees is still an ongoing area of research, and to date significant results have been obtained only for graphs with specific topologies (e.g., several researchers have focused on the analysis of the convergence and solution quality in graphs containing just a single loop <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b30">31]</ref>).</p><p>To better explain the operations performed by the max-sum algorithm we now detail an execution example. To make the example easier we consider a simple factor graph composed of two variables and two functions, each variable has a domain composed of three values indicated as r, b, g. Fig. <ref type="figure">2</ref>(a) shows the factor graph in this case, and the max-sum messages for a single iteration. Fig. <ref type="figure">2(b)</ref> shows the table form of the functions and the operations required to compute the exemplar message r 3 2→2 (x 2 ), where the superscript indicates the iteration for the message computation. At the first iterations all the q messages are initialised to zero, and therefore the r messages are a maximisation of the sending function over the variable which is not receiving the message (e.g., r 0</p><formula xml:id="formula_8">2→2 (x 2 ) = max x 1 [F 2 (x 1 , x 2 )]</formula><p>). At each iteration each variable computes its individual z function and chooses the value that maximise it. For this particular example the messages reach a fixed point after just six iterations and the z functions converge to <ref type="foot" target="#foot_5">6</ref> The algorithm would then find the optimal assignment x 1 = b and x 2 = b obtaining a total utility of 12.</p><formula xml:id="formula_9">z 1 (x 1 ) = { x 1 = r, 9 , x 1 = b, 14 , x 1 = g, 4 }, z 2 (x 2 ) = { x 2 = r, 18 , x 2 = b, 21 , x 2 = g, 18 }.</formula><p>The max-sum algorithm is extremely attractive for the decentralised coordination of computationally and communication constrained devices since the messages are small (they scale with the domain of the variables), the number of messages exchanged typically varies linearly with the number of agents within the system, and the computational complexity of the algorithm scales exponential with just the number of variables on which each function depends (and this is typically much less than the total number of variables in the system) <ref type="bibr" target="#b11">[12]</ref>. However, as with the approximate algorithms mentioned in the introduction, the lack of guaranteed convergence and guaranteed solution quality, limits the use of the standard max-sum algorithm in many application domains.</p><p>A possible solution to address this problem is to remove cycles from the constraint graph by arranging it into tree-like structures such as junction trees <ref type="bibr" target="#b31">[32]</ref> or pseudo-trees <ref type="bibr" target="#b6">[7]</ref>. However, such arrangements result in an exponential element in the computation of the solution or in the communication overhead. For example, DPOP is functionally equivalent to performing max-sum over a pseudo-tree formed by depth-first search of the constraint graph, and the resulting maximum message size is exponential with respect to the width of the pseudo tree. This exponential element is unavoidable in order to guarantee optimality of the solution and is tied to the combinatorial nature of the optimisation problem. However, as discussed in the introduction, such exponential behaviour is undesirable in systems composed of devices with constrained computational resources. Thus, in the next section we present our alternative approach that ensures the convergence of the algorithm to a bounded approximate solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The bounded max-sum algorithm</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notation used in this section</head><p>• FG(x, F; E) is a factor graph.</p><p>• E is the set of links connecting function and variable nodes in the factor graph.</p><p>• x * is the optimal variable assignment for the constraint network.</p><p>• x is the optimal variable assignment for the tree structured constraint network. • Ṽ = i F i (x i ) is the approximate solution obtained with the assignment x.</p><formula xml:id="formula_10">• V * = i F i (x * i ) is the optimal solution.</formula><p>• ρ FG is the approximation ratio.</p><p>• e ij ∈ E are the dependencies links between variables and functions.</p><p>• w ij is the weight associated with dependency link e ij .</p><p>• x t i is the set of dependent variables for function F i which will be part of the tree-structured constraint network.</p><p>• x c i is the set of dependent variables for function F i which will not be part of the tree-structured constraint network.</p><p>• B i (x c i ) is the maximum impact on the solution for a set of removed dependencies of function</p><formula xml:id="formula_11">F i . • B = i B i (x c i )</formula><p>is the maximum impact on the solution for a set of removed dependencies.</p><formula xml:id="formula_12">• Ṽ m = i min x c i F i (x i )</formula><p>is the optimal solution to the tree structured constraint network.</p><p>• C is the set of couples of indices i, j that identify the edges removed from the factor graph.</p><p>• W = i, j ∈C w ij is the sum of the weights of removed edges.</p><p>The basic idea of our approach is to remove cycles from the factor graph, by ignoring some of the dependencies between functions and variables. A dependency directly corresponds to a link between a function node and a variable node in the factor graph, and by removing appropriate dependencies, we can operate max-sum on a cycle free factor graph, hence guaranteeing that the algorithm will converge to the optimal solution of this new problem. Moreover, by removing cycles in this way, we do not incur the exponential communication cost that is typical of complete approaches (as discussed above and in the introduction). With our approach, the size of exchanged messages will be proportional only to the size of the domain of the variables involved, as opposed to the exponentially sized messages that are typical of complete algorithms. Also, the amount of computation required to perform the maximisation step when calculating function to variable messages, is exponential only in the number of variables directly involved in the function. 7 If the arity of the functions is bounded (e.g. we have only pairwise interactions) this computation is polynomial.</p><p>However, since we ignore some of the dependencies in the factor graph, we cannot guarantee that the solution we obtain in the cycle free factor graph is the optimal solution to our original problem. Nonetheless, as we will show shortly, we can bound the distance of the solution we find on the cycle free factor graph to the optimal solution on the original problem. A key step in this approach is to quantify the maximum impact that each dependency has on solution quality.</p><p>Specifically, consider a factor graph FG(x, F; E) where E is the set of links connecting function and variable nodes. To provide an approximation algorithm, our goal is to compute a variable assignment x over a spanning tree for the graph FG, such that the V * ρ FG Ṽ , where our approximate solution Ṽ = i F i (x i ) and the optimal solution</p><formula xml:id="formula_13">V * = i F i (x * i ).</formula><p>Note that the approximation ratio ρ FG is dependent on the particular instance of the problem. Thus, instead of bounding the performance of our algorithm on a large class of problems, we compute a data-dependent bound for any specific problem instance. As a result, this bound is tighter than a theoretical bound for a wider class of problems.</p><p>The key property of our algorithm is that it puts weights on the dependency links between variables and functions. These weights quantify the maximum impact that removing a dependency may have. In more detail, we indicate a dependency link with e ij ∈ E where i is an index over functions and j is an index over variables. Fig. <ref type="figure" target="#fig_1">3</ref> shows the same factor graph in Fig. <ref type="figure" target="#fig_0">1</ref> with the weights, and a possible spanning tree (solid lines represent links present in the spanning tree, and dashed lines represent links that were present in the original cyclic factor graph, but have been removed to form the spanning tree). 8  Given these concepts, our approach proceeds as follows:</p><p>1. We define the weight of each dependency link e ij as:</p><formula xml:id="formula_14">w ij = max x i \x j max x j F i (x i ) -min x j F i (x i )</formula><p>(5) 7 More specifically, when a function F i which depends on a set of variables |x i | = n sends a message to one of its variables x j the amount of computation required will be d n , where d is the size of the variables' domain. 8 This figure will be used as a running example to clarify the key steps of the approach. For example, w 23 reported in Fig. <ref type="figure" target="#fig_1">3</ref> is computed as</p><formula xml:id="formula_15">w 23 = max x 1 ,x 2 max x 3 F 2 (x 1 , x 2 , x 3 ) -min x 3 F 2 (x 1 , x 2 , x 3 )</formula><p>Notice that the weight w ij represents the maximum impact that variable x j can have over the values of function F i . In particular, if we ignore variable x j when maximising F i then the distance between our solution and the optimal will be at most w ij . Thus, the smaller the weight, the less important is the dependency in the optimisation process. 2. We remove dependency links from the original cyclic factor graph to form a tree structured graph. For each function within the factor graph, we now have</p><formula xml:id="formula_16">x i = x t i ∪ x c</formula><p>i where x t i represents the set of dependent variables which have not been removed and x c i represents those that have. For example, in Fig. <ref type="figure" target="#fig_1">3</ref> we have</p><formula xml:id="formula_17">x t 2 = {x 1 } and x c 2 = {x 2 , x 3 }. Notice that x c</formula><p>i might be empty because no dependency was removed for function i, as is the case in our running example for x c 1 and x c 3 because no dependency was removed for functions F 1 and F 3 . However, x t i will always contain at least one element. This follows from the fact that we build a spanning tree of the original factor graph and thus we do not disconnect any element. Consequently, we have that i x t i = x. Now, given a function F i we define the maximum impact of a set of removed dependencies as:</p><formula xml:id="formula_18">B i x c i = max x i \x c i [max x c i F i (x i ) -min x c i F i (x i )] if x c i = ∅ 0 o t h e r w i s e<label>(6)</label></formula><p>where x c i is the set of variables removed from the function dependency. By computing B i (x c i ), we are evaluating the maximum impact of all the removed dependencies from a function to form a spanning tree. For example, considering our running example reported in Fig. <ref type="figure" target="#fig_1">3</ref> we have:</p><formula xml:id="formula_19">B 2 (x 2 , x 3 ) = max x 1 max x 2 ,x 3 F i (x 1 , x 2 , x 3 ) -min x 2 ,x 3 F i (x 1 , x 2 , x 3 )</formula><p>This represents the maximum impact on the solution quality when both variables x 2 and x 3 are removed. Finally, we define the sum of the maximum impact of removed dependencies from the factor graph as:</p><formula xml:id="formula_20">B = i B i x c i 3.</formula><p>We now run the max-sum algorithm on the remaining tree structured factor graph. For functions which have had dependency links removed, we evaluate them by minimising over all values of x c i , and thus, the max-sum algorithm optimally solves:</p><formula xml:id="formula_21">x = arg max x i F i x t i = arg max x i min x c i F i (x i )<label>(7)</label></formula><p>For example, in our case the assignment we obtain after running the max-sum on the spanning tree maximises the function</p><formula xml:id="formula_22">F 1 (x 1 , x 2 ) + F 2 (x 1 ) + F 3 (x 2 , x 3 ) where F 2 (x 1 ) = min x 2 ,x 3 F 2 (x 1 , x 2 , x 3 ). 4.</formula><p>The resulting variable assignment, x, represents our approximate solution to the original optimisation problem, and we shall shortly prove that this approximate solution is within a calculated bound from the optimum solution. More precisely:</p><formula xml:id="formula_23">V * ρ FG Ṽ (8)</formula><p>where the approximation ratio ρ FG = 1 + ( Ṽ m + B -Ṽ )/ Ṽ , and Ṽ m = i min x c i F i (x i ) represents the optimal solution to the tree structured constraint network. Recall that V * is the unknown optimal solution to the original cyclic constraint network and Ṽ is our approximate solution evaluated on the cyclic constraint network. This result follows directly from the following theorem which bounds the difference between the computed solution x and the optimal solution x * . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Analysis of bound</head><p>A bounded approximate solution described above is dependent on the properties of the following theorem:</p><formula xml:id="formula_24">Theorem 1. Bounded approximation i min x c i F i (x i ) + B i F i x * i (9)</formula><p>This theorem states that the unknown optimal solution V * is never greater than the sum of the optimal solution computed on the tree structured constraint network and B. This allows us to have an upper bound on the unknown optimal solution and thus to provide a bounded approximation of the original problem. The complete proof of this theorem can be found in Appendix A.</p><p>The result stated in Theorem 1 is valid for any spanning tree of the original problem. However, the approximation ratio ρ FG is influenced by which dependencies are removed and is thus dependent on the specific problem instance. Nonetheless, we can provide a general approximation ratio ρ, which is independent of the specific problem instance by performing a worst case analysis of ρ FG . Specifically, assuming that we know the maximum fraction of rewards M m across all functions, then a worst case approximation ratio for the optimal solution is ρ = M m . We note that this result is in accordance with the analysis performed in <ref type="bibr" target="#b15">[16]</ref>. See Appendix B for the full derivation of this result. Note that the smaller the ratio between the maximum and minimum payoff, the better will be the bound. However, if we have functions that are not bounded (e.g., they can have arbitrarily high payoff) the approximation ratio we provide will not be significant in the worst case.</p><p>In practice we use the fact that ρ FG is dependent on the specific problem instance, and therefore we can exploit the structure of the problem to provide a better approximation ratio. Specifically, ρ FG depends on the number of dependencies that we need to cut to build the spanning tree. Clearly this value is higher (and thus the approximation ratio will be worse) for graphs with many cycles. Moreover, while ρ depends on the ratio between the maximum and the minimum payoff across all functions, ρ FG depends on the sum of the impacts of the removed dependencies only. Therefore, if we carefully remove dependencies which have a low impact on the solution quality we can provide very good approximation ratios.</p><p>To better explain the operations performed by the bounded max-sum algorithm consider again the factor graph reported in Fig. <ref type="figure">2(a)</ref>. The first step of our algorithm is to compute the weights for each link in the factor graph, and we show these in Fig. <ref type="figure" target="#fig_2">4</ref> using the functions reported in Fig. <ref type="figure">2(b)</ref>. We then form a new factor graph which is a spanning tree of the original factor graph. More specifically, we remove link e 22 , which is the one with the smallest weight (this is shown as a dashed line in the figure), and thus, B = w 22 = 3. Moreover, we replace the function</p><formula xml:id="formula_25">F 2 (x 1 , x 2 ) with F 2 (x 1 ) = min x 2 [F 2 (x 1 , x 2 )].</formula><p>Now, we run the max-sum algorithm on the new factor graph. Since this new factor is a tree, the max-sum algorithm is guaranteed to converge to the optimal solution, which in this case is x 1 = r and x 2 = r. This achieves a utility on the new factor graph, Ṽ m , of 10 and a utility on the original factor graph, Ṽ , of 11. Furthermore, in this case we have that ρ FG = 1 + (10 + 3 -11)/11 = 13/11, and thus, we know that the unknown optimal solution must be greater than Ṽ , but no more than ρ FG Ṽ , which in this case is 13. Now, recall that the optimal solution for the original factor graph was shown in Section 3 to be x 1 = b and x 2 = b yielding a total utility of 12 (V * ). Thus, as required we have that V * ρ FG Ṽ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Decentralised bounded max-sum</head><p>Having described our approach, and discussed the approximation ratio that we can provide, we now detail a decentralised implementation of our bounded max-sum algorithm. This implementation has two key steps: (i) forming the spanning tree factor graph which minimises the approximation ratio, and (ii) initiating the max-sum algorithm and propagating the information required to compute the approximation ratio to the agents. In this section, we describe the approach for factor graphs containing n-ary constraint functions; we specify the computation of the approximation ratio when only pairwise constraint functions are present in Section 4.2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1.">Spanning tree formation</head><p>As described earlier, we aim to remove cycles from the factor graph to guarantee convergence of the max-sum algorithm. Moreover, we want to remove dependencies which have minimal impact on the solution quality. We can do this by finding a spanning tree that minimises the sum of the weights of the removed edges. To this end, we use the weights of each edge to compute a maximum weight spanning tree, T . Notice that, by finding a maximum weight spanning tree we effectively minimise the sum of the weights of the removed edges. Moreover, if we indicate with W = i, j ∈C w ij , where C is the set of couples of indices i, j that identify the edges removed from the factor graph, we can then show that W B, i.e., the sum of the weight of removed edges is an upper bound of B (the proof of this is provided in Appendix A, Lemma 2). Therefore, by minimising the sum of the weights of removed edges we are minimising the approximation ratio ρ FG .</p><p>The computation of the maximum spanning tree can be performed in a distributed fashion using various message passing algorithms. In particular, here we use the minimum spanning tree algorithm by Gallager, Humblet and Spira (GHS), modified to find the maximum spanning tree <ref type="bibr" target="#b27">[28]</ref>. This is a distributed, asynchronous algorithm, for general, undirected graphs. <ref type="foot" target="#foot_6">9</ref> GHS is optimal in terms of communication cost O (n log n + E) and has a running time of O (n log n), where n is the number of nodes in the factor graph.</p><p>We briefly describe the GHS algorithm here and refer to <ref type="bibr" target="#b27">[28]</ref> for a more complete description. Initially, each node (which may be either a variable or a function node) is a fragment with level L = 0, then each node chooses its maximum weight outgoing edge and attempts to join with the node at the other end. This forms a fragment of level L = 1. Nodes in fragments where L &gt; 0 co-operate to determine the fragment's maximum weight outgoing edge that will not form a cycle and attempt to join with the fragment on the other end. This occurs by each node finding its maximum weight outgoing edge, and passing this information to a core node, which can then determine the best edge for the whole fragment.</p><p>Fragments continue to join together in this manner. The two core nodes (those at either end of the edge on which the final joining of fragments occurs) are aware when the algorithm terminates, as they will receive reports from each node that they cannot locate any further outgoing edges that will not lead to a cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2.">Max-sum initiation and information propagation</head><p>On termination of the GHS algorithm described above, only the two core nodes are aware that the algorithm has completed. Therefore we add a message-passing phase to propagate this information throughout the tree. This procedure also establishes a parent-child hierarchy in the tree, and serves to initiate the max-sum algorithm and information propagation stages. This message-passing phase is initiated by the root node; a role adopted by whichever of the two core nodes is a function node. <ref type="foot" target="#foot_7">10</ref> This root node sends out a COMPLETE message to each of its children. When a node receives a COMPLETE message, it marks the sender as its parent, and then propagates the COMPLETE message down the tree.</p><p>When a leaf node receives the COMPLETE message the max-sum phase starts. Each node propagates MAXSUM messages up the tree, waiting for messages from each child node before sending an updated message to the parent node. The content of the messages are calculated as described in Eqs. ( <ref type="formula">2</ref>) and (3), and convergence of the messages to the optimum is guaranteed when the messages have propagated to the root node, and back to the leaf nodes. <ref type="foot" target="#foot_8">11</ref> At this stage, each variable node is aware of both the variable assignment, xi , that represents the approximate solution to the original optimisation problem, and the value of Ṽ m = i min x c i F i (x i ); this is provided directly from the max-sum algorithm and used to calculate ρ FG .</p><p>When the leaf nodes receive this final MAXSUM message, the B and solution propagation phase starts. During this phase, nodes propagate tuples composed of BSUM (which will accumulate the value of B specified in Eq. ( <ref type="formula" target="#formula_18">6</ref>)) and SOLUTION messages. <ref type="bibr" target="#b11">12</ref> If the leaf is a variable node it creates an empty BSUM and an empty SOLUTION message. If it is a function node F i , it creates a BSUM message of value equal to B i (x c i ) where x c i is the set of local deleted variables, and a SOLUTION message equal to F i (x i ). Both messages are then propagated up the tree, with each internal node waiting to receive messages from all its children before propagating a single new BSUM and SOLUTION message to its parent. If the internal node is a variable node, then these new messages are simply the sum of the messages from its children. If it is a function node, then they are given by the sum of the messages from its children plus the local B i component, and the value of F i (x i ), respectively. When the root has received all the BSUM and SOLUTION messages, both are propagated back down the tree, informing each node of the total B, and the final solution, Ṽ = i F i (x i ).</p><p>At this final stage, each agent knows the assignment of the variables that it controls, it knows that this assignment leads to a total solution quality of Ṽ , and that this solution has an approximation ratio ρ FG = 1 + ( Ṽ m + B -Ṽ )/ Ṽ . The number of messages for each information propagation phase is equal to the number of edges in the spanning tree (i.e., |F| + |x| -1), and thus, while the size of each message depends on the message type, it is always constant with respect to the number Fig. <ref type="figure">5</ref>. Empirical results for the utility when varying the number of agents and the link density (using random graphs with payoffs drawn from a gamma distribution).</p><p>of nodes in the factor graph (e.g., a MAXSUM message involving variable x i contains |d i | values while BSUM and SOLUTION messages contain one value each).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Approximation ratio for pairwise interactions</head><p>Note that when the interactions are pairwise <ref type="foot" target="#foot_10">13</ref> and thus at most one dependency is removed from each function node, there is a direct link between B i and the removed weight. Specifically, since each function F i has exactly two edges, B i will be either zero (when no dependencies are removed for that function) or the weight of the removed dependency. Consequently, by minimising the sum of the removed weights, we directly minimise the approximation ratio. Therefore, by using the approach presented in the previous section we find the optimal set of dependencies to be removed, i.e. the set of dependencies that provide the minimum approximation ratio.</p><p>However, in general, when multiple dependencies may be removed from any function node, this is no longer the case. For example, consider Fig. <ref type="figure" target="#fig_1">3</ref>, and suppose the spanning tree is a maximum spanning tree. This implies that e 23 and e 22 are the dependencies, with the minimum total weights, that need to be removed in order to form a spanning tree. However, in this case the possible impact of the removed dependencies on the solution quality will be</p><formula xml:id="formula_26">B i (x 2 , x 3 ) = max x 1 [max x 2 ,x 3 F 2 (x 1 , x 2 , x 3 ) -min x 2 ,x 3 F 2 (x 1 , x 2 , x 3 )] which in general is different from W = w 22 + w 23 .</formula><p>Therefore, when interactions are not pairwise, there might be a combination of dependencies to remove, that has a smaller impact than the B we compute. While it is possible to calculate the impact that removing multiple dependencies has, finding the set that must be removed in order to minimise this impact is a combinatorial problem. Nonetheless, our approach of summing the individual weights overestimates this impact, such that B W , and thus, our bounded approximate solution is still valid in these cases. The proof that this inequality holds is presented in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Empirical evaluation</head><p>We now present an empirical evaluation of our bounded approximate algorithm, in particular we wish to evaluate the significance of the approximation ratio that our approach can provide. Recall that the lower the approximation ratio the better. This empirical evaluation is required because our approximation ratio depends on the specific problem instance, and in particular on the topology of the constraint network (i.e., mainly on the number of loops) and on the ratio between the maximum and minimum payoff of the constraint functions (as discussed above). Thus, here we consider a set of decentralised coordination problems where a set of agents is arranged in a graph. Each agent controls one variable, with domain |d i | = 3, and each edge of the graph represents a pairwise constraint between two agents. Since there are pairwise interactions we have B = W and we are able to compute the minimum approximation ratio ρ FG .</p><p>We consider two different graph topologies: random graphs and graphs from the ADOPT repository which represents a large class of graph colouring problems that have previously been used to benchmark DCOP approaches (available from http://teamcore.usc.edu/dcop/). In both cases, graphs were selected with different link densities (i.e. the average connection per agents) and different numbers of nodes.</p><p>A random payoff matrix is associated with each edge of the graph, specifying the payoff that both agents will obtain for every possible combination of their variables' assignments. Each entry of the payoff matrix is a real number sampled from a distribution, and we consider two different distributions: a gamma distribution with α = 9 and β = 2, and a uniform distribution with range (0, 1). Both produce strictly positive payoffs, but only the uniform distribution has finite support. This setting generalises the distributed graph colouring problem, which is a canonical problem frequently used to evaluate DCOP techniques (e.g., <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b5">[6]</ref>). In the standard graph colouring domain the value of W that our approach provides would simply be the number of edges removed to remove cycles from the graph. The random payoff matrix that we use here enriches the domain by differentiating the values of constraint functions; moreover, the use of a gamma distribution introduces significant variance such that some dependencies have a higher impact than others. By having different values for different constraint functions and dependencies, we consider situations where constraints among the actions of some agents are more important than others for the global solution. This makes the evaluation analysis more significant, and it better represents realistic applications, such as cooperative exploration with mobile sensors, which are the main application focus of this work. An empirical evaluation of our approach in the mobile sensor domain will be presented in Section 6.4.</p><p>For each configuration, we consider the following four performance metrics:</p><p>• Ṽ m : The solution obtained by the max-sum algorithm on the tree structured constraint network.</p><p>• Ṽ : Our bounded approximate solution, obtained by evaluating the assignment computed by max-sum on the spanning tree, on the original loopy constraint network.</p><p>• Ṽ m + B: The upper bound on the value of the unknown optimal solution computed by our approach.</p><p>• V * : The optimal solution computed using a previously published modified version of ADOPT <ref type="bibr" target="#b34">[35]</ref>. <ref type="foot" target="#foot_11">14</ref>We first consider the case of random graphs with payoffs drawn from a gamma distribution, and in Fig. <ref type="figure">5</ref> we show the results obtained for link densities of 2 and 3. <ref type="foot" target="#foot_12">15</ref> For each configuration, we report the average value and the 95% confidence interval computed over twenty repetitions. <ref type="foot" target="#foot_13">16</ref> Since the optimal utility is computed by a complete algorithm, we were able Fig. <ref type="figure">7</ref>. Empirical results for the approximation ratio obtained with our bounded max-sum (BMS) and the approximation ratio computed using the k-optimal analysis (using graphs from the ADOPT repository).</p><p>to compute this metric only for smaller numbers of agents (e.g., up to 15). Our results show that the actual utility that our approach computes is extremely close to the optimal solution (in the experiments the minimum ratio was 95%). Thus showing that, from an empirical point of view, our approach provides very good approximations. More importantly, however, the approximation ratio we guarantee is significant. In the experiments ρ FG was never above 1.27, and was typically 1.23.</p><p>To illustrate the insensitivity of these results to the particular graph topology and payoff distribution, in Fig. <ref type="figure" target="#fig_3">6</ref> we show the results for graphs from the ADOPT repository with payoffs drawn from both gamma and uniform distributions. The same measures described above ( Ṽ m , Ṽ , Ṽ m + B, V * ) averaged over all the different graph instances available in the ADOPT repository (25 instances) and the 95% confidence interval. Results show that the behaviour of our approach is similar across the different payoff distributions we considered. In more detail, the approximation ratio is slightly better (i.e., lower) for the gamma distribution than uniform but it is very significant for both the payoff distributions. In particular, the worst approximation ratio was approximately 1.24 and 1.43 with an average of 1.2 and 1.33 respectively. As before, the actual utility computed by our approach is extremely close to the optimal solution. <ref type="foot" target="#foot_14">17</ref>To analyse the significance of the approximation ratio that our approach provides, we compute for the same data set the approximation ratio obtained with the k-optimality framework, using the formulas provides in <ref type="bibr" target="#b15">[16]</ref> for general constraint networks. For our data set the constraint arity is 2 (m = 2) and we compute the average ratio of the least minimum reward to the maximum reward (indicated with β in <ref type="bibr" target="#b15">[16]</ref>) for the different distributions and agent numbers. Our results, in Fig. <ref type="figure">7</ref>, show that the approximation ratio obtained using the bounded max-sum approach (labelled as BMS) is much more significant than that obtained using the k-optimality framework (labelled by their k value). Clearly, by increasing k it is possible to achieve better approximation ratios, however this would result in an exponential increase in the computation required to obtain a k-optimal solution and, in fact, the most widely used approximate algorithms in the field uses k = 1 or k = 2 <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b9">10]</ref>. Recall however that the approximation ratio computed with the bounded max-sum is specific to the problem instance while the one provided by the k-optimality framework is not, and as such can be computed without running any solution algorithm.</p><p>We now consider the execution time of our approach on the same data set described above. Specifically, we measure the computational time (in milliseconds) required to form the spanning tree and compute the weights (this operation is labelled prepoc. in the figures) and the time required to run the max-sum algorithm over the spanning tree. Out results, in Fig. <ref type="figure">8</ref>, show that our approach scales very well with the number of agents, having a total running time of approximately 1 second on the most complex problem instance in the ADOPT graph repository (specifically, a graph with 40 agents and a Fig. <ref type="figure">8</ref>. Empirical results for the execution time in milliseconds for pre-processing the factor graph and running the max-sum algorithm, varying the number of agents, the link density and the distribution for payoffs (using graphs from the ADOPT repository). link density of 3). Moreover, the running time of the approach is dominated by the execution of max-sum on the spanning tree and the preprocessing time is negligible.</p><p>Finally, we present a comparison of the utility obtained using the bounded max-sum approach proposed here, the loopy version of max-sum (i.e., max-sum running directly on the input constraint network) and the optimal utility computed using a previously published modified version of ADOPT <ref type="bibr" target="#b34">[35]</ref>. Our aim here is to compare the utility obtained using the max-sum and its bounded version with respect to the optimal utility for larger problem instances. To this end we focus on the graphs of the ADOPT repository with link density 3, we use the gamma payoff distribution mentioned above, and we run the various algorithm on a single problem instance for each agent number. Using this approach we were able to compute the optimal utility up to 16 agents, but for higher number of agents the version of ADOPT we used could not terminate the computation within the imposed time limits of five hours. Table <ref type="table">1</ref> reports the results obtained. Since both the bounded max-sum and ADOPT approaches are deterministic, the reported values are the utilities obtained on a single execution of each algorithm. However, for the loopy max-sum we report the average utility obtained over twenty repetitions together with the 95% confidence interval.</p><p>Our results show that the utility values obtained by the loopy max-sum are very close to the ones provided by the bounded max-sum approach, with the loopy max-sum being marginally superior for most of the problem instances. Moreover, both loopy and bounded max-sum achieve results which are very close to the optimal. This results confirm that loopy max-sum is able to provide very good empirical results, and show that the bounded version proposed here achieves similar performance providing guarantees on the solution quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Speeding up message computation</head><p>As mentioned in the introduction, many practical applications inherently have large action spaces for individual agents. For example, in the mobile sensor domain that will be discussed in Section 6, each sensor (agent) can reposition itself to many different locations, and follow different paths on its way to those locations. Moreover, to evaluate the utility gained by the entire team of sensors, a computationally expensive function needs to be evaluated. Therefore, in general, the straightforward application of max-sum to compute the optimal joint action (see Eq. ( <ref type="formula">1</ref>)) is not practical, because the computation of the messages that are sent from function F j to variable x i (Eq. ( <ref type="formula" target="#formula_4">3</ref>)) is a major bottleneck. The naïve way of computing these messages for a given variable x i is to enumerate the entire domain of x j (i.e. the domain of F j ), and evaluate F j for each element. Since the size of this joint action space grows exponentially with both the number of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1</head><p>Utility comparison for max-sum, bounded max-sum and ADOPT <ref type="bibr" target="#b34">[35]</ref> on one problem instance from ADOPT graph repository whilst varying the number of agents (using payoffs drawn from a gamma distribution).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Agents</head><p>Loopy agents, and the number of possible actions for each agent, the amount of computation can quickly become prohibitive in many settings. This is especially true when evaluating F j is costly. Therefore, in this section, we present two novel pruning algorithms that drastically reduce the size of the joint action space that needs to be searched without sacrificing solution quality. In the remainder of this section, we will describe each algorithm in turn.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">The action pruning algorithm</head><p>The first algorithm attempts to reduce the number of actions each agent needs to consider before running the max-sum algorithm. This algorithm prunes the dominated actions that can never maximise the social welfare (Eq. ( <ref type="formula">1</ref>)), regardless of the actions of other agents. More formally, a value d ∈ d i of variable x i is dominated if there exists a value d ∈ d i such that:</p><formula xml:id="formula_27">∀d -i ∈ n × k=1, k =i d k : j∈M i F j (d, d -i ) j∈M i F j d , d -i<label>(10)</label></formula><p>where, as in Section 3, M i is a set of function indexes, indicating which function nodes are connected to variable node i. Now, by removing these dominated actions, the optimal solution remains unchanged. However, since a number of dominated actions are pruned, the size of the joint action space is reduced.</p><p>Just as with the max-sum algorithm itself, this algorithm is implemented by message passing, and operates directly on the variable and function nodes of the factor graph, making it fully decentralised:</p><p>• From function to variable: The message from function F j to x i contains the minimum F j (x i ) and the maximum F j (x i ) value of F j with respect to x i = d, for all actions d ∈ d i , the domain of x i (see Algorithm 1). • From variable to function: Variable x i sums the minimum and maximum values from each of its adjacent functions, and prunes dominated actions. It then informs neighbouring functions of its updated domain (see Algorithm 2). Fig. <ref type="figure">9</ref> reports the messages that variable x 1 would received at the first iteration of the action pruning algorithm using the example factor graph and functions presented in Fig. <ref type="figure">2</ref>. In this case, given the received messages, variable x 1 will be able to prune g from its domain.</p><p>Using this distributed algorithm, functions continually refine the bounds on the utility for a given value of a variable, which potentially causes more actions to be pruned. Therefore, it is possible that action pruning starts by pruning a single action, which results in further actions being pruned throughout the entire factor graph.</p><p>This algorithm terminates once the messages exchanged between the functions and variables converge. That is, when all messages along all edges in the factor graph are equal to the previously received messages. Thus, a node in the factor graph can initiate the max-sum algorithm once it has received the same message twice from each neighbour. Also note that termination is guaranteed because of the fact that every variable has a finite number of actions; during each iteration either at least one variable value is pruned or the algorithm has converged. To see why this is true, note that for the bounds on F i for a certain value d to change, at least one variable value needs to get pruned. Otherwise, the messages sent from variables to functions will be identical, and all variables receive the same message twice, which results in the termination of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">The joint action pruning algorithm</head><p>Now, whereas the first algorithm runs as a preprocessing phase to max-sum, the second algorithm is geared towards speeding up the computation of the messages from function to variable (see Eq. ( <ref type="formula" target="#formula_4">3</ref>)), during the execution of the max-sum algorithm. In contrast to reducing the action space of individual agents, which was the goal of the first algorithm, this algorithm attempts to reduce the size of the joint action space that has to be searched by applying branch and bound.</p><p>Algorithm 1 Algorithm for computing pruning message from function F j to variable x i : i ∈ N j .</p><formula xml:id="formula_28">1: compute F j (x i ) min x j \x i F j (x i , x j \ x i ) 2: compute F j (x j ) max x j \x i F j (x i , x j \ x i ) 3: send F j (x i ), F j (x i ) to x i</formula><p>Algorithm 2 Algorithm for computing pruning messages from variable x i to all functions F j : j ∈ M i .</p><p>1: if a new message has been received from all F j : j ∈ M i then  A naïve way of computing this message to a single variable x i is to determine the maximum utility for each of agent i's actions by exhaustively enumerating the joint domain of the variables in x j \ {x i }, and evaluating the expression between brackets in Eq. ( <ref type="formula" target="#formula_4">3</ref>), which we denote by: r j→i (x j ) = F j (x j ) + k∈N j \x i q k→ j <ref type="bibr" target="#b10">(11)</ref> Instead of just considering joint actions, we now allow some actions to be undetermined, and thus, consider partial joint actions. By doing so, we can create a search tree on which we can employ branch and bound to significantly reduce the size of the domain that needs to be searched. In more detail, to compute r j→i (d k i ) for d k i ∈ d i (a single element of the message from F j to variable x i ), we create a search tree T (d k i ) as follows:</p><formula xml:id="formula_29">2: compute ⊥(x i ) = j∈M i F j (x i ) 3: compute (x i ) = j∈M i F j (x i</formula><p>• The root r of T (d k i ) is a partial joint action dr = ∅, . . . , ∅, d k i , ∅, . . . , ∅ , which indicates that x i has been assigned the value d k i , and the remaining variables are unassigned (denoted by ∅). • The set of children of a node p represented by partial action dp = d (1)  1 , . . . , d (l) l , ∅, . . . , ∅, d k i , ∅, . . . , ∅ is obtained by assigning to the first unassigned variable (x l+1 ) each of its possible actions: Children( dp ) = { d (1)  1 , . . . , d (l) l , d l+1 , ∅, . . . , ∅, d i i , ∅, . . . , ∅ |d l+1 ∈ d l+1 }. Thus, the node dp has |d k+1 | children. • The leafs of the tree represent a (fully determined) joint action: ∀i ∈ N j : x i = ∅. In the search tree, leafs are assigned a value that results from evaluating Eq. ( <ref type="formula">11</ref>) for the corresponding action.</p><p>The leaf with the maximum value found in T (d k i ) represents the action that maximises Eq. (3) for value d k i , and thus has the desired value for r j→i (x i ). Now, to find this value efficiently using branch and bound, we need to be able to find bounds on the maximum value found in a subtree of T (d k i ). These bounds depend on F j and the received messages q k→ j . Now, in many cases we can put bounds on the maximum of the former, that is obtained by further completing a partial joint action in a subtree of T (d i k ). We will show an example case in Section 6, where we apply these techniques on the mobile sensor domain.</p><p>To illustrate this method with a simple example, however, Fig. <ref type="figure" target="#fig_6">10</ref> shows a partially expanded search tree for computing a single element r j→3 (d 1 3 ) of a message from function F j to variable x 3 . Given the lower and upper bounds on the maximum (denoted between brackets), subtree d 1 1 , ∅, d 1   3 can be pruned immediately after expanding the root. Similarly, subtree</p><formula xml:id="formula_30">d 3 1 , ∅, d 1 3 is pruned after expanding leaf d 2 1 , d 2 2 , d 1</formula><p>3 , which has the desired maximum value. Now, since the utility functions F j are domain dependent, there is no general way of computing the aforementioned bounds. However, in most domains, such as the mobile sensor domain which will be introduced in Section 6, a partial joint action has a meaningful interpretation that can lead to an intuitive way of computing the bounds on the maximum of F j in any subtree of T . We will come back to this in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">The mobile sensor domain</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notation used in this section</head><formula xml:id="formula_31">• S = {S i |i = 1 . . . M} is the set of M mobile sensors. • G = (V , E) is the layout of the physical environment.</formula><p>• E is the possible movements between locations V , with each v ∈ V embedded in a 2D plane.</p><p>• P is the spatial phenomena that is monitored by the sensors.</p><p>• T = {t 1 , t 2 , . . .} is a sequence of discrete timesteps of unknown length. • K (X, X ) is the covariance matrix.</p><p>• σ f is the hyperparameter that models the signal variance of the phenomenon.</p><p>• l is the hyperparameter that models the length-scale of the phenomenon.</p><p>• H( A|B) is the conditional entropy of sample set A given the sample set B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• ρ A (B) is the incremental value of adding sample set A to sample set B.</head><p>In this section we present the mobile sensor coordination problem that illustrates our approach, in which mobile sensors collect measurements of a spatial phenomenon (such as temperature, radiation, pressure and gas concentration) at discrete points in time and space. Using a statistical model, the sensors model and predict values of this phenomenon at locations and times for which samples are not available. Applications for this approach include environmental monitoring, military surveillance, and disaster response, in which mobile sensors can play a crucial role in improving situational awareness. This is a particularly challenging problem because of the sophisticated statistical models needed to represent the environmental phenomena, and the fact that sensors have to coordinate to collect informative measurements as a team. These properties make it an interesting benchmark problem for the techniques developed in previous sections.</p><p>This section is organised as follows. First, we formalise the mobile sensor coordination problem in Section 6.1. In Section 6.2, we show how spatial phenomena can be modelled using a Gaussian process. Next, we show how to apply the max-sum algorithm by defining the coordination problem in terms of decision variables and utility functions in Sections 6.3.1 and 6.3.2. Finally, we empirically evaluate the max-sum algorithm in this domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Problem formulation</head><p>In this section we present a formalisation of the environmental monitoring problem for multiple mobile sensors. This formalisation is inspired by <ref type="bibr" target="#b35">[36]</ref>, and has been extended for multiple sensors with limited local knowledge.</p><p>Intuitively, an environment is defined by its physical layout, and by the phenomenon that exist within it. More formally, we can denote an environment and the mobile sensors by a tuple E = (S, G, P, T ), where:</p><formula xml:id="formula_32">• S = {S i | i = 1 . . . M} is the set of M mobile sensors;</formula><p>• G = (V , E) encodes the layout of the physical environment, where E denotes the possible movements between locations V , with each v ∈ V embedded in a 2D plane; • P is a spatial phenomena that is monitored by the sensors in S. Here, we explicitly model phenomenon P as a scalar field defined on one temporal and two spatial dimensions: P : V × T → R. • T = {t 1 , t 2 , . . .} models time as a sequence of discrete timesteps of unknown length. 18   Furthermore, we denote the sensors' locations at time t ∈ T by the M-tuple L t = (l </p><formula xml:id="formula_33">l i t+1 ∈ adj G (l i t ).</formula><p>To illustrate this formal model with an example, Fig. <ref type="figure" target="#fig_0">11</ref> shows the position of a team of four sensors in an example environment during the first four timesteps.</p><p>Given this model, the sensors' challenge is to monitor P at all locations V at time t. Since the number of sensors M is generally much smaller than |V |, the sensors need to not only take measurements at locations L t , but also predict the value of P at time t for every location V , based on observations made earlier. In order to do this, we associate to the measurement at location v ∈ V at time t a continuous random variable X v,t , and use a statistical model to predict values at locations V . As we shall discuss in the next section, we will model the phenomenon P with a Gaussian process, that encodes both its spatial and temporal correlations. Now, in order to move in such a way to collect those samples that improve the accuracy with which measurements at unobserved locations can be predicted, the sensors need to be able to determine the informativeness of samples that may be collected along their path. Here, the informativeness of a set of samples is quantified by a function f (X ) of a set of random variables X = {X (1) , X (2) , . . .} that correspond to these samples. Depending on the context, f (X ) can take on different forms <ref type="bibr" target="#b35">[36]</ref>. In this paper, f (X ) equals the entropy H(X ) of X . 19   To measure the performance of the sensors, we use the root mean squared error (RMSE) of the sensors' predictions. <ref type="foot" target="#foot_15">20</ref>In order to so, we denote the predictions that the sensors make at time t by P t = {p v t | v ∈ V } and the actual values of the environmental parameter at those locations by</p><formula xml:id="formula_34">A t = {a v t | v ∈ V }.</formula><p>The RMSE for timestep t is then defined as:</p><formula xml:id="formula_35">RMSE t = v∈V (a v t -p v t ) 2 |V | (12)</formula><p>In the upcoming sections we will show how the max-sum algorithm can be employed to minimise the RMSE. First, however, we will explain how the spatial phenomena are modelled, and how we obtain a measure of uncertainty about the state of the spatial phenomenon that is strongly correlated with the RMSE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Modelling the spatial phenomena</head><p>In order to predict measurements at unobserved locations, we model the spatial phenomenon P with a Gaussian process (GP) <ref type="bibr" target="#b38">[39]</ref>. A GP is a principled Bayesian method of performing inference over functions, and have been shown to be very suitable for modelling spatial phenomena <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b40">41]</ref>. By using a GP, P can be estimated at any location and at any point in time using the set of samples collected by the sensors so far. <ref type="foot" target="#foot_16">21</ref>In more detail, a single sample o of the scalar field P is a tuple x, y , where x = (v, t) denotes the location and time at which the sample was taken, and y the measured value. Now, if we collect the location vectors x in a matrix X, and the measurements y in a vector y, the predictive distribution of the measurement at spatio-temporal coordinates x * , conditioned on previously collected samples O t = X, y is Gaussian with mean μ and variance σ 2 given by:</p><formula xml:id="formula_36">μ = K (x * , X)K (X, X) -1 y (13) σ 2 = K (x * , x * ) -K (x * , X)K (X, X) -1 K (X, x * ) (14)</formula><p>where K (X, X ) denotes the matrix of covariances for all pairs of rows in X and X . Each element of this covariance matrix is obtained by evaluating a function k(x, x ), called a covariance function, which encodes the spatial and temporal correlations of the pair (x, x ). Generally, covariance is a non-increasing function of the distance in space and time, and a prototypical choice of a covariance function is the squared exponential function where the covariance decreases exponentially with this distance:</p><formula xml:id="formula_37">k x, x = σ 2 f exp - 1 2 x -x 2 /l 2 (<label>15</label></formula><formula xml:id="formula_38">)</formula><p>18 In uncertain and dynamic scenarios, the mission time is often not known beforehand. 19 Here we exploit one of the attractive properties of the Gaussian process, whereby the uncertainty of a sample at any point in time or space can be predicted without having to explicitly reason about the actual value of P. For more details about the reasons for choosing this metric, see <ref type="bibr" target="#b26">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 11.</head><p>Four timesteps of a team of sensors S = {S 1 , S 2 , S 3 , S 4 } moving in an environment whose layout is defined by a graph G = (V , E), pictured in grey. E contains a pair of locations (v i , v j ) when they are less than 7.5 meters apart. The initial deployment of the sensors is</p><formula xml:id="formula_39">L 1 = (v 1 , v 1 , v 1 , v 1 )</formula><p>, where v 1 = (0.5, 17) ∈ V (if sensors occupy the same location, only one of them is shown). Phenomenon P is not shown.</p><p>where σ f and l are called hyperparameters that model the signal variance and the length-scale of the phenomenon respectively. The former models the amplitude of the signal, while the latter determines how quickly the phenomenon varies over time and space. <ref type="foot" target="#foot_17">22</ref>One of the key features of the GP is that the posterior variance in Eq. ( <ref type="formula">14</ref>) is independent of actual measurements y. This allows the sensors to determine the entropy reduction that results from collecting samples along a certain path without the need of actually collecting them. Moreover, since the predictive distribution is Gaussian, the entropy H(X ) of random variables X corresponding to a set of potential samples is ln √ 2π σ 2 e, where σ 2 is directly obtained from Eq. ( <ref type="formula">14</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Applying the max-sum algorithm</head><p>In order to apply the max-sum algorithm to the coordination problem defined in Section 6.1, we need to define a mapping between the concepts of the max-sum algorithm and the concepts in the mobile sensor domain. The three key concepts in max-sum are agent, variable and utility function, which we map to sensor, decision variable and information value respectively. In this mapping, each sensor S i is modelled as an autonomous agent A i that has a single decision variable p i (p for 'path'). This variable represents the path that it will travel along in the next l timesteps. This variable and its domain will be defined in Section 6.3.1. The information value function U i , or utility function, encodes the value of the samples that are collected along a sensor's path, given the paths along which the other sensors decide to move. Thus, U i depends on p i and (a subset of) the other sensor's variables. These functions will be defined in Section 6.3.2. By applying max-sum in this fashion, we aim to find a collection of paths (a joint path) of finite length along which sensors collectively gather the samples of maximum value. Clearly, if these paths are of length l, the sensors will need to use max-sum to coordinate their moves every m l timesteps. After following (a portion of) their paths, the sensors' action space will have changed, and so will their utility functions. Therefore, the factor graph encoding the current coordination problem changes over time, and consequently, the sensors interleave coordinating using the max-sum algorithm with movement through their environment.</p><p>In the remainder of this section, we show how the variables of the factor graph are defined, as well as the functions. Furthermore, we show that the sum of individual sensors' utilities equals the utility of the team, and, as a result of which, we can use max-sum to find the paths that maximise team utility (as described in Eq. ( <ref type="formula">1</ref>)). Finally, we show how to apply the pruning algorithms from Section 5 by computing the various required bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1.">Decision variables</head><p>In Section 6.1 we defined the graph G that defines the layout of the sensors' environment. Observations can only be collected at the vertices of G, and moves between two vertices are only allowed if this graph contains an edge between them. As a result, the set of observations A i that sensor i can collect is restricted by its current location and the layout of the environment. Now, given a sensor's current location v i , and path length l, the set of all possible paths that the sensor can currently consider is denoted by d i . The joint action space d of the team of sensors is then the Cartesian product of all individual action spaces: d = × M i=1 d i . Each element d ∈ d is thus a collection of M paths of length l; one for each sensor. An example of such a joint move for three sensors, consisting of a path of length 5 for each of them, is shown in Fig. <ref type="figure" target="#fig_7">12</ref>. Specifically, a joint move is an ordered list of vertices of G, at each of which the sensor makes an observation of the spatial phenomenon.</p><p>Thus, there exists a correspondence between a path and a collection of random variables that are observed along that path. Therefore, with some slight abuse of notation, we can treat every element in d as both a path and a set of (potential) samples. Thus, we can now assign to each sensor i a decision variable p i , which takes values in the set d i , representing all moves that sensor i is currently considering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2.">Utility functions</head><p>Given the definition of the function f that assigns a value to a set of samples, the team utility of collecting a set of samples A, given that samples B were collected previously is equal to the conditional entropy of A given B and is denoted by H( A|B). By exploiting the chain rule of entropy, which states that H( X, Y ) = H( X|Y ) + H(Y ), we can decompose the team utility of collecting A into a sum of the utility obtained by single sensors that each collect a subset A i of A, such that M i=1 A i = A, as follows: where ρ A (B) is defined as the incremental value of adding A to B: ρ</p><formula xml:id="formula_40">H( A|B) = H( A 1 |B) + H( A 2 |A 1 , B) + • • • + H( A n |A 1 , . . . , A n-1 , B) = H( A 1 ∪ B) -H(B) + H( A 1 ∪ A 2 ∪ B) -H( A 1 ∪ B) + • • • + H( A 1 ∪ • • • ∪ A n ∪ B) -H( A 1 ∪ • • • ∪ A n-1 ∪ B) = ρ A 1 (B) + ρ A 2 (A 1 ∪ B) + • • • + ρ A n (A 1 ∪ • • • ∪ A n-1 ∪ B) = n i=1 ρ A i i-1 j=1 A j ∪ B (16)</formula><formula xml:id="formula_41">A (B) = H( A ∪ B) -H(B).</formula><p>Informally, Eq. ( <ref type="formula">16</ref>) ensures that the team utility is a sum of the incremental values by adding samples A i to the samples collected by sensors j &lt; i. We will call the individual factors of this sum the sensor utility.</p><p>Definition 1 (Sensor utility). Sensor i's contribution to the team utility is:</p><formula xml:id="formula_42">U i (A 1 , . . . , A i ) = ρ A i i-1 j=1 A j ∪ B</formula><p>So, in order to calculate its utility, a sensor need only be aware of the samples collected by sensors with a lower ID. Moreover, by summing the contributions by individual sensors, we obtain</p><formula xml:id="formula_43">H( A|B) = H( A 1 ∪ • • • ∪ A M |B)</formula><p>, which is the team utility. Note, that it is possible to further factorise the utility functions if the samples collected by one agent are independent of those of another agent. In this case, the edge connecting the function node of each of these agents to the variable node of the other agent can be removed. The correlation length of the Gaussian process provides a clear metric to perform this edge removal. However, in this evaluation, we do not do so, since this edge removal is effectively performed by the construction of the maximum spanning tree within the bounded max-sum algorithm.</p><p>Combining this observation with the definition of the sensors' decision variables and the correspondence between observation sets and paths, the goal of the team is now to find joint move p * such that:</p><formula xml:id="formula_44">p * = p * 1 , . . . , p * M = arg max p 1 ∈A i ,...,p M ∈A M M i=1 U i (p 1 , . . . , p i )<label>(17)</label></formula><p>In other words, the sensors attempt to find joint move p * that maximises the team utility by maximising the sum of their contributions as defined in Definition 1. Since the team utility is the sum of the sensors' utility functions, max-sum can be readily applied to solve this coordination problem.</p><p>Finally, to give an example of a factor graph resulting from combining the variables from the previous section with the utility functions defined in this section, Fig. <ref type="figure" target="#fig_8">13</ref> shows the factor graph for solving the coordination problem with four sensors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3.">Applying the pruning algorithms</head><p>As mentioned in Section 5, the straightforward application of max-sum in domains where the utility functions are expensive to evaluate leads to a prohibitive computational cost. Clearly, this the case in the mobile sensors domain, where determining the value of a sample involves the inversion of a potentially very large matrix K (X, X) (see Eq. ( <ref type="formula">14</ref>)). Thus, the use of the pruning algorithms presented in Sections 5.1 and 5.2 could be particularly advantageous in this setting. Now, in order to compute the necessary bounds for these two pruning algorithms, we need to use domain specific knowledge, since these bounds are context dependent. In particular, we will exploit various properties of the GP in order to efficiently compute (approximations to) these bounds.</p><p>Firstly, we derive the bounds on the utility functions for the pruning algorithm from Section 5.1. Note that, given the highly non-linear relations expressed in Eq. ( <ref type="formula">14</ref>) on which the agents' utility functions U i are based, it is very difficult to compute tight bounds on U i and U i in Algorithm 1 without exhaustively searching the domain of p i for utility function U i . Needless to say, this would defeat the purpose of this pruning technique. Nonetheless, experimentation shows that by computing these bounds in a greedy fashion, a very good approximation is obtained. In order to do this, the lower bound U i (p n ) on a move p n is obtained by selecting the neighbouring agents one at a time, and finding the move that reduces the utility of agent i's move the most. In a similar vein, the upper bound U i (p n ) is obtained by selecting those moves of other sensors that reduce the utility the least.</p><p>Next, we derive bounds on the maximum utility found in subtrees T -the search tree for the joint action pruning algorithm defined in Section 5.2. To compute these bounds on U i ( d), for a partial joint action d, first note that this partial joint action represents a situation in which only a subset of the sensors have determined their move. Using this interpretation, we can obtain bounds as follows. The upper bound on this value is obtained by disregarding the sensors that have not yet determined their move (i.e. sensors i for which p i = ∅). To see why this results in an upper bound, note that the act of collecting a sample always reduces the value of other samples (an example of the information never hurts principle), disregarding the samples of these 'undecided' sensors will give an upper bound on the maximum. Thus, this value is computed by evaluating a modified version of the utility function as follows: U i ({p j ∈ p i : p j = ∅}).</p><p>To obtain a lower bound on the maximum, we exploit a property of the covariance function in Eq. ( <ref type="formula" target="#formula_37">15</ref>). This property causes the interdependency between the value of samples to weaken as the distance between them increases. So, in order to calculate a lower bound on the maximum, we compute the value of the sample in the event that the undecided sensors move away from sensors i's destination. This results in minimum correlation between the sample and the samples collected by the undecided sensors, thus increasing the value of this sample. In many cases, this results in a very tight lower bound on the maximum of the sample.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Empirical evaluation</head><p>In this section, we evaluate the algorithms developed in this paper on the mobile sensor domain to ascertain their effectiveness in a setting inspired by a real-life application. Specifically, we first evaluate the speed up resulting from applying the pruning algorithms described in Section 5. The mobile sensor setting is a very suitable candidate to do this, since the computational overhead incurred by evaluating the utility functions is significant in this setting. Second, we evaluate the bounded max-sum algorithm from Section 4 in combination with these pruning algorithms, and determine the difference between the difference between the optimal and obtained solution. This evaluation is similar to Section 4.4, however, instead of considering randomly generated coordination problems, we use the more realistic mobile sensor domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.1.">Effectiveness of the pruning algorithms</head><p>To empirically evaluate the two pruning algorithms in the mobile sensor domain, we simulated five sensors on a lattice graph measuring 26 by 26 vertices. The data was generated by a GP with a squared exponential covariance function (see Eq. ( <ref type="formula" target="#formula_37">15</ref>)) with a spatial length-scale of 10 and a temporal length-scale of 150. This means that the spatial phenomenon has a strong correlation along the temporal dimension, and therefore changes slowly over time. <ref type="foot" target="#foot_18">23</ref>Now, at every m time steps, the sensors plan their motion for the next l time steps (l m). In what follows, this strategy is referred to as MSm-l. Now, instead of considering all possible paths of length l from an agent's current position, which would result in a very high computational overhead, the action space is limited to the locations in G that can be reached in l time steps in 8 different directions, corresponding to the major directions on the compass rose. In the first experiment, we benchmarked MS1-1 and MS1-5 against four strategies often found in the literature:</p><p>• Random: Randomly moving sensors.</p><p>• Greedy: Sensors that greedily maximise the value of the sample collected in the next move without coordination. This strategy was included to determine the effect of coordination between sensors.</p><p>• J(umping) Greedy: The same as Greedy, except that these sensors can instantaneously jump to any location. This strategy will act as an upper bound on the achievable performance of a greedy strategy, since it is not constrained by the movement graph G.</p><p>• Fixed: Fixed sensors that are placed using the algorithm proposed in <ref type="bibr" target="#b36">[37]</ref>. This is an algorithm that positions fixed (i.e. non-mobile) sensors as to minimise the entropy at all monitored locations.</p><p>The average root mean squared error (RMSE) over 100 time steps is plotted in Fig. <ref type="figure" target="#fig_9">14(a)</ref>. From this figure, it is clear that both MS strategies outperform the Greedy and Random strategies, since both have no more than one step look ahead, and the MS strategies compute coordinated paths of length 1 and 5. Furthermore, the prediction accuracy of MS1-5 is comparable to that of JGreedy, whose movement is not restricted by graph G. Moreover, it shows that increasing the look ahead improves the solution quality: the length of the considered paths from 1 to 5 reduces the RMSE by approximately 30%.</p><p>In the second set of experiments, we analysed the speed-up achieved by applying the two pruning techniques described in Section 5. Fig. <ref type="figure" target="#fig_9">14(b)</ref> shows the percentage of joint actions pruned plotted against the number of neighbouring agents. With 5 neighbours, the two pruning techniques combined prune around 92% of the joint moves. With such a number of neighbouring agents, the agents are strongly clustered, which occurs rarely in a large environment. However, should this happen, the utility function needs to be evaluated for only 8% of roughly 8 5 joint actions, thus greatly improving the algorithm's efficiency.</p><p>In the third experiment, we performed a cost/benefit analysis of various MSm-l strategies. More specifically, we examined the effect of varying m and l on both the number of utility function evaluations, and the resulting RMSE. Fig. <ref type="figure" target="#fig_9">14(c</ref>) shows the results. The results of MS1-1, MS2-2, MS4-4, MS5-5, and MS8-8 show an interesting pattern. Up to and including m = l = 4, both the number of function evaluations and the average RMSE decrease. This is due to the fact that planning longer paths is more expensive, but results in lower RMSE. However, for m, l &gt; 4, the action space becomes too coarse (since only 8 directions are considered) to maintain a low RMSE. At the same time, the number of times the agents coordinate reduces significantly, resulting in a lower number of function evaluations. Finally, MS1-5 and MS4-8 provide a compromise; they compute longer paths, but coordinate more frequently. This leads to more computation compared to MS5-5 and MS8-8, but results in significantly lower RMSE, because agents are able to 'reconsider' their paths midway.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.2.">Empirical evaluation of the bounded max-sum algorithm</head><p>In the previous set of experiments, we focused exclusively on the effectiveness of the pruning algorithms in a setting where the evaluation of utility function is computationally demanding. In the second set, we combined the pruning algorithms with the bounded max-sum algorithm presented in Section 4 to determine whether (i) the optimal solution is preserved by using the pruning algorithms, and (ii) to determine the solution quality provided by the bounded max-sum algorithm compared to the optimal solution computed by enumerating the entire joint action-space. The latter presents an empirical estimation of the approximation computed by this algorithm in a realistic and demanding setting.</p><p>In more detail, these experiments used the same environment layout and GP settings as before. During each simulation, which lasted for 200 timesteps, the sensors computed paths of length 8 at 4 timestep intervals (i.e. MS4-8). We performed simulations with 3, 4, 5, and 6 sensors, both with and without the action pruning algorithm from Section 5.1, starting the sensors from random locations in each run. In what follows, the simulation with M sensors, and pruning turned on is denoted by PM, and with pruning turned off, by NPM. In both case, the joint action pruning algorithm from Section 5.2 was always used.</p><p>Fig. <ref type="figure" target="#fig_10">15</ref>(a) shows the average utility obtained during 200 timesteps of the simulation over twenty repetitions. In particular, it reports the four metrics described in Section 4.4. The results show that the solution computed using the bounded max-sum algorithm is very close to the optimal solution. More specifically, the minimum ratio between the computed solution and the optimal solution over 160 runs was 98%, thus showing that the use of this algorithm leads to very good approximations to the optimal solution. Moreover, the graph shows that the use of the pruning techniques results in a slight tightening of the bound on the optimal solution. More importantly, it corroborates the theoretical claim that the optimal solution is preserved when applying the pruning algorithms (see Section 5.1).</p><p>Fig. <ref type="bibr">15(b)</ref> shows the benefits of applying the two pruning algorithms more clearly. This figure includes four key metrics:</p><p>1. Cache misses: the number of times the utility functions actually needed to be evaluated for different joint actions.</p><p>2. The total number of function calls.</p><p>3. The number of nodes that needed to be expanded in the search tree (described in Section 5.2) to find the optimal value. 4. The total number of nodes that the full search tree contains.</p><p>From this figure, we note that the action pruning approach described in Section 5.1 results in reductions in all four of these metrics of approximately one order of magnitude. By removing dominated action choices, the coordination problem is simplified and agents need perform less evaluations of the costly utility function. Furthermore, we note that the joint action pruning algorithm described in Section 5.2 results in a reduction in the number of nodes of the search tree that must be expanded, compared to the total number of nodes in the tree, of up to two orders of magnitude. <ref type="foot" target="#foot_19">24</ref>Fig. <ref type="figure" target="#fig_10">15</ref>(c) shows the required amount of communication needed for coordination. The most notable conclusion that can be drawn from this figure is the strong reduction in message size when the action pruning algorithm is used. Since the action space of individual sensors is reduced by pruning dominated actions, the number of values contained in the messages exchanged between functions and variables (Eqs. ( <ref type="formula">2</ref>) and ( <ref type="formula" target="#formula_4">3</ref>)) is significantly reduced, resulting in a lower communication overhead.</p><p>Finally, Fig. <ref type="bibr">15(d)</ref> shows the obtained solution quality in terms of the average RMSE. Unlike the utility reported in Fig. <ref type="figure" target="#fig_10">15</ref>(a), this figure shows a slight decrease in solution quality when using the pruning algorithms. This is caused by the fact that the sensors minimise entropy in their environment, which, despite being strongly linked, does not directly translate into a decrease of RMSE. Put differently, directed by the utility function that incentivises entropy reduction, the pruning technique in Section 5.1 that operates on the action space of individual agents, prunes actions that would have led to lower RMSE. Fortunately, this effect is limited, as the maximum increase of RMSE found over 160 runs was only 3.5%.</p><p>In summary, in this section, we demonstrated the effectiveness of the bounded max-sum algorithm and the two pruning algorithms in a setting where the utility functions are computationally expensive to evaluate. We showed that, by using the two pruning algorithms, the number of function evaluations is reduced by roughly two orders of magnitude for a joint action space of size 8 6 . Moreover, the results showed that by using the bounded max-sum results, we obtain solutions that are guaranteed to be no further away than 2% from the optimal solution. Generalising from these specific results, these experiments clearly show the effectiveness of the developed techniques for real-life applications with complex interactions between agents.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related work</head><p>As described in the introduction, approximation ratios have previously been provided for k-optimal algorithms in the area of DCOPs <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>. In this case, the k-optimal solution for a DCOP is a solution that cannot be improved by changing the assignment of any k or less variables. Many well known local algorithms for DCOPs are guaranteed to provide k-optimal solutions. In particular, any locally hill climbing algorithm is k-optimal for k = 1, such as for example DSA <ref type="bibr" target="#b0">[1]</ref> and MGM <ref type="bibr" target="#b9">[10]</ref>. While, a k = 2 variant of MGM, termed MGM-2, has been presented <ref type="bibr" target="#b9">[10]</ref>. Specifically, Pearce and Tambe provide approximation ratios which are valid for any DCOP with non-negative reward structure, and which are dependent on the arity of the constraint functions, the number of agents participating in the DCOP and the value of k. Moreover, they provide both general bounds which are not dependent on the constraint graph structure, and tighter bounds for specific structures (e.g. ring and star graph structures). More recently, Bowring et al. have improved on this bound by assuming a priori information concerning the DCOP reward structure <ref type="bibr" target="#b15">[16]</ref>. With respect to this work, our approach is somewhat complementary, as here we provide an approximation ratio which is more accurate but is dependent on the specific problem instance, while their approach provides a less accurate bound which, in turn, is more general. In more detail, the approximation ratio provided within the k-optimality framework is dependent on the number of agents and thus scales poorly when the number of agents in the system grows. <ref type="foot" target="#foot_20">25</ref> Conversely, our approximation ratio is dependent on the reward structures (because it requires functions to be bounded), and on the constraint graph structure (because it is more accurate when less cycles are present in the constraint network). However, it is not dependent on the number of agents present in the system and, since it exploits the specific constraint graph structure, it is able to provide very accurate approximation ratios.</p><p>An alternative approximation approach, proposed by Yeoh et al., is based on the ADOPT algorithm, and its extension BnB-ADOPT <ref type="bibr" target="#b18">[19]</ref>. This algorithm fixes a predetermined error bound for the optimal solution, and stops when a solution that meets this error bound is found. Their approach is similar to our work in that it is dependent on the problem instance. Specifically, in their case, the error bound is fixed and the algorithm will stop only when such a bound is obtained. The number of cycles required by the algorithm to converge is dependent on the particular problem instance, and, in the worst case, remains exponential. Our approach in contrast, is guaranteed to converge after a polynomial number of cycles (i.e., twice the depth of the tree structured factor graph), but the approximation ratio is dependent on the particular problem instance. Therefore, our approach tries to minimise computation and communication, by trading off solution quality. This requirement is driven by our focus on decentralised coordination for embedded agents, where constraints on communication and computation are crucial for the practical applicability of the coordination approach.</p><p>Similar considerations hold with respect to A-DPOP <ref type="bibr" target="#b17">[18]</ref>, an extension of the DPOP algorithm that computes approximate solutions. A-DPOP attempts to reduce message size (which is exponential in the original DPOP algorithm in the width of the pseudo tree) by optimally computing only a part of the messages and approximating the rest (with upper and lower bounds). Given a fixed approximation ratio, A-DPOP can then reduce message size to meet this ratio, or alternatively, given a fixed maximum message size, it propagates only those messages that do not exceed that size. As a result of this, the computed solution is not optimal, but approximate. Moreover, as discussed above, since the algorithm fixes a desired approximation ratio, the message size remains exponential. In contrast, if we would fix the maximum message size in our approach, the approximation ratio is dependent on the specific problem instance. Furthermore, note that in the A-DPOP case, there is no mechanism to minimise the approximation ratio, which in our approach is provided by considering the maximum spanning tree of the constraint network. <ref type="foot" target="#foot_21">26</ref>Our use of tree structures to obtain an approximation of the original problem shares similarities with previous work in information theory where a dependence tree is used to approximate a generic joint probability distribution of random discrete variables. In particular, it has been shown that a maximum weight dependence tree provides the best tree approximation of the joint probability distribution <ref type="bibr" target="#b41">[42]</ref>. In contrast, our contribution addresses a decentralised decision problem as opposed to a centralised tree parametrisation of an unknown joint probability. Consequently, we provide the approximation ratio for our optimisation problem and we consider generic n-ary relationships among variables as opposed to the binary dependence considered in <ref type="bibr" target="#b41">[42]</ref>. Techniques based on tree-decomposition have also been previously used in the area of constraint optimisation. In particular, in <ref type="bibr" target="#b42">[43]</ref> the authors focus on providing bounds on the best-cost extension of a set of variables (i.e., the best value that the target function can achieve for all the possible joint values of the variable set), given a tree-decomposition. <ref type="foot" target="#foot_22">27</ref> In contrast, here we focus on removing cycles from the original problem instance to optimise the approximation ratio, maintaining a low communication and computation overhead, because we focus on decentralised coordination for resource constrained embedded agents.</p><p>Finally, our action pruning approach shares some similarities with the directed soft arc consistency approach proposed by Matsui et al. <ref type="bibr" target="#b43">[44]</ref>. This work proposes a distributed algorithm to perform directed soft arc consistency on pseudo-trees, and shows that this approach can be efficiently combined with common search algorithms (e.g., ADOPT). Our action pruning approach has a similar spirit as it is a distributed preprocessing scheme that results in a faster algorithm. Moreover it is somewhat similar to standard arc consistency for constraint satisfaction problems as it tries to delete useless values from variable domains. However, our action pruning approach, in contrast to the method presented in <ref type="bibr" target="#b43">[44]</ref>, does not try to reduce the range of the values of the functions. This is motivated by the fact that max-sum is not a search algorithm and so it would not benefit from such reduction as it is the case with search algorithms such as ADOPT. Here, we are more concerned to reduce the number of actions that each functions must consider when computing the messages of the max-sum algorithm as this is the main source of algorithm's computational complexity. Nonetheless, applying soft arc consistency could potentially result in a better approximation ratio for the bounded max-sum, as reducing the range of the cost functions could result in smaller weights. However further investigations would be required to see whether the pre-processing overhead to apply directed soft arc consistency would be worth the possible reduction in the approximation ratio, and this falls outside the scope of the current paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusions and future work</head><p>In this paper we proposed a novel approach to decentralised coordination which is particularly suited for embedded computationally constrained agents. Our approach is based on a factor graph representation of the constraint network (i.e. the interactions between agents) and builds on the max-sum algorithm. Our approach guarantees accurate bounded approximate solutions, while maintaining a very low computation and communication overhead. Given any particular instance of a general constraint network, our approach is able to compute a solution and to provide an approximation ratio for the unknown optimal solution. This is achieved without incurring the typical exponential cost of optimal approaches, thus resulting in a very effective and efficient technique. Moreover, by applying two novel generic pruning techniques, we are able to reduce the computation that each agent must perform when computing the approximate solution, thus further improving the computational efficiency of our approach.</p><p>We apply our approach in a mobile sensor domain to assess its practical benefits. In this domain mobile sensors must coordinate their actions to gather the most informative measurements from the environment. In this setting, we develop a factor graph representation for this specific coordination problem, and show how our approach can be used as a solution technique. Moreover, we show how the two developed pruning techniques can be used in this specific domain to further speed up the max-sum message computation. Empirical results showed that our novel technique is extremely effective, providing accurate solutions which are guaranteed to be no further away than 2% from the optimal. Moreover, the use of the pruning techniques proved to be very successful in speeding-up the computation of the max-sum message: for 5 sensors, these techniques prune 92% of joint moves, thus significantly reducing the number of utility function evaluations, which are particularly expensive in our domain.</p><p>Many possible future directions stem from this work. A first interesting research direction is to investigate techniques to further reduce the approximation ratio. A possible approach is to iteratively apply our algorithm while clustering variable and function nodes (as proposed in <ref type="bibr" target="#b31">[32]</ref>) to remove cycles without removing dependencies. In this way, we can iteratively decrease the approximation ratio (by removing less dependencies) while paying an increase in communication and computation (due to clustering of nodes), thus allowing a flexible trade-off between solution quality and communication and computation overhead. In this respect, it would also be interesting to consider the use of state of the art techniques for constraint satisfaction. As mentioned in the previous section, soft arc consistency could be applied, as proposed in <ref type="bibr" target="#b43">[44]</ref>, to preprocess the constraint network before applying our approach. Another interesting possibility would be to investigate the use of cutset schemes to obtain tree-structured network <ref type="bibr" target="#b24">[25]</ref>. For example, the cycle cutset decomposition could be used to completely remove cycles, or alternatively, more general cutset schemes (b-cutset) could be exploited to obtain constraint networks with a bounded induced width. A similar approach has already been successfully used in <ref type="bibr" target="#b12">[13]</ref>, and in this context, our idea of finding a maximum-weight spanning tree could be used as an heuristic to choose the cutset variables.</p><p>A second interesting direction is to investigate the use of region based message passing techniques, such as the family of generalised belief propagation approaches <ref type="bibr" target="#b44">[45]</ref>, as solution techniques for our constraint network. GBP is a generalisation of the standard GDL techniques (such as max-sum) and operates on a region graph, which is obtained by dividing the factor graph into specific regions based on the factor graph topology. <ref type="foot" target="#foot_23">28</ref> Messages are then computed for regions and sent from one region to another. Recent empirical results show that region based techniques such as GBP are able to outperform standard GDL techniques, with a minimal extra cost in terms of computation. Moreover, GBP has similar guarantees on solution optimality as the standard GDL techniques, namely it is optimal when the region based graph does not contain cycles <ref type="bibr" target="#b44">[45]</ref>. Therefore, investigating possible extensions of our bounded max-sum algorithm to GBP techniques appears to be a promising direction. More generally speaking, the application of GDL-based techniques to decentralised coordination appears to be a very promising direction, resulting in effective and efficient solutions. Furthermore, many important aspects which are specific to the coordination of embedded agents still need to be investigated. For example, agents usually have heterogeneous computation and communication capabilities, and this could potentially be taken into account when assigning the responsibility for variables and factor node computation to the different agents in order to better exploit the limited resources of the system.</p><p>Finally, an important research direction is to go beyond the limited look-ahead used here for coordinating the paths of the mobile sensors, and investigate the use of sequential decision making approaches. The sequential aspect is inherent to a wide variety of applications involving embedded agents, however a key issue is to keep the computational costs under control. To this end, the factorisation of the objective function seems to be a promising idea, and again, GDL-based approaches appear to be very well suited solution techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A. Proof of bounded approximation</head><p>To prove Theorem 1 we first introduce and prove the following lemma:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B W (19)</head><p>Proof. We can rewrite the above inequality as:</p><formula xml:id="formula_45">i B i x c i i, j ∈C w ij</formula><p>where C is the set of couples of indices i, j that identify the edges removed from the factor graph. We can prove this inequality by showing that ∀i B i (x c i ) j∈I(x c i ) w ij where I(x c i ) is the set of variable indexes which have been removed. We proceed by expanding B i (x c i ) as defined in Eq. ( <ref type="formula" target="#formula_18">6</ref>) and w ij as defined in Eq. ( <ref type="formula">5</ref>) to give: max</p><formula xml:id="formula_46">x t i max x c i F i x t i ; x c i -min x c i F i x t i ; x c i j max x i \ j max x j F i (x i ) -min x j F i (x i )</formula><p>For functions that have no dependencies removed we have x c i = ∅, therefore B i (∅) = 0. Consequently, I(x c i ) = ∅, and thus, since the sum of the weight will be zero, the above inequality holds. For functions that have at least one dependency removed, we can substitute the left term of the above inequality with: max</p><formula xml:id="formula_47">x t i max j max x c i \ j max x j F i (x i ) -min x j F i (x i )</formula><p>However, this term is less than or equal to: max</p><formula xml:id="formula_48">x t i j max x c i \ j max x j F i (x i ) -min x j F i (x i )</formula><p>which, in turn, is less than or equal to the right-hand side of our original expression. 2</p><p>Theorem. Bounded approximation i min</p><formula xml:id="formula_49">x c i F i (x i ) + B i F i x * i (<label>20</label></formula><formula xml:id="formula_50">)</formula><p>Proof. By considering the definition of x given in Eq. ( <ref type="formula" target="#formula_21">7</ref>), we can write the following inequality:</p><formula xml:id="formula_51">i min x c i F i (x i ) i min x c i F i x * i</formula><p>This inequality holds because x is defined as the assignment that maximises the problem on the tree structured network, and thus, the value given by that assignment on the tree structured problem will be higher or equal than any other possible assignment. Specifically, it will be greater or equal than the optimal assignment of the original problem x * , and thus, we can write: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Derivation of worst case approximation ratio</head><p>We derive here the worst case approximation ratio ρ = M/m starting from the ρ FG .</p><p>Derivation of worst case approximation ratio. The worst case, for ρ FG , happens when the optimal solution on the spanning tree equals the optimal solution evaluated on the original graph. This is the worst case because the approximation ratio is directly dependent on Ṽ m and inversely dependent on Ṽ , but we know that Ṽ m Ṽ . Intuitively, this is the worst case since in this case we overestimate the impact of the removed dependency the most (i.e., the actual impact is zero for the computed solution). When Ṽ m = Ṽ we have ρ = 1 + B/ Ṽ m . Moreover, let us denote the maximum ratio between the minimum reward and maximum reward across all functions with M/m where m and M are the minimum and maximum reward for the function that maximises the reward ratio and m i and M i are the minimum and maximum reward for function i. We can then write:</p><formula xml:id="formula_52">ρ = 1 + B |F| i m i = 1 + |F| i (M i -m i ) |F| i m i</formula><p>This is because we assume, being a worst case analysis, that all functions need to have at least one dependency cut, therefore Ṽ m = |F| i m i and that for all functions the dependencies we cut have the highest possible impact on the solution quality (i.e. ∀i B i (x c i ) = M im i ). Then we have ρ</p><formula xml:id="formula_53">= |F| i M i |F| i m i M/m. 2</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. An example factor graph for agents A 1 , A 2 and A 3 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Example of a factor graph containing cycles and a spanning tree formed by removing the edges between the variables nodes x 2 and x 3 and the function node F 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Tree structured factor graph obtained with the bounded max-sum algorithm for the original factor graph of Fig. 2(a).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig.6. Empirical results for the utility when varying the number of agents, the link density and the distribution for payoffs (using graphs from the ADOPT repository).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>4 :Fig. 9 .</head><label>49</label><figDesc>Fig. 9. First iteration of the action pruning algorithm for variable x 1 showing (a) the messages sent by function nodes F 1 and F 2 , and (b) the resulting removal of 'g' from the domain of variable x 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 .</head><label>10</label><figDesc>Fig.10. Search tree for computing r j→3 (d1  3 ) (a single element of the message from F j to x 3 ). The numbers between the brackets indicate lower and upper bounds on the maximum value in the subtree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. A joint move of length 5 for sensors on a lattice graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. A factor graph encoding the mobile sensor coordination problem for four sensors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Empirical results for the pruning algorithms showing (a) the average root mean squared error (RMSE), (b) the percentage of joint actions pruned, and (c) the number of utility function evaluations plotted against the average root mean squared error achieved. Error bars indicate the standard error of the mean.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Empirical results for the bounded max-sum algorithm showing (a) the average utility, (b) the number of cache misses, the total number of utility function calls, the number of expanded partial joint actions (expanded nodes in search tree T ), and the maximum number of partial joint actions that could have been evaluated (total number of nodes in search tree T ), (c) the average root mean squared error (RMSE), (d) the total message size in terms of the number of values exchanged. PM means that M sensors are deployed, and that the action pruning algorithm from Section 5.1 is used, and NPM means M sensors without action pruning. Error bars indicate the standard error of the mean.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>adding the same quantity B to both terms of the equation. Then using Lemma 1 we know that:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>However, this is a contradiction with respect to the definition of x t i . Therefore Lemma 1 must hold. 2</figDesc><table><row><cell cols="3">∀i, x min x c i</cell><cell cols="5">F i x t i ; x c i + B i x c i</cell><cell>max i x c</cell><cell>F i x t i ; x c i</cell><cell>(18)</cell></row><row><cell cols="8">Proof. Expanding B i (x c i ) as defined in Eq. (6) we have:</cell></row><row><cell cols="2">min x c i</cell><cell cols="4">F i x t i ; x c i + max x t i</cell><cell cols="2">max x c i</cell><cell>F i x t i ; x c i -min x c i</cell><cell>F i x t i ; x c i</cell><cell>max i x c</cell><cell>F i x t i ; x c i</cell></row><row><cell cols="8">where x t i = x i \ x c i as in Section 4. By contradiction, let us consider an assignment x t i such that:</cell></row><row><cell cols="2">min x c i</cell><cell cols="5">F i x t i ; x c i + max x t i</cell><cell>max x c i</cell><cell>F i x t i ; x c i -min x c i</cell><cell>F i x t i ; x c i</cell><cell>&lt; max i x c</cell><cell>F i x t i ; x c i</cell></row><row><cell cols="8">We can rewrite the previous expression as:</cell></row><row><cell cols="2">max x c i</cell><cell cols="4">F i x t i ; x c i -min x c i</cell><cell></cell><cell>F i x t i ; x c i &lt; max x c i</cell><cell>F i x t i ; x c i -min i x c</cell><cell>F i x t i ; x c i</cell></row><row><cell>where</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>x</cell><cell cols="3">t i = arg max x t i</cell><cell>max x c i</cell><cell cols="3">F i x t i ; x c i -min i x c</cell><cell>F i x t i ; x c i</cell></row><row><cell cols="2">Lemma 2.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The turbo codes are probably the most important representative application for which GDL techniques are used. See<ref type="bibr" target="#b21">[22]</ref>, Chapter 48.4.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>A path is a sequence of single actions, thus the number of possible paths grows exponentially with the length of the sequence. However, by coordinating on sequences of actions, robots are able to better predict which are the most informative measurements, and thus coordinate more effectively.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>From this point onwards, we shall use the terms 'factor graph' and 'constraint network' interchangeably, and note that agents are responsible for computing and relaying messages of the function and variable nodes that they control.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Note that this normalisation will fail in the case of a negative infinity utility that represents a hard constraint on the solution. However, it is still possible to use the max-sum algorithm in this context by simply replacing the negative infinity reward with one whose absolute value is greater than the sum of the maximum values of each function. This ensures both that the normalisation works correctly, and that the reward is still sufficiently negative to effectively act as a hard constraint (i.e. there can be no solution that violates this constraint that has a higher utility than one that does not).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>The same results hold for the max-sum algorithm as it can be considered as a derivative of the max-product algorithm when we consider the log domain<ref type="bibr" target="#b11">[12]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>For a complete trace of the max-sum algorithm on an exemplar problem, see<ref type="bibr" target="#b11">[12]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_6"><p>Notice that our approach is completely generic with respect to the algorithm used to compute the maximum spanning tree. Here the choice of the GHS algorithm is dictated by the low communication overhead and by the ease of implementation. However, other distributed algorithms do exist which have a lower bound for running time e.g.<ref type="bibr" target="#b32">[33]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_7"><p>Note that, in our case, one of the two core nodes will always be a function node because the factor graph is a bipartite graph, and the core nodes are connected.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_8"><p>In settings where the choice of variable assignment may not be unique (most commonly, when the functions return integer payoffs) an additional value propagation phase may be used at this point. See<ref type="bibr" target="#b33">[34]</ref> for details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_9"><p>Note that these could be propagated in two separate phases, but here we combine them together for efficiency.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_10"><p>The focus on pairwise interactions is a very common approach in the DCOP literature, which is why we pay specific attention to this type of interactions in this section.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_11"><p>For the results reported here we used the code available at http://teamcore.usc.edu/dcop published by the authors of the paper. Specifically, we used the preprocessing policy named DP2 in their paper, which out-performs alternatives in their empirical evaluation. Furthermore, note that ADOPT normally minimises the constraint costs in a DCOP while here we wish to maximise the sum of the rewards. However, since there are no infinitely high rewards in any problem instance considered here, we are able to determine an arbitrary fixed maximum threshold, M, for each specific instance, and then translate the reward function, r(x), to a cost function, c(x), such that c(x) = Mr(x). ADOPT can then be used to solve the resulting minimisation problem.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_12"><p>These values are in the range often used for benchmarking DCOP techniques on random graph colouring instances<ref type="bibr" target="#b4">[5]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_13"><p>The small confidence interval shows that twenty repetitions provide, for our experimental setting, a good sample size to assess the statistical significance of the results.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_14"><p>As in the previous results, the value for the optimal utility is computed by a complete algorithm, and thus, we were able to report values only up to</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="20" xml:id="foot_15"><p>This measure was chosen because it has been often used in related work to ascertain the accuracy of sensor predictions<ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="21" xml:id="foot_16"><p>We chose to use a GP because of its versatile and flexible nature. However, the techniques discussed in the remainder of this section are not specific to the use of a GP to model the environment; any other model can be used, as long as it provides some measure of uncertainty in the environment.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_17"><p>A slightly modified version of Eq. (15) allows for different length-scales for the spatial and temporal dimensions of the process.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="23" xml:id="foot_18"><p>These parameters were chosen to generate challenging coordination instances. For example, by using a high value for the spatial length-scale, sensors are able to cover the entire area without needing to move. Similarly, with a very high value for the temporal length-scale, the sensors need to traverse the environment only once, since the phenomenon changes very little over time. Thus, while not necessarily being the worst-case scenario, the problems generated by setting the parameters to these values represent the most challenging instances we managed to create.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="24" xml:id="foot_19"><p>Note that in settings where the computational cost of performing the utility function evaluation dominants other processing, this will translate into a significant runtime improvement. However, in general, the runtime of the algorithm will also depend on many other domain specific factors (such as the computational resources of the agents, and even the communication delays as they exchange messages).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="25" xml:id="foot_20"><p>See the discussion in Section 4.4 for a more detailed comparison of our approach with<ref type="bibr" target="#b15">[16]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="26" xml:id="foot_21"><p>If we force A-DPOP to have polynomial message size, as it is the case with our approach, the algorithm would compute a DFS tree and remove all other edges, without considering the impact of removed dependencies on the approximation ratio.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="27" xml:id="foot_22"><p>Notice that a tree-decomposition for a Constraint Optimisation Problem is not a spanning tree of the original graph, but a tree that has clusters of variables as vertices, and that satisfies the running intersection property. See<ref type="bibr" target="#b42">[43]</ref> for further details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="28" xml:id="foot_23"><p>A region is formed by a sub-set of factor nodes and all variable nodes that are connected to them. A region usually includes short loops in the factor graph to have good approximations.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This paper is a significantly extended version of paper <ref type="bibr" target="#b26">[27]</ref>. The work reported in this paper was jointly funded by the Systems Engineering for Autonomous Systems (SEAS) Defence Technology Centre established by the UK Ministry of Defence and the ALADDIN (Autonomous Learning Agents for Decentralised Data and Information Systems) project; a BAE Systems and EPSRC (Engineering and Physical Research Council) strategic partnership (EP/C548051/1).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Distributed coordination through anarchic optimization</title>
		<author>
			<persName><forename type="first">S</forename><surname>Fitzpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Meetrens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Distributed Sensor Networks: A Multiagent Perspective</title>
		<imprint>
			<publisher>Kluwer Academic</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="257" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A utility-based adaptive sensing and multi-hop communication protocol for wireless sensor networks</title>
		<author>
			<persName><forename type="first">P</forename><surname>Padhy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Martinez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Sensor Networks</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>Article 27</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Agent technologies for sensor networks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Corkill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intelligent Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="13" to="17" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A unifying framework for iterative approximate best response algorithms for distributed constraint optimisation problems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Leslie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Knowedge Engineering Review</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>in press</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ADOPT: Asynchronous distributed constraint optimization with quality guarantees</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Modi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tambe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">161</biblScope>
			<biblScope unit="page" from="149" to="180" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Solving distributed constraint optimization problems using cooperative mediation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mailler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lesser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Third International Joint Conference on Autonomous Agents and MultiAgent Systems</title>
		<meeting>Third International Joint Conference on Autonomous Agents and MultiAgent Systems</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="438" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">DPOP: A scalable method for multiagent constraint optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Petcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Faltings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence</title>
		<meeting>the Nineteenth International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="266" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">No-commitment branch and bound search for distributed constraint optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chechetka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sycara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Fifth International Joint Conference on Autonomous Agents and Multi-Agent Systems</title>
		<meeting>Fifth International Joint Conference on Autonomous Agents and Multi-Agent Systems</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="1427" to="1429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Asynchronous forward bounding for distributed cops</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gershman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Meisels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="61" to="88" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Distributed algorithms for DCOP: A graphical game-based approach</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Maheswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tambe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventeenth International Conference on Parallel and Distributed Computing Systems</title>
		<meeting>the Seventeenth International Conference on Parallel and Distributed Computing Systems</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="432" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Anytime local search for distributed constraint optimization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Zivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Third Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Third Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="393" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Decentralised coordination of low-power embedded devices using the max-sum algorithm</title>
		<author>
			<persName><forename type="first">A</forename><surname>Farinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Petcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Conference on Autonomous Agents and Multiagent Systems</title>
		<meeting>the Seventh International Conference on Autonomous Agents and Multiagent Systems</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="639" to="646" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">MB-DPOP: A new memory-bounded algorithm for distributed optimization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Petcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Faltings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth International Joint Conference on Artificial Intelligence</title>
		<meeting>the Twentieth International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1452" to="1457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">BnB-ADOPT: An asynchronous branch-and-bound DCOP algorithm</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yeoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Felner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koenig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Joint Conference on Autonomous Agents and Multiagent Systems</title>
		<meeting>the Seventh International Joint Conference on Autonomous Agents and Multiagent Systems</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="591" to="598" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Quality guarantees on k-optimal solutions for distributed constraint optimization problems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tambe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence</title>
		<meeting>the Nineteenth International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1446" to="1451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On k-optimal distributed constraint optimization algorithms: New bounds and algorithms</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bowring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Portway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tambe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Joint Conference on Autonomous Agents and Multiagent Systems</title>
		<meeting>the Seventh International Joint Conference on Autonomous Agents and Multiagent Systems</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="607" to="614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<title level="m">Introduction to Algorithms</title>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A-DPOP: Approximations in distributed optimization, in: Principles and Practice of Constraint Programming</title>
		<author>
			<persName><forename type="first">A</forename><surname>Petcu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Faltings</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="802" to="806" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Trading off solution quality for faster computation in DCOP search algorithms</title>
		<author>
			<persName><forename type="first">W</forename><surname>Yeoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koenig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence</title>
		<meeting>the Twenty-First International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="354" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Collaborative multiagent reinforcement learning by payoff propagation</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Kok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Vlassis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1789" to="1828" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The generalized distributive law</title>
		<author>
			<persName><forename type="first">S</forename><surname>Aji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mceliece</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="325" to="343" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J C</forename><surname>Mackay</surname></persName>
		</author>
		<title level="m">Information Theory, Inference, and Learning Algorithms</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the optimality of solutions of the max-product belief propagation algorithm in arbitrary graphs</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Freeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="723" to="735" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Correctness of belief propagation in gaussian graphical models of arbitrary topology</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Freeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="2173" to="2200" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<title level="m">Constraint Processing</title>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Constructing a unifying theory of dynamic programming DCOP algorithms via the generalized distributive law</title>
		<author>
			<persName><forename type="first">M</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Rodríguez-Aguilar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cerquides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Autonomous Agents and Multi Agent Systems</title>
		<imprint>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Decentralised coordination of mobile sensors using the max-sum algorithm</title>
		<author>
			<persName><forename type="first">R</forename><surname>Stranders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Farinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence</title>
		<meeting>the Twenty-First International Joint Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="299" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A distributed algorithm for minimum-weight spanning trees</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Gallager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Humblet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Spira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="66" to="77" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Clustering by passing messages between data points</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Frey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dueck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">315</biblScope>
			<biblScope unit="issue">5814</biblScope>
			<biblScope unit="page" from="972" to="976" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On the convergence of iterative decoding on graphs with a single cycle</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Aji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">B</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Mceliece</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Information Theory</title>
		<meeting>the International Symposium on Information Theory</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page">276</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Correctness of local probability propagation in graphical models with loops</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="41" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Factor graphs and the sum-product algorithm</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">R</forename><surname>Kschischang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Frey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Loeliger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="498" to="519" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Optimal distributed algorithms for minimum weight spanning tree, counting, leader election, and related problems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing</title>
		<meeting>the Nineteenth Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="230" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Tree consistency and bounds on the performance of the max-product algorithm and its generalizations</title>
		<author>
			<persName><forename type="first">M</forename><surname>Wainwright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Jaakkola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Willsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistics and Computing</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="143" to="166" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Preprocessing techniques for accelerating the DCOP algorithm adopt</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Ali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tambe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourth International Joint Conference on Autonomous Agents and Multiagent Systems</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1041" to="1048" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Nonmyopic informative path planning in spatio-temporal models</title>
		<author>
			<persName><forename type="first">A</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second Conference on, Artificial Intelligence</title>
		<meeting>the Twenty-Second Conference on, Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="602" to="607" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Near-optimal sensor placements in gaussian processes</title>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Conference on Machine Learning</title>
		<meeting>the Twenty-Second International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="265" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Near-optimal observation selection using submodular functions</title>
		<author>
			<persName><forename type="first">A</forename><surname>Krause</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Second Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1650" to="1655" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Rasmussen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K I</forename><surname>Williams</surname></persName>
		</author>
		<title level="m">Gaussian Processes for Machine Learning</title>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Towards real-time information processing of sensor network data using computationally efficient multi-output gaussian processes</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Osborne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Ramchurn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">R</forename><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Conference on Information Processing in Sensor Networks</title>
		<meeting>the Seventh International Conference on Information Processing in Sensor Networks</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="109" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Adaptive multi-robot wide-area exploration and mapping</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Dolan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Khosla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Conference on Autonomous Agents and Multiagent Systems</title>
		<meeting>the Seventh International Conference on Autonomous Agents and Multiagent Systems</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="23" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Approximating discrete probability distributions with dependence trees</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">K</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="462" to="467" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">A general scheme for multiple lower bound computation in constraint optimization, Principles and Practice of Constraint Programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kask</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Larrosa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="346" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Directed soft arc consistency in pseudo trees</title>
		<author>
			<persName><forename type="first">T</forename><surname>Matsui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Silaghi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hirayama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yokoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Matsuo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The Eighth International Conference on Autonomous Agents and Multiagent Systems</title>
		<meeting>The Eighth International Conference on Autonomous Agents and Multiagent Systems</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1065" to="1072" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Constructing free-energy approximations and generalized belief propagation algorithms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yedidia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Freeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="2282" to="2312" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
