<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Properties and Update Semantics of Consistent Views</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Paolini Politecnico</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Di</forename><surname>Milano</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Roberto</forename><surname>Zicari</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Institute for Applied Mathematics</orgName>
								<orgName type="institution">Stanford University</orgName>
								<address>
									<settlement>Genoa</settlement>
									<region>C.N.R</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Politecnico di Milano</orgName>
								<address>
									<settlement>Milan</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of California at Berkeley</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department" key="dep1">Institut fur Angewandte Informatik</orgName>
								<orgName type="department" key="dep2">Department of Electronics</orgName>
								<orgName type="institution">TU-Wien P. Paolini</orgName>
								<address>
									<addrLine>Paniglgasse 16</addrLine>
									<postCode>A-1040</postCode>
									<settlement>Wien</settlement>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Politecnico di Milano</orgName>
								<address>
									<postCode>21033, 20100</postCode>
									<settlement>Milano, Milano</settlement>
									<country>Italy and A.R.G., Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="department">Department of Electronics</orgName>
								<orgName type="institution">Politecnico di Milano</orgName>
								<address>
									<postCode>21023</postCode>
									<settlement>Milano</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Properties and Update Semantics of Consistent Views</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">54B338068265F130917AA060583613E6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T06:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.1 [Database Management]: Logical Design-data models</term>
					<term>schema and subs&amp;emu</term>
					<term>H.2.1 [Database Management]: Systems Concurrency, consistency, data abstractions, transactions, update semantics, view definition</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The problem of translating view updates to database updates is considered. Both databases and views are modeled as data abstractions. A data abstraction consists of a set of states and of a set of primitive update operators representing state transition functions. It is shown how complex update programs can be built from primitive update operators and how view update programs are translated into database update programs. Special attention is paid to a class of views that we call "consistent." Loosely speaking, a consistent view is a view with the following property: If the effect of a view update program on a view state is determined, then the effect of the corresponding database update is unambiguously determined. Thus, in order to know how to translate a given view update into a database update, it is sufficient to be aware of a functional specification of such a program. We show that consistent views have a number of interesting properties with respect to the concurrency of (high-level) update transactions. Moreover we show that the class of consistent views includes as a subset the class of views that translate updates under maintenance of a constant complement. However, we show that there exist consistent views that do not translate under constant complement. The results of Bancilhon and Spyratos [6]  are generalized in order to capture the update semantics of the entire class of consistent views. In particular we show that the class of consistent views is obtained if we relax the requirement of a constant complement by allowing the complement to decrease according to a suitable partial order.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>A view facility is an important part of many existing database systems, such as Query By Example <ref type="bibr" target="#b48">[46]</ref>, System R <ref type="bibr">[4]</ref>, Ingres <ref type="bibr" target="#b44">[42]</ref>, DB2 <ref type="bibr" target="#b13">[13]</ref>, and many others. In such a context, the problem of updating views that are implemented on an underlying database has been studied with different approaches <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b14">[14]</ref><ref type="bibr" target="#b15">[15]</ref><ref type="bibr" target="#b16">[16]</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b33">32,</ref><ref type="bibr" target="#b36">[35]</ref><ref type="bibr" target="#b37">[36]</ref><ref type="bibr" target="#b38">[37]</ref><ref type="bibr">401</ref>. Updates on views must be translated into updates on the underlying database. In general, there exists more than one database update that may correspond to the same view update. The problem is how to perform a view update, while avoiding the possibility that the corresponding underlying database update may create inconsistencies or have side effects on the view <ref type="bibr" target="#b19">[19]</ref>. Starting with the work of Paolini and Pelagatti <ref type="bibr" target="#b36">[35]</ref>, it has been acknowledged that a careful analysis of views and databases also needs to account for operations on views and databases, and not just for states, as it had been traditionally done. A database can be described by the set of its possible legal states and by its operations. We model databases as algebras that we call data abstractions; that is, a set of states and a set of operations to manipulate them. However, we rigorously distinguish between the syntactic representation of operations and their effective semantics.</p><p>A view is a relationship between two data abstractions, one called the base abstraction and the other called the view abstraction. We distinguish between the notions of static and dynamic view. A static view consists of two data abstractions and a mapping that establishes the correspondence between the states of the base abstraction (base states) and the states of the view abstraction (view states). A dynamic view consists of a static view and a translator (also called "update policy"), which states how to translate view updates into database updates. In general, a static view can be extended in several different ways to a dynamic view, according to the chosen translator. In this paper, whenever we use the general term "view," we mean "dynamic view. <ref type="bibr">"'</ref> In this paper, special attention is given to a class of views that we call consistent. Informally speaking, a consistent view is a view with the following property: If the effect of a view update on a view state is determined, then the effect of the corresponding database update is unambiguously determined. Thus, in order to know how to translate a given view-update program into a database-update program, it is not necessary to know the sequence of the single operations of the view-update program, but it is sufficient to be aware of a functional specification of such a program.2 In other words, in the case of a consistent view, the functional semantics of a view-update program (w.r.t. the view data abstraction) determines the semantics of the underlying database-update program, while, in general, the semantics of the database-update program is also dependent on the syntax of the view-update program. View consistency is an important property, which makes database systems (with views) accessible to formal specification and verification techniques. Moreover, consistent views have interesting properties with respect to the concurrent execution of (high-level) transactions. In particular, we will G. Gottlob et al.</p><p>show that if concurrent transactions on the view-data abstraction are translated to the database level, then properties such as serializability and noninterference are preserved.</p><p>Bancilhon and Spyratos <ref type="bibr" target="#b5">[6]</ref> propose an elegant solution to the view-update problem. They show that the choice of the database-update policy can be made by deciding which portion of the database should remain invariant; this invariant portion is called the constant complement. In our paper we show that the class of views treated by Bancilhon and Spyratos is a subclass of the consistent views. We show, however, that there are meaningful views which are consistent, but cannot be modeled by the approach of <ref type="bibr" target="#b5">[6]</ref>. Consequently, we extend the theory of Bancilhon and Spyratos to capture the update semantics of the much larger class of consistent views. Our approach uses a notion of complement as defined in <ref type="bibr" target="#b5">[6]</ref>. However we do not require that the information contained in the complement remain invariant, but we permit that updates may cause the loss of parts of this information.</p><p>The paper is organized as follows: In Section 2, we introduce our notation and define the basic concepts that will be used throughout the rest of the paper. Databases and views are defined as data abstractions. We distinguish between syntactic entities (update operators) and their semantic correspondents (update operations). We consider update programs as syntactical units built from primitive update operators. In our model, update programs (or parts of them) may be executed conditionally, depending on the result of the evaluation of a state predicate. We define the concepts of static and dynamic view and formulate a translation scheme for view-update programs. We introduce the class of equivalence-preserving views and explain why these views are of particular interest. Finally we recall from <ref type="bibr" target="#b38">[37]</ref> the definition of view consistency. In Section 3 we formally prove that a view is equivalence preserving iff it is consistent. Moreover we analyze the properties of consistent views with respect to the concurrent execution of view transactions. In particular we define the concept of high-level transaction and show that when transactions are translated from the view level to the database level, then serializability and noninterference are preserved. We also show that, in general, these preservation properties do not hold for nonconsistent views. In Section 4, we define the view-update problem, with particular reference to the work of Bancilhon and Spyratos. We define the notion of complement, recall, and reinterpret the results of Bancilhon and Spyratos. We show that each view that translates under constant complement is necessarily also consistent. On the other hand, we show that there exist consistent views that do not translate under constant complement. Hence, the notion of translation under constant complement is too restrictive for semantically characterizing the entire class of consistent views. In Section 5, the extension of the theory of Bancilhon and Spyratos to the class of all consistent views is carried out. In particular we show that this class can be adequately characterized through complements that are allowed to decrease (shrink) according to a suitable partial order. After giving a survey of related work in Section 6, we conclude the paper in Section 7 with an overview and some comments on our results and our plans for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">NOTATION AND BASIC CONCEPTS</head><p>In this section we introduce our notation and state the basic definitions that will be used throughout the paper. Definition 2.1. A data abstraction A = (S, U) is defined by a finite set S of legal states and by a set U of operator symbols (briefly operators). To each operator u E U a mapping ii from S to S is associated. Each ii is called an update operation on S.</p><p>In an earlier paper <ref type="bibr" target="#b38">[37]</ref>, besides update operations, pure query operations were also considered. In this paper we are interested in updates only and disregard query operations. Throughout the paper we assume the update operations ti to be total operations. A generalization of our results to cover partial operations is feasible. The outline of such a generalization can be found in <ref type="bibr" target="#b38">[37]</ref>.</p><p>Each update operation ti can be regarded as the semantic interpretation of the operator u. Thus we distinguish between syntactic entities (update operators) and their semantic correspondents (update operations). This distinction is convenient because we will consider update programs, which are syntactical units built from update operators. Each update program p represents in turn a mapping fi from S to S. However, syntactically different update programs p. and pb may correspond to the same mapping jZ = j%.</p><p>Our notion of update program is mainly based on two syntactical constructs: concatenation plp2 (which means that program p2 is executed immediately after program pl), and conditional combination IF 7~ THEN p1 ELSE p2 (which corresponds to the conditional execution of pl or p2, depending on a state predicate ?r on S).</p><p>In order to form conditional combinations of update programs, we must be able to syntactically express predicates on the state set S. However we do not wish to prescribe a particular formalism for representing predicates here; the definition of such a formalism, according to the underlying data model, can be left to the designer or implementor of a specific data abstraction. We assume that to each state set S a set ns of predicate expressions is associated, such that each element 7r of ns is the syntactic representation of an evaluable predicate 7T. on S and each of the 2 Is ' evaluable predicates on S is represented by at least one predicate expression of us. To avoid syntactical ambiguities, we also assume that among the (possibly) different predicate expressions representing the same predicate, there exists exactly one "designated" predicate expression (i.e., a representation in some canonical form).</p><p>To represent particular predicates in the examples of our paper we use Church's Lambda notation. For instance, the predicate that is true iff the state to which it is applied is equal to state a is written as Xs.s = a.</p><p>For each state set S we consider the identity operator ids, whose semantic interpretation is the identity on S. We now state a formal definition of the set of all update programs on a data abstraction A. In the following example, which was inspired by an example in <ref type="bibr" target="#b43">[41]</ref>, we show a data abstraction and several update programs, some of which are functionally equivalent. The notions of static view and dynamic view were originally defined in <ref type="bibr" target="#b38">[37]</ref>. A comparison to similar concepts that have been presented in the literature, such as view realizations and view specifications <ref type="bibr" target="#b43">[41]</ref> will be given in Section 6.</p><p>According to Definition 2.4, the translator 7 of a dynamic view is specified only for primitive view update operators (set U'). Clearly, the domain of T can be extended automatically, in a natural way, to the domain PB of all update programs on B. In the following example we present two dynamic views, V and V', both based on the data abstraction A1 introduced in Example 1. The corresponding operations are specified in column 3 and column 4 of Table <ref type="table" target="#tab_0">I</ref>.</p><p>It is obvious that we may define a static view by taking A1 (as defined in Example 2.1) as base data abstraction and Bz as view data abstraction (as defined in Example 2.1) through the following abstraction function f from s, to s1:</p><formula xml:id="formula_0">f: f (ay) = f (by) = ~1, f(aybx) = f(axby) = xlyl, f (ah) = x2, . f (ayby) = ~2. f (ax) = f (bx) = xl,</formula><p>Note that f corresponds to an aggregate function that reflects the "count" of all employees in each department. Such a function cannot be expressed by standard relational algebra. The static view (A,, Bz, f) can be extended in several different ways to a dynamic view (Al, B2, f, 7) according to the choice of a translator 7. Informally speaking, different choices of T correspond to different strategies of firing individuals (a or b) when department sizes have to be reduced. In particular, we shall consider two different (dynamic) views, V and V', which differ only by their translators 7 and 7 '. (2) V' = (Al, Bz, f, T '), where T ' is defined as follows: View V is such that employee b is preferred to employee a, since employee a is the first to be fired when both happen to be in the same department whose size must be reduced. View V' is more favorable to employee a instead.</p><p>In order to see how view-update programs are translated into database-update programs, consider the conditional view-update program p: Here we assume that the three predicate expressions Xs.(s = axbx V s = uyby), As. &lt; a, x &gt; E s, and As. &lt; b, x &gt; E s are all designated, i.e., that they are in some G. Gottlob et al. standard form. (This is necessary in order to assure the syntactical uniqueness of the translation since, in general, several syntactically different predicate expressions may represent the same predicate.)</p><p>Note that the placeholder symbol s occurs in both programs, in the viewupdate program p and in its translation rp. In p this symbol is a placeholder for view states (Sp), while in 7p it is a placeholder for base states (&amp;).</p><p>In the next definition the important class of equivalence-preserving views is introduced. Definition 2.6. A view V = (A, B, f, T) is equivalence preserving iff Vpl, P2 E PB:</p><formula xml:id="formula_1">(PI =p2 * 7pl = rp2).</formula><p>A view is equivalence preserving iff the functional specification of a view update is sufficient in order to functionally determine its translation. This means that whenever the effect of a view-update program on the view is known, then the effect of its translation on the database is determined. This property is of highly practical and theoretical relevance. It ensures that the translation of a view-update program p is essentially independent of the particular syntax of p and that it mainly depends on its semantics 0.</p><p>In the presence of an equivalence-preserving view, functionally equivalent view-update programs (or pieces of such) may be interchanged without any problem.</p><p>This high level of independence makes a database system with view capabilities much more accessible for theoretical analysis. Correctness proofs and verifications of transaction systems (possibly involving several different equivalencepreserving views) can be done by using formal specification techniques. Furthermore, equivalence-preserving views have some interesting properties with respect to concurrent transactions, which will be shown in Section 3.</p><p>Clearly, it would be useful to be aware of necessary and sufficient conditions for deciding whether a particular dynamic view is equivalence preserving. It turns out that the concept of view consistency, originally defined in <ref type="bibr" target="#b38">[37]</ref>, is an adequate criterion for characterizing equivalence preservation. Definition 2.7. Let A = (S, U) and B = (S', U') be two data abstractions and let V = (A, B, f, 7) be a view. It follows from Definition 2.7 that a view is consistent iff there do not exist three database states sl, s2, and s: , where s2 # sb , such that s1 =*VJ s2 and s1 =WJ si and f(s2) = f(si). This "forbidden" situation is depicted in Figure <ref type="figure" target="#fig_9">2</ref>.  It is easy to see that both views V and V' defined in Example 2.2 are consistent.</p><p>Figure <ref type="figure" target="#fig_10">3</ref> shows a graph representation of the relation -v+ connecting the states of S1. It is immediately clear that in this graph we cannot reach from one single node two distinct nodes which have the same image by f. Hence, the forbidden situation of Figure <ref type="figure" target="#fig_9">2</ref> does not occur in this graph. Similarly, a graph representation of the relation -v'+ (corresponding to view V') is given in Figure <ref type="figure" target="#fig_11">4</ref>. We can verify in the same way that V' is consistent.</p><p>In the next section we will prove that the notions of equivalence preservations and of consistency coincide.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">EQUIVALENCE PRESERVATION AND CONCURRENCY</head><p>In this section we show that consistent views have a number of interesting properties. We will first consider the functional equivalence of update programs. We show that a view is consistent if and only if it is equivalence preserving. Later we shall draw our attention to the concurrent execution of view-update programs. We will define the concept of (high-level) transaction and we will show that the translator 7 of any consistent view preserves serializability and noninterference of transactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Program Equivalence</head><p>Before proving our main result about the preservation of program equivalence, we state a simple lemma. This means that the commutative diagram of Figure <ref type="figure" target="#fig_4">1</ref> is still valid if we replace the primitive view-update operator u by any view-update program p.</p><formula xml:id="formula_2">G. Gottlob et al. BASE STATES _--_ i-_____ i 'r. ____ '1______ 'I _____ i [pi-] [-q---[%--pi---] [p-] [+-y --- VIEW STATES</formula><p>PROOF. Proposition (b) and the "e=" part of proposition (a) can be proven by induction on the structure of p. The "j" part of proposition (a) can be shown by induction on the distance between s1 and s2 in the graph of relation "-v+" (recall that "=xv=$" is the reflexive and transitive closure of "-v+").</p><p>For space reasons we omit these conceptually simple, but somewhat lengthy, induction proofs. 0 THEOREM 3.1. A view is equivalence preserving iff it is consistent. PROOF. Let A = (S, U) and B = (S', U') be two data abstractions and let V = (A, B, f, T) be a view. We show that V is equivalence preserving iff it is consistent. "if." Assume V is consistent but not equivalence preserving. Then there exist two programs pl, pz E PB such that p1 = p2 but rpl f rp2. Hence there exists a basestatessuchthat7P1(s)#7P2(s).Let7p,(s)=sland7pz(s)=sz.ByLemma 3.1 (a) it holds that s =*VJ s1 and s =*v=J s2. On the other hand, frompl = p2, by Lemma 3.1 (b) it follows that f(s(s))</p><p>= j$j(s)) = jFJf(s)) = f(a(s)), i.e., f(sI) = f(s2). This is in contradiction to the consistency of V (see Definition 2.7 (d)).</p><p>"only if." Assume V is equivalence preserving but not consistent. Since V is not consistent, there exist base states sl, s2, sg E S such that s1 =*v+ s2 and s1 =*v+ sb and f(s2) = f(s:) and s2 # ~6. By Lemma 3.1 (a), there exist two view-update programs p and p' on B, such that ?j5(sl) = s2 and T(sl) = ~6. Applying Lemma 3.1 (b), we have:</p><formula xml:id="formula_3">Ij(f(sl)) = f(v(sl)) = f(s2) and fi'(f(~)) = - f(rp'(sl))</formula><p>= f(sg&gt;. Hence, for the particular view state f(sl), we have:</p><formula xml:id="formula_4">Ij(fbl)) = P'(f(sl)).</formula><p>Using P and P', we now construct two view-update programs q and q ' as follows: q: (IF Xs.s = f(s,) THEN p ELSE ids,) 9 ': (IF Xs.s = f(s,) THEN p' ELSE ids,).</p><p>Obviously we have q = q '; however, 7q f 7q ' since q(sl) = ~(8~) = s2, but ---i -7q (~1) = up' (sl) = ~6. This is in contradiction to our assumption that Vpreserves PROOF. Let p1 and p2 be view-update programs such that 7p1 = rp2 and let s' E S' be an arbitrary view state. We have to show that E(s') = z(s'). Since f is a mapping from S onto S' (i.e., f is surjective), there exists a database state s E S such that f(s) = s'. By applying Lemma 3.1 (b) twice and by exploiting the equivalence rpl = rp2, we can write: E(s')</p><formula xml:id="formula_5">= E(f(s)) = f(%(S)) = fGE(S)) = EWs)) =E(s') 0 3.2 Concurrency</formula><p>Control over concurrency is one of the most important features of advanced database management systems, but the interaction of views and concurrency issues has not been exhaustively treated in the literature.</p><p>In this subsection we first briefly outline how traditional concurrency control methods fit in the context of our algebraic model of data abstractions and views. Then we define a new transaction model and show how concurrency properties that hold at the view level relate to concurrency properties at the database level.</p><p>Traditionally, in concurrency theory <ref type="bibr" target="#b40">[38]</ref> a database is conceived as a set of entities. A transaction is an abstract model of a program execution and represents the sequence of accesses to single entities by an application program. A data access to an entity x may be either a read operation R(x) or a write operation W(x, v), where v is the value to be written on entity X. A transaction, however, does not keep track of the actual semantics of the single operations, so a write access W(x, v) is represented by W(X). It is merely assumed that each write operation depends on all read operations that occurred earlier in the transaction. This transaction model is called the Read-Write Model. Several similar models for the formalization of transactions are developed in the literature that we will not discuss here; however, we will define a more algebraic concept of transaction later.</p><p>By analyzing two or more transactions, one can determine how the operations of the corresponding application programs may be executed in an interleaved fashion, thus allowing the application programs to execute concurrently.</p><p>However, it is required that the effect of the concurrent execution of several transactions be the same as the one of a serial execution of the different transactions. Data accesses arriving at run-time originating from different transactions must be reordered to avoid conflicts. The final schedule of the single data accesses must not necessarily be a serial schedule, but it is required to be serializable, i.e., equivalent to a serializable schedule.</p><p>The part of the DBMS that ensures serializability is called the scheduler. A scheduler examines each arriving data access request at run time and decides whether to perform the corresponding database operation immediately or to delay the request in order to enforce serializability.</p><p>Many sophisticated scheduling mechanisms have been developed and implemented in advanced Database Management Systems. Most schedulers are based on locking techniques <ref type="bibr" target="#b17">[17]</ref>. Scheduling can be performed in different modes according to the type of information available to a scheduler and to the way a scheduler acquires its information <ref type="bibr" target="#b40">[38]</ref>. Schedulers operating in dynamic information acquisition mode have no a priori knowledge about the set of transactions to be processed. They acquire information on the active transactions as the single transaction steps arrive. Schedulers operating in static information acquisition mode, in addition, dispose of a certain amount of initial information on the set of all transactions to be processed and may exploit this knowledge in order to optimize their scheduling policy.</p><p>In our algebraic model, the database-update operations (corresponding to the operators of set U) are high-level operations and are in general more complex than simple reads and writes on single data items. It is the task of the DBMS to translate these operations into lower-level operations. Each database-update operation u at run time can be translated into a sequence R(ri,), . . . , R(Xik), W(xjcjl, ul)t * * * 9 W(xjl, ul) of a number of read accesses to single data entities followed by a number of write accesses to single data entities. Each evaluation of a state predicate 7~ of nA is translated into a sequence R(Q), . . . , R&amp;k) of read accesses. The sequence of data access requests originating from different application programs may be handled by a scheduler of one of the above described types.</p><p>If an application program operates on a view rather than on the database itself, a further translation step has to be added. The view update steps are translated into database-update steps which in turn are translated into lower-level dataaccess operations.</p><p>So far, we have outlined how a traditional concurrency control mechanism can be used at the bottom of our algebraic model of view and database updates. Note, however, that concurrency control can be conceived at a higher level than at the one of Read-Write transactions. For instance, if the DBMS relies on an advanced algebraic database machine, we may define a transaction as a sequence of highlevel database updates and study the interference of two or more transactions from this "macroscopic" viewpoint. Even with conventional DBMSs, the analysis of transactions at a higher level of abstraction can be very profitable, since semantic information and constraints are often available at the conceptual level, but not at the implementation level. Recently several researchers have become interested in a more abstract definition of Transaction.</p><p>Abiteboul and Vianu [l, 21 define a transaction as a finite sequence of update operations applying to a relational database. The operations they consider are fairly complex insertions, deletions, and modifications which apply to single relations and which may be executed conditionally.</p><p>They show that equivalence of such transactions can be tested rather efficiently and they develop methods for simplifying transactions.</p><p>On the base of their transaction model (also called "Conceptual Level Transactions"), Vianu and Vossen <ref type="bibr" target="#b46">[44]</ref> study concurrency control properties. In particular they define the serializability of a schedule of transactions as a purely semantic property. It is shown that scheduling at a high level has several advantages compared to scheduling at the Read-Write level.</p><p>The concept of a transaction as a sequence of high-level operations fits nicely into our algebraic database model and turns out to be very useful for the analysis of the relationship between concurrency issues at the view level versus concurrency issues at the database level. Our definitions of "(high-level) transaction," "schedule," and "serializability" are very similar to the respective definitions in [l, 2, 441; the main difference is that we do not fix a concrete set of update operations (such as insertions, deletions, and modifications), but we remain at the general level of data abstractions. In order to remain as general as possible, we will define a (high-level) transaction as a sequence of update programs, rather than as a sequence of update operators.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.,P~). (d) A schedule of a pair of transactions</head><p>Tl = (pl, ~2, . . . , pn) and T2 = &lt;p:, Pi, * * -9 p,!,,), is a permutation u applying to Tl + T2, which respects the relative order of the steps of Tl and T2, i.e., Tl is a (possibly not contiguous) subsequence of a(Tl + T2) and T2 is a (possibly not contiguous) subsequence of a(Tl + T2). Note that we define a schedule as a permutation 6, i.e., a mapping, and not as a permuted sequence of transaction steps! (e) A schedule u of Tl and T2 is serializable iff either (a(Tl + T2))" = (Tl + T2)" or (a(Tl + T2))' = (T2 + Tl)". (f) The set of all serializable schedules of Tl and T2 on data abstraction A is denoted by CA (T,, T2). Note that the elements of CA (Tl, T2) are not transactions but permutations, i.e., reordering mappings. Note furthermore that CACTI, 7'2) = LU'2, TI).</p><p>(g) Let B be a data abstraction and assume that V = (A, B, f, T) is a view.</p><p>Transactions defined on B are called view transactions while transactions defined on A are called database transactions. If T = (pl, . . . , p,,) is a view transaction, then the translation rT of T is defined as follows: TT= (~pl,...,~p,). 0</p><p>In Definition 3.1, and in the rest of this section, we limit ourselves to considering schedules of pairs of transactions. A generalization to schedules of more than two transactions is straightforward.</p><p>Our definition of a schedule as permutation (and not as permuted sequence of steps) is quite unusual. This definition fits very well into our algebraic framework and has the advantage that we may contemplate the same schedule (T at both the view-level and the database-level. Assume that TI and T2 are two view transactions. By applying u to TI + Tz, we get a single transaction a(TI + Tz), which represents the interleaved execution of TI and Tz at the view-level. On the other hand, by applying u to T(T~ + T,), we get the transaction UT (T1 + Tz), which represents the same interleaved execution at the database-level.</p><p>The following lemma highlights a few commutativity laws holding among the operators u, 7, +, and '. (1) Is every database-serializable schedule necessarily also user-serializable? In other terms, does it hold that CA (7TI, 7Tz) C &amp;(TI, Tz)? (2) Is every user-serializable schedule necessarily also database-serializable?</p><p>In other terms, does it hold that &amp;(TI, Tz) C &amp;(TT~, 7Tz)?</p><p>The concept of user-serializability was originally introduced by Bernstein, Goodman, and Lai <ref type="bibr" target="#b7">[7]</ref>. However, their paper is based on a different view-model and on a different transaction-model (for more details, see Section 6). As the following theorem shows, the first question has a positive answerindependently of whether V is consistent or not. (</p><formula xml:id="formula_6">)<label>7</label></formula><p>Finally, by applying Theorem 3.2 to (7), we get:</p><formula xml:id="formula_7">(U(Tl + T2)Y = VI + TX,<label>(6)</label></formula><p>hence, u E &amp; (Tl, 2'2). 0</p><p>Loosely speaking, Theorem 3.3 states that the use of a scheduler at the database level, which produces serializable schedules, does not introduce concurrency problems or semantic ambiguities at the view level. If view users submit a number of view transactions and these transactions are translated into database transactions, which are executed according to a serializable schedule, then the effect of this execution on the view-data abstraction B is equivalent to a serial execution of the view transactions.</p><p>Let us now concentrate on the second question. It can be shown that a userserializable schedule is not necessarily also database-serializable (see Example 3.1 below). In other words, the translator 7 in general does not preserve serializability of transactions. This means that, in general, the scheduling of a set of concurrent transactions defined on the same view cannot take place at the view level but must be done at the database level.</p><p>However, as the next theorem shows, if a view V is consistent, then its translator preserves serializability. Hence, for consistent views, the userserializable schedules exactly coincide with the database-serializable schedules.  </p><p>hence, CJ E CA(7Tl, TT*). Cl</p><p>One consequence of Theorem 3.4 is that the scheduling of transactions defined on the same consistent view can be done at the view level, before translating the single transaction steps to database updates. This is often advantageous since, in general, both the view data structures and the view operations are much simpler than the data structures and operations of the entire database. The possibility of performing scheduling tasks already at the view level is a new aspect of the view paradigm. Because of this possibility, consistent views may be regarded as views with a high degree of autonomy.</p><p>If two or more transactions are operating concurrently on different consistent views then, of course, scheduling at the database level becomes necessary. However, even in this case, all transactions arising from the same view can be prescheduled at the view level. A global scheduler at the database level is needed for integrating the "local" schedules into one single globally serializable schedule. In this paper, we will not further discuss the interaction between different views and the possible "modularization" of scheduling tasks. A deeper analysis of these problems will be carried out elsewhere.</p><p>Let us now show by an example that nonconsistent views do not necessarily preserve serializability.</p><p>Our example was inspired by Keller <ref type="bibr" target="#b30">[29]</ref>.  It clearly holds that p = ids, on BS. However, r3p f rids,, since -Q(uy) = 0, but Tsids,(uy) = idsI = uy.</p><p>Hence V, is not consistent.</p><p>To see that the translator 73 of V3 does not preserve serializability, consider the following view-update programs: We define two view transactions Tl and T2 on B3 as follows: Tl = &lt; p1 &gt; and T2 = &lt; pi, pi &gt;. Let u be a schedule of Tl and T2, such that a(TI + Tz) = a( &lt; pl, pi, pi &gt; ) = &lt;pi, p,, pl &gt;. It is easy to see that rr is user-serializable, since (a(Tl + T2))0 = (Ti + T,)" on B,.</p><p>Let us now show that (r is not database serializable. Consider the three database transactions ~(T~T~ + TOTS), (TOTS + TOTS), and (TOTS + TOTS). Each of these transactions, applied to database state u&amp;y yields a different result: Even if one does not consider the possibility of scheduling or prescheduling at the view level, it might be worthwhile to know whether certain static properties holding for a set of concurrent view transactions are preserved when these transactions are translated to the database level. Such information can be exploited by a scheduler at the database level in order to produce more efficient schedules.</p><p>Assume, for instance, that two concurrent view transactions TI and T2 are known to be noninterfering, i.e., any schedule of Tl and T2 is user-serializable. If the translator 7 preserves noninterference, then TT~ and rT2 are noninterfering database transactions. In this case, a scheduler at the database level does not need to delay any step from 7TI or 7Tz. The single transaction steps can be executed as they arrive at run-time. The information about the noninterference of transactions is typically exploited by schedulers that operate in static information acquisition mode.</p><p>It is easy to see that noninterference is in general not preserved during the translation process of a set of transactions from the view level to the database level. However, in the case of a consistent view, noninterference is preserved. This is an immediate consequence of Theorem 3. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">CONSISTENCY AND CONSTANT COMPLEMENTS</head><p>In this section we compare the concept of view consistency to the concept of translation under constant complement. The latter has been introduced by Bancilhon and Spyratos <ref type="bibr" target="#b5">[6]</ref> in order to solve the well-known view-update problem. As the main result of this section we show that the class of all views which translate under constant complement is properly contained in the class of all consistent views.</p><p>Before defining the notion of complement, let us briefly formulate the viewupdate problem in our own terminology. The view-update problem can be stated by means of the following three questions:</p><p>(1) Given a static view (A, B, f), is it possible to find a translator T such that (A, B, f, 7) is a dynamic view?</p><p>(2) Which conditions on A, B, and f must be satisfied in order to guarantee that a translator 7 exists? (3) If there exist different possibilities to choose a translator 7, how can we characterize the different possible choices?</p><p>The pioneer work in solving the view-update problem was carried out by F. Bancilhon and N. Spyratos. In their paper <ref type="bibr" target="#b5">[6]</ref>, it is shown how the choice of a translator 7 can be made by deciding which portions of the database should remain constant under the translated-view operations (this part of the database G. Gottlob et al.</p><p>is called the view complement). Choosing a complement that remains invariant assigns unambiguous semantics to a view update. Formally a complement is defined as follows:</p><p>Definition 4.1. Let (A, B, f) be a static view with A = (S, U) and B = (S', U'). Let g be a mapping from 5' onto a set 5'". g is a complement off iff VSl, s2 E s:</p><formula xml:id="formula_9">((Sl z s2 A f(h) = fb2)) =$ g(sd # gb2)).</formula><p>It is easy to see that if g is a complement off then the knowledge off(s) and of g(s) uniquely determines the database state s. Thus g is indeed a mapping "complementary" to f and the knowledge of both, f and g, is sufficient for computing the database.</p><p>A key concept of Bancilhon and Spyratos' theory is the notion of g-translatability of a set of view operations. Definition 4.2. Let (A, B, f) be a static view with A = (S, V) and B = (S', U'). Let g be a complement off. The set U' of view-update operations is g-translatable iff vu E U', vs E s, 3v E PA, 3Sl E s:</p><formula xml:id="formula_10">(E(s) = Sl A gh) = g(s) A f(Sl) = ii(f(s))).</formula><p>This definition of g-translatability differs slightly from the original one <ref type="bibr" target="#b5">[6]</ref>, because in our model the database A is an algebra with a (possibly) limited set U of update operations. In <ref type="bibr" target="#b5">[6]</ref>, on the other hand, a database is a set of states on which all computable operations may be performed. With our model, it is not a priori required that each state s1 of the data abstraction A can be reached by a sequence of updates from a given state s. Therefore, in Definition 4.2 we must require the existence of an update program v, such that v(s) = sl. This difference does not essentially change the concept of g-translatability.</p><p>Our algebraic definition of a database (data abstraction) is more general and has the advantage that it may be used in "cascades", i.e., a view of a database may act as a base for a deeper level view.</p><p>The property of g-translatability is defined for static views (A, B, f) with complement g. For dynamic views (A, B, f, T), we define the concept of translation under constant complement as follows.  <ref type="figure">S',</ref><ref type="figure">U'</ref>). Let g be a complement off. We say that T translates under constant complement g iff Vp E Ps, Vs E S: g@(s)) = g(s). We say that T translates under constant complement iff there exists a complement g of f such that 7 translates under constant complement g. If T translates under constant complement, then, for convenience, we also say that the view V translates under constant complement.</p><p>Bancilhon and Spyratos limit their attention to a particular class of views that we call cyclic views: There is yet another very important difference between Bancilhon and Spyratos' approach and our own approach. In <ref type="bibr" target="#b5">[6]</ref>, no distinction between operators and operations is made. The translation process is defined at the level of operations, and not, as in our paper, at the level of syntactic operators and programs. In order to reformulate the results of <ref type="bibr" target="#b5">[6]</ref> in our terminology, we define the concept of equivalence of translators as follows.</p><p>Definition 4.5. Let V = (A, B, f) b e a static view with B = (S', U') and let 71 and r2 be two translators for V. We say that 71 is equivalent to r2, denoted by 71 = 72, iff Vu E U': 71u = 72u.</p><p>Actually, what is called "translator" in <ref type="bibr" target="#b5">[6]</ref> corresponds to an equivalence class of translators via "=" in our model. Each equivalence class consists of a set of translators that differ only by their syntax.</p><p>The main results of <ref type="bibr" target="#b5">[6]</ref> are briefly summarized as follows:</p><p>(a) Any cyclic consistent4 view translates under constant complement.</p><p>(b) Given a cyclic static view (A, B, f) with B = (S', U') and given a complement g off, such that U' is g-translatable, there exists-up to equivalence-exactly one translator T, such that (A, B, f, )</p><p>r is a dynamic view that translates under constant complement g. The equivalence class of 7 w.r.t. "=" is uniquely determined by: Vu E U': 7ii = (f X g)-'(iif X g). (c) Any cyclic dynamic view translating under constant complement is consistent.</p><p>Hence, in the case of cyclic views, the view-update problem has a very elegant solution: Choosing a translator 7 corresponds to fixing a view complement g off, such that U' is g-translatable. The set of all such complements determines the set of all equivalence classes of possible consistent translators 7. Can we generalize these results to noncyclic views?</p><p>According to (c), each cyclic view that translates under constant complement is consistent. Does this also hold for noncyclic views? A positive answer to this question is given by the following theorem.  From Theorem 4.2 it follows that the concept of "translation under constant complement" is not ample enough to capture the update semantics of the entire class of consistent views: The class of all views that translate under constant complement is a proper subset of the class of all consistent views (Figure <ref type="figure">6</ref>). Consequently, in the next section, we generalize the theory of Bancilhon and Spyratos to a more comprehensive theory, which allows an adequate characterization of all consistent views through the notion of view complement.</p><p>In <ref type="bibr" target="#b43">[41]</ref>, Spyratos presents an operational approach to define views and translators. His method is more general than the one adopted in <ref type="bibr" target="#b5">[6]</ref>, since he does not require that the set of all view-update operations of a given view be cyclic. A more detailed discussion of <ref type="bibr" target="#b43">[41]</ref> is given in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">UPDATE SEMANTICS OF CONSISTENT VIEWS</head><p>The basic idea that underlies the theory developed in this section can be stated as follows: Instead of requiring that the translator 7 of a view translates under constant complement, we will allow the complement to decrease according to a suitable partial order "I". Therefore we shall consider partial orders on the set g(S) of complement values of a database with state set S. Intuitively, g(s) 5 g(s') has the following meaning: All information contained in g(s) is also contained in g (s '), but g(s ') may contain more information than g(s). We require that a complement g and a partial order "I" unambiguously determine an update policy. For this reason we will introduce the notion of f-g-decisiveness and restrict our attention to partial orders that are f-g-decisive.</p><p>It will become clear that these partial orders are sufficient to determine all consistent update policies. For the rest of this section, let A = (S, U) and B = (S', U') be two data abstractions and let (A, B, f) be a static view. Definition 5.2. Let g be a complement off. A partial order "9 on g(S) is called f-g-decisive iff Vsl, s2 E S: ((sI # s2 A f (sl) = f (s2)) + g(sl) T g(sz)).</p><p>We are now able to introduce our generalization of Bancilhon and Spyratos' notion of g-translatability: Definition 5.3. Let g be a complement off and let "5" denote a partial order on g(S). The set U' of view-update operations is g-I-translutable iff 5 is f-g-decisive and Vu E U', Vs E S, 3v E PA, 3sl E S:</p><formula xml:id="formula_11">(fib) = Sl A g(s1)<label>5 g(s)</label></formula><p>A f(G) = ii(f(s))). It is easy to see that g-=-translatability is indeed a generalization of g-translatability.</p><p>Observe that equality constitutes an f-g-decisive partial order on g(S). The concept of g-translatability thus coincides with g-=-translatability. In the next definition we generalize the notion of translation under constant complement. Definition 5.4. Let g be a complement off and let "9' be a partial order on g(S), such that U' is g-s-translatable.</p><p>Let 7 be a translator such that (A, B, f, 7) is a dynamic view. We say that 7 translates under I-shrinking complement g iff vp E Ps, vs E s: g(-iiJ(s)) 5 g(s).</p><p>Our first aim is to show that, after fixing a view complement g and an order I on g(S), there exists (up to equivalence) exactly one translator T, such that (A, B, f, 7) is a consistent view and T translates under c-shrinking complement.</p><p>THEOREM 5.1. Let g be a complement off. If "&lt;" is a partial order on g(S), such that U' is g-&lt;-translatable, then there exists, up to equivalence, exactly one translator 7 from U' to PA, which translates under c-shrinking complement g. With this translator T, (A, B, f, 7) is a consistent view. PROOF. Assume that I is a partial order on g(S), such that U' is g-stranslatable. For the sake of clarity, this proof is organized into five distinct consecutive steps.</p><p>(1) We show that for each u E U' and for each s E S ', the set H(u, s) = (Sl E s 1 3w EPA: (cz(s) = Sl A f(Sl) = C(f(s)) A g(s1) 5g(s)j is a singleton.</p><p>The nonemptiness of H(u, s) follows immediately from the g-s-translatability of U'. Assume that H(u, s) contains two different elements s1 and s2. By definition of H(u, s), f(sl) = f(s2). Since s1 # s2 and since g is a complement off, it must hold that g(sl) # g(s2). By definition of H(u, s), we also have g(si) rz g(s) and g(s2) I g(s), hence s is an upper bound for s1 and s2, and thus g(si) t g(s2). This is in contradiction to the f-g-decisiveness of "5". Therefore H(u, s) is a singleton.</p><p>(2) Let us define for each u E U' a mapping h, from S to S, such that Vs E S: h,(s) = s' E H(u, s). Since H(u, s) is a singleton, h, is well defined. It is easy to see that for each mapping h,, there exists a database-update program pu E PA, such that z = h,. Indeed, for each s E S, by definition of H(u, s), there exists a w, E Pa, such that w,(s) = h,(s). Assume that S = (sl, s2, . . . s,,); define pu as follows: Clearly, for all s E S, j5u(s) = w,(s) = h,(s), hence pu is a syntactic representation of h,, i.e., jiU = h,. (Note that, in general, there might exist several equivalent syntactic representations of h,, even more compact ones than p,). From (a) we immediately deduce that 7 is a translator (see Definition 2.4(b)). Property (b) can be shown to hold not only for primitive view updates u, but more generally for arbitrary view update programs q:</p><p>(b') Vq E Ps, Vs E S: g(q(s)) 5 g(s).</p><p>(This can be shown by structural induction on q; we omit the details of this induction proof). Thus, according to Definition 5.4, 7 translates under s-shrinking complement g. (4) Assume that there exists another translator 7' f T, which translates under s-shrinking complement g. Since T' f T, there exists u E U' such that 7u f T'U. Thus there exists a state s E S with s(s) # T/U(S). On the other hand, from the definition of H(u, s) and from our assumption that T l G. Gottlob et al. and 7' both translate under s-shrinking complement g, it follows that I E(s) E H(u, s) and T u(s) E H(u, s). Since H(u, s) is a singleton, we I get X(s) = T u(s), which is a contradiction. Thus, 7 is the unique translator (up to equivalence), which translates under s-shrinking complement g.</p><p>(5) We show that the view V = (A, B, f, 7) is consistent. As noted under (3), we have:</p><p>vq E Ps, vs E s: g(Fq(s)) I g(s).</p><p>By applying Lemma 3.1(a), we get:</p><p>VSl, s2 E s: (Sl =*v* sp =a g(s2) 5 g(s1)).</p><p>Now let sl, sl, s6 be states of S, such that s1 =*VJ s2 and s1 =*v+ sb and fbd = f(s6). We then have: g(sp) 5 g(sl) and g(,i) 5 g(sl), hence gtsd t g(4): s ince "ZZ" is f-g-decisive, it follows sp = si. Thus, according to Definition 2.7, V is consistent. Cl Theorem 5.1 states that by fixing a complement g and a partial order "s", such that U' is g-c-translatable, a consistent update policy is determined. It remains to show the converse, i.e., for all consistent views V = (A, B, f, T), there exists g and 5, such that T translates under s-shrinking complement g.</p><p>For the rest of this section, let 7 be a translator such that V = (A, B, f, T) is consistent.</p><p>Definition 5.5. The canonical complement g,, off (with respect to 7) is defined as follows: PROOF. Let s, s1 E S such that s # s1 and f(s) = f (sl). We have to show that g(s) # g(sl). Note that s =*VJ s1 cannot hold, since V is consistent and s =*v+ s and s # sl. Thus s1 4 gC,,(s). On the other hand, by definition of &amp;an and because of the reflexivity of "=*v+", it holds that s1 E gC,,(sl). Therefore, aan ts) Z g,,, tsl ). 0 Since for each s E S, gcan(s) is a set, the set-theoretic inclusion "C is a partial order on go,(S). We show that it is precisely this order which, together with the complement g,,,, characterizes the dynamic view V. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF</head><p>(1) We show that "C" is f-g-decisive. Assume that for two elements s1 and s2 of S, it holds that sl # sg and f (sl) = f (s2). We must show that gC,,(sl) PgC,,(s2).</p><p>Assume &amp;,,(sl) t gC,,(s2). Let s E S be such that g,,,(s) is an upper bound (b) For a fixed complement g, different orders may correspond to the same translator (consider for instance g4 with orders sd and 5,).</p><p>A deeper analysis of the relationship between different complements and partial orders is subject to ongoing research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">RELATED WORK</head><p>Paolini and Pelagatti <ref type="bibr" target="#b36">[35]</ref> considered a database as an abstract object upon which one may operate with a given set of operations. This approach is further developed in <ref type="bibr" target="#b37">[36]</ref> and <ref type="bibr" target="#b38">[37]</ref>, where databases and views are modeled as data abstractions. Also Rowe and Schoens <ref type="bibr" target="#b41">[39]</ref>, Claybrook et al.</p><p>[ll], Arora and Carlson <ref type="bibr" target="#b2">[3]</ref>, Lockemann et al. <ref type="bibr" target="#b32">[31]</ref>, and Weber <ref type="bibr" target="#b47">[45]</ref> all use an abstract data type approach to model database views.</p><p>Tucherman, Furtado, and Casanova <ref type="bibr" target="#b45">[43]</ref> define the concept of "module" in the context of relational databases that can be compared to our notion of data abstraction. The admissible update operations on modules are defined through a powerful programming language whose features include composition, conditional execution, and iteration of operations (this language, based on First Order Dynamic Logic <ref type="bibr" target="#b25">[24]</ref>, was introduced earlier in <ref type="bibr" target="#b8">[8]</ref> and <ref type="bibr" target="#b9">[9]</ref>). A module may act as view for one or more higher level modules. The view definition includes the specification of a translator and is thus similar to our definition of dynamic views. As in our model, several layers of views may be defined.</p><p>The concept of consistency, as defined in the present paper was originally introduced in <ref type="bibr" target="#b38">[37]</ref>. Several other classes of views are defined in that paper, in particular, loop-preserving views and connection-preserving views. Let "-*v_*" denote the transitive (but not reflexive) closure of "-v+" (see Definition 2 It can be shown that a view is consistent iff it preserves both connections and loops. Bancilhon and Spyratos <ref type="bibr" target="#b5">[6]</ref> and Siklossy <ref type="bibr" target="#b42">[40]</ref> assume, as a prerequisite, that views preserve loops. This property is called "acceptability" in <ref type="bibr" target="#b5">[6]</ref>, and "minimal admissibility"</p><p>in <ref type="bibr" target="#b42">[40]</ref>. The work of Bancilhon and Spyratos <ref type="bibr" target="#b5">[6]</ref> is closely related to our research and has stimulated important parts of the present paper. Their concept of "translation under constant complement" is described in Section 4 and is generalized in Section 5 of our paper. It follows from the results of Cosmadakis and Papadimitriou that the enumeration of all alternative complements to a given static view is a hard problem. The automatic generation of all combinations of complements with suitable partial orders, in order to get all consistent views, may even be more complex. However, this is not the main goal of our paper. Our intent is to provide more insight into the structure of translators and to highlight the good properties of consistent views. Note that the test whether a given view (A, B, f, T) is consistent can be performed in time polynomial in ] 5' ] + ] U ] + ] U' I, where S is the state set of A and U and U' are the operator sets of A and B. (This can easily be seen by considering Definition 2.7.)</p><p>In <ref type="bibr" target="#b4">[5]</ref> Bancilhon and Spyratos define the notion of independent views. Two static views (A, B, f) and (A, C, g) with A = (S, U) are independent iff (f x g)(S) = f(S) x g(S), i.e., iff the range values off and g can be achieved independently. It is shown that a database decomposition into two complementary independent views may have several advantages. Further investigations on independent views have been carried out by <ref type="bibr">Chan and Mendelson [lo]</ref>, by Spyratos <ref type="bibr" target="#b43">[41]</ref>, and by Keller and Ullman <ref type="bibr" target="#b31">[30]</ref>. In <ref type="bibr">[25,</ref> 261 views that maintain a constant complement have been investigated using the formalism of lattice theory and Boolean algebra.</p><p>An interesting alternative approach to the definition of views and translators is proposed by Spyratos <ref type="bibr" target="#b43">[41]</ref>. He shows how both static and dynamic views can be specified using a purely operational method. In the following, we briefly outline the main concepts of this approach and point out how they compare to our own concepts. Clearly, several operations of 0 may correspond via h to the same view operation, hence 0 itself is not a concise representation of the set of all induced view operations. For an exact particularization of these operations, Spyratos considers the equivalence relation p on 0 defined by: opo ' w h(o) = h(o '). The induced view-update operations on TD are then given by the quotient set ?ro = 01~. The pair (xg, ao) is called a view realization. A view in the sense of <ref type="bibr" target="#b43">[41]</ref> is thus given by a view specification (D, 0) together with a view realization (TD, x0). The elements of ?TD and of 7~0 may be renamed by suitable designators (according to the chosen data model).</p><p>Our concept of static view is very similar to Spyratos' notion of view. Note that Spyratos does not limit the legal view-update operations to those induced by applicable database operations. In his model, the set of legal view updates is the set of all mappings from 7rn to TD. In our model, the set of legal view updates U' is specified at view-definition time. U' may contain operations that are not induced by applicable database operations. However, such operations are not translatable. (d) Translations. The translation scheme proposed by Spyratos, transposed into our own terminology, can briefly be described as follows. Let A = (S, U) and B = (S', U') be data abstractions such that (A, B, f) is a static view.</p><p>(1) choose a complement g off. g is a mapping from S to some set 5'". Let U" denote a set of operators on S", which syntactically represent the entire set of all mappings from S" to S". Let C = (Sn, VW). Clearly, (A, C, g) is a static view. (2) For each operator u of U' choose an operator 6u of U".</p><p>(3) Consider the mapping v from S to S defined by: v = (f x g)-'(6 x &amp;.I).</p><p>If there exists an update program p E PA such that p = i, and such that rj is applicable w.r.t. f, then define ru = p. Note that p is unique (up to equivalence). If TU as defined above exists for each u in U', then U' is translatable and 7 is a well-defined translator.</p><p>It can be seen that with this method, by varying g and 6, we get all possible translators T. Note that the resulting dynamic view V = (A, B, f, 7) is not necessarily consistent but may be any view according to Definition 2.4.</p><p>However, a connection to our results of Section 5 is quickly established. The set of all 6u for u E U, induces a directed transition graph G on 5'" in the obvious way. If G is acyclic, then its reflexive and transitive closure G* corresponds to a partial order 5 on S ". If I is f-g-decisive then V is consistent.</p><p>Moreover, if G consists of a disconnected set of edges, then all 6u are equivalent to i&amp;, and hence T translates under constant complement g.</p><p>In the paper of Spyratos, the complementary static views (A, B, f) and (A, Examples of this approach are Dayal and Bernstein <ref type="bibr" target="#b15">[15]</ref>, for automatic translation within the context of the relational model, and Dayal and Bernstein <ref type="bibr" target="#b16">[16]</ref>, for automatic translation of updates on network views. In <ref type="bibr" target="#b15">[15]</ref> only views that are combinations of projections, selections, and joins of relations are considered. A careful analysis of different types of update operations, such as insertions, deletions, and replacements is given. For these types of operations, Dayal and Bernstein consider translators that do not necessarily lead to consistent views in the sense of our definition.</p><p>On the other hand, their model of view definition does not include aggregate functions, thus they are not able to handle such simple views as the ones presented in our Example 2.2. A primary objective of <ref type="bibr" target="#b15">[15]</ref> is the preservation of integrity constraints (functional dependencies).</p><p>Furtado, Sevcik, and DOS Santos <ref type="bibr" target="#b21">[21]</ref> consider views that are defined through expressions of the algebra of quotient relations <ref type="bibr" target="#b20">[20]</ref>, an extension of classical relational algebra. A view defined by a complex algebraic expression is decomposed into a hierarchical system of views such that each single view can be derived by use of one single algebraic operation from its predecessors. The considered view updates are insertion, deletion, and modification of tuples. The permissivity and effect of each type of update for each type of view (according to the different operations of quotient algebra) is carefully analyzed.</p><p>Medeiros and Tompa [33, 341 define relational views by means of selection, projection, and natural join. The considered atomic view updates are insertion deletion and modification; however, update expressions are parametric in order to allow a validation before run-time. A view update may be executed conditionally depending on whether the integrity constraints on the underlying database (functional dependencies and template dependencies) are violated. More precisely, a conditional update is executed only if no further updates to the database are needed in order to maintain the validity of the integrity constraints. If this condition is violated, an exception action is performed. A general algorithm for predicting the side-effects requested updates may have on the view itself is presented.</p><p>In <ref type="bibr" target="#b28">[27]</ref> and <ref type="bibr" target="#b29">[28]</ref> Keller analyzes the possible translations of particular classes of update operations for relational views. (The considered updates are, as in [ 151, insertions, deletions, and replacements.) Keller gives five criteria that all candidate update translations must satisfy. The satisfaction of these criteria implies restrictions on the view-definition function f and on the form of view-update expressions that our approach does not require. In Keller's model, for instance, the key of each data relation that may be affected by updates must appear in the view. Some combinations of view-update operations are not allowed, such as the replacement of a tuple t by a tuple t' followed by the deletion of tuple t'. On the other hand, Keller's translation-scheme includes some interesting nonconsistent views that are not covered by our approach (for example, some non-loop-preserving views). Keller also shows how the choice of a translator can be done semiautomatically by a program that conducts a dialog with the database administrator.</p><p>In general we can recognize a number of features common to a large group of different approaches to solving the view-update problem <ref type="bibr">[15, 21, 27, 28, 33, 341:</ref> (1) The methods apply only to the relational model. Our method instead is model-independent. (2) The static-view definition is limited to particular combinations of relational operators; views based on aggregate functions, for instance, cannot be defined.</p><p>In our approach, the view definition function f may be an arbitrary mapping. (3) The legal database and view updates are powerful operations, such as insertion, deletion, and modification of tuples. Integrity constraints are introduced, which limit the applicability of these operations. In our approach, the view designer specifies the allowed operations (sets U and U'), which may be more complex and more specialized operations. According to the abstractdata-type paradigm <ref type="bibr" target="#b22">[22]</ref>, it is assumed that the specified operations preserve the underlying integrity constraints (see, for instance, Example 2.1). So, once a view is specified, we do not have to care about the preservation of integrity constraints.</p><p>One of the few works dealing with both concurrency and view updates is the paper of Bernstein, Goodman, and Lai <ref type="bibr" target="#b7">[7]</ref>. Although their approach is based on a different transaction model and uses a more general translation scheme than the one presented in our paper, we have borrowed the concept of userserializability from that paper. Transactions, in <ref type="bibr" target="#b7">[7]</ref>, are sequences of high-level operations that may also involve read operations (note that read operations are not considered in our algebraic approach). Their translation scheme allows that the same view operation is mapped to different database operations, depending on the transaction to which the view operation belongs, i.e., a view operation u belonging to transaction Tl may be translated to a different database update than the same view operation u belonging to a transaction T2. In that model, it is not generally valid that database-serializability implies user-serializability. logical databases is also considered. A view of a first order theory is elegantly defined through logical relationships between view formulas and database formulas. It is shown how view-update requests can be transformed into databaseupdate requests by easy substitutions.</p><p>The main conceptual difference between <ref type="bibr" target="#b18">[18]</ref> and our approach is that Fagin, Ullman, and Vardi look at an update request as the insertion or deletion of a piece of information, while in our model (as in most of the approaches presented in this section) an update request is conceived as the request for a well-defined state change. A qualitative comparison between these two approaches is not quite easy and leads necessarily to a discussion of the advantages and disadvantages of traditional programming paradigms versus logic programming. One disadvantage of our method is certainly that the view-designer has to care about a complete static specification of the update policy with regard to all primitive view updates that a user may issue (or is allowed to issue). On the other hand, the dynamic handling of updates requests as described in <ref type="bibr" target="#b18">[18]</ref> involves reasoning tasks that may require considerable computational overhead at run-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS AND FUTURE RESEARCH</head><p>In this paper we have introduced a new model for representing the syntactic and semantic aspects of database views. Within this model we have defined and investigated the class of consistent views. We do not claim that this class captures the complete spectrum of all "reasonable" views. Of course, there exist realistic views, which are not consistent (see Example 3.1). We believe, however, that the class of consistent views covers a large number of important and interesting applications, some of which are not covered by other approaches. In particular, we have shown that the class of consistent views is a superset of the class of views studied by Bancilhon and Spyratos in <ref type="bibr" target="#b5">[6]</ref>. We have given examples of applications that can be modeled by our approach, but not by the approach described in <ref type="bibr" target="#b5">[6]</ref>.</p><p>We have shown that consistent views are characterized by extremely useful properties. In particular, we have shown that the translator of a consistent view preserves functional equivalence of update programs, as well as some important concurrency properties. We have shown that the update semantics of consistent views can be determined by imposing a partial order on the values of the view complement.</p><p>We believe that the class of consistent views merits attention for its good properties. However, more research is needed in order to render our results more applicable. Let us conclude this paper by giving some outlines of the research we plan to carry out in the future:</p><p>-Study the properties of different types of relational views (projective views, selective views, join views, etc.) for different types of update operations (insertion, deletion, replacement). Derive necessary and sufficient conditions for the consistency of such views. -Extend our model of view-update programs to cover recursive and/or iterative update programs. Note that such an extension would require the capability of handling view and database updates, which are partial operations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>G</head><label></label><figDesc>. Gottlob et al, Definition 2.2. Let A = (S, U) be a data abstraction. The set PA of all update programs on A is defined as follows: E PA: plp2 E PA; to a program p1p2 the following update operation plpz on S is associated: Vs E S: m(s) = E&amp;(s)). l QX E JJs V pl, p2 E PA: (IF r THEN p1 ELSE p2) E PA; to this conditional program P, the following update operation p on S is associated: vs E s: F(s) = { Fl(s) if 7?(s) = true; --(s) if 77(s) = false. l Pa contains no other elements. It is easy to see that by this definition a unique operation fi on S corresponds to each update program P. Definition 2.3. Two update programs, p1 and p2, of a data abstraction A = (S, U) are functionally equivalent, denoted by pl = p2 iff E = z, i.e., iff Vs E S: E(s) = p2(s). Thus, pl and p2 are functionally equivalent iff their corresponding operations have the same effect on S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 2 . 1 .</head><label>21</label><figDesc>Figure 1 is commutative. (c) The quadruple V = (A, B, f, T), where f is an abstraction function and 7 is a translator is called a (dynamic) view.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 2 . 5 .Fig. 1 .</head><label>251</label><figDesc>Fig. 1. Commutative translation diagram.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 2 . 2 .</head><label>22</label><figDesc>Consider the data abstraction BP = (Sz, U,) defined as follows? The state set Sz consists of six instances of a relation with schema (DEPART-MENT, NUMBER-EMPS), such that the DEPARTMENT domain, as in Example 2.1, consists of the values x and y only and the domain of NUMBER-EMPS is the set (1, 21, such that the total sum of all NUMBER-EMPS values does not exceed 2. The single states are listed in the first column of Table I. The second column of this table indicates their shorthand notation. The set U, of primitive update operators is Uz = {REDUCE[x], REDUCE[y]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>( 1 )</head><label>1</label><figDesc>V = (A,, Bz, f, T), where 7 is defined as follows: r(REDUCE[x]) = (IF Xs. &lt; a, x &gt; E s THEN DELETE[a] ELSE(IF Xs. c b, x &gt; E s THEN DELETE[b] ELSE ids,)); T(REDUCE[~]) = (IF Xs. &lt; a, y &gt; E s THEN DELETE[a] ELSE(IF Xs. c b, y &gt; E s THEN DELETE[b] ELSE ids,)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>7 '</head><label>7</label><figDesc>(REDUCE[x]) = (IF Xs. &lt; b, x &gt; E s THEN DELETE[b] ELSE(ZF hs. &lt; a, x &gt; E s THEN DELETE[a] ELSE ids,)); T'(REDUCE[Y]) = (IF Xs. &lt; b, y &gt; E s THEN DELETE[b] ELSE(IF Xs. c a, y &gt; E s THEN DELETE[a] ELSE ids,)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>p: (IF Xs. s = xlyl THEN REDUCE[x] ELSE ids,). This program eliminates the only employee of department x if each department initially has exactly one employee. Using view V, this program is translated into the following database-update program rp: rp: (IF Xs.(s = axby V s = aybx) THEN(IF Xs. C a, x &gt; E s THEN DELETE[a] ELSE(IF Xs. &lt; b, x &gt; E s THEN DELETE[b] ELSE id,,)) ELSE ids,).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(a) "-v+" denotes the binary relation on S such that VSl, s2 E s: (sl-v-sp a 3u E U': TE(Sl) = sz). (b) "-*v+" denotes the transitive closure of -v+. (c) "=*v~" denotes the reflexive and transitive closure of -v+. (d) V is consistent iff Vsl, s2, sa E S: ((Sl =*v* sg A Sl =*v* s; A f(s2) = f(si)) * s2 = s;,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Sl</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Pattern of nonconsistency.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Base state connections induced by view V.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Base state connections induced by view V'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>that in the presence of a consistent view, equivalent view programs are translated into equivalent-database programs. Let us now briefly examine the opposite case. Assume that p1 and pz are view-update programs that are not equivalent, i.e., p1 f p2. Does it then necessarily hold that 7p1 f rp2? The following theorem gives a positive answer to this question, even for nonconsistent views. THEOREM 3.2. Let V = (A, B, f, T) b e a view with A = (S, U) and B = (S', U'). It holds: Vpl, pz E Ps: (7p1 = 7p2 +pl = ~2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Definition 3.1. Let A = (S, U) be a data abstraction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>(a) A (high-level) transaction T on A is a finite sequence of update programs pi: T= (PI,PZ, . . . , p,), where pi E PA for 1 5 i I n. Each pi is called a step of T. We assume that each transaction step is performed atomically. tb) IfT= (PI,P~,... , pn) is a transaction, then T" denotes the update program that consists of the concatenation of the single steps of T: T" = plp2 . . . p,,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>,P~, . . . , pn) and T2 = (p,',pi, . . . , p:), then Tl + T2 is defined ~~T~+T~=(P~,P~,...,P~,P:,P~,..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>LEMMA 3 . 2 .</head><label>32</label><figDesc>Let V(A, B, f, T) be a view, let T, T,, and Tz be view transactions and let u denote a schedule applicable to TI + Tz. (a) T(T~ + Tz) = 7TI + TT~ (b) m(Tl + Tz) = UT(T~ + Tz) (c) (7T)'= 7(T") PROOF. The transformations exposed in this lemma descend directly from the definitions of the different operators. 0For the rest of this section, let V = (A, B, f, 7) be a view and consider the following scenario: Users submit two different transactions, TI and T2, at the view level. The transactions are translated to database transactions rT, and rT2, which are processed on the database according to a schedule u. The effect of schedule u can be reflected at both levels, at the view level and at the database level. If u is serializable, at the view level (data abstraction B) w.r.t. TI and T,, we say that u is user-serializable. If u is serializable at the database level (data abstraction A) w.r.t. TT~ and rTz, we say that u is database-serializable. The following questions arise naturally:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>THEOREM 3 .</head><label>3</label><figDesc>3. &amp;(TT~, 7Tz) G &amp;(TI, Tz) i.e., every database-serializable schedule is user-serializable. PROOF. If u E &amp;(7TI, TT~) then we have either (u(TT, + 7Tz))0 = (7TI + 7Tz)0 or (1) (u(TT, + TT~))O = (7Tz + 7Tl)'.(2)Let us assume without loss of generality that (1) holds. By applying Lemma 3.2 (a) to the left-hand side of (l), we can rewrite (1) as:(UT(T, + T,))" = (TTI + TT*)".(3)By applying Lemma 3.2 (b) to the lhs. of (3), we get:(TU(T, + Tz))" = (TTI + TTz)O.(4)Now apply Lemma 3.2 (c) to the lhs. of (4rhs. of (5) according to Lemma 3.2 (a), we get: the rhs. of (6), we can permute 7 and "O", according to Lemma 3.2 (c):T(U(T, + T,)") = T((Tl + Tz)").</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>THEOREM 3 . 4 .</head><label>34</label><figDesc>If V is consistent then &amp;(Tl, Tz) = CA (~7'1, TZ'~), i.e., schedules on consistent views are database-serializable iff they are user-serializable. PROOF. By virtue of Theorem 3.3, it is sufficient to show that xe(T~, Tz) c &amp;(TT,, TTz). Assume that u E &amp;(T1, T2). Thus, either (u(T1 + Tp.))O = (Tl + T,)" ACM Transactions on Database Systems, Vol. 13, No. 4, December 1988.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>T1 + Tz))" = (T2 + Tl)".<ref type="bibr" target="#b1">(2)</ref> Assume, without loss of generality, that (1) holds. Since V is consistent, it preserves equivalence (Theorem 3.1), hence ~((u(Tl + Tz))") = T((TI + Td").(3)By successively applying the transformations (c), (b), and (a) of Lemma 3.2 to the left-hand side of (3), and (c) and (a) to the right-hand side of (3), we get: (~(TT, + 7Tz))0 = (TT~ + 7TJ',</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Example 3 . 1 .</head><label>31</label><figDesc>Recall the data abstraction A1 = (S,, U1) of Example 2.1. We define a data abstraction B3 = (&amp;, Us) and a view V, = (A,, &amp;, f3, TV) as follows: S3 is the powerset of the set (a, b ) of possible employees. The four elements of S, are denoted as: 0, a, b, ab. The abstraction function f3: S1 w S3 is such that for each database state s, f3(s) consists of the set of all employees belonging to department X. For instance, f3(uybx) = b and f3(uyby) = 0. The set U3 contains four primitive view update operators: u3 = (HZzm[a], zzzzm[b], FZRE[a], FZzLqb]), such that for each view state s E S3, H~fwal(s) = s u (a), HZRE[b](s) = s u (b), ~Z~Jwlb) = s -{a), FZmqb](s) = s -(b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>lG.</head><label></label><figDesc>Gottlob et al. Translator r3 maps each update operator of U3 to an update program of PAl: T~(HZRE[U]) = DELETE[a] ZNSERT[a, x] rs(HZRE[b]) = DELETE[b] ZNSERT[b, x] rz(FZRE[a]) = (IF As. &lt; a, x &gt; E s THEN DELETE[a] ELSE ids,) r3(FZRE[b]) = (IF As. C b, x &gt; E s THEN DELETE[b] ELSE ids,) We now show that the view V, does not preserve program equivalence. Consider the following update program on B3: p: (IF Xs.a @ s THEN HZRE[a]FZRE[a] ELSE ids,).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head></head><label></label><figDesc>pl: (IF Xs.s = 0 THEN HZRE[b] ELSE ids,) p:: FZRE[a] p; FZRE[b] The translations of these view updates to database updates are: r3p1 = (IF As. &lt; a, x &gt; @ s A &lt; b, x &gt; 4 s THEN DELETE[b] ZNSERT[b, x] ELSE id,,) Hopi = (IF As. C a, x &gt; E s THEN DELETE[a] ELSE id,,) r3p; = (IF As. c b, x &gt; E s THEN DELETE[b] ELSE ids,).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head></head><label></label><figDesc>z + ~Jl)~(axby) = 73p1(~(73p:bb~))) = bx It follows that (u(T~T~ + TOTS))" f ((TOTS + T~T~))O and (u(T,T, + TOTS))' f ((TOTS + TOTS))'. Hence u is not database serializable.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head></head><label></label><figDesc>4. COROLLARY OF THEOREM 3.4. If V is consistent and TI and Tz are noninterfering view transactions, then rTI and rT2 are noninterfering database transactions. Example 3.2. Recall the consistent view V = (AI, &amp;, f, 7) of Example 2.2. Consider the following transactions on &amp;. CLOSEx: (REDUCE[x], REDUCE[x]) CLOSEy: (REDUCE[y], REDUCE[y]). Clearly, CLOSEr and CLOSEy are noninterfering view transactions. It follows that their translations TCLOSEX and rCLOSEy are noninterfering database transactions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Definition 4 . 3 .</head><label>43</label><figDesc>Let V = (A, B, f, T) be a view with A = (S, U) and B = (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Definition 4. 4 (</head><label>4</label><figDesc>a) A data abstraction B = (S', U') is cyclic iff Vp E Ps, Vs' E S', 3p' E Ps: p'(fi(s')) = s'. (b) A static view (A, B, f) or a dynamic view (A, B, f, 7) is called cyclic iff the data abstraction B is cyclic. Example 4.1. The data abstractions A1 of Example 2.1 and B3 of Example 3.1 are cyclic, while the data abstraction B1 of Example 2.2 is not cyclic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>THEOREM 4 . 1 .Fig. 5 .</head><label>415</label><figDesc>Fig. 5. A consistent view with no constant complement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>THEOREM 4 . 2 .Fig. 6 .</head><label>426</label><figDesc>Fig. 6. Different classes of views.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Definition 5 . 1 .</head><label>51</label><figDesc>Let (X, 5) denote a partially ordered set and let a, b, c E X; c is an upper bound of a and b with respect to "5" iff a 5 c and b 5 c. If there exists an upper bound for a and b, we write a t b, otherwise we write a f b.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head></head><label></label><figDesc>p,, = (IF Xs.s = .sl THEN w ELSE(IF xs.s = sp &amp;IEN w,, ELSE . . . ELSE(IF Xs.s = s, THEN w,~, ELSE ids) . . .)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>( 3 )</head><label>3</label><figDesc>We define a mapping T from U' to PA by: Vu E U': TU = pu. The following properties of pu follow immediately from the definition of pu through h, and H(u, s): (a) Vu E U', Vs E S: f(ZZ(s)) = f&amp;(s)) = ri(f(s)). (b) Vu E U', Vs E S: &amp;Z(s)) = &amp;Z(s)) 5 g(s).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_32"><head>1 (</head><label>1</label><figDesc>g can : S H 2' (powerset of S) vs E s: &amp;ants) = is1 I s =*v=$ Sl The term "complement" is justified by the following lemma.) LEMMA 5.1. g,,, is a complement off.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_33"><head>THEOREM 5 .</head><label>5</label><figDesc>2. U' is g . ..-C-translatable and T translates under G-shrinking complement g,,,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_34"><head></head><label></label><figDesc>.7). A view V = (A, B, f, T) with A = (S, U) and B = (S', U') preserves connections iff vs, Sl, sz E s: ((f(s1) = f(Sz) A s -*v+ Sl A s -*v+ sz) * Sl = sz).On the other hand, V preserves loops iff vs, Sl E s: ((f(s) = f(s1) A s -*v+ Sl) =s s = Sl).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_35"><head></head><label></label><figDesc>Cosmadakis and Papadimitriou [ 121 study several computational problems related to translation under constant complement. They adopt the Universal Relation Assumption and their views are essentially projections of a given universal relation; hence, views and complements are represented as subsets of a universal scheme R. Semantic constraints on R (functional dependencies and join dependencies) may be specified. It is shown that the test whether two subsets of R are complementary can be performed in polynomial time but finding a l G. Gottlob et al. complement with a minimum set of attributes for a given view is NP-complete. The complexity of translating update operations under maintainment of a constant complement is analyzed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_36"><head></head><label></label><figDesc>(a) View Definition Set. Let S be a database state set. A view definition set D is a set of update operations on S, such that the relation do on S defined by: Vs E S(S~~S ' w 30 E D: o(s) = s ') is an equivalence relation. Specifying a view definition set on S is equivalent to specifying an abstraction function from S to a set 5". Indeed, it is easy to see that to each definition set D corresponds an abstraction function fD: Given a view definition set D, consider the quotient set ?rD = S/B0 and the mapping fD: S w a~, which to each s E S associates its own equivalence class. Clearly fo is an abstraction function from S to XD. On the other hand, it can be shown that each abstraction function can be defined through a suitable definition set. Assume that an arbitrary abstraction function f from S to a set S' is given. The set of sets (f-'(s') ] s' E S') defines a partition on S and hence an equivalence relation y on S. Each equivalence class of y can be identified with one element of S'. It is not hard to show that one can always find an appropriate set D of operations on S such that y = 60 and hence f = fD. (b) Applicable Database Operations. Given a view definition set D, an operation o on S is applicable iff VK E xD 3K' E a D: o(K) C K'. (Note that in terms of classical algebra, 0 is applicable iff 00 is a congruence relation W.r.t. 0). If an operation is applicable then it can be "interpreted" at the view level, i.e, to each applicable operation o on S corresponds an operation h(o) on ?TD, such that if o(s1) = s2 then h(o)(Kl) = K2, where Kl and K2 are the equivalence classes of sl and s2, respectively. Translated into our terminology, a database operator u is applicable w.r.t. an abstraction function f iff Vsl, s2 E S: (f(s1) = f(s2) 4 f (L(s1)) = f(L(s2))). In our theory, we did not introduce a similar concept. However, from our Definition 2.4(b) it follows that for any dynamic view (A, B, f, t), the translation TV of any view operation v is applicable w.r.t. f, Indeed, let sl, s2 E S such that f(s1) = f(s2) = s'. Then, by Definition 2.4(b) we have f(Z(s1)) = f (Z(s2)) = C(s). (c) View Specification and View Realization. A view specification on S is a pair (D, 0) where D is a view definition set and 0 is a set of applicable operations on S. As we have seen, each operation o of 0 can be interpreted as an operation h(o) on the view state set TD.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_37"><head>C</head><label></label><figDesc>, g) are formalized as view realizations, hence f and g are defined through definition sets Dl and 02 on S. A further exploration of the relationship between the operations of Dl, 02, and TU' may lead to new criteria for establishing that a view (A, B, f, t) is consistent. Research in this direction is on schedule. Most of the authors who have been studying the view-update problem concentrate their attention on finding ways for deriving translations automatically or semiautomatically by restricting the set allowed (static) view definitions and the set of allowed update policies. Their derivation rules usually are based upon notions of "natural translation"(typically minimality of side-effects) and upon constraints on the data model and on the database instances (functional dependencies and other data dependencies for relational databases).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table I .</head><label>I</label><figDesc>States and Operations of Abstraction B,</figDesc><table><row><cell>State s</cell><cell cols="3">Shorthand REDUCE[x](s) REDUCE[y](s)</cell></row><row><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell>I(-% 1))</cell><cell>xl</cell><cell>0</cell><cell>Xl</cell></row><row><cell>I(-% 2))</cell><cell>x2</cell><cell>Xl</cell><cell>x2</cell></row><row><cell>I(% l), (Y, 1))</cell><cell>xlyl</cell><cell>Yl</cell><cell>xl</cell></row><row><cell></cell><cell>Yl</cell><cell>Yl</cell><cell>0</cell></row><row><cell>II;: f;;</cell><cell>Y2</cell><cell>Y2</cell><cell>Yl</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Transactions on Database Systems, Vol. 13, No. 4, December 1988.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>The name "B," was chosen for ease of notation. No data abstraction "B," is defined in this paper.ACM Transactions on Database Systems, Vol. 13, No.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>4, December 1988.   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_3"><p>ACM Transactionson Database Systems, Vol. 13, NO. 4, December 1988.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>ACM Transactionson Database Systems, Vol. 13, No. 4, December 1988.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p>lG.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>G. Gottlob et al.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_7"><p>ACM Transactions on Database Systems, Vol. 13, No. 4, December lS88.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_8"><p>Consistency, in the sense of the present paper, has not been defined in<ref type="bibr" target="#b5">[6]</ref>. The authors of<ref type="bibr" target="#b5">[6]</ref> require a weaker property which they call "acceptability" (see also Section 6 of this paper). However it can be shown[23,  371 that, for cyclic views, acceptability is equivalent to consistency. Note furthermore that the word "consistency" appears with a completely different meaning in<ref type="bibr" target="#b5">[6]</ref>. ACM Transactions on Database Systems, Vol. 13, No. 4, December 1988.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank the referees for their detailed and constructive suggestions that helped to improve this paper substantially.</p><p>We also wish to thank Ch. Papadimitriou and G. Vossen for their help in finding references to related work and S. Ceri, A. Keller, M. Murphy, and M. Winslett Wilkins for providing useful comments.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research is partially sponsored by the Consiglio Nazionale delle Ricerche (C.N.R.), Italy; the University of California at Berkeley (MICRO grant); and DARPA contract N39-84-C-211, Stanford University, Stanford, California.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>for gcan(sl ) and g,,,(sd. This means that gcan(sl ) C g,,,(s) and gcanbz) C gc,,(s). Since s1 E g,,,h) and s2 E gcanh), we have ~1, sz E gcanb), and therefore s =*v+ s1 and s =*v+ sp. This is in contradiction to the consistency of V. Thus g,,, (sl) f g,,, (sZ), and hence "C" is f-g-decisive.</p><p>(2) Let us show that U' is g,,,--C-translatable.</p><p>Since we assumed that T is a translator, it is sufficient to show that for each s E S and for each u E U', g,,,(Zi(s)) C g,,,(s). We have: g,,,(Z(s)) = (sl I Z(s) =*v* sll and g,,,(s) = (sl ] s =*VJ s1 ). By Definition 2.7, we have s -v+ X(s), and thus also s =*vd Z(s). Since "=*v+" is transitive, it holds that go, (s(s)) C g,,,(s). (1) Any view obtained through a complement g and an associated partial order "%" is consistent.</p><p>(2) Any consistent view (A, B, f, T) can be characterized by a pair (g, s), where g is a complement off and "z? is a partial order on g(S). In particular, the pair (go,, C) fulfills this task.</p><p>Hence, the association of view complements to partial orders provides a semantic characterization of the variety of consistent views. The remainder of this section is dedicated to an example that illustrates how different translators can be characterized by different combinations of complements and partial orders.</p><p>Example 5.1. Consider the static view (Al, AZ, f) and the two translators T and T' of Example 2.2 (see also Figures <ref type="figure">3</ref> and<ref type="figure">4</ref>). In Table <ref type="table">II</ref> we exhibit several complements of the abstraction function f. In particular, we also show the canonical complements g,,, of T and gf,, of T '.</p><p>Table <ref type="table">III</ref> shows several partial orders defined on the codomains of the different complements. Note that in Table <ref type="table">III</ref> we indicate only the generators of the partial orders, i.e., each partial order consists of the reflexive and transitive closure of the exhibited relationships on the given domain.</p><p>It is easy to see that the translator T of Example 2.2 is characterized by the following combinations of complements and partial orders: (gc,,, C), (gl, s,), (g3, s,), (g4, %d), (g4, 5,). On the other hand, the translator T' is characterized by the following combinations: (gf,, , G), (g, , sb). Gottlob et al.  In particular, on the base of Example 5.1, it can be seen that:</p><p>(a) For a fixed complement g, different orders may determine different translators (consider for instance g, with orders sa and =b).</p><p>' G. Gottlob et al.</p><p>View implementations with scheduling policies that ensure user-serializability are called "correct" in <ref type="bibr" target="#b7">[7]</ref>. Several case studies of correct view implementations are presented.</p><p>Other authors who consider high-level transactions are Abiteboul, Vianu, and Vossen [l, 2, 441. Their elementary operations are insertions, deletions, and modifications on relations. Each operation may affect several tuples at a time, depending on a tuple selection condition. Transactions are defined as sequences of elementary operations. In [l, 21 it is shown that defining a set of parametrized transactions is equivalent to defining a set of database states. Hence the specification of a set of parametrized transactions is an operational alternative to the specification of a set of integrity constraints. The trade-off between these two approaches is carefully studied. The equivalence problem for transactions is treated and it is shown how transactions can be simplified.</p><p>Vianu and Vossen <ref type="bibr" target="#b46">[44]</ref> consider concurrency control problems in the context of this transaction model. In particular, they show that static serializability testing is NP-complete (as for the Read-Write transaction model). They succeed, however, in providing polynomial algorithms for testing important sufficient conditions for serializability.</p><p>They also show that serializability can be tested in polynomial time, when the allowed operations are only insertions and deletions (but not modifications).</p><p>An important argument in favor of the high-level transaction model is that semantic information (such as integrity constraints or commutability of high-level operations) is often available only at the conceptual level, but not at the internal level of a database system. This information can be used for instance to increase the degree of concurrency of a transaction system. Vianu and Vossen outline how functional dependencies can be exploited to improve concurrency.</p><p>Several different types of serializability for low-level transactions have been defined in the literature, for instance, final state serializability, view serializability, and conflict serializability <ref type="bibr" target="#b40">[38]</ref>. Our definition of serializability (as the one of <ref type="bibr" target="#b46">[44]</ref>), though applying to high-level transactions, is comparable to final state serializability.</p><p>Fagin, Ullman, and Vardi <ref type="bibr" target="#b18">[18]</ref> provide a framework for the interpretation of updates in the context of logical databases. In their approach, database states are first order theories, i.e., sets of closed first order formulas. An update request to a first-order theory consists of either an insertion or a deletion of a new first order formula, yielding a new theory. The implementation of such an update request may require additional adjustments (deletions or insertions of formulas) in order to avoid logical inconsistencies.</p><p>For example, if the original theory consists of the set of propositional formulas T = (P A Q + R, P, Q, R], then the request to delete R requires the additional deletion of at least one of the formulas P A Q + R, P, or Q from T. A method for implementing update requests with a minimum amount of additional changes is presented. The authors of <ref type="bibr" target="#b18">[18]</ref> also consider the possibility that certain formulas (for instance, integrity constraints) are "more permanently true" than others (for instance, simple facts). So different priorities may be attached to different categories of formulas; changes involving formulas with high priorities have a higher weight than changes involving lowpriority formulas. The problem of defining and updating views in the context of l G. Gottlob et al.</p><p>-Study the interaction between updates issued on different views.</p><p>-Find algorithms to compute all possible translation functions for a given static view in order to obtain a consistent dynamic view. Our ongoing research shows that there exists a strong relationship between the set of different consistent translation functions and the set of all spanning trees of a directed graph. (This result has not yet been proved in full generality but only for some particular classes of static views.) Therefore we think that it could be useful to take profit of existing graph theoretic algorithms in order to generate translation functions.</p><p>-Given an inconsistent view V, find methodologies for splitting V into two or more consistent views whose sets of operations are subsets of the set of operations of V. With such a splitting it is possible to replace a program P that originally operates on the inconsistent view V by a program P', which switches between different consistent views (for example through explicit switching primitives). The parts of P' that are executed completely within one consistent view can be modified as long as their functional semantics are not affected. All advantages provided by consistent views apply to these program parts.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Transactions and integrity constraints</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboijl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems</title>
		<meeting>the Fourth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Equivalence and optimization of relational transactions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J</title>
		<imprint>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
	<note>To appear in</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Information Preserving Properties of Relational Database Transformations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Carlson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">System R: Relational approach to database management</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><surname>Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1976-06">June 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Independent Components of Databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bancilhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Spyratos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Zn Proceedings of 7th VLDB Conference</title>
		<imprint>
			<date type="published" when="1981-09">Sept. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Update Semantics of Relational Views</title>
		<author>
			<persName><forename type="first">F</forename><surname>Bancilhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Spyratos</surname></persName>
		</author>
		<imprint>
			<publisher>ACM Trans</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Database Syst</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="1981-12">Dec. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On analysing concurrency control algorithms when user and system operations differ</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M-Y</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE-TSE SE</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The logic of a relational database manipulation language</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 5th ACM Symposium on Principles of Programming Languages</title>
		<meeting>5th ACM Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A formal system for reasoning about programs accessing a relational database</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Casanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Independent and separable database schemes</title>
		<author>
			<persName><forename type="first">E</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mendelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM-PODS</title>
		<meeting>ACM-PODS</meeting>
		<imprint>
			<date type="published" when="1983-03">March 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Defining database views as data abstractions</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Claybrook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Claybrook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE-TSE SE</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="1985-01">Jan. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Updates of relational views</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Cosmadakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<date type="published" when="1984-10">Oct. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A Guide to DB2</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On the updatability of relational views</title>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 4th VLDB</title>
		<meeting>4th VLDB<address><addrLine>West Berlin</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the correct translation of update operations on relational views</title>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1982-09">Sept. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the updatability of network views-extending relational view theory to the network model</title>
		<author>
			<persName><forename type="first">U</forename><surname>Dayal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Znf. Syst</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The notions of consistency and predicate locks in a relational database system</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">P</forename><surname>Eswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">N</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">L</forename><surname>Traiger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the semantics of updates in databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2nd ACM SZGACT-SZGMOD Symposium</title>
		<meeting>2nd ACM SZGACT-SZGMOD Symposium<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983">1983. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Updating relational views</title>
		<author>
			<persName><forename type="first">A</forename><surname>Furtado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Casanova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Query Processing in Database Systems</title>
		<editor>
			<persName><forename type="first">Rainer</forename><surname>Kim</surname></persName>
		</editor>
		<editor>
			<persName><surname>Batory</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An algebra of quotient relations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Furtado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kerschberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SZGMOD Conference</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1977">1977. 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Permitting updates through views of databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Furtado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Sevcik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Santos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Znf. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An initial algebra approach to the specification, correctness, and implementation of abstract data types</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Goguen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Structuring</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">R</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ed</forename><surname>Prentice-Hall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978">1978</date>
			<pubPlace>Englewood Cliffs, N.J.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Properties and update semantics of consistent views</title>
		<author>
			<persName><forename type="first">G</forename><surname>Go~lob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Paolini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zicari</surname></persName>
		</author>
		<idno>No. UCB/CSD 86/258</idno>
		<imprint>
			<date type="published" when="1985-09">September 1985</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Division, EECS, University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">First Order Dynamic Logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1979">1979</date>
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Algebraic aspects of relational database decomposition</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Hegner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PODS</title>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Canonical view update support through Boolean algebras of components</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Hegner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PODS</title>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Algorithms for translating view updates to database updates for views involving selections, projections and joins</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Keller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SZGACT-SZGMOD Symposium</title>
		<meeting>ACM SZGACT-SZGMOD Symposium<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1985-03">March 1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Updating relational databases through views</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Keller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
		<respStmt>
			<orgName>Stanford University, Computer Science Dept.</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">On Bancilhon and Spyratos&apos; &quot; Update semantics and relational views</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Keller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="521" to="523" />
			<date type="published" when="1987-09">Sept. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On complementary and independent mappings on databases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SZGMOD</title>
		<meeting>ACM SZGMOD<address><addrLine>Boston; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1984-06">June 1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Data abstractions for database systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Lockemann</surname></persName>
		</author>
		<author>
			<persName><surname>Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trams Database Syst</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1979-03">March 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A relational database view update translation mechanism</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Masunaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Tenth VLDB Conference</title>
		<meeting>Tenth VLDB Conference<address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1984-08">Aug. 1984</date>
			<biblScope unit="page" from="309" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">A validation tool for designing database views that permit updates</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M B</forename><surname>Medeiros</surname></persName>
		</author>
		<idno>CS-85-44</idno>
		<imprint>
			<date type="published" when="1985-11">November 1985. Nov. 1985</date>
		</imprint>
		<respStmt>
			<orgName>University of Waterloo ; University of Waterloo, Data Structuring Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Also Technical Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Understanding the implications of view update policies</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M B</forename><surname>Medeiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">W</forename><surname>Tompa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB 1985</title>
		<meeting>VLDB 1985<address><addrLine>Stockholm</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Formal definition of mappings in a database</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paolini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pelagatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SZGMOD</title>
		<meeting>ACM SZGMOD<address><addrLine>Toronto; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1977">1977. 1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Verification of views and applications programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paolini</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979-12">Dec. 1979</date>
			<pubPlace>Toulouse, France</pubPlace>
		</imprint>
	</monogr>
	<note>Workshop on Formal Bases for Databases</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Properties of views and their implementation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Paolini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zicari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m">Database Theory</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Plenum Press</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Database Concurrency Control</title>
		<author>
			<persName><forename type="first">C</forename><surname>Papadimitriou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Computer Science Press</publisher>
			<pubPlace>Rockville, Md</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Data abstractions, views and updates in RIGEL</title>
		<author>
			<persName><forename type="first">L</forename><surname>Rowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Schoens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SZGMOD</title>
		<meeting>ACM SZGMOD<address><addrLine>Boston, Mass; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1979-05">May 1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Updating views: a constructive approach</title>
		<author>
			<persName><forename type="first">L</forename><surname>Siklossy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Workshop on Logical Bases for Databases</title>
		<meeting>Workshop on Logical Bases for Databases<address><addrLine>Toulouse, Dec</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">An operational approach to data bases</title>
		<author>
			<persName><forename type="first">N</forename><surname>Spyratos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Database System-s (PODS)</title>
		<meeting>the ACM Symposium on Principles of Database System-s (PODS)<address><addrLine>Los Angeles; New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982-03">Mar. 1982. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The design and implementation of INGRES</title>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><surname>Et Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1976-09">Sept. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A pragmatic approach to structured database design</title>
		<author>
			<persName><forename type="first">L</forename><surname>Tucherman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Furtado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Casanova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">9th VLDB Proceedings</title>
		<meeting><address><addrLine>Florence, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Conceptual level concurrency control of relational update transactions</title>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vossen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd International Conference on Database Theory</title>
		<meeting><address><addrLine>Bruges</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988-09-02">Aug. 31-Sept. 2, 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A software engineering view of database systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="1978-09">Sept. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Query-by-example: A database language</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Zloof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Syst. J</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="1977">1977. 1985. 1987. January 1988</date>
		</imprint>
	</monogr>
	<note>Received November. revised May. accepted</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
