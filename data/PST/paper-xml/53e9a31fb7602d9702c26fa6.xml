<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Merging video streams in a multimedia storage server: complexity and heuristics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Siu-Wah</forename><surname>Lau</surname></persName>
							<email>swlau@cs.cuhk.edu.hk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">John</forename><forename type="middle">C S</forename><surname>Lui</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Leana</forename><surname>Golubchik</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Columbia University</orgName>
								<address>
									<postCode>10027</postCode>
									<settlement>New York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<postCode>20742</postCode>
									<settlement>College Park</settlement>
									<region>MD</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Merging video streams in a multimedia storage server: complexity and heuristics</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">360A7466A9F751B6A6C4D54C1CFD9B85</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Multimedia storage systems -Video-on-demand -Stream merging -I/O stream sharing -Complexity</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Due to recent advances in network, storage and data compression technologies, video-on-demand (VOD) service has become economically feasible. It is a challenging task to design a video storage server that can efficiently service a large number of concurrent requests on demand. One approach to accomplishing this task is to reduce the I/O demand to the VOD server through data-and resource-sharing techniques. One form of data sharing is the stream-merging approach proposed in [5]. In this paper, we formalize a static version of the stream-merging problem, derive an upper bound on the I/O demand of static stream merging, and propose efficient heuristic algorithms for both static and dynamic versions of the stream-merging problem.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent advances in networking technologies and vast improvements of storage systems have made it feasible to provide multimedia on-demand services, such as news distribution, advertisement, library information systems, and movies-on-demand. Consequently, the area of multimedia storage systems has received a great deal of attention in the past few years.</p><p>Early research works [2,10,12] concentrated on the study of multimedia storage systems which support the retrieval of multimedia objects at peak display bandwidths (bits/s); for example, assuming that the display bandwidth of the object is fixed at B display Mbps throughout the duration of the display, the storage server retrieves that object using B display Mbps of disk I/O bandwidth. This approach may be applicable for video objects whose average display bandwidth requirements are close to their peak display bandwidth requirements. (The variance of a video object's bandwidth requirement is a function of the compression technique used and the actual content of that object.) Recent works consider video-on-demand (VOD) architectures which can support variable display bandwidths. For example in [7-9], the authors propose novel techniques for supporting variable display bandwidth for a disk-based storage architecture and for a hierarchical storage architecture.</p><p>Part of the challenge of designing efficient VOD servers is due to the large storage and bandwidth requirements of video objects. For example, a 120-min MPEG-I video requires 1.5 Mbits/s of display bandwidth and 1.3 GB of storage [6]. However, the quality of MPEG-I video is at best VHS quality and is certainly lower quality than broadcast television. Higher quality compressed video, such as MPEG-II or compressed HTDV video [1], requires display bandwidths of 4 to 20 Mbits/s. The storage requirements of video objects usually precludes them from being stored in main memory. Video objects have to be stored on magnetic disks or tertiary storage devices such as robotic tape libraries. A video object is displayed by scheduling an I/O stream where the data is read from an appropriate storage device or a set of storage devices and delivered to a display unit.</p><p>There are many approaches to improving the efficiency of a VOD storage system; these include improvements in data layout techniques, disk-scheduling algorithms, etc. In this paper we concentrate on the the delivery of popular objects in a VOD system. That is, we expect there to be a skew in the distribution of access frequencies of the video objects. Moreover, we expect that a small subset of objects would be accessed very frequently, and the rest of the objects would be accessed infrequently; such an access pattern would, for instance, be accurate for a movie server where a small subset of popular movies (perhaps for that week) is accessed simultaneously by many users. In such a system, it is very likely that the I/O bandwidth is the critical resource which contributes to a large fraction of the system response time. We define system response time as the time between a request's arrival to the storage server and the time when we can start streaming the bits of the requested video from the disk storage system to the network. Although disk storage costs are decreasing rapidly, bandwidth costs are not decreasing nearly as quickly; this is partly due to the fact that most storage improvements are due to increases in the number of tracks per inch, rather than the number of bits per track (and, the number of bits per track plus the revolutions per minute determine the bandwidth capability of a disk). One way to improve the system response time for delivery of popular objects is to carefully manage the I/O bandwidth of the VOD server and "share" it among requests for the same object. The following approaches to reducing the aggregate I/O bandwidth requirements of popular objects have been proposed in the past:</p><p>-Batching: the storage server polls the request queue periodically and serves requests, for the same object, that have accumulated in the queue, using a single I/O stream, e.g., [3]. -Buffering: two or more successive requests for the same object can be served by temporarily holding the data, retrieved by a single I/O stream, in the main memory buffers, where the first request is serviced using the I/O stream and successive requests are serviced from the main memory buffers, e.g., [4, 11]. -Adaptive piggybacking or stream merging: the display rates of requests in progress (for the same object) are dynamically adjusted until their corresponding I/O streams can be "merged" into one [5].</p><p>Batching, buffering, and stream merging can serve a group of requests, for the same object, using a single I/O stream. Stream merging differs from batching in that it groups requests dynamically, while displays are in progress, so that no additional latency is experienced by the user. On the other hand, batching requires that the displays of requests of the same group start at the same time and hence contributes to additional delays in the system. Note that, the reduction in I/O bandwidth demand due to stream merging is not quite as high as in the case of batching, since it takes some time to merge the streams (and no I/O bandwidth savings are accomplished during that time). Thus, the trade-off between the two approaches is in balancing the latency for starting service of a request and the amount of I/O bandwidth saved. It is important to point out that all three approaches can be combined, as mentioned in [5].</p><p>In this paper, we concentrate on the stream-merging approach because of its effectiveness as reported in [5]. First, we briefly elaborate on the motivation and feasibility of this approach; a more detailed and more formal description of stream merging is given in Sect. 2. The stream-merging approach is motivated by the fact that it is possible to time compress or time expand a video object by a small percentage (e.g., 5%) without it being perceptible by the user, i.e., it is possible to alter the duration of an object's display without affecting its (perceptible) quality. Similarly, the duration of an audio object can be altered, for instance, using techniques such as audio pitch correction. Ample evidence exists to support the above-stated claims. In [5], the authors give a detailed explanation of the feasibility of such video and audio alteration techniques. In the interests of brevity, we only give a brief example here and refer the reader to [5] for a more detailed explanation. Consider, for instance, airing of movies on television. It is common practice in the television industry to time compress a movie for the purpose of increasing the number of commercial advertisements shown.</p><p>For instance, when the movie "Amadeus" was shown on television, its duration was altered by 3%.</p><p>There are two approaches to actually constructing the altered stream of frames to be transmitted to a display station. They are as follows:</p><p>-Online approach: the altered version of the object can be created online or on the fly. An I/O stream retrieves the original object, which is then time expanded or compressed by the server<ref type="foot" target="#foot_0">1</ref> . The "derived" object is transmitted to the display unit. In this case, the I/O bandwidth required varies with the display rate used. There are two possible disadvantages of the online alteration: (1) the data layout on disks is often tuned to one delivery bandwidth, and having to support multiple bandwidths can complicate scheduling and/or require additional buffer storage, and (2) specialized hardware may be required to be able to produce the altered version in real time. -Offline approach: the altered version of the video can be created offline and stored on the disk in addition to the original version. An I/O stream retrieves an appropriate version of the object (be it original, time expanded, or time compressed), which is then directly transmitted to the display unit. An obvious disadvantage of this approach is the additional disk storage required.</p><p>Whether we use the online or offline approach, the streammerging technique requires the capability of transmitting a video object at several different display rates. There are multiple ways of attacking this problem, for instance, by using techniques similar to the ones proposed in [7-9]. Note that the details of supporting multiple display rates depend on the particular VOD server architecture used. We do not consider a specific architecture here since we are interested in developing a general technique for reducing I/O bandwidth demand using stream merging. Therefore, in this paper, we do not address the details of supporting multiple display rates.</p><p>In [5], the authors proposed several heuristic merging policies and analyzed the subsequent performance improvements using analytical models. However, many questions about the stream-merging approach remain unanswered, for example, determining an optimal stream-merging policy, as well as the maximum (or minimum) achievable performance improvements of the approach. We intend to address some of these questions in this paper. The contributions of this work are as follows: (1) we formalize a version of the streammerging problem and derive an upper bound on its I/O demand, and (2) we propose two novel stream-merging algorithms, which result in significant I/O demand reductions.</p><p>The organization of the paper is as follows. In Sect. 2, we formalize the static version of the stream-merging problem and describe the dynamic version of the stream-merging problem. In Sect. 3, we propose a heuristic algorithm for solving the static stream-merging problem and derive the properties of optimal solutions of the static stream-merging problem as well as the maximum I/O demand for merging n streams. We propose a novel dynamic stream-merging algorithm, Equal-Split, in Sect. 4. Section 5 presents per-formance analysis of algorithm Equal-Split. In Sect. 6 we compare performance of several dynamic stream-merging algorithms. Our conclusions are given in Sect. 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem definition</head><p>The stream-merging approach [5] initiates an I/O stream (or simply stream) for each request. Then, the display rates of the streams, corresponding to requests for the same object, are adjusted until the streams output the same data at the same time. At this point the I/O streams are merged into a single stream and the corresponding requests share this single I/O stream.</p><p>We assume that the storage server transmits frames to the display units at a constant frame rate, e.g., the NTSC standard requires that the display units display at 30 frames per second (fps). The stream-merging approach is viable if the storage server can time compress or time expand some sequence of original object frames. For example, we can time expand a sequence of original object frames by adding one additional frame to every 19 original object frames. Then, a display unit displays 30 × 19 20 = 28.5 original object frames per second. Similarly, we can time compress a sequence of original object frames by removing frames. A sequence of original object frames is time compressed if the display time of this sequence is somehow shortened as compared to its normal display time. Similarly, a sequence of original object frames is time expanded if the display time of the sequence is longer than its normal display time. More formally, time expansion and time compression can be defined as follows. Let f 1 , . . . , f k be a sequence of original object frames. Let f 1 , . . . , f m be a sequence of frames which are derived from f 1 , . . . , f k and are fed to the display unit. The sequence of original frames is time expanded if m &gt; k; it is time compressed if m &lt; k. (The two possible approaches to producing time-expanded or time-compressed versions of an object are discussed in Sect. 1.)  We define the display rate alteration ratio of an I/O stream as follows. If the I/O stream is a sequence of consecutive original object frames, then the display rate alteration ratio of the I/O stream is equal to 1. If the I/O stream is a stream of frames derived from original consecutive object frames, then the display rate alteration ratio of the I/O stream is equal to the number of consecutive original object frames required to derive one frame of the I/O stream. For example, if the frames of an I/O stream are derived by removing 1 out of every 21 original consecutive object frames, then the display rate alteration ratio of that I/O stream is equal to 21 20 = 1.05.</p><p>The display rate of an I/O stream is defined as the number of frames output per second × the display rate alteration ratio of the I/O stream. Therefore, the display rate of an I/O stream is a measure of how fast the I/O stream gets through the content of the "original" video. The effective display rate of a display unit is defined as the display rate of the I/O stream being transmitted to the display unit. Note that the frames of an I/O stream may be time expanded or compressed before transmission to the display unit, if the online approach to display rate alteration is used.</p><p>Let S n be the normal display rate in frames per second (fps). Let ∆ + and ∆ -be the maximum fraction of the normal display rate by which a stream can be sped up or slowed down, respectively, i.e., a stream is constrained to output at a display rate between (1 -∆ -)S n and (1 + ∆ + )S n frames per second (fps). The display rate of a request is defined as the display rate of a stream. For convenience of further discussion, we introduce the following definitions. Definition 1. The playback point of a stream s at time t, p s (t), is the current position (in seconds) in the object's display of stream s at time t. Definition 2. Two streams are said to be "synchronized", if playback points of the streams are the same.</p><p>Note that two streams can be merged into a single stream when they are synchronized (at this point, system resources can be saved). Our goal is to design a general algorithm for synchronizing streams in an optimal way for VOD systems <ref type="bibr" target="#b1">2</ref> . The amount of system resources required by each stream is a function of the system architecture, i.e., communication protocols used, storage and retrieval methods used, etc. Since we are concerned with the delivery of popular objects, it is reasonable to assume that I/O demand is the critical resource. Note that, the stream-merging approach should be applicable to reducing demand on other system resources, e.g., the communication network bandwidth. However, the specific tradeoffs associated with applying this approach to another resource may differ from those we consider here, in the context of I/O bandwidth demand.</p><p>In this paper, we consider two possible versions of the stream-merging problem, namely: (1) the static version and (2) the dynamic version. In both cases, our goal is to merge streams corresponding to requests for the same object, in order to reduce the aggregate I/O bandwidth demand on the system. In the static case, we consider a single group of streams such that the membership of the group is fixed throughout the stream-merging process, i.e., no new streams can be initiated (which would correspond to an arrival of a new request) and no stream can be terminated (which would correspond to an end of an object's display). Thus, in the static merging problem, synchronization decisions can be made under a "complete information" assumption. The dynamic case differs from the static case in that new streams can be initiated and existing streams can be terminated. As a result, synchronization decisions have to be made "on the fly", without having full information about future arrivals. More formally, the static and dynamic merging problems can be defined as follows:</p><p>1. Static stream-merging problem: Given a set of streams of a video object, which has an infinite display time, and the corresponding playback points of these streams, find an optimum way to merge them into a single stream, where the objective is to minimize the total I/O cost (in bits) incurred during the synchronization process<ref type="foot" target="#foot_3">3</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Dynamic stream-merging problem:</head><p>The problem of minimizing the I/O cost (in bits) of retrieving data through merging of streams corresponding to requests for the same object in a VOD system in which -a new stream of a video object can be initiated due to a request arrival, -a stream can terminate due to reaching the end of an object's display, and -the request arrival process is stochastic.</p><p>In the remainder of this section and in Sect. 3, we concentrate on the static stream-merging problem. Before proceeding to characterize the stream-merging problem further and describing our algorithms, we make the following observation about the display rate adjustment decisions. The sooner merging (in an object's display) occurs, the more I/O bandwidth can be conserved and used by the storage system to serve other requests. Hence, we limit our algorithms to consider the slowest display rate, Suppose we would like to synchronize n streams corresponding to requests for the same video object. Let {s 1 , . . . . . . , s n } be this set of streams. Without loss of generality, we assume that (1) ∀i, j if i &lt; j, then p si (0) &gt; p sj (0) (i.e., s 1 is the leading stream and s n is the trailing stream), ( <ref type="formula">2</ref>) the synchronization of streams s 1 , . . . , s n begins at time t = 0, and (3) if two streams s i and s j are merged and i &lt; j, the I/O resources used by s j are released and the requests being served by s j are served by s i .</p><formula xml:id="formula_0">S min = (1 -∆ -)S n ,</formula><p>For the purpose of solving the static stream synchronization problem, we are only interested in the differences between the playback points of the streams, where the objective is to reduce the differences between the playback points of all streams to zero, i.e., to come to a point where each stream outputs the same video data at the same time. In the following definition, we introduce the concept of a relative playback point as a measure of the relative position of a stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. The relative playback point of a stream s</head><formula xml:id="formula_1">i at time t, r si (t), is p si (t) -t -p sn (0).</formula><p>Note that the relative playback point of stream s i changes when s i is sped up or slowed down. For example, if s i is sped up by 5% of the normal display rate, the relative playback point of s i increases by 0.05 seconds per second.</p><p>We can represent the process of synchronization of streams by a synchronization tree, which can be defined as follows.</p><p>stream-merging problem is by: (1) partitioning the streams of the same video object into disjoint sets such that all the streams in each set can be merged into a single stream without any stream terminations and (2) applying a static stream-merging algorithm to merge the streams in each set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.</head><p>A synchronization tree T is a tree in which the root node represents the final stream resulting from synchronization of n (original) streams, the leaf nodes represent the n (original) streams, s 1 , . . . , s n , and each internal node represents a stream derived from the synchronization of its child nodes (streams).</p><p>Let C s (t) be the I/O bandwidth demand (in bits/s) of stream s at time t. If stream s has been discarded at time t due to merging with another stream, then C s (t ) = 0 ∀t &gt; t. Then, we can define the cost of a synchronization tree as follows.</p><p>Definition 5. The cost of a synchronization tree T , corresponding to a set of n (original) streams, {s 1 , . . . , s n }, is defined as</p><formula xml:id="formula_2">cost(T ) = n i=1 P 0 C si (t) dt ,</formula><p>where P is the time required for the synchronization.</p><p>As will become more apparent in Sect. 3, our goal of solving the static stream-merging problem will translate into the goal of constructing an optimum synchronization tree. Definition 6. A synchronization tree T is said to be optimal if cost(T ) ≥ cost(T ) ∀ synchronization trees T with leaves s 1 , . . . , s n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Complexity of static stream merging</head><p>In this section, we characterize the properties of an optimal synchronization tree as well as propose an efficient algorithm for solving the static stream-merging problem, based on the idea of constructing a synchronization tree. We restrict the class of algorithms considered in this section, to the algorithms with the following property: once a decision to merge two streams has been made, their display rates remain unchanged until the completion of the merging process.</p><p>In an optimal synchronization tree, the leading stream s 1 is always slowed down by a fraction of ∆ -and the trailing stream s n is always sped up by a fraction of ∆ + . The synchronization process completes when the trailing stream and the leading stream are synchronized. Hence, we have the following lemma.</p><p>Lemma 1. The time, P , to synchronize the set of streams {s 1 , . . . , s n } is</p><formula xml:id="formula_3">ps 1 (0) -ps n (0) ∆++∆- .</formula><p>Proof. At any time t ∈ [0, P ], the trailing stream s n has a display rate of (1 + ∆ + )× the normal display rate, and the leading stream s 1 has a display rate of (1 -∆ -)× the normal display rate. Hence, the trailing stream and the leading stream move towards each other at a rate of ∆ + + ∆ - seconds per each second of display. Therefore, it takes</p><formula xml:id="formula_4">P = ps 1 (0) -ps n (0) ∆++∆-</formula><p>seconds to synchronize all the streams. Lemma 2. An optimal synchronization tree is a binary tree.</p><p>Proof. From Definition 4, each internal node, including the root of the tree, has at least two children. Suppose there exists an optimal cost tree T which contains a node with three children s a , s b , and s c . Without loss of generality, we assume that r sa (t) &lt; r s b (t) &lt; r sc (t). This situation is illustrated in Fig. <ref type="figure">1a</ref>. Let the display rates of s a , s b , and s c be S a , S b , and S c , respectively. Note that S a &gt; S b &gt; S c ≥ S min , because the three streams are merged at the same time. Let the I/O bandwidths of s a , s b , and s c be C a , C b , and C c , respectively. Let P 1 be the time of synchronization of streams in T 1 . The cost of subtree T 1 , covering s a , s b , and s c in Fig. <ref type="figure">1a</ref>, is</p><formula xml:id="formula_5">P 1 (C a + C c ) + P 1 C b ,</formula><p>where We can now show that a subtree T 2 with a cost lower than that of T 1 can be constructed to cover s a , s b , and s c by synchronizing streams s a and s b first <ref type="bibr" target="#b3">4</ref> , followed by synchronization of streams s a and s c . In this case, the display rate of s b is S min . This situation is illustrated in Fig. <ref type="figure">1b</ref>. Let P 2 be the synchronization time of s a and s b . Since s a and s b are merged first, P 2 &lt; P 1 . The cost of subtree T 2 , covering s a , s b , and s c in Fig. <ref type="figure">1b</ref>, is</p><formula xml:id="formula_6">C min ≤ C b ≤ C max .</formula><formula xml:id="formula_7">P 1 (C a + C c ) + P 2 C min .</formula><p>The first term represents the I/O cost for merging s a and s c , while the second term indicates the I/O cost for merging s b . Since C min ≤ C b and P 2 &lt; P 1 , the cost of subtree T 2 is less than that of subtree T 1 . Therefore, the synchronization tree in Fig. <ref type="figure">1b</ref> has a lower cost than the synchronization tree in Fig. <ref type="figure">1a</ref>. Hence, an optimal tree cannot have a node with three children. Similarly, we can show that an optimal tree cannot have a node with four or more children by merging streams in a pair-wise manner. The result follows.</p><p>The cost of stream synchronization depends on the order in which the streams are synchronized. For example, suppose ∆ + = ∆ -= 0.05, C n = C min = C max = 1.5 Mbits/s, and there are four streams s 1 , s 2 , s 3 , and s 4 , where p s1 (0) = 15 s, p s2 (0) = 9.5 s, p s3 (0) = 5.5 s, and p s4 (0) = 0 s. Two possible synchronization trees T 1 and T 2 are shown in Fig. <ref type="figure">2</ref>. T 1 is an optimal synchronization tree; it synchronizes s 1 and s 2 at time t = 55, s 3 and s 4 at time t = 55, and all streams at time t = 150. Hence, cost(T 1 ) = (55 + 55 + 150 + 150) × 1.5 Mbits = 615 Mbits. T 2 synchronizes s 2 and s 3 at time t = 40, s 2 and s 4 at time t = 95, and all streams at t = 150. Hence, cost(T 2 ) = (40 + 95 + 150 + 150) × 1.5 Mbits = 652.5 Mbits. Note that, if we were given a slightly different input, e.g., one where p s2 (0) and p s3 (0) are 8 s and 7 s, respectively, then T 2 would be the optimal tree, at a cost of 585 Mbits.</p><p>From the above example, it should be clear that the shape of an optimal synchronization tree depends on the initial values of the playback points of all streams. Thus, we have to consider how the remaining streams will be synchronized when making a choice of a pair of adjacent streams to be synchronized. Consider constructing the synchronization tree by choosing one pair of nodes (to merge) at a time, starting with the leaf nodes and working our way up. Then we would have n -1 possible pairs of streams from which to choose the first time, n -2 possible pairs of streams from which to choose the second time, and n -i -1 possible pairs of streams from which to choose the i-th time. Therefore, there are (n -1)! non-unique binary synchronization trees <ref type="bibr" target="#b4">5</ref> . Due to the inter-dependence between choices of pairs of streams to merge and a large number of possible ways to build a synchronization tree, it would be difficult or impossible to find an efficient algorithm which finds an optimal synchronization tree for all possible inputs. Thus, we concentrate on simple heuristic algorithms.</p><p>To simplify our discussion in the remainder of this section, we assume that ∆ + = ∆ -= ∆. For 2 ≤ i ≤ n, let lif e(s i ) be the period between time 0 and the time when the resources used by s i are released due to merging with another stream. Let lif e(s 1 ) be the synchronization time of the set of n streams, {s 1 , . . . , s n }. Definition 7. The time cost of a synchronization tree T, corresponding to the set of n streams, {s 1 , . . . , s n }, is defined as</p><formula xml:id="formula_8">time(T ) = n i=1 lif e(s i ). Lemma 3. Given a synchronization tree T , time(T )C min ≤ cost(T ) ≤ time(T )C max Proof. Since ∀i(1 ≤ i ≤ n), C min ≤ C si (t) ≤ C max for t ∈ [0, P ], n i=1 lif e(s i ) × C min ≤ n i=1 P 0 C si (t) dt ≤ n i=1 lif e(s i ) × C max</formula><p>The result follows.</p><p>Theorem 1. An upper bound on the time cost of a synchronization tree with the minimum time cost for the set of streams {s 1 , . . . , s n } is equal to (log 2 (n) + 1)P , for all n ≥ 2, where P = ps 1 (0) -ps n (0) 2∆</p><p>.</p><p>Proof. We use mathematical induction to prove the theorem. Let P (n) be "the minimum time cost of synchronizing a set of n streams {s 1 , . . . , s n } is less than or equal to (log 2 (n) + 1)P , where P = ps 1 (0) -ps n (0) 2∆</p><p>."</p><p>Basis step. For n = 2, it takes P = ps 1 (0) -ps 2 (0) 2∆ s to synchronize the streams. Hence, the time cost = 2P = (log 2 (2) + 1)P . Hence, P (n) is true for n = 2.</p><p>Inductive step. Assume P (n) is true for n ≤ k for some positive integer k ≥ 2. For n = k + 1, we divide the streams into two groups S 1 and S 2 such that ∀s ∈ S 1 , p s (0) &lt; Since D 1 log 2 (n 1 ) ≥ 0 and D 2 log 2 (n 2 ) ≥ 0, we have time(T ) ≤ P + (P 1 + D 1 )(log 2 (n 1 ) + 1)</p><formula xml:id="formula_9">+(P 2 + D 2 )(log 2 (n 2 ) + 1)</formula><p>.</p><formula xml:id="formula_10">By P 2 = D 1 + P 1 = D 2 + P 2 , time(T ) ≤ P + P 2 (log 2 (n 1 ) + 1) + P 2 (log 2 (n 2 ) + 1) ⇒ time(T ) ≤ P + P 2 (log 2 (n 1 × n 2 ) + 2) .</formula><p>Since</p><formula xml:id="formula_11">n 1 + n 2 = k + 1, n 1 × n 2 has the maximum value when n 1 = n 2 = k+1 2 . Therefore, time(T ) ≤ P + P 2 (log 2 ( (k + 1) 2 2 2 ) + 2) ⇒ time(T ) ≤ (log 2 (k + 1) + 1)P . Thus, P (n) is true for n = k + 1.</formula><p>Corollary 1. The cost of an optimal synchronization tree corresponding to streams s 1 , . . . , s n is not greater than P (log 2 (n) + 1)C max , where P = ps 1 (0)-ps n (0) 2∆</p><p>.</p><p>Proof. The result follows from Theorem 1 and Lemma 3.</p><p>Using the proof of Theorem 1, we can construct a recursive algorithm for finding a synchronization tree which has a time cost not greater than (log 2 (n) + 1)P . This recursive algorithm is used by the function BuildSyncTree, which is given below. (The function returns the root of the synchronization tree.) </p><formula xml:id="formula_12">n i=2 log(i)) = O(n log(n)).</formula><p>Let K be the set of all possible sets of n streams with the same synchronization time P , where an element in K is characterized by the initial relative playback points of the n streams. In other words, since the time cost and the synchronization cost of n streams depend only on the relative playback points of those streams, we do not need to make a distinction between two sets of streams with identical initial relative playback points. Theorem 3. Let S = {s 1 , . . . , s n } be a set of n streams, where S ∈ K and S has the largest optimal time cost among the elements of K . Then the time cost of a synchronization tree with the minimum time cost, corresponding to S, is greater than or equal to P log 2 (n), where P = ps 1 (0)-ps n (0) 2∆ for all n ≥ 2.</p><p>Proof. Let P (n) be "the minimum time cost of synchronization of streams s 1 , . . . , s n is at least nτ log 2 (n) for some input where τ = ps 1 (0)-ps n (0)</p><formula xml:id="formula_13">2(n-1)∆ ." For n = 2, P (n) is true. Assume P (n) is true for n ≤ k for some positive integer k ≥ 2. For n = k + 1, we choose s 1 , . . . , s n such that ∀0 ≤ i ≤ n -1, p si (0) -p si+1 (0) = d for some positive real number d &gt; 0.</formula><p>Let T be a synchronization tree for s 1 , . . . , s n . Let T 1 and T 2 be the subtrees of T . Let n 1 and n 2 be the number of streams that are covered by T 1 and T 2 , respectively. We have</p><formula xml:id="formula_14">n 1 + n 2 = k + 1, τ = d 2∆ .</formula><p>By Lemma 1, the streams of T 1 and the streams of T 2 will be synchronized at time t = (n 1 -1)τ and t = (n 2 -1)τ , respectively, and all streams will be synchronized at time t = kτ . Therefore, the remaining lifetime of the stream at the root of T 1 , after merging all streams in T 1 , and the remaining lifetime of the stream at the root of T 2 , after merging all streams in T 2 , are kτ -(n 1 -1)τ and kτ -(n 2 -1)τ , respectively. Thus,</p><formula xml:id="formula_15">time(T ) = kτ -(n 1 -1)τ + kτ -(n 2 -1)τ +time(T 1 ) + time(T 2 ) ⇒ time(T ) ≥ (k + 1)τ + n 1 log 2 (n 1 )τ +n 2 log 2 (n 2 )τ (by n 1 + n 2 = k + 1 and inductive hypothesis) . Let F (x) = x log 2 (x) + (n-x) log 2 (n-x) for 1 ≤ x ≤ n-1</formula><p>where n ≥ 2 is a constant.</p><formula xml:id="formula_16">dF (x) dx = log 2 (x) -log 2 (n -x) For x = n 2 , dF (x) dx = 0. For x &gt; n 2 , dF (x) dx &gt; 0.</formula><p>For x &lt; n 2 , dF (x) dx &lt; 0. Hence, F (x) is minimum when x = n 2 or F (x) ≥ n(log 2 (n) -1). Letting x = n 1 and n = k + 1, we have:</p><formula xml:id="formula_17">time(T ) ≥ (k + 1)τ + F ( k+1 2 )τ ⇒ time(T ) ≥ (k + 1)τ + (k + 1)(log 2 (k + 1) -1)τ ⇒ time(T ) ≥ (k + 1) log 2 (k + 1)τ ⇒ P (n) is true for n = k + 1 .</formula><p>By mathematical induction, P (n) is true for all positive integers n ≥ 2. Therefore, time(T ) ≥ n log 2 (n)τ ≥ P log 2 (n). The result of the theorem follows as the time cost in the worst case is greater than or equal to the time cost in the case described above.</p><p>Corollary 2. The cost of an optimal synchronization tree corresponding to the set of streams {s 1 , . . . , s n } is greater than or equal to P log 2 (n)C min for some input where P = ps 1 (0)-ps n (0) 2∆</p><p>.</p><p>Proof. By Theorem 3, there exists some input such that if T is the synchronization tree with the minimum time cost, then time(T ) ≥ P log 2 (n) .</p><p>Let T be an optimal synchronization tree. We have</p><formula xml:id="formula_18">P log 2 (n) ≤ time(T ) ≤ time(T ) ⇒ P log 2 (n)C min ≤ time(T )C min ⇒ P log 2 (n)C min ≤ time(T )C min ≤ cost(T ) (by Lemma 3) .</formula><p>Recall that K is the set of all possible sets of n streams with the same synchronization time P , where an element in K is characterized by the initial relative playback points of the n streams. Then we have the following corollary.</p><p>Corollary 3. Let S ∈ K be the set of n streams with the largest optimal synchronization cost among the elements of K ; then S satisfies the following condition:</p><formula xml:id="formula_19">P log 2 (n)C min ≤ the optimal synchronization cost of S ≤ P (log 2 (n) + 1)C max .</formula><p>Proof. The result follows from Corollary 1 and Corollary 2.</p><p>Note that the upper and lower bounds diverge logarithmically, so the bounds on the worst case cost are tight.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Dynamic stream-merging algorithms</head><p>In a VOD system, a stream is initiated for an object when a new request for that object arrives, and it is removed from the system when the stream reaches the end of the object's display. Therefore, we have to consider the dynamic streammerging problem in order to optimize the I/O demand reduction resulting from the stream-merging approach. Thus, in this section, we describe several dynamic stream-merging algorithms. We consider a class of dynamic stream-merging algorithms which make speed adjustments when one of the following two types of events occurs: arrival or merge.</p><p>An arrival event corresponds to an initiation of a new I/O stream. A merge event corresponds to a merge of two I/O streams.</p><p>The dynamic stream-merging problem is much more complex than the static stream-merging problem. When an event occurs, an algorithm which minimizes the I/O demand must consider many factors, such as, the request arrival process and the current playback points of the existing streams. Complex stochastic modeling and optimization would be required to find the best way to merge the streams corresponding to requests for the same object.</p><p>However, we can find a good heuristic for solving the dynamic stream-merging problem by making use of an algorithm constructed for solving the static stream-merging problem. More specifically, we can break down a dynamic stream-merging problem into several smaller static streammerging problems. The basic idea is to partition the streams of the same video object into disjoint sets such that the streams in each set can be merged into a single stream before any of the streams in this set terminate (due to reaching the end of an object's display). One possible partitioning approach is to group the streams according to their arrival times such that all the streams in the same group have arrived within a time period, called the catch-up window. We use the term 'window-based' stream-merging algorithm to refer to a dynamic stream-merging algorithm that partitions streams into disjoint sets using a catch-up window. In the remainder of this section, we present several dynamic merging algorithms, whose performance is analyzed and compared in Sects. 5 and 6, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Baseline algorithm</head><p>This is the normal situation. When a request arrives, there is no attempt to adjust the display rates, i.e., all requests are assigned the normal display rate, and there are no merging events in the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Equal-Split algorithm</head><p>This algorithm partitions I/O streams into groups using a catch-up window. For each group of streams, algorithm BuildSyncTree is used to find a way to merge the streams in the group. The streams are partitioned into groups such that the period between the arrivals of any two streams in the same group is bounded by W seconds, where W is the size of the catch-up window. (If the offline approach to speed alteration is used (see Sect. 1), then the value of W should be chosen to strike a balance between the additional disk storage required and the resulting I/O demand reduction. Section 6.2 discusses this tradeoff in more detail, and Fig. <ref type="figure">9</ref> illustrates it.) The partitioning of I/O streams is done as follows. If a stream s arrives at time t and there does not exist a group of streams such that the arrival time of the leading stream (the group leader) is less than t -W , then s becomes the leader of a new group. All streams which arrive in the period between time t and t + W belong to this new group. The term current group refers to the group of streams that has been created most recently. The details of the algorithm Equal-Split are given below. The size of a catch-up window, i.e., W , is a tuning parameter of the window-based algorithms. Note that there are limitations on the actual value of W ; thus we proceed by deriving the maximum possible value of W . The time required to merge the leading stream and the trailing stream in some group must be less than the remaining lifetime of the leading stream. Note that the leading stream is at most (1 -∆ -)W seconds ahead of the trailing stream, because the leading stream moves at a speed of (1 -∆ -)S n until all streams have been merged. Hence, if L is the normal playback time of a video object, then</p><formula xml:id="formula_20">(1 -∆ -)W ∆ + + ∆ - ≤ L -(1 -∆ -)W 1 -∆ - , or W ≤ (∆ + + ∆ -)L (1 + ∆ + )(1 -∆ -)</formula><p>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Brute-force algorithm</head><p>This algorithm is the same as the Equal-Split algorithm, except that it finds an optimal synchronization tree for the streams in each group by evaluating all the possible synchronization trees. As mentioned in Sect. 3, given a group of n streams, we can construct (n-1)! (corresponding) nonunique binary synchronization trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Offline brute-force algorithm</head><p>This algorithm is the same as the brute-force algorithm, except that it knows the arrival times of requests a priori, and hence it performs better than the online brute-force algorithm and the Equal-Split algorithm. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Performance analysis</head><p>In this section, we present performance analysis of the stream-merging algorithms described in Sect. 4, using the mean total I/O demand, on a storage server, as the measure of performance. We define the following notation to be used in the derivations of this section. All analysis is done with respect to a particular video object. Finally, we assume that the request arrival process is Poisson.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L</head><p>= normal playback time of a video object λ = mean request arrival rate t a = random variable representing the time between successive I/O stream initiations W a = size of a catch-up window for algorithm a (note that we have already defined W in Sect. 4) BW a = mean total I/O bandwidth demand under algorithm a (bits/s) Since the request arrival process is Poisson with rate λ, the probability density function of t a is f ta (x) = λe -λx for x ≥ 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Analysis of the baseline algorithm</head><p>There is no merging of streams in the baseline algorithm. Thus, the mean total bandwidth demand under this algorithm is the product of the average number of streams that are active simultaneously and the normal display bandwidth. Hence, the expected I/O demand is</p><formula xml:id="formula_21">BW b = λLC n .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Analysis of the Equal-Split algorithm</head><p>The behavior of the Equal-Split algorithm is such that each group of streams is statistically identical. We can therefore analyze the mean I/O demand for one such group of streams (and then use the results to compute the mean I/O demand for the system). Consider Fig. <ref type="figure" target="#fig_2">4</ref>, which depicts a system with n streams.</p><p>Let d(w, k) and B(w, k) be the mean time between arrivals of s i and s i+k-1 and the mean I/O cost (in bits) of merging streams s i , . . . , s i+k-1 , respectively, given that (a) exactly k streams have arrived in a period of w time units, (b) stream s i has arrived at the beginning of the period, and (c) streams s i+1 , . . . , s i+k-1 have arrived during this period. Given that k streams have arrived in a catch-up window of length w, d(w, k) is the mean time between the arrivals of the leading and the trailing streams in this set of k streams, and B(w, k) is the mean I/O cost (in bits) of merging these k streams. Hence, d(W es , n) and B(W es , n) are the mean time between arrivals of s 1 and s n and the mean I/O cost of merging streams s 1 , . . . , s n , respectively. d(w, k) can be expressed as</p><formula xml:id="formula_22">d(w, k) = k -1 k w if k &gt; 1 .</formula><p>At this point we can derive B(w, k). When k = 2, two streams, s i and s i+1 , are merged into one stream. Since s i has a display rate of S min = (1 -∆ -)S n before the merge and the time between arrivals of s i and s i+1 is d(w, 2), p si (t) -p si+1 (t) = (1 -∆ -)d(w, 2) when the merge begins at time t. Then the cost of merging s i and s i+1 , B(w, 2), is equal to d(w, 2)( (1+∆+)Cmin ∆++∆-</p><formula xml:id="formula_23">+ (1-∆-)Cmax</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>∆++∆-</head><p>). When k &gt; 2, let i + 1 be the number of streams covered by the left subtree of the root of the synchronization tree. The probability that the left subtree covers i + 1 streams is given by the following binomial distribution,</p><formula xml:id="formula_24">2 -(k-2) (k -2)! (k -2 -i)!i! , where 0 ≤ i ≤ k -2 .</formula><p>By taking the products of this probability and the corresponding I/O cost and then summing over all possible cases, we can derive the value of B(w, k), which can be expressed as</p><formula xml:id="formula_25">B(w, k) =                        d(w, 2)(U 1 + U 2 ) i f k = 2, 2 -(k-2) { k-3 i=1 C k-2 i [B( d(w,k) 2 , i + 1) +B( d(w,k) 2 , k -i -1)+ (d(w, k) -d( d(w,k) 2 , i + 1))U 1 +(d(w, k) -d( d(w,k) 2 , k -i -1))U 2 ]+ (2d(w, k) -d( d(w,k) 2 , k -1))(U 1 + U 2 ) +2B( d(w,k) 2 , k -1)} if k &gt; 2,</formula><p>where</p><formula xml:id="formula_26">U 1 = (1+∆+)Cmin ∆++∆-, U 2 = (1-∆-)Cmax ∆++∆-</formula><p>, and</p><formula xml:id="formula_27">C k i = k! (k-i)!i! . Since, B(w, k) = B(1, k)w, we can express B(w, k) as B(w, k) = wB (k) ,</formula><p>where</p><formula xml:id="formula_28">B (k) =                U1+U2 2 if k = 2. k-1 k2 k-2 { 1 2 k-3 i=1 C k-2 i [B (i + 1) +B (k -1 -i) + i+2 i+1 U 1 + k-i k-i-1 U 2 ]+ 3k-2 2(k-1) (U 1 + U 2 ) + B (k -1)} if k &gt; 2.</formula><p>Since B (k) can be solved recursively, we can compute B(w, k). Let BW n es be the mean total I/O cost for the n streams in Fig. <ref type="figure" target="#fig_2">4</ref>. Then, BW n es can be expressed as follows.</p><formula xml:id="formula_29">BW n es =    W es C min + [L -(1 -∆ -)W es ]C n if n = 1 B(W es , n) + [L -(1-∆-)d(Wes,n) ∆++∆- ]C n if n ≥ 2</formula><p>Since a new group of streams is initiated when a request arrives after the end of the catch-up window of the previous group and is terminated when the new catch-up window expires, the mean time between initiations of two consecutive groups is W es +1/λ. The expected I/O demand for algorithm Equal-Split is the product of the initiation rate of groups of streams and the mean total I/O cost of a group; this expected I/O demand can be expressed as</p><formula xml:id="formula_30">BW es = 1 W es + 1/λ ∞ n=0 (λW es ) n e -λWes</formula><p>n! BW n+1 es .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Validation of analytic result</head><p>In conclusion of this section, we validate our (approximate) analysis of algorithm Equal-Split by comparing it with results obtained through simulation. The performance measure which we consider is the percentage reduction of (or improvement in) the average bandwidth requirement of a system, due to algorithm Equal-Split, as compared to the baseline algorithm. Figure <ref type="figure">5</ref> shows the percentage bandwidth improvement for several different catch-up windows. The curves in Fig. <ref type="figure">5</ref> indicate that the analytic results match the simulation results closely (for most cases we have considered). Therefore, the analytic results should be sufficient for the performance evaluation of the algorithm under different catch-up windows and arrival rates. Note however, that the difference between analytic results and simulation results becomes larger when the length of the catch-up window is maximum (in this case, when W a = 12 min). This is due to the fact that, in the analysis of Sect. 5.2, we assumed that the arrival times of all streams in the same group are known a priori, and thus the synchronization tree can be constructed according to the arrival times of all the streams in the group <ref type="bibr" target="#b5">6</ref> .</p><p>The error caused by this assumption increases as the number of requests in the group increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Performance of merging algorithms</head><p>In this section, we compare the performance of the Equal-Split algorithm, the brute-force algorithm, the offline bruteforce algorithm, and two algorithms proposed in [5]. In [5], the authors proposed the odd-even, simple, and greedy algorithms. The odd-even algorithm attempts to reduce I/O demand by at most 50%. The basic idea behind the odd-even algorithm is to pair up and merge two consecutive streams whenever possible. The simple algorithm merges streams in a group by slowing down the leading stream of the group and accelerating all streams trailing the leader. In the greedy algorithm, adjacent streams are merged until no further merging of streams is possible. (It is basically a recursive application of the odd-even algorithm.) We have evaluated the <ref type="bibr" target="#b5">6</ref> That is, assuming that arrival times of all streams in the same group are known a priori results in the assumption that merging decisions are never "reversed". This is not the case in algorithm Equal-Split, where it is possible to "waste" some effort, because some merging decisions may be "reversed" as a result of new arrivals. performance of the merging algorithms by computer simulation, because we do not have the analytic results for the brute-force and the offline brute-force algorithms <ref type="bibr" target="#b6">7</ref> . The maximum possible catch-up window (for the cases discussed in this section) is W a = 12 min, when the normal display time of a video object is 120 min and ∆ + = ∆ -= 0.05. We have evaluated the performance of the algorithms for the maximum catch-up window (W a = 12 min), a catch-up window of medium length (W a = 6 min), and a relatively short catch-up window (W a = 2 min). The performance of each stream-merging algorithm was measured as the percentage reduction of (or improvement in) the average bandwidth requirement of a system, as compared to the baseline algorithm. The values of the parameters used in the simulations are given in Table <ref type="table" target="#tab_3">1</ref>. The stream arrival process was modeled as a Poisson process. The results are presented with 95% confidence intervals where the length of each confidence interval is bounded by 0.1%. Figures <ref type="figure">6</ref><ref type="figure">7</ref><ref type="figure">8</ref>show the performance results for the maximum possible catch-up window W a = 12 min, W a = 6 min, and W a = 2 min, respectively <ref type="bibr" target="#b7">8</ref> .</p><p>Because of the extremely long computation time (O((n-1)!)) of algorithm Brute-force, the simulation results for this algorithm could not be obtained for high arrival rates, at least not within 480 h of CPU time when W es was between 6 min and 12 min.</p><p>The online brute-force, Equal-Split, and greedy algorithms achieve a high I/O demand reduction at high arrival rates. The brute-force and Equal-Split algorithms can result in reductions in I/O demand of more than 80% when the mean inter-arrival time is 0.5 min and of more than 30% at relatively low arrival rates <ref type="bibr" target="#b8">9</ref> . The results in Figs. <ref type="figure">6</ref><ref type="figure">7</ref><ref type="figure">8</ref>show that algorithm Equal-Split outperforms the odd-even and greedy algorithms in all cases. With a catch-up window of 12 min and the mean inter-arrival times of 0.5 to 10 min, algorithm Equal-Split outperforms the odd-even algorithm by 28% to 70%, and it outperforms the greedy algorithm by 5-20%.</p><p>The (online) brute-force algorithm performs only slightly better than the Equal-Split algorithm in all cases for which  it was possible to compute performance results. Indeed, the performance difference of the two algorithms is under 1%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Offline brute-force algorithm</head><p>We evaluated the performance of the offline brute-force algorithm for several different catch-up windows. Tables <ref type="table" target="#tab_4">2</ref><ref type="table" target="#tab_5">3</ref><ref type="table" target="#tab_6">4</ref>show the percentage bandwidth improvement of the Equal-Split, brute-force, and offline brute-force algorithms for 12-, 6-, and 2-min catch-up windows, respectively. Note that we can only obtain the performance of the (online) brute-force and the offline brute-force algorithms for low-to-medium arrival rates because of the extremely long computation time of the algorithms. We ran the simulations on a Sun Sparc 2000 workstation with 20 processors. We parallelized the procedure for searching for the optimal synchronization tree to harness the power of 20 processors. Each table entry marked with 'NA' corresponds to a case in which a simulation run could not be completed within 480 h of CPU time.</p><p>Since the offline brute-force algorithm has perfect knowledge of arrival times of requests, it performs better than the Equal-Split algorithm and the online brute-force algorithm <ref type="bibr" target="#b9">10</ref> . However, for low-to-medium arrival rates, it performs only slightly better than its online counterpart, brute-force algorithm, or the Equal-Split algorithm. Also, the online (or offline) brute-force algorithm can perform slightly better than the Equal-Split algorithm when the window length is 2 min and the mean inter-arrival time is 0.5 min.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Limited merging</head><p>The alteration of display rates can be implemented by storing replicas of a video object for display rates (1 -∆ -)S n and (1 + ∆ + )S n . If replication of data is used to perform display rate alteration, then we need to consider the amount of additional disk space that would be necessary to store the replicated data. Note that replicated data for speed-up and slow-down is required while the streams in a group are being merged and is not required after the streams in a group have been merged into a single stream. A smaller amount of additional storage is required for a smaller catch-up window, because the amount of replicated data grows with the time required to merge all streams in a group and hence grows with the length of the catch-up window. On the other hand, the larger the catch-up window, the greater the opportunity for I/O bandwidth demand reduction. Thus, there is a tradeoff between the increase in storage requirements and the reduction in I/O bandwidth demand.</p><p>We have investigated the performance of algorithm Equal-Split under different lengths of catch-up windows. The results are shown in Fig. <ref type="figure">9</ref>. Given fairly small mean interarrival times, most of the reduction in I/O demand can be achieved using fairly small catch-up windows. This implies that most of the reduction in I/O demand can be achieved with only a small amount of storage overhead. For example, when the mean inter-arrival time is 0.5 min and the catchup window is 1 min long, the reduction in I/O demand is 64.58%, as compared to 82.88% when using the maximum possible catch-up window. However, the corresponding increase in disk storage (for 120 min video) would be ≈ 235 MB or 17% of the size of a video object for the 1-min catchup window and ≈ 2.7 GB or 200% of the size of a video object for the maximum possible catch-up window.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>In summary, we have formalized the static stream-merging problem, which minimizes the cost of merging a set of n streams, corresponding to requests for the same object, into a single stream, given that it is possible to merge all n streams. Our cost model is general and can be applied to many different architectures of VOD systems. The time required to merge a set of streams depends only on the initial difference of the playback points of the trailing and the leading streams in that set (Lemma 1), the maximum fraction of the display rate by which a stream can be sped up, and the maximum fraction of the display rate by which a stream can be slowed down. We have also proposed an efficient heuristic algorithm (BuildSyncTree), which requires O(n log(n)) comparisons and finds a stream-merging order with an I/O cost not higher than P (log 2 (n) + 1)C max , for n &gt; 1, where P = ps 1 (0)-ps n (0) 2∆</p><p>is the time required to merge all n streams in a set and C max is the bandwidth requirement of the maximum display rate. Based on algorithm BuildSyncTree, we have proposed a heuristic algorithm, Equal-Split, for solving the dynamic stream-merging problem. Although the offline brute-force algorithm (also introduced in the context of dynamic stream-merging) has perfect knowledge of request arrival times and can find an optimal way to merge each group of streams of the same object which have arrived in a catch-up window, simulation results indicate that the performance of the Equal-Split algorithm is very close to that of the offline brute-force algorithm <ref type="bibr" target="#b10">11</ref> .</p><p>Moreover, we have shown that the optimum cost of merging n streams, in the static merging problem, is not greater than P (log 2 (n) + 1)C max (Corollary 1). Algorithm Equal-Split partitions the streams of the same video object into disjoint sets using a catch-up window of length W seconds and calls Algorithm BuildSyncTree to merge the streams in each set. The playback points of the leading stream and the trailing stream of a set of streams differ by at most (1 -∆)W when the trailing stream arrives to the system <ref type="bibr" target="#b11">12</ref> . Hence, the total I/O cost of a set of n streams<ref type="foot" target="#foot_12">13</ref> is not greater than P (log 2 (n)+1)C max +(L-P )C n +nW C max , where P = (1-∆)W 2∆ ≤ L and L is the normal display time of the video. Therefore, the total I/O cost of a set of n streams is not greater than (P log 2 (n) + L)C max + nW C max ≤ (log 2 (n)+1)LC max + 2∆ (1+∆)(1-∆) nLC max . Thus, the total I/O cost of the set of n streams is reduced by at least a factor of nCn {log 2 (n)+1+ 2∆ (1+∆)(1-∆) n}Cmax . The savings in I/O bandwidth are substantial even for a small number of streams.</p><p>The cost/benefit tradeoff considered in this paper is the balance between the reduction in I/O bandwidth demand and the amount of storage overhead required for each video, i.e., we should only apply the stream-merging approach to a request for a given video when the benefit due to the I/O bandwidth demand reduction is greater than the cost of the storage overhead. Note that, in our algorithms, we have considered merging of requests for a single object, without considering how that affects requests for other objects. i.e., we have treated the I/O bandwidth resource allocated for servicing requests for one object independently of servicing requests for other objects. In practice, these are not independent; the I/O bandwidth demand of a pair of streams in the process of being merged could be larger than in the case where no attempts at merging are made, depending on the relative values of C min and C max . Therefore, merging of two streams corresponding to requests for one object could deprive requests for another object of the necessary bandwidth. However, we expect this effect to be quite small, since the deviation from the normal display rate is only a few percent, and thus we expect the difference between C min and C max to be small. Further work is required to either prove that there is an efficient algorithm for finding an optimal way to merge streams, both in the case of the static and the dynamic stream-merging problems, or prove that the problem of finding an optimal way to merge streams is in NP.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>The first term indicates the I/O cost for merging s a and s c , while the second term indicates the I/O cost for merging s b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 .Fig. 2 .Fig. 3 .</head><label>223</label><figDesc>Fig. 1a,b. The left tree contains a node with three children. The right tree reduces the cost by synchronizing the streams in a pair-wise manner Fig. 2. The left and right binary trees are T 1 and T 2 respectively Fig. 3. Synchronization tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Synchronization tree for n streams under algorithm Equal-Split</figDesc><graphic coords="9,43.65,30.49,162.00,118.44" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .Fig. 6 .Fig. 7 .Fig. 8 .Fig. 9 .</head><label>56789</label><figDesc>Fig. 5. Validation of analysis of algorithm Equal-Split Fig. 6. Performance of merging algorithms when Wa = 12 min Fig. 7. Performance of merging algorithms when Wa = 6 min Fig. 8. Performance of merging algorithms when Wa = 2 min Fig. 9. Algorithm Equal-Split</figDesc><graphic coords="11,43.65,55.92,497.70,630.27" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="6,43.65,31.31,509.77,208.83" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>the normal display rate, S n , and the fastest display rate, S max = (1 + ∆ + )S n ; the corresponding I/O bandwidths are C min , C n , and C max , respectively. The relative values of C min , C n , and C max depend on the display rate alteration technique used. We restrict the rest of the discussion in this paper to the class of display rate alteration approaches where ∀S ∈ [S min , S max ], C min ≤ the I/O bandwidth corresponding to display rate S ≤ C max .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Given a set of n streams, {s 1 , . . . , s n }, algorithm BuildSyncTree requires O(n log(n)) comparisons to find a synchronization tree corresponding to these n streams. Proof. Represent the set of streams by an array of n elements sorted in the descending order of the initial values of playback points. In the worst case, each call to function BuildSyncTree splits the set of streams S into a set containing only a single stream and another set containing | S | -1 streams. Using binary search, we can locate the split point of S in O(log(| S |)) comparisons. Therefore, in the worst case, the number of comparisons is O(</figDesc><table><row><cell>p s (0) + p s (0) 2 p s (0) + p s (0) 2 left child of t := BuildSyncTree(S 1 ); S 2 := {s ∈ S | ps(0) ≥</cell><cell>}; };</cell></row><row><cell>right child of t := BuildSyncTree(S 2 );</cell><cell></cell></row><row><cell>end</cell><cell></cell></row><row><cell>else</cell><cell></cell></row><row><cell>begin</cell><cell></cell></row><row><cell>left child of t := NULL;</cell><cell></cell></row><row><cell>right child of t := NULL;</cell><cell></cell></row><row><cell>stream of t := the stream in S;</cell><cell></cell></row><row><cell>end;</cell><cell></cell></row><row><cell>return(t);</cell><cell></cell></row><row><cell>end</cell><cell></cell></row><row><cell>Theorem 2.</cell><cell></cell></row></table><note><p>function BuildSyncTree(set of streams S): tree node pointer var set of streams S 1 , S 2 ; stream s , s ; tree node pointer t; begin t := new(tree node); if | S | &gt; 1 then begin s := first stream of S; s := last stream of S; S 1 := {s ∈ S | ps(0) &lt;</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 .</head><label>1</label><figDesc>Values of parameters used in simulation</figDesc><table><row><cell>Parameter</cell><cell>Value</cell></row><row><cell>L</cell><cell>120 min</cell></row><row><cell>S min</cell><cell>28.5 frames/s</cell></row><row><cell>Sn</cell><cell>30 frames/s</cell></row><row><cell>Smax</cell><cell>31.5 frames/s</cell></row><row><cell>∆+</cell><cell>0.05</cell></row><row><cell>∆ -</cell><cell>0.05</cell></row><row><cell>C min</cell><cell>1.425 Mbits/s</cell></row><row><cell>Cn</cell><cell>1.5 Mbits/s</cell></row><row><cell>Cmax</cell><cell>1.575 Mbits/s</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 .</head><label>2</label><figDesc>Bandwidth improvement when Wa = 12 min</figDesc><table><row><cell>Mean inter-arrival</cell><cell cols="3">Bandwidth improvement (%)</cell></row><row><cell>time (min)</cell><cell>Offline brute-force</cell><cell>Brute-force</cell><cell>Equal-Split</cell></row><row><cell>0.5</cell><cell>NA</cell><cell>NA</cell><cell>82.88</cell></row><row><cell>1.0</cell><cell>NA</cell><cell>NA</cell><cell>73.96</cell></row><row><cell>2.0</cell><cell>NA</cell><cell>63.00</cell><cell>62.37</cell></row><row><cell>4.0</cell><cell>52.59</cell><cell>49.42</cell><cell>49.17</cell></row><row><cell>8.0</cell><cell>38.04</cell><cell>35.74</cell><cell>35.66</cell></row><row><cell>10.0</cell><cell>33.58</cell><cell>31.58</cell><cell>31.53</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 .</head><label>3</label><figDesc>Bandwidth improvement when Wa = 6 min</figDesc><table><row><cell>Mean inter-arrival</cell><cell cols="3">Bandwidth improvement (%)</cell></row><row><cell>time (min)</cell><cell>Offline brute-force</cell><cell>Brute-force</cell><cell>Equal-Split</cell></row><row><cell>0.5</cell><cell>NA</cell><cell>NA</cell><cell>83.16</cell></row><row><cell>1.0</cell><cell>NA</cell><cell>74.57</cell><cell>74.06</cell></row><row><cell>2.0</cell><cell>63.82</cell><cell>62.19</cell><cell>62.00</cell></row><row><cell>4.0</cell><cell>49.05</cell><cell>47.91</cell><cell>47.87</cell></row><row><cell>8.0</cell><cell>34.05</cell><cell>33.34</cell><cell>33.32</cell></row><row><cell>10.0</cell><cell>29.50</cell><cell>28.90</cell><cell>28.90</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 .</head><label>4</label><figDesc>Bandwidth improvement when Wa = 2 min</figDesc><table><row><cell>Mean inter-arrival</cell><cell cols="3">Bandwidth improvement (%)</cell></row><row><cell>time (min)</cell><cell>Offline brute-force</cell><cell>Brute-force</cell><cell>Equal-Split</cell></row><row><cell>0.5</cell><cell>76.46</cell><cell>75.84</cell><cell>75.82</cell></row><row><cell>1.0</cell><cell>62.87</cell><cell>62.43</cell><cell>62.40</cell></row><row><cell>2.0</cell><cell>46.59</cell><cell>46.42</cell><cell>46.29</cell></row><row><cell>4.0</cell><cell>31.00</cell><cell>30.82</cell><cell>30.82</cell></row><row><cell>8.0</cell><cell>18.56</cell><cell>18.46</cell><cell>18.46</cell></row><row><cell>10.0</cell><cell>15.35</cell><cell>15.27</cell><cell>15.27</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We give a more precise definition of "time expansion" and "time compression" of video objects in Sect</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>. 2.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>For the remainder of the paper, we use the terms "synchronizing" and "merging" interchangeably.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>The assumption of infinite display time of a video object is used to prevent any stream termination due to reaching the end of an object's display. In later sections, we will show that one way to solve the dynamic</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>The resources used by s b are released after it has been merged with sa.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>The trees are not unique, because the same binary tree can be constructed in two or more different ways (i.e., corresponding to two or more different sequences of stream merges).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>It appears, from the graphs reported in<ref type="bibr" target="#b4">[5]</ref>, that the simple algorithm performs worse than the other two algorithms presented in the same paper, at least for the Poisson arrival process. Hence, we do not include the simple algorithm in our comparison.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>We have modified the original odd-even and greedy algorithms in<ref type="bibr" target="#b4">[5]</ref> such that Wa is a tuning parameter of the algorithms rather than something that is computed by the algorithm itself, as was defined in<ref type="bibr" target="#b4">[5]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>We refer to the cases for which it was possible to compute performance results.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>Note that the offline brute-force does not necessarily minimize the I/O cost for the dynamic stream-merging problem.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>Note that the offline brute-force does not necessarily minimize the I/O cost for the dynamic stream-merging problem.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>The display rate of the leading stream is S min before all the streams in the set are merged.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_12"><p>Recall that the definition of the static merging problem guarantees that it is possible to merge all n streams into a single stream. When the solution to the static merging problem, Equal-Split, is used to construct a solution to the dynamic merging algorithm, the actual value of n depends on the inter-arrival distribution as well as on the size of the catch-up window, W .</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgements. The research done by S.W. Lau and J.C.S. Lui was supported in part by the UGC Earmarked Grant and the Direct Research Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Channel Coding for Digital HDTV Terrestrial Broadcasting</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">W</forename><surname>Beakley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans Broadcasting</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="137" to="140" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Staggered Stripping in Multimedia Information Systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Berson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghandeharizadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Muntz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOD Conference</title>
		<imprint>
			<biblScope unit="page" from="79" to="90" />
			<date type="published" when="1994">1994</date>
			<pubPlace>Minneapolis, Minnesota</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Channel Allocation under Batching and VCR Control in Movie-on-Demand Servers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Dan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shahabuddin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sitaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
	<note type="report_type">IBM Research Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Buffer Management for Continuous Media Sharing in Multimedia Database System</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kamath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towsley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramamritham</surname></persName>
		</author>
		<idno>TR:4-11</idno>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
		<respStmt>
			<orgName>University of Massachusetts</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Reducing I/O demands in Video-On-Demand Storage Servers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Golubchik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jcs</forename><surname>Lui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">R</forename><surname>Muntz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIG-METRICS/PERFORMANCE &apos;95 Conference</title>
		<meeting>the ACM SIG-METRICS/PERFORMANCE &apos;95 Conference<address><addrLine>Ottawa, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-05">1995. May</date>
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">MPEG: A Video Compression Standard for Multimedia Applications</title>
		<author>
			<persName><forename type="first">Le</forename><surname>Gall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun ACM</title>
		<imprint>
			<biblScope unit="page" from="46" to="58" />
			<date type="published" when="1991-04">1991. April</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Cost-effective Near-line Storage Server for Multimedia System</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jcs</forename><surname>Lui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11 th International Conference on Data Engineering</title>
		<meeting>the 11 th International Conference on Data Engineering<address><addrLine>Taipei, Taiwan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-03">1995. March</date>
			<biblScope unit="page" from="449" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Novel Video-On-Demand Storage Architecture for Supporting Constant Frame Rate with Variable Bit Rate Retrieval</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jcs</forename><surname>Lui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Workshop on Network and Operating System Support for Digital Audio and Video</title>
		<meeting>the 5th International Workshop on Network and Operating System Support for Digital Audio and Video<address><addrLine>New Hampshire</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-04">1995. April</date>
			<biblScope unit="page" from="316" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scheduling and Replacement Policies for a Hierarchical Multimedia Storage Server</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jcs</forename><surname>Lui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Multimedia Japan 96, International Symposium on Multimedia Systems</title>
		<meeting>Multimedia Japan 96, International Symposium on Multimedia Systems<address><addrLine>Yokohama, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-03-18">1996. March 18-22</date>
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Low-cost Storage Server for Movie on Demand Databases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ozden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Biliris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Silberschaz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Very Large Databases</title>
		<meeting>the 20th International Conference on Very Large Databases<address><addrLine>Santiago, Chile</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="594" to="605" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Buffer Management for Video Database Systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Rotem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11 th International Conference on Data Engineering</title>
		<meeting>the 11 th International Conference on Data Engineering<address><addrLine>Taipei, Taiwan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-03">1995. March</date>
			<biblScope unit="page" from="439" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Siu-Wah Lau received his B.Sc. and M.Phil. in Computer Science from the University of Hong Kong in 1988 and 1991, respectively. He received his M.Sc. in Computer Science from UCLA in 1993. Currently, he is a PhD candidate in the Department of</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Vin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">V</forename><surname>Rangan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">His research interests include distributed multimedia systems and computer networks</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="153" to="164" />
		</imprint>
		<respStmt>
			<orgName>Computer Science and Engineering, The Chinese University of Hong Kong</orgName>
		</respStmt>
	</monogr>
	<note>Designing a Multi-User HDTV Storage Server</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">He then joined a team in IBM Almaden/San Jose in the research and development of a parallel I/O architecture project. In 1993, he joined the Department of Computer Science and Engineering in the Chinese University of Hong Kong. His research interests are in parallel and distributed systems design, distributed multimedia systems, parallel I/O architectures, communication networks, mobile computing and performance evaluation theory. Leana Golubchik is an Assistant Professor in the Department of Computer Science, University of Maryland at College Park; from Fall of 1995 until Summer of 1997, she was an Assistant Professor in the Department of Computer Science at Columbia University. Her current research interests are in multimedia information systems, highperformance I/O, and computer systems modeling and performance evaluation. Dr. Golubchik received her BS in Computer Science and Engineering in 1989, her MS in Computer Science in 1992, and her PhD in Computer Science in 1995</title>
		<author>
			<persName><forename type="first">Chi-Shing</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><surname>Lui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Science from UCLA in 1991</title>
		<imprint>
			<publisher>Los Angeles (UCLA)</publisher>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
	<note>She is a member of Tau Beta Pi, the Assocation for Computing Machinery, and the IEEE</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
